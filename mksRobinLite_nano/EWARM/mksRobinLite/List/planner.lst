###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.1.114/W32 for ARM         07/May/2021  14:21:32
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\planner.cpp
#    Command line =  
#        -f C:\Users\PLT\AppData\Local\Temp\EWF1B7.tmp
#        (C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\planner.cpp
#        -D USE_HAL_DRIVER -D STM32F103xE -D MKS_ROBIN -D MARLIN -D __arm__ -D
#        USE_MKS_WIFI --preprocess=s
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List -lC
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List -lA
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List
#        --diag_suppress Pa050 -o
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.1\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Inc\ -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Src\ -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/Inc\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/CMSIS/Include\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/STM32MKS-3dPrinter\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/Common\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/l6474\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/MotorControl\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/u8glib_arm_v1.17/src\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/arduino\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/arduino/avr\
#        -I C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Inc/Logo\ -Om --c++
#        --no_exceptions --no_rtti -I "D:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.1\arm\CMSIS\Core\Include\" -I "D:\Program
#        Files (x86)\IAR Systems\Embedded Workbench
#        8.1\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List\planner.lst
#    Object file  =  
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\Obj\planner.o
#
###############################################################################

C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\planner.cpp
      1          /**
      2           * Marlin 3D Printer Firmware
      3           * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
      4           *
      5           * Based on Sprinter and grbl.
      6           * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
      7           *
      8           * This program is free software: you can redistribute it and/or modify
      9           * it under the terms of the GNU General Public License as published by
     10           * the Free Software Foundation, either version 3 of the License, or
     11           * (at your option) any later version.
     12           *
     13           * This program is distributed in the hope that it will be useful,
     14           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     15           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     16           * GNU General Public License for more details.
     17           *
     18           * You should have received a copy of the GNU General Public License
     19           * along with this program.  If not, see <http://www.gnu.org/licenses/>.
     20           *
     21           */
     22          
     23          /**
     24           * planner.cpp
     25           *
     26           * Buffer movement commands and manage the acceleration profile plan
     27           *
     28           * Derived from Grbl
     29           * Copyright (c) 2009-2011 Simen Svale Skogsrud
     30           *
     31           * The ring buffer implementation gleaned from the wiring_serial library by David A. Mellis.
     32           *
     33           *
     34           * Reasoning behind the mathematics in this module (in the key of 'Mathematica'):
     35           *
     36           * s == speed, a == acceleration, t == time, d == distance
     37           *
     38           * Basic definitions:
     39           *   Speed[s_, a_, t_] := s + (a*t)
     40           *   Travel[s_, a_, t_] := Integrate[Speed[s, a, t], t]
     41           *
     42           * Distance to reach a specific speed with a constant acceleration:
     43           *   Solve[{Speed[s, a, t] == m, Travel[s, a, t] == d}, d, t]
     44           *   d -> (m^2 - s^2)/(2 a) --> estimate_acceleration_distance()
     45           *
     46           * Speed after a given distance of travel with constant acceleration:
     47           *   Solve[{Speed[s, a, t] == m, Travel[s, a, t] == d}, m, t]
     48           *   m -> Sqrt[2 a d + s^2]
     49           *
     50           * DestinationSpeed[s_, a_, d_] := Sqrt[2 a d + s^2]
     51           *
     52           * When to start braking (di) to reach a specified destination speed (s2) after accelerating
     53           * from initial speed s1 without ever stopping at a plateau:
     54           *   Solve[{DestinationSpeed[s1, a, di] == DestinationSpeed[s2, a, d - di]}, di]
     55           *   di -> (2 a d - s1^2 + s2^2)/(4 a) --> intersection_distance()
     56           *
     57           * IntersectionDistance[s1_, s2_, a_, d_] := (2 a d - s1^2 + s2^2)/(4 a)
     58           *
     59           */
     60          #include "Marlin.h"

    #define SDSS   18
            ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\pins_MKS_ROBIN_LITE.h",161  Warning[Pa181]: 
          incompatible redefinition of macro "SDSS" (declared at line 62)

  #define UNUSED(x) ((void)(x))
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_def.h",87  Warning[Pa181]: 
          incompatible redefinition of macro "UNUSED" (declared at line 88 of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marl
          in\macros.h")

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp long CORESIGN(long)
   \                     _ZN32_INTERNAL_11_planner_cpp_planner8CORESIGNEl: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable13_1
   \        0x4   0xF891 0x1058      LDRB     R1,[R1, #+88]
   \        0x8   0x22A8             MOVS     R2,#+168
   \        0xA   0x4211             TST      R1,R2
   \        0xC   0xD000             BEQ.N    ??CORESIGN_0
   \        0xE   0x4240             RSBS     R0,R0,#+0
   \                     ??CORESIGN_0: (+1)
   \       0x10   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void MarlinSerial::write(char const *)
   \                     _ZN12MarlinSerial5writeEPKc: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4628             MOV      R0,R5
   \        0x8   0x.... 0x....      BL       strlen
   \        0xC   0x4602             MOV      R2,R0
   \        0xE   0xB2D2             UXTB     R2,R2
   \       0x10   0x4629             MOV      R1,R5
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0xE8BD 0x4038      POP      {R3-R5,LR}
   \       0x18   0x.... 0x....      B.W      BSP_UartIfQueueTxData

   \                                 In section .text, align 4
   \   __interwork __softfp void MarlinSerial::print(char const *)
   \                     _ZN12MarlinSerial5printEPKc: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4628             MOV      R0,R5
   \        0x8   0x.... 0x....      BL       strlen
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD013             BEQ.N    ??print_1
   \       0x10   0x480A             LDR.N    R0,??print_0
   \       0x12   0x7800             LDRB     R0,[R0, #+0]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD105             BNE.N    ??print_2
   \       0x18   0x4629             MOV      R1,R5
   \       0x1A   0x4620             MOV      R0,R4
   \       0x1C   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \       0x20   0x.... 0x....      B.W      _ZN12MarlinSerial5writeEPKc
   \                     ??print_2: (+1)
   \       0x24   0x4628             MOV      R0,R5
   \       0x26   0x.... 0x....      BL       strlen
   \       0x2A   0x4602             MOV      R2,R0
   \       0x2C   0x4629             MOV      R1,R5
   \       0x2E   0x2002             MOVS     R0,#+2
   \       0x30   0xE8BD 0x4038      POP      {R3-R5,LR}
   \       0x34   0x.... 0x....      B.W      package_to_wifi
   \                     ??print_1: (+1)
   \       0x38   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \       0x3A   0xBF00             Nop      
   \                     ??print_0:
   \       0x3C   0x....'....        DC32     from_wifi_flag

   \                                 In section .text, align 4
   \   __interwork __softfp void serialprintPGM(char const *)
   \                     _Z14serialprintPGMPKc: (+1)
   \        0x0   0x4601             MOV      R1,R0
   \        0x2   0x4805             LDR.N    R0,??serialprintPGM_0
   \        0x4   0x7800             LDRB     R0,[R0, #+0]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD102             BNE.N    ??serialprintPGM_1
   \        0xA   0x4804             LDR.N    R0,??serialprintPGM_0+0x4
   \        0xC   0x.... 0x....      B.W      _ZN12MarlinSerial5writeEPKc
   \                     ??serialprintPGM_1: (+1)
   \       0x10   0x4803             LDR.N    R0,??serialprintPGM_0+0x8
   \       0x12   0x.... 0x....      B.W      _ZN12MarlinSerial5printEPKc
   \       0x16   0xBF00             Nop      
   \                     ??serialprintPGM_0:
   \       0x18   0x....'....        DC32     from_wifi_flag
   \       0x1C   0x....'....        DC32     customizedSerial
   \       0x20   0x....'....        DC32     serial2

  #define PRINT_LED_PIN         PDout(2)
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\BSP\STM32MKS-3dPrinter\mks_fastio.h",14  Warning[Pa181]: 
          incompatible redefinition of macro "PRINT_LED_PIN" (declared at line
          146 of "C:\Users\PLT\Desktop\mksRobinLite_nano\Inc\main.h")
     61          
     62          #include "planner.h"

   \                                 In section .text, align 4
   \   __interwork __softfp uint8_t Planner::movesplanned()
   \                     _ZN7Planner12movesplannedEv: (+1)
   \        0x0   0x4903             LDR.N    R1,??movesplanned_0
   \        0x2   0x7808             LDRB     R0,[R1, #+0]
   \        0x4   0x7849             LDRB     R1,[R1, #+1]
   \        0x6   0x1A40             SUBS     R0,R0,R1
   \        0x8   0xF000 0x000F      AND      R0,R0,#0xF
   \        0xC   0x4770             BX       LR               ;; return
   \        0xE   0xBF00             Nop      
   \                     ??movesplanned_0:
   \       0x10   0x....'....        DC32     _ZN7Planner17block_buffer_headE

   \                                 In section .text, align 2
   \   __interwork __softfp void Planner::apply_leveling(float *)
   \                     _ZN7Planner14apply_levelingEPf: (+1)
   \        0x0   0xF100 0x0208      ADD      R2,R0,#+8
   \        0x4   0x1D01             ADDS     R1,R0,#+4
   \        0x6   0x.... 0x....      B.W      _ZN7Planner14apply_levelingERfS0_S0_

   \                                 In section .text, align 4
   \   __interwork __softfp bool Planner::blocks_queued()
   \                     _ZN7Planner13blocks_queuedEv: (+1)
   \        0x0   0x4804             LDR.N    R0,??blocks_queued_0
   \        0x2   0x7801             LDRB     R1,[R0, #+0]
   \        0x4   0x7840             LDRB     R0,[R0, #+1]
   \        0x6   0x4281             CMP      R1,R0
   \        0x8   0xD001             BEQ.N    ??blocks_queued_1
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0x4770             BX       LR
   \                     ??blocks_queued_1: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x4770             BX       LR               ;; return
   \       0x12   0xBF00             Nop      
   \                     ??blocks_queued_0:
   \       0x14   0x....'....        DC32     _ZN7Planner17block_buffer_headE

   \                                 In section .text, align 2
   \   __interwork __softfp int8_t Planner::next_block_index(int8_t)
   \                     _ZN7Planner16next_block_indexEa: (+1)
   \        0x0   0x1C40             ADDS     R0,R0,#+1
   \        0x2   0xF000 0x000F      AND      R0,R0,#0xF
   \        0x6   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp int8_t Planner::prev_block_index(int8_t)
   \                     _ZN7Planner16prev_block_indexEa: (+1)
   \        0x0   0x1E40             SUBS     R0,R0,#+1
   \        0x2   0xF000 0x000F      AND      R0,R0,#0xF
   \        0x6   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp float Planner::estimate_acceleration_distance(float const &, float const &, float const &)
   \                     _ZN7Planner30estimate_acceleration_distanceERKfS1_S1_: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4680             MOV      R8,R0
   \        0x6   0x460B             MOV      R3,R1
   \        0x8   0x4615             MOV      R5,R2
   \        0xA   0x6828             LDR      R0,[R5, #+0]
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0x12   0xD101             BNE.N    ??estimate_acceleration_distance_0
   \       0x14   0x4608             MOV      R0,R1
   \       0x16   0xE036             B.N      ??estimate_acceleration_distance_1
   \                     ??estimate_acceleration_distance_0: (+1)
   \       0x18   0xF8D3 0x9000      LDR      R9,[R3, #+0]
   \       0x1C   0x2402             MOVS     R4,#+2
   \       0x1E   0xF04F 0x567E      MOV      R6,#+1065353216
   \       0x22   0x4637             MOV      R7,R6
   \       0x24   0xE004             B.N      ??estimate_acceleration_distance_2
   \                     ??estimate_acceleration_distance_3: (+1)
   \       0x26   0x4648             MOV      R0,R9
   \       0x28   0x4649             MOV      R1,R9
   \       0x2A   0x.... 0x....      BL       __aeabi_fmul
   \       0x2E   0x4681             MOV      R9,R0
   \                     ??estimate_acceleration_distance_2: (+1)
   \       0x30   0x07E0             LSLS     R0,R4,#+31
   \       0x32   0xD504             BPL.N    ??estimate_acceleration_distance_4
   \       0x34   0x4638             MOV      R0,R7
   \       0x36   0x4649             MOV      R1,R9
   \       0x38   0x.... 0x....      BL       __aeabi_fmul
   \       0x3C   0x4607             MOV      R7,R0
   \                     ??estimate_acceleration_distance_4: (+1)
   \       0x3E   0x0864             LSRS     R4,R4,#+1
   \       0x40   0xD1F1             BNE.N    ??estimate_acceleration_distance_3
   \       0x42   0xF8D8 0x8000      LDR      R8,[R8, #+0]
   \       0x46   0x2402             MOVS     R4,#+2
   \       0x48   0xE004             B.N      ??estimate_acceleration_distance_5
   \                     ??estimate_acceleration_distance_6: (+1)
   \       0x4A   0x4640             MOV      R0,R8
   \       0x4C   0x4641             MOV      R1,R8
   \       0x4E   0x.... 0x....      BL       __aeabi_fmul
   \       0x52   0x4680             MOV      R8,R0
   \                     ??estimate_acceleration_distance_5: (+1)
   \       0x54   0x07E0             LSLS     R0,R4,#+31
   \       0x56   0xD504             BPL.N    ??estimate_acceleration_distance_7
   \       0x58   0x4630             MOV      R0,R6
   \       0x5A   0x4641             MOV      R1,R8
   \       0x5C   0x.... 0x....      BL       __aeabi_fmul
   \       0x60   0x4606             MOV      R6,R0
   \                     ??estimate_acceleration_distance_7: (+1)
   \       0x62   0x0864             LSRS     R4,R4,#+1
   \       0x64   0xD1F1             BNE.N    ??estimate_acceleration_distance_6
   \       0x66   0x4638             MOV      R0,R7
   \       0x68   0x4631             MOV      R1,R6
   \       0x6A   0x.... 0x....      BL       __aeabi_fsub
   \       0x6E   0x4604             MOV      R4,R0
   \       0x70   0x6829             LDR      R1,[R5, #+0]
   \       0x72   0xF04F 0x4080      MOV      R0,#+1073741824
   \       0x76   0x.... 0x....      BL       __aeabi_fmul
   \       0x7A   0x4601             MOV      R1,R0
   \       0x7C   0x4620             MOV      R0,R4
   \       0x7E   0xE8BD 0x43F4      POP      {R2,R4-R9,LR}
   \       0x82   0x.... 0x....      B.W      __aeabi_fdiv
   \                     ??estimate_acceleration_distance_1: (+1)
   \       0x86   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp float Planner::intersection_distance(float const &, float const &, float const &, float const &)
   \                     _ZN7Planner21intersection_distanceERKfS1_S1_S1_: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x4689             MOV      R9,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x461D             MOV      R5,R3
   \        0xC   0x6830             LDR      R0,[R6, #+0]
   \        0xE   0x2100             MOVS     R1,#+0
   \       0x10   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0x14   0xD101             BNE.N    ??intersection_distance_0
   \       0x16   0x4608             MOV      R0,R1
   \       0x18   0xE041             B.N      ??intersection_distance_1
   \                     ??intersection_distance_0: (+1)
   \       0x1A   0xF8D4 0xA000      LDR      R10,[R4, #+0]
   \       0x1E   0x2402             MOVS     R4,#+2
   \       0x20   0xF04F 0x577E      MOV      R7,#+1065353216
   \       0x24   0x46B8             MOV      R8,R7
   \       0x26   0xE004             B.N      ??intersection_distance_2
   \                     ??intersection_distance_3: (+1)
   \       0x28   0x4650             MOV      R0,R10
   \       0x2A   0x4651             MOV      R1,R10
   \       0x2C   0x.... 0x....      BL       __aeabi_fmul
   \       0x30   0x4682             MOV      R10,R0
   \                     ??intersection_distance_2: (+1)
   \       0x32   0x07E0             LSLS     R0,R4,#+31
   \       0x34   0xD504             BPL.N    ??intersection_distance_4
   \       0x36   0x4640             MOV      R0,R8
   \       0x38   0x4651             MOV      R1,R10
   \       0x3A   0x.... 0x....      BL       __aeabi_fmul
   \       0x3E   0x4680             MOV      R8,R0
   \                     ??intersection_distance_4: (+1)
   \       0x40   0x0864             LSRS     R4,R4,#+1
   \       0x42   0xD1F1             BNE.N    ??intersection_distance_3
   \       0x44   0xF8D9 0x9000      LDR      R9,[R9, #+0]
   \       0x48   0x2402             MOVS     R4,#+2
   \       0x4A   0xE004             B.N      ??intersection_distance_5
   \                     ??intersection_distance_6: (+1)
   \       0x4C   0x4648             MOV      R0,R9
   \       0x4E   0x4649             MOV      R1,R9
   \       0x50   0x.... 0x....      BL       __aeabi_fmul
   \       0x54   0x4681             MOV      R9,R0
   \                     ??intersection_distance_5: (+1)
   \       0x56   0x07E0             LSLS     R0,R4,#+31
   \       0x58   0xD504             BPL.N    ??intersection_distance_7
   \       0x5A   0x4638             MOV      R0,R7
   \       0x5C   0x4649             MOV      R1,R9
   \       0x5E   0x.... 0x....      BL       __aeabi_fmul
   \       0x62   0x4607             MOV      R7,R0
   \                     ??intersection_distance_7: (+1)
   \       0x64   0x0864             LSRS     R4,R4,#+1
   \       0x66   0xD1F1             BNE.N    ??intersection_distance_6
   \       0x68   0x6834             LDR      R4,[R6, #+0]
   \       0x6A   0xF04F 0x4080      MOV      R0,#+1073741824
   \       0x6E   0x4621             MOV      R1,R4
   \       0x70   0x.... 0x....      BL       __aeabi_fmul
   \       0x74   0x6829             LDR      R1,[R5, #+0]
   \       0x76   0x.... 0x....      BL       __aeabi_fmul
   \       0x7A   0x4641             MOV      R1,R8
   \       0x7C   0x.... 0x....      BL       __aeabi_fsub
   \       0x80   0x4639             MOV      R1,R7
   \       0x82   0x.... 0x....      BL       __aeabi_fadd
   \       0x86   0x4605             MOV      R5,R0
   \       0x88   0xF04F 0x4081      MOV      R0,#+1082130432
   \       0x8C   0x4621             MOV      R1,R4
   \       0x8E   0x.... 0x....      BL       __aeabi_fmul
   \       0x92   0x4601             MOV      R1,R0
   \       0x94   0x4628             MOV      R0,R5
   \       0x96   0xE8BD 0x47F0      POP      {R4-R10,LR}
   \       0x9A   0x.... 0x....      B.W      __aeabi_fdiv
   \                     ??intersection_distance_1: (+1)
   \       0x9E   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp float Planner::max_allowable_speed(float const &, float const &, float const &)
   \                     _ZN7Planner19max_allowable_speedERKfS1_S1_: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x4616             MOV      R6,R2
   \        0x8   0x680F             LDR      R7,[R1, #+0]
   \        0xA   0x2402             MOVS     R4,#+2
   \        0xC   0xF04F 0x587E      MOV      R8,#+1065353216
   \       0x10   0xE004             B.N      ??max_allowable_speed_0
   \                     ??max_allowable_speed_1: (+1)
   \       0x12   0x4638             MOV      R0,R7
   \       0x14   0x4639             MOV      R1,R7
   \       0x16   0x.... 0x....      BL       __aeabi_fmul
   \       0x1A   0x4607             MOV      R7,R0
   \                     ??max_allowable_speed_0: (+1)
   \       0x1C   0x07E0             LSLS     R0,R4,#+31
   \       0x1E   0xD504             BPL.N    ??max_allowable_speed_2
   \       0x20   0x4640             MOV      R0,R8
   \       0x22   0x4639             MOV      R1,R7
   \       0x24   0x.... 0x....      BL       __aeabi_fmul
   \       0x28   0x4680             MOV      R8,R0
   \                     ??max_allowable_speed_2: (+1)
   \       0x2A   0x0864             LSRS     R4,R4,#+1
   \       0x2C   0xD1F1             BNE.N    ??max_allowable_speed_1
   \       0x2E   0x6829             LDR      R1,[R5, #+0]
   \       0x30   0xF04F 0x4080      MOV      R0,#+1073741824
   \       0x34   0x.... 0x....      BL       __aeabi_fmul
   \       0x38   0x6831             LDR      R1,[R6, #+0]
   \       0x3A   0x.... 0x....      BL       __aeabi_fmul
   \       0x3E   0x4601             MOV      R1,R0
   \       0x40   0x4640             MOV      R0,R8
   \       0x42   0x.... 0x....      BL       __aeabi_fsub
   \       0x46   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \       0x4A   0x.... 0x....      B.W      sqrtf
     63          #include "stepper.h"
     64          #include "temperature.h"

   \                                 In section .text, align 4
   \   __interwork __softfp bool Temperature::tooColdToExtrude(uint8_t)
   \                     _ZN11Temperature16tooColdToExtrudeEh: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x4809             LDR.N    R0,??tooColdToExtrude_0
   \        0x4   0x7800             LDRB     R0,[R0, #+0]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD001             BEQ.N    ??tooColdToExtrude_1
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xBD02             POP      {R1,PC}
   \                     ??tooColdToExtrude_1: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x.... 0x....      BL       _ZN11Temperature9degHotendEh
   \       0x14   0x4905             LDR.N    R1,??tooColdToExtrude_0+0x4
   \       0x16   0x6809             LDR      R1,[R1, #+0]
   \       0x18   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x1C   0xD201             BCS.N    ??tooColdToExtrude_2
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0xBD02             POP      {R1,PC}
   \                     ??tooColdToExtrude_2: (+1)
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0xBD02             POP      {R1,PC}          ;; return
   \       0x26   0xBF00             Nop      
   \                     ??tooColdToExtrude_0:
   \       0x28   0x....'....        DC32     _ZN11Temperature18allow_cold_extrudeE
   \       0x2C   0x....'....        DC32     _ZN11Temperature16extrude_min_tempE

   \                                 In section .text, align 4
   \   __interwork __softfp float Temperature::degHotend(uint8_t)
   \                     _ZN11Temperature9degHotendEh: (+1)
   \        0x0   0x4801             LDR.N    R0,??degHotend_0
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return
   \        0x6   0xBF00             Nop      
   \                     ??degHotend_0:
   \        0x8   0x....'....        DC32     _ZN11Temperature19current_temperatureE

   \                                 In section .text, align 4
   \   __interwork __softfp float Temperature::degTargetHotend(uint8_t)
   \                     _ZN11Temperature15degTargetHotendEh: (+1)
   \        0x0   0x4801             LDR.N    R0,??degTargetHotend_0
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x.... 0x....      B.W      __aeabi_i2f
   \                     ??degTargetHotend_0:
   \        0x8   0x....'....        DC32     _ZN11Temperature18target_temperatureE

   \                                 In section .text, align 4
   \   __interwork __softfp void Temperature::setTargetHotend(float, uint8_t)
   \                     _ZN11Temperature15setTargetHotendEfh: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}

        target_temperature[HOTEND_INDEX] = celsius;
                                         ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\temperature.h",401  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \        0x2   0x.... 0x....      BL       __aeabi_f2iz
   \        0x6   0x4903             LDR.N    R1,??setTargetHotend_0
   \        0x8   0x6008             STR      R0,[R1, #+0]
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xE8BD 0x4002      POP      {R1,LR}
   \       0x10   0x.... 0x....      B.W      _ZN11Temperature21start_watching_heaterEh
   \                     ??setTargetHotend_0:
   \       0x14   0x....'....        DC32     _ZN11Temperature18target_temperatureE

        target_temperature_bed = celsius;
                               ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\temperature.h",408  Warning[Pa093]: 
          implicit conversion from floating point to integer
     65          #include "ultralcd.h"
     66          #include "language.h"
     67          
     68          
     69          
     70          //#if ENABLED(MESH_BED_LEVELING)
     71          #if 1 /*--mks cfg-- MESH_BED_LEVELING */
     72            #include "mesh_bed_leveling.h"

   \                                 In section .text, align 4
   \   __interwork __softfp bool mesh_bed_leveling::active()
   \                     _ZN17mesh_bed_leveling6activeEv: (+1)
   \        0x0   0x4802             LDR.N    R0,??active_0
   \        0x2   0x7800             LDRB     R0,[R0, #+0]
   \        0x4   0x0840             LSRS     R0,R0,#+1
   \        0x6   0xF000 0x0001      AND      R0,R0,#0x1
   \        0xA   0x4770             BX       LR               ;; return
   \                     ??active_0:
   \        0xC   0x....'....        DC32     _ZN17mesh_bed_leveling6statusE

   \                                 In section .text, align 4
   \   __interwork __softfp int8_t mesh_bed_leveling::cell_index_x(float const &)
   \                     _ZN17mesh_bed_leveling12cell_index_xERKf: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4681             MOV      R9,R0

        int8_t cx = (x - (MESH_MIN_X)) * (1.0 / (MESH_X_DIST));
                    ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",85  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \        0x6   0x4E20             LDR.N    R6,??cell_index_x_0
   \        0x8   0xF896 0x0098      LDRB     R0,[R6, #+152]
   \        0xC   0x.... 0x....      BL       __aeabi_ui2f
   \       0x10   0x4607             MOV      R7,R0
   \       0x12   0x68B0             LDR      R0,[R6, #+8]
   \       0x14   0x4639             MOV      R1,R7
   \       0x16   0x.... 0x....      BL       __aeabi_fadd
   \       0x1A   0x4680             MOV      R8,R0
   \       0x1C   0xF896 0x4060      LDRB     R4,[R6, #+96]
   \       0x20   0x4625             MOV      R5,R4
   \       0x22   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x26   0x4641             MOV      R1,R8
   \       0x28   0x.... 0x....      BL       __aeabi_fsub
   \       0x2C   0x.... 0x....      BL       __aeabi_f2d
   \       0x30   0x4682             MOV      R10,R0
   \       0x32   0x468B             MOV      R11,R1
   \       0x34   0x6970             LDR      R0,[R6, #+20]
   \       0x36   0x4639             MOV      R1,R7
   \       0x38   0x.... 0x....      BL       __aeabi_fsub
   \       0x3C   0x4641             MOV      R1,R8
   \       0x3E   0x.... 0x....      BL       __aeabi_fsub
   \       0x42   0x4606             MOV      R6,R0
   \       0x44   0x1E68             SUBS     R0,R5,#+1
   \       0x46   0x.... 0x....      BL       __aeabi_i2f
   \       0x4A   0x4601             MOV      R1,R0
   \       0x4C   0x4630             MOV      R0,R6
   \       0x4E   0x.... 0x....      BL       __aeabi_fdiv
   \       0x52   0x.... 0x....      BL       __aeabi_f2d
   \       0x56   0x4602             MOV      R2,R0
   \       0x58   0x460B             MOV      R3,R1
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0x490B             LDR.N    R1,??cell_index_x_0+0x4  ;; 0x3ff00000
   \       0x5E   0x.... 0x....      BL       __aeabi_ddiv
   \       0x62   0x4652             MOV      R2,R10
   \       0x64   0x465B             MOV      R3,R11
   \       0x66   0x.... 0x....      BL       __aeabi_dmul
   \       0x6A   0x.... 0x....      BL       __aeabi_d2iz
   \       0x6E   0x4601             MOV      R1,R0
   \       0x70   0xB249             SXTB     R1,R1
   \       0x72   0x2900             CMP      R1,#+0
   \       0x74   0xD501             BPL.N    ??cell_index_x_1
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0xE003             B.N      ??cell_index_x_2
   \                     ??cell_index_x_1: (+1)
   \       0x7A   0x1EAD             SUBS     R5,R5,#+2
   \       0x7C   0x428D             CMP      R5,R1
   \       0x7E   0xDA00             BGE.N    ??cell_index_x_2
   \       0x80   0x1EA0             SUBS     R0,R4,#+2
   \                     ??cell_index_x_2: (+1)
   \       0x82   0xB240             SXTB     R0,R0
   \       0x84   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \                     ??cell_index_x_0:
   \       0x88   0x....'....        DC32     mksCfg
   \       0x8C   0x3FF0'0000        DC32     0x3ff00000

   \                                 In section .text, align 4
   \   __interwork __softfp int8_t mesh_bed_leveling::cell_index_y(float const &)
   \                     _ZN17mesh_bed_leveling12cell_index_yERKf: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4681             MOV      R9,R0

        int8_t cy = (y - (MESH_MIN_Y)) * (1.0 / (MESH_Y_DIST));
                    ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",90  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \        0x6   0x4E20             LDR.N    R6,??cell_index_y_0
   \        0x8   0xF896 0x0098      LDRB     R0,[R6, #+152]
   \        0xC   0x.... 0x....      BL       __aeabi_ui2f
   \       0x10   0x4607             MOV      R7,R0
   \       0x12   0x68F0             LDR      R0,[R6, #+12]
   \       0x14   0x4639             MOV      R1,R7
   \       0x16   0x.... 0x....      BL       __aeabi_fadd
   \       0x1A   0x4680             MOV      R8,R0
   \       0x1C   0xF896 0x4061      LDRB     R4,[R6, #+97]
   \       0x20   0x4625             MOV      R5,R4
   \       0x22   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x26   0x4641             MOV      R1,R8
   \       0x28   0x.... 0x....      BL       __aeabi_fsub
   \       0x2C   0x.... 0x....      BL       __aeabi_f2d
   \       0x30   0x4682             MOV      R10,R0
   \       0x32   0x468B             MOV      R11,R1
   \       0x34   0x69B0             LDR      R0,[R6, #+24]
   \       0x36   0x4639             MOV      R1,R7
   \       0x38   0x.... 0x....      BL       __aeabi_fsub
   \       0x3C   0x4641             MOV      R1,R8
   \       0x3E   0x.... 0x....      BL       __aeabi_fsub
   \       0x42   0x4606             MOV      R6,R0
   \       0x44   0x1E68             SUBS     R0,R5,#+1
   \       0x46   0x.... 0x....      BL       __aeabi_i2f
   \       0x4A   0x4601             MOV      R1,R0
   \       0x4C   0x4630             MOV      R0,R6
   \       0x4E   0x.... 0x....      BL       __aeabi_fdiv
   \       0x52   0x.... 0x....      BL       __aeabi_f2d
   \       0x56   0x4602             MOV      R2,R0
   \       0x58   0x460B             MOV      R3,R1
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0x490B             LDR.N    R1,??cell_index_y_0+0x4  ;; 0x3ff00000
   \       0x5E   0x.... 0x....      BL       __aeabi_ddiv
   \       0x62   0x4652             MOV      R2,R10
   \       0x64   0x465B             MOV      R3,R11
   \       0x66   0x.... 0x....      BL       __aeabi_dmul
   \       0x6A   0x.... 0x....      BL       __aeabi_d2iz
   \       0x6E   0x4601             MOV      R1,R0
   \       0x70   0xB249             SXTB     R1,R1
   \       0x72   0x2900             CMP      R1,#+0
   \       0x74   0xD501             BPL.N    ??cell_index_y_1
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0xE003             B.N      ??cell_index_y_2
   \                     ??cell_index_y_1: (+1)
   \       0x7A   0x1EAD             SUBS     R5,R5,#+2
   \       0x7C   0x428D             CMP      R5,R1
   \       0x7E   0xDA00             BGE.N    ??cell_index_y_2
   \       0x80   0x1EA0             SUBS     R0,R4,#+2
   \                     ??cell_index_y_2: (+1)
   \       0x82   0xB240             SXTB     R0,R0
   \       0x84   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \                     ??cell_index_y_0:
   \       0x88   0x....'....        DC32     mksCfg
   \       0x8C   0x3FF0'0000        DC32     0x3ff00000

        int8_t px = (x - (MESH_MIN_X) + 0.5 * (MESH_X_DIST)) * (1.0 / (MESH_X_DIST));
                    ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",95  Warning[Pa093]: 
          implicit conversion from floating point to integer

        int8_t py = (y - (MESH_MIN_Y) + 0.5 * (MESH_Y_DIST)) * (1.0 / (MESH_Y_DIST));
                    ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",100  Warning[Pa093]: 
          implicit conversion from floating point to integer

   \                                 In section .text, align 2
   \   __interwork __softfp float mesh_bed_leveling::calc_z0(float const &, float const &, float const &, float const &, float const &)
   \                     _ZN17mesh_bed_leveling7calc_z0ERKfS1_S1_S1_S1_: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x461C             MOV      R4,R3
   \        0x6   0x9D06             LDR      R5,[SP, #+24]
   \        0x8   0x6816             LDR      R6,[R2, #+0]
   \        0xA   0x680F             LDR      R7,[R1, #+0]
   \        0xC   0x6800             LDR      R0,[R0, #+0]
   \        0xE   0x4639             MOV      R1,R7
   \       0x10   0x.... 0x....      BL       __aeabi_fsub
   \       0x14   0x4680             MOV      R8,R0
   \       0x16   0x6828             LDR      R0,[R5, #+0]
   \       0x18   0x4631             MOV      R1,R6
   \       0x1A   0x.... 0x....      BL       __aeabi_fsub
   \       0x1E   0x4605             MOV      R5,R0
   \       0x20   0x6820             LDR      R0,[R4, #+0]
   \       0x22   0x4639             MOV      R1,R7
   \       0x24   0x.... 0x....      BL       __aeabi_fsub
   \       0x28   0x4601             MOV      R1,R0
   \       0x2A   0x4628             MOV      R0,R5
   \       0x2C   0x.... 0x....      BL       __aeabi_fdiv
   \       0x30   0x4641             MOV      R1,R8
   \       0x32   0x.... 0x....      BL       __aeabi_fmul
   \       0x36   0x4631             MOV      R1,R6
   \       0x38   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \       0x3C   0x.... 0x....      B.W      __aeabi_fadd

   \                                 In section .text, align 4
   \   __interwork __softfp float mesh_bed_leveling::get_z_mks(float const &, float const &)
   \                     _ZN17mesh_bed_leveling9get_z_mksERKfS1_: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x.... 0x....      BL       _ZN17mesh_bed_leveling12cell_index_xERKf
   \        0xC   0x4681             MOV      R9,R0
   \        0xE   0x4620             MOV      R0,R4
   \       0x10   0x.... 0x....      BL       _ZN17mesh_bed_leveling12cell_index_yERKf
   \       0x14   0x4605             MOV      R5,R0
   \       0x16   0x4819             LDR.N    R0,??get_z_mks_0
   \       0x18   0xEB00 0x1089      ADD      R0,R0,R9, LSL #+6
   \       0x1C   0xEB00 0x0785      ADD      R7,R0,R5, LSL #+2
   \       0x20   0x4817             LDR.N    R0,??get_z_mks_0+0x4
   \       0x22   0x1D01             ADDS     R1,R0,#+4
   \       0x24   0xEB01 0x0889      ADD      R8,R1,R9, LSL #+2
   \       0x28   0xEB00 0x0989      ADD      R9,R0,R9, LSL #+2
   \       0x2C   0xF107 0x0040      ADD      R0,R7,#+64
   \       0x30   0x9000             STR      R0,[SP, #+0]
   \       0x32   0x4643             MOV      R3,R8
   \       0x34   0x463A             MOV      R2,R7
   \       0x36   0x4649             MOV      R1,R9
   \       0x38   0x4630             MOV      R0,R6
   \       0x3A   0x.... 0x....      BL       _ZN17mesh_bed_leveling7calc_z0ERKfS1_S1_S1_S1_
   \       0x3E   0x9002             STR      R0,[SP, #+8]
   \       0x40   0xF107 0x0044      ADD      R0,R7,#+68
   \       0x44   0x9000             STR      R0,[SP, #+0]
   \       0x46   0x4643             MOV      R3,R8
   \       0x48   0x1D3A             ADDS     R2,R7,#+4
   \       0x4A   0x4649             MOV      R1,R9
   \       0x4C   0x4630             MOV      R0,R6
   \       0x4E   0x.... 0x....      BL       _ZN17mesh_bed_leveling7calc_z0ERKfS1_S1_S1_S1_
   \       0x52   0x9001             STR      R0,[SP, #+4]
   \       0x54   0x480B             LDR.N    R0,??get_z_mks_0+0x8
   \       0x56   0xA901             ADD      R1,SP,#+4
   \       0x58   0x9100             STR      R1,[SP, #+0]
   \       0x5A   0x1D01             ADDS     R1,R0,#+4
   \       0x5C   0xEB01 0x0385      ADD      R3,R1,R5, LSL #+2
   \       0x60   0xAA02             ADD      R2,SP,#+8
   \       0x62   0xEB00 0x0185      ADD      R1,R0,R5, LSL #+2
   \       0x66   0x4620             MOV      R0,R4
   \       0x68   0x.... 0x....      BL       _ZN17mesh_bed_leveling7calc_z0ERKfS1_S1_S1_S1_
   \       0x6C   0x4601             MOV      R1,R0
   \       0x6E   0x4806             LDR.N    R0,??get_z_mks_0+0xC
   \       0x70   0x6800             LDR      R0,[R0, #+0]
   \       0x72   0x.... 0x....      BL       __aeabi_fadd
   \       0x76   0xE8BD 0x83FE      POP      {R1-R9,PC}       ;; return
   \       0x7A   0xBF00             Nop      
   \                     ??get_z_mks_0:
   \       0x7C   0x....'....        DC32     _ZN17mesh_bed_leveling8z_valuesE
   \       0x80   0x....'....        DC32     _ZN17mesh_bed_leveling13index_to_xposE
   \       0x84   0x....'....        DC32     _ZN17mesh_bed_leveling13index_to_yposE
   \       0x88   0x....'....        DC32     _ZN17mesh_bed_leveling8z_offsetE
     73          #endif
     74          
     75          extern uint8_t cmd_queue_index_r_bak;
     76          

   \                                 In section .text, align 2, keep-with-next
     77          Planner planner;
   \   static __intrinsic __interwork __softfp void __sti__routine()
   \                     __sti__routine: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable13
   \        0x4   0x....             B.N      _ZN7PlannerC1Ev

   \                                 In section .bss, align 1
   \                     planner:
   \        0x0                      DS8 1
     78          
     79            // public:
     80          
     81          /**
     82           * A ring buffer of moves described in steps
     83           */

   \                                 In section .bss, align 4
     84          block_t Planner::block_buffer[BLOCK_BUFFER_SIZE];
   \                     _ZN7Planner12block_bufferE:
   \        0x0                      DS8 1344
     85          volatile uint8_t Planner::block_buffer_head = 0,           // Index of the next block to be pushed
     86                           Planner::block_buffer_tail = 0;
     87          
     88          float Planner::max_feedrate_mm_s[XYZE_N], // Max speeds in mm per second
     89                Planner::axis_steps_per_mm[XYZE_N],
     90                Planner::steps_to_mm[XYZE_N];
     91          
     92          #if ENABLED(DISTINCT_E_FACTORS)
     93            uint8_t Planner::last_extruder = 0;     // Respond to extruder change
     94          #endif
     95          /*--mks--*/
     96          unsigned long Planner::max_acceleration_steps_per_s2[XYZE_N],
     97                   	  Planner::max_acceleration_mm_per_s2[XYZE_N]; // Use M201 to override by software
     98          
     99          millis_t Planner::min_segment_time;
    100          float Planner::min_feedrate_mm_s,
    101                Planner::acceleration,         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX
    102                Planner::retract_acceleration, // Retract acceleration mm/s^2 filament pull-back and push-forward while standing still in the other axes M204 TXXXX
    103                Planner::travel_acceleration,  // Travel acceleration mm/s^2  DEFAULT ACCELERATION for all NON printing moves. M204 MXXXX
    104                Planner::max_jerk[XYZE],       // The largest speed change requiring no acceleration
    105                Planner::min_travel_feedrate_mm_s;
    106          
    107          //#if HAS_ABL
    108          #if 1
    109            bool Planner::abl_enabled = false; // Flag that auto bed leveling is enabled
    110          #endif
    111          
    112          //#if ABL_PLANAR
    113          #if 1
    114            matrix_3x3 Planner::bed_level_matrix; // Transform to compensate for bed level
    115          #endif
    116          
    117          #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
    118            float Planner::z_fade_height,
    119                  Planner::inverse_z_fade_height;
    120          #endif
    121          
    122          #if ENABLED(AUTOTEMP)
    123            float Planner::autotemp_max = 250,
    124                  Planner::autotemp_min = 210,
    125                  Planner::autotemp_factor = 0.1;
    126            bool Planner::autotemp_enabled = false;
    127          #endif
    128          
    129          #ifdef MKS_BUG_PRINTPAUSE
    130          	 uint16_t Planner::mksBugPrintPauseCnt=0;
    131          #endif
    132          
    133          
    134          // private:
    135          
    136          long Planner::position[NUM_AXIS] = { 0 };
    137          
    138          uint32_t Planner::cutoff_long;
    139          
    140          float Planner::previous_speed[NUM_AXIS],
    141                Planner::previous_nominal_speed;
    142          
    143          #if ENABLED(DISABLE_INACTIVE_EXTRUDER)
    144            uint8_t Planner::g_uc_extruder_last_move[EXTRUDERS] = { 0 };
    145          #endif
    146          
    147          #ifdef XY_FREQUENCY_LIMIT
    148            // Old direction bits. Used for speed calculations
    149            unsigned char Planner::old_direction_bits = 0;
    150            // Segment times (in Âµs). Used for speed calculations
    151            long Planner::axis_segment_time[2][3] = { {MAX_FREQ_TIME + 1, 0, 0}, {MAX_FREQ_TIME + 1, 0, 0} };
    152          #endif
    153          
    154          #if ENABLED(LIN_ADVANCE)
    155            float Planner::extruder_advance_k = LIN_ADVANCE_K,
    156                  Planner::advance_ed_ratio = LIN_ADVANCE_E_D_RATIO,
    157                  Planner::position_float[NUM_AXIS] = { 0 };
    158          #endif
    159          
    160          #if ENABLED(ULTRA_LCD)
    161            volatile uint32_t Planner::block_buffer_runtime_us = 0;
    162          #endif
    163          
    164          /**
    165           * Class and Instance Methods
    166           */
    167          

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp Planner::subobject Planner()
   \                     _ZN7PlannerC2Ev: (+1)
   \        0x0   0x....             B.N      _ZN7PlannerC1Ev

   \                                 In section .text, align 2, keep-with-next
    168          Planner::Planner() { init(); }
   \                     _ZN7PlannerC1Ev: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x.... 0x....      BL       _ZN7Planner4initEv
   \        0x8   0x4620             MOV      R0,R4
   \        0xA   0xBD10             POP      {R4,PC}          ;; return
    169          

   \                                 In section .text, align 2, keep-with-next
    170          void Planner::init() {
   \                     _ZN7Planner4initEv: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    171            block_buffer_head = block_buffer_tail = 0;
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable13_2
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x7060             STRB     R0,[R4, #+1]
   \        0xA   0x7020             STRB     R0,[R4, #+0]
    172            ZERO(position);
   \        0xC   0x4602             MOV      R2,R0
   \        0xE   0x2110             MOVS     R1,#+16
   \       0x10   0xF104 0x0034      ADD      R0,R4,#+52
   \       0x14   0x.... 0x....      BL       __aeabi_memset4
    173            #if ENABLED(LIN_ADVANCE)
    174              ZERO(position_float);
    175            #endif
    176            ZERO(previous_speed);
   \       0x18   0x2200             MOVS     R2,#+0
   \       0x1A   0x2110             MOVS     R1,#+16
   \       0x1C   0xF104 0x0064      ADD      R0,R4,#+100
   \       0x20   0x.... 0x....      BL       __aeabi_memset4
    177            previous_nominal_speed = 0.0;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x6760             STR      R0,[R4, #+116]
    178          //  #if ABL_PLANAR
    179          #if 1
    180              bed_level_matrix.set_to_identity();
   \       0x28   0x.... 0x....      LDR.W    R0,??DataTable13_3
   \       0x2C   0xE8BD 0x4010      POP      {R4,LR}
   \       0x30   0x.... 0x....      B.W      _ZN10matrix_3x315set_to_identityEv
    181            #endif
    182          }
    183          
    184          #define MINIMAL_STEP_RATE 120
    185          
    186          /**
    187           * Calculate trapezoid parameters, multiplying the entry- and exit-speeds
    188           * by the provided factors.
    189           */

   \                                 In section .text, align 4, keep-with-next
    190          void Planner::calculate_trapezoid_for_block(block_t* const block, const float &entry_factor, const float &exit_factor) {
   \                     _ZN7Planner29calculate_trapezoid_for_blockEP7block_tRKfS3_: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB084             SUB      SP,SP,#+16
   \        0x6   0x4604             MOV      R4,R0
   \        0x8   0x460D             MOV      R5,R1
   \        0xA   0x4616             MOV      R6,R2
    191            uint32_t initial_rate = ceil(block->nominal_rate * entry_factor),
                                           ^
Warning[Pa093]: implicit conversion from floating point to integer
   \        0xC   0x6BE0             LDR      R0,[R4, #+60]
   \        0xE   0x.... 0x....      BL       __aeabi_ui2f
   \       0x12   0x6829             LDR      R1,[R5, #+0]
   \       0x14   0x.... 0x....      BL       __aeabi_fmul
   \       0x18   0x.... 0x....      BL       ceilf
   \       0x1C   0x.... 0x....      BL       __aeabi_f2uiz
   \       0x20   0x4605             MOV      R5,R0
    192                     final_rate = ceil(block->nominal_rate * exit_factor); // (steps per second)
                                         ^
Warning[Pa093]: implicit conversion from floating point to integer
   \       0x22   0x6BE0             LDR      R0,[R4, #+60]
   \       0x24   0x.... 0x....      BL       __aeabi_ui2f
   \       0x28   0x6831             LDR      R1,[R6, #+0]
   \       0x2A   0x.... 0x....      BL       __aeabi_fmul
   \       0x2E   0x.... 0x....      BL       ceilf
   \       0x32   0x.... 0x....      BL       __aeabi_f2uiz
   \       0x36   0x4606             MOV      R6,R0
    193          
    194            // Limit minimal step rate (Otherwise the timer will overflow.)
    195            NOLESS(initial_rate, MINIMAL_STEP_RATE);
   \       0x38   0x2D78             CMP      R5,#+120
   \       0x3A   0xD200             BCS.N    ??calculate_trapezoid_for_block_0
   \       0x3C   0x2578             MOVS     R5,#+120
    196            NOLESS(final_rate, MINIMAL_STEP_RATE);
   \                     ??calculate_trapezoid_for_block_0: (+1)
   \       0x3E   0x2E78             CMP      R6,#+120
   \       0x40   0xD200             BCS.N    ??calculate_trapezoid_for_block_1
   \       0x42   0x2678             MOVS     R6,#+120
    197          
    198            int32_t accel = block->acceleration_steps_per_s2,
   \                     ??calculate_trapezoid_for_block_1: (+1)
   \       0x44   0xF8D4 0xB048      LDR      R11,[R4, #+72]
    199                    accelerate_steps = ceil(estimate_acceleration_distance(initial_rate, block->nominal_rate, accel)),
                                              ^
Warning[Pa093]: implicit conversion from floating point to integer
   \       0x48   0x4628             MOV      R0,R5
   \       0x4A   0x.... 0x....      BL       __aeabi_ui2f
   \       0x4E   0x4607             MOV      R7,R0
   \       0x50   0x9702             STR      R7,[SP, #+8]
   \       0x52   0x6BE0             LDR      R0,[R4, #+60]
   \       0x54   0x.... 0x....      BL       __aeabi_ui2f
   \       0x58   0x9000             STR      R0,[SP, #+0]
   \       0x5A   0x4658             MOV      R0,R11
   \       0x5C   0x.... 0x....      BL       __aeabi_i2f
   \       0x60   0x4680             MOV      R8,R0
   \       0x62   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \       0x66   0xAA01             ADD      R2,SP,#+4
   \       0x68   0x4669             MOV      R1,SP
   \       0x6A   0xA802             ADD      R0,SP,#+8
   \       0x6C   0x.... 0x....      BL       _ZN7Planner30estimate_acceleration_distanceERKfS1_S1_
   \       0x70   0x.... 0x....      BL       ceilf
   \       0x74   0x.... 0x....      BL       __aeabi_f2iz
   \       0x78   0x4681             MOV      R9,R0
    200                    decelerate_steps = floor(estimate_acceleration_distance(block->nominal_rate, final_rate, -accel)),
                                              ^
Warning[Pa093]: implicit conversion from floating point to integer
   \       0x7A   0x6BE0             LDR      R0,[R4, #+60]
   \       0x7C   0x.... 0x....      BL       __aeabi_ui2f
   \       0x80   0x9000             STR      R0,[SP, #+0]
   \       0x82   0x4630             MOV      R0,R6
   \       0x84   0x.... 0x....      BL       __aeabi_ui2f
   \       0x88   0x4682             MOV      R10,R0
   \       0x8A   0xF8CD 0xA004      STR      R10,[SP, #+4]
   \       0x8E   0xF1CB 0x0B00      RSB      R11,R11,#+0
   \       0x92   0x4658             MOV      R0,R11
   \       0x94   0x.... 0x....      BL       __aeabi_i2f
   \       0x98   0x9002             STR      R0,[SP, #+8]
   \       0x9A   0xAA02             ADD      R2,SP,#+8
   \       0x9C   0xA901             ADD      R1,SP,#+4
   \       0x9E   0x4668             MOV      R0,SP
   \       0xA0   0x.... 0x....      BL       _ZN7Planner30estimate_acceleration_distanceERKfS1_S1_
   \       0xA4   0x.... 0x....      BL       floorf
   \       0xA8   0x.... 0x....      BL       __aeabi_f2iz
    201                    plateau_steps = block->step_event_count - accelerate_steps - decelerate_steps;
   \       0xAC   0x6961             LDR      R1,[R4, #+20]
   \       0xAE   0xEBA1 0x0109      SUB      R1,R1,R9
   \       0xB2   0x1A08             SUBS     R0,R1,R0
    202          
    203            // Is the Plateau of Nominal Rate smaller than nothing? That means no cruising, and we will
    204            // have to use intersection_distance() to calculate when to abort accel and start braking
    205            // in order to reach the final_rate exactly at the end of this block.
    206            if (plateau_steps < 0) {
   \       0xB4   0x2800             CMP      R0,#+0
   \       0xB6   0xD51D             BPL.N    ??calculate_trapezoid_for_block_2
    207              accelerate_steps = ceil(intersection_distance(initial_rate, final_rate, accel, block->step_event_count));
                                      ^
Warning[Pa093]: implicit conversion from floating point to integer
   \       0xB8   0x9703             STR      R7,[SP, #+12]
   \       0xBA   0xF8CD 0xA008      STR      R10,[SP, #+8]
   \       0xBE   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \       0xC2   0x6960             LDR      R0,[R4, #+20]
   \       0xC4   0x.... 0x....      BL       __aeabi_ui2f
   \       0xC8   0x9000             STR      R0,[SP, #+0]
   \       0xCA   0x466B             MOV      R3,SP
   \       0xCC   0xAA01             ADD      R2,SP,#+4
   \       0xCE   0xA902             ADD      R1,SP,#+8
   \       0xD0   0xA803             ADD      R0,SP,#+12
   \       0xD2   0x.... 0x....      BL       _ZN7Planner21intersection_distanceERKfS1_S1_S1_
   \       0xD6   0x.... 0x....      BL       ceilf
   \       0xDA   0x.... 0x....      BL       __aeabi_f2iz
   \       0xDE   0x4681             MOV      R9,R0
    208              NOLESS(accelerate_steps, 0); // Check limits due to numerical round-off
   \       0xE0   0xF1B9 0x0F00      CMP      R9,#+0
   \       0xE4   0xD501             BPL.N    ??calculate_trapezoid_for_block_3
   \       0xE6   0xF04F 0x0900      MOV      R9,#+0
    209              accelerate_steps = min((uint32_t)accelerate_steps, block->step_event_count);//(We can cast here to unsigned, because the above line ensures that we are above zero)
   \                     ??calculate_trapezoid_for_block_3: (+1)
   \       0xEA   0x6960             LDR      R0,[R4, #+20]
   \       0xEC   0x4581             CMP      R9,R0
   \       0xEE   0xD300             BCC.N    ??calculate_trapezoid_for_block_4
   \       0xF0   0x4681             MOV      R9,R0
    210              plateau_steps = 0;
   \                     ??calculate_trapezoid_for_block_4: (+1)
   \       0xF2   0x2000             MOVS     R0,#+0
    211            }
    212          
    213            // block->accelerate_until = accelerate_steps;
    214            // block->decelerate_after = accelerate_steps+plateau_steps;
    215          
    216            CRITICAL_SECTION_START;  // Fill variables used by the stepper in a critical section
   \                     ??calculate_trapezoid_for_block_2: (+1)
   \       0xF4   0xB672             cpsid i
    217            if (!TEST(block->flag, BLOCK_BIT_BUSY)) { // Don't update variables if block is busy.
   \       0xF6   0x7861             LDRB     R1,[R4, #+1]
   \       0xF8   0x0709             LSLS     R1,R1,#+28
   \       0xFA   0xD407             BMI.N    ??calculate_trapezoid_for_block_5
    218              block->accelerate_until = accelerate_steps;
   \       0xFC   0xF8C4 0x9018      STR      R9,[R4, #+24]
    219              block->decelerate_after = accelerate_steps + plateau_steps;
   \      0x100   0xEB10 0x0909      ADDS     R9,R0,R9
   \      0x104   0xF8C4 0x901C      STR      R9,[R4, #+28]
    220              block->initial_rate = initial_rate;
   \      0x108   0x6425             STR      R5,[R4, #+64]
    221              block->final_rate = final_rate;
   \      0x10A   0x6466             STR      R6,[R4, #+68]
    222              #if ENABLED(ADVANCE)
    223                block->initial_advance = block->advance * sq(entry_factor);
    224                block->final_advance = block->advance * sq(exit_factor);
    225              #endif
    226            }
    227            CRITICAL_SECTION_END;
   \                     ??calculate_trapezoid_for_block_5: (+1)
   \      0x10C   0xB662             cpsie i
    228          }
   \      0x10E   0xB005             ADD      SP,SP,#+20
   \      0x110   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    229          
    230          // "Junction jerk" in this context is the immediate change in speed at the junction of two blocks.
    231          // This method will calculate the junction jerk as the euclidean distance between the nominal
    232          // velocities of the respective blocks.
    233          //inline float junction_jerk(block_t *before, block_t *after) {
    234          //  return sqrt(
    235          //    pow((before->speed_x-after->speed_x), 2)+pow((before->speed_y-after->speed_y), 2));
    236          //}
    237          
    238          
    239          // The kernel called by recalculate() when scanning the plan from last to first entry.

   \                                 In section .text, align 2, keep-with-next
    240          void Planner::reverse_pass_kernel(block_t* const current, const block_t *next) {
   \                     _ZN7Planner19reverse_pass_kernelEP7block_tPKS0_: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    241            if (!current || !next) return;
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD02F             BEQ.N    ??reverse_pass_kernel_0
   \        0xA   0x2D00             CMP      R5,#+0
   \        0xC   0xD02D             BEQ.N    ??reverse_pass_kernel_0
    242            // If entry speed is already at the maximum entry speed, no need to recheck. Block is cruising.
    243            // If not, block in state of acceleration or deceleration. Reset entry speed to maximum and
    244            // check for maximum allowable speed reductions to ensure maximum possible planned speed.
    245            float max_entry_speed = current->max_entry_speed;
   \        0xE   0x6B26             LDR      R6,[R4, #+48]
    246            if (current->entry_speed != max_entry_speed) {
   \       0x10   0x6AE0             LDR      R0,[R4, #+44]
   \       0x12   0x4631             MOV      R1,R6
   \       0x14   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0x18   0xD027             BEQ.N    ??reverse_pass_kernel_0
    247              // If nominal length true, max junction speed is guaranteed to be reached. Only compute
    248              // for max allowable speed if block is decelerating and nominal length is false.
    249              current->entry_speed = (TEST(current->flag, BLOCK_BIT_NOMINAL_LENGTH) || max_entry_speed <= next->entry_speed)
    250                ? max_entry_speed
    251                : min(max_entry_speed, max_allowable_speed(-current->acceleration, next->entry_speed, current->millimeters));
   \       0x1A   0x7860             LDRB     R0,[R4, #+1]
   \       0x1C   0x0780             LSLS     R0,R0,#+30
   \       0x1E   0xD41F             BMI.N    ??reverse_pass_kernel_1
   \       0x20   0x6AE8             LDR      R0,[R5, #+44]
   \       0x22   0x.... 0x....      BL       __aeabi_cfrcmple
   \       0x26   0xD91B             BLS.N    ??reverse_pass_kernel_1
   \       0x28   0x6BA0             LDR      R0,[R4, #+56]
   \       0x2A   0xF080 0x4000      EOR      R0,R0,#0x80000000
   \       0x2E   0x9000             STR      R0,[SP, #+0]
   \       0x30   0xF104 0x0234      ADD      R2,R4,#+52
   \       0x34   0xF105 0x012C      ADD      R1,R5,#+44
   \       0x38   0x4668             MOV      R0,SP
   \       0x3A   0x.... 0x....      BL       _ZN7Planner19max_allowable_speedERKfS1_S1_
   \       0x3E   0x4601             MOV      R1,R0
   \       0x40   0x4630             MOV      R0,R6
   \       0x42   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x46   0xD30B             BCC.N    ??reverse_pass_kernel_1
   \       0x48   0x6BA0             LDR      R0,[R4, #+56]
   \       0x4A   0xF080 0x4000      EOR      R0,R0,#0x80000000
   \       0x4E   0x9001             STR      R0,[SP, #+4]
   \       0x50   0xF104 0x0234      ADD      R2,R4,#+52
   \       0x54   0xF105 0x012C      ADD      R1,R5,#+44
   \       0x58   0xA801             ADD      R0,SP,#+4
   \       0x5A   0x.... 0x....      BL       _ZN7Planner19max_allowable_speedERKfS1_S1_
   \       0x5E   0x4606             MOV      R6,R0
   \                     ??reverse_pass_kernel_1: (+1)
   \       0x60   0x62E6             STR      R6,[R4, #+44]
    252              SBI(current->flag, BLOCK_BIT_RECALCULATE);
   \       0x62   0x7860             LDRB     R0,[R4, #+1]
   \       0x64   0xF040 0x0001      ORR      R0,R0,#0x1
   \       0x68   0x7060             STRB     R0,[R4, #+1]
    253            }
    254          }
   \                     ??reverse_pass_kernel_0: (+1)
   \       0x6A   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    255          
    256          /**
    257           * recalculate() needs to go over the current plan twice.
    258           * Once in reverse and once forward. This implements the reverse pass.
    259           */

   \                                 In section .text, align 2, keep-with-next
    260          void Planner::reverse_pass() {
   \                     _ZN7Planner12reverse_passEv: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    261          
    262            if (movesplanned() > 3) {
   \        0x2   0x.... 0x....      BL       _ZN7Planner12movesplannedEv
   \        0x6   0x2804             CMP      R0,#+4
   \        0x8   0xDB20             BLT.N    ??reverse_pass_0
    263          
    264              block_t* block[3] = { NULL, NULL, NULL };
   \        0xA   0x2400             MOVS     R4,#+0
   \        0xC   0x4625             MOV      R5,R4
    265          
    266              // Make a local copy of block_buffer_tail, because the interrupt can alter it
    267              // Is a critical section REALLY needed for a single byte change?
    268              //CRITICAL_SECTION_START;
    269              uint8_t tail = block_buffer_tail;
   \        0xE   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \       0x12   0x7846             LDRB     R6,[R0, #+1]
    270              //CRITICAL_SECTION_END
    271          
    272              uint8_t b = BLOCK_MOD(block_buffer_head - 3);
   \       0x14   0x7800             LDRB     R0,[R0, #+0]
   \       0x16   0x1EC7             SUBS     R7,R0,#+3
   \       0x18   0xF007 0x070F      AND      R7,R7,#0xF
    273              while (b != tail) {
   \                     ??reverse_pass_1: (+1)
   \       0x1C   0x42B7             CMP      R7,R6
   \       0x1E   0xD015             BEQ.N    ??reverse_pass_0
    274                if (block[0] && TEST(block[0]->flag, BLOCK_BIT_START_FROM_FULL_HALT)) break;
   \       0x20   0x2C00             CMP      R4,#+0
   \       0x22   0xD002             BEQ.N    ??reverse_pass_2
   \       0x24   0x7860             LDRB     R0,[R4, #+1]
   \       0x26   0x0740             LSLS     R0,R0,#+29
   \       0x28   0xD410             BMI.N    ??reverse_pass_0
    275                b = prev_block_index(b);
   \                     ??reverse_pass_2: (+1)
   \       0x2A   0x4638             MOV      R0,R7
   \       0x2C   0xB240             SXTB     R0,R0
   \       0x2E   0x.... 0x....      BL       _ZN7Planner16prev_block_indexEa
   \       0x32   0x4607             MOV      R7,R0
   \       0x34   0xB2FF             UXTB     R7,R7
    276                block[2] = block[1];
   \       0x36   0x4629             MOV      R1,R5
    277                block[1] = block[0];
   \       0x38   0x4625             MOV      R5,R4
    278                block[0] = &block_buffer[b];
   \       0x3A   0x.... 0x....      LDR.W    R0,??DataTable13_4
   \       0x3E   0x2254             MOVS     R2,#+84
   \       0x40   0x437A             MULS     R2,R2,R7
   \       0x42   0x1884             ADDS     R4,R0,R2
    279                reverse_pass_kernel(block[1], block[2]);
   \       0x44   0x4628             MOV      R0,R5
   \       0x46   0x.... 0x....      BL       _ZN7Planner19reverse_pass_kernelEP7block_tPKS0_
   \       0x4A   0xE7E7             B.N      ??reverse_pass_1
    280              }
    281            }
    282          }
   \                     ??reverse_pass_0: (+1)
   \       0x4C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    283          
    284          // The kernel called by recalculate() when scanning the plan from first to last entry.

   \                                 In section .text, align 2, keep-with-next
    285          void Planner::forward_pass_kernel(const block_t* previous, block_t* const current) {
   \                     _ZN7Planner19forward_pass_kernelEPK7block_tPS0_: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    286            if (!previous) return;
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD02E             BEQ.N    ??forward_pass_kernel_0
    287          
    288            // If the previous block is an acceleration block, but it is not long enough to complete the
    289            // full speed change within the block, we need to adjust the entry speed accordingly. Entry
    290            // speeds have already been reset, maximized, and reverse planned by reverse planner.
    291            // If nominal length is true, max junction speed is guaranteed to be reached. No need to recheck.
    292            if (!TEST(previous->flag, BLOCK_BIT_NOMINAL_LENGTH)) {
   \        0xA   0x7860             LDRB     R0,[R4, #+1]
   \        0xC   0x0780             LSLS     R0,R0,#+30
   \        0xE   0xD42B             BMI.N    ??forward_pass_kernel_0
    293              if (previous->entry_speed < current->entry_speed) {
   \       0x10   0x6AE0             LDR      R0,[R4, #+44]
   \       0x12   0x6AE9             LDR      R1,[R5, #+44]
   \       0x14   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x18   0xD226             BCS.N    ??forward_pass_kernel_0
    294                float entry_speed = min(current->entry_speed,
    295                                         max_allowable_speed(-previous->acceleration, previous->entry_speed, previous->millimeters));
   \       0x1A   0x6BA0             LDR      R0,[R4, #+56]
   \       0x1C   0xF080 0x4000      EOR      R0,R0,#0x80000000
   \       0x20   0x9000             STR      R0,[SP, #+0]
   \       0x22   0xF104 0x0234      ADD      R2,R4,#+52
   \       0x26   0xF104 0x012C      ADD      R1,R4,#+44
   \       0x2A   0x4668             MOV      R0,SP
   \       0x2C   0x.... 0x....      BL       _ZN7Planner19max_allowable_speedERKfS1_S1_
   \       0x30   0x4601             MOV      R1,R0
   \       0x32   0x6AEA             LDR      R2,[R5, #+44]
   \       0x34   0x4610             MOV      R0,R2
   \       0x36   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x3A   0xD30B             BCC.N    ??forward_pass_kernel_1
   \       0x3C   0x6BA0             LDR      R0,[R4, #+56]
   \       0x3E   0xF080 0x4000      EOR      R0,R0,#0x80000000
   \       0x42   0x9001             STR      R0,[SP, #+4]
   \       0x44   0xF104 0x0234      ADD      R2,R4,#+52
   \       0x48   0xF104 0x012C      ADD      R1,R4,#+44
   \       0x4C   0xA801             ADD      R0,SP,#+4
   \       0x4E   0x.... 0x....      BL       _ZN7Planner19max_allowable_speedERKfS1_S1_
   \       0x52   0x4602             MOV      R2,R0
    296                // Check for junction speed change
    297                if (current->entry_speed != entry_speed) {
   \                     ??forward_pass_kernel_1: (+1)
   \       0x54   0x6AE8             LDR      R0,[R5, #+44]
   \       0x56   0x4611             MOV      R1,R2
   \       0x58   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0x5C   0xD004             BEQ.N    ??forward_pass_kernel_0
    298                  current->entry_speed = entry_speed;
   \       0x5E   0x62EA             STR      R2,[R5, #+44]
    299                  SBI(current->flag, BLOCK_BIT_RECALCULATE);
   \       0x60   0x7868             LDRB     R0,[R5, #+1]
   \       0x62   0xF040 0x0001      ORR      R0,R0,#0x1
   \       0x66   0x7068             STRB     R0,[R5, #+1]
    300                }
    301              }
    302            }
    303          }
   \                     ??forward_pass_kernel_0: (+1)
   \       0x68   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    304          
    305          /**
    306           * recalculate() needs to go over the current plan twice.
    307           * Once in reverse and once forward. This implements the forward pass.
    308           */

   \                                 In section .text, align 2, keep-with-next
    309          void Planner::forward_pass() {
   \                     _ZN7Planner12forward_passEv: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    310            block_t* block[3] = { NULL, NULL, NULL };
   \        0x2   0x2400             MOVS     R4,#+0
   \        0x4   0x4625             MOV      R5,R4
    311          
    312            for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
   \        0x6   0x.... 0x....      LDR.W    R6,??DataTable13_2
   \        0xA   0x7877             LDRB     R7,[R6, #+1]
   \        0xC   0xE00F             B.N      ??forward_pass_0
    313              block[0] = block[1];
   \                     ??forward_pass_1: (+1)
   \        0xE   0x4620             MOV      R0,R4
    314              block[1] = block[2];
   \       0x10   0x462C             MOV      R4,R5
    315              block[2] = &block_buffer[b];
   \       0x12   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \       0x16   0x2254             MOVS     R2,#+84
   \       0x18   0x437A             MULS     R2,R2,R7
   \       0x1A   0x188D             ADDS     R5,R1,R2
    316              forward_pass_kernel(block[0], block[1]);
   \       0x1C   0x4621             MOV      R1,R4
   \       0x1E   0x.... 0x....      BL       _ZN7Planner19forward_pass_kernelEPK7block_tPS0_
    317            }
   \       0x22   0x4638             MOV      R0,R7
   \       0x24   0xB240             SXTB     R0,R0
   \       0x26   0x.... 0x....      BL       _ZN7Planner16next_block_indexEa
   \       0x2A   0x4607             MOV      R7,R0
   \       0x2C   0xB2FF             UXTB     R7,R7
   \                     ??forward_pass_0: (+1)
   \       0x2E   0x7830             LDRB     R0,[R6, #+0]
   \       0x30   0x4287             CMP      R7,R0
   \       0x32   0xD1EC             BNE.N    ??forward_pass_1
    318            forward_pass_kernel(block[1], block[2]);
   \       0x34   0x4629             MOV      R1,R5
   \       0x36   0x4620             MOV      R0,R4
   \       0x38   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \       0x3C   0x....             B.N      _ZN7Planner19forward_pass_kernelEPK7block_tPS0_
    319          }
    320          
    321          /**
    322           * Recalculate the trapezoid speed profiles for all blocks in the plan
    323           * according to the entry_factor for each junction. Must be called by
    324           * recalculate() after updating the blocks.
    325           */

   \                                 In section .text, align 2, keep-with-next
    326          void Planner::recalculate_trapezoids() {
   \                     _ZN7Planner22recalculate_trapezoidsEv: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
    327            int8_t block_index = block_buffer_tail;
   \        0x4   0x.... 0x....      LDR.W    R6,??DataTable13_2
   \        0x8   0xF996 0x7001      LDRSB    R7,[R6, #+1]
    328            block_t *current, *next = NULL;
   \        0xC   0x2500             MOVS     R5,#+0
   \        0xE   0xE027             B.N      ??recalculate_trapezoids_0
    329          
    330            while (block_index != block_buffer_head) {
    331              current = next;
   \                     ??recalculate_trapezoids_1: (+1)
   \       0x10   0x462C             MOV      R4,R5
    332              next = &block_buffer[block_index];
   \       0x12   0x.... 0x....      LDR.W    R0,??DataTable13_4
   \       0x16   0x4639             MOV      R1,R7
   \       0x18   0x2254             MOVS     R2,#+84
   \       0x1A   0x4351             MULS     R1,R2,R1
   \       0x1C   0x1845             ADDS     R5,R0,R1
    333              if (current) {
   \       0x1E   0x2C00             CMP      R4,#+0
   \       0x20   0xD01A             BEQ.N    ??recalculate_trapezoids_2
    334                // Recalculate if current block entry or exit junction speed has changed.
    335                if (TEST(current->flag, BLOCK_BIT_RECALCULATE) || TEST(next->flag, BLOCK_BIT_RECALCULATE)) {
   \       0x22   0x7860             LDRB     R0,[R4, #+1]
   \       0x24   0x07C0             LSLS     R0,R0,#+31
   \       0x26   0xD402             BMI.N    ??recalculate_trapezoids_3
   \       0x28   0x7868             LDRB     R0,[R5, #+1]
   \       0x2A   0x07C0             LSLS     R0,R0,#+31
   \       0x2C   0xD514             BPL.N    ??recalculate_trapezoids_2
    336                  // NOTE: Entry and exit factors always > 0 by all previous logic operations.
    337                  float nom = current->nominal_speed;
   \                     ??recalculate_trapezoids_3: (+1)
   \       0x2E   0xF8D4 0x8028      LDR      R8,[R4, #+40]
    338                  calculate_trapezoid_for_block(current, current->entry_speed / nom, next->entry_speed / nom);
   \       0x32   0x6AE0             LDR      R0,[R4, #+44]
   \       0x34   0x4641             MOV      R1,R8
   \       0x36   0x.... 0x....      BL       __aeabi_fdiv
   \       0x3A   0x9000             STR      R0,[SP, #+0]
   \       0x3C   0x6AE8             LDR      R0,[R5, #+44]
   \       0x3E   0x4641             MOV      R1,R8
   \       0x40   0x.... 0x....      BL       __aeabi_fdiv
   \       0x44   0x9001             STR      R0,[SP, #+4]
   \       0x46   0xAA01             ADD      R2,SP,#+4
   \       0x48   0x4669             MOV      R1,SP
   \       0x4A   0x4620             MOV      R0,R4
   \       0x4C   0x.... 0x....      BL       _ZN7Planner29calculate_trapezoid_for_blockEP7block_tRKfS3_
    339                  CBI(current->flag, BLOCK_BIT_RECALCULATE); // Reset current only to ensure next trapezoid is computed
   \       0x50   0x7860             LDRB     R0,[R4, #+1]
   \       0x52   0xF000 0x00FE      AND      R0,R0,#0xFE
   \       0x56   0x7060             STRB     R0,[R4, #+1]
    340                }
    341              }
    342              block_index = next_block_index(block_index);
   \                     ??recalculate_trapezoids_2: (+1)
   \       0x58   0x4638             MOV      R0,R7
   \       0x5A   0x.... 0x....      BL       _ZN7Planner16next_block_indexEa
   \       0x5E   0x4607             MOV      R7,R0
    343            }
   \                     ??recalculate_trapezoids_0: (+1)
   \       0x60   0x4638             MOV      R0,R7
   \       0x62   0x7831             LDRB     R1,[R6, #+0]
   \       0x64   0x4288             CMP      R0,R1
   \       0x66   0xD1D3             BNE.N    ??recalculate_trapezoids_1
    344            // Last/newest block in buffer. Exit speed is set with MINIMUM_PLANNER_SPEED. Always recalculated.
    345            if (next) {
   \       0x68   0x2D00             CMP      R5,#+0
   \       0x6A   0xD01C             BEQ.N    ??recalculate_trapezoids_4
    346              float nom = next->nominal_speed;
   \       0x6C   0x6AAC             LDR      R4,[R5, #+40]
    347              calculate_trapezoid_for_block(next, next->entry_speed / nom, (MINIMUM_PLANNER_SPEED) / nom);
   \       0x6E   0x6AE8             LDR      R0,[R5, #+44]
   \       0x70   0x4621             MOV      R1,R4
   \       0x72   0x.... 0x....      BL       __aeabi_fdiv
   \       0x76   0x9000             STR      R0,[SP, #+0]
   \       0x78   0x4620             MOV      R0,R4
   \       0x7A   0x.... 0x....      BL       __aeabi_f2d
   \       0x7E   0x4602             MOV      R2,R0
   \       0x80   0x460B             MOV      R3,R1
   \       0x82   0x.... 0x....      LDR.W    R0,??DataTable13_5  ;; 0x9999999a
   \       0x86   0x.... 0x....      LDR.W    R1,??DataTable13_6  ;; 0x3fa99999
   \       0x8A   0x.... 0x....      BL       __aeabi_ddiv
   \       0x8E   0x.... 0x....      BL       __aeabi_d2f
   \       0x92   0x9001             STR      R0,[SP, #+4]
   \       0x94   0xAA01             ADD      R2,SP,#+4
   \       0x96   0x4669             MOV      R1,SP
   \       0x98   0x4628             MOV      R0,R5
   \       0x9A   0x.... 0x....      BL       _ZN7Planner29calculate_trapezoid_for_blockEP7block_tRKfS3_
    348              CBI(next->flag, BLOCK_BIT_RECALCULATE);
   \       0x9E   0x7868             LDRB     R0,[R5, #+1]
   \       0xA0   0xF000 0x00FE      AND      R0,R0,#0xFE
   \       0xA4   0x7068             STRB     R0,[R5, #+1]
    349            }
    350          }
   \                     ??recalculate_trapezoids_4: (+1)
   \       0xA6   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return
    351          
    352          /*
    353           * Recalculate the motion plan according to the following algorithm:
    354           *
    355           *   1. Go over every block in reverse order...
    356           *
    357           *      Calculate a junction speed reduction (block_t.entry_factor) so:
    358           *
    359           *      a. The junction jerk is within the set limit, and
    360           *
    361           *      b. No speed reduction within one block requires faster
    362           *         deceleration than the one, true constant acceleration.
    363           *
    364           *   2. Go over every block in chronological order...
    365           *
    366           *      Dial down junction speed reduction values if:
    367           *      a. The speed increase within one block would require faster
    368           *         acceleration than the one, true constant acceleration.
    369           *
    370           * After that, all blocks will have an entry_factor allowing all speed changes to
    371           * be performed using only the one, true constant acceleration, and where no junction
    372           * jerk is jerkier than the set limit, Jerky. Finally it will:
    373           *
    374           *   3. Recalculate "trapezoids" for all blocks.
    375           */

   \                                 In section .text, align 2, keep-with-next
    376          void Planner::recalculate() {
   \                     _ZN7Planner11recalculateEv: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    377            reverse_pass();
   \        0x2   0x.... 0x....      BL       _ZN7Planner12reverse_passEv
    378            forward_pass();
   \        0x6   0x.... 0x....      BL       _ZN7Planner12forward_passEv
    379            recalculate_trapezoids();
   \        0xA   0xE8BD 0x4001      POP      {R0,LR}
   \        0xE   0x....             B.N      _ZN7Planner22recalculate_trapezoidsEv
    380          }
    381          
    382          
    383          #if ENABLED(AUTOTEMP)
    384          

   \                                 In section .text, align 2, keep-with-next
    385            void Planner::getHighESpeed() {
   \                     _ZN7Planner13getHighESpeedEv: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
    386              static float oldt = 0;
    387          
    388              if (!autotemp_enabled) return;
   \        0x4   0x.... 0x....      LDR.W    R6,??DataTable13_2
   \        0x8   0x78B0             LDRB     R0,[R6, #+2]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD073             BEQ.N    ??getHighESpeed_0
    389              if (thermalManager.degTargetHotend(0) + 2 < autotemp_min) return; // probably temperature set to zero.
   \        0xE   0x6DB5             LDR      R5,[R6, #+88]
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x.... 0x....      BL       _ZN11Temperature15degTargetHotendEh
   \       0x16   0xF04F 0x4180      MOV      R1,#+1073741824
   \       0x1A   0x.... 0x....      BL       __aeabi_fadd
   \       0x1E   0x4629             MOV      R1,R5
   \       0x20   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x24   0xD367             BCC.N    ??getHighESpeed_0
    390          
    391              float high = 0.0;
   \       0x26   0x2700             MOVS     R7,#+0
    392              for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
   \       0x28   0xF896 0x8001      LDRB     R8,[R6, #+1]
   \       0x2C   0xE029             B.N      ??getHighESpeed_1
    393                block_t* block = &block_buffer[b];
    394                if (block->steps[X_AXIS] || block->steps[Y_AXIS] || block->steps[Z_AXIS]) {
   \                     ??getHighESpeed_2: (+1)
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable13_4
   \       0x32   0x2154             MOVS     R1,#+84
   \       0x34   0xFB01 0xF108      MUL      R1,R1,R8
   \       0x38   0x1844             ADDS     R4,R0,R1
   \       0x3A   0x6860             LDR      R0,[R4, #+4]
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD105             BNE.N    ??getHighESpeed_3
   \       0x40   0x68A0             LDR      R0,[R4, #+8]
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD102             BNE.N    ??getHighESpeed_3
   \       0x46   0x68E0             LDR      R0,[R4, #+12]
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD013             BEQ.N    ??getHighESpeed_4
    395                  float se = (float)block->steps[E_AXIS] / block->step_event_count * block->nominal_speed; // mm/sec;
   \                     ??getHighESpeed_3: (+1)
   \       0x4C   0x6920             LDR      R0,[R4, #+16]
   \       0x4E   0x.... 0x....      BL       __aeabi_i2f
   \       0x52   0x4681             MOV      R9,R0
   \       0x54   0x6960             LDR      R0,[R4, #+20]
   \       0x56   0x.... 0x....      BL       __aeabi_ui2f
   \       0x5A   0x4601             MOV      R1,R0
   \       0x5C   0x4648             MOV      R0,R9
   \       0x5E   0x.... 0x....      BL       __aeabi_fdiv
   \       0x62   0x6AA1             LDR      R1,[R4, #+40]
   \       0x64   0x.... 0x....      BL       __aeabi_fmul
   \       0x68   0x4601             MOV      R1,R0
    396                  NOLESS(high, se);
   \       0x6A   0x4638             MOV      R0,R7
   \       0x6C   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x70   0xD200             BCS.N    ??getHighESpeed_4
   \       0x72   0x460F             MOV      R7,R1
    397                }
    398              }
   \                     ??getHighESpeed_4: (+1)
   \       0x74   0x4640             MOV      R0,R8
   \       0x76   0xB240             SXTB     R0,R0
   \       0x78   0x.... 0x....      BL       _ZN7Planner16next_block_indexEa
   \       0x7C   0x4680             MOV      R8,R0
   \       0x7E   0xFA5F 0xF888      UXTB     R8,R8
   \                     ??getHighESpeed_1: (+1)
   \       0x82   0x7830             LDRB     R0,[R6, #+0]
   \       0x84   0x4580             CMP      R8,R0
   \       0x86   0xD1D2             BNE.N    ??getHighESpeed_2
    399          
    400              float t = autotemp_min + high * autotemp_factor;
   \       0x88   0x6DF0             LDR      R0,[R6, #+92]
   \       0x8A   0x4639             MOV      R1,R7
   \       0x8C   0x.... 0x....      BL       __aeabi_fmul
   \       0x90   0x4629             MOV      R1,R5
   \       0x92   0x.... 0x....      BL       __aeabi_fadd
   \       0x96   0x4602             MOV      R2,R0
    401              t = constrain(t, autotemp_min, autotemp_max);
   \       0x98   0x4629             MOV      R1,R5
   \       0x9A   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x9E   0xD201             BCS.N    ??getHighESpeed_5
   \       0xA0   0x462A             MOV      R2,R5
   \       0xA2   0xE005             B.N      ??getHighESpeed_6
   \                     ??getHighESpeed_5: (+1)
   \       0xA4   0x6D70             LDR      R0,[R6, #+84]
   \       0xA6   0x4611             MOV      R1,R2
   \       0xA8   0x.... 0x....      BL       __aeabi_cfcmple
   \       0xAC   0xD200             BCS.N    ??getHighESpeed_6
   \       0xAE   0x4602             MOV      R2,R0
    402              if (t < oldt) t = t * (1 - (AUTOTEMP_OLDWEIGHT)) + oldt * (AUTOTEMP_OLDWEIGHT);
   \                     ??getHighESpeed_6: (+1)
   \       0xB0   0x6FB7             LDR      R7,[R6, #+120]
   \       0xB2   0x4610             MOV      R0,R2
   \       0xB4   0x4639             MOV      R1,R7
   \       0xB6   0x.... 0x....      BL       __aeabi_cfcmple
   \       0xBA   0xD215             BCS.N    ??getHighESpeed_7
   \       0xBC   0x.... 0x....      BL       __aeabi_f2d
   \       0xC0   0x....             LDR.N    R2,??DataTable13_7  ;; 0x47ae1480
   \       0xC2   0x....             LDR.N    R3,??DataTable13_8  ;; 0x3f947ae1
   \       0xC4   0x.... 0x....      BL       __aeabi_dmul
   \       0xC8   0x4604             MOV      R4,R0
   \       0xCA   0x460D             MOV      R5,R1
   \       0xCC   0x4638             MOV      R0,R7
   \       0xCE   0x.... 0x....      BL       __aeabi_f2d
   \       0xD2   0x....             LDR.N    R2,??DataTable13_9  ;; 0xf5c28f5c
   \       0xD4   0x....             LDR.N    R3,??DataTable13_10  ;; 0x3fef5c28
   \       0xD6   0x.... 0x....      BL       __aeabi_dmul
   \       0xDA   0x4622             MOV      R2,R4
   \       0xDC   0x462B             MOV      R3,R5
   \       0xDE   0x.... 0x....      BL       __aeabi_dadd
   \       0xE2   0x.... 0x....      BL       __aeabi_d2f
   \       0xE6   0x4602             MOV      R2,R0
    403              oldt = t;
   \                     ??getHighESpeed_7: (+1)
   \       0xE8   0x67B2             STR      R2,[R6, #+120]
    404              thermalManager.setTargetHotend(t, 0);
   \       0xEA   0x2100             MOVS     R1,#+0
   \       0xEC   0x4610             MOV      R0,R2
   \       0xEE   0xE8BD 0x43F4      POP      {R2,R4-R9,LR}
   \       0xF2   0x.... 0x....      B.W      _ZN11Temperature15setTargetHotendEfh
   \                     ??getHighESpeed_0: (+1)
   \       0xF6   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    405            }

   \                                 In section .data, align 4
   \                     _ZN7Planner17block_buffer_headE:
   \        0x0   0x00               DC8 0
   \                     _ZN7Planner17block_buffer_tailE:
   \        0x1   0x00               DC8 0
   \                     _ZN7Planner16autotemp_enabledE:
   \        0x2   0x00               DC8 0
   \        0x3   0x00               DC8 0
   \                     _ZN7Planner17axis_steps_per_mmE:
   \        0x4   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     _ZN7Planner11steps_to_mmE:
   \       0x14   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     _ZN7Planner29max_acceleration_steps_per_s2E:
   \       0x24   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     _ZN7Planner8positionE:
   \       0x34   0x0000'0000        DC32 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \                     _ZN7Planner26max_acceleration_mm_per_s2E:
   \       0x44   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     _ZN7Planner12autotemp_maxE:
   \       0x54   0x437A'0000        DC32 437A0000H
   \                     _ZN7Planner12autotemp_minE:
   \       0x58   0x4352'0000        DC32 43520000H
   \                     _ZN7Planner15autotemp_factorE:
   \       0x5C   0x3DCC'CCCD        DC32 3DCCCCCDH
   \                     _ZN7Planner11cutoff_longE:
   \       0x60   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN7Planner14previous_speedE:
   \       0x64   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     _ZN7Planner22previous_nominal_speedE:
   \       0x74   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \       0x78   0x0000'0000        DC32 0H
    406          
    407          #endif //AUTOTEMP
    408          
    409          /**
    410           * Maintain fans, paste extruder pressure,
    411           */

   \                                 In section .text, align 2, keep-with-next
    412          void Planner::check_axes_activity() {
   \                     _ZN7Planner19check_axes_activityEv: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    413            unsigned char axis_active[NUM_AXIS] = { 0 },
    414                          tail_fan_speed[FAN_COUNT];
                                 ^
Warning[Pe550]: variable "tail_fan_speed" was set but never used
    415          
    416            #if FAN_COUNT > 0
    417              for (uint8_t i = 0; i < FAN_COUNT; i++) tail_fan_speed[i] = fanSpeeds[i];
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0xE000             B.N      ??check_axes_activity_0
   \                     ??check_axes_activity_1: (+1)
   \        0x6   0x2001             MOVS     R0,#+1
   \                     ??check_axes_activity_0: (+1)
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD0FC             BEQ.N    ??check_axes_activity_1
    418            #endif
    419          
    420            #if ENABLED(BARICUDA)
    421              #if HAS_HEATER_1
    422                unsigned char tail_valve_pressure = baricuda_valve_pressure;
    423              #endif
    424              #if HAS_HEATER_2
    425                unsigned char tail_e_to_p_pressure = baricuda_e_to_p_pressure;
    426              #endif
    427            #endif
    428          
    429            if (blocks_queued()) {
   \        0xC   0x.... 0x....      BL       _ZN7Planner13blocks_queuedEv
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD013             BEQ.N    ??check_axes_activity_2
    430          
    431              #if FAN_COUNT > 0
    432                for (uint8_t i = 0; i < FAN_COUNT; i++) tail_fan_speed[i] = block_buffer[block_buffer_tail].fan_speed[i];
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x....             LDR.N    R4,??DataTable13_2
   \       0x18   0xE000             B.N      ??check_axes_activity_3
   \                     ??check_axes_activity_4: (+1)
   \       0x1A   0x2001             MOVS     R0,#+1
   \                     ??check_axes_activity_3: (+1)
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0x7860             LDRB     R0,[R4, #+1]
   \       0x20   0xD0FB             BEQ.N    ??check_axes_activity_4
    433              #endif
    434          
    435              block_t* block;
    436          
    437              #if ENABLED(BARICUDA)
    438                block = &block_buffer[block_buffer_tail];
    439                #if HAS_HEATER_1
    440                  tail_valve_pressure = block->valve_pressure;
    441                #endif
    442                #if HAS_HEATER_2
    443                  tail_e_to_p_pressure = block->e_to_p_pressure;
    444                #endif
    445              #endif
    446          
    447              for (uint8_t b = block_buffer_tail; b != block_buffer_head; b = next_block_index(b)) {
   \       0x22   0xE006             B.N      ??check_axes_activity_5
    448                block = &block_buffer[b];
    449                LOOP_XYZE(i) if (block->steps[i]) axis_active[i]++;
   \                     ??check_axes_activity_6: (+1)
   \       0x24   0x1C49             ADDS     R1,R1,#+1
   \                     ??check_axes_activity_7: (+1)
   \       0x26   0x2904             CMP      R1,#+4
   \       0x28   0xDBFC             BLT.N    ??check_axes_activity_6
   \       0x2A   0xB240             SXTB     R0,R0
   \       0x2C   0x.... 0x....      BL       _ZN7Planner16next_block_indexEa
   \       0x30   0xB2C0             UXTB     R0,R0
   \                     ??check_axes_activity_5: (+1)
   \       0x32   0x7821             LDRB     R1,[R4, #+0]
   \       0x34   0x4288             CMP      R0,R1
   \       0x36   0xD001             BEQ.N    ??check_axes_activity_2
   \       0x38   0x2100             MOVS     R1,#+0
   \       0x3A   0xE7F4             B.N      ??check_axes_activity_7
    450              }
    451            }
    452            #if ENABLED(DISABLE_X)
    453              if (!axis_active[X_AXIS]) disable_X(); ABC
    454            #endif
    455            #if ENABLED(DISABLE_Y)
    456              if (!axis_active[Y_AXIS]) disable_Y();
    457            #endif
    458            #if ENABLED(DISABLE_Z)
    459              if (!axis_active[Z_AXIS]) disable_Z();
    460            #endif
    461            #if ENABLED(DISABLE_E)
    462              if (!axis_active[E_AXIS]) disable_e_steppers();
    463            #endif
    464          
    465            #if FAN_COUNT > 0
    466          
    467              #ifdef FAN_MIN_PWM
    468                #define CALC_FAN_SPEED(f) (tail_fan_speed[f] ? ( FAN_MIN_PWM + (tail_fan_speed[f] * (255 - FAN_MIN_PWM)) / 255 ) : 0)
    469              #else
    470                #define CALC_FAN_SPEED(f) tail_fan_speed[f]
    471              #endif
    472          
    473              #ifdef FAN_KICKSTART_TIME
    474          
    475                static millis_t fan_kick_end[FAN_COUNT] = { 0 };
    476          
    477                #define KICKSTART_FAN(f) \
    478                  if (tail_fan_speed[f]) { \
    479                    millis_t ms = millis(); \
    480                    if (fan_kick_end[f] == 0) { \
    481                      fan_kick_end[f] = ms + FAN_KICKSTART_TIME; \
    482                      tail_fan_speed[f] = 255; \
    483                    } else { \
    484                      if (PENDING(ms, fan_kick_end[f])) { \
    485                        tail_fan_speed[f] = 255; \
    486                      } \
    487                    } \
    488                  } else { \
    489                    fan_kick_end[f] = 0; \
    490                  }
    491          
    492                #if HAS_FAN0
    493                  KICKSTART_FAN(0);
    494                #endif
    495                #if HAS_FAN1
    496                  KICKSTART_FAN(1);
    497                #endif
    498                #if HAS_FAN2
    499                  KICKSTART_FAN(2);
    500                #endif
    501          
    502              #endif //FAN_KICKSTART_TIME
    503          
    504              #if ENABLED(FAN_SOFT_PWM)
    505                #if HAS_FAN0
    506                  thermalManager.fanSpeedSoftPwm[0] = CALC_FAN_SPEED(0);
    507                #endif
    508                #if HAS_FAN1
    509                  thermalManager.fanSpeedSoftPwm[1] = CALC_FAN_SPEED(1);
    510                #endif
    511                #if HAS_FAN2
    512                  thermalManager.fanSpeedSoftPwm[2] = CALC_FAN_SPEED(2);
    513                #endif
    514              #else
    515                #if HAS_FAN0
    516                  //analogWrite(FAN_PIN, CALC_FAN_SPEED(0));	/*--mks--*/
    517                #endif
    518                #if HAS_FAN1
    519                  //analogWrite(FAN1_PIN, CALC_FAN_SPEED(1));
    520                #endif
    521                #if HAS_FAN2
    522                  //analogWrite(FAN2_PIN, CALC_FAN_SPEED(2));
    523                #endif
    524              #endif
    525          
    526            #endif // FAN_COUNT > 0
    527          
    528            #if ENABLED(AUTOTEMP)
    529              getHighESpeed();
   \                     ??check_axes_activity_2: (+1)
   \       0x3C   0xE8BD 0x4010      POP      {R4,LR}
   \       0x40   0x....             B.N      _ZN7Planner13getHighESpeedEv
    530            #endif
    531          
    532            #if ENABLED(BARICUDA)
    533              #if HAS_HEATER_1
    534                analogWrite(HEATER_1_PIN, tail_valve_pressure);
    535              #endif
    536              #if HAS_HEATER_2
    537                analogWrite(HEATER_2_PIN, tail_e_to_p_pressure);
    538              #endif
    539            #endif
    540          }
    541          
    542          //#if PLANNER_LEVELING
    543          #if 1
    544            /**
    545             * lx, ly, lz - logical (cartesian, not delta) positions in mm
    546             */

   \                                 In section .text, align 2, keep-with-next
    547            void Planner::apply_leveling(float &lx, float &ly, float &lz) {
   \                     _ZN7Planner14apply_levelingERfS0_S0_: (+1)
   \        0x0   0xE92D 0x47F8      PUSH     {R3-R10,LR}
   \        0x4   0xB08B             SUB      SP,SP,#+44
   \        0x6   0x4606             MOV      R6,R0
   \        0x8   0x460D             MOV      R5,R1
    548          
    549              //#if HAS_ABL
    550          	if(BED_LEVELING_METHOD&HAS_ABL)
   \        0xA   0x....             LDR.N    R1,??DataTable13_11
   \        0xC   0x780F             LDRB     R7,[R1, #+0]
   \        0xE   0xF017 0x0F1E      TST      R7,#0x1E
   \       0x12   0xD004             BEQ.N    ??apply_leveling_0
    551          		{
    552                	if (!abl_enabled) return;
   \       0x14   0x....             LDR.N    R0,??DataTable13_12
   \       0x16   0x7800             LDRB     R0,[R0, #+0]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xF000 0x8093      BEQ.W    ??apply_leveling_1
    553          		}
    554              //#endif
    555          
    556              #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)    //MKS_DEBUG_AUTO_BED_LEVELING_LINEAR
    557          	static float z_fade_factor = 1.0, last_raw_lz = -999.0;
    558          
    559          	if((MACHINETPYE != DELTA) && (BED_LEVELING_METHOD&HAS_FADE))	//mks_delta
   \                     ??apply_leveling_0: (+1)
   \       0x1E   0x4614             MOV      R4,R2
   \       0x20   0xF9B1 0x0018      LDRSH    R0,[R1, #+24]
   \       0x24   0x2802             CMP      R0,#+2
   \       0x26   0xD02C             BEQ.N    ??apply_leveling_2
   \       0x28   0x06F8             LSLS     R0,R7,#+27
   \       0x2A   0xD52A             BPL.N    ??apply_leveling_2
    560          		{
    561                if (z_fade_height) {
   \       0x2C   0x.... 0x....      LDR.W    R8,??DataTable13_12
   \       0x30   0xF8D8 0x9004      LDR      R9,[R8, #+4]
   \       0x34   0x4648             MOV      R0,R9
   \       0x36   0x2100             MOVS     R1,#+0
   \       0x38   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0x3C   0xD01D             BEQ.N    ??apply_leveling_3
    562                  const float raw_lz = RAW_Z_POSITION(lz);
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0x....             LDR.N    R1,??DataTable13_13
   \       0x42   0x6889             LDR      R1,[R1, #+8]
   \       0x44   0x.... 0x....      BL       __aeabi_fsub
   \       0x48   0x4682             MOV      R10,R0
    563                  if (raw_lz >= z_fade_height) return;
   \       0x4A   0x4649             MOV      R1,R9
   \       0x4C   0x.... 0x....      BL       __aeabi_cfrcmple
   \       0x50   0xD978             BLS.N    ??apply_leveling_1
    564                  if (last_raw_lz != raw_lz) {
   \       0x52   0xF8D8 0x0010      LDR      R0,[R8, #+16]
   \       0x56   0x4651             MOV      R1,R10
   \       0x58   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0x5C   0xD011             BEQ.N    ??apply_leveling_2
    565                    last_raw_lz = raw_lz;
   \       0x5E   0xF8C8 0xA010      STR      R10,[R8, #+16]
    566                    z_fade_factor = 1.0 - raw_lz * inverse_z_fade_height;
   \       0x62   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \       0x66   0x.... 0x....      BL       __aeabi_fmul
   \       0x6A   0x4601             MOV      R1,R0
   \       0x6C   0xF04F 0x507E      MOV      R0,#+1065353216
   \       0x70   0x.... 0x....      BL       __aeabi_fsub
   \       0x74   0xF8C8 0x000C      STR      R0,[R8, #+12]
   \       0x78   0xE003             B.N      ??apply_leveling_2
    567                  }
    568                }
    569                else
    570                  z_fade_factor = 1.0;	
   \                     ??apply_leveling_3: (+1)
   \       0x7A   0xF04F 0x507E      MOV      R0,#+1065353216
   \       0x7E   0xF8C8 0x000C      STR      R0,[R8, #+12]
    571          	  }
    572              #endif
    573          
    574          	/*--mks cfg--begin MESH_BED_LEVELING */
    575          /*	
    576              #if ENABLED(MESH_BED_LEVELING)
    577          
    578                if (mbl.active())
    579                  lz += mbl.get_z(RAW_X_POSITION(lx), RAW_Y_POSITION(ly)
    580                    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
    581                      , z_fade_factor
    582                    #endif
    583                    );
    584          
    585              #elif ABL_PLANAR
    586          
    587                float dx = RAW_X_POSITION(lx) - (X_TILT_FULCRUM),
    588                      dy = RAW_Y_POSITION(ly) - (Y_TILT_FULCRUM),
    589                      dz = RAW_Z_POSITION(lz);
    590          
    591                apply_rotation_xyz(bed_level_matrix, dx, dy, dz);
    592          
    593                lx = LOGICAL_X_POSITION(dx + X_TILT_FULCRUM);
    594                ly = LOGICAL_Y_POSITION(dy + Y_TILT_FULCRUM);
    595                lz = LOGICAL_Z_POSITION(dz);
    596          
    597              #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
    598          
    599                float tmp[XYZ] = { lx, ly, 0 };
    600                lz += bilinear_z_offset(tmp)
    601                  #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
    602                    * z_fade_factor
    603                  #endif
    604                ;
    605          
    606              #endif
    607          */
    608          		if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
   \                     ??apply_leveling_2: (+1)
   \       0x82   0x2F20             CMP      R7,#+32
   \       0x84   0xD118             BNE.N    ??apply_leveling_4
    609          		{
    610          		if (mbl.active())
   \       0x86   0x.... 0x....      BL       _ZN17mesh_bed_leveling6activeEv
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0xD05A             BEQ.N    ??apply_leveling_1
    611          		{
    612          		if((MACHINETPYE != DELTA) && (BED_LEVELING_METHOD&HAS_FADE))	//mks_delta
    613          			{
    614          		  		lz += mbl.get_z(RAW_X_POSITION(lx), RAW_Y_POSITION(ly) , z_fade_factor);
    615          			}
    616          			else
    617          				{
    618          				lz += mbl.get_z_mks(RAW_X_POSITION(lx), RAW_Y_POSITION(ly));
   \       0x8E   0x....             LDR.N    R7,??DataTable13_13
   \       0x90   0x6830             LDR      R0,[R6, #+0]
   \       0x92   0x6839             LDR      R1,[R7, #+0]
   \       0x94   0x.... 0x....      BL       __aeabi_fsub
   \       0x98   0x9000             STR      R0,[SP, #+0]
   \       0x9A   0x6828             LDR      R0,[R5, #+0]
   \       0x9C   0x6879             LDR      R1,[R7, #+4]
   \       0x9E   0x.... 0x....      BL       __aeabi_fsub
   \       0xA2   0x9001             STR      R0,[SP, #+4]
   \       0xA4   0xA901             ADD      R1,SP,#+4
   \       0xA6   0x4668             MOV      R0,SP
   \       0xA8   0x.... 0x....      BL       _ZN17mesh_bed_leveling9get_z_mksERKfS1_
   \       0xAC   0x4601             MOV      R1,R0
   \       0xAE   0x6820             LDR      R0,[R4, #+0]
   \       0xB0   0x.... 0x....      BL       __aeabi_fadd
   \       0xB4   0x6020             STR      R0,[R4, #+0]
   \       0xB6   0xE045             B.N      ??apply_leveling_1
    619          				}
    620          		}
    621          		}
    622          		else if(BED_LEVELING_METHOD&ABL_PLANAR)
   \                     ??apply_leveling_4: (+1)
   \       0xB8   0xF017 0x0F06      TST      R7,#0x6
   \       0xBC   0xD02E             BEQ.N    ??apply_leveling_5
    623          			{
    624          			float dx = RAW_X_POSITION(lx) - (X_TILT_FULCRUM),
   \       0xBE   0x....             LDR.N    R7,??DataTable13_13
   \       0xC0   0x6830             LDR      R0,[R6, #+0]
   \       0xC2   0x6839             LDR      R1,[R7, #+0]
   \       0xC4   0x.... 0x....      BL       __aeabi_fsub
   \       0xC8   0x900A             STR      R0,[SP, #+40]
    625          				  dy = RAW_Y_POSITION(ly) - (Y_TILT_FULCRUM),
   \       0xCA   0x6828             LDR      R0,[R5, #+0]
   \       0xCC   0x6879             LDR      R1,[R7, #+4]
   \       0xCE   0x.... 0x....      BL       __aeabi_fsub
   \       0xD2   0x9009             STR      R0,[SP, #+36]
    626          				  dz = RAW_Z_POSITION(lz);
   \       0xD4   0x6820             LDR      R0,[R4, #+0]
   \       0xD6   0x68B9             LDR      R1,[R7, #+8]
   \       0xD8   0x.... 0x....      BL       __aeabi_fsub
   \       0xDC   0x9008             STR      R0,[SP, #+32]
    627          			
    628          			apply_rotation_xyz(bed_level_matrix, dx, dy, dz);
   \       0xDE   0xA808             ADD      R0,SP,#+32
   \       0xE0   0x9007             STR      R0,[SP, #+28]
   \       0xE2   0xA809             ADD      R0,SP,#+36
   \       0xE4   0x9006             STR      R0,[SP, #+24]
   \       0xE6   0xA80A             ADD      R0,SP,#+40
   \       0xE8   0x9005             STR      R0,[SP, #+20]
   \       0xEA   0x....             LDR.N    R1,??DataTable13_3
   \       0xEC   0xB084             SUB      SP,SP,#+16
   \       0xEE   0x4668             MOV      R0,SP
   \       0xF0   0x2224             MOVS     R2,#+36
   \       0xF2   0x.... 0x....      BL       __aeabi_memcpy4
   \       0xF6   0xBC0F             POP      {R0-R3}
   \       0xF8   0x.... 0x....      BL       _Z18apply_rotation_xyz10matrix_3x3RfS0_S0_
    629          			
    630          			lx = LOGICAL_X_POSITION(dx + X_TILT_FULCRUM);
   \       0xFC   0x990A             LDR      R1,[SP, #+40]
   \       0xFE   0x6838             LDR      R0,[R7, #+0]
   \      0x100   0x.... 0x....      BL       __aeabi_fadd
   \      0x104   0x6030             STR      R0,[R6, #+0]
    631          			ly = LOGICAL_Y_POSITION(dy + Y_TILT_FULCRUM);
   \      0x106   0x9909             LDR      R1,[SP, #+36]
   \      0x108   0x6878             LDR      R0,[R7, #+4]
   \      0x10A   0x.... 0x....      BL       __aeabi_fadd
   \      0x10E   0x6028             STR      R0,[R5, #+0]
    632          			lz = LOGICAL_Z_POSITION(dz);
   \      0x110   0x9908             LDR      R1,[SP, #+32]
   \      0x112   0x68B8             LDR      R0,[R7, #+8]
   \      0x114   0x.... 0x....      BL       __aeabi_fadd
   \      0x118   0x6020             STR      R0,[R4, #+0]
   \      0x11A   0xE013             B.N      ??apply_leveling_1
    633          			}
    634          		else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
   \                     ??apply_leveling_5: (+1)
   \      0x11C   0x2F08             CMP      R7,#+8
   \      0x11E   0xD111             BNE.N    ??apply_leveling_1
    635          			{
    636          			float tmp[XYZ] = { lx, ly, 0 };
   \      0x120   0x4668             MOV      R0,SP
   \      0x122   0x2100             MOVS     R1,#+0
   \      0x124   0x460A             MOV      R2,R1
   \      0x126   0x460B             MOV      R3,R1
   \      0x128   0xE880 0x000E      STM      R0,{R1-R3}
   \      0x12C   0x6830             LDR      R0,[R6, #+0]
   \      0x12E   0x9000             STR      R0,[SP, #+0]
   \      0x130   0x6828             LDR      R0,[R5, #+0]
   \      0x132   0x9001             STR      R0,[SP, #+4]
    637          /*			
    638          			lz += bilinear_z_offset(tmp)
    639            			#if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
    640          				* z_fade_factor
    641            			#endif
    642          			;
    643          */
    644          		if((MACHINETPYE != DELTA) && (BED_LEVELING_METHOD&HAS_FADE))	//mks_delta
    645          			{
    646          			lz += bilinear_z_offset(tmp)* z_fade_factor;
    647          			}
    648          		else
    649          			{
    650          			lz += bilinear_z_offset(tmp);
   \      0x134   0x4668             MOV      R0,SP
   \      0x136   0x.... 0x....      BL       _Z17bilinear_z_offsetPKf
   \      0x13A   0x4601             MOV      R1,R0
   \      0x13C   0x6820             LDR      R0,[R4, #+0]
   \      0x13E   0x.... 0x....      BL       __aeabi_fadd
   \      0x142   0x6020             STR      R0,[R4, #+0]
    651          			}
    652          
    653          			}
    654          	/*--mks cfg--begin MESH_BED_LEVELING */
    655          	
    656            }
   \                     ??apply_leveling_1: (+1)
   \      0x144   0xB00C             ADD      SP,SP,#+48
   \      0x146   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return

   \                                 In section .data, align 4
   \                     _ZN7Planner11abl_enabledE:
   \        0x0   0x00               DC8 0
   \        0x1   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   \                     _ZN7Planner13z_fade_heightE:
   \        0x4   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN7Planner21inverse_z_fade_heightE:
   \        0x8   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \        0xC   0x3F80'0000        DC32 3F800000H
   \       0x10   0xC479'C000        DC32 0C479C000H

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_2:
   \        0x0   0x0000'0000        DC32 0H, 0H, 0H
   \              0x0000'0000  
   \              0x0000'0000  
    657          

   \                                 In section .text, align 2, keep-with-next
    658            void Planner::unapply_leveling(float logical[XYZ]) {
   \                     _ZN7Planner16unapply_levelingEPf: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0xB094             SUB      SP,SP,#+80
    659          
    660              //#if HAS_ABL
    661          	if(BED_LEVELING_METHOD&HAS_ABL)
   \        0x4   0x....             LDR.N    R2,??DataTable13_11
   \        0x6   0x7815             LDRB     R5,[R2, #+0]
   \        0x8   0xF015 0x0F1E      TST      R5,#0x1E
   \        0xC   0xD003             BEQ.N    ??unapply_leveling_0
    662          		{
    663                if (!abl_enabled) return;
   \        0xE   0x....             LDR.N    R1,??DataTable13_12
   \       0x10   0x7809             LDRB     R1,[R1, #+0]
   \       0x12   0x2900             CMP      R1,#+0
   \       0x14   0xD077             BEQ.N    ??unapply_leveling_1
    664          		}
    665              //#endif
    666          
    667              #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
    668          	if((MACHINETPYE != DELTA) && (BED_LEVELING_METHOD&HAS_FADE))
   \                     ??unapply_leveling_0: (+1)
   \       0x16   0x4604             MOV      R4,R0
   \       0x18   0xF9B2 0x0018      LDRSH    R0,[R2, #+24]
   \       0x1C   0x2802             CMP      R0,#+2
   \       0x1E   0xD011             BEQ.N    ??unapply_leveling_2
   \       0x20   0x06E8             LSLS     R0,R5,#+27
   \       0x22   0xD50F             BPL.N    ??unapply_leveling_2
    669                if (z_fade_height && RAW_Z_POSITION(logical[Z_AXIS]) >= z_fade_height) return;
   \       0x24   0x....             LDR.N    R0,??DataTable13_12
   \       0x26   0x6846             LDR      R6,[R0, #+4]
   \       0x28   0x4630             MOV      R0,R6
   \       0x2A   0x2100             MOVS     R1,#+0
   \       0x2C   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0x30   0xD008             BEQ.N    ??unapply_leveling_2
   \       0x32   0x68A0             LDR      R0,[R4, #+8]
   \       0x34   0x....             LDR.N    R1,??DataTable13_13
   \       0x36   0x6889             LDR      R1,[R1, #+8]
   \       0x38   0x.... 0x....      BL       __aeabi_fsub
   \       0x3C   0x4631             MOV      R1,R6
   \       0x3E   0x.... 0x....      BL       __aeabi_cfrcmple
   \       0x42   0xD960             BLS.N    ??unapply_leveling_1
    670              #endif
    671          
    672          	/*--mks cfg--begin MESH_BED_LEVELING */
    673          /*
    674              #if ENABLED(MESH_BED_LEVELING)
    675          
    676                if (mbl.active()) {
    677                  #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
    678                    const float c = mbl.get_z(RAW_X_POSITION(logical[X_AXIS]), RAW_Y_POSITION(logical[Y_AXIS]), 1.0);
    679                    logical[Z_AXIS] = (z_fade_height * (RAW_Z_POSITION(logical[Z_AXIS]) - c)) / (z_fade_height - c);
    680                  #else
    681                    logical[Z_AXIS] -= mbl.get_z(RAW_X_POSITION(logical[X_AXIS]), RAW_Y_POSITION(logical[Y_AXIS]));
    682                  #endif
    683                }
    684          
    685              #elif ABL_PLANAR
    686          
    687                matrix_3x3 inverse = matrix_3x3::transpose(bed_level_matrix);
    688          
    689                float dx = RAW_X_POSITION(logical[X_AXIS]) - (X_TILT_FULCRUM),
    690                      dy = RAW_Y_POSITION(logical[Y_AXIS]) - (Y_TILT_FULCRUM),
    691                      dz = RAW_Z_POSITION(logical[Z_AXIS]);
    692          
    693                apply_rotation_xyz(inverse, dx, dy, dz);
    694          
    695                logical[X_AXIS] = LOGICAL_X_POSITION(dx + X_TILT_FULCRUM);
    696                logical[Y_AXIS] = LOGICAL_Y_POSITION(dy + Y_TILT_FULCRUM);
    697                logical[Z_AXIS] = LOGICAL_Z_POSITION(dz);
    698          
    699              #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
    700          
    701                #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
    702                  const float c = bilinear_z_offset(logical);
    703                  logical[Z_AXIS] = (z_fade_height * (RAW_Z_POSITION(logical[Z_AXIS]) - c)) / (z_fade_height - c);
    704                #else
    705                  logical[Z_AXIS] -= bilinear_z_offset(logical);
    706                #endif
    707          
    708              #endif
    709          */
    710          		if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
   \                     ??unapply_leveling_2: (+1)
   \       0x44   0x2D20             CMP      R5,#+32
   \       0x46   0xD118             BNE.N    ??unapply_leveling_3
    711          		{
    712          		if (mbl.active()) {
   \       0x48   0x.... 0x....      BL       _ZN17mesh_bed_leveling6activeEv
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD05A             BEQ.N    ??unapply_leveling_1
    713                                if((MACHINETPYE != DELTA) && (BED_LEVELING_METHOD&HAS_FADE))	//mks_delta
    714                                {
    715          						const float c = mbl.get_z(RAW_X_POSITION(logical[X_AXIS]), RAW_Y_POSITION(logical[Y_AXIS]), 1.0);
    716          						logical[Z_AXIS] = (z_fade_height * (RAW_Z_POSITION(logical[Z_AXIS]) - c)) / (z_fade_height - c);
    717                                }
    718          					  else
    719          					  	{
    720          						logical[Z_AXIS] -= mbl.get_z_mks(RAW_X_POSITION(logical[X_AXIS]), RAW_Y_POSITION(logical[Y_AXIS]));
   \       0x50   0x....             LDR.N    R5,??DataTable13_13
   \       0x52   0x6820             LDR      R0,[R4, #+0]
   \       0x54   0x6829             LDR      R1,[R5, #+0]
   \       0x56   0x.... 0x....      BL       __aeabi_fsub
   \       0x5A   0x9000             STR      R0,[SP, #+0]
   \       0x5C   0x6860             LDR      R0,[R4, #+4]
   \       0x5E   0x6869             LDR      R1,[R5, #+4]
   \       0x60   0x.... 0x....      BL       __aeabi_fsub
   \       0x64   0x9001             STR      R0,[SP, #+4]
   \       0x66   0xA901             ADD      R1,SP,#+4
   \       0x68   0x4668             MOV      R0,SP
   \       0x6A   0x.... 0x....      BL       _ZN17mesh_bed_leveling9get_z_mksERKfS1_
   \       0x6E   0x4601             MOV      R1,R0
   \       0x70   0x68A0             LDR      R0,[R4, #+8]
   \       0x72   0x.... 0x....      BL       __aeabi_fsub
   \       0x76   0x60A0             STR      R0,[R4, #+8]
   \       0x78   0xE045             B.N      ??unapply_leveling_1
    721          					  	}
    722          		}
    723          		
    724          		}
    725          	else if(BED_LEVELING_METHOD & ABL_PLANAR)
   \                     ??unapply_leveling_3: (+1)
   \       0x7A   0xF015 0x0F06      TST      R5,#0x6
   \       0x7E   0xD038             BEQ.N    ??unapply_leveling_4
    726          		{
    727          		matrix_3x3 inverse = matrix_3x3::transpose(bed_level_matrix);
   \       0x80   0x....             LDR.N    R1,??DataTable13_3
   \       0x82   0xB083             SUB      SP,SP,#+12
   \       0x84   0x4668             MOV      R0,SP
   \       0x86   0x2224             MOVS     R2,#+36
   \       0x88   0x.... 0x....      BL       __aeabi_memcpy4
   \       0x8C   0xBC0E             POP      {R1-R3}
   \       0x8E   0xA80B             ADD      R0,SP,#+44
   \       0x90   0x.... 0x....      BL       _ZN10matrix_3x39transposeES_
    728          		
    729          		float dx = RAW_X_POSITION(logical[X_AXIS]) - (X_TILT_FULCRUM),
   \       0x94   0x....             LDR.N    R5,??DataTable13_13
   \       0x96   0x6820             LDR      R0,[R4, #+0]
   \       0x98   0x6829             LDR      R1,[R5, #+0]
   \       0x9A   0x.... 0x....      BL       __aeabi_fsub
   \       0x9E   0x900A             STR      R0,[SP, #+40]
    730          			  dy = RAW_Y_POSITION(logical[Y_AXIS]) - (Y_TILT_FULCRUM),
   \       0xA0   0x6860             LDR      R0,[R4, #+4]
   \       0xA2   0x6869             LDR      R1,[R5, #+4]
   \       0xA4   0x.... 0x....      BL       __aeabi_fsub
   \       0xA8   0x9009             STR      R0,[SP, #+36]
    731          			  dz = RAW_Z_POSITION(logical[Z_AXIS]);
   \       0xAA   0x68A0             LDR      R0,[R4, #+8]
   \       0xAC   0x68A9             LDR      R1,[R5, #+8]
   \       0xAE   0x.... 0x....      BL       __aeabi_fsub
   \       0xB2   0x9008             STR      R0,[SP, #+32]
    732          		
    733          		apply_rotation_xyz(inverse, dx, dy, dz);
   \       0xB4   0xA808             ADD      R0,SP,#+32
   \       0xB6   0x9007             STR      R0,[SP, #+28]
   \       0xB8   0xA809             ADD      R0,SP,#+36
   \       0xBA   0x9006             STR      R0,[SP, #+24]
   \       0xBC   0xA80A             ADD      R0,SP,#+40
   \       0xBE   0x9005             STR      R0,[SP, #+20]
   \       0xC0   0xA90B             ADD      R1,SP,#+44
   \       0xC2   0xB084             SUB      SP,SP,#+16
   \       0xC4   0x4668             MOV      R0,SP
   \       0xC6   0x2224             MOVS     R2,#+36
   \       0xC8   0x.... 0x....      BL       __aeabi_memcpy4
   \       0xCC   0xBC0F             POP      {R0-R3}
   \       0xCE   0x.... 0x....      BL       _Z18apply_rotation_xyz10matrix_3x3RfS0_S0_
    734          		
    735          		logical[X_AXIS] = LOGICAL_X_POSITION(dx + X_TILT_FULCRUM);
   \       0xD2   0x990A             LDR      R1,[SP, #+40]
   \       0xD4   0x6828             LDR      R0,[R5, #+0]
   \       0xD6   0x.... 0x....      BL       __aeabi_fadd
   \       0xDA   0x6020             STR      R0,[R4, #+0]
    736          		logical[Y_AXIS] = LOGICAL_Y_POSITION(dy + Y_TILT_FULCRUM);
   \       0xDC   0x9909             LDR      R1,[SP, #+36]
   \       0xDE   0x6868             LDR      R0,[R5, #+4]
   \       0xE0   0x.... 0x....      BL       __aeabi_fadd
   \       0xE4   0x6060             STR      R0,[R4, #+4]
    737          		logical[Z_AXIS] = LOGICAL_Z_POSITION(dz);
   \       0xE6   0x9908             LDR      R1,[SP, #+32]
   \       0xE8   0x68A8             LDR      R0,[R5, #+8]
   \       0xEA   0x.... 0x....      BL       __aeabi_fadd
   \       0xEE   0x60A0             STR      R0,[R4, #+8]
   \       0xF0   0xE009             B.N      ??unapply_leveling_1
    738          		
    739          		}
    740          	else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
   \                     ??unapply_leveling_4: (+1)
   \       0xF2   0x2D08             CMP      R5,#+8
   \       0xF4   0xD107             BNE.N    ??unapply_leveling_1
    741          		{
    742          		//#if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
    743          		  if((MACHINETPYE != DELTA) && (BED_LEVELING_METHOD&HAS_FADE))	//mks_delta	
    744                            {
    745          		  const float c = bilinear_z_offset(logical);
    746          		  logical[Z_AXIS] = (z_fade_height * (RAW_Z_POSITION(logical[Z_AXIS]) - c)) / (z_fade_height - c);
    747          		  	}
    748          		//#else
    749          		else
    750          		  logical[Z_AXIS] -= bilinear_z_offset(logical);
   \       0xF6   0x4620             MOV      R0,R4
   \       0xF8   0x.... 0x....      BL       _Z17bilinear_z_offsetPKf
   \       0xFC   0x4601             MOV      R1,R0
   \       0xFE   0x68A0             LDR      R0,[R4, #+8]
   \      0x100   0x.... 0x....      BL       __aeabi_fsub
   \      0x104   0x60A0             STR      R0,[R4, #+8]
    751          		//#endif
    752          		
    753          		}
    754          	/*--mks cfg--end MESH_BED_LEVELING */
    755            }
   \                     ??unapply_leveling_1: (+1)
   \      0x106   0xB014             ADD      SP,SP,#+80
   \      0x108   0xBD70             POP      {R4-R6,PC}       ;; return
    756          
    757          #endif // PLANNER_LEVELING
    758          
    759          /**
    760           * Planner::_buffer_line
    761           *
    762           * Add a new linear movement to the buffer.
    763           *
    764           * Leveling and kinematics should be applied ahead of calling this.
    765           *
    766           *  a,b,c,e     - target positions in mm or degrees
    767           *  fr_mm_s     - (target) speed of the move
    768           *  extruder    - target extruder
    769           */

   \                                 In section .text, align 4, keep-with-next
    770          void Planner::_buffer_line(const float &a, const float &b, const float &c, const float &e, float fr_mm_s, const uint8_t extruder) {
   \                     _ZN7Planner12_buffer_lineERKfS1_S1_S1_fh: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB094             SUB      SP,SP,#+80
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4617             MOV      R7,R2
   \        0xA   0x461C             MOV      R4,R3
    771          
    772            // The target position of the tool in absolute steps
    773            // Calculate target position in absolute steps
    774            //this should be done after the wait, because otherwise a M92 code within the gcode disrupts this calculation somehow
    775            const long target[XYZE] = {
    776              lround(a * axis_steps_per_mm[X_AXIS]),
    777              lround(b * axis_steps_per_mm[Y_AXIS]),
    778              lround(c * axis_steps_per_mm[Z_AXIS]),
    779              lround(e * axis_steps_per_mm[E_AXIS_N])
    780            };
   \        0xC   0xF8DF 0x5C08      LDR.W    R5,??_buffer_line_0
   \       0x10   0x6801             LDR      R1,[R0, #+0]
   \       0x12   0x6868             LDR      R0,[R5, #+4]
   \       0x14   0x.... 0x....      BL       __aeabi_fmul
   \       0x18   0x.... 0x....      BL       lroundf
   \       0x1C   0x9010             STR      R0,[SP, #+64]
   \       0x1E   0x6831             LDR      R1,[R6, #+0]
   \       0x20   0x68A8             LDR      R0,[R5, #+8]
   \       0x22   0x.... 0x....      BL       __aeabi_fmul
   \       0x26   0x.... 0x....      BL       lroundf
   \       0x2A   0x4606             MOV      R6,R0
   \       0x2C   0xF10D 0x0840      ADD      R8,SP,#+64
   \       0x30   0xF8C8 0x6004      STR      R6,[R8, #+4]
   \       0x34   0x6839             LDR      R1,[R7, #+0]
   \       0x36   0x68E8             LDR      R0,[R5, #+12]
   \       0x38   0x.... 0x....      BL       __aeabi_fmul
   \       0x3C   0x.... 0x....      BL       lroundf
   \       0x40   0x4682             MOV      R10,R0
   \       0x42   0xF8C8 0xA008      STR      R10,[R8, #+8]
   \       0x46   0x6821             LDR      R1,[R4, #+0]
   \       0x48   0x6928             LDR      R0,[R5, #+16]
   \       0x4A   0x.... 0x....      BL       __aeabi_fmul
   \       0x4E   0x.... 0x....      BL       lroundf
   \       0x52   0x4607             MOV      R7,R0
   \       0x54   0xF8C8 0x700C      STR      R7,[R8, #+12]
    781          
    782            // When changing extruders recalculate steps corresponding to the E position
    783            #if ENABLED(DISTINCT_E_FACTORS)
    784              if (last_extruder != extruder && axis_steps_per_mm[E_AXIS_N] != axis_steps_per_mm[E_AXIS + last_extruder]) {
    785                position[E_AXIS] = lround(position[E_AXIS] * axis_steps_per_mm[E_AXIS_N] * steps_to_mm[E_AXIS + last_extruder]);
    786                last_extruder = extruder;
    787              }
    788            #endif
    789          
    790            #if ENABLED(LIN_ADVANCE)
    791              const float mm_D_float = sqrt(sq(a - position_float[X_AXIS]) + sq(b - position_float[Y_AXIS]));
    792            #endif
    793          
    794            const long da = target[X_AXIS] - position[X_AXIS],
   \       0x58   0x9810             LDR      R0,[SP, #+64]
   \       0x5A   0x6B6C             LDR      R4,[R5, #+52]
   \       0x5C   0x1B04             SUBS     R4,R0,R4
    795                       db = target[Y_AXIS] - position[Y_AXIS],
   \       0x5E   0xF8D5 0x8038      LDR      R8,[R5, #+56]
   \       0x62   0xEBA6 0x0808      SUB      R8,R6,R8
    796                       dc = target[Z_AXIS] - position[Z_AXIS];
   \       0x66   0xF8D5 0x903C      LDR      R9,[R5, #+60]
   \       0x6A   0xEBAA 0x0909      SUB      R9,R10,R9
    797          
    798            /*
    799            SERIAL_ECHOPAIR("  Planner FR:", fr_mm_s);
    800            SERIAL_CHAR(' ');
    801            #if IS_KINEMATIC
    802              SERIAL_ECHOPAIR("A:", a);
    803              SERIAL_ECHOPAIR(" (", da);
    804              SERIAL_ECHOPAIR(") B:", b);
    805            #else
    806              SERIAL_ECHOPAIR("X:", a);
    807              SERIAL_ECHOPAIR(" (", da);
    808              SERIAL_ECHOPAIR(") Y:", b);
    809            #endif
    810            SERIAL_ECHOPAIR(" (", db);
    811            #if ENABLED(DELTA)
    812              SERIAL_ECHOPAIR(") C:", c);
    813            #else
    814              SERIAL_ECHOPAIR(") Z:", c);
    815            #endif
    816            SERIAL_ECHOPAIR(" (", dc);
    817            SERIAL_CHAR(')');
    818            SERIAL_EOL;
    819            //*/
                    ^
Warning[Pe009]: nested comment is not allowed
    820          
    821            // DRYRUN ignores all temperature constraints and assures that the extruder is instantly satisfied
    822            if (DEBUGGING(DRYRUN)) {
   \       0x6E   0xF8DF 0x0C9C      LDR.W    R0,??_buffer_line_1
   \       0x72   0x7800             LDRB     R0,[R0, #+0]
   \       0x74   0x0700             LSLS     R0,R0,#+28
   \       0x76   0xD500             BPL.N    ??_buffer_line_2
    823              position[E_AXIS] = target[E_AXIS];
   \       0x78   0x642F             STR      R7,[R5, #+64]
    824              #if ENABLED(LIN_ADVANCE)
    825                position_float[E_AXIS] = e;
    826              #endif
    827            }
    828          
    829            long de = target[E_AXIS] - position[E_AXIS];
   \                     ??_buffer_line_2: (+1)
   \       0x7A   0x6C2E             LDR      R6,[R5, #+64]
   \       0x7C   0x1BBE             SUBS     R6,R7,R6
    830          
    831            #if ENABLED(LIN_ADVANCE)
    832              float de_float = e - position_float[E_AXIS];
    833            #endif
    834          
    835            #if ENABLED(PREVENT_COLD_EXTRUSION)
    836              if (de) {
   \       0x7E   0xD025             BEQ.N    ??_buffer_line_3
    837                if (thermalManager.tooColdToExtrude(extruder)) {
   \       0x80   0xF89D 0x007C      LDRB     R0,[SP, #+124]
   \       0x84   0x.... 0x....      BL       _ZN11Temperature16tooColdToExtrudeEh
   \       0x88   0x2800             CMP      R0,#+0
   \       0x8A   0xD009             BEQ.N    ??_buffer_line_4
    838                  position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
   \       0x8C   0x642F             STR      R7,[R5, #+64]
    839                  de = 0; // no difference
   \       0x8E   0x2600             MOVS     R6,#+0
    840                  #if ENABLED(LIN_ADVANCE)
    841                    position_float[E_AXIS] = e;
    842                    de_float = 0;
    843                  #endif
    844                  SERIAL_ECHO_START;
   \       0x90   0xF8DF 0x0C7C      LDR.W    R0,??_buffer_line_1+0x4
   \       0x94   0x.... 0x....      BL       _Z14serialprintPGMPKc
    845                  SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
   \       0x98   0xF8DF 0x0C78      LDR.W    R0,??_buffer_line_1+0x8
   \       0x9C   0x.... 0x....      BL       _Z14serialprintPGMPKc
    846                }
    847                #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
    848                  if (labs(de) > (int32_t)axis_steps_per_mm[E_AXIS_N] * (EXTRUDE_MAXLENGTH)) { // It's not important to get max. extrusion length in a precision < 1mm, so save some cycles and cast to int
   \                     ??_buffer_line_4: (+1)
   \       0xA0   0x4630             MOV      R0,R6
   \       0xA2   0x.... 0x....      BL       labs
   \       0xA6   0x4682             MOV      R10,R0
   \       0xA8   0x6928             LDR      R0,[R5, #+16]
   \       0xAA   0x.... 0x....      BL       __aeabi_f2iz
   \       0xAE   0xF44F 0x7196      MOV      R1,#+300
   \       0xB2   0x4348             MULS     R0,R1,R0
   \       0xB4   0x4550             CMP      R0,R10
   \       0xB6   0xDA09             BGE.N    ??_buffer_line_3
    849                    position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
   \       0xB8   0x642F             STR      R7,[R5, #+64]
    850                    de = 0; // no difference
   \       0xBA   0x2600             MOVS     R6,#+0
    851                    #if ENABLED(LIN_ADVANCE)
    852                      position_float[E_AXIS] = e;
    853                      de_float = 0;
    854                    #endif
    855                    SERIAL_ECHO_START;
   \       0xBC   0xF8DF 0x0C50      LDR.W    R0,??_buffer_line_1+0x4
   \       0xC0   0x.... 0x....      BL       _Z14serialprintPGMPKc
    856                    SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
   \       0xC4   0xF8DF 0x0C50      LDR.W    R0,??_buffer_line_1+0xC
   \       0xC8   0x.... 0x....      BL       _Z14serialprintPGMPKc
    857                  }
    858                #endif
    859              }
    860            #endif
    861          
    862            // Compute direction bit-mask for this block
    863            uint8_t dm = 0;
   \                     ??_buffer_line_3: (+1)
   \       0xCC   0x2500             MOVS     R5,#+0
    864            /*	//mks_delta
    865            #if CORE_IS_XY
    866              if (da < 0) SBI(dm, X_HEAD);                // Save the real Extruder (head) direction in X Axis
    867              if (db < 0) SBI(dm, Y_HEAD);                // ...and Y
    868              if (dc < 0) SBI(dm, Z_AXIS);
    869              if (da + db < 0) SBI(dm, A_AXIS);           // Motor A direction
    870              if (CORESIGN(da - db) < 0) SBI(dm, B_AXIS); // Motor B direction
    871            #elif CORE_IS_XZ
    872              if (da < 0) SBI(dm, X_HEAD);                // Save the real Extruder (head) direction in X Axis
    873              if (db < 0) SBI(dm, Y_AXIS);
    874              if (dc < 0) SBI(dm, Z_HEAD);                // ...and Z
    875              if (da + dc < 0) SBI(dm, A_AXIS);           // Motor A direction
    876              if (CORESIGN(da - dc) < 0) SBI(dm, C_AXIS); // Motor C direction
    877            #elif CORE_IS_YZ
    878              if (da < 0) SBI(dm, X_AXIS);
    879              if (db < 0) SBI(dm, Y_HEAD);                // Save the real Extruder (head) direction in Y Axis
    880              if (dc < 0) SBI(dm, Z_HEAD);                // ...and Z
    881              if (db + dc < 0) SBI(dm, B_AXIS);           // Motor B direction
    882              if (CORESIGN(db - dc) < 0) SBI(dm, C_AXIS); // Motor C direction
    883            #else
    884              if (da < 0) SBI(dm, X_AXIS);
    885              if (db < 0) SBI(dm, Y_AXIS);
    886              if (dc < 0) SBI(dm, Z_AXIS);
    887            #endif
    888          */
    889             if(MACHINETPYE & CORE_IS_XY)
   \       0xCE   0xF8DF 0x0C4C      LDR.W    R0,??_buffer_line_1+0x10
   \       0xD2   0xF8B0 0x0058      LDRH     R0,[R0, #+88]
   \       0xD6   0xF010 0x0F0C      TST      R0,#0xC
   \       0xDA   0xD01A             BEQ.N    ??_buffer_line_5
    890             	{
    891          	   if (da < 0) SBI(dm, X_HEAD); 			   // Save the real Extruder (head) direction in X Axis
   \       0xDC   0x2C00             CMP      R4,#+0
   \       0xDE   0xD500             BPL.N    ??_buffer_line_6
   \       0xE0   0x2510             MOVS     R5,#+16
    892          	   if (db < 0) SBI(dm, Y_HEAD); 			   // ...and Y
   \                     ??_buffer_line_6: (+1)
   \       0xE2   0xF1B8 0x0F00      CMP      R8,#+0
   \       0xE6   0xD501             BPL.N    ??_buffer_line_7
   \       0xE8   0xF045 0x0520      ORR      R5,R5,#0x20
    893          	   if (dc < 0) SBI(dm, Z_AXIS);
   \                     ??_buffer_line_7: (+1)
   \       0xEC   0xF1B9 0x0F00      CMP      R9,#+0
   \       0xF0   0xD501             BPL.N    ??_buffer_line_8
   \       0xF2   0xF045 0x0504      ORR      R5,R5,#0x4
    894          	   if (da + db < 0) SBI(dm, A_AXIS);		   // Motor A direction
   \                     ??_buffer_line_8: (+1)
   \       0xF6   0xEB18 0x0004      ADDS     R0,R8,R4
   \       0xFA   0xD501             BPL.N    ??_buffer_line_9
   \       0xFC   0xF045 0x0501      ORR      R5,R5,#0x1
    895          	   if (CORESIGN(da - db) < 0) SBI(dm, B_AXIS); // Motor B direction
   \                     ??_buffer_line_9: (+1)
   \      0x100   0xEBA4 0x0008      SUB      R0,R4,R8
   \      0x104   0x.... 0x....      BL       _ZN32_INTERNAL_11_planner_cpp_planner8CORESIGNEl
   \      0x108   0x2800             CMP      R0,#+0
   \      0x10A   0xD54B             BPL.N    ??_buffer_line_10
   \      0x10C   0xF045 0x0502      ORR      R5,R5,#0x2
   \      0x110   0xE048             B.N      ??_buffer_line_10
    896             	}
    897          	else if(MACHINETPYE & CORE_IS_XZ)
   \                     ??_buffer_line_5: (+1)
   \      0x112   0xF010 0x0F30      TST      R0,#0x30
   \      0x116   0xD01A             BEQ.N    ??_buffer_line_11
    898          		{
    899          		if (da < 0) SBI(dm, X_HEAD);				// Save the real Extruder (head) direction in X Axis
   \      0x118   0x2C00             CMP      R4,#+0
   \      0x11A   0xD500             BPL.N    ??_buffer_line_12
   \      0x11C   0x2510             MOVS     R5,#+16
    900          		if (db < 0) SBI(dm, Y_AXIS);
   \                     ??_buffer_line_12: (+1)
   \      0x11E   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x122   0xD501             BPL.N    ??_buffer_line_13
   \      0x124   0xF045 0x0502      ORR      R5,R5,#0x2
    901          		if (dc < 0) SBI(dm, Z_HEAD);				// ...and Z
   \                     ??_buffer_line_13: (+1)
   \      0x128   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x12C   0xD501             BPL.N    ??_buffer_line_14
   \      0x12E   0xF045 0x0540      ORR      R5,R5,#0x40
    902          		if (da + dc < 0) SBI(dm, A_AXIS);			// Motor A direction
   \                     ??_buffer_line_14: (+1)
   \      0x132   0xEB19 0x0004      ADDS     R0,R9,R4
   \      0x136   0xD501             BPL.N    ??_buffer_line_15
   \      0x138   0xF045 0x0501      ORR      R5,R5,#0x1
    903          		if (CORESIGN(da - dc) < 0) SBI(dm, C_AXIS); // Motor C direction
   \                     ??_buffer_line_15: (+1)
   \      0x13C   0xEBA4 0x0009      SUB      R0,R4,R9
   \      0x140   0x.... 0x....      BL       _ZN32_INTERNAL_11_planner_cpp_planner8CORESIGNEl
   \      0x144   0x2800             CMP      R0,#+0
   \      0x146   0xD52D             BPL.N    ??_buffer_line_10
   \      0x148   0xF045 0x0504      ORR      R5,R5,#0x4
   \      0x14C   0xE02A             B.N      ??_buffer_line_10
    904          		}
    905          	else if(MACHINETPYE & CORE_IS_YZ)
   \                     ??_buffer_line_11: (+1)
   \      0x14E   0xF010 0x0FC0      TST      R0,#0xC0
   \      0x152   0xD01A             BEQ.N    ??_buffer_line_16
    906          		{
    907          		if (da < 0) SBI(dm, X_AXIS);
   \      0x154   0x2C00             CMP      R4,#+0
   \      0x156   0xD500             BPL.N    ??_buffer_line_17
   \      0x158   0x2501             MOVS     R5,#+1
    908          		if (db < 0) SBI(dm, Y_HEAD);				// Save the real Extruder (head) direction in Y Axis
   \                     ??_buffer_line_17: (+1)
   \      0x15A   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x15E   0xD501             BPL.N    ??_buffer_line_18
   \      0x160   0xF045 0x0520      ORR      R5,R5,#0x20
    909          		if (dc < 0) SBI(dm, Z_HEAD);				// ...and Z
   \                     ??_buffer_line_18: (+1)
   \      0x164   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x168   0xD501             BPL.N    ??_buffer_line_19
   \      0x16A   0xF045 0x0540      ORR      R5,R5,#0x40
    910          		if (db + dc < 0) SBI(dm, B_AXIS);			// Motor B direction
   \                     ??_buffer_line_19: (+1)
   \      0x16E   0xEB19 0x0008      ADDS     R0,R9,R8
   \      0x172   0xD501             BPL.N    ??_buffer_line_20
   \      0x174   0xF045 0x0502      ORR      R5,R5,#0x2
    911          		if (CORESIGN(db - dc) < 0) SBI(dm, C_AXIS); // Motor C direction
   \                     ??_buffer_line_20: (+1)
   \      0x178   0xEBA8 0x0009      SUB      R0,R8,R9
   \      0x17C   0x.... 0x....      BL       _ZN32_INTERNAL_11_planner_cpp_planner8CORESIGNEl
   \      0x180   0x2800             CMP      R0,#+0
   \      0x182   0xD50F             BPL.N    ??_buffer_line_10
   \      0x184   0xF045 0x0504      ORR      R5,R5,#0x4
   \      0x188   0xE00C             B.N      ??_buffer_line_10
    912          		}
    913          	else
    914          		{
    915          		if (da < 0) SBI(dm, X_AXIS);
   \                     ??_buffer_line_16: (+1)
   \      0x18A   0x2C00             CMP      R4,#+0
   \      0x18C   0xD500             BPL.N    ??_buffer_line_21
   \      0x18E   0x2501             MOVS     R5,#+1
    916          		if (db < 0) SBI(dm, Y_AXIS);
   \                     ??_buffer_line_21: (+1)
   \      0x190   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x194   0xD501             BPL.N    ??_buffer_line_22
   \      0x196   0xF045 0x0502      ORR      R5,R5,#0x2
    917          		if (dc < 0) SBI(dm, Z_AXIS);
   \                     ??_buffer_line_22: (+1)
   \      0x19A   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x19E   0xD501             BPL.N    ??_buffer_line_10
   \      0x1A0   0xF045 0x0504      ORR      R5,R5,#0x4
    918          		}
    919            
    920            if (de < 0) SBI(dm, E_AXIS);
   \                     ??_buffer_line_10: (+1)
   \      0x1A4   0x2E00             CMP      R6,#+0
   \      0x1A6   0xD501             BPL.N    ??_buffer_line_23
   \      0x1A8   0xF045 0x0508      ORR      R5,R5,#0x8
    921          
    922            const float esteps_float = de * volumetric_multiplier[extruder] * flow_percentage[extruder] * 0.01;
   \                     ??_buffer_line_23: (+1)
   \      0x1AC   0xF89D 0x707C      LDRB     R7,[SP, #+124]
   \      0x1B0   0x4630             MOV      R0,R6
   \      0x1B2   0x.... 0x....      BL       __aeabi_i2f
   \      0x1B6   0x.... 0x....      LDR.W    R1,??DataTable14
   \      0x1BA   0xF851 0x1027      LDR      R1,[R1, R7, LSL #+2]
   \      0x1BE   0x.... 0x....      BL       __aeabi_fmul
   \      0x1C2   0x4606             MOV      R6,R0
   \      0x1C4   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \      0x1C8   0xF850 0x0027      LDR      R0,[R0, R7, LSL #+2]
   \      0x1CC   0x.... 0x....      BL       __aeabi_i2f
   \      0x1D0   0x4631             MOV      R1,R6
   \      0x1D2   0x.... 0x....      BL       __aeabi_fmul
   \      0x1D6   0x.... 0x....      BL       __aeabi_f2d
   \      0x1DA   0x.... 0x....      LDR.W    R2,??DataTable15  ;; 0x47ae147b
   \      0x1DE   0x.... 0x....      LDR.W    R3,??DataTable14_2  ;; 0x3f847ae1
   \      0x1E2   0x.... 0x....      BL       __aeabi_dmul
   \      0x1E6   0x.... 0x....      BL       __aeabi_d2f
   \      0x1EA   0x9001             STR      R0,[SP, #+4]
    923            const int32_t esteps = abs(esteps_float) + 0.5;
                                          ^
Warning[Pa093]: implicit conversion from floating point to integer
   \      0x1EC   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \      0x1F0   0x.... 0x....      BL       __aeabi_f2d
   \      0x1F4   0x2200             MOVS     R2,#+0
   \      0x1F6   0x.... 0x....      LDR.W    R3,??DataTable14_3  ;; 0x3fe00000
   \      0x1FA   0x.... 0x....      BL       __aeabi_dadd
   \      0x1FE   0x.... 0x....      BL       __aeabi_d2iz
   \      0x202   0x9000             STR      R0,[SP, #+0]
    924          
    925            // Calculate the buffer head after we push this byte
    926            const uint8_t next_buffer_head = next_block_index(block_buffer_head);
   \      0x204   0xF8DF 0x7A10      LDR.W    R7,??_buffer_line_0
   \      0x208   0xF997 0x0000      LDRSB    R0,[R7, #+0]
   \      0x20C   0x.... 0x....      BL       _ZN7Planner16next_block_indexEa
   \      0x210   0x4606             MOV      R6,R0
   \      0x212   0xB2F6             UXTB     R6,R6
   \      0x214   0xE002             B.N      ??_buffer_line_24
    927          
    928            // If the buffer is full: good! That means we are well ahead of the robot.
    929            // Rest here until there is room in the buffer.
    930            while (block_buffer_tail == next_buffer_head) idle();
   \                     ??_buffer_line_25: (+1)
   \      0x216   0x2000             MOVS     R0,#+0
   \      0x218   0x.... 0x....      BL       _Z4idleb
   \                     ??_buffer_line_24: (+1)
   \      0x21C   0x7878             LDRB     R0,[R7, #+1]
   \      0x21E   0x42B0             CMP      R0,R6
   \      0x220   0xD0F9             BEQ.N    ??_buffer_line_25
   \      0x222   0x960F             STR      R6,[SP, #+60]
    931          
    932            // Prepare to set up new block
    933            block_t* block = &block_buffer[block_buffer_head];
   \      0x224   0x463E             MOV      R6,R7
   \      0x226   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \      0x22A   0x7832             LDRB     R2,[R6, #+0]
   \      0x22C   0x2054             MOVS     R0,#+84
   \      0x22E   0x4342             MULS     R2,R0,R2
   \      0x230   0x188F             ADDS     R7,R1,R2
    934          
    935            block->cmd_id = cmd_queue_index_r_bak;
   \      0x232   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \      0x236   0x7800             LDRB     R0,[R0, #+0]
   \      0x238   0x7038             STRB     R0,[R7, #+0]
    936          
    937            // Clear all flags, including the "busy" bit
    938            block->flag = 0;
   \      0x23A   0x2000             MOVS     R0,#+0
   \      0x23C   0x7078             STRB     R0,[R7, #+1]
    939          
    940            // Set direction bits
    941            block->direction_bits = dm;
   \      0x23E   0xF107 0x0A24      ADD      R10,R7,#+36
   \      0x242   0xF88A 0x5000      STRB     R5,[R10, #+0]
    942          
    943            // Number of steps for each axis
    944            // See http://www.corexy.com/theory.html
    945            /*	//mks_delta
    946            #if CORE_IS_XY
    947              block->steps[A_AXIS] = labs(da + db);
    948              block->steps[B_AXIS] = labs(da - db);
    949              block->steps[Z_AXIS] = labs(dc);
    950            #elif CORE_IS_XZ
    951              block->steps[A_AXIS] = labs(da + dc);
    952              block->steps[Y_AXIS] = labs(db);
    953              block->steps[C_AXIS] = labs(da - dc);
    954            #elif CORE_IS_YZ
    955              block->steps[X_AXIS] = labs(da);
    956              block->steps[B_AXIS] = labs(db + dc);
    957              block->steps[C_AXIS] = labs(db - dc);
    958            #else
    959              // default non-h-bot planning
    960              block->steps[X_AXIS] = labs(da);
    961              block->steps[Y_AXIS] = labs(db);
    962              block->steps[Z_AXIS] = labs(dc);
    963            #endif
    964            */
    965            if(MACHINETPYE & CORE_IS_XY)
   \      0x246   0xF8DF 0x0AD4      LDR.W    R0,??_buffer_line_1+0x10
   \      0x24A   0xF8B0 0x0058      LDRH     R0,[R0, #+88]
   \      0x24E   0xF010 0x0F0C      TST      R0,#0xC
   \      0x252   0xD00E             BEQ.N    ??_buffer_line_26
    966            	{
    967          	  block->steps[A_AXIS] = labs(da + db);
   \      0x254   0xEB08 0x0004      ADD      R0,R8,R4
   \      0x258   0x.... 0x....      BL       labs
   \      0x25C   0x6078             STR      R0,[R7, #+4]
    968          	  block->steps[B_AXIS] = labs(da - db);
   \      0x25E   0xEBA4 0x0008      SUB      R0,R4,R8
   \      0x262   0x.... 0x....      BL       labs
   \      0x266   0x60B8             STR      R0,[R7, #+8]
    969          	  block->steps[Z_AXIS] = labs(dc);
   \      0x268   0x4648             MOV      R0,R9
   \      0x26A   0x.... 0x....      BL       labs
   \      0x26E   0x60F8             STR      R0,[R7, #+12]
   \      0x270   0xE02E             B.N      ??_buffer_line_27
    970            	}
    971            else if(MACHINETPYE & CORE_IS_XZ)
   \                     ??_buffer_line_26: (+1)
   \      0x272   0xF010 0x0F30      TST      R0,#0x30
   \      0x276   0xD00E             BEQ.N    ??_buffer_line_28
    972            	{
    973          	  block->steps[A_AXIS] = labs(da + dc);
   \      0x278   0xEB09 0x0004      ADD      R0,R9,R4
   \      0x27C   0x.... 0x....      BL       labs
   \      0x280   0x6078             STR      R0,[R7, #+4]
    974          	  block->steps[Y_AXIS] = labs(db);
   \      0x282   0x4640             MOV      R0,R8
   \      0x284   0x.... 0x....      BL       labs
   \      0x288   0x60B8             STR      R0,[R7, #+8]
    975          	  block->steps[C_AXIS] = labs(da - dc);
   \      0x28A   0xEBA4 0x0009      SUB      R0,R4,R9
   \      0x28E   0x.... 0x....      BL       labs
   \      0x292   0x60F8             STR      R0,[R7, #+12]
   \      0x294   0xE01C             B.N      ??_buffer_line_27
    976            	}
    977            else if(MACHINETPYE & CORE_IS_YZ)
   \                     ??_buffer_line_28: (+1)
   \      0x296   0xF010 0x0FC0      TST      R0,#0xC0
   \      0x29A   0x4620             MOV      R0,R4
   \      0x29C   0xD00D             BEQ.N    ??_buffer_line_29
    978            	{
    979          	  block->steps[X_AXIS] = labs(da);
   \      0x29E   0x.... 0x....      BL       labs
   \      0x2A2   0x6078             STR      R0,[R7, #+4]
    980          	  block->steps[B_AXIS] = labs(db + dc);
   \      0x2A4   0xEB09 0x0008      ADD      R0,R9,R8
   \      0x2A8   0x.... 0x....      BL       labs
   \      0x2AC   0x60B8             STR      R0,[R7, #+8]
    981          	  block->steps[C_AXIS] = labs(db - dc);
   \      0x2AE   0xEBA8 0x0009      SUB      R0,R8,R9
   \      0x2B2   0x.... 0x....      BL       labs
   \      0x2B6   0x60F8             STR      R0,[R7, #+12]
   \      0x2B8   0xE00A             B.N      ??_buffer_line_27
    982            	}
    983          	else
    984          	{
    985          		// default non-h-bot planning
    986          		block->steps[X_AXIS] = labs(da);
   \                     ??_buffer_line_29: (+1)
   \      0x2BA   0x.... 0x....      BL       labs
   \      0x2BE   0x6078             STR      R0,[R7, #+4]
    987          		block->steps[Y_AXIS] = labs(db);
   \      0x2C0   0x4640             MOV      R0,R8
   \      0x2C2   0x.... 0x....      BL       labs
   \      0x2C6   0x60B8             STR      R0,[R7, #+8]
    988          		block->steps[Z_AXIS] = labs(dc);
   \      0x2C8   0x4648             MOV      R0,R9
   \      0x2CA   0x.... 0x....      BL       labs
   \      0x2CE   0x60F8             STR      R0,[R7, #+12]
    989          	}
    990          
    991          
    992            block->steps[E_AXIS] = esteps;
   \                     ??_buffer_line_27: (+1)
   \      0x2D0   0x9800             LDR      R0,[SP, #+0]
   \      0x2D2   0x6138             STR      R0,[R7, #+16]
    993            block->step_event_count = MAX4(block->steps[X_AXIS], block->steps[Y_AXIS], block->steps[Z_AXIS], esteps);
   \      0x2D4   0x6878             LDR      R0,[R7, #+4]
   \      0x2D6   0x68B9             LDR      R1,[R7, #+8]
   \      0x2D8   0x4602             MOV      R2,R0
   \      0x2DA   0x460B             MOV      R3,R1
   \      0x2DC   0x429A             CMP      R2,R3
   \      0x2DE   0xDA00             BGE.N    ??_buffer_line_30
   \      0x2E0   0x461A             MOV      R2,R3
   \                     ??_buffer_line_30: (+1)
   \      0x2E2   0x68FB             LDR      R3,[R7, #+12]
   \      0x2E4   0x4293             CMP      R3,R2
   \      0x2E6   0xDA01             BGE.N    ??_buffer_line_31
   \      0x2E8   0x4615             MOV      R5,R2
   \      0x2EA   0xE000             B.N      ??_buffer_line_32
   \                     ??_buffer_line_31: (+1)
   \      0x2EC   0x461D             MOV      R5,R3
   \                     ??_buffer_line_32: (+1)
   \      0x2EE   0xF8DD 0xC000      LDR      R12,[SP, #+0]
   \      0x2F2   0x45AC             CMP      R12,R5
   \      0x2F4   0xDA07             BGE.N    ??_buffer_line_33
   \      0x2F6   0x4293             CMP      R3,R2
   \      0x2F8   0xDA03             BGE.N    ??_buffer_line_34
   \      0x2FA   0x4281             CMP      R1,R0
   \      0x2FC   0xDB04             BLT.N    ??_buffer_line_35
   \      0x2FE   0x4608             MOV      R0,R1
   \      0x300   0xE002             B.N      ??_buffer_line_35
   \                     ??_buffer_line_34: (+1)
   \      0x302   0x4618             MOV      R0,R3
   \      0x304   0xE000             B.N      ??_buffer_line_35
   \                     ??_buffer_line_33: (+1)
   \      0x306   0x4660             MOV      R0,R12
   \                     ??_buffer_line_35: (+1)
   \      0x308   0x6178             STR      R0,[R7, #+20]
    994          
    995            // Bail if this is a zero-length block
    996            if (block->step_event_count < MIN_STEPS_PER_SEGMENT) return;
   \      0x30A   0x2806             CMP      R0,#+6
   \      0x30C   0xF0C0 0x8556      BCC.W    ??_buffer_line_36
    997          
    998            // For a mixing extruder, get a magnified step_event_count for each
    999            #if ENABLED(MIXING_EXTRUDER)
   1000              for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
   1001                block->mix_event_count[i] = mixing_factor[i] * block->step_event_count;
   1002            #endif
   1003          
   1004            #if FAN_COUNT > 0
   1005              for (uint8_t i = 0; i < FAN_COUNT; i++) block->fan_speed[i] = fanSpeeds[i];
   \      0x310   0x2000             MOVS     R0,#+0
   \      0x312   0xE005             B.N      ??_buffer_line_37
   \                     ??_buffer_line_38: (+1)
   \      0x314   0x.... 0x....      LDR.W    R0,??DataTable18
   \      0x318   0x6800             LDR      R0,[R0, #+0]
   \      0x31A   0xF8AA 0x0028      STRH     R0,[R10, #+40]
   \      0x31E   0x2001             MOVS     R0,#+1
   \                     ??_buffer_line_37: (+1)
   \      0x320   0x2800             CMP      R0,#+0
   \      0x322   0xD0F7             BEQ.N    ??_buffer_line_38
   1006            #endif
   1007          
   1008            #if ENABLED(BARICUDA)
   1009              block->valve_pressure = baricuda_valve_pressure;
   1010              block->e_to_p_pressure = baricuda_e_to_p_pressure;
   1011            #endif
   1012          
   1013            block->active_extruder = extruder;
   \      0x324   0xF89D 0x007C      LDRB     R0,[SP, #+124]
   \      0x328   0x70B8             STRB     R0,[R7, #+2]
   1014          
   1015            //enable active axes
   1016          #if 0  
   1017            #if CORE_IS_XY
   1018              if (block->steps[A_AXIS] || block->steps[B_AXIS]) {
   1019                enable_X();
   1020                enable_Y();
   1021              }
   1022              #if DISABLED(Z_LATE_ENABLE)
   1023                if (block->steps[Z_AXIS]) enable_Z();
   1024              #endif
   1025            #elif CORE_IS_XZ
   1026              if (block->steps[A_AXIS] || block->steps[C_AXIS]) {
   1027                enable_X();
   1028                enable_Z();
   1029              }
   1030              if (block->steps[Y_AXIS]) enable_Y();
   1031            #elif CORE_IS_YZ
   1032              if (block->steps[B_AXIS] || block->steps[C_AXIS]) {
   1033                enable_Y();
   1034                enable_Z();
   1035              }
   1036              if (block->steps[X_AXIS]) enable_X();
   1037            #else
   1038              if (block->steps[X_AXIS]) enable_X();
   1039              if (block->steps[Y_AXIS]) enable_Y();
   1040              #if DISABLED(Z_LATE_ENABLE)
   1041                if (block->steps[Z_AXIS]) enable_Z();
   1042              #endif
   1043            #endif
   1044          #endif
   1045          
   1046            if(MACHINETPYE & CORE_IS_XY)
   \      0x32A   0xF8DF 0x09F0      LDR.W    R0,??_buffer_line_1+0x10
   \      0x32E   0xF8B0 0x0058      LDRH     R0,[R0, #+88]
   \      0x332   0xF010 0x0F0C      TST      R0,#0xC
   \      0x336   0xD016             BEQ.N    ??_buffer_line_39
   1047            	{
   1048          	  if (block->steps[A_AXIS] || block->steps[B_AXIS]) {
   \      0x338   0x6878             LDR      R0,[R7, #+4]
   \      0x33A   0x2800             CMP      R0,#+0
   \      0x33C   0xD102             BNE.N    ??_buffer_line_40
   \      0x33E   0x68B8             LDR      R0,[R7, #+8]
   \      0x340   0x2800             CMP      R0,#+0
   \      0x342   0xD062             BEQ.N    ??_buffer_line_41
   1049          		enable_X();
   \                     ??_buffer_line_40: (+1)
   \      0x344   0x.... 0x....      LDR.W    R5,??DataTable19
   \      0x348   0x.... 0x....      LDR.W    R11,??DataTable19_1
   \      0x34C   0x2200             MOVS     R2,#+0
   \      0x34E   0xF8BB 0x101C      LDRH     R1,[R11, #+28]
   \      0x352   0x6BA8             LDR      R0,[R5, #+56]
   \      0x354   0x.... 0x....      BL       HAL_GPIO_WritePin
   1050          		enable_Y();
   \      0x358   0x2200             MOVS     R2,#+0
   \      0x35A   0xF8BB 0x101C      LDRH     R1,[R11, #+28]
   \      0x35E   0x6BA8             LDR      R0,[R5, #+56]
   \      0x360   0x.... 0x....      BL       HAL_GPIO_WritePin
   \      0x364   0xE051             B.N      ??_buffer_line_41
   1051          	  }
   1052          	#if DISABLED(Z_LATE_ENABLE)
   1053          		if (block->steps[Z_AXIS]) enable_Z();
   1054          	#endif
   1055            	}
   1056            else if(MACHINETPYE & CORE_IS_XZ)
   \                     ??_buffer_line_39: (+1)
   \      0x366   0xF010 0x0F30      TST      R0,#0x30
   \      0x36A   0xD019             BEQ.N    ??_buffer_line_42
   1057            	{
   1058          	  if (block->steps[A_AXIS] || block->steps[C_AXIS]) {
   \      0x36C   0x6878             LDR      R0,[R7, #+4]
   \      0x36E   0x2800             CMP      R0,#+0
   \      0x370   0xD102             BNE.N    ??_buffer_line_43
   \      0x372   0x4618             MOV      R0,R3
   \      0x374   0x2800             CMP      R0,#+0
   \      0x376   0xD00F             BEQ.N    ??_buffer_line_44
   1059          		enable_X();
   \                     ??_buffer_line_43: (+1)
   \      0x378   0x.... 0x....      LDR.W    R5,??DataTable19
   \      0x37C   0x.... 0x....      LDR.W    R11,??DataTable19_1
   \      0x380   0x2200             MOVS     R2,#+0
   \      0x382   0xF8BB 0x101C      LDRH     R1,[R11, #+28]
   \      0x386   0x6BA8             LDR      R0,[R5, #+56]
   \      0x388   0x.... 0x....      BL       HAL_GPIO_WritePin
   1060          		enable_Z();
   \      0x38C   0x2200             MOVS     R2,#+0
   \      0x38E   0xF8BB 0x101C      LDRH     R1,[R11, #+28]
   \      0x392   0x6BA8             LDR      R0,[R5, #+56]
   \      0x394   0x.... 0x....      BL       HAL_GPIO_WritePin
   1061          	  }
   1062          	  if (block->steps[Y_AXIS]) enable_Y();
   \                     ??_buffer_line_44: (+1)
   \      0x398   0x68B8             LDR      R0,[R7, #+8]
   \      0x39A   0x2800             CMP      R0,#+0
   \      0x39C   0xD138             BNE.N    ??_buffer_line_45
   \      0x39E   0xE040             B.N      ??_buffer_line_46
   1063            	}
   1064            else if(MACHINETPYE & CORE_IS_YZ)
   \                     ??_buffer_line_42: (+1)
   \      0x3A0   0xF010 0x0FC0      TST      R0,#0xC0
   \      0x3A4   0xD019             BEQ.N    ??_buffer_line_47
   1065            	{
   1066          	  if (block->steps[B_AXIS] || block->steps[C_AXIS]) {
   \      0x3A6   0x68B8             LDR      R0,[R7, #+8]
   \      0x3A8   0x2800             CMP      R0,#+0
   \      0x3AA   0xD102             BNE.N    ??_buffer_line_48
   \      0x3AC   0x4618             MOV      R0,R3
   \      0x3AE   0x2800             CMP      R0,#+0
   \      0x3B0   0xD00F             BEQ.N    ??_buffer_line_49
   1067          		enable_Y();
   \                     ??_buffer_line_48: (+1)
   \      0x3B2   0x.... 0x....      LDR.W    R5,??DataTable19
   \      0x3B6   0x.... 0x....      LDR.W    R11,??DataTable19_1
   \      0x3BA   0x2200             MOVS     R2,#+0
   \      0x3BC   0xF8BB 0x101C      LDRH     R1,[R11, #+28]
   \      0x3C0   0x6BA8             LDR      R0,[R5, #+56]
   \      0x3C2   0x.... 0x....      BL       HAL_GPIO_WritePin
   1068          		enable_Z();
   \      0x3C6   0x2200             MOVS     R2,#+0
   \      0x3C8   0xF8BB 0x101C      LDRH     R1,[R11, #+28]
   \      0x3CC   0x6BA8             LDR      R0,[R5, #+56]
   \      0x3CE   0x.... 0x....      BL       HAL_GPIO_WritePin
   1069          	  }
   1070          	  if (block->steps[X_AXIS]) enable_X();
   \                     ??_buffer_line_49: (+1)
   \      0x3D2   0x6878             LDR      R0,[R7, #+4]
   \      0x3D4   0x2800             CMP      R0,#+0
   \      0x3D6   0xD11B             BNE.N    ??_buffer_line_45
   \      0x3D8   0xE023             B.N      ??_buffer_line_46
   1071            	}
   1072          	else
   1073          	{
   1074          		if (block->steps[X_AXIS]) enable_X();
   \                     ??_buffer_line_47: (+1)
   \      0x3DA   0x6878             LDR      R0,[R7, #+4]
   \      0x3DC   0x2800             CMP      R0,#+0
   \      0x3DE   0xD008             BEQ.N    ??_buffer_line_50
   \      0x3E0   0x2200             MOVS     R2,#+0
   \      0x3E2   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \      0x3E6   0x8B81             LDRH     R1,[R0, #+28]
   \      0x3E8   0x.... 0x....      LDR.W    R0,??DataTable19
   \      0x3EC   0x6B80             LDR      R0,[R0, #+56]
   \      0x3EE   0x.... 0x....      BL       HAL_GPIO_WritePin
   1075          		if (block->steps[Y_AXIS]) enable_Y();
   \                     ??_buffer_line_50: (+1)
   \      0x3F2   0x68B8             LDR      R0,[R7, #+8]
   \      0x3F4   0x2800             CMP      R0,#+0
   \      0x3F6   0xD008             BEQ.N    ??_buffer_line_41
   \      0x3F8   0x2200             MOVS     R2,#+0
   \      0x3FA   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \      0x3FE   0x8B81             LDRH     R1,[R0, #+28]
   \      0x400   0x.... 0x....      LDR.W    R0,??DataTable19
   \      0x404   0x6B80             LDR      R0,[R0, #+56]
   \      0x406   0x.... 0x....      BL       HAL_GPIO_WritePin
   1076          		#if DISABLED(Z_LATE_ENABLE)
   1077          		  if (block->steps[Z_AXIS]) enable_Z();
   \                     ??_buffer_line_41: (+1)
   \      0x40A   0x68F8             LDR      R0,[R7, #+12]
   \      0x40C   0x2800             CMP      R0,#+0
   \      0x40E   0xD008             BEQ.N    ??_buffer_line_46
   \                     ??_buffer_line_45: (+1)
   \      0x410   0x2200             MOVS     R2,#+0
   \      0x412   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \      0x416   0x8B81             LDRH     R1,[R0, #+28]
   \      0x418   0x.... 0x....      LDR.W    R0,??DataTable19
   \      0x41C   0x6B80             LDR      R0,[R0, #+56]
   \      0x41E   0x.... 0x....      BL       HAL_GPIO_WritePin
   1078          		#endif
   1079          	}
   1080          
   1081            // Enable extruder(s)
   1082            if (esteps) {
   \                     ??_buffer_line_46: (+1)
   \      0x422   0x9800             LDR      R0,[SP, #+0]
   \      0x424   0x2800             CMP      R0,#+0
   \      0x426   0xD01C             BEQ.N    ??_buffer_line_51
   1083          
   1084              #if ENABLED(DISABLE_INACTIVE_EXTRUDER) // Enable only the selected extruder
   1085          
   1086                #define DISABLE_IDLE_E(N) if (!g_uc_extruder_last_move[N]) disable_E##N();
   1087          
   1088                for (uint8_t i = 0; i < EXTRUDERS; i++)
   \      0x428   0x2000             MOVS     R0,#+0
   \      0x42A   0x.... 0x....      LDR.W    R1,??DataTable21
   \      0x42E   0xE005             B.N      ??_buffer_line_52
   1089                  if (g_uc_extruder_last_move[i] > 0) g_uc_extruder_last_move[i]--;
   \                     ??_buffer_line_53: (+1)
   \      0x430   0x7808             LDRB     R0,[R1, #+0]
   \      0x432   0x2800             CMP      R0,#+0
   \      0x434   0xD001             BEQ.N    ??_buffer_line_54
   \      0x436   0x1E40             SUBS     R0,R0,#+1
   \      0x438   0x7008             STRB     R0,[R1, #+0]
   \                     ??_buffer_line_54: (+1)
   \      0x43A   0x2001             MOVS     R0,#+1
   \                     ??_buffer_line_52: (+1)
   \      0x43C   0x2800             CMP      R0,#+0
   \      0x43E   0xD0F7             BEQ.N    ??_buffer_line_53
   1090          
   1091                switch(extruder) {
   \      0x440   0xF89D 0x007C      LDRB     R0,[SP, #+124]
   \      0x444   0x2800             CMP      R0,#+0
   \      0x446   0xD10C             BNE.N    ??_buffer_line_51
   1092                  case 0:
   1093                    enable_E0();
   \      0x448   0x2200             MOVS     R2,#+0
   \      0x44A   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \      0x44E   0x8F81             LDRH     R1,[R0, #+60]
   \      0x450   0x.... 0x....      LDR.W    R0,??DataTable19
   \      0x454   0x6F80             LDR      R0,[R0, #+120]
   \      0x456   0x.... 0x....      BL       HAL_GPIO_WritePin
   1094                    g_uc_extruder_last_move[0] = (BLOCK_BUFFER_SIZE) * 2;
   \      0x45A   0x2020             MOVS     R0,#+32
   \      0x45C   0x.... 0x....      LDR.W    R1,??DataTable21
   \      0x460   0x7008             STRB     R0,[R1, #+0]
   1095                    #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
   1096                      if (extruder_duplication_enabled) {
   1097                        enable_E1();
   1098                        g_uc_extruder_last_move[1] = (BLOCK_BUFFER_SIZE) * 2;
   1099                      }
   1100                    #endif
   1101                    #if EXTRUDERS > 1
   1102                      DISABLE_IDLE_E(1);
   1103                      #if EXTRUDERS > 2
   1104                        DISABLE_IDLE_E(2);
   1105                        #if EXTRUDERS > 3
   1106                          DISABLE_IDLE_E(3);
   1107                          #if EXTRUDERS > 4
   1108                            DISABLE_IDLE_E(4);
   1109                          #endif // EXTRUDERS > 4
   1110                        #endif // EXTRUDERS > 3
   1111                      #endif // EXTRUDERS > 2
   1112                    #endif // EXTRUDERS > 1
   1113                  break;
   1114                  #if EXTRUDERS > 1
   1115                    case 1:
   1116                      enable_E1();
   1117                      g_uc_extruder_last_move[1] = (BLOCK_BUFFER_SIZE) * 2;
   1118                      DISABLE_IDLE_E(0);
   1119                      #if EXTRUDERS > 2
   1120                        DISABLE_IDLE_E(2);
   1121                        #if EXTRUDERS > 3
   1122                          DISABLE_IDLE_E(3);
   1123                          #if EXTRUDERS > 4
   1124                            DISABLE_IDLE_E(4);
   1125                          #endif // EXTRUDERS > 4
   1126                        #endif // EXTRUDERS > 3
   1127                      #endif // EXTRUDERS > 2
   1128                    break;
   1129                    #if EXTRUDERS > 2
   1130                      case 2:
   1131                        enable_E2();
   1132                        g_uc_extruder_last_move[2] = (BLOCK_BUFFER_SIZE) * 2;
   1133                        DISABLE_IDLE_E(0);
   1134                        DISABLE_IDLE_E(1);
   1135                        #if EXTRUDERS > 3
   1136                          DISABLE_IDLE_E(3);
   1137                          #if EXTRUDERS > 4
   1138                            DISABLE_IDLE_E(4);
   1139                          #endif
   1140                        #endif
   1141                      break;
   1142                      #if EXTRUDERS > 3
   1143                        case 3:
   1144                          enable_E3();
   1145                          g_uc_extruder_last_move[3] = (BLOCK_BUFFER_SIZE) * 2;
   1146                          DISABLE_IDLE_E(0);
   1147                          DISABLE_IDLE_E(1);
   1148                          DISABLE_IDLE_E(2);
   1149                          #if EXTRUDERS > 4
   1150                            DISABLE_IDLE_E(4);
   1151                          #endif
   1152                        break;
   1153                        #if EXTRUDERS > 4
   1154                          case 4:
   1155                            enable_E4();
   1156                            g_uc_extruder_last_move[4] = (BLOCK_BUFFER_SIZE) * 2;
   1157                            DISABLE_IDLE_E(0);
   1158                            DISABLE_IDLE_E(1);
   1159                            DISABLE_IDLE_E(2);
   1160                            DISABLE_IDLE_E(3);
   1161                          break;
   1162                        #endif // EXTRUDERS > 4
   1163                      #endif // EXTRUDERS > 3
   1164                    #endif // EXTRUDERS > 2
   1165                  #endif // EXTRUDERS > 1
   1166                }
   1167              #else
   1168                enable_E0();
   1169                enable_E1();
   1170                enable_E2();
   1171                enable_E3();
   1172                enable_E4();
   1173              #endif
   1174            }
   1175          
   1176            if (esteps)
   \                     ??_buffer_line_51: (+1)
   \      0x462   0x9800             LDR      R0,[SP, #+0]
   \      0x464   0x2800             CMP      R0,#+0
   \      0x466   0x.... 0x....      LDR.W    R0,??DataTable21
   \      0x46A   0xD006             BEQ.N    ??_buffer_line_55
   1177              NOLESS(fr_mm_s, min_feedrate_mm_s);
   \      0x46C   0x6981             LDR      R1,[R0, #+24]
   \      0x46E   0x981E             LDR      R0,[SP, #+120]
   \      0x470   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x474   0xD207             BCS.N    ??_buffer_line_56
   \      0x476   0x911E             STR      R1,[SP, #+120]
   \      0x478   0xE005             B.N      ??_buffer_line_56
   1178            else
   1179              NOLESS(fr_mm_s, min_travel_feedrate_mm_s);
   \                     ??_buffer_line_55: (+1)
   \      0x47A   0x6B81             LDR      R1,[R0, #+56]
   \      0x47C   0x981E             LDR      R0,[SP, #+120]
   \      0x47E   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x482   0xD200             BCS.N    ??_buffer_line_56
   \      0x484   0x911E             STR      R1,[SP, #+120]
   1180          
   1181            /**
   1182             * This part of the code calculates the total length of the movement.
   1183             * For cartesian bots, the X_AXIS is the real X movement and same for Y_AXIS.
   1184             * But for corexy bots, that is not true. The "X_AXIS" and "Y_AXIS" motors (that should be named to A_AXIS
   1185             * and B_AXIS) cannot be used for X and Y length, because A=X+Y and B=X-Y.
   1186             * So we need to create other 2 "AXIS", named X_HEAD and Y_HEAD, meaning the real displacement of the Head.
   1187             * Having the real displacement of the head, we can calculate the total movement length and apply the desired speed.
   1188             */
   1189            //#if IS_CORE	//mks_delta
   1190              float delta_mm[Z_HEAD + 1];
   1191              //float delta_mm[XYZE];
   1192          
   1193            if(MACHINETPYE & IS_CORE) {
   \                     ??_buffer_line_56: (+1)
   \      0x486   0xF8DF 0x0894      LDR.W    R0,??_buffer_line_1+0x10
   \      0x48A   0xF8B0 0xB058      LDRH     R11,[R0, #+88]
   \      0x48E   0xF01B 0x0FFC      TST      R11,#0xFC
   \      0x492   0xF000 0x808B      BEQ.W    ??_buffer_line_57
   1194              //#if CORE_IS_XY
   1195          	if(MACHINETPYE & CORE_IS_XY) {
   \      0x496   0xF01B 0x0F0C      TST      R11,#0xC
   \      0x49A   0xD02A             BEQ.N    ??_buffer_line_58
   1196                delta_mm[X_HEAD] = da * steps_to_mm[A_AXIS];
   \      0x49C   0x4620             MOV      R0,R4
   \      0x49E   0x.... 0x....      BL       __aeabi_i2f
   \      0x4A2   0x6971             LDR      R1,[R6, #+20]
   \      0x4A4   0x.... 0x....      BL       __aeabi_fmul
   \      0x4A8   0x900B             STR      R0,[SP, #+44]
   1197                delta_mm[Y_HEAD] = db * steps_to_mm[B_AXIS];
   \      0x4AA   0x4630             MOV      R0,R6
   \      0x4AC   0x6985             LDR      R5,[R0, #+24]
   \      0x4AE   0x4640             MOV      R0,R8
   \      0x4B0   0x.... 0x....      BL       __aeabi_i2f
   \      0x4B4   0x4629             MOV      R1,R5
   \      0x4B6   0x.... 0x....      BL       __aeabi_fmul
   \      0x4BA   0x900C             STR      R0,[SP, #+48]
   1198                delta_mm[Z_AXIS] = dc * steps_to_mm[Z_AXIS];
   \      0x4BC   0x4648             MOV      R0,R9
   \      0x4BE   0x.... 0x....      BL       __aeabi_i2f
   \      0x4C2   0x69F1             LDR      R1,[R6, #+28]
   \      0x4C4   0x.... 0x....      BL       __aeabi_fmul
   \      0x4C8   0x9009             STR      R0,[SP, #+36]
   1199                delta_mm[A_AXIS] = (da + db) * steps_to_mm[A_AXIS];
   \      0x4CA   0xEB08 0x0004      ADD      R0,R8,R4
   \      0x4CE   0x.... 0x....      BL       __aeabi_i2f
   \      0x4D2   0x6971             LDR      R1,[R6, #+20]
   \      0x4D4   0x.... 0x....      BL       __aeabi_fmul
   \      0x4D8   0x9007             STR      R0,[SP, #+28]
   1200                delta_mm[B_AXIS] = CORESIGN(da - db) * steps_to_mm[B_AXIS];}
   \      0x4DA   0xEBA4 0x0408      SUB      R4,R4,R8
   \      0x4DE   0x4620             MOV      R0,R4
   \      0x4E0   0x.... 0x....      BL       _ZN32_INTERNAL_11_planner_cpp_planner8CORESIGNEl
   \      0x4E4   0x.... 0x....      BL       __aeabi_i2f
   \      0x4E8   0x4629             MOV      R1,R5
   \      0x4EA   0x.... 0x....      BL       __aeabi_fmul
   \      0x4EE   0x9008             STR      R0,[SP, #+32]
   \      0x4F0   0xE072             B.N      ??_buffer_line_59
   1201              //#elif CORE_IS_XZ
   1202              else if(MACHINETPYE & CORE_IS_XZ) {
   \                     ??_buffer_line_58: (+1)
   \      0x4F2   0xF01B 0x0F30      TST      R11,#0x30
   \      0x4F6   0xD02B             BEQ.N    ??_buffer_line_60
   1203                delta_mm[X_HEAD] = da * steps_to_mm[A_AXIS];
   \      0x4F8   0xAD07             ADD      R5,SP,#+28
   \      0x4FA   0x4620             MOV      R0,R4
   \      0x4FC   0x.... 0x....      BL       __aeabi_i2f
   \      0x500   0x6971             LDR      R1,[R6, #+20]
   \      0x502   0x.... 0x....      BL       __aeabi_fmul
   \      0x506   0x6128             STR      R0,[R5, #+16]
   1204                delta_mm[Y_AXIS] = db * steps_to_mm[Y_AXIS];
   \      0x508   0x4640             MOV      R0,R8
   \      0x50A   0x.... 0x....      BL       __aeabi_i2f
   \      0x50E   0x69B1             LDR      R1,[R6, #+24]
   \      0x510   0x.... 0x....      BL       __aeabi_fmul
   \      0x514   0x6068             STR      R0,[R5, #+4]
   1205                delta_mm[Z_HEAD] = dc * steps_to_mm[C_AXIS];
   \      0x516   0xF8D6 0x801C      LDR      R8,[R6, #+28]
   \      0x51A   0x4648             MOV      R0,R9
   \      0x51C   0x.... 0x....      BL       __aeabi_i2f
   \      0x520   0x4641             MOV      R1,R8
   \      0x522   0x.... 0x....      BL       __aeabi_fmul
   \      0x526   0x61A8             STR      R0,[R5, #+24]
   1206                delta_mm[A_AXIS] = (da + dc) * steps_to_mm[A_AXIS];
   \      0x528   0xEB09 0x0004      ADD      R0,R9,R4
   \      0x52C   0x.... 0x....      BL       __aeabi_i2f
   \      0x530   0x6971             LDR      R1,[R6, #+20]
   \      0x532   0x.... 0x....      BL       __aeabi_fmul
   \      0x536   0x9007             STR      R0,[SP, #+28]
   1207                delta_mm[C_AXIS] = CORESIGN(da - dc) * steps_to_mm[C_AXIS]; }
   \      0x538   0xEBA4 0x0409      SUB      R4,R4,R9
   \      0x53C   0x4620             MOV      R0,R4
   \      0x53E   0x.... 0x....      BL       _ZN32_INTERNAL_11_planner_cpp_planner8CORESIGNEl
   \      0x542   0x.... 0x....      BL       __aeabi_i2f
   \      0x546   0x4641             MOV      R1,R8
   \      0x548   0x.... 0x....      BL       __aeabi_fmul
   \      0x54C   0x60A8             STR      R0,[R5, #+8]
   \      0x54E   0xE043             B.N      ??_buffer_line_59
   1208              //#elif CORE_IS_YZ
   1209              else if(MACHINETPYE & CORE_IS_YZ) {
   \                     ??_buffer_line_60: (+1)
   \      0x550   0xF01B 0x0FC0      TST      R11,#0xC0
   \      0x554   0xD040             BEQ.N    ??_buffer_line_59
   1210                delta_mm[X_AXIS] = da * steps_to_mm[X_AXIS];
   \      0x556   0x4620             MOV      R0,R4
   \      0x558   0x.... 0x....      BL       __aeabi_i2f
   \      0x55C   0x6971             LDR      R1,[R6, #+20]
   \      0x55E   0x.... 0x....      BL       __aeabi_fmul
   \      0x562   0x9007             STR      R0,[SP, #+28]
   1211                delta_mm[Y_HEAD] = db * steps_to_mm[B_AXIS];
   \      0x564   0xAD07             ADD      R5,SP,#+28
   \      0x566   0x4640             MOV      R0,R8
   \      0x568   0x.... 0x....      BL       __aeabi_i2f
   \      0x56C   0x69B1             LDR      R1,[R6, #+24]
   \      0x56E   0x.... 0x....      BL       __aeabi_fmul
   \      0x572   0x6168             STR      R0,[R5, #+20]
   1212                delta_mm[Z_HEAD] = dc * steps_to_mm[C_AXIS];
   \      0x574   0x69F4             LDR      R4,[R6, #+28]
   \      0x576   0x4648             MOV      R0,R9
   \      0x578   0x.... 0x....      BL       __aeabi_i2f
   \      0x57C   0x4621             MOV      R1,R4
   \      0x57E   0x.... 0x....      BL       __aeabi_fmul
   \      0x582   0x61A8             STR      R0,[R5, #+24]
   1213                delta_mm[B_AXIS] = (db + dc) * steps_to_mm[B_AXIS];
   \      0x584   0xEB09 0x0008      ADD      R0,R9,R8
   \      0x588   0x.... 0x....      BL       __aeabi_i2f
   \      0x58C   0x69B1             LDR      R1,[R6, #+24]
   \      0x58E   0x.... 0x....      BL       __aeabi_fmul
   \      0x592   0x6068             STR      R0,[R5, #+4]
   1214                delta_mm[C_AXIS] = CORESIGN(db - dc) * steps_to_mm[C_AXIS]; }
   \      0x594   0xEBA8 0x0809      SUB      R8,R8,R9
   \      0x598   0x4640             MOV      R0,R8
   \      0x59A   0x.... 0x....      BL       _ZN32_INTERNAL_11_planner_cpp_planner8CORESIGNEl
   \      0x59E   0x.... 0x....      BL       __aeabi_i2f
   \      0x5A2   0x4621             MOV      R1,R4
   \      0x5A4   0x.... 0x....      BL       __aeabi_fmul
   \      0x5A8   0x60A8             STR      R0,[R5, #+8]
   \      0x5AA   0xE015             B.N      ??_buffer_line_59
   1215              //#endif
   1216            	}
   1217            //#else
   1218            else {
   1219              delta_mm[X_AXIS] = da * steps_to_mm[X_AXIS];
   \                     ??_buffer_line_57: (+1)
   \      0x5AC   0x4620             MOV      R0,R4
   \      0x5AE   0x.... 0x....      BL       __aeabi_i2f
   \      0x5B2   0x6971             LDR      R1,[R6, #+20]
   \      0x5B4   0x.... 0x....      BL       __aeabi_fmul
   \      0x5B8   0x9007             STR      R0,[SP, #+28]
   1220              delta_mm[Y_AXIS] = db * steps_to_mm[Y_AXIS];
   \      0x5BA   0xAC07             ADD      R4,SP,#+28
   \      0x5BC   0x4640             MOV      R0,R8
   \      0x5BE   0x.... 0x....      BL       __aeabi_i2f
   \      0x5C2   0x69B1             LDR      R1,[R6, #+24]
   \      0x5C4   0x.... 0x....      BL       __aeabi_fmul
   \      0x5C8   0x6060             STR      R0,[R4, #+4]
   1221              delta_mm[Z_AXIS] = dc * steps_to_mm[Z_AXIS];
   \      0x5CA   0x4648             MOV      R0,R9
   \      0x5CC   0x.... 0x....      BL       __aeabi_i2f
   \      0x5D0   0x69F1             LDR      R1,[R6, #+28]
   \      0x5D2   0x.... 0x....      BL       __aeabi_fmul
   \      0x5D6   0x60A0             STR      R0,[R4, #+8]
   1222            }	//#endif
   1223            delta_mm[E_AXIS] = esteps_float * steps_to_mm[E_AXIS_N];
   \                     ??_buffer_line_59: (+1)
   \      0x5D8   0x9901             LDR      R1,[SP, #+4]
   \      0x5DA   0x6A30             LDR      R0,[R6, #+32]
   \      0x5DC   0x.... 0x....      BL       __aeabi_fmul
   \      0x5E0   0x900A             STR      R0,[SP, #+40]
   1224          
   1225            if (block->steps[X_AXIS] < MIN_STEPS_PER_SEGMENT && block->steps[Y_AXIS] < MIN_STEPS_PER_SEGMENT && block->steps[Z_AXIS] < MIN_STEPS_PER_SEGMENT) {
   \      0x5E2   0x6879             LDR      R1,[R7, #+4]
   \      0x5E4   0x2906             CMP      R1,#+6
   \      0x5E6   0xDA0A             BGE.N    ??_buffer_line_61
   \      0x5E8   0x68B9             LDR      R1,[R7, #+8]
   \      0x5EA   0x2906             CMP      R1,#+6
   \      0x5EC   0xDA07             BGE.N    ??_buffer_line_61
   \      0x5EE   0x68F9             LDR      R1,[R7, #+12]
   \      0x5F0   0x2906             CMP      R1,#+6
   \      0x5F2   0xDA04             BGE.N    ??_buffer_line_61
   1226              block->millimeters = fabs(delta_mm[E_AXIS]);
   \      0x5F4   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \      0x5F8   0xF8CA 0x0010      STR      R0,[R10, #+16]
   \      0x5FC   0xE11B             B.N      ??_buffer_line_62
   1227            }
   1228            else {
   1229            	/*	//mks_delta
   1230              block->millimeters = sqrt(
   1231                #if CORE_IS_XY
   1232                  sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_AXIS])
   1233                #elif CORE_IS_XZ
   1234                  sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_HEAD])
   1235                #elif CORE_IS_YZ
   1236                  sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_HEAD])
   1237                #else
   1238                  sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_AXIS])
   1239                #endif
   1240              );
   1241          	*/
   1242          	if(MACHINETPYE & CORE_IS_XY)
   \                     ??_buffer_line_61: (+1)
   \      0x5FE   0xF04F 0x557E      MOV      R5,#+1065353216
   \      0x602   0xF01B 0x0F0C      TST      R11,#0xC
   \      0x606   0xD044             BEQ.N    ??_buffer_line_63
   1243          		block->millimeters = sqrt(sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_AXIS]));
   \      0x608   0xF8DD 0x902C      LDR      R9,[SP, #+44]
   \      0x60C   0x2402             MOVS     R4,#+2
   \      0x60E   0x46A8             MOV      R8,R5
   \      0x610   0xE004             B.N      ??_buffer_line_64
   \                     ??_buffer_line_65: (+1)
   \      0x612   0x4648             MOV      R0,R9
   \      0x614   0x4649             MOV      R1,R9
   \      0x616   0x.... 0x....      BL       __aeabi_fmul
   \      0x61A   0x4681             MOV      R9,R0
   \                     ??_buffer_line_64: (+1)
   \      0x61C   0x07E0             LSLS     R0,R4,#+31
   \      0x61E   0xD504             BPL.N    ??_buffer_line_66
   \      0x620   0x4640             MOV      R0,R8
   \      0x622   0x4649             MOV      R1,R9
   \      0x624   0x.... 0x....      BL       __aeabi_fmul
   \      0x628   0x4680             MOV      R8,R0
   \                     ??_buffer_line_66: (+1)
   \      0x62A   0x0864             LSRS     R4,R4,#+1
   \      0x62C   0xD1F1             BNE.N    ??_buffer_line_65
   \      0x62E   0xF8DD 0xB030      LDR      R11,[SP, #+48]
   \      0x632   0x2402             MOVS     R4,#+2
   \      0x634   0x46A9             MOV      R9,R5
   \      0x636   0xE004             B.N      ??_buffer_line_67
   \                     ??_buffer_line_68: (+1)
   \      0x638   0x4658             MOV      R0,R11
   \      0x63A   0x4659             MOV      R1,R11
   \      0x63C   0x.... 0x....      BL       __aeabi_fmul
   \      0x640   0x4683             MOV      R11,R0
   \                     ??_buffer_line_67: (+1)
   \      0x642   0x07E0             LSLS     R0,R4,#+31
   \      0x644   0xD504             BPL.N    ??_buffer_line_69
   \      0x646   0x4648             MOV      R0,R9
   \      0x648   0x4659             MOV      R1,R11
   \      0x64A   0x.... 0x....      BL       __aeabi_fmul
   \      0x64E   0x4681             MOV      R9,R0
   \                     ??_buffer_line_69: (+1)
   \      0x650   0x0864             LSRS     R4,R4,#+1
   \      0x652   0xD1F1             BNE.N    ??_buffer_line_68
   \      0x654   0x9809             LDR      R0,[SP, #+36]
   \      0x656   0x2402             MOVS     R4,#+2
   \      0x658   0x46AB             MOV      R11,R5
   \      0x65A   0x4605             MOV      R5,R0
   \      0x65C   0xE004             B.N      ??_buffer_line_70
   \                     ??_buffer_line_71: (+1)
   \      0x65E   0x4628             MOV      R0,R5
   \      0x660   0x4629             MOV      R1,R5
   \      0x662   0x.... 0x....      BL       __aeabi_fmul
   \      0x666   0x4605             MOV      R5,R0
   \                     ??_buffer_line_70: (+1)
   \      0x668   0x07E0             LSLS     R0,R4,#+31
   \      0x66A   0xD504             BPL.N    ??_buffer_line_72
   \      0x66C   0x4658             MOV      R0,R11
   \      0x66E   0x4629             MOV      R1,R5
   \      0x670   0x.... 0x....      BL       __aeabi_fmul
   \      0x674   0x4683             MOV      R11,R0
   \                     ??_buffer_line_72: (+1)
   \      0x676   0x0864             LSRS     R4,R4,#+1
   \      0x678   0xD1F1             BNE.N    ??_buffer_line_71
   \      0x67A   0x4640             MOV      R0,R8
   \      0x67C   0x4649             MOV      R1,R9
   \      0x67E   0x.... 0x....      BL       __aeabi_fadd
   \      0x682   0x4659             MOV      R1,R11
   \      0x684   0x.... 0x....      BL       __aeabi_fadd
   \      0x688   0x.... 0x....      BL       sqrtf
   \      0x68C   0xF8CA 0x0010      STR      R0,[R10, #+16]
   \      0x690   0xE0D1             B.N      ??_buffer_line_62
   1244          	else if	(MACHINETPYE & CORE_IS_XZ)
   \                     ??_buffer_line_63: (+1)
   \      0x692   0xF01B 0x0F30      TST      R11,#0x30
   \      0x696   0xD044             BEQ.N    ??_buffer_line_73
   1245          		block->millimeters = sqrt(sq(delta_mm[X_HEAD]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_HEAD]));
   \      0x698   0xF8DD 0x902C      LDR      R9,[SP, #+44]
   \      0x69C   0x2402             MOVS     R4,#+2
   \      0x69E   0x46A8             MOV      R8,R5
   \      0x6A0   0xE004             B.N      ??_buffer_line_74
   \                     ??_buffer_line_75: (+1)
   \      0x6A2   0x4648             MOV      R0,R9
   \      0x6A4   0x4649             MOV      R1,R9
   \      0x6A6   0x.... 0x....      BL       __aeabi_fmul
   \      0x6AA   0x4681             MOV      R9,R0
   \                     ??_buffer_line_74: (+1)
   \      0x6AC   0x07E0             LSLS     R0,R4,#+31
   \      0x6AE   0xD504             BPL.N    ??_buffer_line_76
   \      0x6B0   0x4640             MOV      R0,R8
   \      0x6B2   0x4649             MOV      R1,R9
   \      0x6B4   0x.... 0x....      BL       __aeabi_fmul
   \      0x6B8   0x4680             MOV      R8,R0
   \                     ??_buffer_line_76: (+1)
   \      0x6BA   0x0864             LSRS     R4,R4,#+1
   \      0x6BC   0xD1F1             BNE.N    ??_buffer_line_75
   \      0x6BE   0xF8DD 0xB020      LDR      R11,[SP, #+32]
   \      0x6C2   0x2402             MOVS     R4,#+2
   \      0x6C4   0x46A9             MOV      R9,R5
   \      0x6C6   0xE004             B.N      ??_buffer_line_77
   \                     ??_buffer_line_78: (+1)
   \      0x6C8   0x4658             MOV      R0,R11
   \      0x6CA   0x4659             MOV      R1,R11
   \      0x6CC   0x.... 0x....      BL       __aeabi_fmul
   \      0x6D0   0x4683             MOV      R11,R0
   \                     ??_buffer_line_77: (+1)
   \      0x6D2   0x07E0             LSLS     R0,R4,#+31
   \      0x6D4   0xD504             BPL.N    ??_buffer_line_79
   \      0x6D6   0x4648             MOV      R0,R9
   \      0x6D8   0x4659             MOV      R1,R11
   \      0x6DA   0x.... 0x....      BL       __aeabi_fmul
   \      0x6DE   0x4681             MOV      R9,R0
   \                     ??_buffer_line_79: (+1)
   \      0x6E0   0x0864             LSRS     R4,R4,#+1
   \      0x6E2   0xD1F1             BNE.N    ??_buffer_line_78
   \      0x6E4   0x980D             LDR      R0,[SP, #+52]
   \      0x6E6   0x2402             MOVS     R4,#+2
   \      0x6E8   0x46AB             MOV      R11,R5
   \      0x6EA   0x4605             MOV      R5,R0
   \      0x6EC   0xE004             B.N      ??_buffer_line_80
   \                     ??_buffer_line_81: (+1)
   \      0x6EE   0x4628             MOV      R0,R5
   \      0x6F0   0x4629             MOV      R1,R5
   \      0x6F2   0x.... 0x....      BL       __aeabi_fmul
   \      0x6F6   0x4605             MOV      R5,R0
   \                     ??_buffer_line_80: (+1)
   \      0x6F8   0x07E0             LSLS     R0,R4,#+31
   \      0x6FA   0xD504             BPL.N    ??_buffer_line_82
   \      0x6FC   0x4658             MOV      R0,R11
   \      0x6FE   0x4629             MOV      R1,R5
   \      0x700   0x.... 0x....      BL       __aeabi_fmul
   \      0x704   0x4683             MOV      R11,R0
   \                     ??_buffer_line_82: (+1)
   \      0x706   0x0864             LSRS     R4,R4,#+1
   \      0x708   0xD1F1             BNE.N    ??_buffer_line_81
   \      0x70A   0x4640             MOV      R0,R8
   \      0x70C   0x4649             MOV      R1,R9
   \      0x70E   0x.... 0x....      BL       __aeabi_fadd
   \      0x712   0x4659             MOV      R1,R11
   \      0x714   0x.... 0x....      BL       __aeabi_fadd
   \      0x718   0x.... 0x....      BL       sqrtf
   \      0x71C   0xF8CA 0x0010      STR      R0,[R10, #+16]
   \      0x720   0xE089             B.N      ??_buffer_line_62
   1246          	else if (MACHINETPYE & CORE_IS_YZ)
   \                     ??_buffer_line_73: (+1)
   \      0x722   0xF01B 0x0FC0      TST      R11,#0xC0
   \      0x726   0xF8DD 0x901C      LDR      R9,[SP, #+28]
   \      0x72A   0xD042             BEQ.N    ??_buffer_line_83
   1247          		block->millimeters = sqrt(sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_HEAD]) + sq(delta_mm[Z_HEAD]));
   \      0x72C   0x2402             MOVS     R4,#+2
   \      0x72E   0x46A8             MOV      R8,R5
   \      0x730   0xE004             B.N      ??_buffer_line_84
   \                     ??_buffer_line_85: (+1)
   \      0x732   0x4648             MOV      R0,R9
   \      0x734   0x4649             MOV      R1,R9
   \      0x736   0x.... 0x....      BL       __aeabi_fmul
   \      0x73A   0x4681             MOV      R9,R0
   \                     ??_buffer_line_84: (+1)
   \      0x73C   0x07E0             LSLS     R0,R4,#+31
   \      0x73E   0xD504             BPL.N    ??_buffer_line_86
   \      0x740   0x4640             MOV      R0,R8
   \      0x742   0x4649             MOV      R1,R9
   \      0x744   0x.... 0x....      BL       __aeabi_fmul
   \      0x748   0x4680             MOV      R8,R0
   \                     ??_buffer_line_86: (+1)
   \      0x74A   0x0864             LSRS     R4,R4,#+1
   \      0x74C   0xD1F1             BNE.N    ??_buffer_line_85
   \      0x74E   0xF8DD 0xB030      LDR      R11,[SP, #+48]
   \      0x752   0x2402             MOVS     R4,#+2
   \      0x754   0x46A9             MOV      R9,R5
   \      0x756   0xE004             B.N      ??_buffer_line_87
   \                     ??_buffer_line_88: (+1)
   \      0x758   0x4658             MOV      R0,R11
   \      0x75A   0x4659             MOV      R1,R11
   \      0x75C   0x.... 0x....      BL       __aeabi_fmul
   \      0x760   0x4683             MOV      R11,R0
   \                     ??_buffer_line_87: (+1)
   \      0x762   0x07E0             LSLS     R0,R4,#+31
   \      0x764   0xD504             BPL.N    ??_buffer_line_89
   \      0x766   0x4648             MOV      R0,R9
   \      0x768   0x4659             MOV      R1,R11
   \      0x76A   0x.... 0x....      BL       __aeabi_fmul
   \      0x76E   0x4681             MOV      R9,R0
   \                     ??_buffer_line_89: (+1)
   \      0x770   0x0864             LSRS     R4,R4,#+1
   \      0x772   0xD1F1             BNE.N    ??_buffer_line_88
   \      0x774   0x980D             LDR      R0,[SP, #+52]
   \      0x776   0x2402             MOVS     R4,#+2
   \      0x778   0x46AB             MOV      R11,R5
   \      0x77A   0x4605             MOV      R5,R0
   \      0x77C   0xE004             B.N      ??_buffer_line_90
   \                     ??_buffer_line_91: (+1)
   \      0x77E   0x4628             MOV      R0,R5
   \      0x780   0x4629             MOV      R1,R5
   \      0x782   0x.... 0x....      BL       __aeabi_fmul
   \      0x786   0x4605             MOV      R5,R0
   \                     ??_buffer_line_90: (+1)
   \      0x788   0x07E0             LSLS     R0,R4,#+31
   \      0x78A   0xD504             BPL.N    ??_buffer_line_92
   \      0x78C   0x4658             MOV      R0,R11
   \      0x78E   0x4629             MOV      R1,R5
   \      0x790   0x.... 0x....      BL       __aeabi_fmul
   \      0x794   0x4683             MOV      R11,R0
   \                     ??_buffer_line_92: (+1)
   \      0x796   0x0864             LSRS     R4,R4,#+1
   \      0x798   0xD1F1             BNE.N    ??_buffer_line_91
   \      0x79A   0x4640             MOV      R0,R8
   \      0x79C   0x4649             MOV      R1,R9
   \      0x79E   0x.... 0x....      BL       __aeabi_fadd
   \      0x7A2   0x4659             MOV      R1,R11
   \      0x7A4   0x.... 0x....      BL       __aeabi_fadd
   \      0x7A8   0x.... 0x....      BL       sqrtf
   \      0x7AC   0xF8CA 0x0010      STR      R0,[R10, #+16]
   \      0x7B0   0xE041             B.N      ??_buffer_line_62
   1248          	else	
   1249          		block->millimeters = sqrt(sq(delta_mm[X_AXIS]) + sq(delta_mm[Y_AXIS]) + sq(delta_mm[Z_AXIS]));
   \                     ??_buffer_line_83: (+1)
   \      0x7B2   0x2402             MOVS     R4,#+2
   \      0x7B4   0x46A8             MOV      R8,R5
   \      0x7B6   0xE004             B.N      ??_buffer_line_93
   \                     ??_buffer_line_94: (+1)
   \      0x7B8   0x4648             MOV      R0,R9
   \      0x7BA   0x4649             MOV      R1,R9
   \      0x7BC   0x.... 0x....      BL       __aeabi_fmul
   \      0x7C0   0x4681             MOV      R9,R0
   \                     ??_buffer_line_93: (+1)
   \      0x7C2   0x07E0             LSLS     R0,R4,#+31
   \      0x7C4   0xD504             BPL.N    ??_buffer_line_95
   \      0x7C6   0x4640             MOV      R0,R8
   \      0x7C8   0x4649             MOV      R1,R9
   \      0x7CA   0x.... 0x....      BL       __aeabi_fmul
   \      0x7CE   0x4680             MOV      R8,R0
   \                     ??_buffer_line_95: (+1)
   \      0x7D0   0x0864             LSRS     R4,R4,#+1
   \      0x7D2   0xD1F1             BNE.N    ??_buffer_line_94
   \      0x7D4   0xF8DD 0xB020      LDR      R11,[SP, #+32]
   \      0x7D8   0x2402             MOVS     R4,#+2
   \      0x7DA   0x46A9             MOV      R9,R5
   \      0x7DC   0xE004             B.N      ??_buffer_line_96
   \                     ??_buffer_line_97: (+1)
   \      0x7DE   0x4658             MOV      R0,R11
   \      0x7E0   0x4659             MOV      R1,R11
   \      0x7E2   0x.... 0x....      BL       __aeabi_fmul
   \      0x7E6   0x4683             MOV      R11,R0
   \                     ??_buffer_line_96: (+1)
   \      0x7E8   0x07E0             LSLS     R0,R4,#+31
   \      0x7EA   0xD504             BPL.N    ??_buffer_line_98
   \      0x7EC   0x4648             MOV      R0,R9
   \      0x7EE   0x4659             MOV      R1,R11
   \      0x7F0   0x.... 0x....      BL       __aeabi_fmul
   \      0x7F4   0x4681             MOV      R9,R0
   \                     ??_buffer_line_98: (+1)
   \      0x7F6   0x0864             LSRS     R4,R4,#+1
   \      0x7F8   0xD1F1             BNE.N    ??_buffer_line_97
   \      0x7FA   0x9809             LDR      R0,[SP, #+36]
   \      0x7FC   0x2402             MOVS     R4,#+2
   \      0x7FE   0x46AB             MOV      R11,R5
   \      0x800   0x4605             MOV      R5,R0
   \      0x802   0xE004             B.N      ??_buffer_line_99
   \                     ??_buffer_line_100: (+1)
   \      0x804   0x4628             MOV      R0,R5
   \      0x806   0x4629             MOV      R1,R5
   \      0x808   0x.... 0x....      BL       __aeabi_fmul
   \      0x80C   0x4605             MOV      R5,R0
   \                     ??_buffer_line_99: (+1)
   \      0x80E   0x07E0             LSLS     R0,R4,#+31
   \      0x810   0xD504             BPL.N    ??_buffer_line_101
   \      0x812   0x4658             MOV      R0,R11
   \      0x814   0x4629             MOV      R1,R5
   \      0x816   0x.... 0x....      BL       __aeabi_fmul
   \      0x81A   0x4683             MOV      R11,R0
   \                     ??_buffer_line_101: (+1)
   \      0x81C   0x0864             LSRS     R4,R4,#+1
   \      0x81E   0xD1F1             BNE.N    ??_buffer_line_100
   1250          		
   1251            }
   \      0x820   0x4640             MOV      R0,R8
   \      0x822   0x4649             MOV      R1,R9
   \      0x824   0x.... 0x....      BL       __aeabi_fadd
   \      0x828   0x4659             MOV      R1,R11
   \      0x82A   0x.... 0x....      BL       __aeabi_fadd
   \      0x82E   0x.... 0x....      BL       sqrtf
   \      0x832   0xF8CA 0x0010      STR      R0,[R10, #+16]
   1252            float inverse_millimeters = 1.0 / block->millimeters;  // Inverse millimeters to remove multiple divides
   \                     ??_buffer_line_62: (+1)
   \      0x836   0xF107 0x0424      ADD      R4,R7,#+36
   \      0x83A   0xF04F 0x507E      MOV      R0,#+1065353216
   \      0x83E   0x6921             LDR      R1,[R4, #+16]
   \      0x840   0x.... 0x....      BL       __aeabi_fdiv
   \      0x844   0x9005             STR      R0,[SP, #+20]
   1253          
   1254            // Calculate moves/second for this move. No divide by zero due to previous checks.
   1255            float inverse_mm_s = fr_mm_s * inverse_millimeters;
   \      0x846   0x991E             LDR      R1,[SP, #+120]
   \      0x848   0x.... 0x....      BL       __aeabi_fmul
   \      0x84C   0x4605             MOV      R5,R0
   1256          
   1257            const uint8_t moves_queued = movesplanned();
   \      0x84E   0x.... 0x....      BL       _ZN7Planner12movesplannedEv
   \      0x852   0x9006             STR      R0,[SP, #+24]
   1258          
   1259            // Slow down when the buffer starts to empty, rather than wait at the corner for a buffer refill
   1260           // #if ENABLED(SLOWDOWN) || ENABLED(ULTRA_LCD) || defined(XY_FREQUENCY_LIMIT)
   1261              // Segment time im micro seconds
   1262              unsigned long segment_time = lround(1000000.0 / inverse_mm_s);
   \      0x854   0x4628             MOV      R0,R5
   \      0x856   0x.... 0x....      BL       __aeabi_f2d
   \      0x85A   0x4602             MOV      R2,R0
   \      0x85C   0x460B             MOV      R3,R1
   \      0x85E   0x2000             MOVS     R0,#+0
   \      0x860   0x.... 0x....      LDR.W    R1,??DataTable21_1  ;; 0x412e8480
   \      0x864   0x.... 0x....      BL       __aeabi_ddiv
   \      0x868   0x.... 0x....      BL       lround
   \      0x86C   0x4681             MOV      R9,R0
   1263           // #endif
   1264            //#if ENABLED(SLOWDOWN)
   1265            if(!(MACHINETPYE & IS_KINEMATIC))
   \      0x86E   0xF8DF 0x04AC      LDR.W    R0,??_buffer_line_1+0x10
   \      0x872   0xF8B0 0x0058      LDRH     R0,[R0, #+88]
   \      0x876   0xF240 0x3102      MOVW     R1,#+770
   \      0x87A   0x4208             TST      R0,R1
   \      0x87C   0xD135             BNE.N    ??_buffer_line_102
   1266            {    
   1267              if (WITHIN(moves_queued, 2, (BLOCK_BUFFER_SIZE) / 2 - 1)) {
   \      0x87E   0x9806             LDR      R0,[SP, #+24]
   \      0x880   0x1E80             SUBS     R0,R0,#+2
   \      0x882   0x2806             CMP      R0,#+6
   \      0x884   0xD231             BCS.N    ??_buffer_line_102
   1268                if (segment_time < min_segment_time) {
   \      0x886   0x.... 0x....      LDR.W    R0,??DataTable21
   \      0x88A   0x6940             LDR      R0,[R0, #+20]
   \      0x88C   0x4581             CMP      R9,R0
   \      0x88E   0xD22C             BCS.N    ??_buffer_line_102
   1269                  // buffer is draining, add extra time.  The amount of time added increases if the buffer is still emptied more.
   1270                  /*--mks--*/
   1271                  //inverse_mm_s = 1000000.0 / (segment_time + lround(2 * (min_segment_time - segment_time) / moves_queued));
   1272                  inverse_mm_s = 1000000.0 / (segment_time + lround((float)2 * (min_segment_time - segment_time) / moves_queued));
   \      0x890   0xEBA0 0x0009      SUB      R0,R0,R9
   \      0x894   0x.... 0x....      BL       __aeabi_ui2f
   \      0x898   0xF04F 0x4180      MOV      R1,#+1073741824
   \      0x89C   0x.... 0x....      BL       __aeabi_fmul
   \      0x8A0   0x4605             MOV      R5,R0
   \      0x8A2   0xA806             ADD      R0,SP,#+24
   \      0x8A4   0x7800             LDRB     R0,[R0, #+0]
   \      0x8A6   0x.... 0x....      BL       __aeabi_ui2f
   \      0x8AA   0x4601             MOV      R1,R0
   \      0x8AC   0x4628             MOV      R0,R5
   \      0x8AE   0x.... 0x....      BL       __aeabi_fdiv
   \      0x8B2   0x.... 0x....      BL       lroundf
   \      0x8B6   0x4481             ADD      R9,R0,R9
   \      0x8B8   0x4648             MOV      R0,R9
   \      0x8BA   0x.... 0x....      BL       __aeabi_ui2d
   \      0x8BE   0x4602             MOV      R2,R0
   \      0x8C0   0x460B             MOV      R3,R1
   \      0x8C2   0x2000             MOVS     R0,#+0
   \      0x8C4   0x.... 0x....      LDR.W    R1,??DataTable21_1  ;; 0x412e8480
   \      0x8C8   0x.... 0x....      BL       __aeabi_ddiv
   \      0x8CC   0x.... 0x....      BL       __aeabi_d2f
   \      0x8D0   0x4605             MOV      R5,R0
   1273          
   1274          		#if defined(XY_FREQUENCY_LIMIT) || ENABLED(ULTRA_LCD)
   1275                    segment_time = lround(1000000.0 / inverse_mm_s);
   \      0x8D2   0x.... 0x....      BL       __aeabi_f2d
   \      0x8D6   0x4602             MOV      R2,R0
   \      0x8D8   0x460B             MOV      R3,R1
   \      0x8DA   0x2000             MOVS     R0,#+0
   \      0x8DC   0x.... 0x....      LDR.W    R1,??DataTable21_1  ;; 0x412e8480
   \      0x8E0   0x.... 0x....      BL       __aeabi_ddiv
   \      0x8E4   0x.... 0x....      BL       lround
   \      0x8E8   0x4681             MOV      R9,R0
   1276                  #endif
   1277                }
   1278              }
   1279            }
   1280            //#endif
   1281          
   1282            #if ENABLED(ULTRA_LCD)
   1283              CRITICAL_SECTION_START
   \                     ??_buffer_line_102: (+1)
   \      0x8EA   0xB672             cpsid i
   1284                block_buffer_runtime_us += segment_time;
   \      0x8EC   0x.... 0x....      LDR.W    R8,??DataTable21
   \      0x8F0   0xF8D8 0x003C      LDR      R0,[R8, #+60]
   \      0x8F4   0xEB19 0x0900      ADDS     R9,R9,R0
   \      0x8F8   0xF8C8 0x903C      STR      R9,[R8, #+60]
   1285              CRITICAL_SECTION_END
   \      0x8FC   0xB662             cpsie i
   1286            #endif
   1287          
   1288            block->nominal_speed = block->millimeters * inverse_mm_s; // (mm/sec) Always > 0
   \      0x8FE   0x6920             LDR      R0,[R4, #+16]
   \      0x900   0x4629             MOV      R1,R5
   \      0x902   0x.... 0x....      BL       __aeabi_fmul
   \      0x906   0x6060             STR      R0,[R4, #+4]
   1289            block->nominal_rate = ceil(block->step_event_count * inverse_mm_s); // (step/sec) Always > 0
                                       ^
Warning[Pa093]: implicit conversion from floating point to integer
   \      0x908   0x6978             LDR      R0,[R7, #+20]
   \      0x90A   0x.... 0x....      BL       __aeabi_ui2f
   \      0x90E   0x4629             MOV      R1,R5
   \      0x910   0x.... 0x....      BL       __aeabi_fmul
   \      0x914   0x.... 0x....      BL       ceilf
   \      0x918   0x.... 0x....      BL       __aeabi_f2uiz
   \      0x91C   0x61A0             STR      R0,[R4, #+24]
   1290          
   1291            #if ENABLED(FILAMENT_WIDTH_SENSOR)
   1292              static float filwidth_e_count = 0, filwidth_delay_dist = 0;
   1293          
   1294              //FMM update ring buffer used for delay with filament measurements
   1295              if (extruder == FILAMENT_SENSOR_EXTRUDER_NUM && filwidth_delay_index[1] >= 0) {  //only for extruder with filament sensor and if ring buffer is initialized
   1296          
   1297                const int MMD_CM = MAX_MEASUREMENT_DELAY + 1, MMD_MM = MMD_CM * 10;
   1298          
   1299                // increment counters with next move in e axis
   1300                filwidth_e_count += delta_mm[E_AXIS];
   1301                filwidth_delay_dist += delta_mm[E_AXIS];
   1302          
   1303                // Only get new measurements on forward E movement
   1304                if (filwidth_e_count > 0.0001) {
   1305          
   1306                  // Loop the delay distance counter (modulus by the mm length)
   1307                  while (filwidth_delay_dist >= MMD_MM) filwidth_delay_dist -= MMD_MM;
   1308          
   1309                  // Convert into an index into the measurement array
   1310                  filwidth_delay_index[0] = (int)(filwidth_delay_dist * 0.1 + 0.0001);
   1311          
   1312                  // If the index has changed (must have gone forward)...
   1313                  if (filwidth_delay_index[0] != filwidth_delay_index[1]) {
   1314                    filwidth_e_count = 0; // Reset the E movement counter
   1315                    const int8_t meas_sample = thermalManager.widthFil_to_size_ratio() - 100; // Subtract 100 to reduce magnitude - to store in a signed char
   1316                    do {
   1317                      filwidth_delay_index[1] = (filwidth_delay_index[1] + 1) % MMD_CM; // The next unused slot
   1318                      measurement_delay[filwidth_delay_index[1]] = meas_sample;         // Store the measurement
   1319                    } while (filwidth_delay_index[0] != filwidth_delay_index[1]);       // More slots to fill?
   1320                  }
   1321                }
   1322              }
   1323            #endif
   1324          
   1325            // Calculate and limit speed in mm/sec for each axis
   1326            float current_speed[NUM_AXIS], speed_factor = 1.0; // factor <1 decreases speed
   \      0x91E   0xF04F 0x597E      MOV      R9,#+1065353216
   1327            LOOP_XYZE(i) {
   \      0x922   0xF04F 0x0A00      MOV      R10,#+0
   \      0x926   0xE01A             B.N      ??_buffer_line_103
   1328              const float cs = fabs(current_speed[i] = delta_mm[i] * inverse_mm_s);
   \                     ??_buffer_line_104: (+1)
   \      0x928   0xA807             ADD      R0,SP,#+28
   \      0x92A   0xF850 0x002A      LDR      R0,[R0, R10, LSL #+2]
   \      0x92E   0x4629             MOV      R1,R5
   \      0x930   0x.... 0x....      BL       __aeabi_fmul
   \      0x934   0xA901             ADD      R1,SP,#+4
   \      0x936   0xF841 0x002A      STR      R0,[R1, R10, LSL #+2]
   \      0x93A   0xF020 0x4100      BIC      R1,R0,#0x80000000
   1329              #if ENABLED(DISTINCT_E_FACTORS)
   1330                if (i == E_AXIS) i += extruder;
   1331              #endif
   1332              if (cs > max_feedrate_mm_s[i]) NOMORE(speed_factor, max_feedrate_mm_s[i] / cs);
   \      0x93E   0xF108 0x0004      ADD      R0,R8,#+4
   \      0x942   0xF850 0x002A      LDR      R0,[R0, R10, LSL #+2]
   \      0x946   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x94A   0xD206             BCS.N    ??_buffer_line_105
   \      0x94C   0x.... 0x....      BL       __aeabi_fdiv
   \      0x950   0x4649             MOV      R1,R9
   \      0x952   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x956   0xD200             BCS.N    ??_buffer_line_105
   \      0x958   0x4681             MOV      R9,R0
   1333            }
   \                     ??_buffer_line_105: (+1)
   \      0x95A   0xF10A 0x0A01      ADD      R10,R10,#+1
   \                     ??_buffer_line_103: (+1)
   \      0x95E   0xF1BA 0x0F04      CMP      R10,#+4
   \      0x962   0xDBE1             BLT.N    ??_buffer_line_104
   1334          
   1335            // Max segment time in Âµs.
   1336            #ifdef XY_FREQUENCY_LIMIT
   1337          
   1338              // Check and limit the xy direction change frequency
   1339              const unsigned char direction_change = block->direction_bits ^ old_direction_bits;
   1340              old_direction_bits = block->direction_bits;
   1341              segment_time = lround((float)segment_time / speed_factor);
   1342          
   1343              long xs0 = axis_segment_time[X_AXIS][0],
   1344                   xs1 = axis_segment_time[X_AXIS][1],
   1345                   xs2 = axis_segment_time[X_AXIS][2],
   1346                   ys0 = axis_segment_time[Y_AXIS][0],
   1347                   ys1 = axis_segment_time[Y_AXIS][1],
   1348                   ys2 = axis_segment_time[Y_AXIS][2];
   1349          
   1350              if (TEST(direction_change, X_AXIS)) {
   1351                xs2 = axis_segment_time[X_AXIS][2] = xs1;
   1352                xs1 = axis_segment_time[X_AXIS][1] = xs0;
   1353                xs0 = 0;
   1354              }
   1355              xs0 = axis_segment_time[X_AXIS][0] = xs0 + segment_time;
   1356          
   1357              if (TEST(direction_change, Y_AXIS)) {
   1358                ys2 = axis_segment_time[Y_AXIS][2] = axis_segment_time[Y_AXIS][1];
   1359                ys1 = axis_segment_time[Y_AXIS][1] = axis_segment_time[Y_AXIS][0];
   1360                ys0 = 0;
   1361              }
   1362              ys0 = axis_segment_time[Y_AXIS][0] = ys0 + segment_time;
   1363          
   1364              const long max_x_segment_time = MAX3(xs0, xs1, xs2),
   1365                         max_y_segment_time = MAX3(ys0, ys1, ys2),
   1366                         min_xy_segment_time = min(max_x_segment_time, max_y_segment_time);
   1367              if (min_xy_segment_time < MAX_FREQ_TIME) {
   1368                const float low_sf = speed_factor * min_xy_segment_time / (MAX_FREQ_TIME);
   1369                NOMORE(speed_factor, low_sf);
   1370              }
   1371            #endif // XY_FREQUENCY_LIMIT
   1372          
   1373            // Correct the speed
   1374            if (speed_factor < 1.0) {
   \      0x964   0x4648             MOV      R0,R9
   \      0x966   0xF04F 0x517E      MOV      R1,#+1065353216
   \      0x96A   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x96E   0xD21D             BCS.N    ??_buffer_line_106
   1375              LOOP_XYZE(i) current_speed[i] *= speed_factor;
   \      0x970   0xF04F 0x0800      MOV      R8,#+0
   \      0x974   0xAD01             ADD      R5,SP,#+4
   \      0x976   0xE008             B.N      ??_buffer_line_107
   \                     ??_buffer_line_108: (+1)
   \      0x978   0xF855 0x0028      LDR      R0,[R5, R8, LSL #+2]
   \      0x97C   0x4649             MOV      R1,R9
   \      0x97E   0x.... 0x....      BL       __aeabi_fmul
   \      0x982   0xF845 0x0028      STR      R0,[R5, R8, LSL #+2]
   \      0x986   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??_buffer_line_107: (+1)
   \      0x98A   0xF1B8 0x0F04      CMP      R8,#+4
   \      0x98E   0xDBF3             BLT.N    ??_buffer_line_108
   1376              block->nominal_speed *= speed_factor;
   \      0x990   0x6860             LDR      R0,[R4, #+4]
   \      0x992   0x4649             MOV      R1,R9
   \      0x994   0x.... 0x....      BL       __aeabi_fmul
   \      0x998   0x6060             STR      R0,[R4, #+4]
   1377              block->nominal_rate *= speed_factor;
   \      0x99A   0x69A0             LDR      R0,[R4, #+24]
   \      0x99C   0x.... 0x....      BL       __aeabi_ui2f
   \      0x9A0   0x4649             MOV      R1,R9
   \      0x9A2   0x.... 0x....      BL       __aeabi_fmul
   \      0x9A6   0x.... 0x....      BL       __aeabi_f2uiz
   \      0x9AA   0x61A0             STR      R0,[R4, #+24]
   1378            }
   1379          
   1380            // Compute and limit the acceleration rate for the trapezoid generator.
   1381            const float steps_per_mm = block->step_event_count * inverse_millimeters;
   \                     ??_buffer_line_106: (+1)
   \      0x9AC   0x6978             LDR      R0,[R7, #+20]
   \      0x9AE   0x.... 0x....      BL       __aeabi_ui2f
   \      0x9B2   0x9905             LDR      R1,[SP, #+20]
   \      0x9B4   0x.... 0x....      BL       __aeabi_fmul
   \      0x9B8   0x4605             MOV      R5,R0
   1382            uint32_t accel;
   1383            if (!block->steps[X_AXIS] && !block->steps[Y_AXIS] && !block->steps[Z_AXIS]) {
   \      0x9BA   0x6878             LDR      R0,[R7, #+4]
   \      0x9BC   0x2800             CMP      R0,#+0
   \      0x9BE   0xD111             BNE.N    ??_buffer_line_109
   \      0x9C0   0x68B8             LDR      R0,[R7, #+8]
   \      0x9C2   0x2800             CMP      R0,#+0
   \      0x9C4   0xD10E             BNE.N    ??_buffer_line_109
   \      0x9C6   0x68F8             LDR      R0,[R7, #+12]
   \      0x9C8   0x2800             CMP      R0,#+0
   \      0x9CA   0xD10B             BNE.N    ??_buffer_line_109
   1384              // convert to: acceleration steps/sec^2
   1385              accel = ceil(retract_acceleration * steps_per_mm);
                           ^
Warning[Pa093]: implicit conversion from floating point to integer
   \      0x9CC   0x.... 0x....      LDR.W    R0,??DataTable21
   \      0x9D0   0x6A00             LDR      R0,[R0, #+32]
   \      0x9D2   0x4629             MOV      R1,R5
   \      0x9D4   0x.... 0x....      BL       __aeabi_fmul
   \      0x9D8   0x.... 0x....      BL       ceilf
   \      0x9DC   0x.... 0x....      BL       __aeabi_f2uiz
   \      0x9E0   0x4680             MOV      R8,R0
   \      0x9E2   0xE0E3             B.N      ??_buffer_line_110
   1386            }
   1387            else {
   1388              #define LIMIT_ACCEL_LONG(AXIS,INDX) do{ \
   1389                if (block->steps[AXIS] && max_acceleration_steps_per_s2[AXIS+INDX] < accel) { \
   1390                  const uint32_t comp = max_acceleration_steps_per_s2[AXIS+INDX] * block->step_event_count; \
   1391                  if (accel * block->steps[AXIS] > comp) accel = comp / block->steps[AXIS]; \
   1392                } \
   1393              }while(0)
   1394          
   1395              #define LIMIT_ACCEL_FLOAT(AXIS,INDX) do{ \
   1396                if (block->steps[AXIS] && max_acceleration_steps_per_s2[AXIS+INDX] < accel) { \
   1397                  const float comp = (float)max_acceleration_steps_per_s2[AXIS+INDX] * (float)block->step_event_count; \
   1398                  if ((float)accel * (float)block->steps[AXIS] > comp) accel = comp / (float)block->steps[AXIS]; \
   1399                } \
   1400              }while(0)
   1401          
   1402              // Start with print or travel acceleration
   1403              accel = ceil((esteps ? acceleration : travel_acceleration) * steps_per_mm);
                           ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??_buffer_line_109: (+1)
   \      0x9E4   0x9800             LDR      R0,[SP, #+0]
   \      0x9E6   0x2800             CMP      R0,#+0
   \      0x9E8   0x.... 0x....      LDR.W    R0,??DataTable21
   \      0x9EC   0xD001             BEQ.N    ??_buffer_line_111
   \      0x9EE   0x69C0             LDR      R0,[R0, #+28]
   \      0x9F0   0xE000             B.N      ??_buffer_line_112
   \                     ??_buffer_line_111: (+1)
   \      0x9F2   0x6A40             LDR      R0,[R0, #+36]
   \                     ??_buffer_line_112: (+1)
   \      0x9F4   0x4629             MOV      R1,R5
   \      0x9F6   0x.... 0x....      BL       __aeabi_fmul
   \      0x9FA   0x.... 0x....      BL       ceilf
   \      0x9FE   0x.... 0x....      BL       __aeabi_f2uiz
   \      0xA02   0x4680             MOV      R8,R0
   1404          
   1405              #if ENABLED(DISTINCT_E_FACTORS)
   1406                #define ACCEL_IDX extruder
   1407              #else
   1408                #define ACCEL_IDX 0
   1409              #endif
   1410          
   1411              // Limit acceleration per axis
   1412              if (block->step_event_count <= cutoff_long) {
   \      0xA04   0x687C             LDR      R4,[R7, #+4]
   \      0xA06   0xF8D7 0x9014      LDR      R9,[R7, #+20]
   \      0xA0A   0x6E30             LDR      R0,[R6, #+96]
   \      0xA0C   0x4548             CMP      R0,R9
   \      0xA0E   0xD33A             BCC.N    ??_buffer_line_113
   1413                LIMIT_ACCEL_LONG(X_AXIS, 0);
   \      0xA10   0x2C00             CMP      R4,#+0
   \      0xA12   0xD00A             BEQ.N    ??_buffer_line_114
   \      0xA14   0x6A70             LDR      R0,[R6, #+36]
   \      0xA16   0x4540             CMP      R0,R8
   \      0xA18   0xD207             BCS.N    ??_buffer_line_114
   \      0xA1A   0xFB09 0xF000      MUL      R0,R9,R0
   \      0xA1E   0xFB04 0xF108      MUL      R1,R4,R8
   \      0xA22   0x4288             CMP      R0,R1
   \      0xA24   0xD201             BCS.N    ??_buffer_line_114
   \      0xA26   0xFBB0 0xF8F4      UDIV     R8,R0,R4
   1414                LIMIT_ACCEL_LONG(Y_AXIS, 0);
   \                     ??_buffer_line_114: (+1)
   \      0xA2A   0x68B8             LDR      R0,[R7, #+8]
   \      0xA2C   0x2800             CMP      R0,#+0
   \      0xA2E   0xD00A             BEQ.N    ??_buffer_line_115
   \      0xA30   0x6AB1             LDR      R1,[R6, #+40]
   \      0xA32   0x4541             CMP      R1,R8
   \      0xA34   0xD207             BCS.N    ??_buffer_line_115
   \      0xA36   0xFB09 0xF101      MUL      R1,R9,R1
   \      0xA3A   0xFB00 0xF208      MUL      R2,R0,R8
   \      0xA3E   0x4291             CMP      R1,R2
   \      0xA40   0xD201             BCS.N    ??_buffer_line_115
   \      0xA42   0xFBB1 0xF8F0      UDIV     R8,R1,R0
   1415                LIMIT_ACCEL_LONG(Z_AXIS, 0);
   \                     ??_buffer_line_115: (+1)
   \      0xA46   0x68F8             LDR      R0,[R7, #+12]
   \      0xA48   0x2800             CMP      R0,#+0
   \      0xA4A   0xD00A             BEQ.N    ??_buffer_line_116
   \      0xA4C   0x6AF1             LDR      R1,[R6, #+44]
   \      0xA4E   0x4541             CMP      R1,R8
   \      0xA50   0xD207             BCS.N    ??_buffer_line_116
   \      0xA52   0xFB09 0xF101      MUL      R1,R9,R1
   \      0xA56   0xFB00 0xF208      MUL      R2,R0,R8
   \      0xA5A   0x4291             CMP      R1,R2
   \      0xA5C   0xD201             BCS.N    ??_buffer_line_116
   \      0xA5E   0xFBB1 0xF8F0      UDIV     R8,R1,R0
   1416                LIMIT_ACCEL_LONG(E_AXIS, ACCEL_IDX);
   \                     ??_buffer_line_116: (+1)
   \      0xA62   0x6938             LDR      R0,[R7, #+16]
   \      0xA64   0x2800             CMP      R0,#+0
   \      0xA66   0xF000 0x80A1      BEQ.W    ??_buffer_line_110
   \      0xA6A   0x6B31             LDR      R1,[R6, #+48]
   \      0xA6C   0x4541             CMP      R1,R8
   \      0xA6E   0xF080 0x809D      BCS.W    ??_buffer_line_110
   \      0xA72   0xFB09 0xF901      MUL      R9,R9,R1
   \      0xA76   0xFB00 0xF108      MUL      R1,R0,R8
   \      0xA7A   0x4589             CMP      R9,R1
   \      0xA7C   0xF080 0x8096      BCS.W    ??_buffer_line_110
   \      0xA80   0xFBB9 0xF8F0      UDIV     R8,R9,R0
   \      0xA84   0xE092             B.N      ??_buffer_line_110
   1417              }
   1418              else {
   1419                LIMIT_ACCEL_FLOAT(X_AXIS, 0);
                       ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??_buffer_line_113: (+1)
   \      0xA86   0x2C00             CMP      R4,#+0
   \      0xA88   0xD021             BEQ.N    ??_buffer_line_117
   \      0xA8A   0x6A70             LDR      R0,[R6, #+36]
   \      0xA8C   0x4540             CMP      R0,R8
   \      0xA8E   0xD21E             BCS.N    ??_buffer_line_117
   \      0xA90   0x.... 0x....      BL       __aeabi_ui2f
   \      0xA94   0x4682             MOV      R10,R0
   \      0xA96   0x4648             MOV      R0,R9
   \      0xA98   0x.... 0x....      BL       __aeabi_ui2f
   \      0xA9C   0x4651             MOV      R1,R10
   \      0xA9E   0x.... 0x....      BL       __aeabi_fmul
   \      0xAA2   0x4682             MOV      R10,R0
   \      0xAA4   0x4620             MOV      R0,R4
   \      0xAA6   0x.... 0x....      BL       __aeabi_i2f
   \      0xAAA   0x4604             MOV      R4,R0
   \      0xAAC   0x4640             MOV      R0,R8
   \      0xAAE   0x.... 0x....      BL       __aeabi_ui2f
   \      0xAB2   0x4621             MOV      R1,R4
   \      0xAB4   0x.... 0x....      BL       __aeabi_fmul
   \      0xAB8   0x4601             MOV      R1,R0
   \      0xABA   0x4650             MOV      R0,R10
   \      0xABC   0x.... 0x....      BL       __aeabi_cfcmple
   \      0xAC0   0xD205             BCS.N    ??_buffer_line_117
   \      0xAC2   0x4621             MOV      R1,R4
   \      0xAC4   0x.... 0x....      BL       __aeabi_fdiv
   \      0xAC8   0x.... 0x....      BL       __aeabi_f2uiz
   \      0xACC   0x4680             MOV      R8,R0
   1420                LIMIT_ACCEL_FLOAT(Y_AXIS, 0);
                       ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??_buffer_line_117: (+1)
   \      0xACE   0x68BC             LDR      R4,[R7, #+8]
   \      0xAD0   0x2C00             CMP      R4,#+0
   \      0xAD2   0xD021             BEQ.N    ??_buffer_line_118
   \      0xAD4   0x6AB0             LDR      R0,[R6, #+40]
   \      0xAD6   0x4540             CMP      R0,R8
   \      0xAD8   0xD21E             BCS.N    ??_buffer_line_118
   \      0xADA   0x.... 0x....      BL       __aeabi_ui2f
   \      0xADE   0x4682             MOV      R10,R0
   \      0xAE0   0x4648             MOV      R0,R9
   \      0xAE2   0x.... 0x....      BL       __aeabi_ui2f
   \      0xAE6   0x4651             MOV      R1,R10
   \      0xAE8   0x.... 0x....      BL       __aeabi_fmul
   \      0xAEC   0x4682             MOV      R10,R0
   \      0xAEE   0x4620             MOV      R0,R4
   \      0xAF0   0x.... 0x....      BL       __aeabi_i2f
   \      0xAF4   0x4604             MOV      R4,R0
   \      0xAF6   0x4640             MOV      R0,R8
   \      0xAF8   0x.... 0x....      BL       __aeabi_ui2f
   \      0xAFC   0x4621             MOV      R1,R4
   \      0xAFE   0x.... 0x....      BL       __aeabi_fmul
   \      0xB02   0x4601             MOV      R1,R0
   \      0xB04   0x4650             MOV      R0,R10
   \      0xB06   0x.... 0x....      BL       __aeabi_cfcmple
   \      0xB0A   0xD205             BCS.N    ??_buffer_line_118
   \      0xB0C   0x4621             MOV      R1,R4
   \      0xB0E   0x.... 0x....      BL       __aeabi_fdiv
   \      0xB12   0x.... 0x....      BL       __aeabi_f2uiz
   \      0xB16   0x4680             MOV      R8,R0
   1421                LIMIT_ACCEL_FLOAT(Z_AXIS, 0);
                       ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??_buffer_line_118: (+1)
   \      0xB18   0x68FC             LDR      R4,[R7, #+12]
   \      0xB1A   0x2C00             CMP      R4,#+0
   \      0xB1C   0xD021             BEQ.N    ??_buffer_line_119
   \      0xB1E   0x6AF0             LDR      R0,[R6, #+44]
   \      0xB20   0x4540             CMP      R0,R8
   \      0xB22   0xD21E             BCS.N    ??_buffer_line_119
   \      0xB24   0x.... 0x....      BL       __aeabi_ui2f
   \      0xB28   0x4682             MOV      R10,R0
   \      0xB2A   0x4648             MOV      R0,R9
   \      0xB2C   0x.... 0x....      BL       __aeabi_ui2f
   \      0xB30   0x4651             MOV      R1,R10
   \      0xB32   0x.... 0x....      BL       __aeabi_fmul
   \      0xB36   0x4682             MOV      R10,R0
   \      0xB38   0x4620             MOV      R0,R4
   \      0xB3A   0x.... 0x....      BL       __aeabi_i2f
   \      0xB3E   0x4604             MOV      R4,R0
   \      0xB40   0x4640             MOV      R0,R8
   \      0xB42   0x.... 0x....      BL       __aeabi_ui2f
   \      0xB46   0x4621             MOV      R1,R4
   \      0xB48   0x.... 0x....      BL       __aeabi_fmul
   \      0xB4C   0x4601             MOV      R1,R0
   \      0xB4E   0x4650             MOV      R0,R10
   \      0xB50   0x.... 0x....      BL       __aeabi_cfcmple
   \      0xB54   0xD205             BCS.N    ??_buffer_line_119
   \      0xB56   0x4621             MOV      R1,R4
   \      0xB58   0x.... 0x....      BL       __aeabi_fdiv
   \      0xB5C   0x.... 0x....      BL       __aeabi_f2uiz
   \      0xB60   0x4680             MOV      R8,R0
   1422                LIMIT_ACCEL_FLOAT(E_AXIS, ACCEL_IDX);
                       ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??_buffer_line_119: (+1)
   \      0xB62   0x693C             LDR      R4,[R7, #+16]
   \      0xB64   0x2C00             CMP      R4,#+0
   \      0xB66   0xD021             BEQ.N    ??_buffer_line_110
   \      0xB68   0x6B30             LDR      R0,[R6, #+48]
   \      0xB6A   0x4540             CMP      R0,R8
   \      0xB6C   0xD21E             BCS.N    ??_buffer_line_110
   \      0xB6E   0x.... 0x....      BL       __aeabi_ui2f
   \      0xB72   0x4682             MOV      R10,R0
   \      0xB74   0x4648             MOV      R0,R9
   \      0xB76   0x.... 0x....      BL       __aeabi_ui2f
   \      0xB7A   0x4651             MOV      R1,R10
   \      0xB7C   0x.... 0x....      BL       __aeabi_fmul
   \      0xB80   0x4681             MOV      R9,R0
   \      0xB82   0x4620             MOV      R0,R4
   \      0xB84   0x.... 0x....      BL       __aeabi_i2f
   \      0xB88   0x4604             MOV      R4,R0
   \      0xB8A   0x4640             MOV      R0,R8
   \      0xB8C   0x.... 0x....      BL       __aeabi_ui2f
   \      0xB90   0x4621             MOV      R1,R4
   \      0xB92   0x.... 0x....      BL       __aeabi_fmul
   \      0xB96   0x4601             MOV      R1,R0
   \      0xB98   0x4648             MOV      R0,R9
   \      0xB9A   0x.... 0x....      BL       __aeabi_cfcmple
   \      0xB9E   0xD205             BCS.N    ??_buffer_line_110
   \      0xBA0   0x4621             MOV      R1,R4
   \      0xBA2   0x.... 0x....      BL       __aeabi_fdiv
   \      0xBA6   0x.... 0x....      BL       __aeabi_f2uiz
   \      0xBAA   0x4680             MOV      R8,R0
   1423              }
   1424            }
   1425            block->acceleration_steps_per_s2 = accel;
   \                     ??_buffer_line_110: (+1)
   \      0xBAC   0xF107 0x0424      ADD      R4,R7,#+36
   \      0xBB0   0xF8C4 0x8024      STR      R8,[R4, #+36]
   1426            block->acceleration = accel / steps_per_mm;
   \      0xBB4   0x4640             MOV      R0,R8
   \      0xBB6   0x.... 0x....      BL       __aeabi_ui2f
   \      0xBBA   0x4629             MOV      R1,R5
   \      0xBBC   0x.... 0x....      BL       __aeabi_fdiv
   \      0xBC0   0x6160             STR      R0,[R4, #+20]
   1427            /*--mks--*/
   1428          //  block->acceleration_rate = (long)(accel * 16777216.0 / ((F_CPU) * 0.125)); // * 8.388608
   1429            //block->acceleration_rate = (long)(accel * 16777216.0 / ((F_CPU()) * 0.125)); // * 8.388608
   1430            block->acceleration_rate = (long)(accel * 8.388608); // * 8.388608
   \      0xBC2   0x4640             MOV      R0,R8
   \      0xBC4   0x.... 0x....      BL       __aeabi_ui2d
   \      0xBC8   0x.... 0x....      LDR.W    R2,??DataTable21_2  ;; 0xa0b5ed8d
   \      0xBCC   0x.... 0x....      LDR.W    R3,??DataTable21_3  ;; 0x4020c6f7
   \      0xBD0   0x.... 0x....      BL       __aeabi_dmul
   \      0xBD4   0x.... 0x....      BL       __aeabi_d2iz
   \      0xBD8   0x6238             STR      R0,[R7, #+32]
   1431          
   1432            // Initial limit on the segment entry velocity
   1433            float vmax_junction;
   1434          
   1435            #if 0  // Use old jerk for now
   1436          
   1437              float junction_deviation = 0.1;
   1438          
   1439              // Compute path unit vector
   1440              double unit_vec[XYZ] = {
   1441                delta_mm[X_AXIS] * inverse_millimeters,
   1442                delta_mm[Y_AXIS] * inverse_millimeters,
   1443                delta_mm[Z_AXIS] * inverse_millimeters
   1444              };
   1445          
   1446              /*
   1447                 Compute maximum allowable entry speed at junction by centripetal acceleration approximation.
   1448          
   1449                 Let a circle be tangent to both previous and current path line segments, where the junction
   1450                 deviation is defined as the distance from the junction to the closest edge of the circle,
   1451                 collinear with the circle center.
   1452          
   1453                 The circular segment joining the two paths represents the path of centripetal acceleration.
   1454                 Solve for max velocity based on max acceleration about the radius of the circle, defined
   1455                 indirectly by junction deviation.
   1456          
   1457                 This may be also viewed as path width or max_jerk in the previous grbl version. This approach
   1458                 does not actually deviate from path, but used as a robust way to compute cornering speeds, as
   1459                 it takes into account the nonlinearities of both the junction angle and junction velocity.
   1460               */
   1461          
   1462              vmax_junction = MINIMUM_PLANNER_SPEED; // Set default max junction speed
   1463          
   1464              // Skip first block or when previous_nominal_speed is used as a flag for homing and offset cycles.
   1465              if (block_buffer_head != block_buffer_tail && previous_nominal_speed > 0.0) {
   1466                // Compute cosine of angle between previous and current path. (prev_unit_vec is negative)
   1467                // NOTE: Max junction velocity is computed without sin() or acos() by trig half angle identity.
   1468                float cos_theta = - previous_unit_vec[X_AXIS] * unit_vec[X_AXIS]
   1469                                  - previous_unit_vec[Y_AXIS] * unit_vec[Y_AXIS]
   1470                                  - previous_unit_vec[Z_AXIS] * unit_vec[Z_AXIS] ;
   1471                // Skip and use default max junction speed for 0 degree acute junction.
   1472                if (cos_theta < 0.95) {
   1473                  vmax_junction = min(previous_nominal_speed, block->nominal_speed);
   1474                  // Skip and avoid divide by zero for straight junctions at 180 degrees. Limit to min() of nominal speeds.
   1475                  if (cos_theta > -0.95) {
   1476                    // Compute maximum junction velocity based on maximum acceleration and junction deviation
   1477                    float sin_theta_d2 = sqrt(0.5 * (1.0 - cos_theta)); // Trig half angle identity. Always positive.
   1478                    NOMORE(vmax_junction, sqrt(block->acceleration * junction_deviation * sin_theta_d2 / (1.0 - sin_theta_d2)));
   1479                  }
   1480                }
   1481              }
   1482            #endif
   1483          
   1484            /**
   1485             * Adapted from Prusa MKS firmware
   1486             *
   1487             * Start with a safe speed (from which the machine may halt to stop immediately).
   1488             */
   1489          
   1490            // Exit speed limited by a jerk to full halt of a previous last segment
   1491            static float previous_safe_speed;
   1492          
   1493            float safe_speed = block->nominal_speed;
   \      0xBDA   0xF8D4 0x9004      LDR      R9,[R4, #+4]
   1494            uint8_t limited = 0;
   \      0xBDE   0xF04F 0x0A00      MOV      R10,#+0
   1495            LOOP_XYZE(i) {
   \      0xBE2   0x46D3             MOV      R11,R10
   \                     ??_buffer_line_120: (+1)
   \      0xBE4   0xF1BB 0x0F04      CMP      R11,#+4
   \      0xBE8   0xF280 0x80EB      BGE.W    ??_buffer_line_121
   1496              const float jerk = fabs(current_speed[i]), maxj = max_jerk[i];
   \      0xBEC   0xA801             ADD      R0,SP,#+4
   \      0xBEE   0xF850 0x002B      LDR      R0,[R0, R11, LSL #+2]
   \      0xBF2   0xF020 0x4500      BIC      R5,R0,#0x80000000
   \      0xBF6   0x.... 0x....      LDR.W    R0,??DataTable21_4
   \      0xBFA   0xF850 0x802B      LDR      R8,[R0, R11, LSL #+2]
   1497              if (jerk > maxj) {
   \      0xBFE   0x4640             MOV      R0,R8
   \      0xC00   0x4629             MOV      R1,R5
   \      0xC02   0x.... 0x....      BL       __aeabi_cfcmple
   \      0xC06   0xD21B             BCS.N    ??_buffer_line_122
   1498                if (limited) {
   \      0xC08   0x4650             MOV      R0,R10
   \      0xC0A   0x2800             CMP      R0,#+0
   \      0xC0C   0xD106             BNE.N    ??_buffer_line_123
   1499                  const float mjerk = maxj * block->nominal_speed;
   1500                  if (jerk * safe_speed > mjerk) safe_speed = mjerk / jerk;
   1501                }
   1502                else {
   1503                  ++limited;
   \      0xC0E   0xF04F 0x0A01      MOV      R10,#+1
   1504                  safe_speed = maxj;
   \      0xC12   0x46C1             MOV      R9,R8
   \      0xC14   0xE014             B.N      ??_buffer_line_122
   \      0xC16   0xBF00             Nop      
   \                     ??_buffer_line_0:
   \      0xC18   0x....'....        DC32     _ZN7Planner17block_buffer_headE
   1505                }
   \                     ??_buffer_line_123: (+1)
   \      0xC1C   0x6860             LDR      R0,[R4, #+4]
   \      0xC1E   0x4641             MOV      R1,R8
   \      0xC20   0x.... 0x....      BL       __aeabi_fmul
   \      0xC24   0x4680             MOV      R8,R0
   \      0xC26   0x4628             MOV      R0,R5
   \      0xC28   0x4649             MOV      R1,R9
   \      0xC2A   0x.... 0x....      BL       __aeabi_fmul
   \      0xC2E   0x4601             MOV      R1,R0
   \      0xC30   0x4640             MOV      R0,R8
   \      0xC32   0x.... 0x....      BL       __aeabi_cfcmple
   \      0xC36   0xD203             BCS.N    ??_buffer_line_122
   \      0xC38   0x4629             MOV      R1,R5
   \      0xC3A   0x.... 0x....      BL       __aeabi_fdiv
   \      0xC3E   0x4681             MOV      R9,R0
   1506              }
   1507            }
   \                     ??_buffer_line_122: (+1)
   \      0xC40   0xF10B 0x0B01      ADD      R11,R11,#+1
   \      0xC44   0xE7CE             B.N      ??_buffer_line_120
   1508          
   1509            if (moves_queued > 1 && previous_nominal_speed > 0.0001) {
   1510              // Estimate a maximum velocity allowed at a joint of two successive segments.
   1511              // If this maximum velocity allowed is lower than the minimum of the entry / exit safe velocities,
   1512              // then the machine is not coasting anymore and the safe entry / exit velocities shall be used.
   1513          
   1514              // The junction velocity will be shared between successive segments. Limit the junction velocity to their minimum.
   1515              bool prev_speed_larger = previous_nominal_speed > block->nominal_speed;
   \                     ??_buffer_line_124: (+1)
   \      0xC46   0x2400             MOVS     R4,#+0
   1516              float smaller_speed_factor = prev_speed_larger ? (block->nominal_speed / previous_nominal_speed) : (previous_nominal_speed / block->nominal_speed);
   \                     ??_buffer_line_125: (+1)
   \      0xC48   0x2C00             CMP      R4,#+0
   \      0xC4A   0xD002             BEQ.N    ??_buffer_line_126
   \      0xC4C   0x.... 0x....      BL       __aeabi_fdiv
   \      0xC50   0xE003             B.N      ??_buffer_line_127
   \                     ??_buffer_line_126: (+1)
   \      0xC52   0x4628             MOV      R0,R5
   \      0xC54   0x4631             MOV      R1,R6
   \      0xC56   0x.... 0x....      BL       __aeabi_fdiv
   1517              // Pick the smaller of the nominal speeds. Higher speed shall not be achieved at the junction during coasting.
   1518              vmax_junction = prev_speed_larger ? block->nominal_speed : previous_nominal_speed;
   \                     ??_buffer_line_127: (+1)
   \      0xC5A   0x2C00             CMP      R4,#+0
   \      0xC5C   0xD001             BEQ.N    ??_buffer_line_128
   \      0xC5E   0x9600             STR      R6,[SP, #+0]
   \      0xC60   0xE000             B.N      ??_buffer_line_129
   \                     ??_buffer_line_128: (+1)
   \      0xC62   0x9500             STR      R5,[SP, #+0]
   1519              // Factor to multiply the previous / current nominal velocities to get componentwise limited velocities.
   1520              float v_factor = 1.f;
   \                     ??_buffer_line_129: (+1)
   \      0xC64   0xF04F 0x557E      MOV      R5,#+1065353216
   1521              limited = 0;
   \      0xC68   0x2600             MOVS     R6,#+0
   1522              // Now limit the jerk in all axes.
   1523              LOOP_XYZE(axis) {
   \      0xC6A   0x46B1             MOV      R9,R6
   \      0xC6C   0x4680             MOV      R8,R0
   \      0xC6E   0xE01A             B.N      ??_buffer_line_130
   1524                // Limit an axis. We have to differentiate: coasting, reversal of an axis, full stop.
   1525                float v_exit = previous_speed[axis], v_entry = current_speed[axis];
   1526                if (prev_speed_larger) v_exit *= smaller_speed_factor;
   1527                if (limited) {
   1528                  v_exit *= v_factor;
   1529                  v_entry *= v_factor;
   1530                }
   1531          
   1532                // Calculate jerk depending on whether the axis is coasting in the same direction or reversing.
   1533                const float jerk = (v_exit > v_entry)
   1534                    ? //                                  coasting             axis reversal
   1535                      ( (v_entry > 0.f || v_exit < 0.f) ? (v_exit - v_entry) : max(v_exit, -v_entry) )
   1536                    : // v_exit <= v_entry                coasting             axis reversal
   1537                      ( (v_entry < 0.f || v_exit > 0.f) ? (v_entry - v_exit) : max(-v_exit, v_entry) );
   \                     ??_buffer_line_131: (+1)
   \      0xC70   0x465A             MOV      R2,R11
   \      0xC72   0xE007             B.N      ??_buffer_line_132
   \                     ??_buffer_line_133: (+1)
   \      0xC74   0x4652             MOV      R2,R10
   \      0xC76   0xF082 0x4200      EOR      R2,R2,#0x80000000
   \      0xC7A   0x4658             MOV      R0,R11
   \      0xC7C   0x4611             MOV      R1,R2
   \      0xC7E   0x.... 0x....      BL       __aeabi_cfcmple
   \      0xC82   0xD2F5             BCS.N    ??_buffer_line_131
   1538          
   1539                if (jerk > max_jerk[axis]) {
   \                     ??_buffer_line_132: (+1)
   \      0xC84   0x.... 0x....      LDR.W    R0,??DataTable21_4
   \      0xC88   0xF850 0x0029      LDR      R0,[R0, R9, LSL #+2]
   \      0xC8C   0x4611             MOV      R1,R2
   \      0xC8E   0x.... 0x....      BL       __aeabi_cfcmple
   \      0xC92   0xD206             BCS.N    ??_buffer_line_134
   1540                  v_factor *= max_jerk[axis] / jerk;
   \      0xC94   0x.... 0x....      BL       __aeabi_fdiv
   \      0xC98   0x4629             MOV      R1,R5
   \      0xC9A   0x.... 0x....      BL       __aeabi_fmul
   \      0xC9E   0x4605             MOV      R5,R0
   1541                  ++limited;
   \      0xCA0   0x1C76             ADDS     R6,R6,#+1
   1542                }
   \                     ??_buffer_line_134: (+1)
   \      0xCA2   0xF109 0x0901      ADD      R9,R9,#+1
   \                     ??_buffer_line_130: (+1)
   \      0xCA6   0xF1B9 0x0F04      CMP      R9,#+4
   \      0xCAA   0xF280 0x80A0      BGE.W    ??_buffer_line_135
   \      0xCAE   0x.... 0x....      LDR.W    R0,??DataTable21_5
   \      0xCB2   0xF850 0xA029      LDR      R10,[R0, R9, LSL #+2]
   \      0xCB6   0xA801             ADD      R0,SP,#+4
   \      0xCB8   0xF850 0xB029      LDR      R11,[R0, R9, LSL #+2]
   \      0xCBC   0x2C00             CMP      R4,#+0
   \      0xCBE   0xD004             BEQ.N    ??_buffer_line_136
   \      0xCC0   0x4650             MOV      R0,R10
   \      0xCC2   0x4641             MOV      R1,R8
   \      0xCC4   0x.... 0x....      BL       __aeabi_fmul
   \      0xCC8   0x4682             MOV      R10,R0
   \                     ??_buffer_line_136: (+1)
   \      0xCCA   0x4630             MOV      R0,R6
   \      0xCCC   0xB2C0             UXTB     R0,R0
   \      0xCCE   0x2800             CMP      R0,#+0
   \      0xCD0   0xD009             BEQ.N    ??_buffer_line_137
   \      0xCD2   0x4650             MOV      R0,R10
   \      0xCD4   0x4629             MOV      R1,R5
   \      0xCD6   0x.... 0x....      BL       __aeabi_fmul
   \      0xCDA   0x4682             MOV      R10,R0
   \      0xCDC   0x4658             MOV      R0,R11
   \      0xCDE   0x4629             MOV      R1,R5
   \      0xCE0   0x.... 0x....      BL       __aeabi_fmul
   \      0xCE4   0x4683             MOV      R11,R0
   \                     ??_buffer_line_137: (+1)
   \      0xCE6   0x4658             MOV      R0,R11
   \      0xCE8   0x4651             MOV      R1,R10
   \      0xCEA   0x.... 0x....      BL       __aeabi_cfcmple
   \      0xCEE   0xD221             BCS.N    ??_buffer_line_138
   \      0xCF0   0x2100             MOVS     R1,#+0
   \      0xCF2   0x.... 0x....      BL       __aeabi_cfrcmple
   \      0xCF6   0xD303             BCC.N    ??_buffer_line_139
   \      0xCF8   0x4650             MOV      R0,R10
   \      0xCFA   0x.... 0x....      BL       __aeabi_cfcmple
   \      0xCFE   0xD20F             BCS.N    ??_buffer_line_140
   \                     ??_buffer_line_139: (+1)
   \      0xD00   0x4650             MOV      R0,R10
   \      0xD02   0x4659             MOV      R1,R11
   \      0xD04   0x.... 0x....      BL       __aeabi_fsub
   \      0xD08   0x4602             MOV      R2,R0
   \      0xD0A   0xE7BB             B.N      ??_buffer_line_132
   \                     ??_buffer_line_1:
   \      0xD0C   0x....'....        DC32     marlin_debug_flags
   \      0xD10   0x....'....        DC32     echomagic
   \      0xD14   0x....'....        DC32     ?_0
   \      0xD18   0x....'....        DC32     ?_1
   \      0xD1C   0x....'....        DC32     mksCfg
   \                     ??_buffer_line_140: (+1)
   \      0xD20   0x465A             MOV      R2,R11
   \      0xD22   0xF082 0x4200      EOR      R2,R2,#0x80000000
   \      0xD26   0x4610             MOV      R0,R2
   \      0xD28   0x4651             MOV      R1,R10
   \      0xD2A   0x.... 0x....      BL       __aeabi_cfcmple
   \      0xD2E   0xD2A9             BCS.N    ??_buffer_line_132
   \      0xD30   0x4652             MOV      R2,R10
   \      0xD32   0xE7A7             B.N      ??_buffer_line_132
   \                     ??_buffer_line_138: (+1)
   \      0xD34   0x2100             MOVS     R1,#+0
   \      0xD36   0x.... 0x....      BL       __aeabi_cfcmple
   \      0xD3A   0xD303             BCC.N    ??_buffer_line_141
   \      0xD3C   0x4650             MOV      R0,R10
   \      0xD3E   0x.... 0x....      BL       __aeabi_cfrcmple
   \      0xD42   0xD297             BCS.N    ??_buffer_line_133
   \                     ??_buffer_line_141: (+1)
   \      0xD44   0x4658             MOV      R0,R11
   \      0xD46   0x4651             MOV      R1,R10
   \      0xD48   0x.... 0x....      BL       __aeabi_fsub
   \      0xD4C   0x4602             MOV      R2,R0
   \      0xD4E   0xE799             B.N      ??_buffer_line_132
   1543              }
   1544              if (limited) vmax_junction *= v_factor;
   1545              // Now the transition velocity is known, which maximizes the shared exit / entry velocity while
   1546              // respecting the jerk factors, it may be possible, that applying separate safe exit / entry velocities will achieve faster prints.
   1547              const float vmax_junction_threshold = vmax_junction * 0.99f;
   1548              if (previous_safe_speed > vmax_junction_threshold && safe_speed > vmax_junction_threshold) {
   1549                // Not coasting. The machine will stop and start the movements anyway,
   1550                // better to start the segment from start.
   1551                SBI(block->flag, BLOCK_BIT_START_FROM_FULL_HALT);
   1552                vmax_junction = safe_speed;
   1553              }
   1554            }
   1555            else {
   1556              SBI(block->flag, BLOCK_BIT_START_FROM_FULL_HALT);
   1557              vmax_junction = safe_speed;
   1558            }
   1559          
   1560            // Max entry speed of this block equals the max exit speed of the previous block.
   1561            block->max_entry_speed = vmax_junction;
   1562          
   1563            // Initialize block entry speed. Compute based on deceleration to user-defined MINIMUM_PLANNER_SPEED.
   1564            const float v_allowable = max_allowable_speed(-block->acceleration, MINIMUM_PLANNER_SPEED, block->millimeters);
   1565            block->entry_speed = min(vmax_junction, v_allowable);
   \                     ??_buffer_line_142: (+1)
   \      0xD50   0x4608             MOV      R0,R1
   \                     ??_buffer_line_143: (+1)
   \      0xD52   0x60A0             STR      R0,[R4, #+8]
   1566          
   1567            // Initialize planner efficiency flags
   1568            // Set flag if block will always reach maximum junction speed regardless of entry/exit speeds.
   1569            // If a block can de/ac-celerate from nominal speed to zero within the length of the block, then
   1570            // the current block and next block junction speeds are guaranteed to always be at their maximum
   1571            // junction speeds in deceleration and acceleration, respectively. This is due to how the current
   1572            // block nominal speed limits both the current and next maximum junction speeds. Hence, in both
   1573            // the reverse and forward planners, the corresponding block junction speed will always be at the
   1574            // the maximum junction speed and may always be ignored for any speed reduction checks.
   1575            block->flag |= BLOCK_FLAG_RECALCULATE | (block->nominal_speed <= v_allowable ? BLOCK_FLAG_NOMINAL_LENGTH : 0);
   \      0xD54   0x4608             MOV      R0,R1
   \      0xD56   0x6861             LDR      R1,[R4, #+4]
   \      0xD58   0x.... 0x....      BL       __aeabi_cfrcmple
   \      0xD5C   0xD801             BHI.N    ??_buffer_line_144
   \      0xD5E   0x2002             MOVS     R0,#+2
   \      0xD60   0xE000             B.N      ??_buffer_line_145
   \                     ??_buffer_line_144: (+1)
   \      0xD62   0x2000             MOVS     R0,#+0
   \                     ??_buffer_line_145: (+1)
   \      0xD64   0x7879             LDRB     R1,[R7, #+1]
   \      0xD66   0xF040 0x0001      ORR      R0,R0,#0x1
   \      0xD6A   0x4308             ORRS     R0,R0,R1
   \      0xD6C   0x7078             STRB     R0,[R7, #+1]
   1576          
   1577            // Update previous path unit_vector and nominal speed
   1578            COPY(previous_speed, current_speed);
   \      0xD6E   0x....             LDR.N    R5,??DataTable21_6
   \      0xD70   0x2210             MOVS     R2,#+16
   \      0xD72   0xA901             ADD      R1,SP,#+4
   \      0xD74   0xF105 0x0064      ADD      R0,R5,#+100
   \      0xD78   0x.... 0x....      BL       __aeabi_memcpy4
   1579            previous_nominal_speed = block->nominal_speed;
   \      0xD7C   0x6860             LDR      R0,[R4, #+4]
   \      0xD7E   0x6768             STR      R0,[R5, #+116]
   1580            previous_safe_speed = safe_speed;
   \      0xD80   0x9805             LDR      R0,[SP, #+20]
   \      0xD82   0x....             LDR.N    R1,??DataTable21
   \      0xD84   0x6408             STR      R0,[R1, #+64]
   1581          
   1582            #if ENABLED(LIN_ADVANCE)
   1583          
   1584              //
   1585              // Use LIN_ADVANCE for blocks if all these are true:
   1586              //
   1587              // esteps                                          : We have E steps todo (a printing move)
   1588              //
   1589              // block->steps[X_AXIS] || block->steps[Y_AXIS]    : We have a movement in XY direction (i.e., not retract / prime).
   1590              //
   1591              // extruder_advance_k                              : There is an advance factor set.
   1592              //
   1593              // block->steps[E_AXIS] != block->step_event_count : A problem occurs if the move before a retract is too small.
   1594              //                                                   In that case, the retract and move will be executed together.
   1595              //                                                   This leads to too many advance steps due to a huge e_acceleration.
   1596              //                                                   The math is good, but we must avoid retract moves with advance!
   1597              // de_float > 0.0                                  : Extruder is running forward (e.g., for "Wipe while retracting" (Slic3r) or "Combing" (Cura) moves)
   1598              //
   1599              block->use_advance_lead =  esteps
   1600                                      && (block->steps[X_AXIS] || block->steps[Y_AXIS])
   1601                                      && extruder_advance_k
   1602                                      && (uint32_t)esteps != block->step_event_count
   1603                                      && de_float > 0.0;
   1604              if (block->use_advance_lead)
   1605                block->abs_adv_steps_multiplier8 = lround(
   1606                  extruder_advance_k
   1607                  * (UNEAR_ZERO(advance_ed_ratio) ? de_float / mm_D_float : advance_ed_ratio) // Use the fixed ratio, if set
   1608                  * (block->nominal_speed / (float)block->nominal_rate)
   1609                  * axis_steps_per_mm[E_AXIS_N] * 256.0
   1610                );
   1611          
   1612            #elif ENABLED(ADVANCE)
   1613          
   1614              // Calculate advance rate
   1615              if (esteps && (block->steps[X_AXIS] || block->steps[Y_AXIS] || block->steps[Z_AXIS])) {
   1616                const long acc_dist = estimate_acceleration_distance(0, block->nominal_rate, block->acceleration_steps_per_s2);
   1617                const float advance = ((STEPS_PER_CUBIC_MM_E) * (EXTRUDER_ADVANCE_K)) * HYPOT(current_speed[E_AXIS], EXTRUSION_AREA) * 256;
   1618                block->advance = advance;
   1619                block->advance_rate = acc_dist ? advance / (float)acc_dist : 0;
   1620              }
   1621              else
   1622                block->advance_rate = block->advance = 0;
   1623          
   1624              /**
   1625               SERIAL_ECHO_START;
   1626               SERIAL_ECHOPGM("advance :");
   1627               SERIAL_ECHO(block->advance/256.0);
   1628               SERIAL_ECHOPGM("advance rate :");
   1629               SERIAL_ECHOLN(block->advance_rate/256.0);
   1630               */
   1631          
   1632            #endif // ADVANCE or LIN_ADVANCE
   1633          
   1634            calculate_trapezoid_for_block(block, block->entry_speed / block->nominal_speed, safe_speed / block->nominal_speed);
   \      0xD86   0x68A0             LDR      R0,[R4, #+8]
   \      0xD88   0x6861             LDR      R1,[R4, #+4]
   \      0xD8A   0x.... 0x....      BL       __aeabi_fdiv
   \      0xD8E   0x9000             STR      R0,[SP, #+0]
   \      0xD90   0x9805             LDR      R0,[SP, #+20]
   \      0xD92   0x6861             LDR      R1,[R4, #+4]
   \      0xD94   0x.... 0x....      BL       __aeabi_fdiv
   \      0xD98   0x9006             STR      R0,[SP, #+24]
   \      0xD9A   0xAA06             ADD      R2,SP,#+24
   \      0xD9C   0x4669             MOV      R1,SP
   \      0xD9E   0x4638             MOV      R0,R7
   \      0xDA0   0x.... 0x....      BL       _ZN7Planner29calculate_trapezoid_for_blockEP7block_tRKfS3_
   1635          
   1636          
   1637            // Move buffer head
   1638            block_buffer_head = next_buffer_head;
   \      0xDA4   0x980F             LDR      R0,[SP, #+60]
   \      0xDA6   0x7028             STRB     R0,[R5, #+0]
   1639          
   1640            // Update the position (only when a move was queued)
   1641            COPY(position, target);
   \      0xDA8   0x2210             MOVS     R2,#+16
   \      0xDAA   0xA910             ADD      R1,SP,#+64
   \      0xDAC   0xF105 0x0034      ADD      R0,R5,#+52
   \      0xDB0   0x.... 0x....      BL       __aeabi_memcpy4
   1642            #if ENABLED(LIN_ADVANCE)
   1643              position_float[X_AXIS] = a;
   1644              position_float[Y_AXIS] = b;
   1645              position_float[Z_AXIS] = c;
   1646              position_float[E_AXIS] = e;
   1647            #endif
   1648          
   1649            recalculate();
   \      0xDB4   0x.... 0x....      BL       _ZN7Planner11recalculateEv
   1650          
   1651            stepper.wake_up();
   \      0xDB8   0x.... 0x....      BL       _ZN7Stepper7wake_upEv
   1652          
   1653          } // buffer_line()
   \                     ??_buffer_line_36: (+1)
   \      0xDBC   0xB015             ADD      SP,SP,#+84
   \      0xDBE   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \                     ??_buffer_line_121: (+1)
   \      0xDC2   0xF8CD 0x9014      STR      R9,[SP, #+20]
   \      0xDC6   0x9806             LDR      R0,[SP, #+24]
   \      0xDC8   0x2801             CMP      R0,#+1
   \      0xDCA   0xDD25             BLE.N    ??_buffer_line_146
   \      0xDCC   0x6F75             LDR      R5,[R6, #+116]
   \      0xDCE   0x4628             MOV      R0,R5
   \      0xDD0   0x....             LDR.N    R1,??DataTable21_7  ;; 0x38d1b718
   \      0xDD2   0x.... 0x....      BL       __aeabi_cfrcmple
   \      0xDD6   0xD81F             BHI.N    ??_buffer_line_146
   \      0xDD8   0xF107 0x0024      ADD      R0,R7,#+36
   \      0xDDC   0x6846             LDR      R6,[R0, #+4]
   \      0xDDE   0x4630             MOV      R0,R6
   \      0xDE0   0x4629             MOV      R1,R5
   \      0xDE2   0x.... 0x....      BL       __aeabi_cfcmple
   \      0xDE6   0xF4BF 0xAF2E      BCS.W    ??_buffer_line_124
   \      0xDEA   0x2401             MOVS     R4,#+1
   \      0xDEC   0xE72C             B.N      ??_buffer_line_125
   \                     ??_buffer_line_135: (+1)
   \      0xDEE   0x4629             MOV      R1,R5
   \      0xDF0   0xB2F6             UXTB     R6,R6
   \      0xDF2   0x2E00             CMP      R6,#+0
   \      0xDF4   0xD003             BEQ.N    ??_buffer_line_147
   \      0xDF6   0x9800             LDR      R0,[SP, #+0]
   \      0xDF8   0x.... 0x....      BL       __aeabi_fmul
   \      0xDFC   0x9000             STR      R0,[SP, #+0]
   \                     ??_buffer_line_147: (+1)
   \      0xDFE   0x9900             LDR      R1,[SP, #+0]
   \      0xE00   0x....             LDR.N    R0,??DataTable21_8  ;; 0x3f7d70a4
   \      0xE02   0x.... 0x....      BL       __aeabi_fmul
   \      0xE06   0x....             LDR.N    R1,??DataTable21
   \      0xE08   0x6C09             LDR      R1,[R1, #+64]
   \      0xE0A   0x.... 0x....      BL       __aeabi_cfcmple
   \      0xE0E   0xD209             BCS.N    ??_buffer_line_148
   \      0xE10   0x9905             LDR      R1,[SP, #+20]
   \      0xE12   0x.... 0x....      BL       __aeabi_cfcmple
   \      0xE16   0xD205             BCS.N    ??_buffer_line_148
   \                     ??_buffer_line_146: (+1)
   \      0xE18   0x7878             LDRB     R0,[R7, #+1]
   \      0xE1A   0xF040 0x0004      ORR      R0,R0,#0x4
   \      0xE1E   0x7078             STRB     R0,[R7, #+1]
   \      0xE20   0x9805             LDR      R0,[SP, #+20]
   \      0xE22   0x9000             STR      R0,[SP, #+0]
   \                     ??_buffer_line_148: (+1)
   \      0xE24   0xF107 0x0424      ADD      R4,R7,#+36
   \      0xE28   0x9800             LDR      R0,[SP, #+0]
   \      0xE2A   0x60E0             STR      R0,[R4, #+12]
   \      0xE2C   0x6960             LDR      R0,[R4, #+20]
   \      0xE2E   0xF080 0x4000      EOR      R0,R0,#0x80000000
   \      0xE32   0x9006             STR      R0,[SP, #+24]
   \      0xE34   0x....             LDR.N    R0,??DataTable21_9  ;; 0x3d4ccccd
   \      0xE36   0x900E             STR      R0,[SP, #+56]
   \      0xE38   0xF107 0x0234      ADD      R2,R7,#+52
   \      0xE3C   0xA90E             ADD      R1,SP,#+56
   \      0xE3E   0xA806             ADD      R0,SP,#+24
   \      0xE40   0x.... 0x....      BL       _ZN7Planner19max_allowable_speedERKfS1_S1_
   \      0xE44   0x4601             MOV      R1,R0
   \      0xE46   0x9800             LDR      R0,[SP, #+0]
   \      0xE48   0x.... 0x....      BL       __aeabi_cfcmple
   \      0xE4C   0xF4BF 0xAF80      BCS.W    ??_buffer_line_142
   \      0xE50   0xE77F             B.N      ??_buffer_line_143

   \                                 In section .bss, align 4
   \                     _ZN7Planner23g_uc_extruder_last_moveE:
   \        0x0                      DS8 1
   \        0x1                      DS8 3
   \                     _ZN7Planner17max_feedrate_mm_sE:
   \        0x4                      DS8 16
   \                     _ZN7Planner16min_segment_timeE:
   \       0x14                      DS8 4
   \                     _ZN7Planner17min_feedrate_mm_sE:
   \       0x18                      DS8 4
   \                     _ZN7Planner12accelerationE:
   \       0x1C                      DS8 4
   \                     _ZN7Planner20retract_accelerationE:
   \       0x20                      DS8 4
   \                     _ZN7Planner19travel_accelerationE:
   \       0x24                      DS8 4
   \                     _ZN7Planner8max_jerkE:
   \       0x28                      DS8 16
   \                     _ZN7Planner24min_travel_feedrate_mm_sE:
   \       0x38                      DS8 4
   \                     _ZN7Planner23block_buffer_runtime_usE:
   \       0x3C                      DS8 4
   \       0x40                      DS8 4

   \                                 In section .bss, align 4
   \                     _ZN7Planner16bed_level_matrixE:
   \        0x0                      DS8 36
   1654          
   1655          /**
   1656           * Directly set the planner XYZ position (and stepper positions)
   1657           * converting mm (or angles for SCARA) into steps.
   1658           *
   1659           * On CORE machines stepper ABC will be translated from the given XYZ.
   1660           */
   1661          

   \                                 In section .text, align 2, keep-with-next
   1662          void Planner::_set_position_mm(const float &a, const float &b, const float &c, const float &e) {
   \                     _ZN7Planner16_set_position_mmERKfS1_S1_S1_: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x460F             MOV      R7,R1
   \        0x6   0x4616             MOV      R6,R2
   \        0x8   0x461C             MOV      R4,R3
   1663            #if ENABLED(DISTINCT_E_FACTORS)
   1664              #define _EINDEX (E_AXIS + active_extruder)
   1665              last_extruder = active_extruder;
   1666            #else
   1667              #define _EINDEX E_AXIS
   1668            #endif
   1669            long na = position[X_AXIS] = lround(a * axis_steps_per_mm[X_AXIS]),
   \        0xA   0x....             LDR.N    R5,??DataTable21_6
   \        0xC   0x6801             LDR      R1,[R0, #+0]
   \        0xE   0x6868             LDR      R0,[R5, #+4]
   \       0x10   0x.... 0x....      BL       __aeabi_fmul
   \       0x14   0x.... 0x....      BL       lroundf
   \       0x18   0x6368             STR      R0,[R5, #+52]
   \       0x1A   0x9003             STR      R0,[SP, #+12]
   1670                 nb = position[Y_AXIS] = lround(b * axis_steps_per_mm[Y_AXIS]),
   \       0x1C   0x6839             LDR      R1,[R7, #+0]
   \       0x1E   0x68A8             LDR      R0,[R5, #+8]
   \       0x20   0x.... 0x....      BL       __aeabi_fmul
   \       0x24   0x.... 0x....      BL       lroundf
   \       0x28   0x63A8             STR      R0,[R5, #+56]
   \       0x2A   0x9002             STR      R0,[SP, #+8]
   1671                 nc = position[Z_AXIS] = lround(c * axis_steps_per_mm[Z_AXIS]),
   \       0x2C   0x6831             LDR      R1,[R6, #+0]
   \       0x2E   0x68E8             LDR      R0,[R5, #+12]
   \       0x30   0x.... 0x....      BL       __aeabi_fmul
   \       0x34   0x.... 0x....      BL       lroundf
   \       0x38   0x63E8             STR      R0,[R5, #+60]
   \       0x3A   0x9001             STR      R0,[SP, #+4]
   1672                 ne = position[E_AXIS] = lround(e * axis_steps_per_mm[_EINDEX]);
   \       0x3C   0x6821             LDR      R1,[R4, #+0]
   \       0x3E   0x6928             LDR      R0,[R5, #+16]
   \       0x40   0x.... 0x....      BL       __aeabi_fmul
   \       0x44   0x.... 0x....      BL       lroundf
   \       0x48   0x6428             STR      R0,[R5, #+64]
   \       0x4A   0x9000             STR      R0,[SP, #+0]
   1673            #if ENABLED(LIN_ADVANCE)
   1674              position_float[X_AXIS] = a;
   1675              position_float[Y_AXIS] = b;
   1676              position_float[Z_AXIS] = c;
   1677              position_float[E_AXIS] = e;
   1678            #endif
   1679            stepper.set_position(na, nb, nc, ne);
   \       0x4C   0x466B             MOV      R3,SP
   \       0x4E   0xAA01             ADD      R2,SP,#+4
   \       0x50   0xA902             ADD      R1,SP,#+8
   \       0x52   0xA803             ADD      R0,SP,#+12
   \       0x54   0x.... 0x....      BL       _ZN7Stepper12set_positionERKlS1_S1_S1_
   1680            previous_nominal_speed = 0.0; // Resets planner junction speeds. Assumes start from rest.
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0x6768             STR      R0,[R5, #+116]
   1681            ZERO(previous_speed);
   \       0x5C   0x4602             MOV      R2,R0
   \       0x5E   0x2110             MOVS     R1,#+16
   \       0x60   0xF105 0x0064      ADD      R0,R5,#+100
   \       0x64   0x.... 0x....      BL       __aeabi_memset
   1682          }
   \       0x68   0xB005             ADD      SP,SP,#+20
   \       0x6A   0xBDF0             POP      {R4-R7,PC}       ;; return
   1683          

   \                                 In section .text, align 2, keep-with-next
   1684          void Planner::set_position_mm_kinematic(const float position[NUM_AXIS]) {
   \                     _ZN7Planner25set_position_mm_kinematicEPKf: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x4604             MOV      R4,R0
   1685            //#if PLANNER_LEVELING
   1686            /*
   1687            if(BED_LEVELING_METHOD&PLANNER_LEVELING)	{
   1688              float lpos[XYZ] = { position[X_AXIS], position[Y_AXIS], position[Z_AXIS] };
   1689              apply_leveling(lpos);	}
   1690            //#else
   1691            	else
   1692              {const float * const lpos = position;}
   1693            //#endif
   1694          */
   1695            float lpos[NUM_AXIS];
   1696            if(BED_LEVELING_METHOD&PLANNER_LEVELING)	{
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x....             LDR.N    R5,??DataTable21_10
   \        0xA   0x4669             MOV      R1,SP
   \        0xC   0x782A             LDRB     R2,[R5, #+0]
   \        0xE   0xF012 0x0F2E      TST      R2,#0x2E
   \       0x12   0x9000             STR      R0,[SP, #+0]
   \       0x14   0x6860             LDR      R0,[R4, #+4]
   \       0x16   0x6048             STR      R0,[R1, #+4]
   \       0x18   0x68A0             LDR      R0,[R4, #+8]
   \       0x1A   0x6088             STR      R0,[R1, #+8]
   \       0x1C   0xD003             BEQ.N    ??set_position_mm_kinematic_0
   1697            	lpos[0] = position[X_AXIS];
   1698            	lpos[1] = position[Y_AXIS];
   1699            	lpos[2] = position[Z_AXIS];
   1700          	apply_leveling(lpos);
   \       0x1E   0x4668             MOV      R0,SP
   \       0x20   0x.... 0x....      BL       _ZN7Planner14apply_levelingEPf
   \       0x24   0xE001             B.N      ??set_position_mm_kinematic_1
   1701            	}
   1702            else
   1703            	{
   1704          	  lpos[0] = position[X_AXIS];
   1705          	  lpos[1] = position[Y_AXIS];
   1706          	  lpos[2] = position[Z_AXIS];
   1707          	  lpos[3] = position[3];
   \                     ??set_position_mm_kinematic_0: (+1)
   \       0x26   0x68E0             LDR      R0,[R4, #+12]
   \       0x28   0x60C8             STR      R0,[R1, #+12]
   1708            	}
   1709          
   1710          
   1711          //mks_delta  begin  
   1712          /*
   1713            #if IS_KINEMATIC
   1714              inverse_kinematics(lpos);
   1715              _set_position_mm(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], position[E_AXIS]);
   1716            #else
   1717              _set_position_mm(lpos[X_AXIS], lpos[Y_AXIS], lpos[Z_AXIS], position[E_AXIS]);
   1718            #endif
   1719          */
   1720            if(MACHINETPYE & IS_KINEMATIC)
   \                     ??set_position_mm_kinematic_1: (+1)
   \       0x2A   0xF9B5 0x0018      LDRSH    R0,[R5, #+24]
   \       0x2E   0xF240 0x3102      MOVW     R1,#+770
   \       0x32   0x4208             TST      R0,R1
   \       0x34   0xD011             BEQ.N    ??set_position_mm_kinematic_2
   1721            	{
   1722            	
   1723          	if(MACHINETPYE == MORGAN_SCARA)
   \       0x36   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x3A   0x4668             MOV      R0,SP
   \       0x3C   0xD102             BNE.N    ??set_position_mm_kinematic_3
   1724          	  inverse_kinematics_MORGAN_SCARA(lpos);
   \       0x3E   0x.... 0x....      BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
   \       0x42   0xE001             B.N      ??set_position_mm_kinematic_4
   1725          	else
   1726          	  inverse_kinematics(lpos);
   \                     ??set_position_mm_kinematic_3: (+1)
   \       0x44   0x.... 0x....      BL       _Z18inverse_kinematicsPKf
   1727          	  
   1728          	  _set_position_mm(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], position[E_AXIS]);
   \                     ??set_position_mm_kinematic_4: (+1)
   \       0x48   0x....             LDR.N    R0,??DataTable21_11
   \       0x4A   0xF104 0x030C      ADD      R3,R4,#+12
   \       0x4E   0xF100 0x0208      ADD      R2,R0,#+8
   \       0x52   0x1D01             ADDS     R1,R0,#+4
   \       0x54   0x.... 0x....      BL       _ZN7Planner16_set_position_mmERKfS1_S1_S1_
   \       0x58   0xE006             B.N      ??set_position_mm_kinematic_5
   1729            	}
   1730            else
   1731            	{
   1732          	  _set_position_mm(lpos[X_AXIS], lpos[Y_AXIS], lpos[Z_AXIS], position[E_AXIS]);
   \                     ??set_position_mm_kinematic_2: (+1)
   \       0x5A   0xF104 0x030C      ADD      R3,R4,#+12
   \       0x5E   0xAA02             ADD      R2,SP,#+8
   \       0x60   0xA901             ADD      R1,SP,#+4
   \       0x62   0x4668             MOV      R0,SP
   \       0x64   0x.... 0x....      BL       _ZN7Planner16_set_position_mmERKfS1_S1_S1_
   1733            	}
   1734          
   1735            //mks_delta  end  
   1736            
   1737          }
   \                     ??set_position_mm_kinematic_5: (+1)
   \       0x68   0xB005             ADD      SP,SP,#+20
   \       0x6A   0xBD30             POP      {R4,R5,PC}       ;; return
   1738          
   1739          /**
   1740           * Sync from the stepper positions. (e.g., after an interrupted move)
   1741           */

   \                                 In section .text, align 2, keep-with-next
   1742          void Planner::sync_from_steppers() {
   \                     _ZN7Planner18sync_from_steppersEv: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1743            LOOP_XYZE(i) {
   \        0x2   0x2400             MOVS     R4,#+0
   \        0x4   0xE008             B.N      ??sync_from_steppers_0
   1744              position[i] = stepper.position((AxisEnum)i);
   \                     ??sync_from_steppers_1: (+1)
   \        0x6   0x4620             MOV      R0,R4
   \        0x8   0xB240             SXTB     R0,R0
   \        0xA   0x.... 0x....      BL       _ZN7Stepper8positionE8AxisEnum
   \        0xE   0x....             LDR.N    R1,??DataTable21_6
   \       0x10   0xEB01 0x0184      ADD      R1,R1,R4, LSL #+2
   \       0x14   0x6348             STR      R0,[R1, #+52]
   1745              #if ENABLED(LIN_ADVANCE)
   1746                position_float[i] = position[i] * steps_to_mm[i
   1747                  #if ENABLED(DISTINCT_E_FACTORS)
   1748                    + (i == E_AXIS ? active_extruder : 0)
   1749                  #endif
   1750                ];
   1751              #endif
   1752            }
   \       0x16   0x1C64             ADDS     R4,R4,#+1
   \                     ??sync_from_steppers_0: (+1)
   \       0x18   0x2C04             CMP      R4,#+4
   \       0x1A   0xDBF4             BLT.N    ??sync_from_steppers_1
   1753          }
   \       0x1C   0xBD10             POP      {R4,PC}          ;; return
   1754          
   1755          /**
   1756           * Setters for planner position (also setting stepper position).
   1757           */

   \                                 In section .text, align 2, keep-with-next
   1758          void Planner::set_position_mm(const AxisEnum axis, const float& v) {
   \                     _ZN7Planner15set_position_mmE8AxisEnumRKf: (+1)
   \        0x0   0xB531             PUSH     {R0,R4,R5,LR}
   \        0x2   0xB082             SUB      SP,SP,#+8
   \        0x4   0x460D             MOV      R5,R1
   1759            #if ENABLED(DISTINCT_E_FACTORS)
   1760              const uint8_t axis_index = axis + (axis == E_AXIS ? active_extruder : 0);
   1761              last_extruder = active_extruder;
   1762            #else
   1763              const uint8_t axis_index = axis;
   1764            #endif
   1765            position[axis] = lround(v * axis_steps_per_mm[axis_index]);
   \        0x6   0x....             LDR.N    R4,??DataTable21_6
   \        0x8   0x6829             LDR      R1,[R5, #+0]
   \        0xA   0xB2C0             UXTB     R0,R0
   \        0xC   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \       0x10   0x6840             LDR      R0,[R0, #+4]
   \       0x12   0x.... 0x....      BL       __aeabi_fmul
   \       0x16   0x.... 0x....      BL       lroundf
   \       0x1A   0xF99D 0x1008      LDRSB    R1,[SP, #+8]
   \       0x1E   0xEB04 0x0181      ADD      R1,R4,R1, LSL #+2
   \       0x22   0x6348             STR      R0,[R1, #+52]
   1766            #if ENABLED(LIN_ADVANCE)
   1767              position_float[axis] = v;
   1768            #endif
   1769            stepper.set_position(axis, v);
                                              ^
Warning[Pa093]: implicit conversion from floating point to integer
   \       0x24   0x6828             LDR      R0,[R5, #+0]
   \       0x26   0x.... 0x....      BL       __aeabi_f2iz
   \       0x2A   0x9000             STR      R0,[SP, #+0]
   \       0x2C   0x4669             MOV      R1,SP
   \       0x2E   0xA802             ADD      R0,SP,#+8
   \       0x30   0x.... 0x....      BL       _ZN7Stepper12set_positionERK8AxisEnumRKl
   1770            previous_speed[axis] = 0.0;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xF99D 0x1008      LDRSB    R1,[SP, #+8]
   \       0x3A   0xEB04 0x0181      ADD      R1,R4,R1, LSL #+2
   \       0x3E   0x6648             STR      R0,[R1, #+100]
   1771          }
   \       0x40   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
   1772          
   1773          // Recalculate the steps/s^2 acceleration rates, based on the mm/s^2

   \                                 In section .text, align 2, keep-with-next
   1774          void Planner::reset_acceleration_rates() {
   \                     _ZN7Planner24reset_acceleration_ratesEv: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   1775            #if ENABLED(DISTINCT_E_FACTORS)
   1776              #define HIGHEST_CONDITION (i < E_AXIS || i == E_AXIS + active_extruder)
   1777            #else
   1778              #define HIGHEST_CONDITION true
   1779            #endif
   1780            uint32_t highest_rate = 1;
   \        0x2   0x2401             MOVS     R4,#+1
   1781            LOOP_XYZE_N(i) {
   \        0x4   0x2500             MOVS     R5,#+0
   \        0x6   0xE00E             B.N      ??reset_acceleration_rates_0
   1782              max_acceleration_steps_per_s2[i] = max_acceleration_mm_per_s2[i] * axis_steps_per_mm[i];
                                                      ^
Warning[Pa093]: implicit conversion from floating point to integer

      static uint8_t movesplanned() { return BLOCK_MOD(block_buffer_head - block_buffer_tail + BLOCK_BUFFER_SIZE); }
                                      ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\planner.h",257  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

      static bool blocks_queued() { return (block_buffer_head != block_buffer_tail); }
                                    ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\planner.h",415  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement
   \                     ??reset_acceleration_rates_1: (+1)
   \        0x8   0xEB00 0x0685      ADD      R6,R0,R5, LSL #+2
   \        0xC   0x6C70             LDR      R0,[R6, #+68]
   \        0xE   0x.... 0x....      BL       __aeabi_ui2f
   \       0x12   0x6871             LDR      R1,[R6, #+4]
   \       0x14   0x.... 0x....      BL       __aeabi_fmul
   \       0x18   0x.... 0x....      BL       __aeabi_f2uiz
   \       0x1C   0x6270             STR      R0,[R6, #+36]
   1783              if (HIGHEST_CONDITION) NOLESS(highest_rate, max_acceleration_steps_per_s2[i]);
   \       0x1E   0x4284             CMP      R4,R0
   \       0x20   0xD200             BCS.N    ??reset_acceleration_rates_2
   \       0x22   0x4604             MOV      R4,R0
   1784            }
   \                     ??reset_acceleration_rates_2: (+1)
   \       0x24   0x1C6D             ADDS     R5,R5,#+1
   \                     ??reset_acceleration_rates_0: (+1)
   \       0x26   0x....             LDR.N    R0,??DataTable21_6
   \       0x28   0x2D04             CMP      R5,#+4
   \       0x2A   0xDBED             BLT.N    ??reset_acceleration_rates_1
   1785            cutoff_long = 4294967295UL / highest_rate;
   \       0x2C   0xF04F 0x31FF      MOV      R1,#-1
   \       0x30   0xFBB1 0xF1F4      UDIV     R1,R1,R4
   \       0x34   0x6601             STR      R1,[R0, #+96]
   1786          }
   \       0x36   0xBD70             POP      {R4-R6,PC}       ;; return
   1787          
   1788          // Recalculate position, steps_to_mm if axis_steps_per_mm changes!

   \                                 In section .text, align 2, keep-with-next
   1789          void Planner::refresh_positioning() {
   \                     _ZN7Planner19refresh_positioningEv: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   1790            LOOP_XYZE_N(i) steps_to_mm[i] = 1.0 / axis_steps_per_mm[i];
   \        0x2   0x2400             MOVS     R4,#+0
   \        0x4   0xE009             B.N      ??refresh_positioning_0
   \                     ??refresh_positioning_1: (+1)
   \        0x6   0x....             LDR.N    R0,??DataTable21_6
   \        0x8   0xEB00 0x0584      ADD      R5,R0,R4, LSL #+2
   \        0xC   0xF04F 0x507E      MOV      R0,#+1065353216
   \       0x10   0x6869             LDR      R1,[R5, #+4]
   \       0x12   0x.... 0x....      BL       __aeabi_fdiv
   \       0x16   0x6168             STR      R0,[R5, #+20]
   \       0x18   0x1C64             ADDS     R4,R4,#+1
   \                     ??refresh_positioning_0: (+1)
   \       0x1A   0x2C04             CMP      R4,#+4
   \       0x1C   0xDBF3             BLT.N    ??refresh_positioning_1
   1791            set_position_mm_kinematic(current_position);
   \       0x1E   0x....             LDR.N    R0,??DataTable21_12
   \       0x20   0x.... 0x....      BL       _ZN7Planner25set_position_mm_kinematicEPKf
   1792            reset_acceleration_rates();
   \       0x24   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \       0x28   0x....             B.N      _ZN7Planner24reset_acceleration_ratesEv
   1793          }
   1794          
   1795          #if ENABLED(AUTOTEMP)
   1796          

   \                                 In section .text, align 2, keep-with-next
   1797            void Planner::autotemp_M104_M109() {
   \                     _ZN7Planner18autotemp_M104_M109Ev: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1798              autotemp_enabled = code_seen('F');
   \        0x2   0x2046             MOVS     R0,#+70
   \        0x4   0x.... 0x....      BL       _Z9code_seenc
   \        0x8   0x....             LDR.N    R4,??DataTable21_6
   \        0xA   0x70A0             STRB     R0,[R4, #+2]
   1799              if (autotemp_enabled) autotemp_factor = code_value_temp_diff();
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD004             BEQ.N    ??autotemp_M104_M109_0
   \       0x10   0x.... 0x....      BL       _Z20code_value_temp_diffv
   \       0x14   0x.... 0x....      BL       __aeabi_i2f
   \       0x18   0x65E0             STR      R0,[R4, #+92]
   1800              if (code_seen('S')) autotemp_min = code_value_temp_abs();
   \                     ??autotemp_M104_M109_0: (+1)
   \       0x1A   0x2053             MOVS     R0,#+83
   \       0x1C   0x.... 0x....      BL       _Z9code_seenc
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD004             BEQ.N    ??autotemp_M104_M109_1
   \       0x24   0x.... 0x....      BL       _Z19code_value_temp_absv
   \       0x28   0x.... 0x....      BL       __aeabi_i2f
   \       0x2C   0x65A0             STR      R0,[R4, #+88]
   1801              if (code_seen('B')) autotemp_max = code_value_temp_abs();
   \                     ??autotemp_M104_M109_1: (+1)
   \       0x2E   0x2042             MOVS     R0,#+66
   \       0x30   0x.... 0x....      BL       _Z9code_seenc
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD004             BEQ.N    ??autotemp_M104_M109_2
   \       0x38   0x.... 0x....      BL       _Z19code_value_temp_absv
   \       0x3C   0x.... 0x....      BL       __aeabi_i2f
   \       0x40   0x6560             STR      R0,[R4, #+84]
   1802            }
   \                     ??autotemp_M104_M109_2: (+1)
   \       0x42   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \        0x0   0x....'....        DC32     planner

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \        0x0   0x....'....        DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \        0x0   0x....'....        DC32     _ZN7Planner17block_buffer_headE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \        0x0   0x....'....        DC32     _ZN7Planner16bed_level_matrixE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \        0x0   0x....'....        DC32     _ZN7Planner12block_bufferE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \        0x0   0x9999'999A        DC32     0x9999999a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \        0x0   0x3FA9'9999        DC32     0x3fa99999

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \        0x0   0x47AE'1480        DC32     0x47ae1480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \        0x0   0x3F94'7AE1        DC32     0x3f947ae1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_9:
   \        0x0   0xF5C2'8F5C        DC32     0xf5c28f5c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_10:
   \        0x0   0x3FEF'5C28        DC32     0x3fef5c28

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_11:
   \        0x0   0x....'....        DC32     mksCfg+0x40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_12:
   \        0x0   0x....'....        DC32     _ZN7Planner11abl_enabledE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_13:
   \        0x0   0x....'....        DC32     workspace_offset

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \        0x0   0x....'....        DC32     volumetric_multiplier

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \        0x0   0x....'....        DC32     flow_percentage

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \        0x0   0x3F84'7AE1        DC32     0x3f847ae1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \        0x0   0x3FE0'0000        DC32     0x3fe00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \        0x0   0x....'....        DC32     _ZN7Planner12block_bufferE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \        0x0   0x....'....        DC32     cmd_queue_index_r_bak

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \        0x0   0x47AE'147B        DC32     0x47ae147b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \        0x0   0x....'....        DC32     fanSpeeds

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \        0x0   0x....'....        DC32     gArrayGpioPort

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \        0x0   0x....'....        DC32     gArrayGpioPin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \        0x0   0x....'....        DC32     _ZN7Planner23g_uc_extruder_last_moveE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \        0x0   0x412E'8480        DC32     0x412e8480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_2:
   \        0x0   0xA0B5'ED8D        DC32     0xa0b5ed8d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_3:
   \        0x0   0x4020'C6F7        DC32     0x4020c6f7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_4:
   \        0x0   0x....'....        DC32     _ZN7Planner23g_uc_extruder_last_moveE+0x28

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_5:
   \        0x0   0x....'....        DC32     _ZN7Planner17block_buffer_headE+0x64

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_6:
   \        0x0   0x....'....        DC32     _ZN7Planner17block_buffer_headE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_7:
   \        0x0   0x38D1'B718        DC32     0x38d1b718

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_8:
   \        0x0   0x3F7D'70A4        DC32     0x3f7d70a4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_9:
   \        0x0   0x3D4C'CCCD        DC32     0x3d4ccccd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_10:
   \        0x0   0x....'....        DC32     mksCfg+0x40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_11:
   \        0x0   0x....'....        DC32     delta

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_12:
   \        0x0   0x....'....        DC32     current_position

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_0:
   \        0x0   0x20 0x63          DC8 " cold extrusion prevented\012"
   \              0x6F 0x6C    
   \              0x64 0x20    
   \              0x65 0x78    
   \              0x74 0x72    
   \              0x75 0x73    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x70 0x72    
   \              0x65 0x76    
   \              0x65 0x6E    
   \              0x74 0x65    
   \              0x64 0x0A    
   \              0x00         
   \       0x1B   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_1:
   \        0x0   0x20 0x74          DC8 " too long extrusion prevented\012"
   \              0x6F 0x6F    
   \              0x20 0x6C    
   \              0x6F 0x6E    
   \              0x67 0x20    
   \              0x65 0x78    
   \              0x74 0x72    
   \              0x75 0x73    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x70 0x72    
   \              0x65 0x76    
   \              0x65 0x6E    
   \              0x74 0x65    
   \              0x64 0x0A    
   \              0x00         
   \       0x1F   0x00               DC8 0
   1803          
   1804          #endif
   1805          
   1806          #ifdef MKS_BUG_PRINTPAUSE
   1807          #include "cardreader.h"
   1808          void Planner::mksBugPrintPause()
   1809          {
   1810            if(card.sdprinting && card.getsdpos()>5000)
   1811              mksBugPrintPauseCnt++;
   1812          }
   1813          #endif
   1814          
   1815          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CORESIGN(long)
      16   MarlinSerial::print(char const *)
         0   -> MarlinSerial::write(char const *)
         0   -> package_to_wifi
        16   -> strlen
      16   MarlinSerial::write(char const *)
         0   -> BSP_UartIfQueueTxData
        16   -> strlen
       8   Planner::Planner()
         8   -> Planner::init()
     120   Planner::_buffer_line(float const &, float const &, float const &, float const &, float, uint8_t)
       120   -> CORESIGN(long)
       120   -> HAL_GPIO_WritePin
       120   -> Planner::calculate_trapezoid_for_block(block_t *, float const &, float const &)
       120   -> Planner::max_allowable_speed(float const &, float const &, float const &)
       120   -> Planner::movesplanned()
       120   -> Planner::next_block_index(int8_t)
       120   -> Planner::recalculate()
       120   -> Stepper::wake_up()
       120   -> Temperature::tooColdToExtrude(uint8_t)
       120   -> __aeabi_d2f
       120   -> __aeabi_d2iz
       120   -> __aeabi_dadd
       120   -> __aeabi_ddiv
       120   -> __aeabi_dmul
       120   -> __aeabi_f2d
       120   -> __aeabi_f2iz
       120   -> __aeabi_f2uiz
       120   -> __aeabi_fadd
       120   -> __aeabi_fdiv
       120   -> __aeabi_fmul
       120   -> __aeabi_fsub
       120   -> __aeabi_i2f
       120   -> __aeabi_memcpy4
       120   -> __aeabi_ui2d
       120   -> __aeabi_ui2f
       120   -> ceilf
       120   -> idle(bool)
       120   -> labs
       120   -> lround
       120   -> lroundf
       120   -> serialprintPGM(char const *)
       120   -> sqrtf
       120 __aeabi_cfcmple
       120 __aeabi_cfrcmple
      40   Planner::_set_position_mm(float const &, float const &, float const &, float const &)
        40   -> Stepper::set_position(long const &, long const &, long const &, long const &)
        40   -> __aeabi_fmul
        40   -> __aeabi_memset
        40   -> lroundf
      96   Planner::apply_leveling(float &, float &, float &)
        80   -> __aeabi_fadd
        80   -> __aeabi_fmul
        80   -> __aeabi_fsub
        96   -> __aeabi_memcpy4
        80   -> apply_rotation_xyz(matrix_3x3, float &, float &, float &)
        80   -> bilinear_z_offset(float const *)
        80   -> mesh_bed_leveling::active()
        80   -> mesh_bed_leveling::get_z_mks(float const &, float const &)
        80 __aeabi_cfcmpeq
        80 __aeabi_cfrcmple
       0   Planner::apply_leveling(float *)
         0   -> Planner::apply_leveling(float &, float &, float &)
       8   Planner::autotemp_M104_M109()
         8   -> __aeabi_i2f
         8   -> code_seen(char)
         8   -> code_value_temp_abs()
         8   -> code_value_temp_diff()
       0   Planner::blocks_queued()
      56   Planner::calculate_trapezoid_for_block(block_t *, float const &, float const &)
        56   -> Planner::estimate_acceleration_distance(float const &, float const &, float const &)
        56   -> Planner::intersection_distance(float const &, float const &, float const &, float const &)
        56   -> __aeabi_f2iz
        56   -> __aeabi_f2uiz
        56   -> __aeabi_fmul
        56   -> __aeabi_i2f
        56   -> __aeabi_ui2f
        56   -> ceilf
        56   -> floorf
       8   Planner::check_axes_activity()
         8   -> Planner::blocks_queued()
         0   -> Planner::getHighESpeed()
         8   -> Planner::next_block_index(int8_t)
      32   Planner::estimate_acceleration_distance(float const &, float const &, float const &)
         0   -> __aeabi_fdiv
        32   -> __aeabi_fmul
        32   -> __aeabi_fsub
        32 __aeabi_cfcmpeq
      24   Planner::forward_pass()
         0   -> Planner::forward_pass_kernel(block_t const *, block_t *)
        24   -> Planner::forward_pass_kernel(block_t const *, block_t *)
        24   -> Planner::next_block_index(int8_t)
      24   Planner::forward_pass_kernel(block_t const *, block_t *)
        24   -> Planner::max_allowable_speed(float const &, float const &, float const &)
        24 __aeabi_cfcmpeq
        24 __aeabi_cfcmple
      32   Planner::getHighESpeed()
        32   -> Planner::next_block_index(int8_t)
        32   -> Temperature::degTargetHotend(uint8_t)
         0   -> Temperature::setTargetHotend(float, uint8_t)
        32   -> __aeabi_d2f
        32   -> __aeabi_dadd
        32   -> __aeabi_dmul
        32   -> __aeabi_f2d
        32   -> __aeabi_fadd
        32   -> __aeabi_fdiv
        32   -> __aeabi_fmul
        32   -> __aeabi_i2f
        32   -> __aeabi_ui2f
        32 __aeabi_cfcmple
       8   Planner::init()
         8   -> __aeabi_memset4
         0   -> matrix_3x3::set_to_identity()
      32   Planner::intersection_distance(float const &, float const &, float const &, float const &)
        32   -> __aeabi_fadd
         0   -> __aeabi_fdiv
        32   -> __aeabi_fmul
        32   -> __aeabi_fsub
        32 __aeabi_cfcmpeq
      24   Planner::max_allowable_speed(float const &, float const &, float const &)
        24   -> __aeabi_fmul
        24   -> __aeabi_fsub
         0   -> sqrtf
       0   Planner::movesplanned()
       0   Planner::next_block_index(int8_t)
       0   Planner::prev_block_index(int8_t)
       8   Planner::recalculate()
         8   -> Planner::forward_pass()
         0   -> Planner::recalculate_trapezoids()
         8   -> Planner::reverse_pass()
      32   Planner::recalculate_trapezoids()
        32   -> Planner::calculate_trapezoid_for_block(block_t *, float const &, float const &)
        32   -> Planner::next_block_index(int8_t)
        32   -> __aeabi_d2f
        32   -> __aeabi_ddiv
        32   -> __aeabi_f2d
        32   -> __aeabi_fdiv
      16   Planner::refresh_positioning()
         0   -> Planner::reset_acceleration_rates()
        16   -> Planner::set_position_mm_kinematic(float const *)
        16   -> __aeabi_fdiv
      16   Planner::reset_acceleration_rates()
        16   -> __aeabi_f2uiz
        16   -> __aeabi_fmul
        16   -> __aeabi_ui2f
      24   Planner::reverse_pass()
        24   -> Planner::movesplanned()
        24   -> Planner::prev_block_index(int8_t)
        24   -> Planner::reverse_pass_kernel(block_t *, block_t const *)
      24   Planner::reverse_pass_kernel(block_t *, block_t const *)
        24   -> Planner::max_allowable_speed(float const &, float const &, float const &)
        24 __aeabi_cfcmpeq
        24 __aeabi_cfcmple
        24 __aeabi_cfrcmple
      24   Planner::set_position_mm(AxisEnum, float const &)
        24   -> Stepper::set_position(AxisEnum const &, long const &)
        24   -> __aeabi_f2iz
        24   -> __aeabi_fmul
        24   -> lroundf
      32   Planner::set_position_mm_kinematic(float const *)
        32   -> Planner::_set_position_mm(float const &, float const &, float const &, float const &)
        32   -> Planner::apply_leveling(float *)
        32   -> inverse_kinematics(float const *)
        32   -> inverse_kinematics_MORGAN_SCARA(float const *)
       0   Planner::subobject Planner()
         0   -> Planner::Planner()
       8   Planner::sync_from_steppers()
         8   -> Stepper::position(AxisEnum)
     112   Planner::unapply_leveling(float *)
        96   -> __aeabi_fadd
        96   -> __aeabi_fsub
       108   -> __aeabi_memcpy4
       112   -> __aeabi_memcpy4
        96   -> apply_rotation_xyz(matrix_3x3, float &, float &, float &)
        96   -> bilinear_z_offset(float const *)
        96   -> matrix_3x3::transpose(matrix_3x3)
        96   -> mesh_bed_leveling::active()
        96   -> mesh_bed_leveling::get_z_mks(float const &, float const &)
        96 __aeabi_cfcmpeq
        96 __aeabi_cfrcmple
       0   Temperature::degHotend(uint8_t)
       0   Temperature::degTargetHotend(uint8_t)
         0   -> __aeabi_i2f
       8   Temperature::setTargetHotend(float, uint8_t)
         0   -> Temperature::start_watching_heater(uint8_t)
         8   -> __aeabi_f2iz
       8   Temperature::tooColdToExtrude(uint8_t)
         8   -> Temperature::degHotend(uint8_t)
         8 __aeabi_cfcmple
       0   __sti__routine()
         0   -> Planner::Planner()
       0   mesh_bed_leveling::active()
      24   mesh_bed_leveling::calc_z0(float const &, float const &, float const &, float const &, float const &)
         0   -> __aeabi_fadd
        24   -> __aeabi_fdiv
        24   -> __aeabi_fmul
        24   -> __aeabi_fsub
      40   mesh_bed_leveling::cell_index_x(float const &)
        40   -> __aeabi_d2iz
        40   -> __aeabi_ddiv
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_fadd
        40   -> __aeabi_fdiv
        40   -> __aeabi_fsub
        40   -> __aeabi_i2f
        40   -> __aeabi_ui2f
      40   mesh_bed_leveling::cell_index_y(float const &)
        40   -> __aeabi_d2iz
        40   -> __aeabi_ddiv
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_fadd
        40   -> __aeabi_fdiv
        40   -> __aeabi_fsub
        40   -> __aeabi_i2f
        40   -> __aeabi_ui2f
      40   mesh_bed_leveling::get_z_mks(float const &, float const &)
        40   -> __aeabi_fadd
        40   -> mesh_bed_leveling::calc_z0(float const &, float const &, float const &, float const &, float const &)
        40   -> mesh_bed_leveling::cell_index_x(float const &)
        40   -> mesh_bed_leveling::cell_index_y(float const &)
       0   serialprintPGM(char const *)
         0   -> MarlinSerial::print(char const *)
         0   -> MarlinSerial::write(char const *)


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_11
       4  ??DataTable13_12
       4  ??DataTable13_13
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable15
       4  ??DataTable18
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_10
       4  ??DataTable21_11
       4  ??DataTable21_12
       4  ??DataTable21_2
       4  ??DataTable21_3
       4  ??DataTable21_4
       4  ??DataTable21_5
       4  ??DataTable21_6
       4  ??DataTable21_7
       4  ??DataTable21_8
       4  ??DataTable21_9
      28  ?_0
      32  ?_1
      12  ?_2
      18  CORESIGN(long)
      64  MarlinSerial::print(char const *)
      28  MarlinSerial::write(char const *)
      12  Planner::Planner()
    3666  Planner::_buffer_line(float const &, float const &, float const &, float const &, float, uint8_t)
     108  Planner::_set_position_mm(float const &, float const &, float const &, float const &)
      20  Planner::abl_enabled
          Planner::z_fade_height
          Planner::inverse_z_fade_height
          z_fade_factor
          last_raw_lz
     330  Planner::apply_leveling(float &, float &, float &)
      10  Planner::apply_leveling(float *)
      68  Planner::autotemp_M104_M109()
      36  Planner::bed_level_matrix
    1344  Planner::block_buffer
     124  Planner::block_buffer_head
          Planner::block_buffer_tail
          Planner::autotemp_enabled
          Planner::axis_steps_per_mm
          Planner::steps_to_mm
          Planner::max_acceleration_steps_per_s2
          Planner::position
          Planner::max_acceleration_mm_per_s2
          Planner::autotemp_max
          Planner::autotemp_min
          Planner::autotemp_factor
          Planner::cutoff_long
          Planner::previous_speed
          Planner::previous_nominal_speed
          oldt
      24  Planner::blocks_queued()
     276  Planner::calculate_trapezoid_for_block(block_t *, float const &, float const &)
      66  Planner::check_axes_activity()
     138  Planner::estimate_acceleration_distance(float const &, float const &, float const &)
      62  Planner::forward_pass()
     106  Planner::forward_pass_kernel(block_t const *, block_t *)
      68  Planner::g_uc_extruder_last_move
          Planner::max_feedrate_mm_s
          Planner::min_segment_time
          Planner::min_feedrate_mm_s
          Planner::acceleration
          Planner::retract_acceleration
          Planner::travel_acceleration
          Planner::max_jerk
          Planner::min_travel_feedrate_mm_s
          Planner::block_buffer_runtime_us
          previous_safe_speed
     250  Planner::getHighESpeed()
      52  Planner::init()
     162  Planner::intersection_distance(float const &, float const &, float const &, float const &)
      78  Planner::max_allowable_speed(float const &, float const &, float const &)
      20  Planner::movesplanned()
       8  Planner::next_block_index(int8_t)
       8  Planner::prev_block_index(int8_t)
      16  Planner::recalculate()
     170  Planner::recalculate_trapezoids()
      42  Planner::refresh_positioning()
      56  Planner::reset_acceleration_rates()
      78  Planner::reverse_pass()
     108  Planner::reverse_pass_kernel(block_t *, block_t const *)
      66  Planner::set_position_mm(AxisEnum, float const &)
     108  Planner::set_position_mm_kinematic(float const *)
       2  Planner::subobject Planner()
      30  Planner::sync_from_steppers()
     266  Planner::unapply_leveling(float *)
      12  Temperature::degHotend(uint8_t)
      12  Temperature::degTargetHotend(uint8_t)
      24  Temperature::setTargetHotend(float, uint8_t)
      48  Temperature::tooColdToExtrude(uint8_t)
       6  __sti__routine()
      16  mesh_bed_leveling::active()
      64  mesh_bed_leveling::calc_z0(float const &, float const &, float const &, float const &, float const &)
     144  mesh_bed_leveling::cell_index_x(float const &)
     144  mesh_bed_leveling::cell_index_y(float const &)
     140  mesh_bed_leveling::get_z_mks(float const &, float const &)
       1  planner
      36  serialprintPGM(char const *)
       4  -- Other

 
 1 449 bytes in section .bss
   144 bytes in section .data
     4 bytes in section .init_array
    72 bytes in section .rodata
 7 290 bytes in section .text
 
 6 114 bytes of CODE  memory (+ 1 180 bytes shared)
    72 bytes of CONST memory
 1 593 bytes of DATA  memory

Errors: none
Warnings: 28
