###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.1.114/W32 for ARM         07/Apr/2021  11:05:21
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Users\PLT\Desktop\mksRobinLite_nano\Src\wifi_upload.cpp
#    Command line =  
#        -f C:\Users\PLT\AppData\Local\Temp\EWC387.tmp
#        (C:\Users\PLT\Desktop\mksRobinLite_nano\Src\wifi_upload.cpp -D
#        USE_HAL_DRIVER -D STM32F103xE -D MKS_ROBIN -D MARLIN -D __arm__ -D
#        USE_MKS_WIFI --preprocess=s
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List -lC
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List -lA
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List
#        --diag_suppress Pa050 -o
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.1\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Inc\ -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Src\ -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/Inc\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/CMSIS/Include\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/STM32MKS-3dPrinter\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/Common\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/l6474\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/MotorControl\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/u8glib_arm_v1.17/src\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/arduino\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/arduino/avr\
#        -I C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Inc/Logo\ -Om --c++
#        --no_exceptions --no_rtti -I "D:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.1\arm\CMSIS\Core\Include\" -I "D:\Program
#        Files (x86)\IAR Systems\Embedded Workbench
#        8.1\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List\wifi_upload.lst
#    Object file  =  
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\Obj\wifi_upload.o
#
###############################################################################

C:\Users\PLT\Desktop\mksRobinLite_nano\Src\wifi_upload.cpp
      1          #ifdef USE_MKS_WIFI 
      2          #include "stdint.h"
      3          #include "stddef.h"
      4          #include "stm32f1xx_hal.h"
      5          #include "serial.h"

  #define UNUSED(x) (void) (x)
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\macros.h",88  Warning[Pa181]: 
          incompatible redefinition of macro "UNUSED" (declared at line 87 of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\STM32F1xx_HAL_Driver
          \Inc\stm32f1xx_hal_def.h")

    #define SDSS   18
            ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\pins_MKS_ROBIN_LITE.h",161  Warning[Pa181]: 
          incompatible redefinition of macro "SDSS" (declared at line 62)

  #define PRINT_LED_PIN         PDout(2)
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\BSP\STM32MKS-3dPrinter\mks_fastio.h",14  Warning[Pa181]: 
          incompatible redefinition of macro "PRINT_LED_PIN" (declared at line
          146 of "C:\Users\PLT\Desktop\mksRobinLite_nano\Inc\main.h")
      6          //#include "stm32f10x_gpio.h"
      7          #include "stm32f1xx_hal_gpio.h"
      8          //#include "variant.h"
      9          //#include "ff.h"
     10          //#include "sdio_sdcard.h"
     11          #include "wifi_module.h"
     12          #include "wifi_upload.h"

  };
   ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Inc\wifi_upload.h",18  Warning[Pe375]: 
          declaration requires a typedef name

  };
   ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Inc\wifi_upload.h",32  Warning[Pe375]: 
          declaration requires a typedef name
     13          #include "cardreader.h"

  #define PSTR(str) (str)
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\arduino\avr\pgmspace.h",8  Warning[Pa181]: 
          incompatible redefinition of macro "PSTR" (declared at line 59 of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marl
          in\Marlin.h")

  #define strcpy_P(dest, src) strcpy((dest), (src))
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\arduino\avr\pgmspace.h",23  Warning[Pa181]: 
          incompatible redefinition of macro "strcpy_P" (declared at line 93 of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marl
          in\Marlin_export.h")

  #define strstr_P(a, b) strstr((a), (b))
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\arduino\avr\pgmspace.h",26  Warning[Pa181]: 
          incompatible redefinition of macro "strstr_P" (declared at line 94 of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marl
          in\Marlin_export.h")

  #define sprintf_P(s, f, ...) sprintf((s), (f), __VA_ARGS__)
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\arduino\avr\pgmspace.h",28  Warning[Pa181]: 
          incompatible redefinition of macro "sprintf_P" (declared at line 95
          of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marl
          in\Marlin_export.h")

  #define pgm_read_word_near(addr) pgm_read_word(addr)
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\arduino\avr\pgmspace.h",36  Warning[Pa181]: 
          incompatible redefinition of macro "pgm_read_word_near" (declared at
          line 65 of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marl
          in\Marlin_export.h")

  class SdFile : public SdBaseFile, public Print {
        ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\SdFile.h",45  Warning[Pe611]: 
          overloaded virtual function "Print::write" is only partially
          overridden in class "SdFile"

   \                                 In section .text, align 2
   \   __interwork __softfp void CardReader::setIndex(long)
   \                     _ZN10CardReader8setIndexEl: (+1)
   \        0x0   0x6341             STR      R1,[R0, #+52]
   \        0x2   0xF500 0x7015      ADD      R0,R0,#+596
   \        0x6   0x.... 0x....      B.W      _ZN10SdBaseFile7seekSetEj

   \                                 In section .text, align 2
   \   __interwork __softfp uint32_t CardReader::getFileLength()
   \                     _ZN10CardReader13getFileLengthEv: (+1)
   \        0x0   0xF8D0 0x030C      LDR      R0,[R0, #+780]
   \        0x4   0x4770             BX       LR               ;; return

    FORCE_INLINE bool renameFile(const char * newPath){ file.rename(curDir, newPath);}
                                                                                     ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\cardreader.h",99  Warning[Pe940]: 
          missing return statement at end of non-void function
          "CardReader::renameFile"
     14          #include "language.h"
     15          
     16          #include "ultralcd.h"
     17          
     18          //#include "stm32mks_timer.h"
     19          //#include "sd_usr.h"
     20          
     21          
     22          #define ARRAY_SIZE(a) sizeof(a) / sizeof((a)[0])
     23          
     24          
     25          // ESP8266 command codes
     26          const uint8_t ESP_FLASH_BEGIN = 0x02;
     27          const uint8_t ESP_FLASH_DATA = 0x03;
     28          const uint8_t ESP_FLASH_END = 0x04;
     29          const uint8_t ESP_MEM_BEGIN = 0x05;
     30          const uint8_t ESP_MEM_END = 0x06;
     31          const uint8_t ESP_MEM_DATA = 0x07;
     32          const uint8_t ESP_SYNC = 0x08;
     33          const uint8_t ESP_WRITE_REG = 0x09;
     34          const uint8_t ESP_READ_REG = 0x0a;
     35          
     36          // MAC address storage locations
     37          const uint32_t ESP_OTP_MAC0 = 0x3ff00050;
     38          const uint32_t ESP_OTP_MAC1 = 0x3ff00054;
     39          const uint32_t ESP_OTP_MAC2	= 0x3ff00058;
     40          const uint32_t ESP_OTP_MAC3 = 0x3ff0005c;
     41          
     42          const size_t EspFlashBlockSize = 0x0400;			// 1K byte blocks
     43          
     44          const uint8_t ESP_IMAGE_MAGIC = 0xe9;
     45          const uint8_t ESP_CHECKSUM_MAGIC = 0xef;
     46          
     47          const uint32_t ESP_ERASE_CHIP_ADDR = 0x40004984;	// &SPIEraseChip
     48          const uint32_t ESP_SEND_PACKET_ADDR = 0x40003c80;	// &send_packet
     49          const uint32_t ESP_SPI_READ_ADDR = 0x40004b1c;		// &SPIRead
     50          const uint32_t ESP_UNKNOWN_ADDR = 0x40001121;		// not used
     51          const uint32_t ESP_USER_DATA_RAM_ADDR = 0x3ffe8000;	// &user data ram
     52          const uint32_t ESP_IRAM_ADDR = 0x40100000;			// instruction RAM
     53          const uint32_t ESP_FLASH_ADDR = 0x40200000;			// address of start of Flash
     54          //const uint32_t ESP_FLASH_READ_STUB_BEGIN = IRAM_ADDR + 0x18;
     55          

   \                                 In section .bss, align 4
     56          UPLOAD_STRUCT esp_upload;
   \                     esp_upload:
   \        0x0                      DS8 40
     57          
     58          static const unsigned int retriesPerReset = 3;
     59          static const uint32_t connectAttemptInterval = 50;
     60          static const unsigned int percentToReportIncrement = 5;	// how often we report % complete
     61          static const uint32_t defaultTimeout = 500;	
     62          static const uint32_t eraseTimeout = 15000;	
     63          static const uint32_t blockWriteTimeout = 200;
     64          static const uint32_t blockWriteInterval = 15;			// 15ms is long enough, 10ms is mostly too short
     65          
     66          // Messages corresponding to result codes, should make sense when followed by " error"

   \                                 In section .data, align 4
     67          const char *resultMessages[] =
   \                     resultMessages:
   \        0x0   0x....'....        DC32 ?_0, ?_1, ?_2, ?_3, ?_4, ?_5, ?_6, ?_7, ?_8, ?_9, ?_10
   \              0x....'....  
   \              0x....'....  
   \              0x....'....  
   \              0x....'....  
   \              0x....'....  
   \              0x....'....  
   \              0x....'....  
   \              0x....'....  
   \              0x....'....  
   \              0x....'....  
     68          {
     69          	"no",
     70          	"timeout",
     71          	"comm write",
     72          	"connect",
     73          	"bad reply",
     74          	"file read",
     75          	"empty file",
     76          	"response header",
     77          	"slip frame",
     78          	"slip state",
     79          	"slip data"
     80          };
     81          
     82          // A note on baud rates.
     83          // The ESP8266 supports 921600, 460800, 230400, 115200, 74880 and some lower baud rates.
     84          // 921600b is not reliable because even though it sometimes succeeds in connecting, we get a bad response during uploading after a few blocks.
     85          // Probably our UART ISR cannot receive bytes fast enough, perhaps because of the latency of the system tick ISR.
     86          // 460800b doesn't always manage to connect, but if it does then uploading appears to be reliable.
     87          // 230400b always manages to connect.
     88          static const uint32_t uploadBaudRates[] = { 460800, 230400, 115200, 74880 };
     89          
     90          
     91          

   \                                 In section .text, align 2, keep-with-next
     92          bool IsReady()
     93          {
     94          	return esp_upload.state == upload_idle;
   \                     _Z7IsReadyv: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable26
   \        0x4   0xF990 0x0008      LDRSB    R0,[R0, #+8]
   \        0x8   0x1E40             SUBS     R0,R0,#+1
   \        0xA   0x4180             SBCS     R0,R0,R0
   \        0xC   0x0FC0             LSRS     R0,R0,#+31
   \        0xE   0x4770             BX       LR               ;; return
     95          }
     96          
     97          
     98          

   \                                 In section .text, align 2, keep-with-next
     99          void uploadPort_begin()
    100          {
    101          
    102          	//wifi_deInit (); 
    103          
    104          	//WIFI_COM.end();
    105          	//WIFI_COM.begin(115200, UART_INT_MODE);
    106          	
    107          	WIFI_COM.flushRx();
   \                     _Z16uploadPort_beginv: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable26_1
   \        0x4   0x.... 0x....      B.W      _ZN12MarlinSerial7flushRxEv
    108          	
    109          
    110          }
    111          

   \                                 In section .text, align 2, keep-with-next
    112          void uploadPort_write(const uint8_t *buf, size_t len)
    113          {
   \                     _Z16uploadPort_writePKhj: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    114          	BSP_UartIfTxData(WIFI_COM.getUartStack(), (uint8_t *)buf, len);	
   \        0x6   0x.... 0x....      LDR.W    R0,??DataTable26_1
   \        0xA   0x.... 0x....      BL       _ZN12MarlinSerial12getUartStackEv
   \        0xE   0x462A             MOV      R2,R5
   \       0x10   0x4621             MOV      R1,R4
   \       0x12   0xE8BD 0x4038      POP      {R3-R5,LR}
   \       0x16   0x.... 0x....      B.W      BSP_UartIfTxData
    115          }
    116          

   \                                 In section .text, align 2, keep-with-next
    117          char uploadPort_read()
    118          {
   \                     _Z15uploadPort_readv: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    119          	uint8_t retChar;
    120          	#if 0
    121          	if(retChar = (uint8_t)WIFI_COM.read())
    122          		return retChar;
    123          	else
    124          		return 0;
    125          	#else
    126          	WIFI_COM.readNbytes(&retChar, 1);
   \        0x2   0x2201             MOVS     R2,#+1
   \        0x4   0x4669             MOV      R1,SP
   \        0x6   0x.... 0x....      LDR.W    R0,??DataTable26_1
   \        0xA   0x.... 0x....      BL       _ZN12MarlinSerial10readNbytesEPhj
    127          	return retChar;
   \        0xE   0xF99D 0x0000      LDRSB    R0,[SP, #+0]
   \       0x12   0xBD02             POP      {R1,PC}          ;; return
    128          	#endif
    129          	 
    130          }
    131          

   \                                 In section .text, align 2, keep-with-next
    132          int uploadPort_available()
    133          {
    134          	return WIFI_COM.availableForRead() ;
   \                     _Z20uploadPort_availablev: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable26_1
   \        0x4   0x.... 0x....      B.W      _ZN12MarlinSerial16availableForReadEv
    135          }
    136          

   \                                 In section .text, align 2, keep-with-next
    137          void uploadPort_reset()
    138          {
    139          }
   \                     _Z16uploadPort_resetv: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    140          
    141          

   \                                 In section .text, align 2, keep-with-next
    142          void flushInput()
    143          {
   \                     _Z10flushInputv: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    144          	WIFI_COM.flushRx();
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable26_1
   \        0x6   0x.... 0x....      BL       _ZN12MarlinSerial7flushRxEv
   \        0xA   0xE001             B.N      ??flushInput_0
    145          	while (uploadPort_available() != 0)
    146          	{
    147          		(void)uploadPort_read();
   \                     ??flushInput_1: (+1)
   \        0xC   0x.... 0x....      BL       _Z15uploadPort_readv
    148          		//IWDG_ReloadCounter();    
    149          	}
   \                     ??flushInput_0: (+1)
   \       0x10   0x.... 0x....      BL       _Z20uploadPort_availablev
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD1F9             BNE.N    ??flushInput_1
    150          }
   \       0x18   0xBD01             POP      {R0,PC}          ;; return
    151          
    152          // Extract 1-4 bytes of a value in little-endian order from a buffer beginning at a specified offset

   \                                 In section .text, align 2, keep-with-next
    153          uint32_t getData(unsigned byteCnt, const uint8_t *buf, int ofst)
    154          {
   \                     _Z7getDatajPKhi: (+1)
   \        0x0   0x4603             MOV      R3,R0
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD100             BNE.N    ??getData_0
   \        0x8   0x4770             BX       LR
   \                     ??getData_0: (+1)
   \        0xA   0xB430             PUSH     {R4,R5}
    155          	uint32_t val = 0;
    156          
    157          	if (buf && byteCnt)
   \        0xC   0x2B00             CMP      R3,#+0
   \        0xE   0xD00A             BEQ.N    ??getData_1
    158          	{
    159          		unsigned int shiftCnt = 0;
   \       0x10   0x4604             MOV      R4,R0
    160          		if (byteCnt > 4)
   \       0x12   0x2B04             CMP      R3,#+4
   \       0x14   0xD900             BLS.N    ??getData_2
    161          			byteCnt = 4;
   \       0x16   0x2304             MOVS     R3,#+4
    162          		do
    163          		{
    164          			val |= (uint32_t)buf[ofst++] << shiftCnt;
   \                     ??getData_2: (+1)
   \       0x18   0x5C8D             LDRB     R5,[R1, R2]
   \       0x1A   0x40A5             LSLS     R5,R5,R4
   \       0x1C   0x4328             ORRS     R0,R5,R0
   \       0x1E   0x1C52             ADDS     R2,R2,#+1
    165          			shiftCnt += 8;
   \       0x20   0x3408             ADDS     R4,R4,#+8
    166          		} while (--byteCnt);
   \       0x22   0x1E5B             SUBS     R3,R3,#+1
   \       0x24   0xD1F8             BNE.N    ??getData_2
    167          	}
    168          	return(val);
   \                     ??getData_1: (+1)
   \       0x26   0xBC30             POP      {R4,R5}
   \       0x28   0x4770             BX       LR               ;; return
    169          }
    170          
    171          // Put 1-4 bytes of a value in little-endian order into a buffer beginning at a specified offset.

   \                                 In section .text, align 2, keep-with-next
    172          void putData(uint32_t val, unsigned byteCnt, uint8_t *buf, int ofst)
    173          {
    174          	if (buf && byteCnt)
   \                     _Z7putDatajjPhi: (+1)
   \        0x0   0x2A00             CMP      R2,#+0
   \        0x2   0xD009             BEQ.N    ??putData_0
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD007             BEQ.N    ??putData_0
    175          	{
    176          		if (byteCnt > 4)
   \        0x8   0x2904             CMP      R1,#+4
   \        0xA   0xD900             BLS.N    ??putData_1
    177          		{
    178          			byteCnt = 4;
   \        0xC   0x2104             MOVS     R1,#+4
    179          		}
    180          		do
    181          		{
    182          			buf[ofst++] = (uint8_t)(val & 0xff);
   \                     ??putData_1: (+1)
   \        0xE   0x54D0             STRB     R0,[R2, R3]
   \       0x10   0x1C5B             ADDS     R3,R3,#+1
    183          			val >>= 8;
   \       0x12   0x0A00             LSRS     R0,R0,#+8
    184          		} while (--byteCnt);
   \       0x14   0x1E49             SUBS     R1,R1,#+1
   \       0x16   0xD1FA             BNE.N    ??putData_1
    185          	}
    186          }
   \                     ??putData_0: (+1)
   \       0x18   0x4770             BX       LR               ;; return
    187          
    188          // Read a byte optionally performing SLIP decoding.  The return values are:
    189          //
    190          //	2 - an escaped byte was read successfully
    191          //	1 - a non-escaped byte was read successfully
    192          //	0 - no data was available
    193          //   -1 - the value 0xc0 was encountered (shouldn't happen)
    194          //   -2 - a SLIP escape byte was found but the following byte wasn't available
    195          //   -3 - a SLIP escape byte was followed by an invalid byte

   \                                 In section .text, align 2, keep-with-next
    196          int ReadByte(uint8_t& data, bool slipDecode)
    197          {
   \                     _Z8ReadByteRhb: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    198          	if (uploadPort_available() == 0)
   \        0x6   0x.... 0x....      BL       _Z20uploadPort_availablev
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD101             BNE.N    ??ReadByte_0
    199          	{
    200          		return(0);
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xBD32             POP      {R1,R4,R5,PC}
    201          	}
    202          	
    203          	// at least one byte is available
    204          	data = uploadPort_read();
   \                     ??ReadByte_0: (+1)
   \       0x12   0x.... 0x....      BL       _Z15uploadPort_readv
   \       0x16   0x7020             STRB     R0,[R4, #+0]
    205          	if (!slipDecode)
   \       0x18   0x2D00             CMP      R5,#+0
   \       0x1A   0xD007             BEQ.N    ??ReadByte_1
    206          	{
    207          		return(1);
    208          	}
    209          
    210          	if (data == 0xc0)
   \       0x1C   0x7820             LDRB     R0,[R4, #+0]
   \       0x1E   0x28C0             CMP      R0,#+192
   \       0x20   0xD102             BNE.N    ??ReadByte_2
    211          	{
    212          		// this shouldn't happen
    213          		return(-1);
   \       0x22   0xF04F 0x30FF      MOV      R0,#-1
   \       0x26   0xBD32             POP      {R1,R4,R5,PC}
    214          	}
    215          
    216          	// if not the SLIP escape, we're done
    217          	if (data != 0xdb)
   \                     ??ReadByte_2: (+1)
   \       0x28   0x28DB             CMP      R0,#+219
   \       0x2A   0xD001             BEQ.N    ??ReadByte_3
    218          	{
    219          		return(1);
   \                     ??ReadByte_1: (+1)
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0xBD32             POP      {R1,R4,R5,PC}
    220          	}
    221          
    222          	// SLIP escape, check availability of subsequent byte
    223          	if (uploadPort_available() == 0)
   \                     ??ReadByte_3: (+1)
   \       0x30   0x.... 0x....      BL       _Z20uploadPort_availablev
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD102             BNE.N    ??ReadByte_4
    224          	{
    225          		return(-2);
   \       0x38   0xF06F 0x0001      MVN      R0,#+1
   \       0x3C   0xBD32             POP      {R1,R4,R5,PC}
    226          	}
    227          	
    228          	// process the escaped byte
    229          	data = uploadPort_read();
   \                     ??ReadByte_4: (+1)
   \       0x3E   0x.... 0x....      BL       _Z15uploadPort_readv
   \       0x42   0x7020             STRB     R0,[R4, #+0]
    230          	if (data == 0xdc)
   \       0x44   0x7820             LDRB     R0,[R4, #+0]
   \       0x46   0x28DC             CMP      R0,#+220
   \       0x48   0xD103             BNE.N    ??ReadByte_5
    231          	{
    232          		data = 0xc0;
   \       0x4A   0x20C0             MOVS     R0,#+192
   \       0x4C   0x7020             STRB     R0,[R4, #+0]
    233          		return(2);
   \       0x4E   0x2002             MOVS     R0,#+2
   \       0x50   0xBD32             POP      {R1,R4,R5,PC}
    234          	}
    235          
    236          	if (data == 0xdd)
   \                     ??ReadByte_5: (+1)
   \       0x52   0x28DD             CMP      R0,#+221
   \       0x54   0xD103             BNE.N    ??ReadByte_6
    237          	{
    238          		data = 0xdb;
   \       0x56   0x20DB             MOVS     R0,#+219
   \       0x58   0x7020             STRB     R0,[R4, #+0]
    239          		return(2);
   \       0x5A   0x2002             MOVS     R0,#+2
   \       0x5C   0xBD32             POP      {R1,R4,R5,PC}
    240          	}
    241          	// invalid
    242          	return(-3);
   \                     ??ReadByte_6: (+1)
   \       0x5E   0xF06F 0x0002      MVN      R0,#+2
   \       0x62   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    243          }
    244          // When we write a sync packet, there must be no gaps between most of the characters.
    245          // So use this function, which does a block write to the UART buffer in the latest CoreNG.

   \                                 In section .text, align 2, keep-with-next
    246          void writePacketRaw(const uint8_t *buf, size_t len)
    247          {
    248          	uploadPort_write(buf, len);
   \                     _Z14writePacketRawPKhj: (+1)
   \        0x0   0x....             B.N      _Z16uploadPort_writePKhj
    249          }
    250          
    251          // Write a byte to the serial port optionally SLIP encoding. Return the number of bytes actually written.

   \                                 In section .text, align 2
    252          inline void WriteByteRaw(uint8_t b)
    253          {
   \                     _Z12WriteByteRawh: (+1)
   \        0x0   0xB501             PUSH     {R0,LR}
    254          	uploadPort_write((const uint8_t *)&b, 1);
   \        0x2   0x2101             MOVS     R1,#+1
   \        0x4   0x4668             MOV      R0,SP
   \        0x6   0x.... 0x....      BL       _Z16uploadPort_writePKhj
    255          }
   \        0xA   0xBD01             POP      {R0,PC}          ;; return
    256          
    257          // Write a byte to the serial port optionally SLIP encoding. Return the number of bytes actually written.
    258          inline void WriteByteSlip(uint8_t b)
    259          {
    260          	if (b == 0xC0)
    261          	{
    262          		WriteByteRaw(0xDB);
    263          		WriteByteRaw(0xDC);
    264          	}
    265          	else if (b == 0xDB)
    266          	{
    267          		WriteByteRaw(0xDB);
    268          		WriteByteRaw(0xDD);
    269          	}
    270          	else
    271          	{
    272          		uploadPort_write((const uint8_t *)&b, 1);
    273          	}
    274          }
    275          
    276          // Wait for a data packet to be returned.  If the body of the packet is
    277          // non-zero length, return an allocated buffer indirectly containing the
    278          // data and return the data length. Note that if the pointer for returning
    279          // the data buffer is NULL, the response is expected to be two bytes of zero.
    280          //
    281          // If an error occurs, return a negative value.  Otherwise, return the number
    282          // of bytes in the response (or zero if the response was not the standard "two bytes of zero").

   \                                 In section .text, align 4, keep-with-next
    283          EspUploadResult readPacket(uint8_t op, uint32_t *valp, size_t& bodyLen, uint32_t msTimeout)
    284          {
   \                     _Z10readPackethPjRjj: (+1)
   \        0x0   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \        0x4   0xB084             SUB      SP,SP,#+16
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x4615             MOV      R5,R2
   \        0xA   0x461E             MOV      R6,R3
    285          	typedef enum PacketState
    286          	{
    287          		begin = 0,
    288          		header,
    289          		body,
    290          		end,
    291          		done
    292          	};
                 	 ^
Warning[Pe375]: declaration requires a typedef name
    293          
    294          	const size_t headerLength = 8;
    295          
    296          	uint32_t startTime = millis();
   \        0xC   0x.... 0x....      BL       HAL_GetTick
   \       0x10   0x4607             MOV      R7,R0
    297          	uint8_t hdr[headerLength];
    298          	uint16_t hdrIdx = 0;
   \       0x12   0xF04F 0x0800      MOV      R8,#+0
    299          	bodyLen = 0;
   \       0x16   0x4640             MOV      R0,R8
   \       0x18   0x6028             STR      R0,[R5, #+0]
    300          	uint16_t bodyIdx = 0;
   \       0x1A   0x4681             MOV      R9,R0
    301          	uint8_t respBuf[2];
                 	        ^
Warning[Pe550]: variable "respBuf" was set but never used

  const uint8_t ESP_MEM_BEGIN = 0x05;
                ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Src\wifi_upload.cpp",29  Warning[Pe177]: 
          variable "ESP_MEM_BEGIN" was declared but never referenced

  const uint8_t ESP_MEM_END = 0x06;
                ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Src\wifi_upload.cpp",30  Warning[Pe177]: 
          variable "ESP_MEM_END" was declared but never referenced

  const uint8_t ESP_MEM_DATA = 0x07;
                ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Src\wifi_upload.cpp",31  Warning[Pe177]: 
          variable "ESP_MEM_DATA" was declared but never referenced

  const uint8_t ESP_WRITE_REG = 0x09;
                ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Src\wifi_upload.cpp",33  Warning[Pe177]: 
          variable "ESP_WRITE_REG" was declared but never referenced

  const uint8_t ESP_READ_REG = 0x0a;
                ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Src\wifi_upload.cpp",34  Warning[Pe177]: 
          variable "ESP_READ_REG" was declared but never referenced

  const uint32_t ESP_OTP_MAC0 = 0x3ff00050;
                 ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Src\wifi_upload.cpp",37  Warning[Pe177]: 
          variable "ESP_OTP_MAC0" was declared but never referenced

  const uint32_t ESP_OTP_MAC1 = 0x3ff00054;
                 ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Src\wifi_upload.cpp",38  Warning[Pe177]: 
          variable "ESP_OTP_MAC1" was declared but never referenced

  const uint32_t ESP_OTP_MAC2	= 0x3ff00058;
                 ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Src\wifi_upload.cpp",39  Warning[Pe177]: 
          variable "ESP_OTP_MAC2" was declared but never referenced

  const uint32_t ESP_OTP_MAC3 = 0x3ff0005c;
                 ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Src\wifi_upload.cpp",40  Warning[Pe177]: 
          variable "ESP_OTP_MAC3" was declared but never referenced

  const uint32_t ESP_ERASE_CHIP_ADDR = 0x40004984;	// &SPIEraseChip
                 ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Src\wifi_upload.cpp",47  Warning[Pe177]: 
          variable "ESP_ERASE_CHIP_ADDR" was declared but never referenced

  const uint32_t ESP_SEND_PACKET_ADDR = 0x40003c80;	// &send_packet
                 ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Src\wifi_upload.cpp",48  Warning[Pe177]: 
          variable "ESP_SEND_PACKET_ADDR" was declared but never referenced

  const uint32_t ESP_SPI_READ_ADDR = 0x40004b1c;		// &SPIRead
                 ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Src\wifi_upload.cpp",49  Warning[Pe177]: 
          variable "ESP_SPI_READ_ADDR" was declared but never referenced

  const uint32_t ESP_UNKNOWN_ADDR = 0x40001121;		// not used
                 ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Src\wifi_upload.cpp",50  Warning[Pe177]: 
          variable "ESP_UNKNOWN_ADDR" was declared but never referenced

  const uint32_t ESP_USER_DATA_RAM_ADDR = 0x3ffe8000;	// &user data ram
                 ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Src\wifi_upload.cpp",51  Warning[Pe177]: 
          variable "ESP_USER_DATA_RAM_ADDR" was declared but never referenced

  const uint32_t ESP_IRAM_ADDR = 0x40100000;			// instruction RAM
                 ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Src\wifi_upload.cpp",52  Warning[Pe177]: 
          variable "ESP_IRAM_ADDR" was declared but never referenced

  const uint32_t ESP_FLASH_ADDR = 0x40200000;			// address of start of Flash
                 ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Src\wifi_upload.cpp",53  Warning[Pe177]: 
          variable "ESP_FLASH_ADDR" was declared but never referenced

  static const uint32_t uploadBaudRates[] = { 460800, 230400, 115200, 74880 };
                        ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Src\wifi_upload.cpp",88  Warning[Pe177]: 
          variable "uploadBaudRates" was declared but never referenced
    302          
    303          	// wait for the response
    304          	uint16_t needBytes = 1;
   \       0x1C   0xF04F 0x0A01      MOV      R10,#+1
    305          	PacketState state = begin;
   \       0x20   0x4683             MOV      R11,R0
   \       0x22   0xE003             B.N      ??readPacket_1
    306          	while (state != done)
    307          	{
    308          		uint8_t c;
    309          		EspUploadResult stat;
    310          		
    311          		//IWDG_ReloadCounter();    
    312          
    313          		if (millis() - startTime > msTimeout)
    314          		{
    315          			return(timeout);
    316          		}
    317          
    318          		if (uploadPort_available() < needBytes)
    319          		{
    320          			// insufficient data available
    321          			// preferably, return to Spin() here
    322          			continue;
    323          		}
    324          
    325          		// sufficient bytes have been received for the current state, process them
    326          		switch(state)
    327          		{
    328          		case begin:	// expecting frame start
    329          		case end:		// expecting frame end
    330          			c = uploadPort_read();
    331          			if (c != 0xc0)
    332          			{
    333          				return slipFrame;
    334          			}
    335          			if (state == begin)
    336          			{
    337          				state = header;
   \                     ??readPacket_2: (+1)
   \       0x24   0xF04F 0x0B01      MOV      R11,#+1
    338          				needBytes = 2;
   \       0x28   0xF04F 0x0A02      MOV      R10,#+2
    339          			}
   \                     ??readPacket_1: (+1)
   \       0x2C   0x4658             MOV      R0,R11
   \       0x2E   0x2804             CMP      R0,#+4
   \       0x30   0xD066             BEQ.N    ??readPacket_3
   \       0x32   0x.... 0x....      BL       HAL_GetTick
   \       0x36   0x1BC0             SUBS     R0,R0,R7
   \       0x38   0x4286             CMP      R6,R0
   \       0x3A   0xD319             BCC.N    ??readPacket_4
   \       0x3C   0x.... 0x....      BL       _Z20uploadPort_availablev
   \       0x40   0x4651             MOV      R1,R10
   \       0x42   0x4288             CMP      R0,R1
   \       0x44   0xDBF2             BLT.N    ??readPacket_1
   \       0x46   0x4658             MOV      R0,R11
   \       0x48   0x2803             CMP      R0,#+3
   \       0x4A   0xD86E             BHI.N    ??readPacket_5
   \       0x4C   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??readPacket_0:
   \       0x50   0x02 0x14          DC8      0x2,0x14,0x14,0x2
   \              0x14 0x02    
   \                     ??readPacket_6: (+1)
   \       0x54   0x.... 0x....      BL       _Z15uploadPort_readv
   \       0x58   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \       0x5C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x60   0x28C0             CMP      R0,#+192
   \       0x62   0xD107             BNE.N    ??readPacket_7
   \       0x64   0xF1BB 0x0F00      CMP      R11,#+0
   \       0x68   0xD0DC             BEQ.N    ??readPacket_2
    340          			else
    341          			{
    342          				state = done;
   \       0x6A   0xF04F 0x0B04      MOV      R11,#+4
   \       0x6E   0xE7DD             B.N      ??readPacket_1
    343          			}
   \                     ??readPacket_4: (+1)
   \       0x70   0x2001             MOVS     R0,#+1
   \       0x72   0xE042             B.N      ??readPacket_8
   \                     ??readPacket_7: (+1)
   \       0x74   0x2007             MOVS     R0,#+7
   \       0x76   0xE040             B.N      ??readPacket_8
    344          			break;
    345          
    346          		case header:	// reading an 8-byte header
    347          		case body:		// reading the response body
    348          			{
    349          				int rslt;
    350          				// retrieve a byte with SLIP decoding
    351          				rslt = ReadByte(c, true);
   \                     ??readPacket_9: (+1)
   \       0x78   0x2101             MOVS     R1,#+1
   \       0x7A   0x4668             MOV      R0,SP
   \       0x7C   0x.... 0x....      BL       _Z8ReadByteRhb
    352          				if (rslt != 1 && rslt != 2)
   \       0x80   0x2801             CMP      R0,#+1
   \       0x82   0xD00A             BEQ.N    ??readPacket_10
   \       0x84   0x2802             CMP      R0,#+2
   \       0x86   0xD008             BEQ.N    ??readPacket_10
    353          				{
    354          					// some error occurred
    355          					stat = (rslt == 0 || rslt == -2) ? slipData : slipFrame;
   \       0x88   0x2800             CMP      R0,#+0
   \       0x8A   0xD002             BEQ.N    ??readPacket_11
   \       0x8C   0xF110 0x0F02      CMN      R0,#+2
   \       0x90   0xD101             BNE.N    ??readPacket_12
   \                     ??readPacket_11: (+1)
   \       0x92   0x2009             MOVS     R0,#+9
   \       0x94   0xE031             B.N      ??readPacket_8
   \                     ??readPacket_12: (+1)
   \       0x96   0x2007             MOVS     R0,#+7
    356          					return stat;
   \       0x98   0xE02F             B.N      ??readPacket_8
    357          				}
    358          				else if (state == header)
   \                     ??readPacket_10: (+1)
   \       0x9A   0x4658             MOV      R0,R11
   \       0x9C   0x2801             CMP      R0,#+1
   \       0x9E   0xD11F             BNE.N    ??readPacket_13
    359          				{
    360          					//store the header byte
    361          					hdr[hdrIdx++] = c;
   \       0xA0   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0xA4   0xA901             ADD      R1,SP,#+4
   \       0xA6   0x4642             MOV      R2,R8
   \       0xA8   0xB292             UXTH     R2,R2
   \       0xAA   0x5488             STRB     R0,[R1, R2]
   \       0xAC   0xF108 0x0801      ADD      R8,R8,#+1
    362          					if (hdrIdx >= headerLength)
   \       0xB0   0x4640             MOV      R0,R8
   \       0xB2   0xB280             UXTH     R0,R0
   \       0xB4   0x2808             CMP      R0,#+8
   \       0xB6   0xD3B9             BCC.N    ??readPacket_1
    363          					{
    364          						// get the body length, prepare a buffer for it
    365          						bodyLen = (uint16_t)getData(2, hdr, 2);
   \       0xB8   0x2202             MOVS     R2,#+2
   \       0xBA   0x4610             MOV      R0,R2
   \       0xBC   0x.... 0x....      BL       _Z7getDatajPKhi
   \       0xC0   0xB280             UXTH     R0,R0
   \       0xC2   0x6028             STR      R0,[R5, #+0]
    366          
    367          						// extract the value, if requested
    368          						if (valp != 0)
   \       0xC4   0x2C00             CMP      R4,#+0
   \       0xC6   0xD005             BEQ.N    ??readPacket_14
    369          						{
    370          							*valp = getData(4, hdr, 4);
   \       0xC8   0x2204             MOVS     R2,#+4
   \       0xCA   0xA901             ADD      R1,SP,#+4
   \       0xCC   0x4610             MOV      R0,R2
   \       0xCE   0x.... 0x....      BL       _Z7getDatajPKhi
   \       0xD2   0x6020             STR      R0,[R4, #+0]
    371          						}
    372          
    373          						if (bodyLen != 0)
   \                     ??readPacket_14: (+1)
   \       0xD4   0x6828             LDR      R0,[R5, #+0]
   \       0xD6   0x2800             CMP      R0,#+0
   \       0xD8   0xD009             BEQ.N    ??readPacket_15
    374          						{
    375          							state = body;
   \       0xDA   0xF04F 0x0B02      MOV      R11,#+2
   \       0xDE   0xE7A5             B.N      ??readPacket_1
    376          						}
    377          						else
    378          						{
    379          							needBytes = 1;
    380          							state = end;
    381          						}
    382          					}
    383          				}
    384          				else
    385          				{
    386          					// Store the response body byte, check for completion
    387          					if (bodyIdx < ARRAY_SIZE(respBuf))
    388          					{
    389          						respBuf[bodyIdx] = c;
    390          					}
    391          					++bodyIdx;
   \                     ??readPacket_13: (+1)
   \       0xE0   0xF109 0x0901      ADD      R9,R9,#+1
   \       0xE4   0xFA1F 0xF989      UXTH     R9,R9
    392          					if (bodyIdx >= bodyLen)
   \       0xE8   0x6828             LDR      R0,[R5, #+0]
   \       0xEA   0x4581             CMP      R9,R0
   \       0xEC   0xD39E             BCC.N    ??readPacket_1
    393          					{
    394          						needBytes = 1;
   \                     ??readPacket_15: (+1)
   \       0xEE   0xF04F 0x0A01      MOV      R10,#+1
    395          						state = end;
   \       0xF2   0xF04F 0x0B03      MOV      R11,#+3
   \       0xF6   0xE799             B.N      ??readPacket_1
    396          					}
    397          				}
    398          			}
    399          			break;
    400          
    401          		default:		// this shouldn't happen
    402          			return slipState;
    403          		}
    404          	}
    405          
    406          	// Extract elements from the header
    407          	const uint8_t resp = (uint8_t)getData(1, hdr, 0);
    408          	const uint8_t opRet = (uint8_t)getData(1, hdr, 1);
    409          	// Sync packets often provoke a response with a zero opcode instead of ESP_SYNC
    410          	if (resp != 0x01 || opRet != op)
    411          	{
    412          //debug//printf("resp %02x %02x\n", resp, opRet);
    413          		return respHeader;
    414          	}
    415          
    416          	return success;
   \                     ??readPacket_16: (+1)
   \       0xF8   0x2000             MOVS     R0,#+0
   \                     ??readPacket_8: (+1)
   \       0xFA   0xB005             ADD      SP,SP,#+20
   \       0xFC   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \                     ??readPacket_3: (+1)
   \      0x100   0x2200             MOVS     R2,#+0
   \      0x102   0xA901             ADD      R1,SP,#+4
   \      0x104   0x2001             MOVS     R0,#+1
   \      0x106   0x.... 0x....      BL       _Z7getDatajPKhi
   \      0x10A   0x4604             MOV      R4,R0
   \      0x10C   0x2201             MOVS     R2,#+1
   \      0x10E   0xA901             ADD      R1,SP,#+4
   \      0x110   0x4610             MOV      R0,R2
   \      0x112   0x.... 0x....      BL       _Z7getDatajPKhi
   \      0x116   0xB2E4             UXTB     R4,R4
   \      0x118   0x2C01             CMP      R4,#+1
   \      0x11A   0xD104             BNE.N    ??readPacket_17
   \      0x11C   0xF89D 0x1010      LDRB     R1,[SP, #+16]
   \      0x120   0xB2C0             UXTB     R0,R0
   \      0x122   0x4288             CMP      R0,R1
   \      0x124   0xD0E8             BEQ.N    ??readPacket_16
   \                     ??readPacket_17: (+1)
   \      0x126   0x2006             MOVS     R0,#+6
   \      0x128   0xE7E7             B.N      ??readPacket_8
   \                     ??readPacket_5: (+1)
   \      0x12A   0x2008             MOVS     R0,#+8
   \      0x12C   0xE7E5             B.N      ??readPacket_8
    417          }
    418          
    419          // Send a block of data performing SLIP encoding of the content.

   \                                 In section .text, align 2
    420          inline void writePacket(const uint8_t *data, size_t len)
    421          {
   \                     _Z11writePacketPKhj: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xF5AD 0x6D00      SUB      SP,SP,#+2048
   \        0x6   0x4605             MOV      R5,R0
   \        0x8   0x460C             MOV      R4,R1
    422          	unsigned char outBuf[2048] = {0};
   \        0xA   0x4668             MOV      R0,SP
   \        0xC   0xF44F 0x6100      MOV      R1,#+2048
   \       0x10   0x.... 0x....      BL       __aeabi_memclr4
    423          	unsigned int outIndex = 0;
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x4668             MOV      R0,SP
   \       0x18   0x2C00             CMP      R4,#+0
   \       0x1A   0xE00C             B.N      ??writePacket_0
    424          #if 0
    425          	while (len != 0)
    426          	{
    427          		WriteByteSlip(*data++);
    428          		--len;
    429          	}
    430          #endif
    431          	while (len != 0)
    432          	{
    433          		if (*data == 0xC0)
    434          		{
    435          			outBuf[outIndex++] = 0xDB;
    436          			outBuf[outIndex++] = 0xDC;
    437          		}
    438          		else if (*data == 0xDB)
    439          		{
    440          			outBuf[outIndex++] = 0xDB;
    441          			outBuf[outIndex++] = 0xDD;
    442          		}
    443          		else
    444          		{
    445          			outBuf[outIndex++] = *data;
   \                     ??writePacket_1: (+1)
   \       0x1C   0x5442             STRB     R2,[R0, R1]
   \       0x1E   0x4619             MOV      R1,R3
   \       0x20   0xE007             B.N      ??writePacket_2
    446          			
    447          		}
   \                     ??writePacket_3: (+1)
   \       0x22   0x2ADB             CMP      R2,#+219
   \       0x24   0xD1FA             BNE.N    ??writePacket_1
   \       0x26   0x22DB             MOVS     R2,#+219
   \       0x28   0x5442             STRB     R2,[R0, R1]
   \       0x2A   0x4619             MOV      R1,R3
   \       0x2C   0x22DD             MOVS     R2,#+221
   \       0x2E   0x5442             STRB     R2,[R0, R1]
   \       0x30   0x1C49             ADDS     R1,R1,#+1
    448          		data++;
   \                     ??writePacket_2: (+1)
   \       0x32   0x1C6D             ADDS     R5,R5,#+1
    449          		--len;
   \       0x34   0x1E64             SUBS     R4,R4,#+1
   \                     ??writePacket_0: (+1)
   \       0x36   0xD00A             BEQ.N    ??writePacket_4
   \       0x38   0x1C4B             ADDS     R3,R1,#+1
   \       0x3A   0x782A             LDRB     R2,[R5, #+0]
   \       0x3C   0x2AC0             CMP      R2,#+192
   \       0x3E   0xD1F0             BNE.N    ??writePacket_3
   \       0x40   0x22DB             MOVS     R2,#+219
   \       0x42   0x5442             STRB     R2,[R0, R1]
   \       0x44   0x4619             MOV      R1,R3
   \       0x46   0x22DC             MOVS     R2,#+220
   \       0x48   0x5442             STRB     R2,[R0, R1]
   \       0x4A   0x1C49             ADDS     R1,R1,#+1
   \       0x4C   0xE7F1             B.N      ??writePacket_2
    450          	}
    451          	uploadPort_write((const uint8_t *)outBuf, outIndex);
   \                     ??writePacket_4: (+1)
   \       0x4E   0x.... 0x....      BL       _Z16uploadPort_writePKhj
    452          }
   \       0x52   0xF50D 0x6D00      ADD      SP,SP,#+2048
   \       0x56   0xB001             ADD      SP,SP,#+4
   \       0x58   0xBD30             POP      {R4,R5,PC}       ;; return
    453          
    454          // Send a packet to the serial port while performing SLIP framing. The packet data comprises a header and an optional data block.
    455          // A SLIP packet begins and ends with 0xc0.  The data encapsulated has the bytes
    456          // 0xc0 and 0xdb replaced by the two-byte sequences {0xdb, 0xdc} and {0xdb, 0xdd} respectively.
    457          

   \                                 In section .text, align 2, keep-with-next
    458          void writePacket(const uint8_t *hdr, size_t hdrLen, const uint8_t *data, size_t dataLen)
    459          {
   \                     _Z11writePacketPKhjS0_j: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
   \        0x8   0x461F             MOV      R7,R3
    460          
    461          	WriteByteRaw(0xc0);				// send the packet start character
   \        0xA   0x20C0             MOVS     R0,#+192
   \        0xC   0x.... 0x....      BL       _Z12WriteByteRawh
    462          	writePacket(hdr, hdrLen);		// send the header
   \       0x10   0x4629             MOV      R1,R5
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0x.... 0x....      BL       _Z11writePacketPKhj
    463          	writePacket(data, dataLen);		// send the data block
   \       0x18   0x4639             MOV      R1,R7
   \       0x1A   0x4630             MOV      R0,R6
   \       0x1C   0x.... 0x....      BL       _Z11writePacketPKhj
    464          	WriteByteRaw(0xc0);				// send the packet end character
   \       0x20   0x20C0             MOVS     R0,#+192
   \       0x22   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \       0x26   0x.... 0x....      B.W      _Z12WriteByteRawh
    465          }
    466          
    467          // Send a packet to the serial port while performing SLIP framing. The packet data comprises a header and an optional data block.
    468          // This is like writePacket except that it does a fast block write for both the header and the main data with no SLIP encoding. Used to send sync commands.

   \                                 In section .text, align 2, keep-with-next
    469          void writePacketRaw(const uint8_t *hdr, size_t hdrLen, const uint8_t *data, size_t dataLen)
    470          {
   \                     _Z14writePacketRawPKhjS0_j: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
   \        0x8   0x461F             MOV      R7,R3
    471          	WriteByteRaw(0xc0);				// send the packet start character
   \        0xA   0x20C0             MOVS     R0,#+192
   \        0xC   0x.... 0x....      BL       _Z12WriteByteRawh
    472          	writePacketRaw(hdr, hdrLen);	// send the header
   \       0x10   0x4629             MOV      R1,R5
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0x.... 0x....      BL       _Z14writePacketRawPKhj
    473          	writePacketRaw(data, dataLen);	// send the data block in raw mode
   \       0x18   0x4639             MOV      R1,R7
   \       0x1A   0x4630             MOV      R0,R6
   \       0x1C   0x.... 0x....      BL       _Z14writePacketRawPKhj
    474          	WriteByteRaw(0xc0);				// send the packet end character
   \       0x20   0x20C0             MOVS     R0,#+192
   \       0x22   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \       0x26   0x.... 0x....      B.W      _Z12WriteByteRawh
    475          }
    476          
    477          // Send a command to the attached device together with the supplied data, if any.
    478          // The data is supplied via a list of one or more segments.

   \                                 In section .text, align 2, keep-with-next
    479          void sendCommand(uint8_t op, uint32_t checkVal, const uint8_t *data, size_t dataLen)
    480          {
   \                     _Z11sendCommandhjPKhj: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
   \        0x8   0x461F             MOV      R7,R3
    481          	// populate the header
    482          	uint8_t hdr[8];
    483          	putData(0, 1, hdr, 0);
   \        0xA   0x2300             MOVS     R3,#+0
   \        0xC   0x466A             MOV      R2,SP
   \        0xE   0x2101             MOVS     R1,#+1
   \       0x10   0x4618             MOV      R0,R3
   \       0x12   0x.... 0x....      BL       _Z7putDatajjPhi
    484          	putData(op, 1, hdr, 1);
   \       0x16   0x2301             MOVS     R3,#+1
   \       0x18   0x466A             MOV      R2,SP
   \       0x1A   0x4619             MOV      R1,R3
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0x.... 0x....      BL       _Z7putDatajjPhi
    485          	putData(dataLen, 2, hdr, 2);
   \       0x22   0x2302             MOVS     R3,#+2
   \       0x24   0x466A             MOV      R2,SP
   \       0x26   0x4619             MOV      R1,R3
   \       0x28   0x4638             MOV      R0,R7
   \       0x2A   0x.... 0x....      BL       _Z7putDatajjPhi
    486          	putData(checkVal, 4, hdr, 4);
   \       0x2E   0x2304             MOVS     R3,#+4
   \       0x30   0x466A             MOV      R2,SP
   \       0x32   0x4619             MOV      R1,R3
   \       0x34   0x4628             MOV      R0,R5
   \       0x36   0x.... 0x....      BL       _Z7putDatajjPhi
    487          
    488          	// send the packet
    489          	flushInput();
   \       0x3A   0x.... 0x....      BL       _Z10flushInputv
    490          	if (op == ESP_SYNC)
   \       0x3E   0x2C08             CMP      R4,#+8
   \       0x40   0x463B             MOV      R3,R7
   \       0x42   0x4632             MOV      R2,R6
   \       0x44   0xD104             BNE.N    ??sendCommand_0
    491          	{
    492          		writePacketRaw(hdr, sizeof(hdr), data, dataLen);
   \       0x46   0x2108             MOVS     R1,#+8
   \       0x48   0x4668             MOV      R0,SP
   \       0x4A   0x.... 0x....      BL       _Z14writePacketRawPKhjS0_j
   \       0x4E   0xBDF7             POP      {R0-R2,R4-R7,PC}
    493          	}
    494          	else
    495          	{
    496          		writePacket(hdr, sizeof(hdr), data, dataLen);
   \                     ??sendCommand_0: (+1)
   \       0x50   0x2108             MOVS     R1,#+8
   \       0x52   0x4668             MOV      R0,SP
   \       0x54   0x.... 0x....      BL       _Z11writePacketPKhjS0_j
    497          	}
    498          }
   \       0x58   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
    499          
    500          // Send a command to the attached device together with the supplied data, if any, and get the response

   \                                 In section .text, align 2, keep-with-next
    501          EspUploadResult doCommand(uint8_t op, const uint8_t *data, size_t dataLen, uint32_t checkVal, uint32_t *valp, uint32_t msTimeout)
    502          {
   \                     _Z9doCommandhPKhjjPjj: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x4608             MOV      R0,R1
   \        0x6   0x4619             MOV      R1,R3
   \        0x8   0x9D06             LDR      R5,[SP, #+24]
   \        0xA   0x9E07             LDR      R6,[SP, #+28]
    503          	sendCommand(op, checkVal, data, dataLen);
   \        0xC   0x4613             MOV      R3,R2
   \        0xE   0x4602             MOV      R2,R0
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0x.... 0x....      BL       _Z11sendCommandhjPKhj
    504          	size_t bodyLen;
    505          	EspUploadResult stat = readPacket(op, valp, bodyLen, msTimeout);
   \       0x16   0x4633             MOV      R3,R6
   \       0x18   0x466A             MOV      R2,SP
   \       0x1A   0x4629             MOV      R1,R5
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0x.... 0x....      BL       _Z10readPackethPjRjj
    506          	if (stat == success && bodyLen != 2)
   \       0x22   0x0001             MOVS     R1,R0
   \       0x24   0xD103             BNE.N    ??doCommand_0
   \       0x26   0x9900             LDR      R1,[SP, #+0]
   \       0x28   0x2902             CMP      R1,#+2
   \       0x2A   0xD000             BEQ.N    ??doCommand_0
    507          	{
    508          		stat = badReply;
   \       0x2C   0x2003             MOVS     R0,#+3
    509          	}
    510          
    511          	return stat;
   \                     ??doCommand_0: (+1)
   \       0x2E   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    512          }
    513          
    514          // Send a synchronising packet to the serial port in an attempt to induce
    515          // the ESP8266 to auto-baud lock on the baud rate.

   \                                 In section .text, align 2, keep-with-next
    516          EspUploadResult Sync(uint16_t timeout)
    517          {
   \                     _Z4Synct: (+1)
   \        0x0   0xB578             PUSH     {R3-R6,LR}
   \        0x2   0xB08B             SUB      SP,SP,#+44
   \        0x4   0x4604             MOV      R4,R0
    518          	uint8_t buf[36];
    519          
    520          	// compose the data for the sync attempt
    521          	memset(buf, 0x55, sizeof(buf));
   \        0x6   0x2255             MOVS     R2,#+85
   \        0x8   0x2124             MOVS     R1,#+36
   \        0xA   0xA802             ADD      R0,SP,#+8
   \        0xC   0x.... 0x....      BL       __aeabi_memset4
    522          	buf[0] = 0x07;
   \       0x10   0x2007             MOVS     R0,#+7
   \       0x12   0xF88D 0x0008      STRB     R0,[SP, #+8]
    523          	buf[1] = 0x07;
   \       0x16   0xA802             ADD      R0,SP,#+8
   \       0x18   0x2107             MOVS     R1,#+7
   \       0x1A   0x7041             STRB     R1,[R0, #+1]
    524          	buf[2] = 0x12;
   \       0x1C   0x2112             MOVS     R1,#+18
   \       0x1E   0x7081             STRB     R1,[R0, #+2]
    525          	buf[3] = 0x20;
   \       0x20   0x2020             MOVS     R0,#+32
   \       0x22   0xF88D 0x000B      STRB     R0,[SP, #+11]
    526          
    527          	EspUploadResult stat = doCommand(ESP_SYNC, buf, sizeof(buf), 0, 0, timeout);
   \       0x26   0x9401             STR      R4,[SP, #+4]
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0x9000             STR      R0,[SP, #+0]
   \       0x2C   0x4603             MOV      R3,R0
   \       0x2E   0x2224             MOVS     R2,#+36
   \       0x30   0xA902             ADD      R1,SP,#+8
   \       0x32   0x2008             MOVS     R0,#+8
   \       0x34   0x.... 0x....      BL       _Z9doCommandhPKhjjPjj
   \       0x38   0x4605             MOV      R5,R0
    528          
    529          	// If we got a response other than sync, discard it and wait for a sync response. This happens at higher baud rates.
    530          	for (int i = 0; i < 10 && stat == respHeader; ++i)
   \       0x3A   0x2600             MOVS     R6,#+0
   \                     ??Sync_0: (+1)
   \       0x3C   0x2E0A             CMP      R6,#+10
   \       0x3E   0xDA0B             BGE.N    ??Sync_1
   \       0x40   0x4628             MOV      R0,R5
   \       0x42   0x2806             CMP      R0,#+6
   \       0x44   0xD108             BNE.N    ??Sync_1
    531          	{
    532          		size_t bodyLen;
    533          		stat = readPacket(ESP_SYNC, 0, bodyLen, timeout);
   \       0x46   0x4623             MOV      R3,R4
   \       0x48   0x466A             MOV      R2,SP
   \       0x4A   0x2100             MOVS     R1,#+0
   \       0x4C   0x2008             MOVS     R0,#+8
   \       0x4E   0x.... 0x....      BL       _Z10readPackethPjRjj
   \       0x52   0x4605             MOV      R5,R0
    534          	}
   \       0x54   0x1C76             ADDS     R6,R6,#+1
   \       0x56   0xE7F1             B.N      ??Sync_0
    535          
    536          	if (stat == success)
   \                     ??Sync_1: (+1)
   \       0x58   0x0028             MOVS     R0,R5
   \       0x5A   0xD10B             BNE.N    ??Sync_2
    537          	{
    538          		// Read and discard additional replies
    539          		for (;;)
    540          		{
    541          			size_t bodyLen;
    542          			EspUploadResult rc = readPacket(ESP_SYNC, 0, bodyLen, defaultTimeout);
    543          			if (rc != success || bodyLen != 2)
   \                     ??Sync_3: (+1)
   \       0x5C   0xF44F 0x73FA      MOV      R3,#+500
   \       0x60   0x466A             MOV      R2,SP
   \       0x62   0x2100             MOVS     R1,#+0
   \       0x64   0x2008             MOVS     R0,#+8
   \       0x66   0x.... 0x....      BL       _Z10readPackethPjRjj
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD102             BNE.N    ??Sync_2
   \       0x6E   0x9800             LDR      R0,[SP, #+0]
   \       0x70   0x2802             CMP      R0,#+2
   \       0x72   0xD0F3             BEQ.N    ??Sync_3
    544          			{
    545          				break;
    546          			}
    547          		}
    548          	}
    549          //DEBUG
    550          //	else debug//printf("stat=%d\n", (int)stat);
    551          	return stat;
   \                     ??Sync_2: (+1)
   \       0x74   0x4628             MOV      R0,R5
   \       0x76   0xB00C             ADD      SP,SP,#+48
   \       0x78   0xBD70             POP      {R4-R6,PC}       ;; return
    552          }
    553          
    554          // Send a command to the device to begin the Flash process.

   \                                 In section .text, align 2, keep-with-next
    555          EspUploadResult flashBegin(uint32_t addr, uint32_t size)
    556          {
   \                     _Z10flashBeginjj: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB086             SUB      SP,SP,#+24
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x460C             MOV      R4,R1
    557          	// determine the number of blocks represented by the size
    558          	uint32_t blkCnt;
    559          	blkCnt = (size + EspFlashBlockSize - 1) / EspFlashBlockSize;
    560          
    561          	// ensure that the address is on a block boundary
    562          	addr &= ~(EspFlashBlockSize - 1);
    563          
    564          	// begin the Flash process
    565          	uint8_t buf[16];
    566          	putData(size, 4, buf, 0);
   \        0x8   0x2300             MOVS     R3,#+0
   \        0xA   0xAA02             ADD      R2,SP,#+8
   \        0xC   0x2104             MOVS     R1,#+4
   \        0xE   0x4620             MOV      R0,R4
   \       0x10   0x.... 0x....      BL       _Z7putDatajjPhi
    567          	putData(blkCnt, 4, buf, 4);
   \       0x14   0x2304             MOVS     R3,#+4
   \       0x16   0xAA02             ADD      R2,SP,#+8
   \       0x18   0x4619             MOV      R1,R3
   \       0x1A   0xF204 0x30FF      ADDW     R0,R4,#+1023
   \       0x1E   0x0A80             LSRS     R0,R0,#+10
   \       0x20   0x.... 0x....      BL       _Z7putDatajjPhi
    568          	putData(EspFlashBlockSize, 4, buf, 8);
   \       0x24   0x2308             MOVS     R3,#+8
   \       0x26   0xAA02             ADD      R2,SP,#+8
   \       0x28   0x2104             MOVS     R1,#+4
   \       0x2A   0xF44F 0x6080      MOV      R0,#+1024
   \       0x2E   0x.... 0x....      BL       _Z7putDatajjPhi
    569          	putData(addr, 4, buf, 12);
   \       0x32   0x230C             MOVS     R3,#+12
   \       0x34   0xAA02             ADD      R2,SP,#+8
   \       0x36   0x2104             MOVS     R1,#+4
   \       0x38   0x0AAD             LSRS     R5,R5,#+10
   \       0x3A   0x02AD             LSLS     R5,R5,#+10
   \       0x3C   0x4628             MOV      R0,R5
   \       0x3E   0x.... 0x....      BL       _Z7putDatajjPhi
    570          
    571          	uint32_t timeout = (size != 0) ? eraseTimeout : defaultTimeout;
   \       0x42   0x2C00             CMP      R4,#+0
   \       0x44   0xD002             BEQ.N    ??flashBegin_0
   \       0x46   0xF643 0x2098      MOVW     R0,#+15000
   \       0x4A   0xE001             B.N      ??flashBegin_1
   \                     ??flashBegin_0: (+1)
   \       0x4C   0xF44F 0x70FA      MOV      R0,#+500
    572          	return doCommand(ESP_FLASH_BEGIN, buf, sizeof(buf), 0, 0, timeout);
   \                     ??flashBegin_1: (+1)
   \       0x50   0x9001             STR      R0,[SP, #+4]
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0x9000             STR      R0,[SP, #+0]
   \       0x56   0x4603             MOV      R3,R0
   \       0x58   0x2210             MOVS     R2,#+16
   \       0x5A   0xA902             ADD      R1,SP,#+8
   \       0x5C   0x2002             MOVS     R0,#+2
   \       0x5E   0x.... 0x....      BL       _Z9doCommandhPKhjjPjj
   \       0x62   0xB007             ADD      SP,SP,#+28
   \       0x64   0xBD30             POP      {R4,R5,PC}       ;; return
    573          }
    574          
    575          // Send a command to the device to terminate the Flash process

   \                                 In section .text, align 2, keep-with-next
    576          EspUploadResult flashFinish(bool reboot)
    577          {
   \                     _Z11flashFinishb: (+1)
   \        0x0   0xB51F             PUSH     {R0-R4,LR}
    578          	uint8_t buf[4];
    579          	putData(reboot ? 0 : 1, 4, buf, 0);
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x1E64             SUBS     R4,R4,#+1
   \        0x6   0x41A4             SBCS     R4,R4,R4
   \        0x8   0x0FE4             LSRS     R4,R4,#+31
   \        0xA   0x2300             MOVS     R3,#+0
   \        0xC   0xAA02             ADD      R2,SP,#+8
   \        0xE   0x2104             MOVS     R1,#+4
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0x.... 0x....      BL       _Z7putDatajjPhi
    580          	return doCommand(ESP_FLASH_END, buf, sizeof(buf), 0, 0, defaultTimeout);
   \       0x16   0xF44F 0x70FA      MOV      R0,#+500
   \       0x1A   0x9001             STR      R0,[SP, #+4]
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0x9000             STR      R0,[SP, #+0]
   \       0x20   0x4603             MOV      R3,R0
   \       0x22   0x2204             MOVS     R2,#+4
   \       0x24   0xA902             ADD      R1,SP,#+8
   \       0x26   0x4610             MOV      R0,R2
   \       0x28   0x.... 0x....      BL       _Z9doCommandhPKhjjPjj
   \       0x2C   0xB004             ADD      SP,SP,#+16
   \       0x2E   0xBD10             POP      {R4,PC}          ;; return
    581          }
    582          
    583          // Compute the checksum of a block of data

   \                                 In section .text, align 2, keep-with-next
    584          uint16_t checksum(const uint8_t *data, uint16_t dataLen, uint16_t cksum)
    585          {
    586          	if (data != NULL)
   \                     _Z8checksumPKhtt: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD008             BEQ.N    ??checksum_0
   \        0x4   0xE002             B.N      ??checksum_1
    587          	{
    588          		while (dataLen--)
    589          		{
    590          			cksum ^= (uint16_t)*data++;
   \                     ??checksum_2: (+1)
   \        0x6   0xF810 0x3B01      LDRB     R3,[R0], #+1
   \        0xA   0x405A             EORS     R2,R3,R2
    591          		}
   \                     ??checksum_1: (+1)
   \        0xC   0x460B             MOV      R3,R1
   \        0xE   0x1E59             SUBS     R1,R3,#+1
   \       0x10   0xB29B             UXTH     R3,R3
   \       0x12   0x2B00             CMP      R3,#+0
   \       0x14   0xD1F7             BNE.N    ??checksum_2
    592          	}
    593          	return(cksum);
   \                     ??checksum_0: (+1)
   \       0x16   0x4610             MOV      R0,R2
   \       0x18   0xB280             UXTH     R0,R0
   \       0x1A   0x4770             BX       LR               ;; return
    594          }
    595          

   \                                 In section .text, align 2, keep-with-next
    596          EspUploadResult flashWriteBlock(uint16_t flashParmVal, uint16_t flashParmMask)
    597          {
   \                     _Z15flashWriteBlocktt: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0xF5AD 0x6D83      SUB      SP,SP,#+1048
   \        0x8   0x4604             MOV      R4,R0
   \        0xA   0x460D             MOV      R5,R1
    598          	const uint32_t blkSize = EspFlashBlockSize;
    599          
    600          	// Allocate a data buffer for the combined header and block data
    601          	const uint16_t hdrOfst = 0;
    602          	const uint16_t dataOfst = 16;
    603          	const uint16_t blkBufSize = dataOfst + blkSize;
    604          	uint32_t blkBuf32[blkBufSize/4];
    605          	uint8_t * const blkBuf = reinterpret_cast<uint8_t*>(blkBuf32);
    606          	uint32_t cnt;
    607          
    608          	// Prepare the header for the block
    609          	putData(blkSize, 4, blkBuf, hdrOfst + 0);
   \        0xC   0x2300             MOVS     R3,#+0
   \        0xE   0xAA02             ADD      R2,SP,#+8
   \       0x10   0x2104             MOVS     R1,#+4
   \       0x12   0xF44F 0x6080      MOV      R0,#+1024
   \       0x16   0x.... 0x....      BL       _Z7putDatajjPhi
    610          	putData(esp_upload.uploadBlockNumber, 4, blkBuf, hdrOfst + 4);
   \       0x1A   0x.... 0x....      LDR.W    R6,??DataTable26
   \       0x1E   0x2304             MOVS     R3,#+4
   \       0x20   0xAA02             ADD      R2,SP,#+8
   \       0x22   0x4619             MOV      R1,R3
   \       0x24   0x69F0             LDR      R0,[R6, #+28]
   \       0x26   0x.... 0x....      BL       _Z7putDatajjPhi
    611          	putData(0, 4, blkBuf, hdrOfst + 8);
   \       0x2A   0x2308             MOVS     R3,#+8
   \       0x2C   0xAA02             ADD      R2,SP,#+8
   \       0x2E   0x2104             MOVS     R1,#+4
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x.... 0x....      BL       _Z7putDatajjPhi
    612          	putData(0, 4, blkBuf, hdrOfst + 12);
   \       0x36   0x230C             MOVS     R3,#+12
   \       0x38   0xAA02             ADD      R2,SP,#+8
   \       0x3A   0x2104             MOVS     R1,#+4
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0x.... 0x....      BL       _Z7putDatajjPhi
    613          
    614          	// Get the data for the block
    615          	cnt = card.read_data((char *)(blkBuf + dataOfst),  blkSize); 
   \       0x42   0x.... 0x....      LDR.W    R7,??DataTable26_2
   \       0x46   0xF44F 0x6280      MOV      R2,#+1024
   \       0x4A   0xA906             ADD      R1,SP,#+24
   \       0x4C   0x4638             MOV      R0,R7
   \       0x4E   0x.... 0x....      BL       _ZN10CardReader9read_dataEPci
   \       0x52   0x4680             MOV      R8,R0
    616          	if (cnt != blkSize)
   \       0x54   0xF5B8 0x6F80      CMP      R8,#+1024
   \       0x58   0xD00C             BEQ.N    ??flashWriteBlock_0
    617          	{
    618          		if(card.getsdpos() == esp_upload.fileSize)
   \       0x5A   0x4638             MOV      R0,R7
   \       0x5C   0x.... 0x....      BL       _ZN10CardReader8getsdposEv
   \       0x60   0x6831             LDR      R1,[R6, #+0]
   \       0x62   0x4288             CMP      R0,R1
   \       0x64   0xD13B             BNE.N    ??flashWriteBlock_1
    619          		{
    620          			// partial last block, fill the remainder
    621          			memset(blkBuf + dataOfst + cnt, 0xff, blkSize - cnt);
   \       0x66   0x22FF             MOVS     R2,#+255
   \       0x68   0xF5C8 0x6180      RSB      R1,R8,#+1024
   \       0x6C   0xA806             ADD      R0,SP,#+24
   \       0x6E   0x4440             ADD      R0,R0,R8
   \       0x70   0x.... 0x....      BL       __aeabi_memset
    622          		}
    623          		else
    624          		{
    625          			return fileRead;
    626          		}
    627          	}
    628          
    629          	// Patch the flash parameters into the first block if it is loaded at address 0
    630          	if (esp_upload.uploadBlockNumber == 0 && esp_upload.uploadAddress == 0 && blkBuf[dataOfst] == ESP_IMAGE_MAGIC && flashParmMask != 0)
   \                     ??flashWriteBlock_0: (+1)
   \       0x74   0x69F0             LDR      R0,[R6, #+28]
   \       0x76   0x2800             CMP      R0,#+0
   \       0x78   0xD118             BNE.N    ??flashWriteBlock_2
   \       0x7A   0x6870             LDR      R0,[R6, #+4]
   \       0x7C   0x2800             CMP      R0,#+0
   \       0x7E   0xD115             BNE.N    ??flashWriteBlock_2
   \       0x80   0xF89D 0x0018      LDRB     R0,[SP, #+24]
   \       0x84   0x28E9             CMP      R0,#+233
   \       0x86   0xD111             BNE.N    ??flashWriteBlock_2
   \       0x88   0x0028             MOVS     R0,R5
   \       0x8A   0xD00F             BEQ.N    ??flashWriteBlock_2
    631          	{
    632          		// update the Flash parameters
    633          		uint32_t flashParm = getData(2, blkBuf + dataOfst + 2, 0) & ~(uint32_t)flashParmMask;
   \       0x8C   0x2200             MOVS     R2,#+0
   \       0x8E   0xF10D 0x011A      ADD      R1,SP,#+26
   \       0x92   0x2002             MOVS     R0,#+2
   \       0x94   0x.... 0x....      BL       _Z7getDatajPKhi
   \       0x98   0xEA20 0x0505      BIC      R5,R0,R5
    634          		putData(flashParm | flashParmVal, 2, blkBuf + dataOfst + 2, 0);
   \       0x9C   0x2300             MOVS     R3,#+0
   \       0x9E   0xF10D 0x021A      ADD      R2,SP,#+26
   \       0xA2   0x2102             MOVS     R1,#+2
   \       0xA4   0x432C             ORRS     R4,R4,R5
   \       0xA6   0x4620             MOV      R0,R4
   \       0xA8   0x.... 0x....      BL       _Z7putDatajjPhi
    635          	}
    636          
    637          	// Calculate the block checksum
    638          	uint16_t cksum = checksum(blkBuf + dataOfst, blkSize, ESP_CHECKSUM_MAGIC);
   \                     ??flashWriteBlock_2: (+1)
   \       0xAC   0x22EF             MOVS     R2,#+239
   \       0xAE   0xF44F 0x6180      MOV      R1,#+1024
   \       0xB2   0xA806             ADD      R0,SP,#+24
   \       0xB4   0x.... 0x....      BL       _Z8checksumPKhtt
   \       0xB8   0x4604             MOV      R4,R0
    639          	EspUploadResult stat;
    640          	for (int i = 0; i < 3; i++)
   \       0xBA   0x2500             MOVS     R5,#+0
   \                     ??flashWriteBlock_3: (+1)
   \       0xBC   0x2D03             CMP      R5,#+3
   \       0xBE   0xDA10             BGE.N    ??flashWriteBlock_4
    641          	{
    642          		if ((stat = doCommand(ESP_FLASH_DATA, blkBuf, blkBufSize, cksum, 0, blockWriteTimeout)) == success)
   \       0xC0   0x20C8             MOVS     R0,#+200
   \       0xC2   0x9001             STR      R0,[SP, #+4]
   \       0xC4   0x2000             MOVS     R0,#+0
   \       0xC6   0x9000             STR      R0,[SP, #+0]
   \       0xC8   0x4623             MOV      R3,R4
   \       0xCA   0xF44F 0x6282      MOV      R2,#+1040
   \       0xCE   0xA902             ADD      R1,SP,#+8
   \       0xD0   0x2003             MOVS     R0,#+3
   \       0xD2   0x.... 0x....      BL       _Z9doCommandhPKhjjPjj
   \       0xD6   0x0001             MOVS     R1,R0
   \       0xD8   0xD003             BEQ.N    ??flashWriteBlock_4
    643          		{
    644          			break;
    645          		}
    646          	}
   \       0xDA   0x1C6D             ADDS     R5,R5,#+1
   \       0xDC   0xE7EE             B.N      ??flashWriteBlock_3
   \                     ??flashWriteBlock_1: (+1)
   \       0xDE   0x2004             MOVS     R0,#+4
   \       0xE0   0xE000             B.N      ??flashWriteBlock_5
    647          
    648          	//printf("Upload %d\%\n", ftell(&esp_upload.uploadFile) * 100 / esp_upload.fileSize);
    649          
    650          	return stat;
   \                     ??flashWriteBlock_4: (+1)
   \       0xE2   0xB240             SXTB     R0,R0
   \                     ??flashWriteBlock_5: (+1)
   \       0xE4   0xF50D 0x6D83      ADD      SP,SP,#+1048
   \       0xE8   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    651          }
    652          

   \                                 In section .text, align 4, keep-with-next
    653          void upload_spin()
    654          {
   \                     _Z11upload_spinv: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    655          	switch (esp_upload.state)
   \        0x2   0x....             LDR.N    R4,??DataTable26
   \        0x4   0xF994 0x0008      LDRSB    R0,[R4, #+8]
   \        0x8   0x1E40             SUBS     R0,R0,#+1
   \        0xA   0x2804             CMP      R0,#+4
   \        0xC   0xF200 0x809E      BHI.W    ??upload_spin_1
   \       0x10   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??upload_spin_0:
   \       0x14   0x03 0x14          DC8      0x3,0x14,0x3C,0x6A
   \              0x3C 0x6A    
   \       0x18   0x96 0x00          DC8      0x96,0x0
    656          	{
    657          	case upload_resetting:
    658          #if 1
    659          		if (esp_upload.connectAttemptNumber == esp_upload.retriesPerBaudRate)
   \                     ??upload_spin_2: (+1)
   \       0x1A   0x6920             LDR      R0,[R4, #+16]
   \       0x1C   0x68E1             LDR      R1,[R4, #+12]
   \       0x1E   0x4288             CMP      R0,R1
   \       0x20   0xD105             BNE.N    ??upload_spin_3
    660          		{
    661          			// Time to give up
    662          			//Network::ResetWiFi();
    663          			esp_upload.uploadResult = connected;
   \       0x22   0x2002             MOVS     R0,#+2
   \       0x24   0xF884 0x0024      STRB     R0,[R4, #+36]
    664          			esp_upload.state = upload_done;
   \       0x28   0x2005             MOVS     R0,#+5
   \       0x2A   0x7220             STRB     R0,[R4, #+8]
   \       0x2C   0xBD31             POP      {R0,R4,R5,PC}
    665          		}
    666          		else
    667          		{
    668          			// Reset the serial port at the new baud rate. Also reset the ESP8266.
    669          		//	const uint32_t baud = uploadBaudRates[esp_upload.connectAttemptNumber/esp_upload.retriesPerBaudRate];
    670          			if (esp_upload.connectAttemptNumber % esp_upload.retriesPerBaudRate == 0)
    671          			{
    672          			}
    673          		//	uploadPort.begin(baud);//
    674          		/*	if (uploadPort_available() < 20)
    675          			{
    676          				esp_upload.state = upload_done;
    677          				return;
    678          			}*/
    679          			
    680          			//uploadPort_reset();
    681          			//uploadPort_begin();
    682          		
    683          			esp_upload.lastAttemptTime = esp_upload.lastResetTime = millis();
   \                     ??upload_spin_3: (+1)
   \       0x2E   0x.... 0x....      BL       HAL_GetTick
   \       0x32   0x61A0             STR      R0,[R4, #+24]
   \       0x34   0x6160             STR      R0,[R4, #+20]
    684          			esp_upload.state = upload_connecting;
   \       0x36   0x2002             MOVS     R0,#+2
   \       0x38   0x7220             STRB     R0,[R4, #+8]
   \       0x3A   0xBD31             POP      {R0,R4,R5,PC}
    685          		}
    686          #endif
    687          		break;
    688          
    689          	case upload_connecting:
    690          		if (millis() - esp_upload.lastAttemptTime >= connectAttemptInterval && millis() - esp_upload.lastResetTime >= 500)
   \                     ??upload_spin_4: (+1)
   \       0x3C   0x.... 0x....      BL       HAL_GetTick
   \       0x40   0x6961             LDR      R1,[R4, #+20]
   \       0x42   0x1A40             SUBS     R0,R0,R1
   \       0x44   0x2832             CMP      R0,#+50
   \       0x46   0xF0C0 0x8081      BCC.W    ??upload_spin_1
   \       0x4A   0x.... 0x....      BL       HAL_GetTick
   \       0x4E   0x69A1             LDR      R1,[R4, #+24]
   \       0x50   0x1A40             SUBS     R0,R0,R1
   \       0x52   0xF5B0 0x7FFA      CMP      R0,#+500
   \       0x56   0xD379             BCC.N    ??upload_spin_1
    691          		{
    692          			// Attempt to establish a connection to the ESP8266.
    693          			EspUploadResult res = Sync(5000);
   \       0x58   0xF241 0x3088      MOVW     R0,#+5000
   \       0x5C   0x.... 0x....      BL       _Z4Synct
   \       0x60   0x4605             MOV      R5,R0
    694          			esp_upload.lastAttemptTime = millis();
   \       0x62   0x.... 0x....      BL       HAL_GetTick
   \       0x66   0x6160             STR      R0,[R4, #+20]
    695          			if (res == success)
   \       0x68   0x2D00             CMP      R5,#+0
   \       0x6A   0xD102             BNE.N    ??upload_spin_5
    696          			{
    697          				// Successful connection
    698          //				//MessageF(" success on attempt %d\n", (connectAttemptNumber % retriesPerBaudRate) + 1);
    699          				//printf("connect success\n");
    700          				esp_upload.state = upload_erasing;
   \       0x6C   0x2003             MOVS     R0,#+3
   \       0x6E   0x7220             STRB     R0,[R4, #+8]
   \       0x70   0xBD31             POP      {R0,R4,R5,PC}
    701          			}
    702          			else
    703          			{
    704          				// This attempt failed
    705          				esp_upload.connectAttemptNumber++;
   \                     ??upload_spin_5: (+1)
   \       0x72   0x6920             LDR      R0,[R4, #+16]
   \       0x74   0x1C40             ADDS     R0,R0,#+1
   \       0x76   0x6120             STR      R0,[R4, #+16]
    706          				if (esp_upload.connectAttemptNumber % retriesPerReset == 0)
   \       0x78   0x2103             MOVS     R1,#+3
   \       0x7A   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \       0x7E   0xEB01 0x0141      ADD      R1,R1,R1, LSL #+1
   \       0x82   0x1A40             SUBS     R0,R0,R1
   \       0x84   0xD162             BNE.N    ??upload_spin_1
    707          				{
    708          					esp_upload.state = upload_resetting;		// try a reset and a lower baud rate
   \       0x86   0x2001             MOVS     R0,#+1
   \       0x88   0x7220             STRB     R0,[R4, #+8]
   \       0x8A   0xBD31             POP      {R0,R4,R5,PC}
    709          				}
    710          			}
    711          		}
    712          		break;
    713          
    714          	case upload_erasing:
    715          		if (millis() - esp_upload.lastAttemptTime >= blockWriteInterval)
   \                     ??upload_spin_6: (+1)
   \       0x8C   0x.... 0x....      BL       HAL_GetTick
   \       0x90   0x6961             LDR      R1,[R4, #+20]
   \       0x92   0x1A40             SUBS     R0,R0,R1
   \       0x94   0x280F             CMP      R0,#+15
   \       0x96   0xD359             BCC.N    ??upload_spin_1
    716          		{
    717          			uint32_t eraseSize;
    718          			const uint32_t sectorsPerBlock = 16;
    719          			const uint32_t sectorSize = 4096;
    720          			const uint32_t numSectors = (esp_upload.fileSize + sectorSize - 1)/sectorSize;
   \       0x98   0x6821             LDR      R1,[R4, #+0]
   \       0x9A   0xF601 0x71FF      ADDW     R1,R1,#+4095
   \       0x9E   0x0B09             LSRS     R1,R1,#+12
    721          			const uint32_t startSector = esp_upload.uploadAddress/sectorSize;
    722          			uint32_t headSectors = sectorsPerBlock - (startSector % sectorsPerBlock);
   \       0xA0   0x6860             LDR      R0,[R4, #+4]
   \       0xA2   0xF3C0 0x3203      UBFX     R2,R0,#+12,#+4
   \       0xA6   0xF1C2 0x0210      RSB      R2,R2,#+16
    723          
    724          			if (numSectors < headSectors)
   \       0xAA   0x4291             CMP      R1,R2
   \       0xAC   0xD800             BHI.N    ??upload_spin_7
   \       0xAE   0x460A             MOV      R2,R1
    725          			{
    726          				headSectors = numSectors;
    727          			}
    728          	        	eraseSize = (numSectors < 2 * headSectors)
    729              									? (numSectors + 1) / 2 * sectorSize
    730              									: (numSectors - headSectors) * sectorSize;
   \                     ??upload_spin_7: (+1)
   \       0xB0   0xEBB1 0x0F42      CMP      R1,R2, LSL #+1
   \       0xB4   0xD203             BCS.N    ??upload_spin_8
   \       0xB6   0x1C49             ADDS     R1,R1,#+1
   \       0xB8   0x0849             LSRS     R1,R1,#+1
   \       0xBA   0x0309             LSLS     R1,R1,#+12
   \       0xBC   0xE001             B.N      ??upload_spin_9
   \                     ??upload_spin_8: (+1)
   \       0xBE   0x1A89             SUBS     R1,R1,R2
   \       0xC0   0x0309             LSLS     R1,R1,#+12
    731          
    732          			//MessageF("Erasing %u bytes...\n", fileSize);
    733          			esp_upload.uploadResult = flashBegin(esp_upload.uploadAddress, eraseSize);
   \                     ??upload_spin_9: (+1)
   \       0xC2   0x.... 0x....      BL       _Z10flashBeginjj
   \       0xC6   0xF884 0x0024      STRB     R0,[R4, #+36]
    734          			if (esp_upload.uploadResult == success)
   \       0xCA   0x2800             CMP      R0,#+0
   \       0xCC   0xD109             BNE.N    ??upload_spin_10
    735          			{
    736          				//MessageF("Uploading file...\n");
    737          				esp_upload.uploadBlockNumber = 0;
   \       0xCE   0x2000             MOVS     R0,#+0
   \       0xD0   0x61E0             STR      R0,[R4, #+28]
    738          				esp_upload.uploadNextPercentToReport = percentToReportIncrement;
   \       0xD2   0x2005             MOVS     R0,#+5
   \       0xD4   0x6220             STR      R0,[R4, #+32]
    739          				esp_upload.lastAttemptTime = millis();
   \       0xD6   0x.... 0x....      BL       HAL_GetTick
   \       0xDA   0x6160             STR      R0,[R4, #+20]
    740          				esp_upload.state = upload_uploading;
   \       0xDC   0x2004             MOVS     R0,#+4
   \       0xDE   0x7220             STRB     R0,[R4, #+8]
   \       0xE0   0xBD31             POP      {R0,R4,R5,PC}
    741          			}
    742          			else
    743          			{
    744          				//MessageF("Erase failed\n");
    745          				esp_upload.state = upload_done;
   \                     ??upload_spin_10: (+1)
   \       0xE2   0x2005             MOVS     R0,#+5
   \       0xE4   0x7220             STRB     R0,[R4, #+8]
   \       0xE6   0xBD31             POP      {R0,R4,R5,PC}
    746          			}
    747          		}
    748          		break;
    749          
    750          	case upload_uploading:
    751          		// The ESP needs several milliseconds to recover from one packet before it will accept another
    752          		if (millis() - esp_upload.lastAttemptTime >= 15)
   \                     ??upload_spin_11: (+1)
   \       0xE8   0x.... 0x....      BL       HAL_GetTick
   \       0xEC   0x6961             LDR      R1,[R4, #+20]
   \       0xEE   0x1A40             SUBS     R0,R0,R1
   \       0xF0   0x280F             CMP      R0,#+15
   \       0xF2   0xD32B             BCC.N    ??upload_spin_1
    753          		{
    754          			const uint32_t blkCnt = (esp_upload.fileSize + EspFlashBlockSize - 1) / EspFlashBlockSize;
   \       0xF4   0x6825             LDR      R5,[R4, #+0]
   \       0xF6   0xF205 0x35FF      ADDW     R5,R5,#+1023
   \       0xFA   0x0AAD             LSRS     R5,R5,#+10
    755          			if (esp_upload.uploadBlockNumber < blkCnt)
   \       0xFC   0x69E0             LDR      R0,[R4, #+28]
   \       0xFE   0x42A8             CMP      R0,R5
   \      0x100   0xD21B             BCS.N    ??upload_spin_12
    756          			{
    757          				esp_upload.uploadResult = flashWriteBlock(0, 0);
   \      0x102   0x2100             MOVS     R1,#+0
   \      0x104   0x4608             MOV      R0,R1
   \      0x106   0x.... 0x....      BL       _Z15flashWriteBlocktt
   \      0x10A   0xF884 0x0024      STRB     R0,[R4, #+36]
    758          				esp_upload.lastAttemptTime = millis();
   \      0x10E   0x.... 0x....      BL       HAL_GetTick
   \      0x112   0x6160             STR      R0,[R4, #+20]
    759          				if (esp_upload.uploadResult != success)
   \      0x114   0xF994 0x0024      LDRSB    R0,[R4, #+36]
   \      0x118   0x2800             CMP      R0,#+0
   \      0x11A   0xD001             BEQ.N    ??upload_spin_13
    760          				{
    761          					//MessageF("Flash block upload failed\n");
    762          					esp_upload.state = upload_done;
   \      0x11C   0x2005             MOVS     R0,#+5
   \      0x11E   0x7220             STRB     R0,[R4, #+8]
    763          				}
    764          				const unsigned int percentComplete = (100 * esp_upload.uploadBlockNumber)/blkCnt;
   \                     ??upload_spin_13: (+1)
   \      0x120   0x69E0             LDR      R0,[R4, #+28]
   \      0x122   0x2164             MOVS     R1,#+100
   \      0x124   0x4341             MULS     R1,R1,R0
   \      0x126   0xFBB1 0xF1F5      UDIV     R1,R1,R5
    765          				++esp_upload.uploadBlockNumber;
   \      0x12A   0x1C40             ADDS     R0,R0,#+1
   \      0x12C   0x61E0             STR      R0,[R4, #+28]
    766          				if (percentComplete >= esp_upload.uploadNextPercentToReport)
   \      0x12E   0x6A20             LDR      R0,[R4, #+32]
   \      0x130   0x4281             CMP      R1,R0
   \      0x132   0xD30B             BCC.N    ??upload_spin_1
    767          				{
    768          					//MessageF("%u%% complete\n", percentComplete);
    769          					esp_upload.uploadNextPercentToReport += percentToReportIncrement;
   \      0x134   0x1D40             ADDS     R0,R0,#+5
   \      0x136   0x6220             STR      R0,[R4, #+32]
   \      0x138   0xBD31             POP      {R0,R4,R5,PC}
    770          				}
    771          			}
    772          			else
    773          			{
    774          				esp_upload.state = upload_done;
   \                     ??upload_spin_12: (+1)
   \      0x13A   0x2005             MOVS     R0,#+5
   \      0x13C   0x7220             STRB     R0,[R4, #+8]
   \      0x13E   0xBD31             POP      {R0,R4,R5,PC}
    775          			}
    776          		}
    777          		break;
    778          
    779          	case upload_done:
    780          		card.closefile();
   \                     ??upload_spin_14: (+1)
   \      0x140   0x2100             MOVS     R1,#+0
   \      0x142   0x....             LDR.N    R0,??DataTable26_2
   \      0x144   0x.... 0x....      BL       _ZN10CardReader9closefileEb
    781          		//uploadPort.end();				//	// disable the port, it has a high interrupt priority
    782          		//uploadPort_reset();
    783          
    784          		//WIFI_COM.begin(115200, true);
    785          		//wifi_init(); //WIFI
    786          		
    787          		if (esp_upload.uploadResult == success)
    788          		{
    789          			//printf("upload successfully\n");
    790          		}
    791          		else
    792          		{
    793          			//printf("upload failed\n");
    794          		}
    795          		esp_upload.state = upload_idle;
   \      0x148   0x2000             MOVS     R0,#+0
   \      0x14A   0x7220             STRB     R0,[R4, #+8]
    796          		break;
    797          
    798          	default:
    799          		break;
    800          	}
    801          }
   \                     ??upload_spin_1: (+1)
   \      0x14C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    802          
    803          // Try to upload the given file at the given address

   \                                 In section .text, align 2, keep-with-next
    804          void SendUpdateFile(const char *file, uint32_t address)
    805          {
   \                     _Z14SendUpdateFilePKcj: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x460C             MOV      R4,R1
    806          	/*FRESULT res = f_open(&esp_upload.uploadFile, file,  FA_OPEN_EXISTING | FA_READ);
    807          	
    808          	if(res !=  FR_OK) 
    809          		return;*/
    810          
    811          	int res = card.openFile((char *)file, true, false);
    812          	if(res <  0) 
   \        0x4   0x....             LDR.N    R5,??DataTable26_2
   \        0x6   0x2300             MOVS     R3,#+0
   \        0x8   0x2201             MOVS     R2,#+1
   \        0xA   0x4601             MOV      R1,R0
   \        0xC   0x4628             MOV      R0,R5
   \        0xE   0x.... 0x....      BL       _ZN10CardReader8openFileEPcbb
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD415             BMI.N    ??SendUpdateFile_0
    813          		return;
    814          	
    815             	esp_upload.fileSize = card.getFileLength();
   \       0x16   0x4628             MOV      R0,R5
   \       0x18   0x.... 0x....      BL       _ZN10CardReader13getFileLengthEv
   \       0x1C   0x....             LDR.N    R6,??DataTable26
   \       0x1E   0x6030             STR      R0,[R6, #+0]
    816          	if (esp_upload.fileSize == 0)
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD105             BNE.N    ??SendUpdateFile_1
    817          	{
    818          		//f_close(&esp_upload.uploadFile);
    819          		card.closefile();
   \       0x24   0x2100             MOVS     R1,#+0
   \       0x26   0x4628             MOV      R0,R5
   \       0x28   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x2C   0x.... 0x....      B.W      _ZN10CardReader9closefileEb
    820          		return;
    821          	}
    822          	//f_lseek(&esp_upload.uploadFile, 0);
    823          	card.setIndex(0);
   \                     ??SendUpdateFile_1: (+1)
   \       0x30   0x2100             MOVS     R1,#+0
   \       0x32   0x4628             MOV      R0,R5
   \       0x34   0x.... 0x....      BL       _ZN10CardReader8setIndexEl
    824          	
    825          	esp_upload.uploadAddress = address;
   \       0x38   0x6074             STR      R4,[R6, #+4]
    826          	esp_upload.connectAttemptNumber = 0;
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x6130             STR      R0,[R6, #+16]
    827          	esp_upload.state = upload_resetting;
   \       0x3E   0x2001             MOVS     R0,#+1
   \       0x40   0x7230             STRB     R0,[R6, #+8]
    828          }
   \                     ??SendUpdateFile_0: (+1)
   \       0x42   0xBD70             POP      {R4-R6,PC}       ;; return
    829          
    830          static const uint32_t FirmwareAddress = 0x00000000; //
    831          static const uint32_t WebFilesAddress = 0x00100000; //
    832          
    833          

   \                                 In section .text, align 2, keep-with-next
    834          void ResetWiFiForUpload(int begin_or_end)
    835          {
   \                     _Z18ResetWiFiForUploadi: (+1)
   \        0x0   0xE92D 0x41FF      PUSH     {R0-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
    836          	uint32_t start, now;
    837          #if 0
    838          	/*hardware init*/	
    839          	GPIO_InitTypeDef GPIO_InitStructure;
    840          	GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
    841          	GPIO_InitStructure.Pin = GPIO_PIN_7;//PC7
    842          	GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;   
    843          	HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
    844          
    845          	start = getTick();
    846          	now = start;
    847          	
    848          	//GPIO_ResetBits(GPIOG, GPIO_Pin_1); //reset
    849                  WIFI_RESET();
    850          	if(begin_or_end == 0)
    851          	{
    852          		WIFI_IO2_RESET();
    853          	}
    854          	else
    855          	{
    856          		WIFI_IO2_SET();
    857          		
    858          		
    859          		
    860          	}
    861          	while(getTickDiff(now, start) < 500)
    862          	{
    863          		now = getTick();
    864          	} 	
    865          	
    866          	
    867          	//GPIO_SetBits(GPIOG, GPIO_Pin_1);
    868                  WIFI_SET();
    869          
    870          	GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
    871          	GPIO_InitStructure.Pin = GPIO_PIN_7;//PC7
    872          	GPIO_InitStructure.Mode = GPIO_MODE_INPUT;   
    873          	HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
    874          	#else
    875          
    876          	/*hardware init*/	
    877          	GPIO_InitTypeDef GPIO_InitStructure;
    878          	GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
   \        0x6   0x2003             MOVS     R0,#+3
   \        0x8   0x9003             STR      R0,[SP, #+12]
    879          	GPIO_InitStructure.Pin = GPIO_PIN_7;//PC7
   \        0xA   0x2080             MOVS     R0,#+128
   \        0xC   0x9000             STR      R0,[SP, #+0]
    880          	GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;   
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0x9001             STR      R0,[SP, #+4]
    881          	HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
   \       0x12   0x....             LDR.N    R5,??DataTable26_3  ;; 0x40011000
   \       0x14   0x4669             MOV      R1,SP
   \       0x16   0x4628             MOV      R0,R5
   \       0x18   0x.... 0x....      BL       HAL_GPIO_Init
    882          	
    883          	//GPIO_ResetBits(GPIOG, GPIO_Pin_1); //reset
    884                  
    885          	if(begin_or_end == 0)
   \       0x1C   0x2C00             CMP      R4,#+0
   \       0x1E   0xD105             BNE.N    ??ResetWiFiForUpload_0
    886          	{
    887          		WIFI_IO2_RESET();
   \       0x20   0x2200             MOVS     R2,#+0
   \       0x22   0x2180             MOVS     R1,#+128
   \       0x24   0x4628             MOV      R0,R5
   \       0x26   0x.... 0x....      BL       HAL_GPIO_WritePin
   \       0x2A   0xE004             B.N      ??ResetWiFiForUpload_1
    888          	}
    889          	else
    890          	{
    891          		WIFI_IO2_SET();
   \                     ??ResetWiFiForUpload_0: (+1)
   \       0x2C   0x2201             MOVS     R2,#+1
   \       0x2E   0x2180             MOVS     R1,#+128
   \       0x30   0x4628             MOV      R0,R5
   \       0x32   0x.... 0x....      BL       HAL_GPIO_WritePin
    892          		
    893          	}
    894          
    895          	start = getTick();
   \                     ??ResetWiFiForUpload_1: (+1)
   \       0x36   0x.... 0x....      BL       getTick
   \       0x3A   0x4606             MOV      R6,R0
    896          	now = start;
   \       0x3C   0x4637             MOV      R7,R6
    897          	
    898          	WIFI_RESET();
   \       0x3E   0x.... 0x....      LDR.W    R8,??DataTable26_4  ;; 0x40010800
   \       0x42   0x2200             MOVS     R2,#+0
   \       0x44   0xF44F 0x5180      MOV      R1,#+4096
   \       0x48   0x4640             MOV      R0,R8
   \       0x4A   0x.... 0x....      BL       HAL_GPIO_WritePin
   \       0x4E   0xE002             B.N      ??ResetWiFiForUpload_2
    899          	
    900          	while(getTickDiff(now, start) < 500)
    901          	{
    902          		now = getTick();
   \                     ??ResetWiFiForUpload_3: (+1)
   \       0x50   0x.... 0x....      BL       getTick
   \       0x54   0x4607             MOV      R7,R0
    903          	} 	
   \                     ??ResetWiFiForUpload_2: (+1)
   \       0x56   0x4631             MOV      R1,R6
   \       0x58   0x4638             MOV      R0,R7
   \       0x5A   0x.... 0x....      BL       getTickDiff
   \       0x5E   0xF5B0 0x7FFA      CMP      R0,#+500
   \       0x62   0xD3F5             BCC.N    ??ResetWiFiForUpload_3
    904          	
    905          	
    906          	//GPIO_SetBits(GPIOG, GPIO_Pin_1);
    907                  WIFI_SET();
   \       0x64   0x2201             MOVS     R2,#+1
   \       0x66   0xF44F 0x5180      MOV      R1,#+4096
   \       0x6A   0x4640             MOV      R0,R8
   \       0x6C   0x.... 0x....      BL       HAL_GPIO_WritePin
    908          
    909          	if(begin_or_end == 1)
   \       0x70   0x2C01             CMP      R4,#+1
   \       0x72   0xD109             BNE.N    ??ResetWiFiForUpload_4
    910          	{
    911          		GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
   \       0x74   0x2003             MOVS     R0,#+3
   \       0x76   0x9003             STR      R0,[SP, #+12]
    912          		GPIO_InitStructure.Pin = GPIO_PIN_7;//PC7
   \       0x78   0x2080             MOVS     R0,#+128
   \       0x7A   0x9000             STR      R0,[SP, #+0]
    913          		GPIO_InitStructure.Mode = GPIO_MODE_INPUT;   
   \       0x7C   0x2000             MOVS     R0,#+0
   \       0x7E   0x9001             STR      R0,[SP, #+4]
    914          		HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
   \       0x80   0x4669             MOV      R1,SP
   \       0x82   0x4628             MOV      R0,R5
   \       0x84   0x.... 0x....      BL       HAL_GPIO_Init
    915          	}
    916          	
    917          	#endif
    918          	
    919          }
   \                     ??ResetWiFiForUpload_4: (+1)
   \       0x88   0xE8BD 0x81FF      POP      {R0-R8,PC}       ;; return
    920          
    921          
    922          	
    923          

   \                                 In section .text, align 2, keep-with-next
    924          int32_t wifi_upload(int type)
    925          {
   \                     wifi_upload: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
    926          	esp_upload.retriesPerBaudRate = 3; //9
   \        0x4   0x....             LDR.N    R5,??DataTable26
   \        0x6   0x2003             MOVS     R0,#+3
   \        0x8   0x60E8             STR      R0,[R5, #+12]
    927          
    928          	
    929          
    930          	ResetWiFiForUpload(0); //esp
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x.... 0x....      BL       _Z18ResetWiFiForUploadi
    931          
    932          	
    933          	
    934          	if(type == 0) // wifi firmware
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD10A             BNE.N    ??wifi_upload_0
    935          	{
    936          		SendUpdateFile(ESP_FIRMWARE_FILE, FirmwareAddress);
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x.... 0x....      ADR.W    R0,?_12
   \       0x1A   0x.... 0x....      BL       _Z14SendUpdateFilePKcj
    937          	}
    938          	else if(type == 1) 
    939          	{
    940          		SendUpdateFile(ESP_WEB_FIRMWARE_FILE, FirmwareAddress);
    941          	}
    942          	else if(type == 2) 
    943          	{
    944          		SendUpdateFile(ESP_WEB_FILE, WebFilesAddress);
    945          	}
    946          	else
    947          		return -1;
    948          
    949          	LCD_MESSAGEPGM(MSG_FILE_WIFI_UPDATING);
   \                     ??wifi_upload_1: (+1)
   \       0x1E   0x2100             MOVS     R1,#+0
   \       0x20   0x.... 0x....      ADR.W    R0,?_15
   \       0x24   0x.... 0x....      BL       _Z16lcd_setstatuspgmPKch
   \       0x28   0xE017             B.N      ??wifi_upload_2
   \                     ??wifi_upload_0: (+1)
   \       0x2A   0x2C01             CMP      R4,#+1
   \       0x2C   0xD105             BNE.N    ??wifi_upload_3
   \       0x2E   0x2100             MOVS     R1,#+0
   \       0x30   0x.... 0x....      ADR.W    R0,?_13
   \       0x34   0x.... 0x....      BL       _Z14SendUpdateFilePKcj
   \       0x38   0xE7F1             B.N      ??wifi_upload_1
   \                     ??wifi_upload_3: (+1)
   \       0x3A   0x2C02             CMP      R4,#+2
   \       0x3C   0xD106             BNE.N    ??wifi_upload_4
   \       0x3E   0xF44F 0x1180      MOV      R1,#+1048576
   \       0x42   0x.... 0x....      ADR.W    R0,?_14
   \       0x46   0x.... 0x....      BL       _Z14SendUpdateFilePKcj
   \       0x4A   0xE7E8             B.N      ??wifi_upload_1
   \                     ??wifi_upload_4: (+1)
   \       0x4C   0xF04F 0x30FF      MOV      R0,#-1
   \       0x50   0xBD32             POP      {R1,R4,R5,PC}
    950          	
    951          	while(esp_upload.state != upload_idle)
    952          	{
    953          
    954          		upload_spin();
   \                     ??wifi_upload_5: (+1)
   \       0x52   0x.... 0x....      BL       _Z11upload_spinv
    955          		lcd_update();
   \       0x56   0x.... 0x....      BL       _Z10lcd_updatev
    956          		//IWDG_ReloadCounter();    
    957          	}
   \                     ??wifi_upload_2: (+1)
   \       0x5A   0xF995 0x0008      LDRSB    R0,[R5, #+8]
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD1F7             BNE.N    ??wifi_upload_5
    958          	
    959          	ResetWiFiForUpload(1);
   \       0x62   0x2001             MOVS     R0,#+1
   \       0x64   0x.... 0x....      BL       _Z18ResetWiFiForUploadi
    960          	
    961          	if(esp_upload.uploadResult == success)
   \       0x68   0xF995 0x0024      LDRSB    R0,[R5, #+36]
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0xD101             BNE.N    ??wifi_upload_6
    962          		return 0;
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0xBD32             POP      {R1,R4,R5,PC}
    963          	else
    964          		return -1;
   \                     ??wifi_upload_6: (+1)
   \       0x74   0xF04F 0x30FF      MOV      R0,#-1
   \       0x78   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    965          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \        0x0   0x....'....        DC32     esp_upload

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_1:
   \        0x0   0x....'....        DC32     serial2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_2:
   \        0x0   0x....'....        DC32     card

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_3:
   \        0x0   0x4001'1000        DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_4:
   \        0x0   0x4001'0800        DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ?_12:
   \        0x0   0x2F 0x4D          DC8 "/MksWifi.bin"
   \              0x6B 0x73    
   \              0x57 0x69    
   \              0x66 0x69    
   \              0x2E 0x62    
   \              0x69 0x6E    
   \              0x00         
   \        0xD   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_13:
   \        0x0   0x2F 0x4D          DC8 "/MksWifi_Web.bin"
   \              0x6B 0x73    
   \              0x57 0x69    
   \              0x66 0x69    
   \              0x5F 0x57    
   \              0x65 0x62    
   \              0x2E 0x62    
   \              0x69 0x6E    
   \              0x00         
   \       0x11   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_14:
   \        0x0   0x2F 0x4D          DC8 "/MksWifi_WebView.bin"
   \              0x6B 0x73    
   \              0x57 0x69    
   \              0x66 0x69    
   \              0x5F 0x57    
   \              0x65 0x62    
   \              0x56 0x69    
   \              0x65 0x77    
   \              0x2E 0x62    
   \              0x69 0x6E    
   \              0x00         
   \       0x15   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_15:
   \        0x0   0x57 0x69          DC8 "Wifi updating..."
   \              0x66 0x69    
   \              0x20 0x75    
   \              0x70 0x64    
   \              0x61 0x74    
   \              0x69 0x6E    
   \              0x67 0x2E    
   \              0x2E 0x2E    
   \              0x00         
   \       0x11   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_0:
   \        0x0   0x6E 0x6F          DC8 "no"
   \              0x00         
   \        0x3   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_1:
   \        0x0   0x74 0x69          DC8 "timeout"
   \              0x6D 0x65    
   \              0x6F 0x75    
   \              0x74 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_2:
   \        0x0   0x63 0x6F          DC8 "comm write"
   \              0x6D 0x6D    
   \              0x20 0x77    
   \              0x72 0x69    
   \              0x74 0x65    
   \              0x00         
   \        0xB   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_3:
   \        0x0   0x63 0x6F          DC8 "connect"
   \              0x6E 0x6E    
   \              0x65 0x63    
   \              0x74 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_4:
   \        0x0   0x62 0x61          DC8 "bad reply"
   \              0x64 0x20    
   \              0x72 0x65    
   \              0x70 0x6C    
   \              0x79 0x00    
   \        0xA   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_5:
   \        0x0   0x66 0x69          DC8 "file read"
   \              0x6C 0x65    
   \              0x20 0x72    
   \              0x65 0x61    
   \              0x64 0x00    
   \        0xA   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_6:
   \        0x0   0x65 0x6D          DC8 "empty file"
   \              0x70 0x74    
   \              0x79 0x20    
   \              0x66 0x69    
   \              0x6C 0x65    
   \              0x00         
   \        0xB   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_7:
   \        0x0   0x72 0x65          DC8 "response header"
   \              0x73 0x70    
   \              0x6F 0x6E    
   \              0x73 0x65    
   \              0x20 0x68    
   \              0x65 0x61    
   \              0x64 0x65    
   \              0x72 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_8:
   \        0x0   0x73 0x6C          DC8 "slip frame"
   \              0x69 0x70    
   \              0x20 0x66    
   \              0x72 0x61    
   \              0x6D 0x65    
   \              0x00         
   \        0xB   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_9:
   \        0x0   0x73 0x6C          DC8 "slip state"
   \              0x69 0x70    
   \              0x20 0x73    
   \              0x74 0x61    
   \              0x74 0x65    
   \              0x00         
   \        0xB   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_10:
   \        0x0   0x73 0x6C          DC8 "slip data"
   \              0x69 0x70    
   \              0x20 0x64    
   \              0x61 0x74    
   \              0x61 0x00    
   \        0xA   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_11:
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \       0x17   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \       0x2E   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \       0x45   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \       0x5C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \       0x73   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \       0x8A   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \       0xA1   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \       0xB8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \       0xCF   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \       0xE6   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \       0xFD   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x114   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x12B   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x142   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x159   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x170   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x187   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x19E   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x1B5   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x1CC   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x1E3   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x1FA   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x211   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x228   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x23F   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x256   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x26D   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x284   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x29B   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x2B2   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x2C9   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x2E0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x2F7   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x30E   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x325   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x33C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x353   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x36A   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x381   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x398   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x3AF   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x3C6   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x3DD   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x3F4   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x40B   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x422   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x439   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x450   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x467   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x47E   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x495   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x4AC   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x4C3   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x4DA   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x4F1   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x508   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x51F   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x536   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x54D   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x564   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x57B   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x592   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x5A9   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x5C0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x5D7   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x5EE   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x605   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x61C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x633   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x64A   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x661   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x678   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x68F   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x6A6   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x6BD   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x6D4   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x6EB   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x702   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x719   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x730   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x747   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x75E   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x775   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x78C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x7A3   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x7BA   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x7D1   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x7E8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \      0x7FF   0x00               DC8 0
    966          
    967          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CardReader::getFileLength()
       0   CardReader::setIndex(long)
         0   -> SdBaseFile::seekSet(uint32_t)
       0   IsReady()
      16   ReadByte(uint8_t &, bool)
        16   -> uploadPort_available()
        16   -> uploadPort_read()
      40   ResetWiFiForUpload(int)
        40   -> HAL_GPIO_Init
        40   -> HAL_GPIO_WritePin
        40   -> getTick
        40   -> getTickDiff
      16   SendUpdateFile(char const *, uint32_t)
         0   -> CardReader::closefile(bool)
        16   -> CardReader::getFileLength()
        16   -> CardReader::openFile(char *, bool, bool)
        16   -> CardReader::setIndex(long)
      64   Sync(uint16_t)
        64   -> __aeabi_memset4
        64   -> doCommand(uint8_t, uint8_t const *, size_t, uint32_t, uint32_t *, uint32_t)
        64   -> readPacket(uint8_t, uint32_t *, size_t &, uint32_t)
       8   WriteByteRaw(uint8_t)
         8   -> uploadPort_write(uint8_t const *, size_t)
       0   checksum(uint8_t const *, uint16_t, uint16_t)
      24   doCommand(uint8_t, uint8_t const *, size_t, uint32_t, uint32_t *, uint32_t)
        24   -> readPacket(uint8_t, uint32_t *, size_t &, uint32_t)
        24   -> sendCommand(uint8_t, uint32_t, uint8_t const *, size_t)
      40   flashBegin(uint32_t, uint32_t)
        40   -> doCommand(uint8_t, uint8_t const *, size_t, uint32_t, uint32_t *, uint32_t)
        40   -> putData(uint32_t, unsigned int, uint8_t *, int)
      24   flashFinish(bool)
        24   -> doCommand(uint8_t, uint8_t const *, size_t, uint32_t, uint32_t *, uint32_t)
        24   -> putData(uint32_t, unsigned int, uint8_t *, int)
    1072   flashWriteBlock(uint16_t, uint16_t)
      1072   -> CardReader::getsdpos()
      1072   -> CardReader::read_data(char *, int)
      1072   -> __aeabi_memset
      1072   -> checksum(uint8_t const *, uint16_t, uint16_t)
      1072   -> doCommand(uint8_t, uint8_t const *, size_t, uint32_t, uint32_t *, uint32_t)
      1072   -> getData(unsigned int, uint8_t const *, int)
      1072   -> putData(uint32_t, unsigned int, uint8_t *, int)
       8   flushInput()
         8   -> MarlinSerial::flushRx()
         8   -> uploadPort_available()
         8   -> uploadPort_read()
       8   getData(unsigned int, uint8_t const *, int)
       0   putData(uint32_t, unsigned int, uint8_t *, int)
      56   readPacket(uint8_t, uint32_t *, size_t &, uint32_t)
        56   -> HAL_GetTick
        56   -> ReadByte(uint8_t &, bool)
        56   -> getData(unsigned int, uint8_t const *, int)
        56   -> uploadPort_available()
        56   -> uploadPort_read()
      32   sendCommand(uint8_t, uint32_t, uint8_t const *, size_t)
        32   -> flushInput()
        32   -> putData(uint32_t, unsigned int, uint8_t *, int)
        32   -> writePacket(uint8_t const *, size_t, uint8_t const *, size_t)
        32   -> writePacketRaw(uint8_t const *, size_t, uint8_t const *, size_t)
       0   uploadPort_available()
         0   -> MarlinSerial::availableForRead()
       0   uploadPort_begin()
         0   -> MarlinSerial::flushRx()
       8   uploadPort_read()
         8   -> MarlinSerial::readNbytes(uint8_t *, uint32_t)
       0   uploadPort_reset()
      16   uploadPort_write(uint8_t const *, size_t)
         0   -> BSP_UartIfTxData
        16   -> MarlinSerial::getUartStack()
      16   upload_spin()
        16   -> CardReader::closefile(bool)
        16   -> HAL_GetTick
        16   -> Sync(uint16_t)
        16   -> flashBegin(uint32_t, uint32_t)
        16   -> flashWriteBlock(uint16_t, uint16_t)
      16   wifi_upload
        16   -> ResetWiFiForUpload(int)
        16   -> SendUpdateFile(char const *, uint32_t)
        16   -> lcd_setstatuspgm(char const *, uint8_t)
        16   -> lcd_update()
        16   -> upload_spin()
    2064   writePacket(uint8_t const *, size_t)
      2064   -> __aeabi_memclr4
      2064   -> uploadPort_write(uint8_t const *, size_t)
      24   writePacket(uint8_t const *, size_t, uint8_t const *, size_t)
         0   -> WriteByteRaw(uint8_t)
        24   -> WriteByteRaw(uint8_t)
        24   -> writePacket(uint8_t const *, size_t)
       0   writePacketRaw(uint8_t const *, size_t)
         0   -> uploadPort_write(uint8_t const *, size_t)
      24   writePacketRaw(uint8_t const *, size_t, uint8_t const *, size_t)
         0   -> WriteByteRaw(uint8_t)
        24   -> WriteByteRaw(uint8_t)
        24   -> writePacketRaw(uint8_t const *, size_t)


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable26_2
       4  ??DataTable26_3
       4  ??DataTable26_4
       4  ?_0
       8  ?_1
      12  ?_10
    2048  ?_11
      16  ?_12
      20  ?_13
      24  ?_14
      20  ?_15
      12  ?_2
       8  ?_3
      12  ?_4
      12  ?_5
      12  ?_6
      16  ?_7
      12  ?_8
      12  ?_9
       6  CardReader::getFileLength()
      10  CardReader::setIndex(long)
      16  IsReady()
     100  ReadByte(uint8_t &, bool)
     140  ResetWiFiForUpload(int)
      68  SendUpdateFile(char const *, uint32_t)
     122  Sync(uint16_t)
      12  WriteByteRaw(uint8_t)
      28  checksum(uint8_t const *, uint16_t, uint16_t)
      48  doCommand(uint8_t, uint8_t const *, size_t, uint32_t, uint32_t *, uint32_t)
      40  esp_upload
     102  flashBegin(uint32_t, uint32_t)
      48  flashFinish(bool)
     236  flashWriteBlock(uint16_t, uint16_t)
      26  flushInput()
      42  getData(unsigned int, uint8_t const *, int)
      26  putData(uint32_t, unsigned int, uint8_t *, int)
     302  readPacket(uint8_t, uint32_t *, size_t &, uint32_t)
      44  resultMessages
      90  sendCommand(uint8_t, uint32_t, uint8_t const *, size_t)
       8  uploadPort_available()
       8  uploadPort_begin()
      20  uploadPort_read()
       2  uploadPort_reset()
      26  uploadPort_write(uint8_t const *, size_t)
     334  upload_spin()
     122  wifi_upload
      90  writePacket(uint8_t const *, size_t)
      42  writePacket(uint8_t const *, size_t, uint8_t const *, size_t)
       2  writePacketRaw(uint8_t const *, size_t)
      42  writePacketRaw(uint8_t const *, size_t, uint8_t const *, size_t)

 
    40 bytes in section .bss
    44 bytes in section .data
 2 168 bytes in section .rodata
 2 218 bytes in section .text
 
 2 100 bytes of CODE  memory (+ 118 bytes shared)
 2 168 bytes of CONST memory
    84 bytes of DATA  memory

Errors: none
Warnings: 31
