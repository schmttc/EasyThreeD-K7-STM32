///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V8.30.1.114/W32 for ARM        07/May/2021  14:21:34
// Copyright 1999-2018 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\Marlin_main.cpp
//    Command line =  
//        -f C:\Users\PLT\AppData\Local\Temp\EWEADF.tmp
//        (C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\Marlin_main.cpp
//        -D USE_HAL_DRIVER -D STM32F103xE -D MKS_ROBIN -D MARLIN -D __arm__ -D
//        USE_MKS_WIFI --preprocess=s
//        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List -lC
//        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List -lA
//        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List
//        --diag_suppress Pa050 -o
//        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\Obj
//        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
//        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
//        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
//        8.1\arm\inc\c\DLib_Config_Full.h" -I
//        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Inc\ -I
//        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Src\ -I
//        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
//        -I
//        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
//        -I
//        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/Inc\
//        -I
//        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
//        -I
//        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/CMSIS/Include\
//        -I
//        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/STM32MKS-3dPrinter\
//        -I
//        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/Common\
//        -I
//        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/l6474\
//        -I
//        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/at24cxx\
//        -I
//        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/w25qxx\
//        -I
//        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/MotorControl\
//        -I
//        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/FatFs/src\
//        -I
//        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
//        -I
//        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/Marlin\
//        -I
//        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/u8glib_arm_v1.17/src\
//        -I
//        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/arduino\
//        -I
//        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/arduino/avr\
//        -I C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Inc/Logo\ -Om
//        --c++ --no_exceptions --no_rtti -I "D:\Program Files (x86)\IAR
//        Systems\Embedded Workbench 8.1\arm\CMSIS\Core\Include\" -I
//        "D:\Program Files (x86)\IAR Systems\Embedded Workbench
//        8.1\arm\CMSIS\DSP\Include\")
//    Locale       =  C
//    List file    =  
//        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List\Marlin_main.s
//
///////////////////////////////////////////////////////////////////////////////

        RTMODEL "__CPP_Exceptions", "Disabled"
        RTMODEL "__CPP_Language", "C++14"
        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__dlib_file_descriptor", "1"
        RTMODEL "__dlib_full_locale_support", "1"
        RTMODEL "__dlib_version", "6"
        RTMODEL "__iar_require _Printf", "floats,int_specials"
        AAPCS BASE,INTERWORK
        PRESERVE8
        REQUIRE8

        #define SHT_PROGBITS 0x1
        #define SHT_INIT_ARRAY 0xe

        EXTERN BSP_UartGetNbRxAvalaibleBytes
        EXTERN BSP_UartIfQueueTxData
        EXTERN HAL_Delay
        EXTERN HAL_GPIO_ReadPin
        EXTERN HAL_GPIO_WritePin
        EXTERN HAL_GetTick
        EXTERN HAL_SetTick
        EXTERN HAL_TIM_Base_Start_IT
        EXTERN HAL_TIM_Base_Stop_IT
        EXTERN MSG_BED_DONE
        EXTERN MSG_BED_HEATING
        EXTERN MSG_HEATING
        EXTERN MSG_HEATING_COMPLETE
        EXTERN MSG_HOME_OFFSETS_APPLIED
        EXTERN MSG_MKSPRINTINTING
        EXTERN MSG_OFF
        EXTERN MSG_ON
        EXTERN MSG_PAUSE_PRINT
        EXTERN MSG_USERWAIT
        EXTERN WELCOME_MSG
        EXTERN _Z10lcd_updatev
        EXTERN _Z10safe_delaym
        EXTERN _Z11GoHomeCheckv
        EXTERN _Z11PrintOneKeyv
        EXTERN _Z11kill_screenPKc
        EXTERN _Z12LoadFilamentv
        EXTERN _Z12lcd_detectedv
        EXTERN _Z13gcode_G29_UBLv
        EXTERN _Z13lcd_hasstatusv
        EXTERN _Z13lcd_setstatusPKcb
        EXTERN _Z16lcd_setstatuspgmPKch
        EXTERN _Z17serial_echopair_PPKcS0_
        EXTERN _Z17serial_echopair_PPKcd
        EXTERN _Z17serial_echopair_PPKcf
        EXTERN _Z17serial_echopair_PPKci
        EXTERN _Z17serial_echopair_PPKcm
        EXTERN _Z18apply_rotation_xyz10matrix_3x3RfS0_S0_
        EXTERN _Z19lcd_status_printf_PhPKcz
        EXTERN _Z21lcd_reset_alert_levelv
        EXTERN _Z21lcd_setalertstatuspgmPKc
        EXTERN _Z23ubl_line_to_destinationRKfh
        EXTERN _Z32lcd_filament_change_show_message21FilamentChangeMessage
        EXTERN _Z8BlinkLedv
        EXTERN _Z8lcd_initv
        EXTERN _Z8qr_solvePfiiS_S_
        EXTERN _Z9gcode_G26v
        EXTERN _ZN10CardReader10removeFileEPc
        EXTERN _ZN10CardReader11openLogFileEPc
        EXTERN _ZN10CardReader13write_commandEPc
        EXTERN _ZN10CardReader14checkautostartEb
        EXTERN _ZN10CardReader14startFileprintEv
        EXTERN _ZN10CardReader19printingHasFinishedEv
        EXTERN _ZN10CardReader2lsEv
        EXTERN _ZN10CardReader6initsdEv
        EXTERN _ZN10CardReader7releaseEv
        EXTERN _ZN10CardReader8getsdposEv
        EXTERN _ZN10CardReader8openFileEPcbb
        EXTERN _ZN10CardReader9closefileEb
        EXTERN _ZN10CardReader9getStatusEv
        EXTERN _ZN10CardReaderC1Ev
        EXTERN _ZN10SdBaseFile4readEv
        EXTERN _ZN10SdBaseFile5closeEv
        EXTERN _ZN10SdBaseFile7seekSetEj
        EXTERN _ZN10matrix_3x314create_look_atE8vector_3
        EXTERN _ZN10matrix_3x315set_to_identityEv
        EXTERN _ZN10matrix_3x35debugEPKc
        EXTERN _ZN11Temperature12PID_autotuneEfiib
        EXTERN _ZN11Temperature13manage_heaterEv
        EXTERN _ZN11Temperature14getHeaterPowerEi
        EXTERN _ZN11Temperature16extrude_min_tempE
        EXTERN _ZN11Temperature18allow_cold_extrudeE
        EXTERN _ZN11Temperature18start_watching_bedEv
        EXTERN _ZN11Temperature18target_temperatureE
        EXTERN _ZN11Temperature19current_temperatureE
        EXTERN _ZN11Temperature19disable_all_heatersEv
        EXTERN _ZN11Temperature21start_watching_heaterEh
        EXTERN _ZN11Temperature22target_temperature_bedE
        EXTERN _ZN11Temperature23current_temperature_bedE
        EXTERN _ZN11Temperature2KdE
        EXTERN _ZN11Temperature2KiE
        EXTERN _ZN11Temperature2KpE
        EXTERN _ZN11Temperature4initEv
        EXTERN _ZN11Temperature5bedKdE
        EXTERN _ZN11Temperature5bedKiE
        EXTERN _ZN11Temperature5bedKpE
        EXTERN _ZN11Temperature9updatePIDEv
        EXTERN _ZN12MarlinSerial4readEv
        EXTERN _ZN12MarlinSerial5flushEv
        EXTERN _ZN12MarlinSerial5printEci
        EXTERN _ZN12MarlinSerial5printEdi
        EXTERN _ZN12MarlinSerial5printEii
        EXTERN _ZN12MarlinSerial5printEli
        EXTERN _ZN14MarlinSettings4loadEv
        EXTERN _ZN14MarlinSettings4saveEv
        EXTERN _ZN14MarlinSettings5resetEv
        EXTERN _ZN14MarlinSettings6reportEb
        EXTERN _ZN17mesh_bed_leveling13index_to_xposE
        EXTERN _ZN17mesh_bed_leveling13index_to_yposE
        EXTERN _ZN17mesh_bed_leveling5resetEv
        EXTERN _ZN17mesh_bed_leveling6statusE
        EXTERN _ZN17mesh_bed_leveling8z_offsetE
        EXTERN _ZN17mesh_bed_leveling8z_valuesE
        EXTERN _ZN20unified_bed_leveling11display_mapEi
        EXTERN _ZN20unified_bed_leveling12eeprom_startE
        EXTERN _ZN20unified_bed_leveling14g26_debug_flagE
        EXTERN _ZN20unified_bed_leveling5resetEv
        EXTERN _ZN20unified_bed_leveling5stateE
        EXTERN _ZN20unified_bed_leveling8z_valuesE
        EXTERN _ZN20unified_bed_leveling9load_meshEs
        EXTERN _ZN20unified_bed_levelingC1Ev
        EXTERN _ZN7Planner11abl_enabledE
        EXTERN _ZN7Planner12_buffer_lineERKfS1_S1_S1_fh
        EXTERN _ZN7Planner12accelerationE
        EXTERN _ZN7Planner13z_fade_heightE
        EXTERN _ZN7Planner14apply_levelingERfS0_S0_
        EXTERN _ZN7Planner15set_position_mmE8AxisEnumRKf
        EXTERN _ZN7Planner16_set_position_mmERKfS1_S1_S1_
        EXTERN _ZN7Planner16bed_level_matrixE
        EXTERN _ZN7Planner16min_segment_timeE
        EXTERN _ZN7Planner16unapply_levelingEPf
        EXTERN _ZN7Planner17axis_steps_per_mmE
        EXTERN _ZN7Planner17block_buffer_headE
        EXTERN _ZN7Planner17block_buffer_tailE
        EXTERN _ZN7Planner17max_feedrate_mm_sE
        EXTERN _ZN7Planner17min_feedrate_mm_sE
        EXTERN _ZN7Planner18autotemp_M104_M109Ev
        EXTERN _ZN7Planner19check_axes_activityEv
        EXTERN _ZN7Planner19refresh_positioningEv
        EXTERN _ZN7Planner19travel_accelerationE
        EXTERN _ZN7Planner20retract_accelerationE
        EXTERN _ZN7Planner21inverse_z_fade_heightE
        EXTERN _ZN7Planner24min_travel_feedrate_mm_sE
        EXTERN _ZN7Planner24reset_acceleration_ratesEv
        EXTERN _ZN7Planner25set_position_mm_kinematicEPKf
        EXTERN _ZN7Planner26max_acceleration_mm_per_s2E
        EXTERN _ZN7Planner29max_acceleration_steps_per_s2E
        EXTERN _ZN7Planner8max_jerkE
        EXTERN _ZN7Stepper10quick_stopEv
        EXTERN _ZN7Stepper11synchronizeEv
        EXTERN _ZN7Stepper13current_blockE
        EXTERN _ZN7Stepper16report_positionsEv
        EXTERN _ZN7Stepper18finish_and_disableEv
        EXTERN _ZN7Stepper20get_axis_position_mmE8AxisEnum
        EXTERN _ZN7Stepper4initEv
        EXTERN _ZN8Endstops12report_stateEv
        EXTERN _ZN8Endstops15z_probe_enabledE
        EXTERN _ZN8Endstops16enabled_globallyE
        EXTERN _ZN8Endstops16endstop_hit_bitsE
        EXTERN _ZN8Endstops4M119Ev
        EXTERN _ZN8Endstops7enabledE
        EXTERN _ZN8vector_310get_normalEv
        EXTERN _ZN8vector_35crossES_S_
        EXTERN _ZN8vector_3C1Efff
        EXTERN _ZN8vector_3miES_
        EXTERN _ZN9Stopwatch4stopEv
        EXTERN _ZN9Stopwatch5pauseEv
        EXTERN _ZN9Stopwatch5startEv
        EXTERN _ZN9Stopwatch7getTimeEPmS0_S0_
        EXTERN _ZN9Stopwatch7setTimeEmmm
        EXTERN _ZN9Stopwatch8durationEv
        EXTERN _ZN9Stopwatch9isRunningEv
        EXTERN _ZN9StopwatchC1Ev
        EXTERN _ZTVN10__cxxabiv117__class_type_infoE
        EXTERN __aeabi_atexit
        EXTERN __aeabi_cdcmple
        EXTERN __aeabi_cdrcmple
        EXTERN __aeabi_cfcmpeq
        EXTERN __aeabi_cfcmple
        EXTERN __aeabi_cfrcmple
        EXTERN __aeabi_d2f
        EXTERN __aeabi_d2iz
        EXTERN __aeabi_dadd
        EXTERN __aeabi_ddiv
        EXTERN __aeabi_dmul
        EXTERN __aeabi_dsub
        EXTERN __aeabi_f2d
        EXTERN __aeabi_f2iz
        EXTERN __aeabi_f2uiz
        EXTERN __aeabi_fadd
        EXTERN __aeabi_fdiv
        EXTERN __aeabi_fmul
        EXTERN __aeabi_fsub
        EXTERN __aeabi_i2d
        EXTERN __aeabi_i2f
        EXTERN __aeabi_memcpy
        EXTERN __aeabi_memcpy4
        EXTERN __aeabi_memset
        EXTERN __aeabi_memset4
        EXTERN __aeabi_ui2f
        EXTERN __aeabi_vec_dtor
        EXTERN __dso_handle
        EXTERN __iar_Strchr
        EXTERN __iar_Strstr
        EXTERN atan2f
        EXTERN atof
        EXTERN atoi
        EXTERN blink_time
        EXTERN cos
        EXTERN cosf
        EXTERN customizedSerial
        EXTERN echomagic
        EXTERN epr_read_data
        EXTERN epr_write_data
        EXTERN errormagic
        EXTERN espGcodeFifo
        EXTERN floor
        EXTERN floorf
        EXTERN free
        EXTERN gArrayGpioPin
        EXTERN gArrayGpioPort
        EXTERN htim2
        EXTERN labs
        EXTERN lcd_preheat_bed_temp
        EXTERN lcd_preheat_fan_speed
        EXTERN lcd_preheat_hotend_temp
        EXTERN malloc
        EXTERN mksCfg
        EXTERN mksTmp
        EXTERN package_to_wifi
        EXTERN rand
        EXTERN serial2
        EXTERN sin
        EXTERN sinf
        EXTERN sprintf
        EXTERN sqrt
        EXTERN sqrtf
        EXTERN strcat
        EXTERN strcmp
        EXTERN strcpy
        EXTERN strlen
        EXTERN strncpy
        EXTERN strtod
        EXTERN strtol
        EXTERN strtoul
        EXTERN thermalManager
        EXTERN wifi_looping

        PUBLIC Running
        PUBLIC _Z10freeMemoryv
        PUBLIC _Z10gcode_M104v
        PUBLIC _Z10gcode_M105v
        PUBLIC _Z10gcode_M106v
        PUBLIC _Z10gcode_M107v
        PUBLIC _Z10gcode_M108v
        PUBLIC _Z10gcode_M109v
        PUBLIC _Z10gcode_M110v
        PUBLIC _Z10gcode_M111v
        PUBLIC _Z10gcode_M112v
        PUBLIC _Z10gcode_M113v
        PUBLIC _Z10gcode_M114v
        PUBLIC _Z10gcode_M115v
        PUBLIC _Z10gcode_M117v
        PUBLIC _Z10gcode_M119v
        PUBLIC _Z10gcode_M120v
        PUBLIC _Z10gcode_M121v
        PUBLIC _Z10gcode_M140v
        PUBLIC _Z10gcode_M145v
        PUBLIC _Z10gcode_M190v
        PUBLIC _Z10gcode_M200v
        PUBLIC _Z10gcode_M201v
        PUBLIC _Z10gcode_M203v
        PUBLIC _Z10gcode_M204v
        PUBLIC _Z10gcode_M205v
        PUBLIC _Z10gcode_M206v
        PUBLIC _Z10gcode_M211v
        PUBLIC _Z10gcode_M220v
        PUBLIC _Z10gcode_M221v
        PUBLIC _Z10gcode_M226v
        PUBLIC _Z10gcode_M300v
        PUBLIC _Z10gcode_M301v
        PUBLIC _Z10gcode_M302v
        PUBLIC _Z10gcode_M303v
        PUBLIC _Z10gcode_M304v
        PUBLIC _Z10gcode_M355v
        PUBLIC _Z10gcode_M360v
        PUBLIC _Z10gcode_M361v
        PUBLIC _Z10gcode_M362v
        PUBLIC _Z10gcode_M363v
        PUBLIC _Z10gcode_M364v
        PUBLIC _Z10gcode_M400v
        PUBLIC _Z10gcode_M401v
        PUBLIC _Z10gcode_M402v
        PUBLIC _Z10gcode_M410v
        PUBLIC _Z10gcode_M420v
        PUBLIC _Z10gcode_M421v
        PUBLIC _Z10gcode_M428v
        PUBLIC _Z10gcode_M500v
        PUBLIC _Z10gcode_M501v
        PUBLIC _Z10gcode_M502v
        PUBLIC _Z10gcode_M503v
        PUBLIC _Z10gcode_M600v
        PUBLIC _Z10gcode_M665v
        PUBLIC _Z10gcode_M666v
        PUBLIC _Z10gcode_M851v
        PUBLIC _Z10gcode_M907v
        PUBLIC _Z10gcode_M928v
        PUBLIC _Z10gcode_M999v
        PUBLIC _Z10home_deltav
        PUBLIC _Z10ok_to_sendv
        PUBLIC _Z10servo_initv
        PUBLIC _Z11gcode_G0_G1v
        PUBLIC _Z11gcode_G2_G3b
        PUBLIC _Z11gcode_M0_M1v
        PUBLIC _Z11quick_pausev
        PUBLIC _Z11tool_changehfb
        PUBLIC _Z12ADJUST_DELTAPKf
        PUBLIC _Z13gcode_M18_M84v
        PUBLIC _Z13home_all_axesv
        PUBLIC _Z13setup_homepinv
        PUBLIC _Z13setup_killpinv
        PUBLIC _Z14code_has_valuev
        PUBLIC _Z14code_value_intv
        PUBLIC _Z14do_probe_raisef
        PUBLIC _Z14host_keepalivev
        PUBLIC _Z14mks_WriteToEprv
        PUBLIC _Z14serialprintPGMPKc
        PUBLIC _Z15_commit_commandb
        PUBLIC _Z15_enqueuecommandPKcb
        PUBLIC _Z15_manual_goto_xyRKfS0_
        PUBLIC _Z15code_value_boolv
        PUBLIC _Z15code_value_bytev
        PUBLIC _Z15code_value_longv
        PUBLIC _Z15mbl_mesh_reportv
        PUBLIC _Z15mks_setFeedratev
        PUBLIC _Z15reset_bed_levelv
        PUBLIC _Z15say_not_enteredv
        PUBLIC _Z15setup_powerholdv
        PUBLIC _Z16code_value_floatv
        PUBLIC _Z16code_value_ulongv
        PUBLIC _Z16find_pause_e_posv
        PUBLIC _Z16gcode_line_errorPKcb
        PUBLIC _Z16mks_get_commandsv
        PUBLIC _Z17SCARA_move_to_calhh
        PUBLIC _Z17bilinear_z_offsetPKf
        PUBLIC _Z17code_value_millisv
        PUBLIC _Z17code_value_ushortv
        PUBLIC _Z17gcode_G0_G1_SCARAb
        PUBLIC _Z17get_wifi_commandsv
        PUBLIC _Z17manage_inactivityb
        PUBLIC _Z17mesh_probing_donev
        PUBLIC _Z17pause_file_offsetv
        PUBLIC _Z17quickstop_stepperv
        PUBLIC _Z17refresh_bed_levelv
        PUBLIC _Z17serial_echopair_PPKcb
        PUBLIC _Z17serial_echopair_PPKch
        PUBLIC _Z17set_z_fade_heightf
        PUBLIC _Z18axis_unhomed_errorbbb
        PUBLIC _Z18disable_e_steppersv
        PUBLIC _Z18inverse_kinematicsPKf
        PUBLIC _Z18mks_setTemperaturev
        PUBLIC _Z18out_of_range_errorPKc
        PUBLIC _Z18print_heaterstatesv
        PUBLIC _Z18set_probe_deployedb
        PUBLIC _Z18setup_filrunoutpinv
        PUBLIC _Z18sync_plan_positionv
        PUBLIC _Z19clear_command_queuev
        PUBLIC _Z19code_value_temp_absv
        PUBLIC _Z19do_blocking_move_toRKfS0_S0_S0_
        PUBLIC _Z19enable_all_steppersv
        PUBLIC _Z19get_sdcard_commandsv
        PUBLIC _Z19get_serial_commandsv
        PUBLIC _Z19line_to_destinationf
        PUBLIC _Z19line_to_destinationv
        PUBLIC _Z19mks_getPositionXYZEv
        PUBLIC _Z19refresh_cmd_timeoutv
        PUBLIC _Z20code_value_temp_diffv
        PUBLIC _Z20disable_all_steppersv
        PUBLIC _Z20filament_change_beepb
        PUBLIC _Z20process_next_commandv
        PUBLIC _Z20sync_plan_position_ev
        PUBLIC _Z21do_blocking_move_to_xRKfS0_
        PUBLIC _Z21do_blocking_move_to_zRKfS0_
        PUBLIC _Z21gcode_get_destinationv
        PUBLIC _Z21position_is_reachablePKfb
        PUBLIC _Z21recalc_delta_settingsff
        PUBLIC _Z21unknown_command_errorv
        PUBLIC _Z22do_blocking_move_to_xyRKfS0_S0_
        PUBLIC _Z22get_available_commandsv
        PUBLIC _Z22handle_filament_runoutv
        PUBLIC _Z22refresh_zprobe_zoffsetb
        PUBLIC _Z24FlushSerialRequestResendv
        PUBLIC _Z24enqueue_and_echo_commandPKcb
        PUBLIC _Z24forward_kinematics_DELTAPf
        PUBLIC _Z24forward_kinematics_DELTAfff
        PUBLIC _Z24forward_kinematics_SCARARKfS0_
        PUBLIC _Z24get_homing_bump_feedrate8AxisEnum
        PUBLIC _Z24line_to_current_positionv
        PUBLIC _Z24mesh_line_to_destinationfhh
        PUBLIC _Z24set_bed_leveling_enabledb
        PUBLIC _Z24update_software_endstops8AxisEnum
        PUBLIC _Z25prepare_kinematic_move_toPf
        PUBLIC _Z26clamp_to_software_endstopsPf
        PUBLIC _Z26set_current_to_destinationv
        PUBLIC _Z26set_destination_to_currentv
        PUBLIC _Z27enqueue_and_echo_commands_PPKc
        PUBLIC _Z27gcode_G29_MESH_BED_LEVELINGv
        PUBLIC _Z27get_cartesian_from_steppersv
        PUBLIC _Z27prepare_move_to_destinationv
        PUBLIC _Z28SYNC_PLAN_POSITION_KINEMATICv
        PUBLIC _Z28bilinear_line_to_destinationftt
        PUBLIC _Z28delta_safe_distance_from_topv
        PUBLIC _Z28gcode_M421_MESH_BED_LEVELINGv
        PUBLIC _Z28sync_plan_position_kinematicv
        PUBLIC _Z30code_value_millis_from_secondsv
        PUBLIC _Z31calculate_volumetric_multiplierf
        PUBLIC _Z31inverse_kinematics_MORGAN_SCARAPKf
        PUBLIC _Z32calculate_volumetric_multipliersv
        PUBLIC _Z32get_target_extruder_from_commandi
        PUBLIC _Z34set_current_from_steppers_for_axis8AxisEnum
        PUBLIC _Z37prepare_move_to_destination_cartesianv
        PUBLIC _Z42prepare_uninterpolated_move_to_destinationf
        PUBLIC _Z4idleb
        PUBLIC _Z4killPKc
        PUBLIC _Z4stopv
        PUBLIC _Z5isnanf
        PUBLIC _Z7RUNPLANf
        PUBLIC _Z7gcode_Th
        PUBLIC _Z7mks_G28Pc
        PUBLIC _Z7suicidev
        PUBLIC _Z8gcode_G4v
        PUBLIC _Z8plan_arcPfS_h
        PUBLIC _Z8probe_ptffbi
        PUBLIC _Z9IsRunningv
        PUBLIC _Z9IsStoppedv
        PUBLIC _Z9code_seenc
        PUBLIC _Z9gcode_G28v
        PUBLIC _Z9gcode_G29v
        PUBLIC _Z9gcode_G30v
        PUBLIC _Z9gcode_G92v
        PUBLIC _Z9gcode_M17v
        PUBLIC _Z9gcode_M20v
        PUBLIC _Z9gcode_M21v
        PUBLIC _Z9gcode_M22v
        PUBLIC _Z9gcode_M23v
        PUBLIC _Z9gcode_M24v
        PUBLIC _Z9gcode_M25v
        PUBLIC _Z9gcode_M26v
        PUBLIC _Z9gcode_M27v
        PUBLIC _Z9gcode_M28v
        PUBLIC _Z9gcode_M29v
        PUBLIC _Z9gcode_M30v
        PUBLIC _Z9gcode_M31v
        PUBLIC _Z9gcode_M32v
        PUBLIC _Z9gcode_M42v
        PUBLIC _Z9gcode_M49v
        PUBLIC _Z9gcode_M75v
        PUBLIC _Z9gcode_M76v
        PUBLIC _Z9gcode_M77v
        PUBLIC _Z9gcode_M81v
        PUBLIC _Z9gcode_M82v
        PUBLIC _Z9gcode_M83v
        PUBLIC _Z9gcode_M85v
        PUBLIC _Z9gcode_M92v
        PUBLIC _ZN10CardReader10isFileOpenEv
        PUBLIC _ZN10CardReader10lastOpenOkEv
        PUBLIC _ZN10CardReader12pauseSDPrintEv
        PUBLIC _ZN10CardReader3eofEv
        PUBLIC _ZN10CardReader3getEv
        PUBLIC _ZN10CardReader8setIndexEl
        PUBLIC _ZN10CardReaderD1Ev
        PUBLIC _ZN10SdBaseFileD1Ev
        PUBLIC _ZN10SdBaseFileD2Ev
        PUBLIC _ZN10duration_tC1ERKj
        PUBLIC _ZN11Temperature12degTargetBedEv
        PUBLIC _ZN11Temperature12isCoolingBedEv
        PUBLIC _ZN11Temperature12setTargetBedEf
        PUBLIC _ZN11Temperature15degTargetHotendEh
        PUBLIC _ZN11Temperature15isCoolingHotendEh
        PUBLIC _ZN11Temperature15setTargetHotendEfh
        PUBLIC _ZN11Temperature16tooColdToExtrudeEh
        PUBLIC _ZN11Temperature6degBedEv
        PUBLIC _ZN11Temperature9degHotendEh
        PUBLIC _ZN12MarlinSerial5printEPKc
        PUBLIC _ZN12MarlinSerial5writeEPKc
        PUBLIC _ZN12MarlinSerial5writeEh
        PUBLIC _ZN12MarlinSerial9availableEv
        PUBLIC _ZN13CircularQueueI6tone_tLh4EE6isFullEv
        PUBLIC _ZN13CircularQueueI6tone_tLh4EE7dequeueEv
        PUBLIC _ZN13CircularQueueI6tone_tLh4EE7enqueueERKS0_
        PUBLIC _ZN13CircularQueueI6tone_tLh4EE7isEmptyEv
        PUBLIC _ZN13CircularQueueI6tone_tLh4EEC1Ev
        PUBLIC _ZN17mesh_bed_leveling10set_activeEb
        PUBLIC _ZN17mesh_bed_leveling12cell_index_xERKf
        PUBLIC _ZN17mesh_bed_leveling12cell_index_yERKf
        PUBLIC _ZN17mesh_bed_leveling12set_has_meshEb
        PUBLIC _ZN17mesh_bed_leveling12set_zigzag_zEaRKf
        PUBLIC _ZN17mesh_bed_leveling13probe_index_xERKf
        PUBLIC _ZN17mesh_bed_leveling13probe_index_yERKf
        PUBLIC _ZN17mesh_bed_leveling5set_zEaaRKf
        PUBLIC _ZN17mesh_bed_leveling6activeEv
        PUBLIC _ZN17mesh_bed_leveling6zigzagEaRaS0_
        PUBLIC _ZN17mesh_bed_leveling8has_meshEv
        PUBLIC _ZN18DATA_REPRINT_ITMESC1Ev
        PUBLIC _ZN18DATA_REPRINT_ITMESD1Ev
        PUBLIC _ZN6Buzzer2onEv
        PUBLIC _ZN6Buzzer3offEv
        PUBLIC _ZN6Buzzer4tickEv
        PUBLIC _ZN6Buzzer4toneERKtS1_
        PUBLIC _ZN6Buzzer5resetEv
        PUBLIC _ZN6BuzzerC1Ev
        PUBLIC _ZN6SdFileD1Ev
        PUBLIC _ZN7Planner11buffer_lineEfffRKfS1_h
        PUBLIC _ZN7Planner13blocks_queuedEv
        PUBLIC _ZN7Planner14apply_levelingEPf
        PUBLIC _ZN7Planner15set_position_mmEfffRKf
        PUBLIC _ZN7Planner17set_e_position_mmERKf
        PUBLIC _ZN7Planner21buffer_line_kinematicEPKfRS0_h
        PUBLIC _ZN7Planner21discard_current_blockEv
        PUBLIC _ZN7Stepper25get_axis_position_degreesE8AxisEnum
        PUBLIC _ZN8Endstops10not_homingEv
        PUBLIC _ZN8Endstops14enable_z_probeEb
        PUBLIC _ZN8Endstops14hit_on_purposeEv
        PUBLIC _ZN8Endstops15enable_globallyEb
        PUBLIC _ZN8Endstops6enableEb
        PUBLIC _ZNK10SdBaseFile11curPositionEv
        PUBLIC _ZNK10SdBaseFile6isOpenEv
        PUBLIC _ZNK10duration_t3dayEv
        PUBLIC _ZNK10duration_t4hourEv
        PUBLIC _ZNK10duration_t4yearEv
        PUBLIC _ZNK10duration_t6minuteEv
        PUBLIC _ZNK10duration_t6secondEv
        PUBLIC _ZNK10duration_t8toStringEPc
        PUBLIC _ZTI6Buzzer
        PUBLIC _ZTS6Buzzer
        PUBLIC _ZTV6Buzzer
        PUBLIC _ZZ10gcode_M104vEs
        PUBLIC _ZZ10gcode_M104vEs_0
        PUBLIC _ZZ10gcode_M104vEs_1
        PUBLIC _ZZ10gcode_M104vEs_2
        PUBLIC _ZZ10gcode_M104vEs_3
        PUBLIC _ZZ10gcode_M104vEs_4
        PUBLIC _ZZ10gcode_M105vEs
        PUBLIC _ZZ10gcode_M109vEs
        PUBLIC _ZZ10gcode_M109vEs_0
        PUBLIC _ZZ10gcode_M109vEs_1
        PUBLIC _ZZ10gcode_M109vEs_2
        PUBLIC _ZZ10gcode_M109vEs_3
        PUBLIC _ZZ10gcode_M109vEs_4
        PUBLIC _ZZ10gcode_M111vE11str_debug_1
        PUBLIC _ZZ10gcode_M111vE11str_debug_2
        PUBLIC _ZZ10gcode_M111vE11str_debug_4
        PUBLIC _ZZ10gcode_M111vE11str_debug_8
        PUBLIC _ZZ10gcode_M111vE12str_debug_16
        PUBLIC _ZZ10gcode_M111vE13debug_strings
        PUBLIC _ZZ10gcode_M111vEs_4
        PUBLIC _ZZ10gcode_M111vEs_5
        PUBLIC _ZZ10gcode_M112vEs
        PUBLIC _ZZ10gcode_M113vEs
        PUBLIC _ZZ10gcode_M115vEs
        PUBLIC _ZZ10gcode_M145vEs
        PUBLIC _ZZ10gcode_M190vEs
        PUBLIC _ZZ10gcode_M190vEs_0
        PUBLIC _ZZ10gcode_M204vEs
        PUBLIC _ZZ10gcode_M204vEs_0
        PUBLIC _ZZ10gcode_M204vEs_1
        PUBLIC _ZZ10gcode_M204vEs_2
        PUBLIC _ZZ10gcode_M211vEs
        PUBLIC _ZZ10gcode_M211vEs_0
        PUBLIC _ZZ10gcode_M211vEs_1
        PUBLIC _ZZ10gcode_M211vEs_2
        PUBLIC _ZZ10gcode_M211vEs_3
        PUBLIC _ZZ10gcode_M211vEs_4
        PUBLIC _ZZ10gcode_M301vEs
        PUBLIC _ZZ10gcode_M301vEs_0
        PUBLIC _ZZ10gcode_M301vEs_1
        PUBLIC _ZZ10gcode_M301vEs_2
        PUBLIC _ZZ10gcode_M302vEs
        PUBLIC _ZZ10gcode_M302vEs_0
        PUBLIC _ZZ10gcode_M302vEs_1
        PUBLIC _ZZ10gcode_M302vEs_2
        PUBLIC _ZZ10gcode_M302vEs_3
        PUBLIC _ZZ10gcode_M303vEs
        PUBLIC _ZZ10gcode_M304vEs
        PUBLIC _ZZ10gcode_M304vEs_0
        PUBLIC _ZZ10gcode_M304vEs_1
        PUBLIC _ZZ10gcode_M355vEs
        PUBLIC _ZZ10gcode_M360vEs
        PUBLIC _ZZ10gcode_M361vEs
        PUBLIC _ZZ10gcode_M362vEs
        PUBLIC _ZZ10gcode_M363vEs
        PUBLIC _ZZ10gcode_M364vEs
        PUBLIC _ZZ10gcode_M420vEs
        PUBLIC _ZZ10gcode_M420vEs_0
        PUBLIC _ZZ10gcode_M420vEs_1
        PUBLIC _ZZ10gcode_M420vEs_2
        PUBLIC _ZZ10gcode_M420vEs_3
        PUBLIC _ZZ10gcode_M420vEs_4
        PUBLIC _ZZ10gcode_M420vEs_5
        PUBLIC _ZZ10gcode_M421vEs
        PUBLIC _ZZ10gcode_M421vEs_0
        PUBLIC _ZZ10gcode_M428vEs
        PUBLIC _ZZ10gcode_M428vEs_0
        PUBLIC _ZZ10gcode_M600vEs
        PUBLIC _ZZ10gcode_M851vEs
        PUBLIC _ZZ10gcode_M851vEs_0
        PUBLIC _ZZ10gcode_M851vEs_1
        PUBLIC _ZZ11gcode_G2_G3bEs
        PUBLIC _ZZ11gcode_M0_M1vEs
        PUBLIC _ZZ17get_wifi_commandsvE16wifi_line_buffer
        PUBLIC _ZZ17get_wifi_commandsvE17wifi_comment_mode
        PUBLIC _ZZ17get_wifi_commandsvEs
        PUBLIC _ZZ17get_wifi_commandsvEs_0
        PUBLIC _ZZ17get_wifi_commandsvEs_1
        PUBLIC _ZZ17get_wifi_commandsvEs_2
        PUBLIC _ZZ17get_wifi_commandsvEs_3
        PUBLIC _ZZ17get_wifi_commandsvEs_4
        PUBLIC _ZZ19get_sdcard_commandsvE14stop_buffering
        PUBLIC _ZZ19get_sdcard_commandsvE15sd_comment_mode
        PUBLIC _ZZ19get_sdcard_commandsvEs
        PUBLIC _ZZ19get_sdcard_commandsvEs_0
        PUBLIC _ZZ19get_serial_commandsvE14last_wait_time
        PUBLIC _ZZ19get_serial_commandsvE18serial_line_buffer
        PUBLIC _ZZ19get_serial_commandsvE19serial_comment_mode
        PUBLIC _ZZ19get_serial_commandsvEs
        PUBLIC _ZZ19get_serial_commandsvEs_0
        PUBLIC _ZZ19get_serial_commandsvEs_1
        PUBLIC _ZZ19get_serial_commandsvEs_2
        PUBLIC _ZZ19get_serial_commandsvEs_3
        PUBLIC _ZZ19get_serial_commandsvEs_4
        PUBLIC _ZZ19get_serial_commandsvEs_5
        PUBLIC _ZZ19get_serial_commandsvEs_6
        PUBLIC _ZZ19get_serial_commandsvEs_7
        PUBLIC _ZZ19get_serial_commandsvEs_8
        PUBLIC _ZZ19get_serial_commandsvEs_9
        PUBLIC _ZZ24get_homing_bump_feedrate8AxisEnumEs
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvE15mbl_probe_index
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvE20enable_soft_endstops
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_0
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_1
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_2
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_3
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_4
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_5
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_6
        PUBLIC _ZZ28gcode_M421_MESH_BED_LEVELINGvEs
        PUBLIC _ZZ28gcode_M421_MESH_BED_LEVELINGvEs_0
        PUBLIC _ZZ8gcode_G4vEs
        PUBLIC _ZZ9gcode_G29vEs
        PUBLIC _ZZ9gcode_G29vEs_0
        PUBLIC _ZZ9gcode_G29vEs_1
        PUBLIC _ZZ9gcode_G29vEs_2
        PUBLIC _ZZ9gcode_G29vEs_3
        PUBLIC _ZZ9gcode_G29vEs_4
        PUBLIC _ZZ9gcode_G29vEs_5
        PUBLIC _ZZ9gcode_G29vEs_6
        PUBLIC _ZZ9gcode_G29vEs_7
        PUBLIC _ZZ9gcode_G29vEs_8
        PUBLIC _ZZ9gcode_G29vEs_9
        PUBLIC _ZZ9gcode_G29vEs__10_
        PUBLIC _ZZ9gcode_G29vEs__11_
        PUBLIC _ZZ9gcode_G29vEs__12_
        PUBLIC _ZZ9gcode_G29vEs__13_
        PUBLIC _ZZ9gcode_G29vEs__14_
        PUBLIC _ZZ9gcode_G29vEs__15_
        PUBLIC _ZZ9gcode_G29vEs__16_
        PUBLIC _ZZ9gcode_G29vEs__17_
        PUBLIC _ZZ9gcode_G29vEs__18_
        PUBLIC _ZZ9gcode_G30vEs
        PUBLIC _ZZ9gcode_G30vEs_0
        PUBLIC _ZZ9gcode_G30vEs_1
        PUBLIC _ZZ9gcode_M17vEs
        PUBLIC _ZZ9gcode_M20vEs
        PUBLIC _ZZ9gcode_M20vEs_0
        PUBLIC _ZZ9gcode_M23vEs
        PUBLIC _ZZ9gcode_M23vEs_0
        PUBLIC _ZZ9gcode_M31vEs
        PUBLIC _ZZ9gcode_M42vEs
        PUBLIC _ZZ9gcode_M49vEs
        PUBLIC _ZZ9gcode_M49vEs_0
        PUBLIC _ZZ9gcode_M49vEs_1
        PUBLIC _ZZ9gcode_M81vEs
        PUBLIC _ZZ9gcode_M81vEs_0
        PUBLIC _ZZNK10duration_t8toStringEPcEs
        PUBLIC _ZZNK10duration_t8toStringEPcEs_0
        PUBLIC _ZZNK10duration_t8toStringEPcEs_1
        PUBLIC _ZZNK10duration_t8toStringEPcEs_2
        PUBLIC _ZZNK10duration_t8toStringEPcEs_3
        PUBLIC active_extruder
        PUBLIC axis_homed
        PUBLIC axis_known_position
        PUBLIC axis_relative_modes
        PUBLIC base_home_pos_P
        PUBLIC base_max_pos_P
        PUBLIC base_min_pos_P
        PUBLIC bilinear_grid_factor
        PUBLIC bilinear_grid_spacing
        PUBLIC bilinear_start
        PUBLIC busy_state
        PUBLIC buzzer
        PUBLIC card
        PUBLIC cartes
        PUBLIC cmd_id_bak
        PUBLIC cmd_id_bak_temp
        PUBLIC cmd_length
        PUBLIC cmd_queue_index_r_bak
        PUBLIC commands_in_queue
        PUBLIC current_position
        PUBLIC delta
        PUBLIC delta_calibration_radius
        PUBLIC delta_clip_start_height
        PUBLIC delta_diagonal_rod
        PUBLIC delta_diagonal_rod_2_tower
        PUBLIC delta_radius
        PUBLIC delta_segments_per_second
        PUBLIC delta_tower
        PUBLIC delta_tower_angle_trim
        PUBLIC destination
        PUBLIC endstop_adj
        PUBLIC fanSpeeds
        PUBLIC feedrate_percentage
        PUBLIC filament_change_menu_response
        PUBLIC filament_size
        PUBLIC flow_percentage
        PUBLIC from_wifi_flag
        PUBLIC home_bump_mm_P
        PUBLIC home_dir_P
        PUBLIC home_offset
        PUBLIC homing_feedrate_mm_s
        PUBLIC host_keepalive_interval
        PUBLIC kill_c
        PUBLIC loop
        PUBLIC marlin_debug_flags
        PUBLIC max_length_P
        PUBLIC mksReprint
        PUBLIC mks_PrintStatePolling
        PUBLIC mks_ReadFromEpr
        PUBLIC mks_ReadFromFile
        PUBLIC mks_WriteToFile
        PUBLIC mks_clearDir
        PUBLIC mks_clearFile
        PUBLIC mks_contiuePrintDelta
        PUBLIC mks_contiuePrintPause
        PUBLIC mks_contiuePrintPwdwn
        PUBLIC mks_contiuePrint_UI
        PUBLIC mks_heating_busy
        PUBLIC mks_initPrint
        PUBLIC mks_moveXY
        PUBLIC mks_moveZ
        PUBLIC mks_pausePrint
        PUBLIC mks_preExtrude
        PUBLIC mks_rePrintCheck
        PUBLIC mks_resumePrint
        PUBLIC mks_setPositionZ
        PUBLIC position_shift
        PUBLIC previous_cmd_ms
        PUBLIC print_job_timer
        PUBLIC saved_feedrate_percentage
        PUBLIC serial_wait_tick
        PUBLIC setup
        PUBLIC soft_endstop_max
        PUBLIC soft_endstop_min
        PUBLIC soft_endstops_enabled
        PUBLIC target_extruder
        PUBLIC ubl
        PUBLIC volumetric_enabled
        PUBLIC volumetric_multiplier
        PUBLIC wait_for_heatup
        PUBLIC wait_for_user
        PUBLIC workspace_offset
        PUBLIC xy_probe_feedrate_mm_s
        PUBLIC z_values
        PUBLIC zprobe_zoffset
        
          CFI Names cfiNames0
          CFI StackFrame CFA R13 DATA
          CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
          CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, R13:32, R14:32
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 4
          CFI ReturnAddress R14 CODE
          CFI CFA R13+0
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R12 Undefined
          CFI R14 SameValue
          CFI EndCommon cfiCommon0
        
// C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\Marlin_main.cpp
//    1 /**
//    2  * Marlin 3D Printer Firmware
//    3  * Copyright (C) 2016, 2017 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
//    4  *
//    5  * Based on Sprinter and grbl.
//    6  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
//    7  *
//    8  * This program is free software: you can redistribute it and/or modify
//    9  * it under the terms of the GNU General Public License as published by
//   10  * the Free Software Foundation, either version 3 of the License, or
//   11  * (at your option) any later version.
//   12  *
//   13  * This program is distributed in the hope that it will be useful,
//   14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
//   15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   16  * GNU General Public License for more details.
//   17  *
//   18  * You should have received a copy of the GNU General Public License
//   19  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
//   20  *
//   21  */
//   22 
//   23 /**
//   24  * About Marlin
//   25  *
//   26  * This firmware is a mashup between Sprinter and grbl.
//   27  *  - https://github.com/kliment/Sprinter
//   28  *  - https://github.com/simen/grbl/tree
//   29  */
//   30 
//   31 /**
//   32  * -----------------
//   33  * G-Codes in Marlin
//   34  * -----------------
//   35  *
//   36  * Helpful G-code references:
//   37  *  - http://linuxcnc.org/handbook/gcode/g-code.html
//   38  *  - http://objects.reprap.org/wiki/Mendel_User_Manual:_RepRapGCodes
//   39  *
//   40  * Help to document Marlin's G-codes online:
//   41  *  - http://reprap.org/wiki/G-code
//   42  *  - https://github.com/MarlinFirmware/MarlinDocumentation
//   43  *
//   44  * -----------------
//   45  *
//   46  * "G" Codes
//   47  *
//   48  * G0  -> G1
//   49  * G1  - Coordinated Movement X Y Z E
//   50  * G2  - CW ARC
//   51  * G3  - CCW ARC
//   52  * G4  - Dwell S<seconds> or P<milliseconds>
//   53  * G5  - Cubic B-spline with XYZE destination and IJPQ offsets
//   54  * G10 - Retract filament according to settings of M207
//   55  * G11 - Retract recover filament according to settings of M208
//   56  * G12 - Clean tool
//   57  * G20 - Set input units to inches
//   58  * G21 - Set input units to millimeters
//   59  * G28 - Home one or more axes
//   60  * G29 - Detailed Z probe, probes the bed at 3 or more points.  Will fail if you haven't homed yet.
//   61  * G30 - Single Z probe, probes bed at X Y location (defaults to current XY location)
//   62  * G31 - Dock sled (Z_PROBE_SLED only)
//   63  * G32 - Undock sled (Z_PROBE_SLED only)
//   64  * G33 - Delta Auto-Calibration (Requires DELTA_AUTO_CALIBRATION)
//   65  * G38 - Probe target - similar to G28 except it uses the Z_MIN_PROBE for all three axes
//   66  * G90 - Use Absolute Coordinates
//   67  * G91 - Use Relative Coordinates
//   68  * G92 - Set current position to coordinates given
//   69  *
//   70  * "M" Codes
//   71  *
//   72  * M0   - Unconditional stop - Wait for user to press a button on the LCD (Only if ULTRA_LCD is enabled)
//   73  * M1   - Same as M0
//   74  * M17  - Enable/Power all stepper motors
//   75  * M18  - Disable all stepper motors; same as M84
//   76  * M20  - List SD card. (Requires SDSUPPORT)
//   77  * M21  - Init SD card. (Requires SDSUPPORT)
//   78  * M22  - Release SD card. (Requires SDSUPPORT)
//   79  * M23  - Select SD file: "M23 /path/file.gco". (Requires SDSUPPORT)
//   80  * M24  - Start/resume SD print. (Requires SDSUPPORT)
//   81  * M25  - Pause SD print. (Requires SDSUPPORT)
//   82  * M26  - Set SD position in bytes: "M26 S12345". (Requires SDSUPPORT)
//   83  * M27  - Report SD print status. (Requires SDSUPPORT)
//   84  * M28  - Start SD write: "M28 /path/file.gco". (Requires SDSUPPORT)
//   85  * M29  - Stop SD write. (Requires SDSUPPORT)
//   86  * M30  - Delete file from SD: "M30 /path/file.gco"
//   87  * M31  - Report time since last M109 or SD card start to serial.
//   88  * M32  - Select file and start SD print: "M32 [S<bytepos>] !/path/file.gco#". (Requires SDSUPPORT)
//   89  *        Use P to run other files as sub-programs: "M32 P !filename#"
//   90  *        The '#' is necessary when calling from within sd files, as it stops buffer prereading
//   91  * M33  - Get the longname version of a path. (Requires LONG_FILENAME_HOST_SUPPORT)
//   92  * M34  - Set SD Card sorting options. (Requires SDCARD_SORT_ALPHA)
//   93  * M42  - Change pin status via gcode: M42 P<pin> S<value>. LED pin assumed if P is omitted.
//   94  * M43  - Display pin status, watch pins for changes, watch endstops & toggle LED, Z servo probe test, toggle pins
//   95  * M48  - Measure Z Probe repeatability: M48 P<points> X<pos> Y<pos> V<level> E<engage> L<legs>. (Requires Z_MIN_PROBE_REPEATABILITY_TEST)
//   96  * M75  - Start the print job timer.
//   97  * M76  - Pause the print job timer.
//   98  * M77  - Stop the print job timer.
//   99  * M78  - Show statistical information about the print jobs. (Requires PRINTCOUNTER)
//  100  * M80  - Turn on Power Supply. (Requires POWER_SUPPLY)
//  101  * M81  - Turn off Power Supply. (Requires POWER_SUPPLY)
//  102  * M82  - Set E codes absolute (default).
//  103  * M83  - Set E codes relative while in Absolute (G90) mode.
//  104  * M84  - Disable steppers until next move, or use S<seconds> to specify an idle
//  105  *        duration after which steppers should turn off. S0 disables the timeout.
//  106  * M85  - Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
//  107  * M92  - Set planner.axis_steps_per_mm for one or more axes.
//  108  * M104 - Set extruder target temp.
//  109  * M105 - Report current temperatures.
//  110  * M106 - Fan on.
//  111  * M107 - Fan off.
//  112  * M108 - Break out of heating loops (M109, M190, M303). With no controller, breaks out of M0/M1. (Requires EMERGENCY_PARSER)
//  113  * M109 - Sxxx Wait for extruder current temp to reach target temp. Waits only when heating
//  114  *        Rxxx Wait for extruder current temp to reach target temp. Waits when heating and cooling
//  115  *        If AUTOTEMP is enabled, S<mintemp> B<maxtemp> F<factor>. Exit autotemp by any M109 without F
//  116  * M110 - Set the current line number. (Used by host printing)
//  117  * M111 - Set debug flags: "M111 S<flagbits>". See flag bits defined in enum.h.
//  118  * M112 - Emergency stop.
//  119  * M113 - Get or set the timeout interval for Host Keepalive "busy" messages. (Requires HOST_KEEPALIVE_FEATURE)
//  120  * M114 - Report current position.
//  121  * M115 - Report capabilities. (Extended capabilities requires EXTENDED_CAPABILITIES_REPORT)
//  122  * M117 - Display a message on the controller screen. (Requires an LCD)
//  123  * M119 - Report endstops status.
//  124  * M120 - Enable endstops detection.
//  125  * M121 - Disable endstops detection.
//  126  * M125 - Save current position and move to filament change position. (Requires PARK_HEAD_ON_PAUSE)
//  127  * M126 - Solenoid Air Valve Open. (Requires BARICUDA)
//  128  * M127 - Solenoid Air Valve Closed. (Requires BARICUDA)
//  129  * M128 - EtoP Open. (Requires BARICUDA)
//  130  * M129 - EtoP Closed. (Requires BARICUDA)
//  131  * M140 - Set bed target temp. S<temp>
//  132  * M145 - Set heatup values for materials on the LCD. H<hotend> B<bed> F<fan speed> for S<material> (0=PLA, 1=ABS)
//  133  * M149 - Set temperature units. (Requires TEMPERATURE_UNITS_SUPPORT)
//  134  * M150 - Set Status LED Color as R<red> U<green> B<blue>. Values 0-255. (Requires BLINKM or RGB_LED)
//  135  * M155 - Auto-report temperatures with interval of S<seconds>. (Requires AUTO_REPORT_TEMPERATURES)
//  136  * M163 - Set a single proportion for a mixing extruder. (Requires MIXING_EXTRUDER)
//  137  * M164 - Save the mix as a virtual extruder. (Requires MIXING_EXTRUDER and MIXING_VIRTUAL_TOOLS)
//  138  * M165 - Set the proportions for a mixing extruder. Use parameters ABCDHI to set the mixing factors. (Requires MIXING_EXTRUDER)
//  139  * M190 - Sxxx Wait for bed current temp to reach target temp. ** Waits only when heating! **
//  140  *        Rxxx Wait for bed current temp to reach target temp. ** Waits for heating or cooling. **
//  141  * M200 - Set filament diameter, D<diameter>, setting E axis units to cubic. (Use S0 to revert to linear units.)
//  142  * M201 - Set max acceleration in units/s^2 for print moves: "M201 X<accel> Y<accel> Z<accel> E<accel>"
//  143  * M202 - Set max acceleration in units/s^2 for travel moves: "M202 X<accel> Y<accel> Z<accel> E<accel>" ** UNUSED IN MARLIN! **
//  144  * M203 - Set maximum feedrate: "M203 X<fr> Y<fr> Z<fr> E<fr>" in units/sec.
//  145  * M204 - Set default acceleration in units/sec^2: P<printing> R<extruder_only> T<travel>
//  146  * M205 - Set advanced settings. Current units apply:
//  147             S<print> T<travel> minimum speeds
//  148             B<minimum segment time>
//  149             X<max X jerk>, Y<max Y jerk>, Z<max Z jerk>, E<max E jerk>
//  150  * M206 - Set additional homing offset. (Disabled by NO_WORKSPACE_OFFSETS or DELTA)
//  151  * M207 - Set Retract Length: S<length>, Feedrate: F<units/min>, and Z lift: Z<distance>. (Requires FWRETRACT)
//  152  * M208 - Set Recover (unretract) Additional (!) Length: S<length> and Feedrate: F<units/min>. (Requires FWRETRACT)
//  153  * M209 - Turn Automatic Retract Detection on/off: S<0|1> (For slicers that don't support G10/11). (Requires FWRETRACT)
//  154           Every normal extrude-only move will be classified as retract depending on the direction.
//  155  * M211 - Enable, Disable, and/or Report software endstops: S<0|1> (Requires MIN_SOFTWARE_ENDSTOPS or MAX_SOFTWARE_ENDSTOPS)
//  156  * M218 - Set a tool offset: "M218 T<index> X<offset> Y<offset>". (Requires 2 or more extruders)
//  157  * M220 - Set Feedrate Percentage: "M220 S<percent>" (i.e., "FR" on the LCD)
//  158  * M221 - Set Flow Percentage: "M221 S<percent>"
//  159  * M226 - Wait until a pin is in a given state: "M226 P<pin> S<state>"
//  160  * M240 - Trigger a camera to take a photograph. (Requires CHDK or PHOTOGRAPH_PIN)
//  161  * M250 - Set LCD contrast: "M250 C<contrast>" (0-63). (Requires LCD support)
//  162  * M260 - i2c Send Data (Requires EXPERIMENTAL_I2CBUS)
//  163  * M261 - i2c Request Data (Requires EXPERIMENTAL_I2CBUS)
//  164  * M280 - Set servo position absolute: "M280 P<index> S<angle|Âµs>". (Requires servos)
//  165  * M300 - Play beep sound S<frequency Hz> P<duration ms>
//  166  * M301 - Set PID parameters P I and D. (Requires PIDTEMP)
//  167  * M302 - Allow cold extrudes, or set the minimum extrude S<temperature>. (Requires PREVENT_COLD_EXTRUSION)
//  168  * M303 - PID relay autotune S<temperature> sets the target temperature. Default 150C. (Requires PIDTEMP)
//  169  * M304 - Set bed PID parameters P I and D. (Requires PIDTEMPBED)
//  170  * M355 - Turn the Case Light on/off and set its brightness. (Requires CASE_LIGHT_PIN)
//  171  * M380 - Activate solenoid on active extruder. (Requires EXT_SOLENOID)
//  172  * M381 - Disable all solenoids. (Requires EXT_SOLENOID)
//  173  * M400 - Finish all moves.
//  174  * M401 - Lower Z probe. (Requires a probe)
//  175  * M402 - Raise Z probe. (Requires a probe)
//  176  * M404 - Display or set the Nominal Filament Width: "W<diameter>". (Requires FILAMENT_WIDTH_SENSOR)
//  177  * M405 - Enable Filament Sensor flow control. "M405 D<delay_cm>". (Requires FILAMENT_WIDTH_SENSOR)
//  178  * M406 - Disable Filament Sensor flow control. (Requires FILAMENT_WIDTH_SENSOR)
//  179  * M407 - Display measured filament diameter in millimeters. (Requires FILAMENT_WIDTH_SENSOR)
//  180  * M410 - Quickstop. Abort all planned moves.
//  181  * M420 - Enable/Disable Leveling (with current values) S1=enable S0=disable (Requires MESH_BED_LEVELING or ABL)
//  182  * M421 - Set a single Z coordinate in the Mesh Leveling grid. X<units> Y<units> Z<units> (Requires MESH_BED_LEVELING or AUTO_BED_LEVELING_UBL)
//  183  * M428 - Set the home_offset based on the current_position. Nearest edge applies. (Disabled by NO_WORKSPACE_OFFSETS or DELTA)
//  184  * M500 - Store parameters in EEPROM. (Requires EEPROM_SETTINGS)
//  185  * M501 - Restore parameters from EEPROM. (Requires EEPROM_SETTINGS)
//  186  * M502 - Revert to the default "factory settings". ** Does not write them to EEPROM! **
//  187  * M503 - Print the current settings (in memory): "M503 S<verbose>". S0 specifies compact output.
//  188  * M540 - Enable/disable SD card abort on endstop hit: "M540 S<state>". (Requires ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
//  189  * M600 - Pause for filament change: "M600 X<pos> Y<pos> Z<raise> E<first_retract> L<later_retract>". (Requires FILAMENT_CHANGE_FEATURE)
//  190  * M665 - Set delta configurations: "M665 L<diagonal rod> R<delta radius> S<segments/s> A<rod A trim mm> B<rod B trim mm> C<rod C trim mm> I<tower A trim angle> J<tower B trim angle> K<tower C trim angle>" (Requires DELTA)
//  191  * M666 - Set delta endstop adjustment. (Requires DELTA)
//  192  * M605 - Set dual x-carriage movement mode: "M605 S<mode> [X<x_offset>] [R<temp_offset>]". (Requires DUAL_X_CARRIAGE)
//  193  * M851 - Set Z probe's Z offset in current units. (Negative = below the nozzle.)
//  194  * M906 - Set or get motor current in milliamps using axis codes X, Y, Z, E. Report values if no axis codes given. (Requires HAVE_TMC2130)
//  195  * M907 - Set digital trimpot motor current using axis codes. (Requires a board with digital trimpots)
//  196  * M908 - Control digital trimpot directly. (Requires DAC_STEPPER_CURRENT or DIGIPOTSS_PIN)
//  197  * M909 - Print digipot/DAC current value. (Requires DAC_STEPPER_CURRENT)
//  198  * M910 - Commit digipot/DAC value to external EEPROM via I2C. (Requires DAC_STEPPER_CURRENT)
//  199  * M911 - Report stepper driver overtemperature pre-warn condition. (Requires HAVE_TMC2130)
//  200  * M912 - Clear stepper driver overtemperature pre-warn condition flag. (Requires HAVE_TMC2130)
//  201  * M913 - Set HYBRID_THRESHOLD speed. (Requires HYBRID_THRESHOLD)
//  202  * M914 - Set SENSORLESS_HOMING sensitivity. (Requires SENSORLESS_HOMING)
//  203  * M350 - Set microstepping mode. (Requires digital microstepping pins.)
//  204  * M351 - Toggle MS1 MS2 pins directly. (Requires digital microstepping pins.)
//  205  *
//  206  * M360 - SCARA calibration: Move to cal-position ThetaA (0 deg calibration)
//  207  * M361 - SCARA calibration: Move to cal-position ThetaB (90 deg calibration - steps per degree)
//  208  * M362 - SCARA calibration: Move to cal-position PsiA (0 deg calibration)
//  209  * M363 - SCARA calibration: Move to cal-position PsiB (90 deg calibration - steps per degree)
//  210  * M364 - SCARA calibration: Move to cal-position PSIC (90 deg to Theta calibration position)
//  211  *
//  212  * ************ Custom codes - This can change to suit future G-code regulations
//  213  * M100 - Watch Free Memory (For Debugging). (Requires M100_FREE_MEMORY_WATCHER)
//  214  * M928 - Start SD logging: "M928 filename.gco". Stop with M29. (Requires SDSUPPORT)
//  215  * M999 - Restart after being stopped by error
//  216  *
//  217  * "T" Codes
//  218  *
//  219  * T0-T3 - Select an extruder (tool) by index: "T<n> F<units/min>"
//  220  *
//  221  */
//  222 
//  223 #include "Marlin.h"
//  224 #include "ultralcd.h"
//  225 #include "planner.h"
//  226 #include "stepper.h"
//  227 #include "endstops.h"
//  228 #include "temperature.h"
//  229 #include "cardreader.h"
//  230 #include "configuration_store.h"
//  231 #include "language.h"
//  232 //#include "pins_arduino.h"
//  233 #include "math.h"
//  234 #include "nozzle.h"
//  235 #include "duration_t.h"
//  236 //#include "types.h"
//  237 #include "tim.h"
//  238 //#include <stdlib.h>
//  239 #include "mks_reprint.h"
//  240 #ifdef USE_MKS_WIFI
//  241 #include "wifi_module.h"
//  242 #endif
//  243 #include "nano.h"
//  244 
//  245 volatile uint8_t mks_heating_busy = 0;
//  246 
//  247 
//  248 /*--mks cfg--begin MESH_BED_LEVELING */
//  249 /*
//  250 #if HAS_ABL
//  251   #include "vector_3.h"
//  252   #if ENABLED(AUTO_BED_LEVELING_LINEAR)
//  253     #include "qr_solve.h"
//  254   #endif
//  255 #elif ENABLED(MESH_BED_LEVELING)
//  256   #include "mesh_bed_leveling.h"
//  257 #endif
//  258 */
//  259 	#include "vector_3.h"
//  260 	#include "qr_solve.h"
//  261 	#include "mesh_bed_leveling.h"
//  262 
//  263 /*--mks cfg--end MESH_BED_LEVELING */
//  264 
//  265 #if ENABLED(BEZIER_CURVE_SUPPORT)
//  266   #include "planner_bezier.h"
//  267 #endif
//  268 
//  269 #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
//  270   #include "buzzer.h"
//  271 #endif
//  272 
//  273 #if ENABLED(USE_WATCHDOG)
//  274   #include "watchdog.h"
//  275 #endif
//  276 
//  277 #if ENABLED(BLINKM)
//  278   #include "blinkm.h"
//  279   #include "Wire.h"
//  280 #endif
//  281 
//  282 #if HAS_SERVOS
//  283   #include "servo.h"
//  284 #endif
//  285 
//  286 #if HAS_DIGIPOTSS
//  287   #include <SPI.h>
//  288 #endif
//  289 
//  290 #if ENABLED(DAC_STEPPER_CURRENT)
//  291   #include "stepper_dac.h"
//  292 #endif
//  293 
//  294 #if ENABLED(EXPERIMENTAL_I2CBUS)
//  295   #include "twibus.h"
//  296 #endif
//  297 
//  298 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
//  299   #include "endstop_interrupts.h"
//  300 #endif
//  301 
//  302 #if ENABLED(M100_FREE_MEMORY_WATCHER)
//  303   void gcode_M100();
//  304   void M100_dump_routine(const char * const title, const char *start, const char *end);
//  305 #endif
//  306 
//  307 #if ENABLED(SDSUPPORT)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function __sti__routine
        THUMB
// static __intrinsic __interwork __softfp void __sti__routine()
__sti__routine:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
//  308   CardReader card;
        LDR.W    R0,??DataTable112
          CFI FunCall _ZN10CardReaderC1Ev
        BL       _ZN10CardReaderC1Ev
        LDR.W    R5,??DataTable112_1
        MOV      R2,R5
        LDR.W    R1,??DataTable112_2
          CFI FunCall __aeabi_atexit
        BL       __aeabi_atexit
//  309 
//  310 #endif
//  311 
//  312 #if ENABLED(EXPERIMENTAL_I2CBUS)
//  313   TWIBus i2c;
//  314 #endif
//  315 
//  316 #if ENABLED(G38_PROBE_TARGET)
//  317   bool G38_move = false,
//  318        G38_endstop_hit = false;
//  319 #endif
//  320 
//  321 //#if ENABLED(AUTO_BED_LEVELING_UBL)
//  322 #if 1
//  323   #include "ubl.h"
//  324   unified_bed_leveling ubl;
        LDR.W    R4,??DataTable112_3
        ADD      R0,R4,#+132
          CFI FunCall _ZN20unified_bed_levelingC1Ev
        BL       _ZN20unified_bed_levelingC1Ev
//  325   #define UBL_MESH_VALID !( ( ubl.z_values[0][0] == ubl.z_values[0][1] && ubl.z_values[0][1] == ubl.z_values[0][2] \ 
//  326                            && ubl.z_values[1][0] == ubl.z_values[1][1] && ubl.z_values[1][1] == ubl.z_values[1][2] \ 
//  327                            && ubl.z_values[2][0] == ubl.z_values[2][1] && ubl.z_values[2][1] == ubl.z_values[2][2] \ 
//  328                            && ubl.z_values[0][0] == 0 && ubl.z_values[1][0] == 0 && ubl.z_values[2][0] == 0 )  \ 
//  329                            || isnan(ubl.z_values[0][0]))
//  330 #endif
//  331 
//  332 
//  333 bool Running = true;
//  334 
//  335 uint8_t marlin_debug_flags = DEBUG_NONE;
//  336 
//  337 /**
//  338  * Cartesian Current Position
//  339  *   Used to track the logical position as moves are queued.
//  340  *   Used by 'line_to_current_position' to do a move after changing it.
//  341  *   Used by 'SYNC_PLAN_POSITION_KINEMATIC' to update 'planner.position'.
//  342  */
//  343 float current_position[XYZE] = { 0.0 };
//  344 
//  345 /**
//  346  * Cartesian Destination
//  347  *   A temporary position, usually applied to 'current_position'.
//  348  *   Set with 'gcode_get_destination' or 'set_destination_to_current'.
//  349  *   'line_to_destination' sets 'current_position' to 'destination'.
//  350  */
//  351 float destination[XYZE] = { 0.0 };
//  352 
//  353 /**
//  354  * axis_homed
//  355  *   Flags that each linear axis was homed.
//  356  *   XYZ on cartesian, ABC on delta, ABZ on SCARA.
//  357  *
//  358  * axis_known_position
//  359  *   Flags that the position is known in each linear axis. Set when homed.
//  360  *   Cleared whenever a stepper powers off, potentially losing its position.
//  361  */
//  362 bool axis_homed[XYZ] = { false }, axis_known_position[XYZ] = { false };
//  363 
//  364 /**
//  365  * GCode line number handling. Hosts may opt to include line numbers when
//  366  * sending commands to Marlin, and lines will be checked for sequentiality.
//  367  * M110 N<int> sets the current line number.
//  368  */
//  369 static long gcode_N, gcode_LastN, Stopped_gcode_LastN = 0;
//  370 
//  371 /**
//  372  * GCode Command Queue
//  373  * A simple ring buffer of BUFSIZE command strings.
//  374  *
//  375  * Commands are copied into this buffer by the command injectors
//  376  * (immediate, serial, sd card) and they are processed sequentially by
//  377  * the main loop. The process_next_command function parses the next
//  378  * command and hands off execution to individual handler functions.
//  379  */
//  380 uint8_t commands_in_queue = 0; // Count of commands in the queue
//  381 static uint8_t cmd_queue_index_r = 0, // Ring buffer read position
//  382                cmd_queue_index_w = 0; // Ring buffer write position
//  383 uint8_t cmd_queue_index_r_bak = 0;               
//  384 #if ENABLED(M100_FREE_MEMORY_WATCHER)
//  385   char command_queue[BUFSIZE][MAX_CMD_SIZE];  // Necessary so M100 Free Memory Dumper can show us the commands and any corruption
//  386 #else                                         // This can be collapsed back to the way it was soon.
//  387 static char command_queue[BUFSIZE][MAX_CMD_SIZE];
//  388 static char command_queue_bak[8][MAX_CMD_SIZE];
//  389 static char command_queue_bak_end[MAX_CMD_SIZE];
//  390 
//  391 
//  392 #endif
//  393 
//  394 /**
//  395  * Current GCode Command
//  396  * When a GCode handler is running, these will be set
//  397  */
//  398 static char *current_command,      // The command currently being executed
//  399             *current_command_args, // The address where arguments begin
//  400             *seen_pointer;         // Set by code_seen(), used by the code_value functions
//  401 
//  402 /**
//  403  * Next Injected Command pointer. NULL if no commands are being injected.
//  404  * Used by Marlin internally to ensure that commands initiated from within
//  405  * are enqueued ahead of any pending serial or sd card commands.
//  406  */
//  407 static const char *injected_commands_P = NULL;
//  408 
//  409 #if ENABLED(INCH_MODE_SUPPORT)
//  410   float linear_unit_factor = 1.0, volumetric_unit_factor = 1.0;
//  411 #endif
//  412 
//  413 #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
//  414   TempUnit input_temp_units = TEMPUNIT_C;
//  415 #endif
//  416 
//  417 /**
//  418  * Feed rates are often configured with mm/m
//  419  * but the planner and stepper like mm/s units.
//  420  */
//  421 	/*--mks cfg--*/
//  422 /*
//  423 float constexpr homing_feedrate_mm_s[] = {	
//  424 
//  425   #if ENABLED(DELTA)
//  426     MMM_TO_MMS(HOMING_FEEDRATE_Z), MMM_TO_MMS(HOMING_FEEDRATE_Z),
//  427   #else
//  428     MMM_TO_MMS(HOMING_FEEDRATE_XY), MMM_TO_MMS(HOMING_FEEDRATE_XY),
//  429   #endif
//  430   MMM_TO_MMS(HOMING_FEEDRATE_Z), 0
//  431 };*/
//  432 float  homing_feedrate_mm_s[4];
//  433 
//  434 
//  435 static float feedrate_mm_s = MMM_TO_MMS(1500.0), saved_feedrate_mm_s;
//  436 int feedrate_percentage = 100, saved_feedrate_percentage,
//  437     flow_percentage[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100);
//  438 
//  439 bool axis_relative_modes[] = AXIS_RELATIVE_MODES,
//  440      volumetric_enabled =
//  441         #if ENABLED(VOLUMETRIC_DEFAULT_ON)
//  442           true
//  443         #else
//  444           false
//  445         #endif
//  446       ;
//  447 float filament_size[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(DEFAULT_NOMINAL_FILAMENT_DIA),
//  448       volumetric_multiplier[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(1.0);
//  449 
//  450 #if HAS_WORKSPACE_OFFSET
//  451   #if HAS_POSITION_SHIFT
//  452     // The distance that XYZ has been offset by G92. Reset by G28.
//  453     float position_shift[XYZ] = { 0 };
//  454   #endif
//  455   #if HAS_HOME_OFFSET
//  456     // This offset is added to the configured home position.
//  457     // Set by M206, M428, or menu item. Saved to EEPROM.
//  458     float home_offset[XYZ] = { 0 };
//  459   #endif
//  460   #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
//  461     // The above two are combined to save on computes
//  462     float workspace_offset[XYZ] = { 0 };
//  463   #endif
//  464 #endif
//  465 
//  466 // Software Endstops are based on the configured limits.
//  467 #if HAS_SOFTWARE_ENDSTOPS
//  468   bool soft_endstops_enabled = true;
//  469 #endif
//  470 float soft_endstop_min[XYZ] = { X_MIN_POS, Y_MIN_POS, Z_MIN_POS },
        LDR.W    R6,??DataTable113_4
        LDR      R0,[R6, #+8]
        STR      R0,[R4, #+80]
        LDR      R0,[R6, #+12]
        STR      R0,[R4, #+84]
        LDR      R0,[R6, #+16]
        STR      R0,[R4, #+88]
//  471       soft_endstop_max[XYZ] = { X_MAX_POS, Y_MAX_POS, Z_MAX_POS };
        LDR      R0,[R6, #+20]
        STR      R0,[R4, #+92]
        LDR      R0,[R6, #+24]
        STR      R0,[R4, #+96]
        LDR      R0,[R6, #+28]
        STR      R0,[R4, #+100]
//  472 
//  473 #if FAN_COUNT > 0
//  474   //int16_t fanSpeeds[FAN_COUNT] = { 0 };  /*--mks--*/     
//  475   int fanSpeeds[FAN_COUNT] = { 0 };
//  476 #if ENABLED(PROBING_FANS_OFF)
//  477   bool fans_paused = false;
//  478   int16_t paused_fanSpeeds[FAN_COUNT] = { 0 };
//  479 #endif
//  480 
//  481 #endif
//  482 
//  483 // The active extruder (tool). Set with T<extruder> command.
//  484 uint8_t active_extruder = 0;
//  485 
//  486 // Relative Mode. Enable with G91, disable with G90.
//  487 static bool relative_mode = false;
//  488 
//  489 // For M109 and M190, this flag may be cleared (by M108) to exit the wait loop
//  490 volatile bool wait_for_heatup = true;
//  491 
//  492 // For M0/M1, this flag may be cleared (by M108) to exit the wait-for-user loop
//  493 #if HAS_RESUME_CONTINUE
//  494   volatile bool wait_for_user = false;
//  495 #endif
//  496 
//  497 const char axis_codes[XYZE] = {'X', 'Y', 'Z', 'E'};
//  498 
//  499 // Number of characters read in the current line of serial input
//  500 static int serial_count = 0;
//  501 static int wifi_read_count = 0;
//  502 
//  503 // Inactivity shutdown
//  504 millis_t previous_cmd_ms = 0;
//  505 static millis_t max_inactive_time = 0;
//  506 static millis_t stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL;
//  507 
//  508 // Print Job Timer
//  509 #if ENABLED(PRINTCOUNTER)
//  510   PrintCounter print_job_timer = PrintCounter();
//  511 #else
//  512   Stopwatch print_job_timer = Stopwatch();
        ADD      R0,R4,#+904
          CFI FunCall _ZN9StopwatchC1Ev
        BL       _ZN9StopwatchC1Ev
//  513 #endif
//  514 
//  515 // Buzzer - I2C on the LCD or a BEEPER_PIN
//  516 #if ENABLED(LCD_USE_I2C_BUZZER)
//  517   #define BUZZ(d,f) lcd_buzz(d, f)
//  518 #elif PIN_EXISTS(BEEPER)
//  519   Buzzer buzzer;
        ADD      R0,R4,#+920
          CFI FunCall _ZN6BuzzerC1Ev
        BL       _ZN6BuzzerC1Ev
//  520   #define BUZZ(d,f) buzzer.tone(d, f)
//  521 #else
//  522   #define BUZZ(d,f) NOOP
//  523 #endif
//  524 
//  525 uint8_t target_extruder;
//  526 
//  527 #if HAS_BED_PROBE
//  528   float zprobe_zoffset = Z_PROBE_OFFSET_FROM_EXTRUDER;
//  529 #endif
//  530 
//  531 //#if HAS_ABL
//  532 #if 1
//  533   float xy_probe_feedrate_mm_s = MMM_TO_MMS(XY_PROBE_SPEED);
        LDR      R0,[R6, #+116]
        LDR.W    R1,??DataTable113_5  ;; 0x42700000
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[R4, #+124]
        LDR      R7,[R6, #+28]
        STR      R7,[R4, #+128]
        LDR.W    R9,??DataTable113_6  ;; 0x43160000
        MOV      R10,R9
        MOVS     R4,#+2
        MOV      R8,#+1065353216
        MOV      R11,R8
        B.N      ??__sti__routine_0
??__sti__routine_1:
        MOV      R0,R10
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??__sti__routine_0:
        LSLS     R0,R4,#+31
        BPL.N    ??__sti__routine_2
        MOV      R0,R11
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??__sti__routine_2:
        LSRS     R4,R4,#+1
        BNE.N    ??__sti__routine_1
        LDR.W    R10,??DataTable113_7
        STR      R11,[R10, #+52]
        MOV      R1,R11
        MOV      R0,#+1073741824
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[R10, #+56]
        MOVS     R4,#+2
        B.N      ??__sti__routine_3
??__sti__routine_4:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??__sti__routine_3:
        LSLS     R0,R4,#+31
        BPL.N    ??__sti__routine_5
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??__sti__routine_5:
        LSRS     R4,R4,#+1
        BNE.N    ??__sti__routine_4
        STR      R8,[R10, #+60]
        LDR      R1,[R6, #+8]
        STR      R1,[R10, #+4]
        LDR      R4,[R6, #+12]
        STR      R4,[R10, #+8]
        LDR      R8,[R6, #+16]
        STR      R8,[R10, #+12]
        LDR      R0,[R6, #+20]
        STR      R0,[R10, #+16]
        LDR      R9,[R6, #+24]
        STR      R9,[R10, #+20]
        STR      R7,[R10, #+24]
        LDR      R2,[R6, #+80]
        STR      R2,[R10, #+36]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R10, #+40]
        MOV      R0,R9
        MOV      R1,R4
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R10, #+44]
        MOV      R0,R7
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R10, #+48]
        LDRB     R0,[R6, #+4]
        STRB     R0,[R10, #+0]
        LDRB     R0,[R6, #+5]
        STRB     R0,[R10, #+1]
        LDRB     R0,[R6, #+6]
        STRB     R0,[R10, #+2]
        LDR.W    R0,??DataTable113_8
          CFI FunCall _ZN18DATA_REPRINT_ITMESC1Ev
        BL       _ZN18DATA_REPRINT_ITMESC1Ev
        MOV      R2,R5
        LDR.W    R1,??DataTable115
        POP      {R3-R11,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall __aeabi_atexit
        B.W      __aeabi_atexit
          CFI EndBlock cfiBlock0

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        DATA
card:
        DS8 800

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        DATA
command_queue:
        DS8 384

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        DATA
injected_commands_P:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        DATA
saved_feedrate_mm_s:
        DS8 4
saved_feedrate_percentage:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        DATA
fanSpeeds:
        DS8 4
//  534   #define XY_PROBE_FEEDRATE_MM_S xy_probe_feedrate_mm_s
//  535 #elif defined(XY_PROBE_SPEED)
//  536   #define XY_PROBE_FEEDRATE_MM_S MMM_TO_MMS(XY_PROBE_SPEED)
//  537 #else
//  538   #define XY_PROBE_FEEDRATE_MM_S PLANNER_XY_FEEDRATE()
//  539 #endif
//  540 
//  541 /*--mks cfg--begin AUTO_BED_LEVELING_BILINEAR */
//  542 
//  543 //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
//  544 #if 1
//  545 	//mks_delta
//  546 /*
//  547   #if ENABLED(DELTA)
//  548     #define ADJUST_DELTA(V) \ 
//  549       if (planner.abl_enabled) { \ 
//  550         const float zadj = bilinear_z_offset(V); \ 
//  551         delta[A_AXIS] += zadj; \ 
//  552         delta[B_AXIS] += zadj; \ 
//  553         delta[C_AXIS] += zadj; \ 
//  554       }
//  555   #else
//  556     #define ADJUST_DELTA(V) if (planner.abl_enabled) { delta[Z_AXIS] += bilinear_z_offset(V); }
//  557   #endif
//  558 */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function _Z12ADJUST_DELTAPKf
        THUMB
//  559 void  ADJUST_DELTA(const float logical[XYZ])
//  560 {
_Z12ADJUST_DELTAPKf:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
//  561 	float zadj;
//  562 
//  563 	if(MACHINETPYE == DELTA)
        LDR.W    R1,??DataTable113_9
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable113_4
        LDRSH    R2,[R2, #+88]
        CMP      R2,#+2
        BNE.N    ??ADJUST_DELTA_0
//  564 		{
//  565       	if (planner.abl_enabled) { 
        CMP      R1,#+0
        BEQ.N    ??ADJUST_DELTA_1
//  566        	 	zadj = bilinear_z_offset(logical); 
          CFI FunCall _Z17bilinear_z_offsetPKf
        BL       _Z17bilinear_z_offsetPKf
        MOV      R5,R0
//  567         	delta[A_AXIS] += zadj; 
        LDR.W    R4,??DataTable112_3
        LDR      R0,[R4, #+104]
        MOV      R1,R5
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+104]
//  568        		delta[B_AXIS] += zadj; 
        LDR      R0,[R4, #+108]
        MOV      R1,R5
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+108]
//  569         	delta[C_AXIS] += zadj; 
        LDR      R0,[R4, #+112]
        MOV      R1,R5
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+112]
        POP      {R0,R4,R5,PC}
//  570       		}
//  571 		}
//  572 		else
//  573 			{
//  574 			if (planner.abl_enabled) 
??ADJUST_DELTA_0:
        CMP      R1,#+0
        BEQ.N    ??ADJUST_DELTA_1
//  575 				 delta[Z_AXIS] += bilinear_z_offset(logical); 
          CFI FunCall _Z17bilinear_z_offsetPKf
        BL       _Z17bilinear_z_offsetPKf
        LDR.W    R4,??DataTable112_3
        LDR      R1,[R4, #+112]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+112]
//  576 			}
//  577 }
??ADJUST_DELTA_1:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock1
//  578 
//  579 //#elif IS_KINEMATIC	//mks_delta
//  580   //#define ADJUST_DELTA(V) NOOP
//  581 #endif
//  582 /*--mks cfg--end AUTO_BED_LEVELING_BILINEAR */
//  583 
//  584 #if ENABLED(Z_DUAL_ENDSTOPS)
//  585   float z_endstop_adj =
//  586     #ifdef Z_DUAL_ENDSTOPS_ADJUSTMENT
//  587       Z_DUAL_ENDSTOPS_ADJUSTMENT
//  588     #else
//  589       0
//  590     #endif
//  591   ;
//  592 #endif
//  593 
//  594 // Extruder offsets
//  595 #if HOTENDS > 1
//  596   float hotend_offset[XYZ][HOTENDS];
//  597 #endif
//  598 
//  599 #if HAS_Z_SERVO_ENDSTOP
//  600   const int z_servo_angle[2] = Z_SERVO_ANGLES;
//  601 #endif
//  602 
//  603 #if ENABLED(BARICUDA)
//  604   int baricuda_valve_pressure = 0;
//  605   int baricuda_e_to_p_pressure = 0;
//  606 #endif
//  607 
//  608 #if ENABLED(FWRETRACT)
//  609 
//  610   bool autoretract_enabled = false;
//  611   bool retracted[EXTRUDERS] = { false };
//  612   bool retracted_swap[EXTRUDERS] = { false };
//  613 
//  614   float retract_length = RETRACT_LENGTH;
//  615   float retract_length_swap = RETRACT_LENGTH_SWAP;
//  616   float retract_feedrate_mm_s = RETRACT_FEEDRATE;
//  617   float retract_zlift = RETRACT_ZLIFT;
//  618   float retract_recover_length = RETRACT_RECOVER_LENGTH;
//  619   float retract_recover_length_swap = RETRACT_RECOVER_LENGTH_SWAP;
//  620   float retract_recover_feedrate_mm_s = RETRACT_RECOVER_FEEDRATE;
//  621 
//  622 #endif // FWRETRACT
//  623 
//  624 #if ENABLED(ULTIPANEL) && HAS_POWER_SWITCH
//  625   bool powersupply =
//  626     #if ENABLED(PS_DEFAULT_OFF)
//  627       false
//  628     #else
//  629       true
//  630     #endif
//  631   ;
//  632 #endif
//  633 
//  634 #if HAS_CASE_LIGHT
//  635   bool case_light_on =
//  636     #if ENABLED(CASE_LIGHT_DEFAULT_ON)
//  637       true
//  638     #else
//  639       false
//  640     #endif
//  641   ;
//  642 #endif
//  643 
//  644 //#if ENABLED(DELTA)	//mks_delta
//  645 #if 1
//  646   float delta[ABC],

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        DATA
//  647         endstop_adj[ABC] = { 0 };
endstop_adj:
        DS8 12
//  648 
//  649   // These values are loaded or reset at boot time when setup() calls
//  650   // settings.load(), which calls recalc_delta_settings().
//  651   float delta_radius,
//  652         delta_tower_angle_trim[2],
//  653         delta_tower[ABC][2],
//  654         delta_diagonal_rod,
//  655         delta_calibration_radius,
//  656         delta_diagonal_rod_2_tower[ABC],
//  657         delta_segments_per_second,
//  658         delta_clip_start_height = Z_MAX_POS;
//  659 
//  660   float delta_safe_distance_from_top();
//  661 
//  662 #endif
//  663 
//  664 //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
//  665 #if 1 /*--mks cfg-- AUTO_BED_LEVELING_BILINEAR */
//  666   int bilinear_grid_spacing[2], bilinear_start[2];		/*---mks---*/ //int to int16_t
//  667   float bilinear_grid_factor[2],
//  668         //z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        DATA
//  669         z_values[GRID_MAX_POINTS_X_MAX][GRID_MAX_POINTS_Y_MAX];
z_values:
        DS8 1024
//  670 #endif
//  671 
//  672 //#if IS_SCARA	//mks_delta
//  673 #if 1
//  674   // Float constants for SCARA calculations
//  675   const float L1 = SCARA_LINKAGE_1, L2 = SCARA_LINKAGE_2,
//  676               L1_2 = sq(float(L1)), L1_2_2 = 2.0 * L1_2,
//  677               L2_2 = sq(float(L2));
//  678 
//  679 //  float delta_segments_per_second = SCARA_SEGMENTS_PER_SECOND,
//  680 //        delta[ABC];
//  681 #endif
//  682 
//  683 float cartes[XYZ] = { 0 };
//  684 
//  685 #if ENABLED(FILAMENT_WIDTH_SENSOR)
//  686   bool filament_sensor = false;                                 // M405 turns on filament sensor control. M406 turns it off.
//  687   float filament_width_nominal = DEFAULT_NOMINAL_FILAMENT_DIA,  // Nominal filament width. Change with M404.
//  688         filament_width_meas = DEFAULT_MEASURED_FILAMENT_DIA;    // Measured filament diameter
//  689   int8_t measurement_delay[MAX_MEASUREMENT_DELAY + 1];          // Ring buffer to delayed measurement. Store extruder factor after subtracting 100
//  690   int filwidth_delay_index[2] = { 0, -1 };                      // Indexes into ring buffer
//  691   int meas_delay_cm = MEASUREMENT_DELAY_CM;                     // Distance delay setting
//  692 #endif
//  693 
//  694 #if ENABLED(FILAMENT_RUNOUT_SENSOR)
//  695   static bool filament_ran_out = false;
//  696 #endif
//  697 
//  698 #if ENABLED(FILAMENT_CHANGE_FEATURE)
//  699   FilamentChangeMenuResponse filament_change_menu_response;
//  700 #endif
//  701 
//  702 #if ENABLED(MIXING_EXTRUDER)
//  703   float mixing_factor[MIXING_STEPPERS]; // Reciprocal of mix proportion. 0.0 = off, otherwise >= 1.0.
//  704   #if MIXING_VIRTUAL_TOOLS > 1
//  705     float mixing_virtual_tool_mix[MIXING_VIRTUAL_TOOLS][MIXING_STEPPERS];
//  706   #endif
//  707 #endif
//  708 
//  709 static bool send_ok[BUFSIZE];
//  710 
//  711 #if HAS_SERVOS
//  712   Servo servo[NUM_SERVOS];
//  713   #define MOVE_SERVO(I, P) servo[I].move(P)
//  714   #if HAS_Z_SERVO_ENDSTOP
//  715     #define DEPLOY_Z_SERVO() MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[0])
//  716     #define STOW_Z_SERVO() MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[1])
//  717   #endif
//  718 #endif
//  719 
//  720 #ifdef CHDK
//  721   millis_t chdkHigh = 0;
//  722   bool chdkActive = false;
//  723 #endif
//  724 
//  725 #ifdef AUTOMATIC_CURRENT_CONTROL
//  726   bool auto_current_control = 0;
//  727 #endif
//  728 
//  729 #if ENABLED(PID_EXTRUSION_SCALING)
//  730   int lpq_len = 20;
//  731 #endif
//  732 
//  733 #if ENABLED(HOST_KEEPALIVE_FEATURE)
//  734   MarlinBusyState busy_state = NOT_BUSY;
//  735   static millis_t next_busy_signal_ms = 0;
//  736   uint8_t host_keepalive_interval = DEFAULT_KEEPALIVE_INTERVAL;
//  737 #else
//  738   #define host_keepalive() NOOP
//  739 #endif
//  740 
//  741 static inline float pgm_read_any(const float *p) { return pgm_read_float_near(p); }
//  742 static inline signed char pgm_read_any(const signed char *p) { return pgm_read_byte_near(p); }
//  743 
//  744 /*--mks--*/
//  745 /*
//  746 #define XYZ_CONSTS_FROM_CONFIG(type, array, CONFIG) \ 
//  747   static const PROGMEM type array##_P[XYZ] = { X_##CONFIG, Y_##CONFIG, Z_##CONFIG }; \ 
//  748   static inline type array(AxisEnum axis) { return (array##_P[axis]); } 	
//  749   //typedef void __void_##CONFIG##__
//  750 
//  751 XYZ_CONSTS_FROM_CONFIG(float, base_min_pos,   MIN_POS);
//  752 XYZ_CONSTS_FROM_CONFIG(float, base_max_pos,   MAX_POS);
//  753 XYZ_CONSTS_FROM_CONFIG(float, base_home_pos,  HOME_POS);
//  754 XYZ_CONSTS_FROM_CONFIG(float, max_length,     MAX_LENGTH);
//  755 XYZ_CONSTS_FROM_CONFIG(float, home_bump_mm,   HOME_BUMP_MM);
//  756 XYZ_CONSTS_FROM_CONFIG(signed char, home_dir, HOME_DIR);
//  757 */
//  758 /*--mks cfg XYZ_CONSTS_FROM_CONFIG BEGIN--*/
//  759 #define XYZ_CONSTS_FROM_CONFIG(type, array, CONFIG) \ 
//  760   type array##_P[XYZ] = { X_##CONFIG, Y_##CONFIG, Z_##CONFIG }; \ 
//  761   static inline type array(AxisEnum axis) { return (array##_P[axis]); } 	
//  762   //typedef void __void_##CONFIG##__
//  763 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function _ZN37_INTERNAL_15_Marlin_main_cpp_3178531912base_min_posE8AxisEnum
          CFI NoCalls
        THUMB
//  764 XYZ_CONSTS_FROM_CONFIG(float, base_min_pos,   MIN_POS);			/*--mks cfg--*/
_ZN37_INTERNAL_15_Marlin_main_cpp_3178531912base_min_posE8AxisEnum:
        LDR.W    R1,??DataTable113_7
        ADD      R0,R1,R0, LSL #+2
        LDR      R0,[R0, #+4]
        BX       LR               ;; return
          CFI EndBlock cfiBlock2

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function _ZN37_INTERNAL_15_Marlin_main_cpp_3178531912base_max_posE8AxisEnum
          CFI NoCalls
        THUMB
//  765 XYZ_CONSTS_FROM_CONFIG(float, base_max_pos,   MAX_POS);			/*--mks cfg--*/
_ZN37_INTERNAL_15_Marlin_main_cpp_3178531912base_max_posE8AxisEnum:
        LDR.W    R1,??DataTable113_7
        ADD      R0,R1,R0, LSL #+2
        LDR      R0,[R0, #+16]
        BX       LR               ;; return
          CFI EndBlock cfiBlock3

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function _ZN37_INTERNAL_15_Marlin_main_cpp_3178531913base_home_posE8AxisEnum
          CFI NoCalls
        THUMB
//  766 XYZ_CONSTS_FROM_CONFIG(float, base_home_pos,  HOME_POS);		/*--mks cfg--*/ 
_ZN37_INTERNAL_15_Marlin_main_cpp_3178531913base_home_posE8AxisEnum:
        LDR.W    R1,??DataTable113_7
        ADD      R0,R1,R0, LSL #+2
        LDR      R0,[R0, #+28]
        BX       LR               ;; return
          CFI EndBlock cfiBlock4

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function _ZN37_INTERNAL_15_Marlin_main_cpp_3178531910max_lengthE8AxisEnum
          CFI NoCalls
        THUMB
//  767 XYZ_CONSTS_FROM_CONFIG(float, max_length,     MAX_LENGTH);		/*--mks cfg--*/	
_ZN37_INTERNAL_15_Marlin_main_cpp_3178531910max_lengthE8AxisEnum:
        LDR.W    R1,??DataTable113_7
        ADD      R0,R1,R0, LSL #+2
        LDR      R0,[R0, #+40]
        BX       LR               ;; return
          CFI EndBlock cfiBlock5

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function _ZN37_INTERNAL_15_Marlin_main_cpp_3178531912home_bump_mmE8AxisEnum
          CFI NoCalls
        THUMB
//  768 XYZ_CONSTS_FROM_CONFIG(float, home_bump_mm,   HOME_BUMP_MM);
_ZN37_INTERNAL_15_Marlin_main_cpp_3178531912home_bump_mmE8AxisEnum:
        LDR.W    R1,??DataTable116
        LDR      R0,[R1, R0, LSL #+2]
        BX       LR               ;; return
          CFI EndBlock cfiBlock6

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function _ZN37_INTERNAL_15_Marlin_main_cpp_317853198home_dirE8AxisEnum
          CFI NoCalls
        THUMB
//  769 XYZ_CONSTS_FROM_CONFIG(signed char, home_dir, HOME_DIR);		/*--mks cfg--*/
_ZN37_INTERNAL_15_Marlin_main_cpp_317853198home_dirE8AxisEnum:
        LDR.W    R1,??DataTable113_7
        LDRSB    R0,[R1, R0]
        BX       LR               ;; return
          CFI EndBlock cfiBlock7
//  770 //signed char home_dir_P[XYZ] = {-1, Y_HOME_DIR, Z_HOME_DIR }; 
//  771 //static inline signed char home_dir(AxisEnum axis) { return (home_dir_P[axis]); }	  
//  772 
//  773 /*--mks cfg XYZ_CONSTS_FROM_CONFIG END--*/
//  774 
//  775 /**
//  776  * ***************************************************************************
//  777  * ******************************** FUNCTIONS ********************************
//  778  * ***************************************************************************
//  779  */
//  780 
//  781 void stop();
//  782 
//  783 void get_available_commands();
//  784 void process_next_command();
//  785 void prepare_move_to_destination();
//  786 
//  787 void get_cartesian_from_steppers();
//  788 void set_current_from_steppers_for_axis(const AxisEnum axis);
//  789 
//  790 #if ENABLED(ARC_SUPPORT)
//  791   void plan_arc(float target[XYZE], float* offset, uint8_t clockwise);
//  792 #endif
//  793 
//  794 #if ENABLED(BEZIER_CURVE_SUPPORT)
//  795   void plan_cubic_move(const float offset[4]);
//  796 #endif
//  797 
//  798 void tool_change(const uint8_t tmp_extruder, const float fr_mm_s=0.0, bool no_move=false);
//  799 static void report_current_position();
//  800 
//  801 #if ENABLED(DEBUG_LEVELING_FEATURE)
//  802   void print_xyz(const char* prefix, const char* suffix, const float x, const float y, const float z) {
//  803     serialprintPGM(prefix);
//  804     SERIAL_CHAR('(');
//  805     SERIAL_ECHO(x);
//  806     SERIAL_ECHOPAIR(", ", y);
//  807     SERIAL_ECHOPAIR(", ", z);
//  808     SERIAL_CHAR(')');
//  809 
//  810     suffix ? serialprintPGM(suffix) : SERIAL_EOL;
//  811   }
//  812 
//  813   void print_xyz(const char* prefix, const char* suffix, const float xyz[]) {
//  814     print_xyz(prefix, suffix, xyz[X_AXIS], xyz[Y_AXIS], xyz[Z_AXIS]);
//  815   }
//  816 
//  817 //  #if HAS_ABL
//  818 #if 1
//  819     void print_xyz(const char* prefix, const char* suffix, const vector_3 &xyz) {
//  820       print_xyz(prefix, suffix, xyz.x, xyz.y, xyz.z);
//  821     }
//  822   #endif
//  823 
//  824   #define DEBUG_POS(SUFFIX,VAR) do { \ 
//  825     print_xyz(PSTR("  " STRINGIFY(VAR) "="), PSTR(" : " SUFFIX "\n"), VAR); } while(0)
//  826 #endif
//  827 
//  828 /**
//  829  * sync_plan_position
//  830  *
//  831  * Set the planner/stepper positions directly from current_position with
//  832  * no kinematic translation. Used for homing axes and cartesian/core syncing.
//  833  */
//  834 inline void sync_plan_position() {
//  835   #if ENABLED(DEBUG_LEVELING_FEATURE)
//  836     if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position", current_position);
//  837   #endif
//  838   planner.set_position_mm(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
//  839 }
//  840 inline void sync_plan_position_e() { planner.set_e_position_mm(current_position[E_AXIS]); }
//  841 
//  842 //mks_delta
//  843 /*	
//  844 #if IS_KINEMATIC
//  845 
//  846   inline void sync_plan_position_kinematic() {
//  847     #if ENABLED(DEBUG_LEVELING_FEATURE)
//  848       if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position_kinematic", current_position);
//  849     #endif
//  850     planner.set_position_mm_kinematic(current_position);
//  851   }
//  852   #define SYNC_PLAN_POSITION_KINEMATIC() sync_plan_position_kinematic()
//  853 #else
//  854   #define SYNC_PLAN_POSITION_KINEMATIC() sync_plan_position()
//  855 #endif
//  856 */
//  857 	inline void sync_plan_position_kinematic() {
//  858   #if ENABLED(DEBUG_LEVELING_FEATURE)
//  859 		if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position_kinematic", current_position);
//  860   #endif
//  861 	  planner.set_position_mm_kinematic(current_position);
//  862 	}
//  863 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function _Z28SYNC_PLAN_POSITION_KINEMATICv
        THUMB
//  864 void SYNC_PLAN_POSITION_KINEMATIC()
//  865 {
//  866 	if(MACHINETPYE & IS_KINEMATIC)
_Z28SYNC_PLAN_POSITION_KINEMATICv:
        LDR.W    R0,??DataTable113_4
        LDRH     R0,[R0, #+88]
        MOVW     R1,#+770
        TST      R0,R1
        BEQ.N    ??SYNC_PLAN_POSITION_KINEMATIC_0
//  867 		sync_plan_position_kinematic();
          CFI FunCall _Z28sync_plan_position_kinematicv
        B.W      _Z28sync_plan_position_kinematicv
//  868 	else
//  869 		sync_plan_position();
??SYNC_PLAN_POSITION_KINEMATIC_0:
          CFI FunCall _Z18sync_plan_positionv
        B.W      _Z18sync_plan_positionv
//  870 }
          CFI EndBlock cfiBlock8
//  871 	
//  872 
//  873 
//  874 #if 0	/*--mks--*/
//  875 //#if ENABLED(SDSUPPORT)
//  876   #include "SdFatUtil.h"
//  877   int freeMemory() { return SdFatUtil::FreeRam(); }
//  878 #else
//  879 /*
//  880 extern "C" {
//  881   extern char __bss_end;
//  882   extern char __heap_start;
//  883   extern void* __brkval;
//  884 
//  885   int freeMemory() {
//  886     int free_memory;
//  887     if ((int)__brkval == 0)
//  888       free_memory = ((int)&free_memory) - ((int)&__bss_end);
//  889     else
//  890       free_memory = ((int)&free_memory) - ((int)__brkval);
//  891     return free_memory;
//  892   }
//  893 }
//  894 */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock9 Using cfiCommon0
          CFI Function _Z10freeMemoryv
          CFI NoCalls
        THUMB
//  895 	int freeMemory() { return 4396; }	//No free ram management
_Z10freeMemoryv:
        MOVW     R0,#+4396
        BX       LR               ;; return
          CFI EndBlock cfiBlock9
//  896 
//  897 #endif //!SDSUPPORT
//  898 
//  899 #if ENABLED(DIGIPOT_I2C)
//  900   extern void digipot_i2c_set_current(int channel, float current);
//  901   extern void digipot_i2c_init();
//  902 #endif
//  903 
//  904 /**
//  905  * Inject the next "immediate" command, when possible, onto the front of the queue.
//  906  * Return true if any immediate commands remain to inject.
//  907  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock10 Using cfiCommon0
          CFI Function _ZN37_INTERNAL_15_Marlin_main_cpp_3178531925drain_injected_commands_PEv
        THUMB
//  908 static bool drain_injected_commands_P() {
_ZN37_INTERNAL_15_Marlin_main_cpp_3178531925drain_injected_commands_PEv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+32
          CFI CFA R13+48
//  909   if (injected_commands_P != NULL) {
        LDR.W    R5,??DataTable116_1
        LDR      R1,[R5, #+0]
        CMP      R1,#+0
        BEQ.N    ??drain_injected_commands_P_0
//  910     size_t i = 0;
        MOVS     R6,#+0
//  911     char c, cmd[30];
//  912 	//strncpy_P(cmd, injected_commands_P, sizeof(cmd) - 1);
//  913     strncpy(cmd, injected_commands_P, sizeof(cmd) - 1);	/*--mks--*/
        MOVS     R2,#+29
        MOV      R0,SP
          CFI FunCall strncpy
        BL       strncpy
//  914 
//  915 	cmd[sizeof(cmd) - 1] = '\0';
        MOV      R0,SP
        MOV      R1,R6
        STRB     R1,[R0, #+29]
//  916     while ((c = cmd[i]) && c != '\n') i++; // find the end of this gcode command
??drain_injected_commands_P_1:
        LDRSB    R4,[R0, R6]
        CMP      R4,#+0
        BEQ.N    ??drain_injected_commands_P_2
        CMP      R4,#+10
        BEQ.N    ??drain_injected_commands_P_2
        ADDS     R6,R6,#+1
        B.N      ??drain_injected_commands_P_1
//  917     cmd[i] = '\0';
//  918     if (enqueue_and_echo_command(cmd))     // success?
//  919       injected_commands_P = c ? injected_commands_P + i + 1 : NULL; // next command or done
??drain_injected_commands_P_3:
        MOVS     R0,#+0
        STR      R0,[R5, #+0]
//  920   }
//  921   return (injected_commands_P != NULL);    // return whether any more remain
??drain_injected_commands_P_0:
        LDR      R0,[R5, #+0]
        CMP      R0,#+0
        BEQ.N    ??drain_injected_commands_P_4
        MOVS     R0,#+1
        B.N      ??drain_injected_commands_P_5
??drain_injected_commands_P_4:
        MOVS     R0,#+0
??drain_injected_commands_P_5:
        ADD      SP,SP,#+32
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
          CFI CFA R13+48
??drain_injected_commands_P_2:
        STRB     R1,[R0, R6]
          CFI FunCall _Z24enqueue_and_echo_commandPKcb
        BL       _Z24enqueue_and_echo_commandPKcb
        CMP      R0,#+0
        BEQ.N    ??drain_injected_commands_P_0
        CMP      R4,#+0
        BEQ.N    ??drain_injected_commands_P_3
        LDR      R0,[R5, #+0]
        ADD      R0,R0,R6
        ADDS     R0,R0,#+1
        STR      R0,[R5, #+0]
        B.N      ??drain_injected_commands_P_0
//  922 }
          CFI EndBlock cfiBlock10
//  923 
//  924 /**
//  925  * Record one or many commands to run from program memory.
//  926  * Aborts the current queue, if any.
//  927  * Note: drain_injected_commands_P() must be called repeatedly to drain the commands afterwards
//  928  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock11 Using cfiCommon0
          CFI Function _Z27enqueue_and_echo_commands_PPKc
        THUMB
//  929 void enqueue_and_echo_commands_P(const char* pgcode) {
//  930   injected_commands_P = pgcode;
_Z27enqueue_and_echo_commands_PPKc:
        LDR.W    R1,??DataTable116_1
        STR      R0,[R1, #+0]
//  931   drain_injected_commands_P(); // first command executed asap (when possible)
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531925drain_injected_commands_PEv
        B.N      _ZN37_INTERNAL_15_Marlin_main_cpp_3178531925drain_injected_commands_PEv
//  932 }
          CFI EndBlock cfiBlock11
//  933 
//  934 /**
//  935  * Clear the Marlin command queue
//  936  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock12 Using cfiCommon0
          CFI Function _Z19clear_command_queuev
          CFI NoCalls
        THUMB
//  937 void clear_command_queue() {
//  938   cmd_queue_index_r = cmd_queue_index_w;
_Z19clear_command_queuev:
        LDR.W    R0,??DataTable116_2
        LDRB     R1,[R0, #+10]
        STRB     R1,[R0, #+9]
//  939   commands_in_queue = 0;
        MOVS     R1,#+0
        STRB     R1,[R0, #+8]
//  940 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock12
//  941 
//  942 /**
//  943  * Once a new command is in the ring buffer, call this to commit it
//  944  */
//  945 inline void _commit_command(bool say_ok) {
//  946   send_ok[cmd_queue_index_w] = say_ok;
//  947   if (++cmd_queue_index_w >= BUFSIZE) cmd_queue_index_w = 0;
//  948   commands_in_queue++;
//  949 }
//  950 
//  951 /**
//  952  * Copy a command from RAM into the main command buffer.
//  953  * Return true if the command was successfully added.
//  954  * Return false for a full buffer, or if the 'command' is a comment.
//  955  */
//  956 inline bool _enqueuecommand(const char* cmd, bool say_ok=false) {
//  957   if (*cmd == ';' || commands_in_queue >= BUFSIZE) return false;
//  958   strcpy(command_queue[cmd_queue_index_w], cmd);
//  959   _commit_command(say_ok);
//  960   return true;
//  961 }
//  962 
//  963 /**
//  964  * Enqueue with Serial Echo
//  965  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock13 Using cfiCommon0
          CFI Function _Z24enqueue_and_echo_commandPKcb
        THUMB
//  966 bool enqueue_and_echo_command(const char* cmd, bool say_ok/*=false*/) {
_Z24enqueue_and_echo_commandPKcb:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
//  967   if (_enqueuecommand(cmd, say_ok)) {
          CFI FunCall _Z15_enqueuecommandPKcb
        BL       _Z15_enqueuecommandPKcb
        CMP      R0,#+0
        BEQ.N    ??enqueue_and_echo_command_0
//  968     SERIAL_ECHO_START;
        LDR.W    R0,??DataTable116_3
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
//  969     SERIAL_ECHOPAIR(MSG_ENQUEUEING, cmd);
        MOV      R1,R4
        ADR.W    R0,?_0
          CFI FunCall _Z17serial_echopair_PPKcS0_
        BL       _Z17serial_echopair_PPKcS0_
//  970     SERIAL_CHAR('"');
        LDR.W    R4,??DataTable112_3
        LDRB     R0,[R4, #+7]
        CMP      R0,#+0
        BNE.N    ??enqueue_and_echo_command_1
        MOVS     R1,#+34
        LDR.W    R0,??DataTable116_4
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??enqueue_and_echo_command_2
??enqueue_and_echo_command_1:
        MOVS     R2,#+0
        MOVS     R1,#+34
        LDR.W    R0,??DataTable116_5
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
//  971     SERIAL_EOL;
??enqueue_and_echo_command_2:
        LDRB     R0,[R4, #+7]
        CMP      R0,#+0
        BNE.N    ??enqueue_and_echo_command_3
        MOVS     R1,#+10
        LDR.W    R0,??DataTable116_4
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??enqueue_and_echo_command_4
??enqueue_and_echo_command_3:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.W    R0,??DataTable116_5
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
//  972     return true;
??enqueue_and_echo_command_4:
        MOVS     R0,#+1
        POP      {R4,PC}
//  973   }
//  974   return false;
??enqueue_and_echo_command_0:
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
//  975 }
          CFI EndBlock cfiBlock13

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_0:
        DC8 "enqueueing \""
        DC8 0, 0, 0
//  976 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock14 Using cfiCommon0
          CFI Function _Z13setup_killpinv
          CFI NoCalls
        THUMB
//  977 void setup_killpin() {
//  978   #if HAS_KILL
//  979     SET_INPUT_PULLUP(KILL_PIN);
//  980   #endif
//  981 }
_Z13setup_killpinv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock14
//  982 
//  983 #if ENABLED(FILAMENT_RUNOUT_SENSOR)
//  984 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock15 Using cfiCommon0
          CFI Function _Z18setup_filrunoutpinv
          CFI NoCalls
        THUMB
//  985   void setup_filrunoutpin() {
//  986     #if ENABLED(ENDSTOPPULLUP_FIL_RUNOUT)
//  987       SET_INPUT_PULLUP(FIL_RUNOUT_PIN);
//  988     #else
//  989       SET_INPUT(FIL_RUNOUT_PIN);
//  990     #endif
//  991   }
_Z18setup_filrunoutpinv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock15
//  992 
//  993 #endif
//  994 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock16 Using cfiCommon0
          CFI Function _Z13setup_homepinv
          CFI NoCalls
        THUMB
//  995 void setup_homepin(void) {
//  996   #if HAS_HOME
//  997     SET_INPUT_PULLUP(HOME_PIN);
//  998   #endif
//  999 }
_Z13setup_homepinv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock16
// 1000 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock17 Using cfiCommon0
          CFI Function _Z15setup_powerholdv
          CFI NoCalls
        THUMB
// 1001 void setup_powerhold() {
// 1002   #if HAS_SUICIDE
// 1003     OUT_WRITE(SUICIDE_PIN, HIGH);
// 1004   #endif
// 1005   #if HAS_POWER_SWITCH
// 1006     #if ENABLED(PS_DEFAULT_OFF)
// 1007       OUT_WRITE(PS_ON_PIN, PS_ON_ASLEEP);
// 1008     #else
// 1009       OUT_WRITE(PS_ON_PIN, PS_ON_AWAKE);
// 1010     #endif
// 1011   #endif
// 1012 }
_Z15setup_powerholdv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock17
// 1013 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock18 Using cfiCommon0
          CFI Function _Z7suicidev
          CFI NoCalls
        THUMB
// 1014 void suicide() {
// 1015   #if HAS_SUICIDE
// 1016     OUT_WRITE(SUICIDE_PIN, LOW);
// 1017   #endif
// 1018 }
_Z7suicidev:
        BX       LR               ;; return
          CFI EndBlock cfiBlock18
// 1019 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock19 Using cfiCommon0
          CFI Function _Z10servo_initv
          CFI NoCalls
        THUMB
// 1020 void servo_init() {
// 1021   #if NUM_SERVOS >= 1 && HAS_SERVO_0
// 1022     servo[0].attach(SERVO0_PIN);
// 1023     servo[0].detach(); // Just set up the pin. We don't have a position yet. Don't move to a random position.
// 1024   #endif
// 1025   #if NUM_SERVOS >= 2 && HAS_SERVO_1
// 1026     servo[1].attach(SERVO1_PIN);
// 1027     servo[1].detach();
// 1028   #endif
// 1029   #if NUM_SERVOS >= 3 && HAS_SERVO_2
// 1030     servo[2].attach(SERVO2_PIN);
// 1031     servo[2].detach();
// 1032   #endif
// 1033   #if NUM_SERVOS >= 4 && HAS_SERVO_3
// 1034     servo[3].attach(SERVO3_PIN);
// 1035     servo[3].detach();
// 1036   #endif
// 1037 
// 1038   #if HAS_Z_SERVO_ENDSTOP
// 1039     /**
// 1040      * Set position of Z Servo Endstop
// 1041      *
// 1042      * The servo might be deployed and positioned too low to stow
// 1043      * when starting up the machine or rebooting the board.
// 1044      * There's no way to know where the nozzle is positioned until
// 1045      * homing has been done - no homing with z-probe without init!
// 1046      *
// 1047      */
// 1048     STOW_Z_SERVO();
// 1049   #endif
// 1050 }
_Z10servo_initv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock19
// 1051 
// 1052 /**
// 1053  * Stepper Reset (RigidBoard, et.al.)
// 1054  */
// 1055 #if HAS_STEPPER_RESET
// 1056   void disableStepperDrivers() {
// 1057     OUT_WRITE(STEPPER_RESET_PIN, LOW);  // drive it down to hold in reset motor driver chips
// 1058   }
// 1059   void enableStepperDrivers() { SET_INPUT(STEPPER_RESET_PIN); }  // set to input, which allows it to be pulled high by pullups
// 1060 #endif
// 1061 
// 1062 #if ENABLED(EXPERIMENTAL_I2CBUS) && I2C_SLAVE_ADDRESS > 0
// 1063 
// 1064   void i2c_on_receive(int bytes) { // just echo all bytes received to serial
// 1065     i2c.receive(bytes);
// 1066   }
// 1067 
// 1068   void i2c_on_request() {          // just send dummy data for now
// 1069     i2c.reply("Hello World!\n");
// 1070   }
// 1071 
// 1072 #endif
// 1073 
// 1074 #if HAS_COLOR_LEDS
// 1075 
// 1076   void set_led_color(
// 1077     const uint8_t r, const uint8_t g, const uint8_t b
// 1078       #if ENABLED(RGBW_LED)
// 1079         , const uint8_t w=0
// 1080       #endif
// 1081   ) {
// 1082 
// 1083     #if ENABLED(BLINKM)
// 1084 
// 1085       // This variant uses i2c to send the RGB components to the device.
// 1086       SendColors(r, g, b);
// 1087 
// 1088     #else
// 1089 
// 1090       // This variant uses 3 separate pins for the RGB components.
// 1091       // If the pins can do PWM then their intensity will be set.
// 1092       WRITE(RGB_LED_R_PIN, r ? HIGH : LOW);
// 1093       WRITE(RGB_LED_G_PIN, g ? HIGH : LOW);
// 1094       WRITE(RGB_LED_B_PIN, b ? HIGH : LOW);
// 1095       analogWrite(RGB_LED_R_PIN, r);
// 1096       analogWrite(RGB_LED_G_PIN, g);
// 1097       analogWrite(RGB_LED_B_PIN, b);
// 1098 
// 1099       #if ENABLED(RGBW_LED)
// 1100         WRITE(RGB_LED_W_PIN, w ? HIGH : LOW);
// 1101         analogWrite(RGB_LED_W_PIN, w);
// 1102       #endif
// 1103 
// 1104     #endif
// 1105   }
// 1106 
// 1107 #endif // HAS_COLOR_LEDS
// 1108 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock20 Using cfiCommon0
          CFI Function _Z16gcode_line_errorPKcb
        THUMB
// 1109 void gcode_line_error(const char* err, bool doFlush = true) {
_Z16gcode_line_errorPKcb:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R4,R0
        MOV      R5,R1
// 1110   SERIAL_ERROR_START;
        LDR.W    R0,??DataTable116_6
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 1111   serialprintPGM(err);
        MOV      R0,R4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 1112   SERIAL_ERRORLN(gcode_LastN);
        LDR.W    R4,??DataTable116_2
        LDR      R1,[R4, #+32]
        LDR.W    R6,??DataTable112_3
        LDRB     R0,[R6, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_line_error_0
        MOVS     R2,#+10
        LDR.W    R0,??DataTable116_4
          CFI FunCall _ZN12MarlinSerial5printEli
        BL       _ZN12MarlinSerial5printEli
        B.N      ??gcode_line_error_1
??gcode_line_error_0:
        MOVS     R2,#+10
        LDR.W    R0,??DataTable116_5
          CFI FunCall _ZN12MarlinSerial5printEli
        BL       _ZN12MarlinSerial5printEli
??gcode_line_error_1:
        LDRB     R0,[R6, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_line_error_2
        MOVS     R1,#+10
        LDR.W    R0,??DataTable116_4
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??gcode_line_error_3
??gcode_line_error_2:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.W    R0,??DataTable116_5
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
// 1113   //Serial.println(gcode_N);
// 1114   if (doFlush) FlushSerialRequestResend();
??gcode_line_error_3:
        CMP      R5,#+0
        BEQ.N    ??gcode_line_error_4
          CFI FunCall _Z24FlushSerialRequestResendv
        BL       _Z24FlushSerialRequestResendv
// 1115   serial_count = 0;
??gcode_line_error_4:
        MOVS     R0,#+0
        STR      R0,[R4, #+48]
// 1116 }
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock20

        SECTION `.data`:DATA:REORDER:NOROOT(2)
        DATA
mks_heating_busy:
        DC8 0
marlin_debug_flags:
        DC8 0
active_extruder:
        DC8 0
wait_for_heatup:
        DC8 1
wait_for_user:
        DC8 0
target_extruder:
        DC8 0
busy_state:
        DC8 0
// 1117 
// 1118 /**
// 1119  * Get all commands waiting on the serial port and queue them.
// 1120  * Exit when the buffer is full or when no more characters are
// 1121  * left on the serial port.
// 1122  */
// 1123  uint8_t serial_wait_tick = 0; //use to calculate the serial wait ticks
// 1124 
// 1125 uint8_t from_wifi_flag = 0; // whether data comes from wifi model
from_wifi_flag:
        DC8 0
current_position:
        DC32 0H
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
destination:
        DC32 0H
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
homing_feedrate_mm_s:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
home_offset:
        DC32 0H
        DC8 0, 0, 0, 0, 0, 0, 0, 0
workspace_offset:
        DC32 0H
        DC8 0, 0, 0, 0, 0, 0, 0, 0
soft_endstop_min:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
soft_endstop_max:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
delta:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC32 41C80000H
feedrate_percentage:
        DC32 100
xy_probe_feedrate_mm_s:
        DC8 0, 0, 0, 0
delta_clip_start_height:
        DC8 0, 0, 0, 0
ubl:
        DC8 0
        DC8 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
print_job_timer:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
buzzer:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
// 1126 
// 1127 inline void get_serial_commands() {
// 1128   static char serial_line_buffer[MAX_CMD_SIZE];
// 1129   static bool serial_comment_mode = false;
// 1130 static millis_t last_wait_time = 0;
// 1131     const millis_t wait_ms = millis();
// 1132 
// 1133   // If the command buffer is empty for too long,
// 1134   // send "wait" to indicate Marlin is still waiting.
// 1135   #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
// 1136     static millis_t last_command_time = 0;
// 1137     const millis_t ms = millis();
// 1138     if (commands_in_queue == 0 && !MYSERIAL.available() && ELAPSED(ms, last_command_time + NO_TIMEOUTS)) {
// 1139       SERIAL_ECHOLNPGM(MSG_WAIT);
// 1140       last_command_time = ms;
// 1141     }
// 1142   #endif
// 1143 
// 1144 #ifdef USE_MKS_WIFI
// 1145 
// 1146 	/*5s?¨¬2a2?¦Ì?¡ä??¨²¨ºy?Y?¨°¨¨??a??¨®D¨¢a?¨²????¡ê??¨¦¨º1¨®?wifi*/
// 1147    if (commands_in_queue == 0 && !MYSERIAL.available() && ELAPSED(wait_ms, last_wait_time + 1000)) {
// 1148       if(serial_wait_tick <= 5)
// 1149 	{
// 1150 		serial_wait_tick ++;
// 1151 	}
// 1152       last_wait_time = wait_ms;
// 1153     }
// 1154 #endif
// 1155   /**
// 1156    * Loop while serial characters are incoming and the queue is not full
// 1157    */
// 1158   while (commands_in_queue < BUFSIZE && MYSERIAL.available() > 0) {
// 1159 
// 1160     char serial_char = MYSERIAL.read();
// 1161 
// 1162 	serial_wait_tick = 0;
// 1163 	from_wifi_flag = 0;
// 1164 
// 1165     /**
// 1166      * If the character ends the line
// 1167      */
// 1168     if (serial_char == '\n' || serial_char == '\r') {
// 1169 
// 1170       serial_comment_mode = false; // end of line == end of comment
// 1171 
// 1172       if (!serial_count) continue; // skip empty lines
// 1173 
// 1174       serial_line_buffer[serial_count] = 0; // terminate string
// 1175       serial_count = 0; //reset buffer
// 1176 
// 1177       char* command = serial_line_buffer;
// 1178 
// 1179       while (*command == ' ') command++; // skip any leading spaces
// 1180       char* npos = (*command == 'N') ? command : NULL; // Require the N parameter to start the line
// 1181       char* apos = strchr(command, '*');
// 1182 
// 1183       if (npos) {
// 1184 
// 1185         bool M110 = strstr_P(command, PSTR("M110")) != NULL;
// 1186 
// 1187         if (M110) {
// 1188           char* n2pos = strchr(command + 4, 'N');
// 1189           if (n2pos) npos = n2pos;
// 1190         }
// 1191 
// 1192         gcode_N = strtol(npos + 1, NULL, 10);
// 1193 
// 1194         if (gcode_N != gcode_LastN + 1 && !M110) {
// 1195           gcode_line_error(PSTR(MSG_ERR_LINE_NO));
// 1196           return;
// 1197         }
// 1198 
// 1199         if (apos) {
// 1200           byte checksum = 0, count = 0;
// 1201           while (command[count] != '*') checksum ^= command[count++];
// 1202 
// 1203           if (strtol(apos + 1, NULL, 10) != checksum) {
// 1204             gcode_line_error(PSTR(MSG_ERR_CHECKSUM_MISMATCH));
// 1205             return;
// 1206           }
// 1207           // if no errors, continue parsing
// 1208         }
// 1209         else {
// 1210           gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM));
// 1211           return;
// 1212         }
// 1213 
// 1214         gcode_LastN = gcode_N;
// 1215         // if no errors, continue parsing
// 1216       }
// 1217       else if (apos) { // No '*' without 'N'
// 1218         gcode_line_error(PSTR(MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM), false);
// 1219         return;
// 1220       }
// 1221 
// 1222       // Movement commands alert when stopped
// 1223       if (IsStopped()) {
// 1224         char* gpos = strchr(command, 'G');
// 1225         if (gpos) {
// 1226           const int codenum = strtol(gpos + 1, NULL, 10);
// 1227           switch (codenum) {
// 1228             case 0:
// 1229             case 1:
// 1230             case 2:
// 1231             case 3:
// 1232               SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
// 1233               LCD_MESSAGEPGM(MSG_STOPPED);
// 1234               break;
// 1235           }
// 1236         }
// 1237       }
// 1238 
// 1239       #if DISABLED(EMERGENCY_PARSER)
// 1240         // If command was e-stop process now
// 1241         if (strcmp(command, "M108") == 0) {
// 1242           wait_for_heatup = false;
// 1243           #if ENABLED(ULTIPANEL)
// 1244             wait_for_user = false;
// 1245           #endif
// 1246         }
// 1247         if (strcmp(command, "M112") == 0) kill(PSTR(MSG_KILLED));
// 1248         if (strcmp(command, "M410") == 0) { quickstop_stepper(); }
// 1249       #endif
// 1250 
// 1251       #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
// 1252         last_command_time = ms;
// 1253       #endif
// 1254 
// 1255       // Add the command to the queue
// 1256       _enqueuecommand(serial_line_buffer, true);
// 1257     }
// 1258     else if (serial_count >= MAX_CMD_SIZE - 1) {
// 1259       // Keep fetching, but ignore normal characters beyond the max length
// 1260       // The command will be injected when EOL is reached
// 1261     }
// 1262     else if (serial_char == '\\') {  // Handle escapes
// 1263       if (MYSERIAL.available() > 0) {
// 1264         // if we have one more character, copy it over
// 1265         serial_char = MYSERIAL.read();
// 1266         if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
// 1267       }
// 1268       // otherwise do nothing
// 1269     }
// 1270     else { // it's not a newline, carriage return or escape char
// 1271       if (serial_char == ';') serial_comment_mode = true;
// 1272       if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
// 1273     }
// 1274 
// 1275   } // queue has space, serial has data
// 1276 }
// 1277 
// 1278 #if ENABLED(SDSUPPORT)
// 1279 
// 1280   /**
// 1281    * Get commands from the SD Card until the command buffer is full
// 1282    * or until the end of the file is reached. The special character '#'
// 1283    * can also interrupt buffering.
// 1284    */
// 1285   inline void get_sdcard_commands() {
// 1286     static bool stop_buffering = false,
// 1287                 sd_comment_mode = false;
// 1288 
// 1289     if (!card.sdprinting) 
// 1290       return;
// 1291 
// 1292     /**
// 1293      * '#' stops reading from SD to the buffer prematurely, so procedural
// 1294      * macro calls are possible. If it occurs, stop_buffering is triggered
// 1295      * and the buffer is run dry; this character _can_ occur in serial com
// 1296      * due to checksums, however, no checksums are used in SD printing.
// 1297      */
// 1298 
// 1299     if (commands_in_queue == 0) stop_buffering = false;
// 1300 
// 1301     uint16_t sd_count = 0;
// 1302     bool card_eof = card.eof();
// 1303     while (commands_in_queue < BUFSIZE && !card_eof && !stop_buffering) {
// 1304       const int16_t n = card.get();
// 1305       char sd_char = (char)n;
// 1306       card_eof = card.eof();
// 1307       if (card_eof || n == -1
// 1308           || sd_char == '\n' || sd_char == '\r'
// 1309           || ((sd_char == '#' || sd_char == ':') && !sd_comment_mode)
// 1310       ) {
// 1311         if (card_eof) {
// 1312           SERIAL_PROTOCOLLNPGM(MSG_FILE_PRINTED);
// 1313           card.printingHasFinished();
// 1314           #if ENABLED(PRINTER_EVENT_LEDS)
// 1315             LCD_MESSAGEPGM(MSG_INFO_COMPLETED_PRINTS);
// 1316             set_led_color(0, 255, 0); // Green
// 1317             #if HAS_RESUME_CONTINUE
// 1318               enqueue_and_echo_commands_P(PSTR("M0")); // end of the queue!
// 1319             #else
// 1320               safe_delay(1000);
// 1321             #endif
// 1322             set_led_color(0, 0, 0);   // OFF
// 1323           #endif
// 1324           card.checkautostart(true);
// 1325         }
// 1326         else if (n == -1) {
// 1327           SERIAL_ERROR_START;
// 1328           SERIAL_ECHOLNPGM(MSG_SD_ERR_READ);
// 1329         }
// 1330         if (sd_char == '#') stop_buffering = true;
// 1331 
// 1332         sd_comment_mode = false; // for new command
// 1333 
// 1334         if (!sd_count) continue; // skip empty lines (and comment lines)
// 1335 
// 1336         command_queue[cmd_queue_index_w][sd_count] = '\0'; // terminate string
// 1337         sd_count = 0; // clear sd line buffer
// 1338 
// 1339         _commit_command(false);
// 1340       }
// 1341       else if (sd_count >= MAX_CMD_SIZE - 1) {
// 1342         /**
// 1343          * Keep fetching, but ignore normal characters beyond the max length
// 1344          * The command will be injected when EOL is reached
// 1345          */
// 1346       }
// 1347       else {
// 1348         if (sd_char == ';') sd_comment_mode = true;
// 1349         if (!sd_comment_mode) 
// 1350         	{
// 1351 			command_queue[cmd_queue_index_w][sd_count++] = sd_char;
// 1352 			if(sd_char == 0x5a ) 
// 1353 				{
// 1354 				mksReprint.sdpos = card.getsdpos()-3;	//"·Ö²ãÎ»ÖÃ"
// 1355 				mksReprint.refresh = true;
// 1356 				}
// 1357         	}
// 1358 		
// 1359       }
// 1360     }
// 1361   }
// 1362 
// 1363 #endif // SDSUPPORT
// 1364 
// 1365 #ifdef USE_MKS_WIFI
// 1366 inline void get_wifi_commands() {
// 1367   static char wifi_line_buffer[MAX_CMD_SIZE];
// 1368   static bool wifi_comment_mode = false;
// 1369 
// 1370   if(serial_wait_tick > 5)
// 1371   {
// 1372   	from_wifi_flag = 1;
// 1373 
// 1374 /**
// 1375 	   * Loop while serial characters are incoming and the queue is not full
// 1376 	   */
// 1377 	  while ((commands_in_queue < BUFSIZE) && (espGcodeFifo.r != espGcodeFifo.w)) {
// 1378 
// 1379 	    char wifi_char = espGcodeFifo.Buffer[espGcodeFifo.r];
// 1380 
// 1381 	    espGcodeFifo.r = (espGcodeFifo.r + 1) % WIFI_GCODE_BUFFER_SIZE;
// 1382 
// 1383 	    /**
// 1384 	     * If the character ends the line
// 1385 	     */
// 1386 	    if (wifi_char == '\n' || wifi_char == '\r') {
// 1387 
// 1388 	      wifi_comment_mode = false; // end of line == end of comment
// 1389 
// 1390 	      if (!wifi_read_count) continue; // skip empty lines
// 1391 
// 1392 	      wifi_line_buffer[wifi_read_count] = 0; // terminate string
// 1393 	      wifi_read_count = 0; //reset buffer
// 1394 
// 1395 	      char* command = wifi_line_buffer;
// 1396 
// 1397 	      while (*command == ' ') command++; // skip any leading spaces	    
// 1398 
// 1399 	      // Movement commands alert when stopped
// 1400 	      if (IsStopped()) {
// 1401 	        char* gpos = strchr(command, 'G');
// 1402 	        if (gpos) {
// 1403 	          const int codenum = strtol(gpos + 1, NULL, 10);
// 1404 	          switch (codenum) {
// 1405 	            case 0:
// 1406 	            case 1:
// 1407 	            case 2:
// 1408 	            case 3:
// 1409 	              SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
// 1410 	              LCD_MESSAGEPGM(MSG_STOPPED);
// 1411 	              break;
// 1412 	          }
// 1413 	        }
// 1414 	      }
// 1415 
// 1416 	      #if DISABLED(EMERGENCY_PARSER)
// 1417 	        // If command was e-stop process now
// 1418 	        if (strcmp(command, "M108") == 0) {
// 1419 	          wait_for_heatup = false;
// 1420 	          #if ENABLED(ULTIPANEL)
// 1421 	            wait_for_user = false;
// 1422 	          #endif
// 1423 	        }
// 1424 	        if (strcmp(command, "M112") == 0) kill(PSTR(MSG_KILLED));
// 1425 	        if (strcmp(command, "M410") == 0) { quickstop_stepper(); }
// 1426 	      #endif
// 1427 
// 1428 	      #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
// 1429 	        last_command_time = ms;
// 1430 	      #endif
// 1431 
// 1432 	      // Add the command to the queue
// 1433 	      _enqueuecommand(wifi_line_buffer, true);
// 1434 	    }
// 1435 	    else if (wifi_read_count >= MAX_CMD_SIZE - 1) {
// 1436 	      // Keep fetching, but ignore normal characters beyond the max length
// 1437 	      // The command will be injected when EOL is reached
// 1438 	    }
// 1439 		/*
// 1440 	    else if (wifi_char == '\\') {  // Handle escapes
// 1441 	      if (MYSERIAL.available() > 0) {
// 1442 	        // if we have one more character, copy it over
// 1443 	        wifi_char = MYSERIAL.read();
// 1444 	        if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
// 1445 	      }
// 1446 	      // otherwise do nothing
// 1447 	    }*/
// 1448 	    else { // it's not a newline, carriage return or escape char
// 1449 	      if (wifi_char == ';') wifi_comment_mode = true;
// 1450 	      if (!wifi_comment_mode) wifi_line_buffer[wifi_read_count++] = wifi_char;
// 1451 	    }
// 1452 
// 1453 	  }
// 1454     }// queue has space, serial has data
// 1455     else
// 1456     {
// 1457     	from_wifi_flag = 0;
// 1458     }
// 1459 }
// 1460 #endif
// 1461 
// 1462 /**
// 1463  * Add to the circular command queue the next command from:
// 1464  *  - The command-injection queue (injected_commands_P)
// 1465  *  - The active serial input (usually USB)
// 1466  *  - The SD card file being actively printed
// 1467  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock21 Using cfiCommon0
          CFI Function _Z22get_available_commandsv
        THUMB
// 1468 void get_available_commands() {
_Z22get_available_commandsv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 1469 
// 1470   // if any immediate commands remain, don't get other commands yet
// 1471   if (drain_injected_commands_P()) return;
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531925drain_injected_commands_PEv
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531925drain_injected_commands_PEv
        CMP      R0,#+0
        BNE.N    ??get_available_commands_0
// 1472 //#if MASK_FOR_SPACE
// 1473   get_serial_commands();
          CFI FunCall _Z19get_serial_commandsv
        BL       _Z19get_serial_commandsv
// 1474 //#endif
// 1475 
// 1476 #ifdef USE_MKS_WIFI
// 1477   get_wifi_commands();
          CFI FunCall _Z17get_wifi_commandsv
        BL       _Z17get_wifi_commandsv
// 1478 #endif
// 1479 
// 1480   #if ENABLED(SDSUPPORT)
// 1481  // #if MASK_FOR_SPACE
// 1482     get_sdcard_commands();
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z19get_sdcard_commandsv
        B.W      _Z19get_sdcard_commandsv
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??get_available_commands_0:
        POP      {R0,PC}          ;; return
// 1483  //#endif
// 1484   #endif
// 1485 }
          CFI EndBlock cfiBlock21
// 1486 
// 1487 inline bool code_has_value() {
// 1488   int i = 1;
// 1489   char c = seen_pointer[i];
// 1490   while (c == ' ') c = seen_pointer[++i];
// 1491   if (c == '-' || c == '+') c = seen_pointer[++i];
// 1492   if (c == '.') c = seen_pointer[++i];
// 1493   return NUMERIC(c);
// 1494 }
// 1495 
// 1496 inline float code_value_float() {
// 1497   char* e = strchr(seen_pointer, 'E');
// 1498   if (!e) return strtod(seen_pointer + 1, NULL);
// 1499   *e = 0;
// 1500   float ret = strtod(seen_pointer + 1, NULL);
// 1501   *e = 'E';
// 1502   return ret;
// 1503 }
// 1504 
// 1505 inline unsigned long code_value_ulong() { return strtoul(seen_pointer + 1, NULL, 10); }
// 1506 
// 1507 inline long code_value_long() { return strtol(seen_pointer + 1, NULL, 10); }
// 1508 
// 1509 inline int code_value_int() { return (int)strtol(seen_pointer + 1, NULL, 10); }
// 1510 
// 1511 inline uint16_t code_value_ushort() { return (uint16_t)strtoul(seen_pointer + 1, NULL, 10); }
// 1512 
// 1513 inline uint8_t code_value_byte() { return (uint8_t)(constrain(strtol(seen_pointer + 1, NULL, 10), 0, 255)); }
// 1514 
// 1515 inline bool code_value_bool() { return !code_has_value() || code_value_byte() > 0; }
// 1516 
// 1517 #if ENABLED(INCH_MODE_SUPPORT)
// 1518   inline void set_input_linear_units(LinearUnit units) {
// 1519     switch (units) {
// 1520       case LINEARUNIT_INCH:
// 1521         linear_unit_factor = 25.4;
// 1522         break;
// 1523       case LINEARUNIT_MM:
// 1524       default:
// 1525         linear_unit_factor = 1.0;
// 1526         break;
// 1527     }
// 1528     volumetric_unit_factor = pow(linear_unit_factor, 3.0);
// 1529   }
// 1530 
// 1531   inline float axis_unit_factor(const AxisEnum axis) {
// 1532     return (axis >= E_AXIS && volumetric_enabled ? volumetric_unit_factor : linear_unit_factor);
// 1533   }
// 1534 
// 1535   inline float code_value_linear_units() { return code_value_float() * linear_unit_factor; }
// 1536   inline float code_value_axis_units(const AxisEnum axis) { return code_value_float() * axis_unit_factor(axis); }
// 1537   inline float code_value_per_axis_unit(const AxisEnum axis) { return code_value_float() / axis_unit_factor(axis); }
// 1538 #endif
// 1539 
// 1540 #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
// 1541   inline void set_input_temp_units(TempUnit units) { input_temp_units = units; }
// 1542   float to_temp_units(const float &c) {
// 1543     switch (input_temp_units) {
// 1544       case TEMPUNIT_F:
// 1545         return c * 0.5555555556 + 32.0;
// 1546       case TEMPUNIT_K:
// 1547         return c + 273.15;
// 1548       case TEMPUNIT_C:
// 1549       default:
// 1550         return c;
// 1551     }
// 1552   }
// 1553 
// 1554   int16_t code_value_temp_abs() {
// 1555 	const float c = code_value_float();
// 1556     switch (input_temp_units) {
// 1557       case TEMPUNIT_F:
// 1558 		  return (int16_t)((c - 32.0) * 0.5555555556);
// 1559       case TEMPUNIT_K:
// 1560 		  return (int16_t)(c - 273.15);
// 1561       case TEMPUNIT_C:
// 1562       default:
// 1563 		  return (int16_t)(c);
// 1564     }
// 1565   }
// 1566 
// 1567   int16_t code_value_temp_diff() {
// 1568     switch (input_temp_units) {
// 1569       case TEMPUNIT_F:
// 1570         return code_value_float() * 0.5555555556;
// 1571 		case TEMPUNIT_C:
// 1572 		case TEMPUNIT_K:
// 1573       default:
// 1574         return code_value_float();
// 1575     }
// 1576   }
// 1577 #else

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock22 Using cfiCommon0
          CFI Function _Z19code_value_temp_absv
        THUMB
// 1578   int16_t code_value_temp_abs() { return code_value_int(); }
_Z19code_value_temp_absv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _Z14code_value_intv
        BL       _Z14code_value_intv
        SXTH     R0,R0
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock22

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock23 Using cfiCommon0
          CFI Function _Z20code_value_temp_diffv
        THUMB
// 1579   int16_t code_value_temp_diff() { return code_value_int(); }
_Z20code_value_temp_diffv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _Z14code_value_intv
        BL       _Z14code_value_intv
        SXTH     R0,R0
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock23
// 1580 #endif
// 1581 
// 1582 FORCE_INLINE millis_t code_value_millis() { return code_value_ulong(); }
// 1583 inline millis_t code_value_millis_from_seconds() { return code_value_float() * 1000; }
// 1584 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock24 Using cfiCommon0
          CFI Function _Z9code_seenc
        THUMB
// 1585 bool code_seen(char code) {
_Z9code_seenc:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R1,R0
// 1586   seen_pointer = strchr(current_command_args, code);
        LDR.W    R4,??DataTable116_2
        LDR      R0,[R4, #+40]
          CFI FunCall __iar_Strchr
        BL       __iar_Strchr
        STR      R0,[R4, #+44]
// 1587   return (seen_pointer != NULL); // Return TRUE if the code-letter was found
        CMP      R0,#+0
        BEQ.N    ??code_seen_0
        MOVS     R0,#+1
        POP      {R4,PC}
??code_seen_0:
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
// 1588 }
          CFI EndBlock cfiBlock24
// 1589 
// 1590 /**
// 1591  * Set target_extruder from the T parameter or the active_extruder
// 1592  *
// 1593  * Returns TRUE if the target is invalid
// 1594  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock25 Using cfiCommon0
          CFI Function _Z32get_target_extruder_from_commandi
        THUMB
// 1595 bool get_target_extruder_from_command(int code) {
_Z32get_target_extruder_from_commandi:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
// 1596   if (code_seen('T')) {
        LDR.W    R5,??DataTable112_3
        MOVS     R0,#+84
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??get_target_extruder_from_command_0
// 1597     if (code_value_byte() >= EXTRUDERS) {
          CFI FunCall _Z15code_value_bytev
        BL       _Z15code_value_bytev
        CMP      R0,#+0
        BEQ.N    ??get_target_extruder_from_command_1
// 1598       SERIAL_ECHO_START;
        LDR.W    R0,??DataTable116_3
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 1599       SERIAL_CHAR('M');
        LDRB     R0,[R5, #+7]
        CMP      R0,#+0
        BNE.N    ??get_target_extruder_from_command_2
        MOVS     R1,#+77
        LDR.W    R0,??DataTable116_4
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??get_target_extruder_from_command_3
??get_target_extruder_from_command_2:
        MOVS     R2,#+0
        MOVS     R1,#+77
        LDR.W    R0,??DataTable116_5
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
// 1600       SERIAL_ECHO(code);
??get_target_extruder_from_command_3:
        LDRB     R0,[R5, #+7]
        CMP      R0,#+0
        BNE.N    ??get_target_extruder_from_command_4
        MOVS     R2,#+10
        MOV      R1,R4
        LDR.W    R0,??DataTable116_4
          CFI FunCall _ZN12MarlinSerial5printEii
        BL       _ZN12MarlinSerial5printEii
        B.N      ??get_target_extruder_from_command_5
??get_target_extruder_from_command_4:
        MOVS     R2,#+10
        MOV      R1,R4
        LDR.W    R0,??DataTable116_5
          CFI FunCall _ZN12MarlinSerial5printEii
        BL       _ZN12MarlinSerial5printEii
// 1601       SERIAL_ECHOLNPAIR(" " MSG_INVALID_EXTRUDER " ", code_value_byte());
??get_target_extruder_from_command_5:
          CFI FunCall _Z15code_value_bytev
        BL       _Z15code_value_bytev
        MOV      R1,R0
        ADR.W    R0,?_1
          CFI FunCall _Z17serial_echopair_PPKch
        BL       _Z17serial_echopair_PPKch
        LDRB     R0,[R5, #+7]
        CMP      R0,#+0
        BNE.N    ??get_target_extruder_from_command_6
        MOVS     R1,#+10
        LDR.W    R0,??DataTable116_4
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??get_target_extruder_from_command_7
??get_target_extruder_from_command_6:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.W    R0,??DataTable116_5
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
// 1602       return true;
??get_target_extruder_from_command_7:
        MOVS     R0,#+1
        POP      {R1,R4,R5,PC}
// 1603     }
// 1604     target_extruder = code_value_byte();
??get_target_extruder_from_command_1:
          CFI FunCall _Z15code_value_bytev
        BL       _Z15code_value_bytev
        STRB     R0,[R5, #+5]
        B.N      ??get_target_extruder_from_command_8
// 1605   }
// 1606   else
// 1607     target_extruder = active_extruder;
??get_target_extruder_from_command_0:
        LDRB     R0,[R5, #+2]
        STRB     R0,[R5, #+5]
// 1608 
// 1609   return false;
??get_target_extruder_from_command_8:
        MOVS     R0,#+0
        POP      {R1,R4,R5,PC}    ;; return
// 1610 }
          CFI EndBlock cfiBlock25

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_1:
        DC8 " Invalid extruder "
        DC8 0
// 1611 
// 1612 #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
// 1613   bool extruder_duplication_enabled = false; // Used in Dual X mode 2
// 1614 #endif
// 1615 
// 1616 #if ENABLED(DUAL_X_CARRIAGE)
// 1617 
// 1618   static DualXMode dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
// 1619 
// 1620   static float x_home_pos(const int extruder) {
// 1621     if (extruder == 0)
// 1622       return LOGICAL_X_POSITION(base_home_pos(X_AXIS));
// 1623     else
// 1624       /**
// 1625        * In dual carriage mode the extruder offset provides an override of the
// 1626        * second X-carriage position when homed - otherwise X2_HOME_POS is used.
// 1627        * This allows soft recalibration of the second extruder home position
// 1628        * without firmware reflash (through the M218 command).
// 1629        */
// 1630       return LOGICAL_X_POSITION(hotend_offset[X_AXIS][1] > 0 ? hotend_offset[X_AXIS][1] : X2_HOME_POS);
// 1631   }
// 1632 
// 1633   static int x_home_dir(const int extruder) { return extruder ? X2_HOME_DIR : X_HOME_DIR; }
// 1634 
// 1635   static float inactive_extruder_x_pos = X2_MAX_POS; // used in mode 0 & 1
// 1636   static bool active_extruder_parked = false;        // used in mode 1 & 2
// 1637   static float raised_parked_position[XYZE];         // used in mode 1
// 1638   static millis_t delayed_move_time = 0;             // used in mode 1
// 1639   static float duplicate_extruder_x_offset = DEFAULT_DUPLICATION_X_OFFSET; // used in mode 2
// 1640   static int16_t duplicate_extruder_temp_offset = 0; // used in mode 2
// 1641 
// 1642 #endif // DUAL_X_CARRIAGE
// 1643 
// 1644 #if HAS_WORKSPACE_OFFSET || ENABLED(DUAL_X_CARRIAGE)
// 1645 
// 1646   /**
// 1647    * Software endstops can be used to monitor the open end of
// 1648    * an axis that has a hardware endstop on the other end. Or
// 1649    * they can prevent axes from moving past endstops and grinding.
// 1650    *
// 1651    * To keep doing their job as the coordinate system changes,
// 1652    * the software endstop positions must be refreshed to remain
// 1653    * at the same positions relative to the machine.
// 1654    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock26 Using cfiCommon0
          CFI Function _Z24update_software_endstops8AxisEnum
        THUMB
// 1655   void update_software_endstops(const AxisEnum axis) {
_Z24update_software_endstops8AxisEnum:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOV      R4,R0
// 1656     const float offs = 0.0
// 1657       #if HAS_HOME_OFFSET
// 1658         + home_offset[axis]
// 1659       #endif
// 1660       #if HAS_POSITION_SHIFT
// 1661         + position_shift[axis]
// 1662       #endif
// 1663     ;
        LDR.W    R5,??DataTable112_3
        ADD      R6,R5,R0, LSL #+2
        LDR      R1,[R6, #+56]
        LDR.W    R2,??DataTable116_7
        ADD      R0,R2,R0, LSL #+2
        LDR      R0,[R0, #+60]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R7,R0
// 1664 
// 1665     #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
// 1666       workspace_offset[axis] = offs;
        STR      R7,[R6, #+68]
// 1667     #endif
// 1668 
// 1669     #if ENABLED(DUAL_X_CARRIAGE)
// 1670       if (axis == X_AXIS) {
// 1671 
// 1672         // In Dual X mode hotend_offset[X] is T1's home position
// 1673         float dual_max_x = max(hotend_offset[X_AXIS][1], X2_MAX_POS);
// 1674 
// 1675         if (active_extruder != 0) {
// 1676           // T1 can move from X2_MIN_POS to X2_MAX_POS or X2 home position (whichever is larger)
// 1677           soft_endstop_min[X_AXIS] = X2_MIN_POS + offs;
// 1678           soft_endstop_max[X_AXIS] = dual_max_x + offs;
// 1679         }
// 1680         else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE) {
// 1681           // In Duplication Mode, T0 can move as far left as X_MIN_POS
// 1682           // but not so far to the right that T1 would move past the end
// 1683           soft_endstop_min[X_AXIS] = base_min_pos(X_AXIS) + offs;
// 1684           soft_endstop_max[X_AXIS] = min(base_max_pos(X_AXIS), dual_max_x - duplicate_extruder_x_offset) + offs;
// 1685         }
// 1686         else {
// 1687           // In other modes, T0 can move from X_MIN_POS to X_MAX_POS
// 1688           soft_endstop_min[axis] = base_min_pos(axis) + offs;
// 1689           soft_endstop_max[axis] = base_max_pos(axis) + offs;
// 1690         }
// 1691       }
// 1692     #else
// 1693       soft_endstop_min[axis] = base_min_pos(axis) + offs;
        MOV      R0,R4
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531912base_min_posE8AxisEnum
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531912base_min_posE8AxisEnum
        MOV      R1,R7
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R6, #+80]
// 1694       soft_endstop_max[axis] = base_max_pos(axis) + offs;
        MOV      R0,R4
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531912base_max_posE8AxisEnum
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531912base_max_posE8AxisEnum
        MOV      R1,R7
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R6, #+92]
// 1695     #endif
// 1696 
// 1697     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1698       if (DEBUGGING(LEVELING)) {
// 1699         SERIAL_ECHOPAIR("For ", axis_codes[axis]);
// 1700         #if HAS_HOME_OFFSET
// 1701           SERIAL_ECHOPAIR(" axis:\n home_offset = ", home_offset[axis]);
// 1702         #endif
// 1703         #if HAS_POSITION_SHIFT
// 1704           SERIAL_ECHOPAIR("\n position_shift = ", position_shift[axis]);
// 1705         #endif
// 1706         SERIAL_ECHOPAIR("\n soft_endstop_min = ", soft_endstop_min[axis]);
// 1707         SERIAL_ECHOLNPAIR("\n soft_endstop_max = ", soft_endstop_max[axis]);
// 1708       }
// 1709     #endif
// 1710 
// 1711 //    #if ENABLED(DELTA)
// 1712 	if(MACHINETPYE == DELTA)
        LDR.W    R0,??DataTable113_4
        LDRSH    R0,[R0, #+88]
        CMP      R0,#+2
        BNE.N    ??update_software_endstops_0
// 1713       if (axis == Z_AXIS)
        CMP      R4,#+2
        BNE.N    ??update_software_endstops_0
// 1714         delta_clip_start_height = soft_endstop_max[axis] - delta_safe_distance_from_top();
          CFI FunCall _Z28delta_safe_distance_from_topv
        BL       _Z28delta_safe_distance_from_topv
        MOV      R1,R0
        LDR      R0,[R5, #+100]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R5, #+128]
// 1715   //  #endif
// 1716   }
??update_software_endstops_0:
        POP      {R0,R4-R7,PC}    ;; return
          CFI EndBlock cfiBlock26
// 1717 
// 1718 #endif // HAS_WORKSPACE_OFFSET || DUAL_X_CARRIAGE
// 1719 
// 1720 //#if HAS_M206_COMMAND	//mks_delta
// 1721 #if 1
// 1722   /**
// 1723    * Change the home offset for an axis, update the current
// 1724    * position and the software endstops to retain the same
// 1725    * relative distance to the new home.
// 1726    *
// 1727    * Since this changes the current_position, code should
// 1728    * call sync_plan_position soon after this.
// 1729    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock27 Using cfiCommon0
          CFI Function _ZN37_INTERNAL_15_Marlin_main_cpp_3178531915set_home_offsetE8AxisEnumf
        THUMB
// 1730   static void set_home_offset(const AxisEnum axis, const float v) {
_ZN37_INTERNAL_15_Marlin_main_cpp_3178531915set_home_offsetE8AxisEnumf:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R4,R0
        MOV      R5,R1
// 1731   if(MACHINETPYE == DELTA)	return;
        LDR.W    R0,??DataTable113_4
        LDRSH    R0,[R0, #+88]
        CMP      R0,#+2
        BEQ.N    ??set_home_offset_0
// 1732   	
// 1733     current_position[axis] += v - home_offset[axis];
        LDR.W    R0,??DataTable112_3
        MOV      R1,R4
        ADD      R6,R0,R1, LSL #+2
        MOV      R0,R5
        LDR      R1,[R6, #+56]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[R6, #+8]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R6, #+8]
// 1734     home_offset[axis] = v;
        STR      R5,[R6, #+56]
// 1735     update_software_endstops(axis);
        MOV      R0,R4
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z24update_software_endstops8AxisEnum
        B.N      _Z24update_software_endstops8AxisEnum
          CFI R4 Frame(CFA, -16)
          CFI R5 Frame(CFA, -12)
          CFI R6 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??set_home_offset_0:
        POP      {R4-R6,PC}       ;; return
// 1736   }
          CFI EndBlock cfiBlock27
// 1737 #endif // HAS_M206_COMMAND
// 1738 
// 1739 /**
// 1740  * Set an axis' current position to its home position (after homing).
// 1741  *
// 1742  * For Core and Cartesian robots this applies one-to-one when an
// 1743  * individual axis has been homed.
// 1744  *
// 1745  * DELTA should wait until all homing is done before setting the XYZ
// 1746  * current_position to home, because homing is a single operation.
// 1747  * In the case where the axis positions are already known and previously
// 1748  * homed, DELTA could home to X or Y individually by moving either one
// 1749  * to the center. However, homing Z always homes XY and Z.
// 1750  *
// 1751  * SCARA should wait until all XY homing is done before setting the XY
// 1752  * current_position to home, because neither X nor Y is at home until
// 1753  * both are at home. Z can however be homed individually.
// 1754  *
// 1755  * Callers must sync the planner position after calling this!
// 1756  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock28 Using cfiCommon0
          CFI Function _ZN37_INTERNAL_15_Marlin_main_cpp_3178531919set_axis_is_at_homeE8AxisEnum
        THUMB
// 1757 static void set_axis_is_at_home(AxisEnum axis) {
_ZN37_INTERNAL_15_Marlin_main_cpp_3178531919set_axis_is_at_homeE8AxisEnum:
        PUSH     {R0-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+48
        MOV      R4,R0
// 1758   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1759     if (DEBUGGING(LEVELING)) {
// 1760       SERIAL_ECHOPAIR(">>> set_axis_is_at_home(", axis_codes[axis]);
// 1761       SERIAL_CHAR(')');
// 1762       SERIAL_EOL;
// 1763     }
// 1764   #endif
// 1765 
// 1766   axis_known_position[axis] = axis_homed[axis] = true;
        MOV      R8,R4
        LDR.W    R5,??DataTable116_7
        MOVS     R0,#+1
        STRB     R0,[R5, R8]
        LDR.W    R1,??DataTable116_2
        ADD      R1,R1,R8
        STRB     R0,[R1, #+4]
// 1767 
// 1768   #if HAS_POSITION_SHIFT
// 1769     position_shift[axis] = 0;
        ADD      R9,R5,R8, LSL #+2
        MOVS     R0,#+0
        STR      R0,[R9, #+60]
// 1770     update_software_endstops(axis);
        MOV      R0,R4
          CFI FunCall _Z24update_software_endstops8AxisEnum
        BL       _Z24update_software_endstops8AxisEnum
// 1771   #endif
// 1772 
// 1773   #if ENABLED(DUAL_X_CARRIAGE)
// 1774     if (axis == X_AXIS && (active_extruder == 1 || dual_x_carriage_mode == DXC_DUPLICATION_MODE)) {
// 1775       current_position[X_AXIS] = x_home_pos(active_extruder);
// 1776       return;
// 1777     }
// 1778   #endif
// 1779 
// 1780   //#if ENABLED(MORGAN_SCARA)
// 1781   if(MACHINETPYE&MORGAN_SCARA)
        LDR.W    R6,??DataTable112_3
        LDR.W    R7,??DataTable113_4
        LDRH     R0,[R7, #+88]
        LSLS     R0,R0,#+23
        BPL.N    ??set_axis_is_at_home_0
// 1782   	{
// 1783     /**
// 1784      * Morgan SCARA homes XY at the same time
// 1785      */
// 1786     if (axis == X_AXIS || axis == Y_AXIS) {
        MOVS     R0,R4
        BEQ.N    ??set_axis_is_at_home_1
        CMP      R0,#+1
        BNE.N    ??set_axis_is_at_home_2
// 1787 
// 1788       float homeposition[XYZ];
// 1789       LOOP_XYZ(i) homeposition[i] = LOGICAL_POSITION(base_home_pos((AxisEnum)i), i);
??set_axis_is_at_home_1:
        MOV      R10,#+0
        B.N      ??set_axis_is_at_home_3
??set_axis_is_at_home_4:
        MOV      R0,R10
        SXTB     R0,R0
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531913base_home_posE8AxisEnum
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531913base_home_posE8AxisEnum
        ADD      R1,R6,#+68
        LDR      R1,[R1, R10, LSL #+2]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,SP
        STR      R0,[R1, R10, LSL #+2]
        ADD      R10,R10,#+1
??set_axis_is_at_home_3:
        CMP      R10,#+3
        BLT.N    ??set_axis_is_at_home_4
// 1790 
// 1791       // SERIAL_ECHOPAIR("homeposition X:", homeposition[X_AXIS]);
// 1792       // SERIAL_ECHOLNPAIR(" Y:", homeposition[Y_AXIS]);
// 1793 
// 1794       /**
// 1795        * Get Home position SCARA arm angles using inverse kinematics,
// 1796        * and calculate homing offset using forward kinematics
// 1797        */
// 1798       inverse_kinematics_MORGAN_SCARA(homeposition);
        MOV      R0,SP
          CFI FunCall _Z31inverse_kinematics_MORGAN_SCARAPKf
        BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
// 1799       forward_kinematics_SCARA(delta[A_AXIS], delta[B_AXIS]);
        ADD      R1,R6,#+108
        ADD      R0,R6,#+104
          CFI FunCall _Z24forward_kinematics_SCARARKfS0_
        BL       _Z24forward_kinematics_SCARARKfS0_
// 1800 
// 1801       // SERIAL_ECHOPAIR("Cartesian X:", cartes[X_AXIS]);
// 1802       // SERIAL_ECHOLNPAIR(" Y:", cartes[Y_AXIS]);
// 1803 
// 1804       current_position[axis] = LOGICAL_POSITION(cartes[axis], axis);
        ADD      R8,R6,R8, LSL #+2
        LDR      R1,[R9, #+40]
        LDR      R0,[R8, #+68]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R8, #+8]
// 1805 
// 1806       /**
// 1807        * SCARA home positions are based on configuration since the actual
// 1808        * limits are determined by the inverse kinematic transform.
// 1809        */
// 1810       soft_endstop_min[axis] = base_min_pos(axis); // + (cartes[axis] - base_home_pos(axis));
        MOV      R0,R4
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531912base_min_posE8AxisEnum
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531912base_min_posE8AxisEnum
        STR      R0,[R8, #+80]
// 1811       soft_endstop_max[axis] = base_max_pos(axis); // + (cartes[axis] - base_home_pos(axis));
        MOV      R0,R4
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531912base_max_posE8AxisEnum
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531912base_max_posE8AxisEnum
        STR      R0,[R8, #+92]
        B.N      ??set_axis_is_at_home_5
// 1812     }
// 1813     else
// 1814   //#endif
// 1815   {
// 1816     current_position[axis] = LOGICAL_POSITION(base_home_pos(axis), axis);
??set_axis_is_at_home_2:
        ADD      R8,R6,R8, LSL #+2
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531913base_home_posE8AxisEnum
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531913base_home_posE8AxisEnum
        LDR      R1,[R8, #+68]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R8, #+8]
        B.N      ??set_axis_is_at_home_5
// 1817   }
// 1818   	}
// 1819   else
// 1820   	{
// 1821   	current_position[axis] = LOGICAL_POSITION(base_home_pos(axis), axis);
??set_axis_is_at_home_0:
        ADD      R8,R6,R8, LSL #+2
        MOV      R0,R4
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531913base_home_posE8AxisEnum
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531913base_home_posE8AxisEnum
        LDR      R1,[R8, #+68]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R8, #+8]
// 1822   	}
// 1823   /**
// 1824    * Z Probe Z Homing? Account for the probe's Z offset.
// 1825    */
// 1826   //#if HAS_BED_PROBE && Z_HOME_DIR < 0	/*--mks cfg--*/
// 1827   #if HAS_BED_PROBE
// 1828   if(Z_HOME_DIR < 0){
??set_axis_is_at_home_5:
        LDRSB    R0,[R7, #+6]
        CMP      R0,#+0
        BPL.N    ??set_axis_is_at_home_6
// 1829     if (axis == Z_AXIS) {
        CMP      R4,#+2
        BNE.N    ??set_axis_is_at_home_6
// 1830   //#define HOMING_Z_WITH_PROBE (HAS_BED_PROBE && Z_HOME_DIR < 0 && ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))		
// 1831       #if HOMING_Z_WITH_PROBE
// 1832 	  	if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
        LDRB     R0,[R7, #+153]
        CMP      R0,#+1
        BNE.N    ??set_axis_is_at_home_7
// 1833       	{
// 1834         current_position[Z_AXIS] -= zprobe_zoffset;
        LDR      R0,[R6, #+16]
        LDR      R1,[R5, #+72]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R6, #+16]
        B.N      ??set_axis_is_at_home_6
// 1835 
// 1836         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1837           if (DEBUGGING(LEVELING)) {
// 1838             SERIAL_ECHOLNPGM("*** Z HOMED WITH PROBE (Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) ***");
// 1839             SERIAL_ECHOLNPAIR("> zprobe_zoffset = ", zprobe_zoffset);
// 1840           }
// 1841         #endif
// 1842       	}
// 1843 		else
// 1844 			{
// 1845 			if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("*** Z HOMED TO ENDSTOP (Z_MIN_PROBE_ENDSTOP) ***");
??set_axis_is_at_home_7:
        LDRB     R0,[R6, #+1]
        LSLS     R0,R0,#+26
        BPL.N    ??set_axis_is_at_home_6
        ADR.W    R0,?_2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 1846 			}
// 1847       #elif ENABLED(DEBUG_LEVELING_FEATURE)
// 1848 
// 1849         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("*** Z HOMED TO ENDSTOP (Z_MIN_PROBE_ENDSTOP) ***");
// 1850 
// 1851       #endif
// 1852     }
// 1853   	}
// 1854   #endif
// 1855 
// 1856   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1857     if (DEBUGGING(LEVELING)) {
// 1858       #if HAS_HOME_OFFSET
// 1859         SERIAL_ECHOPAIR("> home_offset[", axis_codes[axis]);
// 1860         SERIAL_ECHOLNPAIR("] = ", home_offset[axis]);
// 1861       #endif
// 1862       DEBUG_POS("", current_position);
// 1863       SERIAL_ECHOPAIR("<<< set_axis_is_at_home(", axis_codes[axis]);
// 1864       SERIAL_CHAR(')');
// 1865       SERIAL_EOL;
// 1866     }
// 1867   #endif
// 1868 }
??set_axis_is_at_home_6:
        POP      {R0-R10,PC}      ;; return
          CFI EndBlock cfiBlock28

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_2:
        DC8 "*** Z HOMED TO ENDSTOP (Z_MIN_PROBE_ENDSTOP) ***\012"
        DC8 0, 0
// 1869 
// 1870 /**
// 1871  * Some planner shorthand inline functions
// 1872  */
// 1873 inline float get_homing_bump_feedrate(AxisEnum axis) {
// 1874 //  int constexpr homing_bump_divisor[] = HOMING_BUMP_DIVISOR;
// 1875 	int  homing_bump_divisor[4];
// 1876 	if(MACHINETPYE == DELTA)
// 1877 	{
// 1878 	homing_bump_divisor[0] = 10;
// 1879 	homing_bump_divisor[1] = 10;
// 1880 	homing_bump_divisor[2] = 10;
// 1881 	}
// 1882 	else
// 1883 	{
// 1884 	homing_bump_divisor[0] = 2;
// 1885 	homing_bump_divisor[1] = 2;
// 1886 	homing_bump_divisor[2] = 4;
// 1887 	}
// 1888 
// 1889   int hbd = homing_bump_divisor[axis];
// 1890   if (hbd < 1) {
// 1891     hbd = 10;
// 1892     SERIAL_ECHO_START;
// 1893     SERIAL_ECHOLNPGM("Warning: Homing Bump Divisor < 1");
// 1894   }
// 1895   return homing_feedrate_mm_s[axis] / hbd;
// 1896 }
// 1897 
// 1898 //
// 1899 // line_to_current_position
// 1900 // Move the planner to the current position from wherever it last moved
// 1901 // (or from wherever it has been told it is located).
// 1902 //
// 1903 inline void line_to_current_position() {
// 1904   planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], feedrate_mm_s, active_extruder);
// 1905 }
// 1906 
// 1907 //
// 1908 // line_to_destination
// 1909 // Move the planner, not necessarily synced with current_position
// 1910 //
// 1911 inline void line_to_destination(float fr_mm_s) {
// 1912   planner.buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], fr_mm_s, active_extruder);
// 1913 }
// 1914 inline void line_to_destination() { line_to_destination(feedrate_mm_s); }
// 1915 
// 1916 inline void set_current_to_destination() { COPY(current_position, destination); }
// 1917 inline void set_destination_to_current() { COPY(destination, current_position); }
// 1918 
// 1919 //#if IS_KINEMATIC	//mks_delta
// 1920 #if 1
// 1921   /**
// 1922    * Calculate delta, start a line, and set current_position to destination
// 1923    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock29 Using cfiCommon0
          CFI Function _Z42prepare_uninterpolated_move_to_destinationf
        THUMB
// 1924   void prepare_uninterpolated_move_to_destination(const float fr_mm_s=0.0) {
_Z42prepare_uninterpolated_move_to_destinationf:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
// 1925     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1926       if (DEBUGGING(LEVELING)) DEBUG_POS("prepare_uninterpolated_move_to_destination", destination);
// 1927     #endif
// 1928 
// 1929     if ( current_position[X_AXIS] == destination[X_AXIS]
// 1930       && current_position[Y_AXIS] == destination[Y_AXIS]
// 1931       && current_position[Z_AXIS] == destination[Z_AXIS]
// 1932       && current_position[E_AXIS] == destination[E_AXIS]
// 1933     ) return;
        LDR.W    R5,??DataTable112_3
        LDR      R0,[R5, #+8]
        LDR      R1,[R5, #+24]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??prepare_uninterpolated_move_to_destination_0
        LDR      R0,[R5, #+12]
        LDR      R1,[R5, #+28]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??prepare_uninterpolated_move_to_destination_0
        LDR      R0,[R5, #+16]
        LDR      R1,[R5, #+32]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??prepare_uninterpolated_move_to_destination_0
        LDR      R0,[R5, #+20]
        LDR      R1,[R5, #+36]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??prepare_uninterpolated_move_to_destination_1
// 1934 
// 1935     refresh_cmd_timeout();
??prepare_uninterpolated_move_to_destination_0:
          CFI FunCall _Z19refresh_cmd_timeoutv
        BL       _Z19refresh_cmd_timeoutv
// 1936     planner.buffer_line_kinematic(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s), active_extruder);
        MOV      R0,R4
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??prepare_uninterpolated_move_to_destination_2
        LDR      R4,[R5, #+116]
??prepare_uninterpolated_move_to_destination_2:
        LDR      R0,[R5, #+120]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable120  ;; 0x47ae147b
        LDR.W    R3,??DataTable121  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+0]
        LDRB     R2,[R5, #+2]
        MOV      R1,SP
        ADD      R0,R5,#+24
          CFI FunCall _ZN7Planner21buffer_line_kinematicEPKfRS0_h
        BL       _ZN7Planner21buffer_line_kinematicEPKfRS0_h
// 1937     set_current_to_destination();
          CFI FunCall _Z26set_current_to_destinationv
        BL       _Z26set_current_to_destinationv
// 1938   }
??prepare_uninterpolated_move_to_destination_1:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock29
// 1939 #endif // IS_KINEMATIC
// 1940 
// 1941 /**
// 1942  *  Plan a move to (X, Y, Z) and set the current_position
// 1943  *  The final current_position may not be the one that was requested
// 1944  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock30 Using cfiCommon0
          CFI Function _Z19do_blocking_move_toRKfS0_S0_S0_
        THUMB
// 1945 void do_blocking_move_to(const float &x, const float &y, const float &z, const float &fr_mm_s /*=0.0*/) {
_Z19do_blocking_move_toRKfS0_S0_S0_:
        PUSH     {R3-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+32
        MOV      R6,R0
        MOV      R7,R1
        MOV      R8,R2
        MOV      R9,R3
// 1946   const float old_feedrate_mm_s = feedrate_mm_s;
        LDR.W    R4,??DataTable112_3
        LDR      R5,[R4, #+116]
// 1947 
// 1948   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1949     if (DEBUGGING(LEVELING)) print_xyz(PSTR(">>> do_blocking_move_to"), NULL, x, y, z);
// 1950   #endif
// 1951 
// 1952   //#if ENABLED(DELTA)	//mks_delta
// 1953   if(MACHINETPYE == DELTA) {
        LDR.W    R0,??DataTable113_4
        LDRSH    R0,[R0, #+88]
        CMP      R0,#+2
        BNE.N    ??do_blocking_move_to_0
// 1954 	
// 1955     feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
        LDR      R2,[R9, #+0]
        MOV      R0,R2
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??do_blocking_move_to_1
        STR      R2,[R4, #+116]
        B.N      ??do_blocking_move_to_2
??do_blocking_move_to_1:
        LDR      R0,[R4, #+124]
        STR      R0,[R4, #+116]
// 1956 
// 1957     set_destination_to_current();          // sync destination at the start
??do_blocking_move_to_2:
          CFI FunCall _Z26set_destination_to_currentv
        BL       _Z26set_destination_to_currentv
// 1958 
// 1959     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1960       if (DEBUGGING(LEVELING)) DEBUG_POS("set_destination_to_current", destination);
// 1961     #endif
// 1962 
// 1963     // when in the danger zone
// 1964     if (current_position[Z_AXIS] > delta_clip_start_height) {
        LDR      R0,[R4, #+128]
        LDR      R1,[R4, #+16]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_blocking_move_to_3
// 1965       if (z > delta_clip_start_height) {   // staying in the danger zone
        LDR      R1,[R8, #+0]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_blocking_move_to_4
// 1966         destination[X_AXIS] = x;           // move directly (uninterpolated)
        LDR      R0,[R6, #+0]
        STR      R0,[R4, #+24]
// 1967         destination[Y_AXIS] = y;
        LDR      R0,[R7, #+0]
        STR      R0,[R4, #+28]
// 1968         destination[Z_AXIS] = z;
        LDR      R0,[R8, #+0]
        STR      R0,[R4, #+32]
// 1969         prepare_uninterpolated_move_to_destination(); // set_current_to_destination
        MOVS     R0,#+0
        POP      {R1,R4-R9,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z42prepare_uninterpolated_move_to_destinationf
        B.N      _Z42prepare_uninterpolated_move_to_destinationf
          CFI R4 Frame(CFA, -28)
          CFI R5 Frame(CFA, -24)
          CFI R6 Frame(CFA, -20)
          CFI R7 Frame(CFA, -16)
          CFI R8 Frame(CFA, -12)
          CFI R9 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
// 1970         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1971           if (DEBUGGING(LEVELING)) DEBUG_POS("danger zone move", current_position);
// 1972         #endif
// 1973         return;
// 1974       }
// 1975       else {
// 1976         destination[Z_AXIS] = delta_clip_start_height;
??do_blocking_move_to_4:
        STR      R0,[R4, #+32]
// 1977         prepare_uninterpolated_move_to_destination(); // set_current_to_destination
        MOVS     R0,#+0
          CFI FunCall _Z42prepare_uninterpolated_move_to_destinationf
        BL       _Z42prepare_uninterpolated_move_to_destinationf
// 1978         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1979           if (DEBUGGING(LEVELING)) DEBUG_POS("zone border move", current_position);
// 1980         #endif
// 1981       }
// 1982     }
// 1983 
// 1984     if (z > current_position[Z_AXIS]) {    // raising?
??do_blocking_move_to_3:
        LDR      R1,[R8, #+0]
        LDR      R0,[R4, #+16]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_blocking_move_to_5
// 1985       destination[Z_AXIS] = z;
        STR      R1,[R4, #+32]
// 1986       prepare_uninterpolated_move_to_destination();   // set_current_to_destination
        MOVS     R0,#+0
          CFI FunCall _Z42prepare_uninterpolated_move_to_destinationf
        BL       _Z42prepare_uninterpolated_move_to_destinationf
// 1987       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1988         if (DEBUGGING(LEVELING)) DEBUG_POS("z raise move", current_position);
// 1989       #endif
// 1990     }
// 1991 
// 1992     destination[X_AXIS] = x;
??do_blocking_move_to_5:
        LDR      R0,[R6, #+0]
        STR      R0,[R4, #+24]
// 1993     destination[Y_AXIS] = y;
        LDR      R0,[R7, #+0]
        STR      R0,[R4, #+28]
// 1994     prepare_move_to_destination();         // set_current_to_destination
          CFI FunCall _Z27prepare_move_to_destinationv
        BL       _Z27prepare_move_to_destinationv
// 1995     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1996       if (DEBUGGING(LEVELING)) DEBUG_POS("xy move", current_position);
// 1997     #endif
// 1998 
// 1999     if (z < current_position[Z_AXIS]) {    // lowering?
        LDR      R0,[R8, #+0]
        LDR      R1,[R4, #+16]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_blocking_move_to_6
// 2000       destination[Z_AXIS] = z;
        STR      R0,[R4, #+32]
// 2001       prepare_uninterpolated_move_to_destination();   // set_current_to_destination
        MOVS     R0,#+0
          CFI FunCall _Z42prepare_uninterpolated_move_to_destinationf
        BL       _Z42prepare_uninterpolated_move_to_destinationf
        B.N      ??do_blocking_move_to_6
// 2002       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2003         if (DEBUGGING(LEVELING)) DEBUG_POS("z lower move", current_position);
// 2004       #endif
// 2005     }
// 2006   	}
// 2007   //#elif IS_SCARA
// 2008 	else if(MACHINETPYE&IS_SCARA) {
??do_blocking_move_to_0:
        TST      R0,#0x300
        BEQ.N    ??do_blocking_move_to_7
// 2009     set_destination_to_current();
          CFI FunCall _Z26set_destination_to_currentv
        BL       _Z26set_destination_to_currentv
// 2010 
// 2011     // If Z needs to raise, do it before moving XY
// 2012     if (destination[Z_AXIS] < z) {
        LDR      R1,[R8, #+0]
        LDR      R0,[R4, #+32]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_blocking_move_to_8
// 2013       destination[Z_AXIS] = z;
        STR      R1,[R4, #+32]
// 2014       prepare_uninterpolated_move_to_destination(fr_mm_s ? fr_mm_s : homing_feedrate_mm_s[Z_AXIS]);
        LDR      R2,[R9, #+0]
        MOV      R0,R2
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??do_blocking_move_to_9
        LDR      R2,[R4, #+48]
??do_blocking_move_to_9:
        MOV      R0,R2
          CFI FunCall _Z42prepare_uninterpolated_move_to_destinationf
        BL       _Z42prepare_uninterpolated_move_to_destinationf
// 2015     }
// 2016 
// 2017     destination[X_AXIS] = x;
??do_blocking_move_to_8:
        LDR      R0,[R6, #+0]
        STR      R0,[R4, #+24]
// 2018     destination[Y_AXIS] = y;
        LDR      R0,[R7, #+0]
        STR      R0,[R4, #+28]
// 2019     prepare_uninterpolated_move_to_destination(fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S);
        LDR      R2,[R9, #+0]
        MOV      R0,R2
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??do_blocking_move_to_10
        LDR      R2,[R4, #+124]
??do_blocking_move_to_10:
        MOV      R0,R2
          CFI FunCall _Z42prepare_uninterpolated_move_to_destinationf
        BL       _Z42prepare_uninterpolated_move_to_destinationf
// 2020 
// 2021     // If Z needs to lower, do it after moving XY
// 2022     if (destination[Z_AXIS] > z) {
        LDR      R0,[R8, #+0]
        LDR      R1,[R4, #+32]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_blocking_move_to_6
// 2023       destination[Z_AXIS] = z;
        STR      R0,[R4, #+32]
// 2024       prepare_uninterpolated_move_to_destination(fr_mm_s ? fr_mm_s : homing_feedrate_mm_s[Z_AXIS]);
        LDR      R2,[R9, #+0]
        MOV      R0,R2
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??do_blocking_move_to_11
        LDR      R2,[R4, #+48]
??do_blocking_move_to_11:
        MOV      R0,R2
          CFI FunCall _Z42prepare_uninterpolated_move_to_destinationf
        BL       _Z42prepare_uninterpolated_move_to_destinationf
        B.N      ??do_blocking_move_to_6
// 2025     }
// 2026 		}
// 2027   //#else
// 2028 	else {
// 2029     // If Z needs to raise, do it before moving XY
// 2030     if (current_position[Z_AXIS] < z) {
??do_blocking_move_to_7:
        LDR      R0,[R4, #+16]
        LDR      R1,[R8, #+0]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_blocking_move_to_12
// 2031       feedrate_mm_s = fr_mm_s ? fr_mm_s : homing_feedrate_mm_s[Z_AXIS];
        LDR      R2,[R9, #+0]
        MOV      R0,R2
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??do_blocking_move_to_13
        STR      R2,[R4, #+116]
        B.N      ??do_blocking_move_to_14
??do_blocking_move_to_13:
        LDR      R0,[R4, #+48]
        STR      R0,[R4, #+116]
// 2032       current_position[Z_AXIS] = z;
??do_blocking_move_to_14:
        LDR      R0,[R8, #+0]
        STR      R0,[R4, #+16]
// 2033       line_to_current_position();
          CFI FunCall _Z24line_to_current_positionv
        BL       _Z24line_to_current_positionv
// 2034     }
// 2035 
// 2036     feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
??do_blocking_move_to_12:
        LDR      R2,[R9, #+0]
        MOV      R0,R2
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??do_blocking_move_to_15
        STR      R2,[R4, #+116]
        B.N      ??do_blocking_move_to_16
??do_blocking_move_to_15:
        LDR      R0,[R4, #+124]
        STR      R0,[R4, #+116]
// 2037     current_position[X_AXIS] = x;
??do_blocking_move_to_16:
        LDR      R0,[R6, #+0]
        STR      R0,[R4, #+8]
// 2038     current_position[Y_AXIS] = y;
        LDR      R0,[R7, #+0]
        STR      R0,[R4, #+12]
// 2039     line_to_current_position();
          CFI FunCall _Z24line_to_current_positionv
        BL       _Z24line_to_current_positionv
// 2040 
// 2041     // If Z needs to lower, do it after moving XY
// 2042     if (current_position[Z_AXIS] > z) {
        LDR      R0,[R8, #+0]
        LDR      R1,[R4, #+16]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_blocking_move_to_6
// 2043       feedrate_mm_s = fr_mm_s ? fr_mm_s : homing_feedrate_mm_s[Z_AXIS];
        LDR      R2,[R9, #+0]
        MOV      R0,R2
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??do_blocking_move_to_17
        STR      R2,[R4, #+116]
        B.N      ??do_blocking_move_to_18
??do_blocking_move_to_17:
        LDR      R0,[R4, #+48]
        STR      R0,[R4, #+116]
// 2044       current_position[Z_AXIS] = z;
??do_blocking_move_to_18:
        LDR      R0,[R8, #+0]
        STR      R0,[R4, #+16]
// 2045       line_to_current_position();
          CFI FunCall _Z24line_to_current_positionv
        BL       _Z24line_to_current_positionv
// 2046     }
// 2047 		}
// 2048   //#endif
// 2049 
// 2050   stepper.synchronize();
??do_blocking_move_to_6:
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
// 2051 
// 2052   feedrate_mm_s = old_feedrate_mm_s;
        STR      R5,[R4, #+116]
// 2053 
// 2054   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2055     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< do_blocking_move_to");
// 2056   #endif
// 2057 }
        POP      {R0,R4-R9,PC}    ;; return
          CFI EndBlock cfiBlock30

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock31 Using cfiCommon0
          CFI Function _Z21do_blocking_move_to_xRKfS0_
        THUMB
// 2058 void do_blocking_move_to_x(const float &x, const float &fr_mm_s/*=0.0*/) {
_Z21do_blocking_move_to_xRKfS0_:
        MOV      R3,R1
// 2059   do_blocking_move_to(x, current_position[Y_AXIS], current_position[Z_AXIS], fr_mm_s);
        LDR.N    R1,??DataTable112_3
        ADD      R2,R1,#+16
        ADDS     R1,R1,#+12
          CFI FunCall _Z19do_blocking_move_toRKfS0_S0_S0_
        B.N      _Z19do_blocking_move_toRKfS0_S0_S0_
// 2060 }
          CFI EndBlock cfiBlock31

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock32 Using cfiCommon0
          CFI Function _Z21do_blocking_move_to_zRKfS0_
        THUMB
// 2061 void do_blocking_move_to_z(const float &z, const float &fr_mm_s/*=0.0*/) {
_Z21do_blocking_move_to_zRKfS0_:
        MOV      R2,R0
        MOV      R3,R1
// 2062   do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], z, fr_mm_s);
        LDR.N    R0,??DataTable112_3
        ADD      R1,R0,#+12
        ADDS     R0,R0,#+8
          CFI FunCall _Z19do_blocking_move_toRKfS0_S0_S0_
        B.N      _Z19do_blocking_move_toRKfS0_S0_S0_
// 2063 }
          CFI EndBlock cfiBlock32

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock33 Using cfiCommon0
          CFI Function _Z22do_blocking_move_to_xyRKfS0_S0_
        THUMB
// 2064 void do_blocking_move_to_xy(const float &x, const float &y, const float &fr_mm_s/*=0.0*/) {
_Z22do_blocking_move_to_xyRKfS0_S0_:
        MOV      R3,R2
// 2065   do_blocking_move_to(x, y, current_position[Z_AXIS], fr_mm_s);
        LDR.W    R2,??DataTable123
          CFI FunCall _Z19do_blocking_move_toRKfS0_S0_S0_
        B.N      _Z19do_blocking_move_toRKfS0_S0_S0_
// 2066 }
          CFI EndBlock cfiBlock33
// 2067 
// 2068 //
// 2069 // Prepare to do endstop or probe moves
// 2070 // with custom feedrates.
// 2071 //
// 2072 //  - Save current feedrates
// 2073 //  - Reset the rate multiplier
// 2074 //  - Reset the command timeout
// 2075 //  - Enable the endstops (for endstop moves)
// 2076 //

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock34 Using cfiCommon0
          CFI Function _ZN37_INTERNAL_15_Marlin_main_cpp_3178531931setup_for_endstop_or_probe_moveEv
        THUMB
// 2077 static void setup_for_endstop_or_probe_move() {
// 2078   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2079     if (DEBUGGING(LEVELING)) DEBUG_POS("setup_for_endstop_or_probe_move", current_position);
// 2080   #endif
// 2081   saved_feedrate_mm_s = feedrate_mm_s;
_ZN37_INTERNAL_15_Marlin_main_cpp_3178531931setup_for_endstop_or_probe_moveEv:
        LDR.W    R0,??DataTable122
        LDR.N    R1,??DataTable112_3
        LDR      R2,[R1, #+116]
        STR      R2,[R0, #+0]
// 2082   saved_feedrate_percentage = feedrate_percentage;
        LDR      R2,[R1, #+120]
        STR      R2,[R0, #+4]
// 2083   feedrate_percentage = 100;
        MOVS     R0,#+100
        STR      R0,[R1, #+120]
// 2084   refresh_cmd_timeout();
          CFI FunCall _Z19refresh_cmd_timeoutv
        B.W      _Z19refresh_cmd_timeoutv
// 2085 }
          CFI EndBlock cfiBlock34
// 2086 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock35 Using cfiCommon0
          CFI Function _ZN37_INTERNAL_15_Marlin_main_cpp_3178531936clean_up_after_endstop_or_probe_moveEv
        THUMB
// 2087 static void clean_up_after_endstop_or_probe_move() {
// 2088   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2089     if (DEBUGGING(LEVELING)) DEBUG_POS("clean_up_after_endstop_or_probe_move", current_position);
// 2090   #endif
// 2091   feedrate_mm_s = saved_feedrate_mm_s;
_ZN37_INTERNAL_15_Marlin_main_cpp_3178531936clean_up_after_endstop_or_probe_moveEv:
        LDR.N    R0,??DataTable112_3
        LDR.W    R1,??DataTable122
        LDR      R2,[R1, #+0]
        STR      R2,[R0, #+116]
// 2092   feedrate_percentage = saved_feedrate_percentage;
        LDR      R1,[R1, #+4]
        STR      R1,[R0, #+120]
// 2093   refresh_cmd_timeout();
          CFI FunCall _Z19refresh_cmd_timeoutv
        B.W      _Z19refresh_cmd_timeoutv
// 2094 }
          CFI EndBlock cfiBlock35
// 2095 
// 2096 #if HAS_BED_PROBE
// 2097   /**
// 2098    * Raise Z to a minimum height to make room for a probe to move
// 2099    */
// 2100   inline void do_probe_raise(float z_raise) {
// 2101     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2102       if (DEBUGGING(LEVELING)) {
// 2103         SERIAL_ECHOPAIR("do_probe_raise(", z_raise);
// 2104         SERIAL_CHAR(')');
// 2105         SERIAL_EOL;
// 2106       }
// 2107     #endif
// 2108 
// 2109     float z_dest = LOGICAL_Z_POSITION(z_raise);
// 2110     if (zprobe_zoffset < 0) z_dest -= zprobe_zoffset;
// 2111 //    #if ENABLED(DELTA)
// 2112 	  if(MACHINETPYE == DELTA)
// 2113 	      z_dest -= home_offset[Z_AXIS];
// 2114 //    #endif
// 2115 
// 2116     if (z_dest > current_position[Z_AXIS])
// 2117       do_blocking_move_to_z(z_dest);
// 2118   }
// 2119 
// 2120 #endif //HAS_BED_PROBE
// 2121 
// 2122 #if HAS_PROBING_PROCEDURE || HOTENDS > 1 || ENABLED(Z_PROBE_ALLEN_KEY) || ENABLED(Z_PROBE_SLED) || ENABLED(NOZZLE_CLEAN_FEATURE) || ENABLED(NOZZLE_PARK_FEATURE) || ENABLED(DELTA_AUTO_CALIBRATION)
// 2123 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock36 Using cfiCommon0
          CFI Function _Z18axis_unhomed_errorbbb
        THUMB
// 2124   bool axis_unhomed_error(const bool x, const bool y, const bool z) {
_Z18axis_unhomed_errorbbb:
        PUSH     {R2-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+24
// 2125     const bool xx = x && !axis_homed[X_AXIS],
        CMP      R0,#+0
        BEQ.N    ??axis_unhomed_error_0
        LDR.W    R0,??DataTable116_7
        LDRB     R0,[R0, #+0]
        SUBS     R4,R0,#+1
        SBCS     R4,R4,R4
        LSRS     R4,R4,#+31
        B.N      ??axis_unhomed_error_1
??axis_unhomed_error_0:
        MOVS     R4,#+0
// 2126                yy = y && !axis_homed[Y_AXIS],
??axis_unhomed_error_1:
        CMP      R1,#+0
        BEQ.N    ??axis_unhomed_error_2
        LDR.W    R0,??DataTable116_7
        LDRB     R0,[R0, #+1]
        SUBS     R6,R0,#+1
        SBCS     R6,R6,R6
        LSRS     R6,R6,#+31
        B.N      ??axis_unhomed_error_3
??axis_unhomed_error_2:
        MOVS     R6,#+0
// 2127                zz = z && !axis_homed[Z_AXIS];
??axis_unhomed_error_3:
        CMP      R2,#+0
        BEQ.N    ??axis_unhomed_error_4
        LDR.W    R0,??DataTable116_7
        LDRB     R0,[R0, #+2]
        SUBS     R5,R0,#+1
        SBCS     R5,R5,R5
        LSRS     R5,R5,#+31
        B.N      ??axis_unhomed_error_5
??axis_unhomed_error_4:
        MOVS     R5,#+0
// 2128     if (xx || yy || zz) {
??axis_unhomed_error_5:
        ORR      R0,R6,R4
        ORRS     R0,R5,R0
        BEQ.N    ??axis_unhomed_error_6
// 2129       SERIAL_ECHO_START;
        LDR.W    R0,??DataTable116_3
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2130       SERIAL_ECHOPGM(MSG_HOME " ");
        ADR.W    R0,?_3
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2131       if (xx) SERIAL_ECHOPGM(MSG_X);
        CMP      R4,#+0
        BEQ.N    ??axis_unhomed_error_7
        ADR.N    R0,??DataTable113  ;; "X"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2132       if (yy) SERIAL_ECHOPGM(MSG_Y);
??axis_unhomed_error_7:
        CMP      R6,#+0
        BEQ.N    ??axis_unhomed_error_8
        ADR.N    R0,??DataTable113_1  ;; "Y"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2133       if (zz) SERIAL_ECHOPGM(MSG_Z);
??axis_unhomed_error_8:
        CMP      R5,#+0
        BEQ.N    ??axis_unhomed_error_9
        ADR.N    R0,??DataTable113_2  ;; "Z"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2134       SERIAL_ECHOLNPGM(" " MSG_FIRST);
??axis_unhomed_error_9:
        ADR.W    R0,?_7
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2135 
// 2136       #if ENABLED(ULTRA_LCD)
// 2137         lcd_status_printf_P(0, PSTR(MSG_HOME " %s%s%s " MSG_FIRST), xx ? MSG_X : "", yy ? MSG_Y : "", zz ? MSG_Z : "");
        CMP      R5,#+0
        BEQ.N    ??axis_unhomed_error_10
        ADR.N    R0,??DataTable113_2  ;; "Z"
        B.N      ??axis_unhomed_error_11
??axis_unhomed_error_10:
        ADR.N    R0,??DataTable113_3  ;; ""
??axis_unhomed_error_11:
        CMP      R6,#+0
        BEQ.N    ??axis_unhomed_error_12
        ADR.N    R3,??DataTable113_1  ;; "Y"
        B.N      ??axis_unhomed_error_13
??axis_unhomed_error_12:
        ADR.N    R3,??DataTable113_3  ;; ""
??axis_unhomed_error_13:
        CMP      R4,#+0
        BEQ.N    ??axis_unhomed_error_14
        ADR.N    R2,??DataTable113  ;; "X"
        B.N      ??axis_unhomed_error_15
??axis_unhomed_error_14:
        ADR.N    R2,??DataTable113_3  ;; ""
??axis_unhomed_error_15:
        STR      R0,[SP, #+0]
        ADR.W    R1,?_8
        MOVS     R0,#+0
          CFI FunCall _Z19lcd_status_printf_PhPKcz
        BL       _Z19lcd_status_printf_PhPKcz
// 2138       #endif
// 2139       return true;
        MOVS     R0,#+1
        POP      {R1,R2,R4-R6,PC}
// 2140     }
// 2141     return false;
??axis_unhomed_error_6:
        MOVS     R0,#+0
        POP      {R1,R2,R4-R6,PC}  ;; return
// 2142   }
          CFI EndBlock cfiBlock36

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_3:
        DC8 "Home "
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_7:
        DC8 " first\012"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_8:
        DC8 "Home %s%s%s first"
        DC8 0, 0
// 2143 
// 2144 #endif
// 2145 
// 2146 #if ENABLED(Z_PROBE_SLED)
// 2147 
// 2148   #ifndef SLED_DOCKING_OFFSET
// 2149     #define SLED_DOCKING_OFFSET 0
// 2150   #endif
// 2151 
// 2152   /**
// 2153    * Method to dock/undock a sled designed by Charles Bell.
// 2154    *
// 2155    * stow[in]     If false, move to MAX_X and engage the solenoid
// 2156    *              If true, move to MAX_X and release the solenoid
// 2157    */
// 2158   static void dock_sled(bool stow) {
// 2159     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2160       if (DEBUGGING(LEVELING)) {
// 2161         SERIAL_ECHOPAIR("dock_sled(", stow);
// 2162         SERIAL_CHAR(')');
// 2163         SERIAL_EOL;
// 2164       }
// 2165     #endif
// 2166 
// 2167     // Dock sled a bit closer to ensure proper capturing
// 2168     do_blocking_move_to_x(X_MAX_POS + SLED_DOCKING_OFFSET - ((stow) ? 1 : 0));
// 2169 
// 2170     #if HAS_SOLENOID_1 && DISABLED(EXT_SOLENOID)
// 2171       WRITE(SOL1_PIN, !stow); // switch solenoid
// 2172     #endif
// 2173   }
// 2174 
// 2175 #elif ENABLED(Z_PROBE_ALLEN_KEY)
// 2176 
// 2177   void run_deploy_moves_script() {
// 2178     #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Z)
// 2179       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_X
// 2180         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_X current_position[X_AXIS]
// 2181       #endif
// 2182       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_Y
// 2183         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_Y current_position[Y_AXIS]
// 2184       #endif
// 2185       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_Z
// 2186         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_Z current_position[Z_AXIS]
// 2187       #endif
// 2188       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE
// 2189         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE 0.0
// 2190       #endif
// 2191       do_blocking_move_to(Z_PROBE_ALLEN_KEY_DEPLOY_1_X, Z_PROBE_ALLEN_KEY_DEPLOY_1_Y, Z_PROBE_ALLEN_KEY_DEPLOY_1_Z, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE));
// 2192     #endif
// 2193     #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_Z)
// 2194       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_X
// 2195         #define Z_PROBE_ALLEN_KEY_DEPLOY_2_X current_position[X_AXIS]
// 2196       #endif
// 2197       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_Y
// 2198         #define Z_PROBE_ALLEN_KEY_DEPLOY_2_Y current_position[Y_AXIS]
// 2199       #endif
// 2200       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_Z
// 2201         #define Z_PROBE_ALLEN_KEY_DEPLOY_2_Z current_position[Z_AXIS]
// 2202       #endif
// 2203       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE
// 2204         #define Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE 0.0
// 2205       #endif
// 2206       do_blocking_move_to(Z_PROBE_ALLEN_KEY_DEPLOY_2_X, Z_PROBE_ALLEN_KEY_DEPLOY_2_Y, Z_PROBE_ALLEN_KEY_DEPLOY_2_Z, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE));
// 2207     #endif
// 2208     #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_Z)
// 2209       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_X
// 2210         #define Z_PROBE_ALLEN_KEY_DEPLOY_3_X current_position[X_AXIS]
// 2211       #endif
// 2212       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_Y
// 2213         #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Y current_position[Y_AXIS]
// 2214       #endif
// 2215       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_Z
// 2216         #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Z current_position[Z_AXIS]
// 2217       #endif
// 2218       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE
// 2219         #define Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE 0.0
// 2220       #endif
// 2221       do_blocking_move_to(Z_PROBE_ALLEN_KEY_DEPLOY_3_X, Z_PROBE_ALLEN_KEY_DEPLOY_3_Y, Z_PROBE_ALLEN_KEY_DEPLOY_3_Z, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE));
// 2222     #endif
// 2223     #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_Z)
// 2224       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_X
// 2225         #define Z_PROBE_ALLEN_KEY_DEPLOY_4_X current_position[X_AXIS]
// 2226       #endif
// 2227       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_Y
// 2228         #define Z_PROBE_ALLEN_KEY_DEPLOY_4_Y current_position[Y_AXIS]
// 2229       #endif
// 2230       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_Z
// 2231         #define Z_PROBE_ALLEN_KEY_DEPLOY_4_Z current_position[Z_AXIS]
// 2232       #endif
// 2233       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE
// 2234         #define Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE 0.0
// 2235       #endif
// 2236       do_blocking_move_to(Z_PROBE_ALLEN_KEY_DEPLOY_4_X, Z_PROBE_ALLEN_KEY_DEPLOY_4_Y, Z_PROBE_ALLEN_KEY_DEPLOY_4_Z, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE));
// 2237     #endif
// 2238     #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_Z)
// 2239       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_X
// 2240         #define Z_PROBE_ALLEN_KEY_DEPLOY_5_X current_position[X_AXIS]
// 2241       #endif
// 2242       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_Y
// 2243         #define Z_PROBE_ALLEN_KEY_DEPLOY_5_Y current_position[Y_AXIS]
// 2244       #endif
// 2245       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_Z
// 2246         #define Z_PROBE_ALLEN_KEY_DEPLOY_5_Z current_position[Z_AXIS]
// 2247       #endif
// 2248       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE
// 2249         #define Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE 0.0
// 2250       #endif
// 2251       do_blocking_move_to(Z_PROBE_ALLEN_KEY_DEPLOY_5_X, Z_PROBE_ALLEN_KEY_DEPLOY_5_Y, Z_PROBE_ALLEN_KEY_DEPLOY_5_Z, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE));
// 2252     #endif
// 2253   }
// 2254 
// 2255   void run_stow_moves_script() {
// 2256     #if defined(Z_PROBE_ALLEN_KEY_STOW_1_X) || defined(Z_PROBE_ALLEN_KEY_STOW_1_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_1_Z)
// 2257       #ifndef Z_PROBE_ALLEN_KEY_STOW_1_X
// 2258         #define Z_PROBE_ALLEN_KEY_STOW_1_X current_position[X_AXIS]
// 2259       #endif
// 2260       #ifndef Z_PROBE_ALLEN_KEY_STOW_1_Y
// 2261         #define Z_PROBE_ALLEN_KEY_STOW_1_Y current_position[Y_AXIS]
// 2262       #endif
// 2263       #ifndef Z_PROBE_ALLEN_KEY_STOW_1_Z
// 2264         #define Z_PROBE_ALLEN_KEY_STOW_1_Z current_position[Z_AXIS]
// 2265       #endif
// 2266       #ifndef Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE
// 2267         #define Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE 0.0
// 2268       #endif
// 2269       do_blocking_move_to(Z_PROBE_ALLEN_KEY_STOW_1_X, Z_PROBE_ALLEN_KEY_STOW_1_Y, Z_PROBE_ALLEN_KEY_STOW_1_Z, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE));
// 2270     #endif
// 2271     #if defined(Z_PROBE_ALLEN_KEY_STOW_2_X) || defined(Z_PROBE_ALLEN_KEY_STOW_2_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_2_Z)
// 2272       #ifndef Z_PROBE_ALLEN_KEY_STOW_2_X
// 2273         #define Z_PROBE_ALLEN_KEY_STOW_2_X current_position[X_AXIS]
// 2274       #endif
// 2275       #ifndef Z_PROBE_ALLEN_KEY_STOW_2_Y
// 2276         #define Z_PROBE_ALLEN_KEY_STOW_2_Y current_position[Y_AXIS]
// 2277       #endif
// 2278       #ifndef Z_PROBE_ALLEN_KEY_STOW_2_Z
// 2279         #define Z_PROBE_ALLEN_KEY_STOW_2_Z current_position[Z_AXIS]
// 2280       #endif
// 2281       #ifndef Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE
// 2282         #define Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE 0.0
// 2283       #endif
// 2284       do_blocking_move_to(Z_PROBE_ALLEN_KEY_STOW_2_X, Z_PROBE_ALLEN_KEY_STOW_2_Y, Z_PROBE_ALLEN_KEY_STOW_2_Z, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE));
// 2285     #endif
// 2286     #if defined(Z_PROBE_ALLEN_KEY_STOW_3_X) || defined(Z_PROBE_ALLEN_KEY_STOW_3_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_3_Z)
// 2287       #ifndef Z_PROBE_ALLEN_KEY_STOW_3_X
// 2288         #define Z_PROBE_ALLEN_KEY_STOW_3_X current_position[X_AXIS]
// 2289       #endif
// 2290       #ifndef Z_PROBE_ALLEN_KEY_STOW_3_Y
// 2291         #define Z_PROBE_ALLEN_KEY_STOW_3_Y current_position[Y_AXIS]
// 2292       #endif
// 2293       #ifndef Z_PROBE_ALLEN_KEY_STOW_3_Z
// 2294         #define Z_PROBE_ALLEN_KEY_STOW_3_Z current_position[Z_AXIS]
// 2295       #endif
// 2296       #ifndef Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE
// 2297         #define Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE 0.0
// 2298       #endif
// 2299       do_blocking_move_to(Z_PROBE_ALLEN_KEY_STOW_3_X, Z_PROBE_ALLEN_KEY_STOW_3_Y, Z_PROBE_ALLEN_KEY_STOW_3_Z, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE));
// 2300     #endif
// 2301     #if defined(Z_PROBE_ALLEN_KEY_STOW_4_X) || defined(Z_PROBE_ALLEN_KEY_STOW_4_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_4_Z)
// 2302       #ifndef Z_PROBE_ALLEN_KEY_STOW_4_X
// 2303         #define Z_PROBE_ALLEN_KEY_STOW_4_X current_position[X_AXIS]
// 2304       #endif
// 2305       #ifndef Z_PROBE_ALLEN_KEY_STOW_4_Y
// 2306         #define Z_PROBE_ALLEN_KEY_STOW_4_Y current_position[Y_AXIS]
// 2307       #endif
// 2308       #ifndef Z_PROBE_ALLEN_KEY_STOW_4_Z
// 2309         #define Z_PROBE_ALLEN_KEY_STOW_4_Z current_position[Z_AXIS]
// 2310       #endif
// 2311       #ifndef Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE
// 2312         #define Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE 0.0
// 2313       #endif
// 2314       do_blocking_move_to(Z_PROBE_ALLEN_KEY_STOW_4_X, Z_PROBE_ALLEN_KEY_STOW_4_Y, Z_PROBE_ALLEN_KEY_STOW_4_Z, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE));
// 2315     #endif
// 2316     #if defined(Z_PROBE_ALLEN_KEY_STOW_5_X) || defined(Z_PROBE_ALLEN_KEY_STOW_5_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_5_Z)
// 2317       #ifndef Z_PROBE_ALLEN_KEY_STOW_5_X
// 2318         #define Z_PROBE_ALLEN_KEY_STOW_5_X current_position[X_AXIS]
// 2319       #endif
// 2320       #ifndef Z_PROBE_ALLEN_KEY_STOW_5_Y
// 2321         #define Z_PROBE_ALLEN_KEY_STOW_5_Y current_position[Y_AXIS]
// 2322       #endif
// 2323       #ifndef Z_PROBE_ALLEN_KEY_STOW_5_Z
// 2324         #define Z_PROBE_ALLEN_KEY_STOW_5_Z current_position[Z_AXIS]
// 2325       #endif
// 2326       #ifndef Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE
// 2327         #define Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE 0.0
// 2328       #endif
// 2329       do_blocking_move_to(Z_PROBE_ALLEN_KEY_STOW_5_X, Z_PROBE_ALLEN_KEY_STOW_5_Y, Z_PROBE_ALLEN_KEY_STOW_5_Z, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE));
// 2330     #endif
// 2331   }
// 2332 
// 2333 #endif
// 2334 #if ENABLED(PROBING_FANS_OFF)
// 2335   void fans_pause(bool p) {
// 2336     if (p && fans_paused) { // If called out of order something is wrong
// 2337       SERIAL_ERROR_START;
// 2338       SERIAL_ERRORLNPGM("Fans already paused!");
// 2339       return;
// 2340     }
// 2341 
// 2342     if (!p && !fans_paused) {
// 2343       SERIAL_ERROR_START;
// 2344       SERIAL_ERRORLNPGM("Fans already unpaused!");
// 2345       return;
// 2346     }
// 2347 
// 2348     if (p) {
// 2349       for (uint8_t x = 0;x < FAN_COUNT;x++) {
// 2350         paused_fanSpeeds[x] = fanSpeeds[x];
// 2351         fanSpeeds[x] = 0;
// 2352       }
// 2353     }
// 2354     else {
// 2355       for (uint8_t x = 0;x < FAN_COUNT;x++)
// 2356         fanSpeeds[x] = paused_fanSpeeds[x];
// 2357     }
// 2358 
// 2359     fans_paused = p;
// 2360   }
// 2361 #endif
// 2362 
// 2363 #if HAS_BED_PROBE
// 2364 
// 2365   // TRIGGERED_WHEN_STOWED_TEST can easily be extended to servo probes, ... if needed.
// 2366   #if ENABLED(PROBE_IS_TRIGGERED_WHEN_STOWED_TEST)
// 2367 //    #if ENABLED(Z_MIN_PROBE_ENDSTOP)
// 2368 	#if 1	//mks
// 2369       #define _TRIGGERED_WHEN_STOWED_TEST (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)
// 2370     #else
// 2371       #define _TRIGGERED_WHEN_STOWED_TEST (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)
// 2372     #endif
// 2373   #endif
// 2374 
// 2375 #if QUIET_PROBING
// 2376     void probing_pause(bool pause) {
// 2377 	#if ENABLED(PROBING_HEATERS_OFF)
// 2378         thermalManager.pause(pause);
// 2379 	#endif
// 2380 
// 2381 	#if ENABLED(PROBING_FANS_OFF)
// 2382         fans_pause(pause);
// 2383 	#endif
// 2384 
// 2385       if(pause) safe_delay(25);
// 2386     }
// 2387 #endif
// 2388 
// 2389 #if ENABLED(BLTOUCH)
// 2390 
// 2391     void bltouch_command(int angle) {
// 2392       servo[Z_ENDSTOP_SERVO_NR].move(angle);  // Give the BL-Touch the command and wait
// 2393       safe_delay(BLTOUCH_DELAY);
// 2394     }
// 2395 
// 2396     void set_bltouch_deployed(const bool deploy) {
// 2397 
// 2398 	if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
// 2399 		{
// 2400 		if (deploy && (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)) 
// 2401 		  { 	 // If BL-Touch says it's triggered
// 2402 		  bltouch_command(BLTOUCH_RESET);	 //  try to reset it.
// 2403 		  bltouch_command(BLTOUCH_DEPLOY);	 // Also needs to deploy and stow to
// 2404 		  bltouch_command(BLTOUCH_STOW);	 //  clear the triggered condition.
// 2405 		  safe_delay(1500); 				 // Wait for internal self-test to complete.
// 2406 											 //  (Measured completion time was 0.65 seconds
// 2407 											 //   after reset, deploy, and stow sequence)
// 2408 		  if ((READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)) { 			 // If it still claims to be triggered...
// 2409 			SERIAL_ERROR_START;
// 2410 			SERIAL_ERRORLNPGM(MSG_STOP_BLTOUCH);
// 2411 			stop(); 						 // punt!
// 2412 		  	}
// 2413 			}
// 2414 		
// 2415 		}
// 2416 	else if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN
// 2417 		{
// 2418 		if (deploy && (READ(Z_MAX_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)) 
// 2419 		  { 	 // If BL-Touch says it's triggered
// 2420 		  bltouch_command(BLTOUCH_RESET);	 //  try to reset it.
// 2421 		  bltouch_command(BLTOUCH_DEPLOY);	 // Also needs to deploy and stow to
// 2422 		  bltouch_command(BLTOUCH_STOW);	 //  clear the triggered condition.
// 2423 		  safe_delay(1500); 				 // Wait for internal self-test to complete.
// 2424 											 //  (Measured completion time was 0.65 seconds
// 2425 											 //   after reset, deploy, and stow sequence)
// 2426 		  if ((READ(Z_MAX_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)) { 			 // If it still claims to be triggered...
// 2427 			SERIAL_ERROR_START;
// 2428 			SERIAL_ERRORLNPGM(MSG_STOP_BLTOUCH);
// 2429 			stop(); 						 // punt!
// 2430 		  }
// 2431 		}
// 2432 		
// 2433 		}
// 2434 
// 2435       bltouch_command(deploy ? BLTOUCH_DEPLOY : BLTOUCH_STOW);
// 2436 
// 2437       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2438         if (DEBUGGING(LEVELING)) {
// 2439           SERIAL_ECHOPAIR("set_bltouch_deployed(", deploy);
// 2440           SERIAL_CHAR(')');
// 2441           SERIAL_EOL;
// 2442         }
// 2443       #endif
// 2444     }
// 2445 
// 2446   #endif // BLTOUCH
// 2447 
// 2448   // returns false for ok and true for failure

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock37 Using cfiCommon0
          CFI Function _Z18set_probe_deployedb
        THUMB
// 2449   bool set_probe_deployed(bool deploy) {
_Z18set_probe_deployedb:
        PUSH     {R0-R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+24
        MOV      R4,R0
// 2450 
// 2451     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2452       if (DEBUGGING(LEVELING)) {
// 2453         DEBUG_POS("set_probe_deployed", current_position);
// 2454         SERIAL_ECHOLNPAIR("deploy: ", deploy);
// 2455       }
// 2456     #endif
// 2457 
// 2458     if (endstops.z_probe_enabled == deploy) return false;
        LDR.W    R0,??DataTable123_1
        LDRB     R0,[R0, #+0]
        MOV      R1,R4
        CMP      R0,R1
        BNE.N    ??set_probe_deployed_0
        MOVS     R0,#+0
        B.N      ??set_probe_deployed_1
// 2459 
// 2460     // Make room for probe
// 2461     //do_probe_raise(_Z_CLEARANCE_DEPLOY_PROBE);	//mks
// 2462     do_probe_raise(Z_CLEARANCE_DEPLOY_PROBE>Z_CLEARANCE_BETWEEN_PROBES ? Z_CLEARANCE_DEPLOY_PROBE : Z_CLEARANCE_BETWEEN_PROBES);
??set_probe_deployed_0:
        LDR.N    R0,??DataTable113_4
        LDR      R1,[R0, #+100]
        LDR      R0,[R0, #+104]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??set_probe_deployed_2
        MOV      R1,R0
??set_probe_deployed_2:
        MOV      R0,R1
          CFI FunCall _Z14do_probe_raisef
        BL       _Z14do_probe_raisef
// 2463 
// 2464     // When deploying make sure BLTOUCH is not already triggered
// 2465     #if ENABLED(BLTOUCH)
// 2466 
// 2467 	if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
// 2468 		{
// 2469 		if (deploy && (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)) 
// 2470 		  { 	 // If BL-Touch says it's triggered
// 2471 		  bltouch_command(BLTOUCH_RESET);	 // try to reset it.
// 2472 		  bltouch_command(BLTOUCH_DEPLOY);	 // Also needs to deploy and stow to
// 2473 		  bltouch_command(BLTOUCH_STOW);	 // clear the triggered condition.
// 2474 		  safe_delay(1500); 				 // wait for internal self test to complete
// 2475 											 //   measured completion time was 0.65 seconds
// 2476 											 //   after reset, deploy & stow sequence
// 2477 		  if ((READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)) { 			 // If it still claims to be triggered...
// 2478 			SERIAL_ERROR_START;
// 2479 			SERIAL_ERRORLNPGM(MSG_STOP_BLTOUCH);
// 2480 			stop(); 						 // punt!
// 2481 			return true;
// 2482 		  }
// 2483 		}
// 2484 
// 2485 		}
// 2486 	else if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN
// 2487 		{
// 2488 		if (deploy && (READ(Z_MAX_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)) 
// 2489 		  { 	 // If BL-Touch says it's triggered
// 2490 		  bltouch_command(BLTOUCH_RESET);	 // try to reset it.
// 2491 		  bltouch_command(BLTOUCH_DEPLOY);	 // Also needs to deploy and stow to
// 2492 		  bltouch_command(BLTOUCH_STOW);	 // clear the triggered condition.
// 2493 		  safe_delay(1500); 				 // wait for internal self test to complete
// 2494 											 //   measured completion time was 0.65 seconds
// 2495 											 //   after reset, deploy & stow sequence
// 2496 		  if ((READ(Z_MAX_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)) { 			 // If it still claims to be triggered...
// 2497 			SERIAL_ERROR_START;
// 2498 			SERIAL_ERRORLNPGM(MSG_STOP_BLTOUCH);
// 2499 			stop(); 						 // punt!
// 2500 			return true;
// 2501 		  }
// 2502 		}
// 2503 		
// 2504 		}
// 2505 
// 2506 	  
// 2507     #elif ENABLED(Z_PROBE_SLED)
// 2508       if (axis_unhomed_error(true, false, false)) {
// 2509         SERIAL_ERROR_START;
// 2510         SERIAL_ERRORLNPGM(MSG_STOP_UNHOMED);
// 2511         stop();
// 2512         return true;
// 2513       }
// 2514     #elif ENABLED(Z_PROBE_ALLEN_KEY)
// 2515       if (axis_unhomed_error(true, true,  true )) {
// 2516         SERIAL_ERROR_START;
// 2517         SERIAL_ERRORLNPGM(MSG_STOP_UNHOMED);
// 2518         stop();
// 2519         return true;
// 2520       }
// 2521     #endif
// 2522 
// 2523     const float oldXpos = current_position[X_AXIS],
        LDR.N    R0,??DataTable112_3
        LDR      R1,[R0, #+8]
        STR      R1,[SP, #+8]
// 2524                 oldYpos = current_position[Y_AXIS];
        LDR      R1,[R0, #+12]
        STR      R1,[SP, #+4]
// 2525 
// 2526     #ifdef _TRIGGERED_WHEN_STOWED_TEST
// 2527 
// 2528       // If endstop is already false, the Z probe is deployed
// 2529       bool _triggered_bool =false;
// 2530 	if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
// 2531 		_triggered_bool = (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING);
// 2532 	else if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)
// 2533 		_triggered_bool = (READ(Z_MAX_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING);
// 2534 	
// 2535       //if (_TRIGGERED_WHEN_STOWED_TEST == deploy) 
// 2536 	if (_triggered_bool == deploy) 
// 2537 	  {     // closed after the probe specific actions.
// 2538                                                        // Would a goto be less ugly?
// 2539         //while (!_TRIGGERED_WHEN_STOWED_TEST) idle(); // would offer the opportunity
// 2540                                                        // for a triggered when stowed manual probe.
// 2541 
// 2542         if (!deploy) endstops.enable_z_probe(false); // Switch off triggered when stowed probes early
// 2543                                                      // otherwise an Allen-Key probe can't be stowed.
// 2544     #endif
// 2545 
// 2546         #if ENABLED(SOLENOID_PROBE)
// 2547 
// 2548           #if HAS_SOLENOID_1
// 2549             WRITE(SOL1_PIN, deploy);
// 2550           #endif
// 2551 
// 2552         #elif ENABLED(Z_PROBE_SLED)
// 2553 
// 2554           dock_sled(!deploy);
// 2555 
// 2556         #elif HAS_Z_SERVO_ENDSTOP && DISABLED(BLTOUCH)
// 2557 
// 2558           servo[Z_ENDSTOP_SERVO_NR].move(z_servo_angle[deploy ? 0 : 1]);
// 2559 
// 2560         #elif ENABLED(Z_PROBE_ALLEN_KEY)
// 2561 
// 2562           deploy ? run_deploy_moves_script() : run_stow_moves_script();
// 2563 
// 2564         #endif
// 2565 
// 2566     #ifdef _TRIGGERED_WHEN_STOWED_TEST
// 2567       } // _TRIGGERED_WHEN_STOWED_TEST == deploy
// 2568 
// 2569 
// 2570 		//bool _triggered_bool =false;
// 2571 	  if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
// 2572 		  _triggered_bool = (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING);
// 2573 	  else if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)
// 2574 		  _triggered_bool = (READ(Z_MAX_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING);
// 2575 
// 2576 //      if (_TRIGGERED_WHEN_STOWED_TEST == deploy) { // State hasn't changed?
// 2577 	  if (_triggered_bool == deploy) { // State hasn't changed?
// 2578 
// 2579         if (IsRunning()) {
// 2580           SERIAL_ERROR_START;
// 2581           SERIAL_ERRORLNPGM("Z-Probe failed");
// 2582           LCD_ALERTMESSAGEPGM("Err: ZPROBE");
// 2583         }
// 2584         stop();
// 2585         return true;
// 2586 
// 2587       } // _TRIGGERED_WHEN_STOWED_TEST == deploy
// 2588 
// 2589     #endif
// 2590 
// 2591     do_blocking_move_to(oldXpos, oldYpos, current_position[Z_AXIS]); // return to position before deploy
        MOVS     R1,#+0
        STR      R1,[SP, #+0]
        MOV      R3,SP
        ADD      R2,R0,#+16
        ADD      R1,SP,#+4
        ADD      R0,SP,#+8
          CFI FunCall _Z19do_blocking_move_toRKfS0_S0_S0_
        BL       _Z19do_blocking_move_toRKfS0_S0_S0_
// 2592     endstops.enable_z_probe(deploy);
        MOV      R0,R4
          CFI FunCall _ZN8Endstops14enable_z_probeEb
        BL       _ZN8Endstops14enable_z_probeEb
// 2593     return false;
        MOVS     R0,#+0
??set_probe_deployed_1:
        ADD      SP,SP,#+16
          CFI CFA R13+8
        POP      {R4,PC}          ;; return
// 2594   }
          CFI EndBlock cfiBlock37
// 2595 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock38 Using cfiCommon0
          CFI Function _ZN37_INTERNAL_15_Marlin_main_cpp_3178531913do_probe_moveEff
        THUMB
// 2596   static void do_probe_move(float z, float fr_mm_m) {
_ZN37_INTERNAL_15_Marlin_main_cpp_3178531913do_probe_moveEff:
        PUSH     {R2-R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+16
        MOV      R4,R1
// 2597     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2598       if (DEBUGGING(LEVELING)) DEBUG_POS(">>> do_probe_move", current_position);
// 2599     #endif
// 2600 
// 2601     // Deploy BLTouch at the start of any probe
// 2602     #if ENABLED(BLTOUCH)
// 2603       set_bltouch_deployed(true);
// 2604     #endif
// 2605 
// 2606 #if QUIET_PROBING
// 2607       probing_pause(true);
// 2608 #endif
// 2609 
// 2610     // Move down until probe triggered
// 2611     do_blocking_move_to_z(LOGICAL_Z_POSITION(z), MMM_TO_MMS(fr_mm_m));
        LDR.N    R1,??DataTable112_3
        LDR      R1,[R1, #+76]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[SP, #+4]
        MOV      R0,R4
        LDR.N    R1,??DataTable113_5  ;; 0x42700000
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[SP, #+0]
        MOV      R1,SP
        ADD      R0,SP,#+4
          CFI FunCall _Z21do_blocking_move_to_zRKfS0_
        BL       _Z21do_blocking_move_to_zRKfS0_
// 2612 
// 2613 #if QUIET_PROBING
// 2614       probing_pause(false);
// 2615 #endif
// 2616 
// 2617     // Retract BLTouch immediately after a probe
// 2618     #if ENABLED(BLTOUCH)
// 2619       set_bltouch_deployed(false);
// 2620     #endif
// 2621 
// 2622     // Clear endstop flags
// 2623     endstops.hit_on_purpose();
          CFI FunCall _ZN8Endstops14hit_on_purposeEv
        BL       _ZN8Endstops14hit_on_purposeEv
// 2624 
// 2625     // Get Z where the steppers were interrupted
// 2626     set_current_from_steppers_for_axis(Z_AXIS);
        MOVS     R0,#+2
          CFI FunCall _Z34set_current_from_steppers_for_axis8AxisEnum
        BL       _Z34set_current_from_steppers_for_axis8AxisEnum
// 2627 
// 2628     // Tell the planner where we actually are
// 2629     SYNC_PLAN_POSITION_KINEMATIC();
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
// 2630 
// 2631     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2632       if (DEBUGGING(LEVELING)) DEBUG_POS("<<< do_probe_move", current_position);
// 2633     #endif
// 2634   }
        POP      {R0,R1,R4,PC}    ;; return
          CFI EndBlock cfiBlock38
// 2635 
// 2636   // Do a single Z probe and return with current_position[Z_AXIS]
// 2637   // at the height where the probe triggered.

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock39 Using cfiCommon0
          CFI Function _ZN37_INTERNAL_15_Marlin_main_cpp_3178531911run_z_probeEv
        THUMB
// 2638   static float run_z_probe() {
_ZN37_INTERNAL_15_Marlin_main_cpp_3178531911run_z_probeEv:
        PUSH     {R1-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+32
// 2639 
// 2640     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2641       if (DEBUGGING(LEVELING)) DEBUG_POS(">>> run_z_probe", current_position);
// 2642     #endif
// 2643 
// 2644     // Prevent stepper_inactive_time from running out and EXTRUDER_RUNOUT_PREVENT from extruding
// 2645     refresh_cmd_timeout();
          CFI FunCall _Z19refresh_cmd_timeoutv
        BL       _Z19refresh_cmd_timeoutv
// 2646 
// 2647     #if ENABLED(PROBE_DOUBLE_TOUCH)
// 2648 
// 2649       // Do a first probe at the fast speed
// 2650       do_probe_move(-(Z_MAX_LENGTH) - 10, Z_PROBE_SPEED_FAST);
// 2651 
// 2652       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2653         float first_probe_z = current_position[Z_AXIS];
// 2654         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("1st Probe Z:", first_probe_z);
// 2655       #endif
// 2656 
// 2657       // move up by the bump distance
// 2658       do_blocking_move_to_z(current_position[Z_AXIS] + home_bump_mm(Z_AXIS), MMM_TO_MMS(Z_PROBE_SPEED_FAST));
// 2659 
// 2660     #else
// 2661 
// 2662       // If the nozzle is above the travel height then
// 2663       // move down quickly before doing the slow probe
// 2664       float z = LOGICAL_Z_POSITION(Z_CLEARANCE_BETWEEN_PROBES);
        LDR.N    R4,??DataTable112_3
        LDR.N    R5,??DataTable113_4
        LDR      R1,[R5, #+104]
        LDR      R0,[R4, #+76]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[SP, #+0]
// 2665       if (zprobe_zoffset < 0) z -= zprobe_zoffset;
        LDR.W    R6,??DataTable116_7
        LDR      R2,[R6, #+72]
        MOV      R0,R2
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??run_z_probe_0
        LDR      R0,[SP, #+0]
        MOV      R1,R2
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+0]
// 2666      // #if ENABLED(DELTA)
// 2667      if(MACHINETPYE == DELTA)
??run_z_probe_0:
        LDRSH    R0,[R5, #+88]
        CMP      R0,#+2
        BNE.N    ??run_z_probe_1
// 2668         z -= home_offset[Z_AXIS];
        LDR      R0,[SP, #+0]
        LDR      R1,[R4, #+64]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+0]
// 2669       //#endif
// 2670       if (z < current_position[Z_AXIS])
??run_z_probe_1:
        LDR      R0,[SP, #+0]
        LDR      R1,[R4, #+16]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??run_z_probe_2
// 2671         do_blocking_move_to_z(z, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
        LDR      R0,[R5, #+120]
        LDR.N    R1,??DataTable113_5  ;; 0x42700000
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[SP, #+4]
        ADD      R1,SP,#+4
        MOV      R0,SP
          CFI FunCall _Z21do_blocking_move_to_zRKfS0_
        BL       _Z21do_blocking_move_to_zRKfS0_
// 2672 
// 2673     #endif
// 2674 
// 2675     // move down slowly to find bed
// 2676     do_probe_move(-(Z_MAX_LENGTH) - 10, Z_PROBE_SPEED_SLOW);
??run_z_probe_2:
        LDR      R1,[R5, #+124]
        MOV      R7,R1
        LDR      R0,[R5, #+16]
        LDR      R1,[R5, #+28]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR.W    R1,??DataTable126  ;; 0xc1200000
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R7
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531913do_probe_moveEff
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531913do_probe_moveEff
// 2677 
// 2678     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2679       if (DEBUGGING(LEVELING)) DEBUG_POS("<<< run_z_probe", current_position);
// 2680     #endif
// 2681 
// 2682     // Debug: compare probe heights
// 2683     #if ENABLED(PROBE_DOUBLE_TOUCH) && ENABLED(DEBUG_LEVELING_FEATURE)
// 2684       if (DEBUGGING(LEVELING)) {
// 2685         SERIAL_ECHOPAIR("2nd Probe Z:", current_position[Z_AXIS]);
// 2686         SERIAL_ECHOLNPAIR(" Discrepancy:", first_probe_z - current_position[Z_AXIS]);
// 2687       }
// 2688     #endif
// 2689     return current_position[Z_AXIS] + zprobe_zoffset;
        LDR      R1,[R4, #+16]
        LDR      R0,[R6, #+72]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        POP      {R1-R7,PC}       ;; return
// 2690   }
          CFI EndBlock cfiBlock39

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable112:
        DC32     card

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable112_1:
        DC32     __dso_handle

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable112_2:
        DC32     _ZN10CardReaderD1Ev

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable112_3:
        DC32     mks_heating_busy
// 2691 
// 2692   /**
// 2693    * - Move to the given XY
// 2694    * - Deploy the probe, if not already deployed
// 2695    * - Probe the bed, get the Z position
// 2696    * - Depending on the 'stow' flag
// 2697    *   - Stow the probe, or
// 2698    *   - Raise to the BETWEEN height
// 2699    * - Return the probed Z position
// 2700    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock40 Using cfiCommon0
          CFI Function _Z8probe_ptffbi
        THUMB
// 2701   float probe_pt(const float x, const float y, const bool stow/*=true*/, const int verbose_level/*=1*/) {
_Z8probe_ptffbi:
        PUSH     {R1-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+48
        MOV      R10,R0
        MOV      R7,R1
        MOV      R11,R2
        MOV      R8,R3
// 2702     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2703       if (DEBUGGING(LEVELING)) {
// 2704         SERIAL_ECHOPAIR(">>> probe_pt(", x);
// 2705         SERIAL_ECHOPAIR(", ", y);
// 2706         SERIAL_ECHOPAIR(", ", stow ? "" : "no ");
// 2707         SERIAL_ECHOLNPGM("stow)");
// 2708         DEBUG_POS("", current_position);
// 2709       }
// 2710     #endif
// 2711 
// 2712     const float old_feedrate_mm_s = feedrate_mm_s;
        LDR.W    R4,??DataTable126_1
        LDR      R5,[R4, #+116]
// 2713 
// 2714 //    #if ENABLED(DELTA)
// 2715 	if(MACHINETPYE == DELTA)	{
        LDR.W    R9,??DataTable113_4
        LDRSH    R0,[R9, #+88]
        CMP      R0,#+2
        BNE.N    ??probe_pt_0
// 2716       if (current_position[Z_AXIS] > delta_clip_start_height)
        LDR      R0,[R4, #+128]
        LDR      R1,[R4, #+16]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??probe_pt_0
// 2717         do_blocking_move_to_z(delta_clip_start_height);
        MOVS     R0,#+0
        STR      R0,[SP, #+0]
        MOV      R1,SP
        ADD      R0,R4,#+128
          CFI FunCall _Z21do_blocking_move_to_zRKfS0_
        BL       _Z21do_blocking_move_to_zRKfS0_
// 2718     }	//#endif
// 2719 
// 2720     // Ensure a minimum height before moving the probe
// 2721     do_probe_raise(Z_CLEARANCE_BETWEEN_PROBES);
??probe_pt_0:
        LDR      R0,[R9, #+104]
          CFI FunCall _Z14do_probe_raisef
        BL       _Z14do_probe_raisef
// 2722 
// 2723     feedrate_mm_s = XY_PROBE_FEEDRATE_MM_S;
        LDR      R0,[R4, #+124]
        STR      R0,[R4, #+116]
// 2724 
// 2725     // Move the probe to the given XY
// 2726     do_blocking_move_to_xy(x - (X_PROBE_OFFSET_FROM_EXTRUDER), y - (Y_PROBE_OFFSET_FROM_EXTRUDER));
        MOV      R0,R10
        LDR      R1,[R9, #+108]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+8]
        MOV      R0,R7
        LDR      R1,[R9, #+112]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+4]
        MOVS     R0,#+0
        STR      R0,[SP, #+0]
        MOV      R2,SP
        ADD      R1,SP,#+4
        ADD      R0,SP,#+8
          CFI FunCall _Z22do_blocking_move_to_xyRKfS0_S0_
        BL       _Z22do_blocking_move_to_xyRKfS0_S0_
// 2727 
// 2728     if (DEPLOY_PROBE()) return NAN;
        MOVS     R0,#+1
          CFI FunCall _Z18set_probe_deployedb
        BL       _Z18set_probe_deployedb
        CMP      R0,#+0
        BNE.N    ??probe_pt_1
// 2729 
// 2730     const float measured_z = run_z_probe();
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531911run_z_probeEv
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531911run_z_probeEv
        MOV      R6,R0
// 2731 
// 2732     if (!stow)
        CMP      R11,#+0
        BNE.N    ??probe_pt_2
// 2733       do_probe_raise(Z_CLEARANCE_BETWEEN_PROBES);
        LDR      R0,[R9, #+104]
          CFI FunCall _Z14do_probe_raisef
        BL       _Z14do_probe_raisef
// 2734     else
// 2735       if (STOW_PROBE()) return NAN;
// 2736 
// 2737     if (verbose_level > 2) {
??probe_pt_3:
        CMP      R8,#+3
        BLT.N    ??probe_pt_4
// 2738       SERIAL_PROTOCOLPGM("Bed X: ");
        ADR.W    R0,?_10
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2739       SERIAL_PROTOCOL_F(x, 3);
        MOV      R0,R10
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        LDRB     R0,[R4, #+7]
        CMP      R0,#+0
        BNE.N    ??probe_pt_5
        MOVS     R0,#+3
        STR      R0,[SP, #+0]
        LDR.N    R0,??DataTable116_4
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
        B.N      ??probe_pt_6
??probe_pt_2:
        MOVS     R0,#+0
          CFI FunCall _Z18set_probe_deployedb
        BL       _Z18set_probe_deployedb
        CMP      R0,#+0
        BEQ.N    ??probe_pt_3
??probe_pt_1:
        MVN      R0,#-2147483648
        B.N      ??probe_pt_7
??probe_pt_5:
        MOVS     R0,#+3
        STR      R0,[SP, #+0]
        LDR.N    R0,??DataTable116_5
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
// 2740       SERIAL_PROTOCOLPGM(" Y: ");
??probe_pt_6:
        ADR.W    R0,?_11
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2741       SERIAL_PROTOCOL_F(y, 3);
        MOV      R0,R7
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        LDRB     R0,[R4, #+7]
        CMP      R0,#+0
        BNE.N    ??probe_pt_8
        MOVS     R0,#+3
        STR      R0,[SP, #+0]
        LDR.N    R0,??DataTable116_4
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
        B.N      ??probe_pt_9
??probe_pt_8:
        MOVS     R0,#+3
        STR      R0,[SP, #+0]
        LDR.N    R0,??DataTable116_5
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
// 2742       SERIAL_PROTOCOLPGM(" Z: ");
??probe_pt_9:
        ADR.W    R0,?_12
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2743       SERIAL_PROTOCOL_F(measured_z, 3);
        MOV      R0,R6
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDRB     R2,[R4, #+7]
        CMP      R2,#+0
        BNE.N    ??probe_pt_10
        MOVS     R2,#+3
        STR      R2,[SP, #+0]
        MOV      R2,R0
        MOV      R3,R1
        LDR.N    R0,??DataTable116_4
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
        B.N      ??probe_pt_11
??probe_pt_10:
        MOVS     R2,#+3
        STR      R2,[SP, #+0]
        MOV      R2,R0
        MOV      R3,R1
        LDR.N    R0,??DataTable116_5
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
// 2744       SERIAL_EOL;
??probe_pt_11:
        LDRB     R0,[R4, #+7]
        CMP      R0,#+0
        BNE.N    ??probe_pt_12
        MOVS     R1,#+10
        LDR.N    R0,??DataTable116_4
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??probe_pt_4
??probe_pt_12:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.N    R0,??DataTable116_5
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
// 2745     }
// 2746 
// 2747     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2748       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< probe_pt");
// 2749     #endif
// 2750 
// 2751     feedrate_mm_s = old_feedrate_mm_s;
??probe_pt_4:
        STR      R5,[R4, #+116]
// 2752 
// 2753     return measured_z;
        MOV      R0,R6
??probe_pt_7:
        POP      {R1-R11,PC}      ;; return
// 2754   }
          CFI EndBlock cfiBlock40

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable113:
        DC8      "X",0x0,0x0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable113_1:
        DC8      "Y",0x0,0x0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable113_2:
        DC8      "Z",0x0,0x0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable113_3:
        DC8      "",0x0,0x0,0x0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable113_4:
        DC32     mksCfg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable113_5:
        DC32     0x42700000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable113_6:
        DC32     0x43160000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable113_7:
        DC32     home_dir_P

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable113_8:
        DC32     mksReprint

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable113_9:
        DC32     _ZN7Planner11abl_enabledE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_10:
        DC8 "Bed X: "

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_11:
        DC8 " Y: "
        DC8 0, 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_12:
        DC8 " Z: "
        DC8 0, 0, 0
// 2755 
// 2756 #endif // HAS_BED_PROBE
// 2757 
// 2758 //#if HAS_LEVELING
// 2759 #if 1
// 2760   /**
// 2761    * Turn bed leveling on or off, fixing the current
// 2762    * position as-needed.
// 2763    *
// 2764    * Disable: Current position = physical position
// 2765    *  Enable: Current position = "unleveled" physical position
// 2766    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock41 Using cfiCommon0
          CFI Function _Z24set_bed_leveling_enabledb
        THUMB
// 2767   void set_bed_leveling_enabled(bool enable/*=true*/) {
_Z24set_bed_leveling_enabledb:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R4,R0
// 2768 /*--mks cfg--begin MESH_BED_LEVELING */  
// 2769 /*
// 2770     #if ENABLED(MESH_BED_LEVELING)
// 2771 
// 2772       if (enable != mbl.active()) {
// 2773 
// 2774         if (!enable)
// 2775           planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS]);
// 2776 
// 2777         mbl.set_active(enable && mbl.has_mesh());
// 2778 
// 2779         if (enable && mbl.has_mesh()) planner.unapply_leveling(current_position);
// 2780       }
// 2781 
// 2782     #elif ENABLED(AUTO_BED_LEVELING_UBL)
// 2783 
// 2784       ubl.state.active = enable;
// 2785       //set_current_from_steppers_for_axis(Z_AXIS);
// 2786 
// 2787     #else
// 2788 
// 2789       #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 2790         const bool can_change = (!enable || (bilinear_grid_spacing[0] && bilinear_grid_spacing[1]));
// 2791       #else
// 2792         constexpr bool can_change = true;
// 2793       #endif
// 2794 
// 2795       if (can_change && enable != planner.abl_enabled) {
// 2796 
// 2797         #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 2798           // Force bilinear_z_offset to re-calculate next time
// 2799           const float reset[XYZ] = { -9999.999, -9999.999, 0 };
// 2800           (void)bilinear_z_offset(reset);
// 2801         #endif
// 2802 
// 2803         planner.abl_enabled = enable;
// 2804         if (!enable)
// 2805           set_current_from_steppers_for_axis(
// 2806             #if ABL_PLANAR
// 2807               ALL_AXES
// 2808             #else
// 2809               Z_AXIS
// 2810             #endif
// 2811           );
// 2812         else
// 2813           planner.unapply_leveling(current_position);
// 2814       }
// 2815     #endif
// 2816 */
// 2817 
// 2818 //#if ENABLED(MESH_BED_LEVELING)
// 2819 if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
        LDR.W    R5,??DataTable126_2
        LDRB     R1,[R5, #+64]
        CMP      R1,#+32
        BNE.N    ??set_bed_leveling_enabled_0
// 2820 {
// 2821       if (enable != mbl.active()) {
        MOV      R5,R4
          CFI FunCall _ZN17mesh_bed_leveling6activeEv
        BL       _ZN17mesh_bed_leveling6activeEv
        CMP      R5,R0
        BEQ.N    ??set_bed_leveling_enabled_1
// 2822 
// 2823         if (!enable)
        MOVS     R0,R4
        BNE.N    ??set_bed_leveling_enabled_2
// 2824           planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS]);
        LDR.W    R0,??DataTable126_1
        ADD      R2,R0,#+16
        ADD      R1,R0,#+12
        ADDS     R0,R0,#+8
          CFI FunCall _ZN7Planner14apply_levelingERfS0_S0_
        BL       _ZN7Planner14apply_levelingERfS0_S0_
// 2825 
// 2826         mbl.set_active(enable && mbl.has_mesh());
??set_bed_leveling_enabled_2:
        MOVS     R0,R4
        BEQ.N    ??set_bed_leveling_enabled_3
          CFI FunCall _ZN17mesh_bed_leveling8has_meshEv
        BL       _ZN17mesh_bed_leveling8has_meshEv
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
        B.N      ??set_bed_leveling_enabled_4
??set_bed_leveling_enabled_3:
        MOVS     R0,#+0
??set_bed_leveling_enabled_4:
          CFI FunCall _ZN17mesh_bed_leveling10set_activeEb
        BL       _ZN17mesh_bed_leveling10set_activeEb
// 2827 
// 2828         if (enable && mbl.has_mesh()) planner.unapply_leveling(current_position);
        CMP      R4,#+0
        BEQ.N    ??set_bed_leveling_enabled_1
          CFI FunCall _ZN17mesh_bed_leveling8has_meshEv
        BL       _ZN17mesh_bed_leveling8has_meshEv
        CMP      R0,#+0
        BEQ.N    ??set_bed_leveling_enabled_1
        LDR.W    R0,??DataTable126_3
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Planner16unapply_levelingEPf
        B.W      _ZN7Planner16unapply_levelingEPf
          CFI R4 Frame(CFA, -16)
          CFI R5 Frame(CFA, -12)
          CFI R6 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
// 2829       }
// 2830 }
// 2831 //#else
// 2832 else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
??set_bed_leveling_enabled_0:
        CMP      R1,#+16
        BNE.N    ??set_bed_leveling_enabled_5
// 2833 {
// 2834 	ubl.state.active = enable;
        LDR.W    R0,??DataTable126_4
        STRB     R4,[R0, #+0]
        POP      {R4-R6,PC}
// 2835 	//set_current_from_steppers_for_axis(Z_AXIS);
// 2836 
// 2837 }
// 2838 	else
// 2839 {
// 2840 	/*--mks cfg--begin AUTO_BED_LEVELING_BILINEAR */
// 2841 /*
// 2842   #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 2843 		  const bool can_change = (!enable || (bilinear_grid_spacing[0] && bilinear_grid_spacing[1]));
// 2844   #else
// 2845 		  constexpr bool can_change = true;
// 2846   #endif
// 2847   */
// 2848 	bool can_change;
// 2849 	if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
??set_bed_leveling_enabled_5:
        CMP      R1,#+8
        BNE.N    ??set_bed_leveling_enabled_6
// 2850 		{
// 2851 		can_change= (!enable || (bilinear_grid_spacing[0] && bilinear_grid_spacing[1]));
        MOVS     R0,R4
        BEQ.N    ??set_bed_leveling_enabled_6
        LDR.W    R2,??DataTable126_5
        LDR      R0,[R2, #+8]
        CMP      R0,#+0
        BEQ.N    ??set_bed_leveling_enabled_7
        LDR      R0,[R2, #+12]
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
        B.N      ??set_bed_leveling_enabled_8
??set_bed_leveling_enabled_7:
        MOVS     R0,#+0
        B.N      ??set_bed_leveling_enabled_8
// 2852 		}
// 2853 		else
// 2854 			{
// 2855 			can_change = true;
??set_bed_leveling_enabled_6:
        MOVS     R0,#+1
// 2856 			}
// 2857 	
// 2858 	  
// 2859 	if (can_change && enable != planner.abl_enabled) {
??set_bed_leveling_enabled_8:
        CMP      R0,#+0
        BEQ.N    ??set_bed_leveling_enabled_1
        LDR.W    R6,??DataTable126_6
        MOV      R0,R4
        LDRB     R2,[R6, #+0]
        CMP      R0,R2
        BEQ.N    ??set_bed_leveling_enabled_1
// 2860 
// 2861 /*
// 2862 	#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 2863 			// Force bilinear_z_offset to re-calculate next time
// 2864 			const float reset[XYZ] = { -9999.999, -9999.999, 0 };
// 2865 			(void)bilinear_z_offset(reset);
// 2866 	#endif
// 2867 */	
// 2868 			if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
        CMP      R1,#+8
        BNE.N    ??set_bed_leveling_enabled_9
// 2869 				{
// 2870 				const float reset[XYZ] = { -9999.999, -9999.999, 0 };
// 2871 				(void)bilinear_z_offset(reset);
        ADR.W    R0,`set_bed_leveling_enabled(bool){3}{5}{8}{9}::reset`
          CFI FunCall _Z17bilinear_z_offsetPKf
        BL       _Z17bilinear_z_offsetPKf
// 2872 				}
// 2873 			
// 2874 		  planner.abl_enabled = enable;
??set_bed_leveling_enabled_9:
        STRB     R4,[R6, #+0]
// 2875 		  if (!enable)
        CMP      R4,#+0
        BNE.N    ??set_bed_leveling_enabled_10
// 2876 		  	{
// 2877 			if(BED_LEVELING_METHOD&ABL_PLANAR)
        LDRB     R0,[R5, #+64]
        TST      R0,#0x6
        BEQ.N    ??set_bed_leveling_enabled_11
// 2878 				{set_current_from_steppers_for_axis(ALL_AXES);}
        MOVS     R0,#+100
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z34set_current_from_steppers_for_axis8AxisEnum
        B.W      _Z34set_current_from_steppers_for_axis8AxisEnum
          CFI R4 Frame(CFA, -16)
          CFI R5 Frame(CFA, -12)
          CFI R6 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
// 2879 			else
// 2880 				{set_current_from_steppers_for_axis(Z_AXIS);}
??set_bed_leveling_enabled_11:
        MOVS     R0,#+2
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z34set_current_from_steppers_for_axis8AxisEnum
        B.W      _Z34set_current_from_steppers_for_axis8AxisEnum
          CFI R4 Frame(CFA, -16)
          CFI R5 Frame(CFA, -12)
          CFI R6 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
// 2881 		  	}
// 2882 		  else
// 2883 			{planner.unapply_leveling(current_position);}
??set_bed_leveling_enabled_10:
        LDR.W    R0,??DataTable126_3
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Planner16unapply_levelingEPf
        B.W      _ZN7Planner16unapply_levelingEPf
          CFI R4 Frame(CFA, -16)
          CFI R5 Frame(CFA, -12)
          CFI R6 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
// 2884 		}
// 2885 }
// 2886 //#endif
// 2887 	/*--mks cfg--end MESH_BED_LEVELING */
// 2888   }
??set_bed_leveling_enabled_1:
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock41

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`set_bed_leveling_enabled(bool){3}{5}{8}{9}::reset`:
        DC32 0C61C3FFFH, 0C61C3FFFH, 0H
// 2889 
// 2890 
// 2891   #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
// 2892 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock42 Using cfiCommon0
          CFI Function _Z17set_z_fade_heightf
        THUMB
// 2893     void set_z_fade_height(const float zfh) {
_Z17set_z_fade_heightf:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOV      R2,R0
// 2894       planner.z_fade_height = zfh;
        LDR.W    R0,??DataTable126_7
        STR      R2,[R0, #+0]
// 2895       planner.inverse_z_fade_height = RECIPROCAL(zfh);
        MOV      R0,R2
        LDR.W    R1,??DataTable126_8  ;; 0xb58637bd
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??set_z_fade_height_0
        LDR.W    R1,??DataTable127  ;; 0x358637be
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??set_z_fade_height_0
        MOVS     R0,#+0
        LDR.W    R1,??DataTable127_1
        STR      R0,[R1, #+0]
        B.N      ??set_z_fade_height_1
??set_z_fade_height_0:
        MOV      R0,#+1065353216
        MOV      R1,R2
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        LDR.W    R1,??DataTable127_1
        STR      R0,[R1, #+0]
// 2896 
// 2897 /*--mks cfg--begin MESH_BED_LEVELING */
// 2898 /*
// 2899       if (
// 2900         #if ENABLED(MESH_BED_LEVELING)
// 2901           mbl.active()
// 2902         #else
// 2903           planner.abl_enabled
// 2904         #endif
// 2905       ) {
// 2906         set_current_from_steppers_for_axis(
// 2907           #if ABL_PLANAR
// 2908             ALL_AXES
// 2909           #else
// 2910             Z_AXIS
// 2911           #endif
// 2912         );
// 2913       }
// 2914 */
// 2915 	if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
??set_z_fade_height_1:
        LDR.W    R0,??DataTable126_2
        LDRB     R1,[R0, #+64]
        CMP      R1,#+32
        BNE.N    ??set_z_fade_height_2
// 2916 		{
// 2917 		if(mbl.active())
          CFI FunCall _ZN17mesh_bed_leveling6activeEv
        BL       _ZN17mesh_bed_leveling6activeEv
        CMP      R0,#+0
        BEQ.N    ??set_z_fade_height_3
// 2918 			{
// 2919 				if(BED_LEVELING_METHOD&ABL_PLANAR)
// 2920 					{set_current_from_steppers_for_axis(ALL_AXES);}
// 2921 				else
// 2922 					{set_current_from_steppers_for_axis(Z_AXIS);}
        MOVS     R0,#+2
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z34set_current_from_steppers_for_axis8AxisEnum
        B.W      _Z34set_current_from_steppers_for_axis8AxisEnum
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 2923 			}
// 2924 		}
// 2925 	else
// 2926 		{
// 2927 		if(planner.abl_enabled)
??set_z_fade_height_2:
        LDR.W    R0,??DataTable126_6
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??set_z_fade_height_3
// 2928 			{
// 2929 			if(BED_LEVELING_METHOD&ABL_PLANAR)
        TST      R1,#0x6
        BEQ.N    ??set_z_fade_height_4
// 2930 				{set_current_from_steppers_for_axis(ALL_AXES);}
        MOVS     R0,#+100
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z34set_current_from_steppers_for_axis8AxisEnum
        B.W      _Z34set_current_from_steppers_for_axis8AxisEnum
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 2931 			else
// 2932 				{set_current_from_steppers_for_axis(Z_AXIS);}
??set_z_fade_height_4:
        MOVS     R0,#+2
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z34set_current_from_steppers_for_axis8AxisEnum
        B.W      _Z34set_current_from_steppers_for_axis8AxisEnum
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 2933 			}
// 2934 		}
// 2935 /*--mks cfg--end MESH_BED_LEVELING */		
// 2936     }
??set_z_fade_height_3:
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock42

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable115:
        DC32     _ZN18DATA_REPRINT_ITMESD1Ev
// 2937 
// 2938   #endif // LEVELING_FADE_HEIGHT
// 2939 
// 2940   /**
// 2941    * Reset calibration results to zero.
// 2942    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock43 Using cfiCommon0
          CFI Function _Z15reset_bed_levelv
        THUMB
// 2943   void reset_bed_level() {
_Z15reset_bed_levelv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
// 2944     set_bed_leveling_enabled(false);
        MOVS     R0,#+0
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
// 2945 	
// 2946 	/*--mks cfg--begin AUTO_BED_LEVELING_BILINEAR */
// 2947 /*	
// 2948     #if ENABLED(MESH_BED_LEVELING)
// 2949       if (mbl.has_mesh()) {
// 2950         mbl.reset();
// 2951         mbl.set_has_mesh(false);
// 2952       }
// 2953     #else
// 2954       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2955         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("reset_bed_level");
// 2956       #endif
// 2957       #if ABL_PLANAR
// 2958         planner.bed_level_matrix.set_to_identity();
// 2959       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 2960         bilinear_start[X_AXIS] = bilinear_start[Y_AXIS] =
// 2961         bilinear_grid_spacing[X_AXIS] = bilinear_grid_spacing[Y_AXIS] = 0;
// 2962         for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
// 2963           for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
// 2964             z_values[x][y] = NAN;
// 2965       #elif ENABLED(AUTO_BED_LEVELING_UBL)
// 2966         ubl.reset();
// 2967       #endif
// 2968     #endif
// 2969 */
// 2970 
// 2971 	if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
        LDR.W    R0,??DataTable126_2
        LDRB     R1,[R0, #+64]
        CMP      R1,#+32
        BNE.N    ??reset_bed_level_0
// 2972 {
// 2973 		  if (mbl.has_mesh()) {
          CFI FunCall _ZN17mesh_bed_leveling8has_meshEv
        BL       _ZN17mesh_bed_leveling8has_meshEv
        CMP      R0,#+0
        BEQ.N    ??reset_bed_level_1
// 2974 			mbl.reset();
          CFI FunCall _ZN17mesh_bed_leveling5resetEv
        BL       _ZN17mesh_bed_leveling5resetEv
// 2975 			mbl.set_has_mesh(false);
        MOVS     R0,#+0
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN17mesh_bed_leveling12set_has_meshEb
        B.W      _ZN17mesh_bed_leveling12set_has_meshEb
          CFI R4 Frame(CFA, -16)
          CFI R5 Frame(CFA, -12)
          CFI R6 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
// 2976 		  }
// 2977 }
// 2978 else
// 2979 {
// 2980 
// 2981   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2982 			  if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("reset_bed_level");
// 2983   #endif
// 2984   if(BED_LEVELING_METHOD&ABL_PLANAR)
??reset_bed_level_0:
        TST      R1,#0x6
        BEQ.N    ??reset_bed_level_2
// 2985   	{
// 2986   	planner.bed_level_matrix.set_to_identity();
        LDR.W    R0,??DataTable127_2
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10matrix_3x315set_to_identityEv
        B.W      _ZN10matrix_3x315set_to_identityEv
          CFI R4 Frame(CFA, -16)
          CFI R5 Frame(CFA, -12)
          CFI R6 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
// 2987   	}
// 2988   else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
??reset_bed_level_2:
        CMP      R1,#+8
        BNE.N    ??reset_bed_level_3
// 2989   	{
// 2990 	  bilinear_start[X_AXIS] = bilinear_start[Y_AXIS] =
// 2991 	  bilinear_grid_spacing[X_AXIS] = bilinear_grid_spacing[Y_AXIS] = 0;
        LDR.W    R1,??DataTable126_5
        MOVS     R2,#+0
        STR      R2,[R1, #+12]
        STR      R2,[R1, #+8]
        STR      R2,[R1, #+20]
        STR      R2,[R1, #+16]
// 2992 	  for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
        MOV      R1,R2
        ADD      R3,R0,#+96
        MVN      R6,#-2147483648
        B.N      ??reset_bed_level_4
// 2993 		for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
// 2994 		  z_values[x][y] = NAN;
??reset_bed_level_5:
        LDR.W    R4,??DataTable127_3
        ADD      R4,R4,R1, LSL #+6
        MOV      R5,R2
        UXTB     R5,R5
        STR      R6,[R4, R5, LSL #+2]
        ADDS     R2,R2,#+1
??reset_bed_level_6:
        MOV      R4,R2
        LDRB     R5,[R3, #+1]
        UXTB     R4,R4
        CMP      R4,R5
        BCC.N    ??reset_bed_level_5
        ADDS     R1,R1,#+1
        UXTB     R1,R1
??reset_bed_level_4:
        LDRB     R2,[R3, #+0]
        CMP      R1,R2
        BGE.N    ??reset_bed_level_1
        MOVS     R2,#+0
        B.N      ??reset_bed_level_6
// 2995   	
// 2996   	}
// 2997   else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
??reset_bed_level_3:
        CMP      R1,#+16
        BNE.N    ??reset_bed_level_1
// 2998   	{
// 2999   	ubl.reset();
        LDR.W    R0,??DataTable129
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN20unified_bed_leveling5resetEv
        B.W      _ZN20unified_bed_leveling5resetEv
          CFI R4 Frame(CFA, -16)
          CFI R5 Frame(CFA, -12)
          CFI R6 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
// 3000   	}
// 3001 }
// 3002 	
// 3003 	/*--mks cfg--end AUTO_BED_LEVELING_BILINEAR */
// 3004   }
??reset_bed_level_1:
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock43

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable116:
        DC32     home_bump_mm_P

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable116_1:
        DC32     injected_commands_P

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable116_2:
        DC32     axis_relative_modes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable116_3:
        DC32     echomagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable116_4:
        DC32     customizedSerial

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable116_5:
        DC32     serial2

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable116_6:
        DC32     errormagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable116_7:
        DC32     axis_homed
// 3005 
// 3006 #endif // HAS_LEVELING
// 3007 
// 3008 //#if ENABLED(AUTO_BED_LEVELING_BILINEAR) || ENABLED(MESH_BED_LEVELING)
// 3009 #if 1   /*--mks cfg--end AUTO_BED_LEVELING_BILINEAR */
// 3010   /**
// 3011    * Enable to produce output in JSON format suitable
// 3012    * for SCAD or JavaScript mesh visualizers.
// 3013    *
// 3014    * Visualize meshes in OpenSCAD using the included script.
// 3015    *
// 3016    *   buildroot/shared/scripts/MarlinMesh.scad
// 3017    */
// 3018   //#define SCAD_MESH_OUTPUT
// 3019 
// 3020   /**
// 3021    * Print calibration results for plotting or manual frame adjustment.
// 3022    */
// 3023    /*--mks cfg-- LCD_ MESH_BED_LEVELING */
// 3024   //static void print_2d_array(const uint8_t sx, const uint8_t sy, const uint8_t precision, float (*fn)(const uint8_t, const uint8_t)) {

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock44 Using cfiCommon0
          CFI Function _ZN37_INTERNAL_15_Marlin_main_cpp_3178531914print_2d_arrayEhhhh
        THUMB
// 3025   static void print_2d_array(const uint8_t sx, const uint8_t sy, const uint8_t precision, const uint8_t fn) {
_ZN37_INTERNAL_15_Marlin_main_cpp_3178531914print_2d_arrayEhhhh:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R6,R0
        MOV      R10,R1
        MOV      R4,R2
        MOV      R9,R3
// 3026     #ifndef SCAD_MESH_OUTPUT
// 3027       for (uint8_t x = 0; x < sx; x++) {
        MOVS     R7,#+0
        LDR.W    R5,??DataTable126_1
        B.N      ??print_2d_array_0
// 3028         for (uint8_t i = 0; i < precision + 2 + (x < 10 ? 1 : 0); i++)
// 3029           SERIAL_PROTOCOLCHAR(' ');
// 3030         SERIAL_PROTOCOL((int)x);
??print_2d_array_1:
        MOVS     R2,#+10
        MOV      R1,R7
        LDR.W    R0,??DataTable129_1
          CFI FunCall _ZN12MarlinSerial5printEii
        BL       _ZN12MarlinSerial5printEii
        B.N      ??print_2d_array_2
??print_2d_array_3:
        CMP      R0,#+0
        BNE.N    ??print_2d_array_1
        MOVS     R2,#+10
        MOV      R1,R7
        LDR.W    R0,??DataTable128
          CFI FunCall _ZN12MarlinSerial5printEii
        BL       _ZN12MarlinSerial5printEii
??print_2d_array_2:
        ADDS     R7,R7,#+1
        UXTB     R7,R7
??print_2d_array_0:
        MOV      R8,R6
        CMP      R7,R8
        BGE.N    ??print_2d_array_4
        MOV      R8,#+0
        B.N      ??print_2d_array_5
??print_2d_array_6:
        MOVS     R2,#+0
        MOVS     R1,#+32
        LDR.W    R0,??DataTable129_1
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
        B.N      ??print_2d_array_7
??print_2d_array_8:
        MOVS     R1,#+0
??print_2d_array_9:
        LDRB     R0,[R5, #+7]
        MOV      R2,R8
        UXTB     R2,R2
        MOV      R3,R4
        ADDS     R1,R1,R3
        ADDS     R1,R1,#+2
        CMP      R2,R1
        BGE.N    ??print_2d_array_3
        CMP      R0,#+0
        BNE.N    ??print_2d_array_6
        MOVS     R1,#+32
        LDR.W    R0,??DataTable128
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
??print_2d_array_7:
        ADD      R8,R8,#+1
??print_2d_array_5:
        CMP      R7,#+10
        BGE.N    ??print_2d_array_8
        MOVS     R1,#+1
        B.N      ??print_2d_array_9
// 3031       }
// 3032       SERIAL_EOL;
??print_2d_array_4:
        LDRB     R0,[R5, #+7]
        CMP      R0,#+0
        BNE.N    ??print_2d_array_10
        MOVS     R1,#+10
        LDR.W    R0,??DataTable128
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??print_2d_array_11
??print_2d_array_10:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.W    R0,??DataTable129_1
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
// 3033     #endif
// 3034     #ifdef SCAD_MESH_OUTPUT
// 3035       SERIAL_PROTOCOLLNPGM("measured_z = ["); // open 2D array
// 3036     #endif
// 3037     for (uint8_t y = 0; y < sy; y++) {
??print_2d_array_11:
        MOVS     R6,#+0
        B.N      ??print_2d_array_12
// 3038       #ifdef SCAD_MESH_OUTPUT
// 3039         SERIAL_PROTOCOLLNPGM(" [");           // open sub-array
// 3040       #else
// 3041         if (y < 10) SERIAL_PROTOCOLCHAR(' ');
// 3042         SERIAL_PROTOCOL((int)y);
// 3043       #endif
// 3044       for (uint8_t x = 0; x < sx; x++) {
// 3045         SERIAL_PROTOCOLCHAR(' ');
// 3046         //const float offset = fn(x, y); /*--mks cfg-- LCD_ MESH_BED_LEVELING */
// 3047         float offset;
// 3048 		switch(fn)
// 3049 			{
// 3050 			case 0:	
// 3051 			if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
// 3052 				offset =z_values[x][y];
// 3053 			break;
// 3054 			case 1:	
// 3055 			#if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 3056 				offset =z_values_virt[x][y];	
// 3057 			#endif
// 3058 			break;
// 3059 			case 2:	
// 3060 				if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
// 3061                    offset =mbl.z_values[x][y];		
// 3062                           break;
// 3063 			default:		break;
// 3064 			}
// 3065 		
// 3066         if (!isnan(offset)) {
// 3067           if (offset >= 0) SERIAL_PROTOCOLCHAR('+');
// 3068           SERIAL_PROTOCOL_F(offset, precision);
// 3069         }
// 3070         else {
// 3071           #ifdef SCAD_MESH_OUTPUT
// 3072             for (uint8_t i = 3; i < precision + 3; i++)
// 3073               SERIAL_PROTOCOLCHAR(' ');
// 3074             SERIAL_PROTOCOLPGM("NAN");
// 3075           #else
// 3076             for (uint8_t i = 0; i < precision + 3; i++)
// 3077               SERIAL_PROTOCOLCHAR(i ? '=' : ' ');
// 3078           #endif
// 3079         }
// 3080         #ifdef SCAD_MESH_OUTPUT
// 3081           if (x < sx - 1) SERIAL_PROTOCOLCHAR(',');
// 3082         #endif
// 3083       }
// 3084       #ifdef SCAD_MESH_OUTPUT
// 3085         SERIAL_PROTOCOLCHAR(' ');
// 3086         SERIAL_PROTOCOLCHAR(']');                     // close sub-array
// 3087         if (y < sy - 1) SERIAL_PROTOCOLCHAR(',');
// 3088       #endif
// 3089       SERIAL_EOL;
??print_2d_array_13:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.W    R0,??DataTable129_1
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
        B.N      ??print_2d_array_14
??print_2d_array_15:
        CMP      R0,#+0
        BNE.N    ??print_2d_array_13
        MOVS     R1,#+10
        LDR.W    R0,??DataTable128
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
??print_2d_array_14:
        ADDS     R6,R6,#+1
        UXTB     R6,R6
??print_2d_array_12:
        MOV      R0,R10
        CMP      R6,R0
        BGE.W    ??print_2d_array_16
        CMP      R6,#+10
        BGE.N    ??print_2d_array_17
        LDRB     R0,[R5, #+7]
        CMP      R0,#+0
        BNE.N    ??print_2d_array_18
        MOVS     R1,#+32
        LDR.W    R0,??DataTable128
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??print_2d_array_17
??print_2d_array_18:
        MOVS     R2,#+0
        MOVS     R1,#+32
        LDR.W    R0,??DataTable129_1
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
??print_2d_array_17:
        LDRB     R0,[R5, #+7]
        CMP      R0,#+0
        BNE.N    ??print_2d_array_19
        MOVS     R2,#+10
        MOV      R1,R6
        LDR.W    R0,??DataTable128
          CFI FunCall _ZN12MarlinSerial5printEii
        BL       _ZN12MarlinSerial5printEii
        B.N      ??print_2d_array_20
??print_2d_array_19:
        MOVS     R2,#+10
        MOV      R1,R6
        LDR.W    R0,??DataTable129_1
          CFI FunCall _ZN12MarlinSerial5printEii
        BL       _ZN12MarlinSerial5printEii
??print_2d_array_20:
        MOVS     R7,#+0
        B.N      ??print_2d_array_21
??print_2d_array_22:
        MOVS     R2,#+0
        MOVS     R1,#+32
        LDR.W    R0,??DataTable129_1
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
??print_2d_array_23:
        MOV      R0,R9
        CMP      R0,#+0
        BEQ.N    ??print_2d_array_24
        CMP      R0,#+2
        BEQ.N    ??print_2d_array_25
        B.N      ??print_2d_array_26
??print_2d_array_24:
        LDR.W    R0,??DataTable126_2
        LDRB     R0,[R0, #+64]
        CMP      R0,#+8
        BNE.N    ??print_2d_array_26
        LDR.W    R0,??DataTable127_3
        ADD      R0,R0,R7, LSL #+6
        LDR      R11,[R0, R6, LSL #+2]
        B.N      ??print_2d_array_26
??print_2d_array_25:
        LDR.W    R0,??DataTable126_2
        LDRB     R0,[R0, #+64]
        CMP      R0,#+32
        BNE.N    ??print_2d_array_26
        LDR.W    R0,??DataTable130
        ADD      R0,R0,R7, LSL #+6
        LDR      R11,[R0, R6, LSL #+2]
??print_2d_array_26:
        MOV      R0,R11
          CFI FunCall _Z5isnanf
        BL       _Z5isnanf
        CMP      R0,#+0
        BNE.N    ??print_2d_array_27
        MOV      R0,R11
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??print_2d_array_28
        LDRB     R0,[R5, #+7]
        CMP      R0,#+0
        BNE.N    ??print_2d_array_29
        MOVS     R1,#+43
        LDR.W    R0,??DataTable128
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??print_2d_array_28
??print_2d_array_29:
        MOV      R2,R1
        MOVS     R1,#+43
        LDR.W    R0,??DataTable129_1
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
??print_2d_array_28:
        MOV      R0,R11
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R3,R4
        LDRB     R2,[R5, #+7]
        CMP      R2,#+0
        STR      R3,[SP, #+0]
        MOV      R2,R0
        MOV      R3,R1
        BNE.N    ??print_2d_array_30
        LDR.W    R0,??DataTable128
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
??print_2d_array_31:
        ADDS     R7,R7,#+1
        UXTB     R7,R7
??print_2d_array_21:
        LDRB     R0,[R5, #+7]
        CMP      R7,R8
        BGE.W    ??print_2d_array_15
        CMP      R0,#+0
        BNE.N    ??print_2d_array_22
        MOVS     R1,#+32
        LDR.W    R0,??DataTable128
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??print_2d_array_23
??print_2d_array_30:
        LDR.W    R0,??DataTable129_1
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
        B.N      ??print_2d_array_31
??print_2d_array_27:
        MOVS     R0,#+0
        MOV      R11,R4
        MOV      R4,R0
        B.N      ??print_2d_array_32
??print_2d_array_33:
        MOVS     R1,#+32
        B.N      ??print_2d_array_34
??print_2d_array_35:
        CMP      R4,#+0
        BEQ.N    ??print_2d_array_33
        MOVS     R1,#+61
??print_2d_array_34:
        MOVS     R2,#+0
        LDR.W    R0,??DataTable129_1
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
??print_2d_array_36:
        ADDS     R4,R4,#+1
        UXTB     R4,R4
??print_2d_array_32:
        MOV      R0,R11
        ADDS     R0,R0,#+3
        CMP      R4,R0
        BGE.N    ??print_2d_array_37
        LDRB     R0,[R5, #+7]
        CMP      R0,#+0
        BNE.N    ??print_2d_array_35
        CMP      R4,#+0
        BEQ.N    ??print_2d_array_38
        MOVS     R1,#+61
        B.N      ??print_2d_array_39
??print_2d_array_38:
        MOVS     R1,#+32
??print_2d_array_39:
        LDR.W    R0,??DataTable128
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??print_2d_array_36
// 3090     }
// 3091     #ifdef SCAD_MESH_OUTPUT
// 3092       SERIAL_PROTOCOLPGM("\n];");                     // close 2D array
// 3093     #endif
// 3094     SERIAL_EOL;
??print_2d_array_16:
        LDRB     R0,[R5, #+7]
        CMP      R0,#+0
        BNE.N    ??print_2d_array_40
        MOVS     R1,#+10
        LDR.W    R0,??DataTable128
        POP      {R2,R4-R11,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN12MarlinSerial5writeEh
        B.W      _ZN12MarlinSerial5writeEh
          CFI R4 Frame(CFA, -36)
          CFI R5 Frame(CFA, -32)
          CFI R6 Frame(CFA, -28)
          CFI R7 Frame(CFA, -24)
          CFI R8 Frame(CFA, -20)
          CFI R9 Frame(CFA, -16)
          CFI R10 Frame(CFA, -12)
          CFI R11 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+40
??print_2d_array_40:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.W    R0,??DataTable129_1
        POP      {R3-R11,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN12MarlinSerial5printEci
        B.W      _ZN12MarlinSerial5printEci
          CFI R4 Frame(CFA, -36)
          CFI R5 Frame(CFA, -32)
          CFI R6 Frame(CFA, -28)
          CFI R7 Frame(CFA, -24)
          CFI R8 Frame(CFA, -20)
          CFI R9 Frame(CFA, -16)
          CFI R10 Frame(CFA, -12)
          CFI R11 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+40
??print_2d_array_37:
        MOV      R4,R11
        B.N      ??print_2d_array_31
// 3095   }
          CFI EndBlock cfiBlock44
// 3096 
// 3097 #endif
// 3098 
// 3099 //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 3100 #if 1  /*--mks cfg-- AUTO_BED_LEVELING_BILINEAR */
// 3101 
// 3102   /**
// 3103    * Extrapolate a single point from its neighbors
// 3104    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock45 Using cfiCommon0
          CFI Function _ZN37_INTERNAL_15_Marlin_main_cpp_3178531921extrapolate_one_pointEhhaa
        THUMB
// 3105   static void extrapolate_one_point(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir) {
_ZN37_INTERNAL_15_Marlin_main_cpp_3178531921extrapolate_one_pointEhhaa:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R9,R0
        MOV      R8,R1
        MOV      R7,R2
        MOV      R10,R3
// 3106     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3107       if (DEBUGGING(LEVELING)) {
// 3108         SERIAL_ECHOPGM("Extrapolate [");
// 3109         if (x < 10) SERIAL_CHAR(' ');
// 3110         SERIAL_ECHO((int)x);
// 3111         SERIAL_CHAR(xdir ? (xdir > 0 ? '+' : '-') : ' ');
// 3112         SERIAL_CHAR(' ');
// 3113         if (y < 10) SERIAL_CHAR(' ');
// 3114         SERIAL_ECHO((int)y);
// 3115         SERIAL_CHAR(ydir ? (ydir > 0 ? '+' : '-') : ' ');
// 3116         SERIAL_CHAR(']');
// 3117       }
// 3118     #endif
// 3119     if (!isnan(z_values[x][y])) {
        LDR.W    R6,??DataTable127_3
        ADDS     R4,R6,R0, LSL #+6
        MOV      R5,R8
        LDR      R0,[R4, R5, LSL #+2]
          CFI FunCall _Z5isnanf
        BL       _Z5isnanf
        CMP      R0,#+0
        BEQ.N    ??extrapolate_one_point_0
// 3120       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3121         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM(" (done)");
// 3122       #endif
// 3123       return;  // Don't overwrite good values.
// 3124     }
// 3125     SERIAL_EOL;
        LDR.W    R0,??DataTable126_1
        LDRB     R0,[R0, #+7]
        CMP      R0,#+0
        BNE.N    ??extrapolate_one_point_1
        MOVS     R1,#+10
        LDR.W    R0,??DataTable128
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??extrapolate_one_point_2
??extrapolate_one_point_1:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.W    R0,??DataTable129_1
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
// 3126 
// 3127     // Get X neighbors, Y neighbors, and XY neighbors
// 3128     const uint8_t x1 = x + xdir, y1 = y + ydir, x2 = x1 + xdir, y2 = y1 + ydir;
??extrapolate_one_point_2:
        ADD      R9,R7,R9
        UXTB     R9,R9
        ADD      R8,R10,R8
        UXTB     R8,R8
// 3129     float a1 = z_values[x1][y ], a2 = z_values[x2][y ],
        ADD      R0,R6,R9, LSL #+6
        LDR      R1,[R0, R5, LSL #+2]
        STR      R1,[SP, #+0]
        ADD      R7,R7,R9
        UXTB     R7,R7
        ADDS     R1,R6,R7, LSL #+6
        LDR      R6,[R1, R5, LSL #+2]
// 3130           b1 = z_values[x ][y1], b2 = z_values[x ][y2],
        LDR      R7,[R4, R8, LSL #+2]
        ADD      R10,R10,R8
        UXTB     R10,R10
        LDR      R9,[R4, R10, LSL #+2]
// 3131           c1 = z_values[x1][y1], c2 = z_values[x2][y2];
        LDR      R8,[R0, R8, LSL #+2]
        LDR      R10,[R1, R10, LSL #+2]
// 3132 
// 3133     // Treat far unprobed points as zero, near as equal to far
// 3134     if (isnan(a2)) a2 = 0.0; if (isnan(a1)) a1 = a2;
        MOV      R0,R6
          CFI FunCall _Z5isnanf
        BL       _Z5isnanf
        CMP      R0,#+0
        BEQ.N    ??extrapolate_one_point_3
        MOVS     R6,#+0
??extrapolate_one_point_3:
        LDR      R0,[SP, #+0]
          CFI FunCall _Z5isnanf
        BL       _Z5isnanf
        CMP      R0,#+0
        BEQ.N    ??extrapolate_one_point_4
        STR      R6,[SP, #+0]
// 3135     if (isnan(b2)) b2 = 0.0; if (isnan(b1)) b1 = b2;
??extrapolate_one_point_4:
        MOV      R0,R9
          CFI FunCall _Z5isnanf
        BL       _Z5isnanf
        CMP      R0,#+0
        BEQ.N    ??extrapolate_one_point_5
        MOV      R9,#+0
??extrapolate_one_point_5:
        MOV      R0,R7
          CFI FunCall _Z5isnanf
        BL       _Z5isnanf
        CMP      R0,#+0
        BEQ.N    ??extrapolate_one_point_6
        MOV      R7,R9
// 3136     if (isnan(c2)) c2 = 0.0; if (isnan(c1)) c1 = c2;
??extrapolate_one_point_6:
        MOV      R0,R10
          CFI FunCall _Z5isnanf
        BL       _Z5isnanf
        CMP      R0,#+0
        BEQ.N    ??extrapolate_one_point_7
        MOV      R10,#+0
??extrapolate_one_point_7:
        MOV      R0,R8
          CFI FunCall _Z5isnanf
        BL       _Z5isnanf
        CMP      R0,#+0
        BEQ.N    ??extrapolate_one_point_8
        MOV      R8,R10
// 3137 
// 3138     const float a = 2 * a1 - a2, b = 2 * b1 - b2, c = 2 * c1 - c2;
// 3139 
// 3140     // Take the average instead of the median
// 3141     z_values[x][y] = (a + b + c) / 3.0;
??extrapolate_one_point_8:
        MOV      R11,#+1073741824
        LDR      R0,[SP, #+0]
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R6
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R6,R0
        MOV      R0,R7
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R6
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R6,R0
        MOV      R0,R8
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R10
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R6
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR.W    R1,??DataTable131  ;; 0x40400000
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[R4, R5, LSL #+2]
// 3142 
// 3143     // Median is robust (ignores outliers).
// 3144     // z_values[x][y] = (a < b) ? ((b < c) ? b : (c < a) ? a : c)
// 3145     //                                : ((c < b) ? b : (a < c) ? a : c);
// 3146   }
??extrapolate_one_point_0:
        POP      {R0,R4-R11,PC}   ;; return
          CFI EndBlock cfiBlock45
// 3147 
// 3148   //Enable this if your SCARA uses 180Â° of total area
// 3149   //#define EXTRAPOLATE_FROM_EDGE
// 3150 
// 3151   #if ENABLED(EXTRAPOLATE_FROM_EDGE)
// 3152     #if GRID_MAX_POINTS_X < GRID_MAX_POINTS_Y
// 3153       #define HALF_IN_X
// 3154     #elif GRID_MAX_POINTS_Y < GRID_MAX_POINTS_X
// 3155       #define HALF_IN_Y
// 3156     #endif
// 3157   #endif
// 3158 
// 3159   /**
// 3160    * Fill in the unprobed points (corners of circular print surface)
// 3161    * using linear extrapolation, away from the center.
// 3162    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock46 Using cfiCommon0
          CFI Function _ZN37_INTERNAL_15_Marlin_main_cpp_3178531930extrapolate_unprobed_bed_levelEv
        THUMB
// 3163   static void extrapolate_unprobed_bed_level() {
_ZN37_INTERNAL_15_Marlin_main_cpp_3178531930extrapolate_unprobed_bed_levelEv:
        PUSH     {R1-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+48
// 3164     #ifdef HALF_IN_X
// 3165       constexpr uint8_t ctrx2 = 0, xlen = GRID_MAX_POINTS_X - 1;
// 3166     #else
// 3167       constexpr uint8_t ctrx1 = (GRID_MAX_POINTS_X - 1) / 2, // left-of-center
        LDR.W    R0,??DataTable131_1
        LDRB     R5,[R0, #+0]
        MOV      R4,R5
        SUBS     R4,R4,#+1
        ADD      R4,R4,R4, LSR #+31
        ASRS     R4,R4,#+1
        UXTB     R4,R4
// 3168                         ctrx2 = (GRID_MAX_POINTS_X) / 2,     // right-of-center
// 3169                         xlen = ctrx1;
        MOV      R1,R4
        STR      R1,[SP, #+4]
// 3170     #endif
// 3171 
// 3172     #ifdef HALF_IN_Y
// 3173       constexpr uint8_t ctry2 = 0, ylen = GRID_MAX_POINTS_Y - 1;
// 3174     #else
// 3175       constexpr uint8_t ctry1 = (GRID_MAX_POINTS_Y - 1) / 2, // top-of-center
        LDRB     R7,[R0, #+1]
        MOV      R6,R7
        SUBS     R6,R6,#+1
        ADD      R6,R6,R6, LSR #+31
        ASRS     R6,R6,#+1
        UXTB     R6,R6
// 3176                         ctry2 = (GRID_MAX_POINTS_Y) / 2,     // bottom-of-center
// 3177                         ylen = ctry1;
        MOV      R8,R6
// 3178     #endif
// 3179 
// 3180     for (uint8_t xo = 0; xo <= xlen; xo++)
        MOV      R9,#+0
        B.N      ??extrapolate_unprobed_bed_level_0
// 3181       for (uint8_t yo = 0; yo <= ylen; yo++) {
// 3182         uint8_t x2 = ctrx2 + xo, y2 = ctry2 + yo;
??extrapolate_unprobed_bed_level_1:
        ADD      R0,R9,R5, LSR #+1
        STRB     R0,[SP, #+2]
        ADD      R0,R10,R7, LSR #+1
        STRB     R0,[SP, #+1]
// 3183         #ifndef HALF_IN_X
// 3184           const uint8_t x1 = ctrx1 - xo;
        SUB      R0,R4,R9
        STRB     R0,[SP, #+0]
// 3185         #endif
// 3186         #ifndef HALF_IN_Y
// 3187           const uint8_t y1 = ctry1 - yo;
        SUB      R11,R6,R10
// 3188           #ifndef HALF_IN_X
// 3189             extrapolate_one_point(x1, y1, +1, +1);   //  left-below + +
        MOVS     R3,#+1
        MOV      R2,R3
        MOV      R1,R11
        UXTB     R1,R1
        LDRB     R0,[SP, #+0]
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531921extrapolate_one_pointEhhaa
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531921extrapolate_one_pointEhhaa
// 3190           #endif
// 3191           extrapolate_one_point(x2, y1, -1, +1);     // right-below - +
        MOVS     R3,#+1
        MOV      R2,#-1
        MOV      R1,R11
        UXTB     R1,R1
        LDRB     R0,[SP, #+2]
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531921extrapolate_one_pointEhhaa
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531921extrapolate_one_pointEhhaa
// 3192         #endif
// 3193         #ifndef HALF_IN_X
// 3194           extrapolate_one_point(x1, y2, +1, -1);     //  left-above + -
        MOV      R3,#-1
        MOVS     R2,#+1
        LDRB     R1,[SP, #+1]
        LDRB     R0,[SP, #+0]
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531921extrapolate_one_pointEhhaa
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531921extrapolate_one_pointEhhaa
// 3195         #endif
// 3196         extrapolate_one_point(x2, y2, -1, -1);       // right-above - -
        MOV      R3,#-1
        MOV      R2,R3
        LDRB     R1,[SP, #+1]
        LDRB     R0,[SP, #+2]
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531921extrapolate_one_pointEhhaa
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531921extrapolate_one_pointEhhaa
// 3197       }
        ADD      R10,R10,#+1
        UXTB     R10,R10
??extrapolate_unprobed_bed_level_2:
        CMP      R8,R10
        BGE.N    ??extrapolate_unprobed_bed_level_1
        ADD      R9,R9,#+1
        UXTB     R9,R9
??extrapolate_unprobed_bed_level_0:
        LDR      R0,[SP, #+4]
        CMP      R0,R9
        BLT.N    ??extrapolate_unprobed_bed_level_3
        MOV      R10,#+0
        B.N      ??extrapolate_unprobed_bed_level_2
// 3198 
// 3199   }
??extrapolate_unprobed_bed_level_3:
        POP      {R0-R2,R4-R11,PC}  ;; return
          CFI EndBlock cfiBlock46
// 3200 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock47 Using cfiCommon0
          CFI Function _ZN37_INTERNAL_15_Marlin_main_cpp_3178531928print_bilinear_leveling_gridEv
        THUMB
// 3201   static void print_bilinear_leveling_grid() {
_ZN37_INTERNAL_15_Marlin_main_cpp_3178531928print_bilinear_leveling_gridEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 3202     SERIAL_ECHOLNPGM("Bilinear Leveling Grid:");
        ADR.W    R0,?_13
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 3203 	/*--mks cfg-- LCD_ MESH_BED_LEVELING */
// 3204 	/*
// 3205     print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 3,
// 3206       [](const uint8_t ix, const uint8_t iy) { return z_values[ix][iy]; }
// 3207     );
// 3208 	*/
// 3209     print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 3,0);
        LDR.W    R0,??DataTable131_1
        MOVS     R3,#+0
        MOVS     R2,#+3
        LDRB     R1,[R0, #+1]
        LDRB     R0,[R0, #+0]
        POP      {R12,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531914print_2d_arrayEhhhh
        B.N      _ZN37_INTERNAL_15_Marlin_main_cpp_3178531914print_2d_arrayEhhhh
// 3210   }
          CFI EndBlock cfiBlock47

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable120:
        DC32     0x47ae147b

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_13:
        DC8 "Bilinear Leveling Grid:\012"
        DC8 0, 0, 0
// 3211 
// 3212   #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 3213 
// 3214     #define ABL_GRID_POINTS_VIRT_X (GRID_MAX_POINTS_X - 1) * (BILINEAR_SUBDIVISIONS) + 1
// 3215     #define ABL_GRID_POINTS_VIRT_Y (GRID_MAX_POINTS_Y - 1) * (BILINEAR_SUBDIVISIONS) + 1
// 3216     #define ABL_TEMP_POINTS_X (GRID_MAX_POINTS_X + 2)
// 3217     #define ABL_TEMP_POINTS_Y (GRID_MAX_POINTS_Y + 2)
// 3218     float z_values_virt[ABL_GRID_POINTS_VIRT_X][ABL_GRID_POINTS_VIRT_Y];
// 3219     int bilinear_grid_spacing_virt[2] = { 0 };
// 3220     float bilinear_grid_factor_virt[2] = { 0 };
// 3221 
// 3222     static void bed_level_virt_print() {
// 3223       SERIAL_ECHOLNPGM("Subdivided with CATMULL ROM Leveling Grid:");
// 3224 	  /*--mks cfg-- LCD_ MESH_BED_LEVELING */
// 3225 	  /*
// 3226       print_2d_array(ABL_GRID_POINTS_VIRT_X, ABL_GRID_POINTS_VIRT_Y, 5,
// 3227         [](const uint8_t ix, const uint8_t iy) { return z_values_virt[ix][iy]; }
// 3228       );*/
// 3229       print_2d_array(ABL_GRID_POINTS_VIRT_X, ABL_GRID_POINTS_VIRT_Y, 5,1);
// 3230     }
// 3231 
// 3232     #define LINEAR_EXTRAPOLATION(E, I) ((E) * 2 - (I))
// 3233     float bed_level_virt_coord(const uint8_t x, const uint8_t y) {
// 3234       uint8_t ep = 0, ip = 1;
// 3235       if (!x || x == ABL_TEMP_POINTS_X - 1) {
// 3236         if (x) {
// 3237           ep = GRID_MAX_POINTS_X - 1;
// 3238           ip = GRID_MAX_POINTS_X - 2;
// 3239         }
// 3240         if (WITHIN(y, 1, ABL_TEMP_POINTS_Y - 2))
// 3241           return LINEAR_EXTRAPOLATION(
// 3242             z_values[ep][y - 1],
// 3243             z_values[ip][y - 1]
// 3244           );
// 3245         else
// 3246           return LINEAR_EXTRAPOLATION(
// 3247             bed_level_virt_coord(ep + 1, y),
// 3248             bed_level_virt_coord(ip + 1, y)
// 3249           );
// 3250       }
// 3251       if (!y || y == ABL_TEMP_POINTS_Y - 1) {
// 3252         if (y) {
// 3253           ep = GRID_MAX_POINTS_Y - 1;
// 3254           ip = GRID_MAX_POINTS_Y - 2;
// 3255         }
// 3256         if (WITHIN(x, 1, ABL_TEMP_POINTS_X - 2))
// 3257           return LINEAR_EXTRAPOLATION(
// 3258             z_values[x - 1][ep],
// 3259             z_values[x - 1][ip]
// 3260           );
// 3261         else
// 3262           return LINEAR_EXTRAPOLATION(
// 3263             bed_level_virt_coord(x, ep + 1),
// 3264             bed_level_virt_coord(x, ip + 1)
// 3265           );
// 3266       }
// 3267       return z_values[x - 1][y - 1];
// 3268     }
// 3269 
// 3270     static float bed_level_virt_cmr(const float p[4], const uint8_t i, const float t) {
// 3271       return (
// 3272           p[i-1] * -t * sq(1 - t)
// 3273         + p[i]   * (2 - 5 * sq(t) + 3 * t * sq(t))
// 3274         + p[i+1] * t * (1 + 4 * t - 3 * sq(t))
// 3275         - p[i+2] * sq(t) * (1 - t)
// 3276       ) * 0.5;
// 3277     }
// 3278 
// 3279     static float bed_level_virt_2cmr(const uint8_t x, const uint8_t y, const float &tx, const float &ty) {
// 3280       float row[4], column[4];
// 3281       for (uint8_t i = 0; i < 4; i++) {
// 3282         for (uint8_t j = 0; j < 4; j++) {
// 3283           column[j] = bed_level_virt_coord(i + x - 1, j + y - 1);
// 3284         }
// 3285         row[i] = bed_level_virt_cmr(column, 1, ty);
// 3286       }
// 3287       return bed_level_virt_cmr(row, 1, tx);
// 3288     }
// 3289 
// 3290     void bed_level_virt_interpolate() {
// 3291       bilinear_grid_spacing_virt[X_AXIS] = bilinear_grid_spacing[X_AXIS] / (BILINEAR_SUBDIVISIONS);
// 3292       bilinear_grid_spacing_virt[Y_AXIS] = bilinear_grid_spacing[Y_AXIS] / (BILINEAR_SUBDIVISIONS);
// 3293       bilinear_grid_factor_virt[X_AXIS] = RECIPROCAL(bilinear_grid_spacing_virt[X_AXIS]);
// 3294       bilinear_grid_factor_virt[Y_AXIS] = RECIPROCAL(bilinear_grid_spacing_virt[Y_AXIS]);
// 3295       for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
// 3296         for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
// 3297           for (uint8_t ty = 0; ty < BILINEAR_SUBDIVISIONS; ty++)
// 3298             for (uint8_t tx = 0; tx < BILINEAR_SUBDIVISIONS; tx++) {
// 3299               if ((ty && y == GRID_MAX_POINTS_Y - 1) || (tx && x == GRID_MAX_POINTS_X - 1))
// 3300                 continue;
// 3301               z_values_virt[x * (BILINEAR_SUBDIVISIONS) + tx][y * (BILINEAR_SUBDIVISIONS) + ty] =
// 3302                 bed_level_virt_2cmr(
// 3303                   x + 1,
// 3304                   y + 1,
// 3305                   (float)tx / (BILINEAR_SUBDIVISIONS),
// 3306                   (float)ty / (BILINEAR_SUBDIVISIONS)
// 3307                 );
// 3308             }
// 3309     }
// 3310   #endif // ABL_BILINEAR_SUBDIVISION
// 3311 
// 3312   // Refresh after other values have been updated

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock48 Using cfiCommon0
          CFI Function _Z17refresh_bed_levelv
        THUMB
// 3313   void refresh_bed_level() {
_Z17refresh_bed_levelv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 3314     bilinear_grid_factor[X_AXIS] = RECIPROCAL(bilinear_grid_spacing[X_AXIS]);
        LDR.W    R4,??DataTable126_5
        LDR      R0,[R4, #+8]
        CMP      R0,#+0
        BNE.N    ??refresh_bed_level_0
        MOVS     R0,#+0
        B.N      ??refresh_bed_level_1
??refresh_bed_level_0:
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        MOV      R2,R0
        MOV      R3,R1
        MOVS     R0,#+0
        LDR.W    R1,??DataTable133  ;; 0x3ff00000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
??refresh_bed_level_1:
        STR      R0,[R4, #+24]
// 3315     bilinear_grid_factor[Y_AXIS] = RECIPROCAL(bilinear_grid_spacing[Y_AXIS]);
        LDR      R0,[R4, #+12]
        CMP      R0,#+0
        BNE.N    ??refresh_bed_level_2
        MOVS     R0,#+0
        B.N      ??refresh_bed_level_3
??refresh_bed_level_2:
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        MOV      R2,R0
        MOV      R3,R1
        MOVS     R0,#+0
        LDR.W    R1,??DataTable133  ;; 0x3ff00000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
??refresh_bed_level_3:
        STR      R0,[R4, #+28]
// 3316     #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 3317       bed_level_virt_interpolate();
// 3318     #endif
// 3319   }
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock48

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable121:
        DC32     0x3f847ae1
// 3320 
// 3321 #endif // AUTO_BED_LEVELING_BILINEAR
// 3322 
// 3323 /**
// 3324  * Home an individual linear axis
// 3325  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock49 Using cfiCommon0
          CFI Function _ZN37_INTERNAL_15_Marlin_main_cpp_3178531914do_homing_moveE8AxisEnumff
        THUMB
// 3326 static void do_homing_move(const AxisEnum axis, float distance, float fr_mm_s=0.0) {
_ZN37_INTERNAL_15_Marlin_main_cpp_3178531914do_homing_moveE8AxisEnumff:
        PUSH     {R0-R2,R4-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+32
        MOV      R5,R1
// 3327 
// 3328   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3329     if (DEBUGGING(LEVELING)) {
// 3330       SERIAL_ECHOPAIR(">>> do_homing_move(", axis_codes[axis]);
// 3331       SERIAL_ECHOPAIR(", ", distance);
// 3332       SERIAL_ECHOPAIR(", ", fr_mm_s);
// 3333       SERIAL_CHAR(')');
// 3334       SERIAL_EOL;
// 3335     }
// 3336   #endif
// 3337 
// 3338   #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
// 3339   if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)){	/*--mks cfg--*/
// 3340     const bool deploy_bltouch = (axis == Z_AXIS && distance < 0);
// 3341     if (deploy_bltouch) set_bltouch_deployed(true);
// 3342   		}
// 3343   #endif
// 3344 
// 3345 #if QUIET_PROBING
// 3346     if (axis == Z_AXIS) probing_pause(true);
// 3347 #endif
// 3348 
// 3349   // Tell the planner we're at Z=0
// 3350   current_position[axis] = 0;
        LDR.W    R4,??DataTable126_1
        ADD      R6,R4,R0, LSL #+2
        MOVS     R0,#+0
        STR      R0,[R6, #+8]
// 3351 
// 3352  // #if IS_SCARA	//mks_delta
// 3353  if(MACHINETPYE&IS_SCARA) { 	
        LDR.W    R7,??DataTable126_2
        LDRH     R0,[R7, #+88]
        TST      R0,#0x300
        BEQ.N    ??do_homing_move_0
// 3354     SYNC_PLAN_POSITION_KINEMATIC();
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
// 3355     current_position[axis] = distance;
        STR      R5,[R6, #+8]
// 3356 	if(MACHINETPYE&IS_SCARA)
        LDRH     R0,[R7, #+88]
        TST      R0,#0x300
        ADD      R0,R4,#+8
        BEQ.N    ??do_homing_move_1
// 3357 		inverse_kinematics_MORGAN_SCARA(current_position);
          CFI FunCall _Z31inverse_kinematics_MORGAN_SCARAPKf
        BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
        B.N      ??do_homing_move_2
// 3358 		else
// 3359 	    inverse_kinematics(current_position);
??do_homing_move_1:
          CFI FunCall _Z18inverse_kinematicsPKf
        BL       _Z18inverse_kinematicsPKf
// 3360     planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate_mm_s[axis], active_extruder);
??do_homing_move_2:
        LDR      R0,[SP, #+8]
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??do_homing_move_3
        ADD      R0,SP,#+8
        B.N      ??do_homing_move_4
??do_homing_move_3:
        ADD      R0,R6,#+40
??do_homing_move_4:
        LDRB     R1,[R4, #+2]
        STR      R1,[SP, #+4]
        STR      R0,[SP, #+0]
        ADD      R3,R4,#+20
        LDR      R2,[R4, #+112]
        LDR      R1,[R4, #+108]
        LDR      R0,[R4, #+104]
          CFI FunCall _ZN7Planner11buffer_lineEfffRKfS1_h
        BL       _ZN7Planner11buffer_lineEfffRKfS1_h
        B.N      ??do_homing_move_5
// 3361  	}
// 3362 //  #else
// 3363 	else
// 3364 		{
// 3365     sync_plan_position();
??do_homing_move_0:
          CFI FunCall _Z18sync_plan_positionv
        BL       _Z18sync_plan_positionv
// 3366     current_position[axis] = distance;
        STR      R5,[R6, #+8]
// 3367     planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate_mm_s[axis], active_extruder);
        LDR      R0,[SP, #+8]
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??do_homing_move_6
        ADD      R0,SP,#+8
        B.N      ??do_homing_move_7
??do_homing_move_6:
        ADD      R0,R6,#+40
??do_homing_move_7:
        LDRB     R1,[R4, #+2]
        STR      R1,[SP, #+4]
        STR      R0,[SP, #+0]
        ADD      R3,R4,#+20
        LDR      R2,[R4, #+16]
        LDR      R1,[R4, #+12]
        LDR      R0,[R4, #+8]
          CFI FunCall _ZN7Planner11buffer_lineEfffRKfS1_h
        BL       _ZN7Planner11buffer_lineEfffRKfS1_h
// 3368 		}
// 3369   //#endif
// 3370 
// 3371   stepper.synchronize();
??do_homing_move_5:
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
// 3372 
// 3373 #if QUIET_PROBING
// 3374     if (axis == Z_AXIS) probing_pause(false);
// 3375 #endif
// 3376 
// 3377   #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
// 3378   if((Z_HOME_DIR < 0) &&  (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))	/*--mks cfg--*/
// 3379   	{
// 3380     if (deploy_bltouch) set_bltouch_deployed(false);
// 3381   	}
// 3382   #endif
// 3383 
// 3384   endstops.hit_on_purpose();
          CFI FunCall _ZN8Endstops14hit_on_purposeEv
        BL       _ZN8Endstops14hit_on_purposeEv
// 3385 
// 3386   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3387     if (DEBUGGING(LEVELING)) {
// 3388       SERIAL_ECHOPAIR("<<< do_homing_move(", axis_codes[axis]);
// 3389       SERIAL_CHAR(')');
// 3390       SERIAL_EOL;
// 3391     }
// 3392   #endif
// 3393 }
        POP      {R0-R2,R4-R7,PC}  ;; return
          CFI EndBlock cfiBlock49

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable122:
        DC32     saved_feedrate_mm_s
// 3394 
// 3395 /**
// 3396  * TMC2130 specific sensorless homing using stallGuard2.
// 3397  * stallGuard2 only works when in spreadCycle mode.
// 3398  * spreadCycle and stealthChop are mutually exclusive.
// 3399  */
// 3400 #if ENABLED(SENSORLESS_HOMING)
// 3401   void tmc2130_sensorless_homing(TMC2130Stepper &st, bool enable=true) {
// 3402     #if ENABLED(STEALTHCHOP)
// 3403       if (enable) {
// 3404         st.coolstep_min_speed(1024UL * 1024UL - 1UL);
// 3405         st.stealthChop(0);
// 3406       }
// 3407       else {
// 3408         st.coolstep_min_speed(0);
// 3409         st.stealthChop(1);
// 3410       }
// 3411     #endif
// 3412 
// 3413     st.diag1_stall(enable ? 1 : 0);
// 3414   }
// 3415 #endif
// 3416 
// 3417 /**
// 3418  * Home an individual "raw axis" to its endstop.
// 3419  * This applies to XYZ on Cartesian and Core robots, and
// 3420  * to the individual ABC steppers on DELTA and SCARA.
// 3421  *
// 3422  * At the end of the procedure the axis is marked as
// 3423  * homed and the current position of that axis is updated.
// 3424  * Kinematic robots should wait till all axes are homed
// 3425  * before updating the current position.
// 3426  */
// 3427 
// 3428 #define HOMEAXIS(LETTER) homeaxis(LETTER##_AXIS)
// 3429 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock50 Using cfiCommon0
          CFI Function _ZN37_INTERNAL_15_Marlin_main_cpp_317853198homeaxisE8AxisEnum
        THUMB
// 3430 static void homeaxis(const AxisEnum axis) {
_ZN37_INTERNAL_15_Marlin_main_cpp_317853198homeaxisE8AxisEnum:
        PUSH     {R3-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+32
        MOV      R4,R0
// 3431 
// 3432   //#if IS_SCARA
// 3433 #define CAN_HOME(A) \ 
// 3434 	(axis == A##_AXIS && ((A##_MIN_PIN > -1 && A##_HOME_DIR < 0) || (A##_MAX_PIN > -1 && A##_HOME_DIR > 0)))
// 3435 
// 3436   if(MACHINETPYE&IS_SCARA)
        LDR.N    R5,??DataTable126_2
        LDRH     R0,[R5, #+88]
        TST      R0,#0x300
        BEQ.N    ??homeaxis_0
// 3437     // Only Z homing (with probe) is permitted
// 3438     if (axis != Z_AXIS) { BUZZ(100, 880); return; }
        MOV      R0,R4
        CMP      R0,#+2
        BEQ.N    ??homeaxis_1
        MOVS     R0,#+100
        STRH     R0,[SP, #+2]
        MOV      R0,#+880
        STRH     R0,[SP, #+0]
        MOV      R2,SP
        ADD      R1,SP,#+2
        LDR.W    R0,??DataTable133_3
          CFI FunCall _ZN6Buzzer4toneERKtS1_
        BL       _ZN6Buzzer4toneERKtS1_
        B.N      ??homeaxis_2
??homeaxis_1:
        LDRSB    R0,[R5, #+6]
        CMP      R0,#+0
        BEQ.W    ??homeaxis_2
// 3439   //#else
// 3440   else
// 3441     if (!CAN_HOME(X) && !CAN_HOME(Y) && !CAN_HOME(Z)) return;
// 3442   //#endif
// 3443 
// 3444   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3445     if (DEBUGGING(LEVELING)) {
// 3446       SERIAL_ECHOPAIR(">>> homeaxis(", axis_codes[axis]);
// 3447       SERIAL_CHAR(')');
// 3448       SERIAL_EOL;
// 3449     }
// 3450   #endif
// 3451 
// 3452   const int axis_home_dir =
// 3453     #if ENABLED(DUAL_X_CARRIAGE)
// 3454       (axis == X_AXIS) ? x_home_dir(active_extruder) :
// 3455     #endif
// 3456     home_dir(axis);
??homeaxis_0:
        MOV      R0,R4
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_317853198home_dirE8AxisEnum
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_317853198home_dirE8AxisEnum
        MOV      R6,R0
// 3457 
// 3458   // Homing Z towards the bed? Deploy the Z probe or endstop.
// 3459   #if HOMING_Z_WITH_PROBE
// 3460   if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))	/*--mks cfg--*/
        LDRSB    R0,[R5, #+6]
        CMP      R0,#+0
        BPL.N    ??homeaxis_3
        LDRB     R0,[R5, #+153]
        CMP      R0,#+1
        BNE.N    ??homeaxis_3
// 3461    { if (axis == Z_AXIS && DEPLOY_PROBE()) return;}
        MOV      R0,R4
        CMP      R0,#+2
        BNE.N    ??homeaxis_3
        MOVS     R0,#+1
          CFI FunCall _Z18set_probe_deployedb
        BL       _Z18set_probe_deployedb
        CMP      R0,#+0
        BNE.W    ??homeaxis_2
// 3462   #endif
// 3463 
// 3464   // Set a flag for Z motor locking
// 3465   #if ENABLED(Z_DUAL_ENDSTOPS)
// 3466     if (axis == Z_AXIS) stepper.set_homing_flag(true);
// 3467   #endif
// 3468 
// 3469   // Disable stealthChop if used. Enable diag1 pin on driver.
// 3470   #if ENABLED(SENSORLESS_HOMING)
// 3471     #if ENABLED(X_IS_TMC2130)
// 3472       if (axis == X_AXIS) tmc2130_sensorless_homing(stepperX);
// 3473     #endif
// 3474     #if ENABLED(Y_IS_TMC2130)
// 3475       if (axis == Y_AXIS) tmc2130_sensorless_homing(stepperY);
// 3476     #endif
// 3477   #endif
// 3478 
// 3479   // Fast move towards endstop until triggered
// 3480   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3481     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 1 Fast:");
// 3482   #endif
// 3483   do_homing_move(axis, 1.1 * max_length(axis) * axis_home_dir);
??homeaxis_3:
        MOV      R0,R4
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531910max_lengthE8AxisEnum
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531910max_lengthE8AxisEnum
        MOVS     R2,#+0
        MOV      R7,R2
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable133_4  ;; 0x9999999a
        LDR.W    R3,??DataTable133_5  ;; 0x3ff19999
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R8,R0
        MOV      R9,R1
        MOV      R0,R6
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R1,R0
        MOV      R2,R7
        MOV      R0,R4
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531914do_homing_moveE8AxisEnumff
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531914do_homing_moveE8AxisEnumff
// 3484 
// 3485   // When homing Z with probe respect probe clearance
// 3486   /*--mks cfg begin--*/
// 3487 /*  
// 3488   const float bump = axis_home_dir * (
// 3489   #if HOMING_Z_WITH_PROBE
// 3490       (axis == Z_AXIS) ? max(Z_CLEARANCE_BETWEEN_PROBES, home_bump_mm(Z_AXIS)) :
// 3491   #endif
// 3492     home_bump_mm(axis)
// 3493   );
// 3494 */
// 3495 
// 3496 float bump = 0;
// 3497 #if HOMING_Z_WITH_PROBE
// 3498 	if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))	/*--mks cfg--*/
        LDRSB    R0,[R5, #+6]
        CMP      R0,#+0
        BPL.N    ??homeaxis_4
        LDRB     R0,[R5, #+153]
        CMP      R0,#+1
        BNE.N    ??homeaxis_4
// 3499 		bump = axis_home_dir*((axis == Z_AXIS) ? max(Z_CLEARANCE_BETWEEN_PROBES, home_bump_mm(Z_AXIS)) :home_bump_mm(axis));
        MOV      R0,R4
        CMP      R0,#+2
        BNE.N    ??homeaxis_5
        LDR      R7,[R5, #+104]
        MOVS     R0,#+2
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531912home_bump_mmE8AxisEnum
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531912home_bump_mmE8AxisEnum
        MOV      R1,R7
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??homeaxis_6
        MOVS     R0,#+2
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531912home_bump_mmE8AxisEnum
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531912home_bump_mmE8AxisEnum
        MOV      R7,R0
        B.N      ??homeaxis_6
??homeaxis_5:
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531912home_bump_mmE8AxisEnum
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531912home_bump_mmE8AxisEnum
        MOV      R7,R0
??homeaxis_6:
        MOV      R0,R6
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
        B.N      ??homeaxis_7
// 3500 	else
// 3501 		bump = axis_home_dir *home_bump_mm(axis);
??homeaxis_4:
        MOV      R0,R6
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R6,R0
        MOV      R0,R4
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531912home_bump_mmE8AxisEnum
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531912home_bump_mmE8AxisEnum
        MOV      R1,R0
        MOV      R0,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
// 3502 #else
// 3503 	bump = axis_home_dir *home_bump_mm(axis);
// 3504 #endif
// 3505 
// 3506 
// 3507 ///////////////////////////
// 3508 /*
// 3509  float bump;
// 3510 #if HOMING_Z_WITH_PROBE
// 3511 if(Z_HOME_DIR < 0)
// 3512 	bump = axis_home_dir * ((axis == Z_AXIS) ? max(Z_CLEARANCE_BETWEEN_PROBES, home_bump_mm(Z_AXIS)) :home_bump_mm(axis));
// 3513 #else
// 3514 	bump = axis_home_dir * (home_bump_mm(axis));
// 3515 #endif
// 3516 */	
// 3517 	/*--mks cfg end--*/
// 3518 
// 3519   // If a second homing move is configured...
// 3520   if (bump) {
??homeaxis_7:
        MOV      R0,R6
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??homeaxis_8
// 3521     // Move away from the endstop by the axis HOME_BUMP_MM
// 3522     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3523       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Move Away:");
// 3524     #endif
// 3525     do_homing_move(axis, -bump);
        MOV      R2,R1
        MOV      R1,R6
        EOR      R1,R1,#0x80000000
        MOV      R0,R4
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531914do_homing_moveE8AxisEnumff
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531914do_homing_moveE8AxisEnumff
// 3526 
// 3527     // Slow move towards endstop until triggered
// 3528     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3529       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 2 Slow:");
// 3530     #endif
// 3531     do_homing_move(axis, 2 * bump, get_homing_bump_feedrate(axis));
        MOV      R0,R4
          CFI FunCall _Z24get_homing_bump_feedrate8AxisEnum
        BL       _Z24get_homing_bump_feedrate8AxisEnum
        MOV      R2,R0
        MOV      R7,R2
        MOV      R1,#+1073741824
        MOV      R0,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R2,R7
        MOV      R0,R4
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531914do_homing_moveE8AxisEnumff
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531914do_homing_moveE8AxisEnumff
// 3532   }
// 3533 
// 3534   #if ENABLED(Z_DUAL_ENDSTOPS)
// 3535     if (axis == Z_AXIS) {
// 3536       float adj = fabs(z_endstop_adj);
// 3537       bool lockZ1;
// 3538       if (axis_home_dir > 0) {
// 3539         adj = -adj;
// 3540         lockZ1 = (z_endstop_adj > 0);
// 3541       }
// 3542       else
// 3543         lockZ1 = (z_endstop_adj < 0);
// 3544 
// 3545       if (lockZ1) stepper.set_z_lock(true); else stepper.set_z2_lock(true);
// 3546 
// 3547       // Move to the adjusted endstop height
// 3548       do_homing_move(axis, adj);
// 3549 
// 3550       if (lockZ1) stepper.set_z_lock(false); else stepper.set_z2_lock(false);
// 3551       stepper.set_homing_flag(false);
// 3552     } // Z_AXIS
// 3553   #endif
// 3554 
// 3555  // #if IS_SCARA
// 3556   if(MACHINETPYE&IS_SCARA)
??homeaxis_8:
        LDRSH    R0,[R5, #+88]
        TST      R0,#0x300
        BEQ.N    ??homeaxis_9
// 3557   	{
// 3558     set_axis_is_at_home(axis);
        MOV      R0,R4
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531919set_axis_is_at_homeE8AxisEnum
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531919set_axis_is_at_homeE8AxisEnum
// 3559     SYNC_PLAN_POSITION_KINEMATIC();
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
        B.N      ??homeaxis_10
// 3560   	}
// 3561 //  #elif ENABLED(DELTA)
// 3562 	else if(MACHINETPYE == DELTA) {
??homeaxis_9:
        MOV      R6,R4
        CMP      R0,#+2
        BNE.N    ??homeaxis_11
// 3563     // Delta has already moved all three towers up in G28
// 3564     // so here it re-homes each tower in turn.
// 3565     // Delta homing treats the axes as normal linear axes.
// 3566 
// 3567     // retrace by the amount specified in endstop_adj
// 3568     if (endstop_adj[axis] * Z_HOME_DIR < 0) {
        LDR.W    R0,??DataTable135_2
        LDR      R6,[R0, R6, LSL #+2]
        LDRSB    R0,[R5, #+6]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??homeaxis_10
// 3569       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3570         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("endstop_adj:");
// 3571       #endif
// 3572       do_homing_move(axis, endstop_adj[axis]);
        MOV      R2,R1
        MOV      R1,R6
        MOV      R0,R4
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531914do_homing_moveE8AxisEnumff
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531914do_homing_moveE8AxisEnumff
        B.N      ??homeaxis_10
// 3573    		 }
// 3574 	  }
// 3575   //#else
// 3576 	else {
// 3577     // For cartesian/core machines,
// 3578     // set the axis to its home position
// 3579     set_axis_is_at_home(axis);
??homeaxis_11:
        MOV      R0,R4
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531919set_axis_is_at_homeE8AxisEnum
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531919set_axis_is_at_homeE8AxisEnum
// 3580     sync_plan_position();
          CFI FunCall _Z18sync_plan_positionv
        BL       _Z18sync_plan_positionv
// 3581 
// 3582     destination[axis] = current_position[axis];
        LDR.N    R0,??DataTable126_1
        ADD      R0,R0,R6, LSL #+2
        LDR      R1,[R0, #+8]
        STR      R1,[R0, #+24]
// 3583 
// 3584     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3585       if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
// 3586     #endif
// 3587 	}
// 3588   //#endif
// 3589 
// 3590   // Re-enable stealthChop if used. Disable diag1 pin on driver.
// 3591   #if ENABLED(SENSORLESS_HOMING)
// 3592     #if ENABLED(X_IS_TMC2130)
// 3593       if (axis == X_AXIS) tmc2130_sensorless_homing(stepperX, false);
// 3594     #endif
// 3595     #if ENABLED(Y_IS_TMC2130)
// 3596       if (axis == Y_AXIS) tmc2130_sensorless_homing(stepperY, false);
// 3597     #endif
// 3598   #endif
// 3599 
// 3600   // Put away the Z probe
// 3601   #if HOMING_Z_WITH_PROBE
// 3602   if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))	/*--mks cfg--*/
??homeaxis_10:
        LDRSB    R0,[R5, #+6]
        CMP      R0,#+0
        BPL.N    ??homeaxis_2
        LDRB     R0,[R5, #+153]
        CMP      R0,#+1
        BNE.N    ??homeaxis_2
// 3603    { if (axis == Z_AXIS && STOW_PROBE()) return;}
        CMP      R4,#+2
        BNE.N    ??homeaxis_2
        MOVS     R0,#+0
          CFI FunCall _Z18set_probe_deployedb
        BL       _Z18set_probe_deployedb
// 3604   #endif
// 3605 
// 3606   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3607     if (DEBUGGING(LEVELING)) {
// 3608       SERIAL_ECHOPAIR("<<< homeaxis(", axis_codes[axis]);
// 3609       SERIAL_CHAR(')');
// 3610       SERIAL_EOL;
// 3611     }
// 3612   #endif
// 3613 } // homeaxis()
??homeaxis_2:
        POP      {R0,R4-R9,PC}    ;; return
          CFI EndBlock cfiBlock50

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable123:
        DC32     mks_heating_busy+0x10

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable123_1:
        DC32     _ZN8Endstops15z_probe_enabledE
// 3614 
// 3615 #if ENABLED(FWRETRACT)
// 3616 
// 3617   void retract(const bool retracting, const bool swapping = false) {
// 3618 
// 3619     static float hop_height;
// 3620 
// 3621     if (retracting == retracted[active_extruder]) return;
// 3622 
// 3623     const float old_feedrate_mm_s = feedrate_mm_s;
// 3624 
// 3625     set_destination_to_current();
// 3626 
// 3627     if (retracting) {
// 3628 
// 3629       feedrate_mm_s = retract_feedrate_mm_s;
// 3630       current_position[E_AXIS] += (swapping ? retract_length_swap : retract_length) / volumetric_multiplier[active_extruder];
// 3631       sync_plan_position_e();
// 3632       prepare_move_to_destination();
// 3633 
// 3634       if (retract_zlift > 0.01) {
// 3635         hop_height = current_position[Z_AXIS];
// 3636         // Pretend current position is lower
// 3637         current_position[Z_AXIS] -= retract_zlift;
// 3638         SYNC_PLAN_POSITION_KINEMATIC();
// 3639         // Raise up to the old current_position
// 3640         prepare_move_to_destination();
// 3641       }
// 3642     }
// 3643     else {
// 3644 
// 3645       // If the height hasn't been altered, undo the Z hop
// 3646       if (retract_zlift > 0.01 && hop_height == current_position[Z_AXIS]) {
// 3647         // Pretend current position is higher. Z will lower on the next move
// 3648         current_position[Z_AXIS] += retract_zlift;
// 3649         SYNC_PLAN_POSITION_KINEMATIC();
// 3650         // Lower Z
// 3651         prepare_move_to_destination();
// 3652       }
// 3653 
// 3654       feedrate_mm_s = retract_recover_feedrate_mm_s;
// 3655       const float move_e = swapping ? retract_length_swap + retract_recover_length_swap : retract_length + retract_recover_length;
// 3656       current_position[E_AXIS] -= move_e / volumetric_multiplier[active_extruder];
// 3657       sync_plan_position_e();
// 3658 
// 3659       // Recover E
// 3660       prepare_move_to_destination();
// 3661     }
// 3662 
// 3663     feedrate_mm_s = old_feedrate_mm_s;
// 3664     retracted[active_extruder] = retracting;
// 3665 
// 3666   } // retract()
// 3667 
// 3668 #endif // FWRETRACT
// 3669 
// 3670 #if ENABLED(MIXING_EXTRUDER)
// 3671 
// 3672   void normalize_mix() {
// 3673     float mix_total = 0.0;
// 3674     for (uint8_t i = 0; i < MIXING_STEPPERS; i++) mix_total += RECIPROCAL(mixing_factor[i]);
// 3675     // Scale all values if they don't add up to ~1.0
// 3676     if (!NEAR(mix_total, 1.0)) {
// 3677       SERIAL_PROTOCOLLNPGM("Warning: Mix factors must add up to 1.0. Scaling.");
// 3678       for (uint8_t i = 0; i < MIXING_STEPPERS; i++) mixing_factor[i] *= mix_total;
// 3679     }
// 3680   }
// 3681 
// 3682   #if ENABLED(DIRECT_MIXING_IN_G1)
// 3683     // Get mixing parameters from the GCode
// 3684     // The total "must" be 1.0 (but it will be normalized)
// 3685     // If no mix factors are given, the old mix is preserved
// 3686     void gcode_get_mix() {
// 3687       const char* mixing_codes = "ABCDHI";
// 3688       byte mix_bits = 0;
// 3689       for (uint8_t i = 0; i < MIXING_STEPPERS; i++) {
// 3690         if (code_seen(mixing_codes[i])) {
// 3691           SBI(mix_bits, i);
// 3692           float v = code_value_float();
// 3693           NOLESS(v, 0.0);
// 3694           mixing_factor[i] = RECIPROCAL(v);
// 3695         }
// 3696       }
// 3697       // If any mixing factors were included, clear the rest
// 3698       // If none were included, preserve the last mix
// 3699       if (mix_bits) {
// 3700         for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
// 3701           if (!TEST(mix_bits, i)) mixing_factor[i] = 0.0;
// 3702         normalize_mix();
// 3703       }
// 3704     }
// 3705   #endif
// 3706 
// 3707 #endif
// 3708 
// 3709 /**
// 3710  * ***************************************************************************
// 3711  * ***************************** G-CODE HANDLING *****************************
// 3712  * ***************************************************************************
// 3713  */
// 3714 
// 3715 /**
// 3716  * Set XYZE destination and feedrate from the current GCode command
// 3717  *
// 3718  *  - Set destination from included axis codes
// 3719  *  - Set to current for missing axis codes
// 3720  *  - Set the feedrate, if included
// 3721  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock51 Using cfiCommon0
          CFI Function _Z21gcode_get_destinationv
        THUMB
// 3722 void gcode_get_destination() {
_Z21gcode_get_destinationv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
// 3723   LOOP_XYZE(i) {
        MOVS     R4,#+0
        B.N      ??gcode_get_destination_0
// 3724     if (code_seen(axis_codes[i]))
// 3725       destination[i] = code_value_axis_units((AxisEnum)i) + (axis_relative_modes[i] || relative_mode ? current_position[i] : 0);
// 3726     else
// 3727       destination[i] = current_position[i];
??gcode_get_destination_1:
        LDR      R0,[R5, #+8]
        STR      R0,[R5, #+24]
        B.N      ??gcode_get_destination_2
??gcode_get_destination_3:
        MOVS     R1,#+0
??gcode_get_destination_4:
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+24]
??gcode_get_destination_2:
        ADDS     R4,R4,#+1
??gcode_get_destination_0:
        CMP      R4,#+4
        BGE.N    ??gcode_get_destination_5
        LDR.W    R0,??DataTable136_2
        ADD      R5,R0,R4, LSL #+2
        ADR.W    R0,axis_codes
        LDRSB    R0,[R0, R4]
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_get_destination_1
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        LDR.W    R1,??DataTable136_3
        LDRB     R2,[R1, R4]
        LDRB     R1,[R1, #+12]
        ORRS     R2,R1,R2
        BEQ.N    ??gcode_get_destination_3
        LDR      R1,[R5, #+8]
        B.N      ??gcode_get_destination_4
// 3728   }
// 3729 
// 3730   if (code_seen('F') && code_value_linear_units() > 0.0)
??gcode_get_destination_5:
        MOVS     R0,#+70
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_get_destination_6
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BCS.N    ??gcode_get_destination_6
// 3731     feedrate_mm_s = MMM_TO_MMS(code_value_linear_units());
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        LDR.W    R1,??DataTable136_4  ;; 0x42700000
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        LDR.W    R1,??DataTable136_2
        STR      R0,[R1, #+116]
// 3732 
// 3733   #if ENABLED(PRINTCOUNTER)
// 3734     if (!DEBUGGING(DRYRUN))
// 3735       print_job_timer.incFilamentUsed(destination[E_AXIS] - current_position[E_AXIS]);
// 3736   #endif
// 3737 
// 3738   // Get ABCDHI mixing factors
// 3739   #if ENABLED(MIXING_EXTRUDER) && ENABLED(DIRECT_MIXING_IN_G1)
// 3740     gcode_get_mix();
// 3741   #endif
// 3742 }
??gcode_get_destination_6:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock51

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
axis_codes:
        DC8 88, 89, 90, 69
// 3743 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock52 Using cfiCommon0
          CFI Function _Z21unknown_command_errorv
        THUMB
// 3744 void unknown_command_error() {
_Z21unknown_command_errorv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 3745   SERIAL_ECHO_START;
        LDR.W    R0,??DataTable136_5
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 3746   SERIAL_ECHOPAIR(MSG_UNKNOWN_COMMAND, current_command);
        LDR.W    R0,??DataTable136_3
        LDR      R1,[R0, #+36]
        ADR.W    R0,?_14
          CFI FunCall _Z17serial_echopair_PPKcS0_
        BL       _Z17serial_echopair_PPKcS0_
// 3747   SERIAL_CHAR('"');
        LDR.N    R4,??DataTable126_1
        LDRB     R0,[R4, #+7]
        CMP      R0,#+0
        BNE.N    ??unknown_command_error_0
        MOVS     R1,#+34
        LDR.W    R0,??DataTable128
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??unknown_command_error_1
??unknown_command_error_0:
        MOVS     R2,#+0
        MOVS     R1,#+34
        LDR.W    R0,??DataTable136_6
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
// 3748   SERIAL_EOL;
??unknown_command_error_1:
        LDRB     R0,[R4, #+7]
        CMP      R0,#+0
        BNE.N    ??unknown_command_error_2
        MOVS     R1,#+10
        LDR.W    R0,??DataTable128
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN12MarlinSerial5writeEh
        B.W      _ZN12MarlinSerial5writeEh
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??unknown_command_error_2:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.W    R0,??DataTable136_6
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN12MarlinSerial5printEci
        B.W      _ZN12MarlinSerial5printEci
// 3749 }
          CFI EndBlock cfiBlock52

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_14:
        DC8 "Unknown command: \""
        DC8 0
// 3750 
// 3751 #if ENABLED(HOST_KEEPALIVE_FEATURE)
// 3752 
// 3753   /**
// 3754    * Output a "busy" message at regular intervals
// 3755    * while the machine is not accepting commands.
// 3756    */

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock53 Using cfiCommon0
          CFI Function _Z14host_keepalivev
        THUMB
// 3757   void host_keepalive() {
_Z14host_keepalivev:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
// 3758     const millis_t ms = millis();
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        MOV      R5,R0
// 3759     if (host_keepalive_interval && busy_state != NOT_BUSY) {
        LDR.W    R4,??DataTable136_7
        LDRB     R0,[R4, #+0]
        CMP      R0,#+0
        BEQ.N    ??host_keepalive_1
        LDR.N    R0,??DataTable126_1
        LDRSB    R0,[R0, #+6]
        CMP      R0,#+0
        BEQ.N    ??host_keepalive_1
// 3760       if (PENDING(ms, next_busy_signal_ms)) return;
        LDR      R1,[R4, #+4]
        SUBS     R1,R5,R1
        BMI.N    ??host_keepalive_2
// 3761       switch (busy_state) {
        SUBS     R0,R0,#+1
        CMP      R0,#+3
        BHI.N    ??host_keepalive_1
        TBB      [PC, R0]
        DATA
??host_keepalive_0:
        DC8      0x2,0x2,0xB,0x14
        THUMB
// 3762         case IN_HANDLER:
// 3763         case IN_PROCESS:
// 3764           SERIAL_ECHO_START;
??host_keepalive_3:
        LDR.W    R0,??DataTable136_5
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 3765           SERIAL_ECHOLNPGM(MSG_BUSY_PROCESSING);
        ADR.W    R0,?_15
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 3766           break;
        B.N      ??host_keepalive_1
// 3767         case PAUSED_FOR_USER:
// 3768           SERIAL_ECHO_START;
??host_keepalive_4:
        LDR.W    R0,??DataTable136_5
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 3769           SERIAL_ECHOLNPGM(MSG_BUSY_PAUSED_FOR_USER);
        ADR.W    R0,?_16
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 3770           break;
        B.N      ??host_keepalive_1
// 3771         case PAUSED_FOR_INPUT:
// 3772           SERIAL_ECHO_START;
??host_keepalive_5:
        LDR.W    R0,??DataTable136_5
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 3773           SERIAL_ECHOLNPGM(MSG_BUSY_PAUSED_FOR_INPUT);
        ADR.W    R0,?_17
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 3774           break;
// 3775         default:
// 3776           break;
// 3777       }
// 3778     }
// 3779     next_busy_signal_ms = ms + host_keepalive_interval * 1000UL;
??host_keepalive_1:
        LDRB     R1,[R4, #+0]
        MOV      R0,#+1000
        MLA      R5,R0,R1,R5
        STR      R5,[R4, #+4]
// 3780   }
??host_keepalive_2:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock53

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable126:
        DC32     0xc1200000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable126_1:
        DC32     mks_heating_busy

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable126_2:
        DC32     mksCfg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable126_3:
        DC32     mks_heating_busy+0x8

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable126_4:
        DC32     _ZN20unified_bed_leveling5stateE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable126_5:
        DC32     Running

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable126_6:
        DC32     _ZN7Planner11abl_enabledE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable126_7:
        DC32     _ZN7Planner13z_fade_heightE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable126_8:
        DC32     0xb58637bd

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_15:
        DC8 "busy: processing\012"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_16:
        DC8 "busy: paused for user\012"
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_17:
        DC8 "busy: paused for input\012"
// 3781 
// 3782 #endif //HOST_KEEPALIVE_FEATURE
// 3783 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock54 Using cfiCommon0
          CFI Function _Z21position_is_reachablePKfb
        THUMB
// 3784 bool position_is_reachable(const float target[XYZ]
// 3785   #if HAS_BED_PROBE
// 3786     , bool by_probe=false
// 3787   #endif
// 3788 ) {
_Z21position_is_reachablePKfb:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R4,R0
        MOV      R8,R1
// 3789   float dx = RAW_X_POSITION(target[X_AXIS]),
        LDR.W    R9,??DataTable136_2
        LDR      R0,[R4, #+0]
        LDR      R1,[R9, #+68]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R5,R0
// 3790         dy = RAW_Y_POSITION(target[Y_AXIS]);
        LDR      R0,[R4, #+4]
        LDR      R1,[R9, #+72]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R7,R0
// 3791 
// 3792   #if HAS_BED_PROBE
// 3793     if (by_probe) {
        LDR.W    R6,??DataTable136_8
        CMP      R8,#+0
        BEQ.N    ??position_is_reachable_0
// 3794       dx -= X_PROBE_OFFSET_FROM_EXTRUDER;
        MOV      R0,R5
        LDR      R1,[R6, #+108]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R5,R0
// 3795       dy -= Y_PROBE_OFFSET_FROM_EXTRUDER;
        MOV      R0,R7
        LDR      R1,[R6, #+112]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R7,R0
// 3796     }
// 3797   #endif
// 3798 
// 3799 //mks_delta		begin
// 3800 /*
// 3801   #if IS_SCARA
// 3802     #if MIDDLE_DEAD_ZONE_R > 0
// 3803       const float R2 = HYPOT2(dx - SCARA_OFFSET_X, dy - SCARA_OFFSET_Y);
// 3804       return R2 >= sq(float(MIDDLE_DEAD_ZONE_R)) && R2 <= sq(L1 + L2);
// 3805     #else
// 3806       return HYPOT2(dx - SCARA_OFFSET_X, dy - SCARA_OFFSET_Y) <= sq(L1 + L2);
// 3807     #endif
// 3808   #elif ENABLED(DELTA)
// 3809     return HYPOT2(dx, dy) <= sq((float)(DELTA_PRINTABLE_RADIUS));
// 3810   #else
// 3811     const float dz = RAW_Z_POSITION(target[Z_AXIS]);
// 3812     return WITHIN(dx, X_MIN_POS - 0.0001, X_MAX_POS + 0.0001)
// 3813         && WITHIN(dy, Y_MIN_POS - 0.0001, Y_MAX_POS + 0.0001)
// 3814         && WITHIN(dz, Z_MIN_POS - 0.0001, Z_MAX_POS + 0.0001);
// 3815   #endif
// 3816   */
// 3817 ///////////
// 3818 
// 3819   float dz;
// 3820 
// 3821   if(MACHINETPYE&IS_SCARA)
??position_is_reachable_0:
        LDRSH    R0,[R6, #+88]
        TST      R0,#0x300
        BEQ.N    ??position_is_reachable_1
// 3822   	{
// 3823 	#if MIDDLE_DEAD_ZONE_R > 0
// 3824 		const float R2 = HYPOT2(dx - SCARA_OFFSET_X, dy - SCARA_OFFSET_Y);
// 3825 		return R2 >= sq(float(MIDDLE_DEAD_ZONE_R)) && R2 <= sq(L1 + L2);
// 3826 	#else
// 3827 		return HYPOT2(dx - SCARA_OFFSET_X, dy - SCARA_OFFSET_Y) <= sq(L1 + L2);
        LDR.W    R9,??DataTable136_9  ;; 0x43960000
        MOVS     R4,#+2
        MOV      R6,#+1065353216
        MOV      R8,R6
        B.N      ??position_is_reachable_2
??position_is_reachable_3:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??position_is_reachable_2:
        LSLS     R0,R4,#+31
        BPL.N    ??position_is_reachable_4
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??position_is_reachable_4:
        LSRS     R4,R4,#+1
        BNE.N    ??position_is_reachable_3
        LDR.W    R0,??DataTable136_10  ;; 0xc2c80000
        MOV      R1,R5
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R9,R0
        MOVS     R4,#+2
        MOV      R5,R6
        B.N      ??position_is_reachable_5
??position_is_reachable_6:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??position_is_reachable_5:
        LSLS     R0,R4,#+31
        BPL.N    ??position_is_reachable_7
        MOV      R0,R5
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
??position_is_reachable_7:
        LSRS     R4,R4,#+1
        BNE.N    ??position_is_reachable_6
        LDR.W    R0,??DataTable136_11  ;; 0x42600000
        MOV      R1,R7
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R7,R0
        MOVS     R4,#+2
        B.N      ??position_is_reachable_8
??position_is_reachable_9:
        MOV      R0,R7
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??position_is_reachable_8:
        LSLS     R0,R4,#+31
        BPL.N    ??position_is_reachable_10
        MOV      R0,R6
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
??position_is_reachable_10:
        LSRS     R4,R4,#+1
        BNE.N    ??position_is_reachable_9
// 3828 	#endif
// 3829   	}
        MOV      R0,R5
        MOV      R1,R6
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??position_is_reachable_11
        MOVS     R0,#+1
        B.N      ??position_is_reachable_12
??position_is_reachable_11:
        MOVS     R0,#+0
        B.N      ??position_is_reachable_12
// 3830   else if(MACHINETPYE == DELTA)
??position_is_reachable_1:
        CMP      R0,#+2
        BNE.N    ??position_is_reachable_13
// 3831   	{
// 3832 	  return HYPOT2(dx, dy) <= sq((float)(DELTA_PRINTABLE_RADIUS));
        LDR      R9,[R6, #+84]
        MOVS     R4,#+2
        MOV      R6,#+1065353216
        MOV      R8,R6
        B.N      ??position_is_reachable_14
??position_is_reachable_15:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??position_is_reachable_14:
        LSLS     R0,R4,#+31
        BPL.N    ??position_is_reachable_16
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??position_is_reachable_16:
        LSRS     R4,R4,#+1
        BNE.N    ??position_is_reachable_15
        MOVS     R4,#+2
        MOV      R9,R6
        B.N      ??position_is_reachable_17
??position_is_reachable_18:
        MOV      R0,R5
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
??position_is_reachable_17:
        LSLS     R0,R4,#+31
        BPL.N    ??position_is_reachable_19
        MOV      R0,R9
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??position_is_reachable_19:
        LSRS     R4,R4,#+1
        BNE.N    ??position_is_reachable_18
        MOVS     R4,#+2
        B.N      ??position_is_reachable_20
??position_is_reachable_21:
        MOV      R0,R7
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??position_is_reachable_20:
        LSLS     R0,R4,#+31
        BPL.N    ??position_is_reachable_22
        MOV      R0,R6
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
??position_is_reachable_22:
        LSRS     R4,R4,#+1
        BNE.N    ??position_is_reachable_21
// 3833   	}
        MOV      R0,R9
        MOV      R1,R6
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??position_is_reachable_23
        MOVS     R0,#+1
        B.N      ??position_is_reachable_12
??position_is_reachable_23:
        MOVS     R0,#+0
        B.N      ??position_is_reachable_12
// 3834   else
// 3835   	{
// 3836 	  dz = RAW_Z_POSITION(target[Z_AXIS]);
??position_is_reachable_13:
        LDR      R0,[R4, #+8]
        LDR      R1,[R9, #+76]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+0]
// 3837 	  return WITHIN(dx, X_MIN_POS - 0.0001, X_MAX_POS + 0.0001)
// 3838 		  && WITHIN(dy, Y_MIN_POS - 0.0001, Y_MAX_POS + 0.0001)
// 3839 		  && WITHIN(dz, Z_MIN_POS - 0.0001, Z_MAX_POS + 0.0001);
        MOV      R0,R5
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R4,R0
        MOV      R5,R1
        LDR.W    R10,??DataTable136_12  ;; 0xeb1c432d
        LDR.W    R11,??DataTable136_13  ;; 0xbf1a36e2
        LDR      R0,[R6, #+8]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R10
        MOV      R3,R11
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
        MOV      R1,R5
          CFI FunCall __aeabi_cdrcmple
        BL       __aeabi_cdrcmple
        BHI.N    ??position_is_reachable_24
        MOV      R8,R10
        LDR.W    R9,??DataTable136_14  ;; 0x3f1a36e2
        LDR      R0,[R6, #+20]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_cdrcmple
        BL       __aeabi_cdrcmple
        BHI.N    ??position_is_reachable_24
        MOV      R0,R7
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R4,R0
        MOV      R5,R1
        LDR      R0,[R6, #+12]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R10
        MOV      R3,R11
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
        MOV      R1,R5
          CFI FunCall __aeabi_cdrcmple
        BL       __aeabi_cdrcmple
        BHI.N    ??position_is_reachable_24
        LDR      R0,[R6, #+24]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_cdrcmple
        BL       __aeabi_cdrcmple
        BHI.N    ??position_is_reachable_24
        LDR      R0,[SP, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R4,R0
        MOV      R5,R1
        LDR      R0,[R6, #+16]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R10
        MOV      R3,R11
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
        MOV      R1,R5
          CFI FunCall __aeabi_cdrcmple
        BL       __aeabi_cdrcmple
        BHI.N    ??position_is_reachable_24
        LDR      R0,[R6, #+28]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_cdrcmple
        BL       __aeabi_cdrcmple
        BHI.N    ??position_is_reachable_24
        MOVS     R0,#+1
        B.N      ??position_is_reachable_12
??position_is_reachable_24:
        MOVS     R0,#+0
??position_is_reachable_12:
        POP      {R1,R4-R11,PC}   ;; return
// 3840   	}
// 3841 
// 3842 //mks_delta	  end
// 3843 
// 3844   
// 3845 }
          CFI EndBlock cfiBlock54

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable127:
        DC32     0x358637be

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable127_1:
        DC32     _ZN7Planner21inverse_z_fade_heightE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable127_2:
        DC32     _ZN7Planner16bed_level_matrixE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable127_3:
        DC32     z_values
// 3846 
// 3847 /**************************************************
// 3848  ***************** GCode Handlers *****************
// 3849  **************************************************/
// 3850 
// 3851 /**
// 3852  * G0, G1: Coordinated movement of X Y Z E axes
// 3853  */
// 3854 	inline void gcode_G0_G1(
// 3855 	) {
// 3856 	  if (IsRunning()) {
// 3857 		gcode_get_destination(); // For X Y Z E F
// 3858 	
// 3859     #if ENABLED(FWRETRACT)
// 3860 	
// 3861 		  if (autoretract_enabled && !(code_seen('X') || code_seen('Y') || code_seen('Z')) && code_seen('E')) {
// 3862 			const float echange = destination[E_AXIS] - current_position[E_AXIS];
// 3863 			// Is this move an attempt to retract or recover?
// 3864 			if ((echange < -MIN_RETRACT && !retracted[active_extruder]) || (echange > MIN_RETRACT && retracted[active_extruder])) {
// 3865 			  current_position[E_AXIS] = destination[E_AXIS]; // hide the slicer-generated retract/recover from calculations
// 3866 			  sync_plan_position_e();  // AND from the planner
// 3867 			  retract(!retracted[active_extruder]);
// 3868 			  return;
// 3869 			}
// 3870 		  }
// 3871 	
// 3872     #endif //FWRETRACT
// 3873 	
// 3874 		  prepare_move_to_destination(); //mks step1  destination[]={1.0,0.0,100.0,0.0}
// 3875 	  }
// 3876 	}
// 3877 
// 3878   inline void gcode_G0_G1_SCARA(
// 3879 	  bool fast_move=false
// 3880   ) {
// 3881 	if (IsRunning()) {
// 3882 	  gcode_get_destination(); // For X Y Z E F
// 3883   
// 3884   #if ENABLED(FWRETRACT)
// 3885   
// 3886 		if (autoretract_enabled && !(code_seen('X') || code_seen('Y') || code_seen('Z')) && code_seen('E')) {
// 3887 		  const float echange = destination[E_AXIS] - current_position[E_AXIS];
// 3888 		  // Is this move an attempt to retract or recover?
// 3889 		  if ((echange < -MIN_RETRACT && !retracted[active_extruder]) || (echange > MIN_RETRACT && retracted[active_extruder])) {
// 3890 			current_position[E_AXIS] = destination[E_AXIS]; // hide the slicer-generated retract/recover from calculations
// 3891 			sync_plan_position_e();  // AND from the planner
// 3892 			retract(!retracted[active_extruder]);
// 3893 			return;
// 3894 		  }
// 3895 		}
// 3896   
// 3897   #endif //FWRETRACT
// 3898   
// 3899 		fast_move ? prepare_uninterpolated_move_to_destination() : prepare_move_to_destination();
// 3900 	}
// 3901   }
// 3902 
// 3903 /**
// 3904  * G2: Clockwise Arc
// 3905  * G3: Counterclockwise Arc
// 3906  *
// 3907  * This command has two forms: IJ-form and R-form.
// 3908  *
// 3909  *  - I specifies an X offset. J specifies a Y offset.
// 3910  *    At least one of the IJ parameters is required.
// 3911  *    X and Y can be omitted to do a complete circle.
// 3912  *    The given XY is not error-checked. The arc ends
// 3913  *     based on the angle of the destination.
// 3914  *    Mixing I or J with R will throw an error.
// 3915  *
// 3916  *  - R specifies the radius. X or Y is required.
// 3917  *    Omitting both X and Y will throw an error.
// 3918  *    X or Y must differ from the current XY.
// 3919  *    Mixing R with I or J will throw an error.
// 3920  *
// 3921  *  Examples:
// 3922  *
// 3923  *    G2 I10           ; CW circle centered at X+10
// 3924  *    G3 X20 Y12 R14   ; CCW circle with r=14 ending at X20 Y12
// 3925  */
// 3926 #if ENABLED(ARC_SUPPORT)
// 3927   inline void gcode_G2_G3(bool clockwise) {
// 3928     if (IsRunning()) {
// 3929 
// 3930       #if ENABLED(SF_ARC_FIX)
// 3931         const bool relative_mode_backup = relative_mode;
// 3932         relative_mode = true;
// 3933       #endif
// 3934 
// 3935       gcode_get_destination();
// 3936 
// 3937       #if ENABLED(SF_ARC_FIX)
// 3938         relative_mode = relative_mode_backup;
// 3939       #endif
// 3940 
// 3941       float arc_offset[2] = { 0.0, 0.0 };
// 3942       if (code_seen('R')) {
// 3943         const float r = code_value_linear_units(),
// 3944                     x1 = current_position[X_AXIS], y1 = current_position[Y_AXIS],
// 3945                     x2 = destination[X_AXIS], y2 = destination[Y_AXIS];
// 3946         if (r && (x2 != x1 || y2 != y1)) {
// 3947           const float e = clockwise ^ (r < 0) ? -1 : 1,           // clockwise -1/1, counterclockwise 1/-1
// 3948                       dx = x2 - x1, dy = y2 - y1,                 // X and Y differences
// 3949                       d = HYPOT(dx, dy),                          // Linear distance between the points
// 3950                       h = sqrt(sq(r) - sq(d * 0.5)),              // Distance to the arc pivot-point
// 3951                       mx = (x1 + x2) * 0.5, my = (y1 + y2) * 0.5, // Point between the two points
// 3952                       sx = -dy / d, sy = dx / d,                  // Slope of the perpendicular bisector
// 3953                       cx = mx + e * h * sx, cy = my + e * h * sy; // Pivot-point of the arc
// 3954           arc_offset[X_AXIS] = cx - x1;
// 3955           arc_offset[Y_AXIS] = cy - y1;
// 3956         }
// 3957       }
// 3958       else {
// 3959         if (code_seen('I')) arc_offset[X_AXIS] = code_value_linear_units();
// 3960         if (code_seen('J')) arc_offset[Y_AXIS] = code_value_linear_units();
// 3961       }
// 3962 
// 3963       if (arc_offset[0] || arc_offset[1]) {
// 3964         // Send an arc to the planner
// 3965         plan_arc(destination, arc_offset, clockwise);
// 3966         refresh_cmd_timeout();
// 3967       }
// 3968       else {
// 3969         // Bad arguments
// 3970         SERIAL_ERROR_START;
// 3971         SERIAL_ERRORLNPGM(MSG_ERR_ARC_ARGS);
// 3972       }
// 3973     }
// 3974   }
// 3975 #endif
// 3976 
// 3977 /**
// 3978  * G4: Dwell S<seconds> or P<milliseconds>
// 3979  */
// 3980 inline void gcode_G4() {
// 3981   millis_t dwell_ms = 0;
// 3982 
// 3983   if (code_seen('P')) dwell_ms = code_value_millis(); // milliseconds to wait
// 3984   if (code_seen('S')) dwell_ms = code_value_millis_from_seconds(); // seconds to wait
// 3985 
// 3986   stepper.synchronize();
// 3987   refresh_cmd_timeout();
// 3988   dwell_ms += previous_cmd_ms;  // keep track of when we started waiting
// 3989 
// 3990   if (!lcd_hasstatus()) LCD_MESSAGEPGM(MSG_DWELL);
// 3991 
// 3992   while (PENDING(millis(), dwell_ms)) idle();
// 3993 }
// 3994 
// 3995 #if ENABLED(BEZIER_CURVE_SUPPORT)
// 3996 
// 3997   /**
// 3998    * Parameters interpreted according to:
// 3999    * http://linuxcnc.org/docs/2.6/html/gcode/gcode.html#sec:G5-Cubic-Spline
// 4000    * However I, J omission is not supported at this point; all
// 4001    * parameters can be omitted and default to zero.
// 4002    */
// 4003 
// 4004   /**
// 4005    * G5: Cubic B-spline
// 4006    */
// 4007   inline void gcode_G5() {
// 4008     if (IsRunning()) {
// 4009 
// 4010       gcode_get_destination();
// 4011 
// 4012       const float offset[] = {
// 4013         code_seen('I') ? code_value_linear_units() : 0.0,
// 4014         code_seen('J') ? code_value_linear_units() : 0.0,
// 4015         code_seen('P') ? code_value_linear_units() : 0.0,
// 4016         code_seen('Q') ? code_value_linear_units() : 0.0
// 4017       };
// 4018 
// 4019       plan_cubic_move(offset);
// 4020     }
// 4021   }
// 4022 
// 4023 #endif // BEZIER_CURVE_SUPPORT
// 4024 
// 4025 #if ENABLED(FWRETRACT)
// 4026 
// 4027   /**
// 4028    * G10 - Retract filament according to settings of M207
// 4029    * G11 - Recover filament according to settings of M208
// 4030    */
// 4031   inline void gcode_G10_G11(bool doRetract=false) {
// 4032     #if EXTRUDERS > 1
// 4033       if (doRetract) {
// 4034         retracted_swap[active_extruder] = (code_seen('S') && code_value_bool()); // checks for swap retract argument
// 4035       }
// 4036     #endif
// 4037     retract(doRetract
// 4038      #if EXTRUDERS > 1
// 4039       , retracted_swap[active_extruder]
// 4040      #endif
// 4041     );
// 4042   }
// 4043 
// 4044 #endif //FWRETRACT
// 4045 
// 4046 #if ENABLED(NOZZLE_CLEAN_FEATURE)
// 4047   /**
// 4048    * G12: Clean the nozzle
// 4049    */
// 4050   inline void gcode_G12() {
// 4051     // Don't allow nozzle cleaning without homing first
// 4052     if (axis_unhomed_error(true, true, true)) return;
// 4053 
// 4054     const uint8_t pattern = code_seen('P') ? code_value_ushort() : 0,
// 4055                   strokes = code_seen('S') ? code_value_ushort() : NOZZLE_CLEAN_STROKES,
// 4056                   objects = code_seen('T') ? code_value_ushort() : NOZZLE_CLEAN_TRIANGLES;
// 4057     const float radius = code_seen('R') ? code_value_float() : NOZZLE_CLEAN_CIRCLE_RADIUS;
// 4058 
// 4059     Nozzle::clean(pattern, strokes, radius, objects);
// 4060   }
// 4061 #endif
// 4062 
// 4063 #if ENABLED(INCH_MODE_SUPPORT)
// 4064   /**
// 4065    * G20: Set input mode to inches
// 4066    */
// 4067   inline void gcode_G20() { set_input_linear_units(LINEARUNIT_INCH); }
// 4068 
// 4069   /**
// 4070    * G21: Set input mode to millimeters
// 4071    */
// 4072   inline void gcode_G21() { set_input_linear_units(LINEARUNIT_MM); }
// 4073 #endif
// 4074 
// 4075 #if ENABLED(NOZZLE_PARK_FEATURE)
// 4076   /**
// 4077    * G27: Park the nozzle
// 4078    */
// 4079   inline void gcode_G27() {
// 4080     // Don't allow nozzle parking without homing first
// 4081     if (axis_unhomed_error(true, true, true)) return;
// 4082     Nozzle::park(code_seen('P') ? code_value_ushort() : 0);
// 4083   }
// 4084 #endif // NOZZLE_PARK_FEATURE
// 4085 
// 4086 //#if ENABLED(QUICK_HOME)	//mks_delta
// 4087 #if 1

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock55 Using cfiCommon0
          CFI Function _ZN37_INTERNAL_15_Marlin_main_cpp_3178531913quick_home_xyEv
        THUMB
// 4088   static void quick_home_xy() {
_ZN37_INTERNAL_15_Marlin_main_cpp_3178531913quick_home_xyEv:
        PUSH     {R1-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+48
// 4089 
// 4090     // Pretend the current position is 0,0
// 4091     current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
        LDR.W    R6,??DataTable136_2
        MOVS     R0,#+0
        STR      R0,[R6, #+12]
        STR      R0,[R6, #+8]
// 4092     sync_plan_position();
          CFI FunCall _Z18sync_plan_positionv
        BL       _Z18sync_plan_positionv
// 4093 
// 4094     const int x_axis_home_dir =
// 4095       #if ENABLED(DUAL_X_CARRIAGE)
// 4096         x_home_dir(active_extruder)
// 4097       #else
// 4098         home_dir(X_AXIS)
// 4099       #endif
// 4100     ;
        MOVS     R0,#+0
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_317853198home_dirE8AxisEnum
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_317853198home_dirE8AxisEnum
        MOV      R9,R0
// 4101 
// 4102     const float mlx = max_length(X_AXIS),
        MOVS     R0,#+0
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531910max_lengthE8AxisEnum
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531910max_lengthE8AxisEnum
        MOV      R8,R0
// 4103                 mly = max_length(Y_AXIS),
        MOVS     R0,#+1
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531910max_lengthE8AxisEnum
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531910max_lengthE8AxisEnum
        MOV      R7,R0
// 4104                 mlratio = mlx > mly ? mly / mlx : mlx / mly,
        MOV      R1,R8
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??quick_home_xy_0
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R11,R0
        B.N      ??quick_home_xy_1
??quick_home_xy_0:
        MOV      R0,R8
        MOV      R1,R7
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R11,R0
// 4105                 fr_mm_s = min(homing_feedrate_mm_s[X_AXIS], homing_feedrate_mm_s[Y_AXIS]) * sqrt(sq(mlratio) + 1.0);
??quick_home_xy_1:
        LDR      R1,[R6, #+44]
        LDR      R0,[R6, #+40]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??quick_home_xy_2
        MOV      R5,R0
        B.N      ??quick_home_xy_3
??quick_home_xy_2:
        MOV      R5,R1
??quick_home_xy_3:
        MOVS     R4,#+2
        MOV      R10,#+1065353216
        B.N      ??quick_home_xy_4
??quick_home_xy_5:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??quick_home_xy_4:
        LSLS     R0,R4,#+31
        BPL.N    ??quick_home_xy_6
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??quick_home_xy_6:
        LSRS     R4,R4,#+1
        BNE.N    ??quick_home_xy_5
        MOV      R0,R5
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R4,R0
        MOV      R5,R1
        MOV      R0,R10
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        LDR.W    R3,??DataTable133  ;; 0x3ff00000
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall sqrt
        BL       sqrt
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+8]
// 4106 
// 4107     do_blocking_move_to_xy(0.1 * mlx * x_axis_home_dir, 0.1 * mly * home_dir(Y_AXIS), fr_mm_s);
        LDR.W    R4,??DataTable133_4  ;; 0x9999999a
        LDR.W    R5,??DataTable136_15  ;; 0x3fb99999
        MOV      R0,R8
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R10,R0
        MOV      R11,R1
        MOV      R0,R9
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        MOV      R2,R10
        MOV      R3,R11
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+4]
        MOV      R0,R7
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R4,R0
        MOV      R5,R1
        MOVS     R0,#+1
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_317853198home_dirE8AxisEnum
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_317853198home_dirE8AxisEnum
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+0]
        ADD      R2,SP,#+8
        MOV      R1,SP
        ADD      R0,SP,#+4
          CFI FunCall _Z22do_blocking_move_to_xyRKfS0_S0_
        BL       _Z22do_blocking_move_to_xyRKfS0_S0_
// 4108     endstops.hit_on_purpose(); // clear endstop hit flags
          CFI FunCall _ZN8Endstops14hit_on_purposeEv
        BL       _ZN8Endstops14hit_on_purposeEv
// 4109     current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
        MOVS     R0,#+0
        STR      R0,[R6, #+12]
        STR      R0,[R6, #+8]
// 4110   }
        POP      {R0-R2,R4-R11,PC}  ;; return
          CFI EndBlock cfiBlock55

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable128:
        DC32     customizedSerial
// 4111 
// 4112 #endif // QUICK_HOME
// 4113 
// 4114 #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4115 
// 4116   void log_machine_info() 
// 4117 {
// 4118 }
// 4119 
// 4120 #endif // DEBUG_LEVELING_FEATURE
// 4121 
// 4122 //#if ENABLED(DELTA)	//mks_delta
// 4123 #if 1
// 4124   /**
// 4125    * A delta can only safely home all axes at the same time
// 4126    * This is like quick_home_xy() but for 3 towers.
// 4127    */
// 4128   inline void home_delta() {
// 4129     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4130       if (DEBUGGING(LEVELING)) DEBUG_POS(">>> home_delta", current_position);
// 4131     #endif
// 4132     // Init the current position of all carriages to 0,0,0
// 4133     ZERO(current_position);
// 4134     sync_plan_position();
// 4135 
// 4136     // Move all carriages together linearly until an endstop is hit.
// 4137     current_position[X_AXIS] = current_position[Y_AXIS] = current_position[Z_AXIS] = (Z_MAX_LENGTH + 10);
// 4138     feedrate_mm_s = homing_feedrate_mm_s[X_AXIS];
// 4139     line_to_current_position();
// 4140     stepper.synchronize();
// 4141     endstops.hit_on_purpose(); // clear endstop hit flags
// 4142 
// 4143     // At least one carriage has reached the top.
// 4144     // Now re-home each carriage separately.
// 4145     HOMEAXIS(A);
// 4146     HOMEAXIS(B);
// 4147     HOMEAXIS(C);
// 4148 
// 4149     // Set all carriages to their home positions
// 4150     // Do this here all at once for Delta, because
// 4151     // XYZ isn't ABC. Applying this per-tower would
// 4152     // give the impression that they are the same.
// 4153     LOOP_XYZ(i) set_axis_is_at_home((AxisEnum)i);
// 4154 
// 4155     SYNC_PLAN_POSITION_KINEMATIC();
// 4156 
// 4157     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4158       if (DEBUGGING(LEVELING)) DEBUG_POS("<<< home_delta", current_position);
// 4159     #endif
// 4160   }
// 4161 
// 4162 #endif // DELTA
// 4163 
// 4164 #if ENABLED(Z_SAFE_HOMING)
// 4165 
// 4166   inline void home_z_safely() {
// 4167 
// 4168     // Disallow Z homing if X or Y are unknown
// 4169     if (!axis_known_position[X_AXIS] || !axis_known_position[Y_AXIS]) {
// 4170       LCD_MESSAGEPGM(MSG_ERR_Z_HOMING);
// 4171       SERIAL_ECHO_START;
// 4172       SERIAL_ECHOLNPGM(MSG_ERR_Z_HOMING);
// 4173       return;
// 4174     }
// 4175 
// 4176     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4177       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Z_SAFE_HOMING >>>");
// 4178     #endif
// 4179 
// 4180     SYNC_PLAN_POSITION_KINEMATIC();
// 4181 
// 4182     /**
// 4183      * Move the Z probe (or just the nozzle) to the safe homing point
// 4184      */
// 4185     destination[X_AXIS] = LOGICAL_X_POSITION(Z_SAFE_HOMING_X_POINT);
// 4186     destination[Y_AXIS] = LOGICAL_Y_POSITION(Z_SAFE_HOMING_Y_POINT);
// 4187     destination[Z_AXIS] = current_position[Z_AXIS]; // Z is already at the right height
// 4188 
// 4189 #if 0		/*--mks cfg--*/
// 4190     if (position_is_reachable(
// 4191           destination
// 4192           #if HOMING_Z_WITH_PROBE
// 4193             , true
// 4194           #endif
// 4195         )
// 4196     ) 
// 4197 #endif    
// 4198 bool cfg_tmp_bool;    
// 4199  if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))	/*--mks cfg--*/
// 4200 	{
// 4201 	#if HOMING_Z_WITH_PROBE
// 4202     cfg_tmp_bool = (position_is_reachable(destination , true)); 
// 4203 	#else
// 4204     cfg_tmp_bool = (position_is_reachable(destination)); 
// 4205 	#endif
// 4206 	}
// 4207 else
// 4208 	cfg_tmp_bool = (position_is_reachable(destination));
// 4209 
// 4210 	if(cfg_tmp_bool)
// 4211 		
// 4212     {
// 4213 
// 4214       #if HOMING_Z_WITH_PROBE
// 4215 	  if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))	/*--mks cfg--*/
// 4216 	  	{	/*--mks cfg--*/
// 4217         destination[X_AXIS] -= X_PROBE_OFFSET_FROM_EXTRUDER;
// 4218         destination[Y_AXIS] -= Y_PROBE_OFFSET_FROM_EXTRUDER;
// 4219 	  	}
// 4220       #endif
// 4221 
// 4222       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4223         if (DEBUGGING(LEVELING)) DEBUG_POS("Z_SAFE_HOMING", destination);
// 4224       #endif
// 4225 
// 4226       // This causes the carriage on Dual X to unpark
// 4227       #if ENABLED(DUAL_X_CARRIAGE)
// 4228         active_extruder_parked = false;
// 4229       #endif
// 4230 
// 4231       do_blocking_move_to_xy(destination[X_AXIS], destination[Y_AXIS]);
// 4232       HOMEAXIS(Z);
// 4233     }
// 4234     else {
// 4235       LCD_MESSAGEPGM(MSG_ZPROBE_OUT);
// 4236       SERIAL_ECHO_START;
// 4237       SERIAL_ECHOLNPGM(MSG_ZPROBE_OUT);
// 4238     }
// 4239 
// 4240     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4241       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< Z_SAFE_HOMING");
// 4242     #endif
// 4243   }
// 4244 
// 4245 #endif // Z_SAFE_HOMING
// 4246 
// 4247 #if ENABLED(PROBE_MANUALLY)
// 4248   bool g29_in_progress = false;
// 4249 #else
// 4250   constexpr bool g29_in_progress = false;
// 4251 #endif
// 4252 
// 4253 /**
// 4254  * G28: Home all axes according to settings
// 4255  *
// 4256  * Parameters
// 4257  *
// 4258  *  None  Home to all axes with no parameters.
// 4259  *        With QUICK_HOME enabled XY will home together, then Z.
// 4260  *
// 4261  * Cartesian parameters
// 4262  *
// 4263  *  X   Home to the X endstop
// 4264  *  Y   Home to the Y endstop
// 4265  *  Z   Home to the Z endstop
// 4266  *
// 4267  */
// 4268 inline void gcode_G28() {
// 4269 
// 4270   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4271     if (DEBUGGING(LEVELING)) {
// 4272       SERIAL_ECHOLNPGM(">>> gcode_G28");
// 4273       log_machine_info();
// 4274     }
// 4275   #endif
// 4276 
// 4277   // Wait for planner moves to finish!
// 4278   stepper.synchronize();
// 4279 
// 4280   // Cancel the active G29 session
// 4281   #if ENABLED(PROBE_MANUALLY)
// 4282     g29_in_progress = false;
// 4283   #endif
// 4284 
// 4285   // Disable the leveling matrix before homing
// 4286 //  #if HAS_LEVELING
// 4287    bool bed_leveling_state_at_entry;
// 4288   if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
// 4289     bed_leveling_state_at_entry = ubl.state.active;
// 4290 
// 4291   if(BED_LEVELING_METHOD&HAS_LEVELING)
// 4292   	{
// 4293 	//#if ENABLED(AUTO_BED_LEVELING_UBL)
// 4294 	/*if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_UBL)
// 4295 		{
// 4296 		const bool bed_leveling_state_at_entry = ubl.state.active;
// 4297 		}*/
// 4298 	//#endif
// 4299 	
// 4300     set_bed_leveling_enabled(false);
// 4301   	}
// 4302   //#endif
// 4303 
// 4304   // Always home with tool 0 active
// 4305   #if HOTENDS > 1
// 4306     const uint8_t old_tool_index = active_extruder;
// 4307     tool_change(0, 0, true);
// 4308   #endif
// 4309 
// 4310   #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
// 4311     extruder_duplication_enabled = false;
// 4312   #endif
// 4313 
// 4314   setup_for_endstop_or_probe_move();
// 4315   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4316     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> endstops.enable(true)");
// 4317   #endif
// 4318   endstops.enable(true); // Enable endstops for next homing move
// 4319 
// 4320   //#if ENABLED(DELTA)
// 4321   if(MACHINETPYE == DELTA)
// 4322 
// 4323     home_delta();
// 4324 
// 4325   //#else // NOT DELTA
// 4326 	else 
// 4327 		{
// 4328     const bool homeX = code_seen('X'), homeY = code_seen('Y'), homeZ = code_seen('Z'),
// 4329                home_all_axis = (!homeX && !homeY && !homeZ) || (homeX && homeY && homeZ);
// 4330 
// 4331     set_destination_to_current();
// 4332 
// 4333    // #if Z_HOME_DIR > 0  // If homing away from BED do Z first
// 4334 if(Z_HOME_DIR > 0){		/*--mks cfg--*/
// 4335       if (home_all_axis || homeZ) {
// 4336         HOMEAXIS(Z);
// 4337         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4338           if (DEBUGGING(LEVELING)) DEBUG_POS("> HOMEAXIS(Z)", current_position);
// 4339         #endif
// 4340       }
// 4341 }
// 4342    // #else	/*--mks cfg--*/
// 4343    else
// 4344     	{
// 4345       if ((home_all_axis || homeX || homeY) && (mksReprint.mks_printer_state != MKS_REPRINTED)) {    // mksReprint.mks_printer_state
// 4346         // Raise Z before homing any other axes and z is not already high enough (never lower z)
// 4347         destination[Z_AXIS] = LOGICAL_Z_POSITION(Z_HOMING_HEIGHT);
// 4348         if (destination[Z_AXIS] > current_position[Z_AXIS]) {
// 4349 
// 4350           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4351             if (DEBUGGING(LEVELING))
// 4352               SERIAL_ECHOLNPAIR("Raise Z (before homing) to ", destination[Z_AXIS]);
// 4353           #endif
// 4354 
// 4355           do_blocking_move_to_z(destination[Z_AXIS]);
// 4356         }
// 4357       }
// 4358     	}
// 4359    // #endif	/*--mks cfg--*/
// 4360 
// 4361 //    #if ENABLED(QUICK_HOME)		//mks_delta
// 4362    if(MACHINETPYE&IS_SCARA)
// 4363       if (home_all_axis || (homeX && homeY)) quick_home_xy();
// 4364 //    #endif
// 4365 
// 4366    // #if ENABLED(HOME_Y_BEFORE_X)	/*--mks cfg--*/
// 4367 	if(HOME_Y_BEFORE_X)
// 4368       // Home Y
// 4369       if (home_all_axis || homeY) {
// 4370         HOMEAXIS(Y);
// 4371         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4372           if (DEBUGGING(LEVELING)) DEBUG_POS("> homeY", current_position);
// 4373         #endif
// 4374       }
// 4375 
// 4376     //#endif
// 4377 
// 4378     // Home X
// 4379     if (home_all_axis || homeX) {
// 4380 
// 4381       #if ENABLED(DUAL_X_CARRIAGE)
// 4382 
// 4383         // Always home the 2nd (right) extruder first
// 4384         active_extruder = 1;
// 4385         HOMEAXIS(X);
// 4386 
// 4387         // Remember this extruder's position for later tool change
// 4388         inactive_extruder_x_pos = RAW_X_POSITION(current_position[X_AXIS]);
// 4389 
// 4390         // Home the 1st (left) extruder
// 4391         active_extruder = 0;
// 4392         HOMEAXIS(X);
// 4393 
// 4394         // Consider the active extruder to be parked
// 4395         COPY(raised_parked_position, current_position);
// 4396         delayed_move_time = 0;
// 4397         active_extruder_parked = true;
// 4398 
// 4399       #else
// 4400 
// 4401         HOMEAXIS(X);
// 4402 
// 4403       #endif
// 4404 
// 4405       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4406         if (DEBUGGING(LEVELING)) DEBUG_POS("> homeX", current_position);
// 4407       #endif
// 4408     }
// 4409 
// 4410 //    #if DISABLED(HOME_Y_BEFORE_X)	/*--mks cfg--*/
// 4411 	if(!HOME_Y_BEFORE_X)
// 4412       // Home Y
// 4413       if (home_all_axis || homeY) {
// 4414         HOMEAXIS(Y);
// 4415         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4416           if (DEBUGGING(LEVELING)) DEBUG_POS("> homeY", current_position);
// 4417         #endif
// 4418       }
// 4419     //#endif
// 4420 
// 4421     // Home Z last if homing towards the bed
// 4422     //#if Z_HOME_DIR < 0	/*--mks cfg--*/
// 4423 	if(Z_HOME_DIR < 0)
// 4424       if (home_all_axis || homeZ) {
// 4425         #if ENABLED(Z_SAFE_HOMING)
// 4426           home_z_safely();
// 4427         #else
// 4428           HOMEAXIS(Z);
// 4429         #endif
// 4430         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4431           if (DEBUGGING(LEVELING)) DEBUG_POS("> (home_all_axis || homeZ) > final", current_position);
// 4432         #endif
// 4433       } // home_all_axis || homeZ
// 4434 
// 4435 	//#endif // Z_HOME_DIR < 0	/*--mks cfg--*/
// 4436 
// 4437     SYNC_PLAN_POSITION_KINEMATIC();
// 4438 }
// 4439   //#endif // !DELTA (gcode_G28)
// 4440 
// 4441   endstops.not_homing();
// 4442 
// 4443   #if ENABLED(DELTA) && ENABLED(DELTA_HOME_TO_SAFE_ZONE)
// 4444     // move to a height where we can use the full xy-area
// 4445     abc
// 4446     do_blocking_move_to_z(delta_clip_start_height);
// 4447   #endif
// 4448 //#if ENABLED(AUTO_BED_LEVELING_UBL)
// 4449 	if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
// 4450     set_bed_leveling_enabled(bed_leveling_state_at_entry);
// 4451 //#endif
// 4452   clean_up_after_endstop_or_probe_move();
// 4453 
// 4454   // Restore the active tool after homing
// 4455   #if HOTENDS > 1
// 4456     tool_change(old_tool_index, 0, true);
// 4457   #endif
// 4458 
// 4459   report_current_position();
// 4460 
// 4461   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4462     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< gcode_G28");
// 4463   #endif
// 4464 } // G28
// 4465 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock56 Using cfiCommon0
          CFI Function _Z13home_all_axesv
          CFI FunCall _Z9gcode_G28v
        THUMB
// 4466 void home_all_axes() { gcode_G28(); }
_Z13home_all_axesv:
        B.W      _Z9gcode_G28v
          CFI EndBlock cfiBlock56
// 4467 
// 4468 #if HAS_PROBING_PROCEDURE
// 4469 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock57 Using cfiCommon0
          CFI Function _Z18out_of_range_errorPKc
        THUMB
// 4470   void out_of_range_error(const char* p_edge) {
_Z18out_of_range_errorPKc:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
// 4471     SERIAL_PROTOCOLPGM("?Probe ");
        ADR.W    R0,?_18
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 4472     serialprintPGM(p_edge);
        MOV      R0,R4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 4473     SERIAL_PROTOCOLLNPGM(" position out of range.");
        ADR.W    R0,?_19
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
// 4474   }
          CFI EndBlock cfiBlock57

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_18:
        DC8 "?Probe "

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_19:
        DC8 " position out of range.\012"
        DC8 0, 0, 0
// 4475 
// 4476 #endif
// 4477 
// 4478 /*--mks cfg-- MESH_BED_LEVELING */
// 4479 //#if ENABLED(MESH_BED_LEVELING) || ENABLED(PROBE_MANUALLY)
// 4480 #if 1
// 4481   inline void _manual_goto_xy(const float &x, const float &y) {
// 4482     const float old_feedrate_mm_s = feedrate_mm_s;
// 4483 
// 4484     //#if MANUAL_PROBE_HEIGHT > 0	//mks
// 4485     #if 1
// 4486       feedrate_mm_s = homing_feedrate_mm_s[Z_AXIS];
// 4487       current_position[Z_AXIS] = LOGICAL_Z_POSITION(Z_MIN_POS) + MANUAL_PROBE_HEIGHT;
// 4488       line_to_current_position();
// 4489     #endif
// 4490 
// 4491     feedrate_mm_s = MMM_TO_MMS(XY_PROBE_SPEED);
// 4492     current_position[X_AXIS] = LOGICAL_X_POSITION(x);
// 4493     current_position[Y_AXIS] = LOGICAL_Y_POSITION(y);
// 4494     line_to_current_position();
// 4495 
// 4496     //#if MANUAL_PROBE_HEIGHT > 0	//mks
// 4497     #if 1
// 4498       feedrate_mm_s = homing_feedrate_mm_s[Z_AXIS];
// 4499       current_position[Z_AXIS] = LOGICAL_Z_POSITION(Z_MIN_POS) + 0.2; // just slightly over the bed
// 4500       line_to_current_position();
// 4501     #endif
// 4502 
// 4503     feedrate_mm_s = old_feedrate_mm_s;
// 4504     stepper.synchronize();
// 4505   }
// 4506 
// 4507 #endif
// 4508 
// 4509 /*--mks cfg-- MESH_BED_LEVELING */
// 4510 //#if ENABLED(MESH_BED_LEVELING)
// 4511 #if 1
// 4512   // Save 130 bytes with non-duplication of PSTR

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock58 Using cfiCommon0
          CFI Function _Z15say_not_enteredv
        THUMB
// 4513   void say_not_entered() { SERIAL_PROTOCOLLNPGM(" not entered."); }
_Z15say_not_enteredv:
        ADR.W    R0,?_20
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI EndBlock cfiBlock58

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_20:
        DC8 " not entered.\012"
        DC8 0
// 4514 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock59 Using cfiCommon0
          CFI Function _Z15mbl_mesh_reportv
        THUMB
// 4515   void mbl_mesh_report() {
_Z15mbl_mesh_reportv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 4516     SERIAL_PROTOCOLLNPGM("Num X,Y: " STRINGIFY(GRID_MAX_POINTS_X) "," STRINGIFY(GRID_MAX_POINTS_Y));
        ADR.W    R0,?_21
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 4517     SERIAL_PROTOCOLPGM("Z offset: "); SERIAL_PROTOCOL_F(mbl.z_offset, 5);
        ADR.W    R0,?_22
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R0,??DataTable136_16
        LDR      R0,[R0, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable136_2
        LDRB     R2,[R2, #+7]
        CMP      R2,#+0
        BNE.N    ??mbl_mesh_report_0
        MOVS     R2,#+5
        STR      R2,[SP, #+0]
        MOV      R2,R0
        MOV      R3,R1
        LDR.W    R0,??DataTable136_17
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
        B.N      ??mbl_mesh_report_1
??mbl_mesh_report_0:
        MOVS     R2,#+5
        STR      R2,[SP, #+0]
        MOV      R2,R0
        MOV      R3,R1
        LDR.N    R0,??DataTable129_1
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
// 4518     SERIAL_PROTOCOLLNPGM("\nMeasured points:");
??mbl_mesh_report_1:
        ADR.W    R0,?_23
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 4519 	/*--mks cfg-- LCD_ MESH_BED_LEVELING */
// 4520 	/*
// 4521     print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 5,
// 4522       [](const uint8_t ix, const uint8_t iy) { return mbl.z_values[ix][iy]; }
// 4523     );*/
// 4524     print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 5,2);
        LDR.N    R0,??DataTable131_1
        MOVS     R3,#+2
        MOVS     R2,#+5
        LDRB     R1,[R0, #+1]
        LDRB     R0,[R0, #+0]
        POP      {R12,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531914print_2d_arrayEhhhh
        B.W      _ZN37_INTERNAL_15_Marlin_main_cpp_3178531914print_2d_arrayEhhhh
// 4525   }
          CFI EndBlock cfiBlock59

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable129:
        DC32     mks_heating_busy+0x84

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable129_1:
        DC32     serial2

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_21:
        DC8 4EH, 75H, 6DH, 20H, 58H, 2CH, 59H, 3AH
        DC8 20H, 6DH, 6BH, 73H, 43H, 66H, 67H, 2EH
        DC8 67H, 72H, 69H, 64H, 5FH, 6DH, 61H, 78H
        DC8 5FH, 70H, 6FH, 69H, 6EH, 74H, 73H, 5FH
        DC8 78H, 2CH, 6DH, 6BH, 73H, 43H, 66H, 67H
        DC8 2EH, 67H, 72H, 69H, 64H, 5FH, 6DH, 61H
        DC8 78H, 5FH, 70H, 6FH, 69H, 6EH, 74H, 73H
        DC8 5FH, 79H, 0AH, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_22:
        DC8 "Z offset: "
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_23:
        DC8 "\012Measured points:\012"
        DC8 0
// 4526 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock60 Using cfiCommon0
          CFI Function _Z17mesh_probing_donev
        THUMB
// 4527   void mesh_probing_done() {
_Z17mesh_probing_donev:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 4528     mbl.set_has_mesh(true);
        MOVS     R0,#+1
          CFI FunCall _ZN17mesh_bed_leveling12set_has_meshEb
        BL       _ZN17mesh_bed_leveling12set_has_meshEb
// 4529     home_all_axes();
          CFI FunCall _Z13home_all_axesv
        BL       _Z13home_all_axesv
// 4530     set_bed_leveling_enabled(true);
        MOVS     R0,#+1
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z24set_bed_leveling_enabledb
        B.W      _Z24set_bed_leveling_enabledb
// 4531     #if ENABLED(MESH_G28_REST_ORIGIN)
// 4532       current_position[Z_AXIS] = LOGICAL_Z_POSITION(Z_MIN_POS);
// 4533       set_destination_to_current();
// 4534       line_to_destination(homing_feedrate_mm_s[Z_AXIS]);
// 4535       stepper.synchronize();
// 4536     #endif
// 4537   }
          CFI EndBlock cfiBlock60
// 4538 
// 4539   /**
// 4540    * G29: Mesh-based Z probe, probes a grid and produces a
// 4541    *      mesh to compensate for variable bed height
// 4542    *
// 4543    * Parameters With MESH_BED_LEVELING:
// 4544    *
// 4545    *  S0              Produce a mesh report
// 4546    *  S1              Start probing mesh points
// 4547    *  S2              Probe the next mesh point
// 4548    *  S3 Xn Yn Zn.nn  Manually modify a single point
// 4549    *  S4 Zn.nn        Set z offset. Positive away from bed, negative closer to bed.
// 4550    *  S5              Reset and disable mesh
// 4551    *
// 4552    * The S0 report the points as below
// 4553    *
// 4554    *  +----> X-axis  1-n
// 4555    *  |
// 4556    *  |
// 4557    *  v Y-axis  1-n
// 4558    *
// 4559    */
// 4560 	  /*--mks cfg-- MESH_BED_LEVELING */
// 4561 //  inline void gcode_G29() {
// 4562   inline void gcode_G29_MESH_BED_LEVELING() {
// 4563     static int mbl_probe_index = -1;
// 4564     #if HAS_SOFTWARE_ENDSTOPS
// 4565       static bool enable_soft_endstops;
// 4566     #endif
// 4567 
// 4568     const MeshLevelingState state = code_seen('S') ? (MeshLevelingState)code_value_byte() : MeshReport;
// 4569     if (!WITHIN(state, 0, 5)) {
// 4570       SERIAL_PROTOCOLLNPGM("S out of range (0-5).");
// 4571       return;
// 4572     }
// 4573 
// 4574     int8_t px, py;
// 4575 
// 4576     switch (state) {
// 4577       case MeshReport:
// 4578         if (mbl.has_mesh()) {
// 4579           SERIAL_PROTOCOLLNPAIR("State: ", mbl.active() ? MSG_ON : MSG_OFF);
// 4580           mbl_mesh_report();
// 4581         }
// 4582         else
// 4583           SERIAL_PROTOCOLLNPGM("Mesh bed leveling has no data.");
// 4584         break;
// 4585 
// 4586       case MeshStart:
// 4587         mbl.reset();
// 4588         mbl_probe_index = 0;
// 4589         enqueue_and_echo_commands_P(PSTR("G28\nG29 S2"));
// 4590         break;
// 4591 
// 4592       case MeshNext:
// 4593         if (mbl_probe_index < 0) {
// 4594           SERIAL_PROTOCOLLNPGM("Start mesh probing with \"G29 S1\" first.");
// 4595           return;
// 4596         }
// 4597         // For each G29 S2...
// 4598         if (mbl_probe_index == 0) {
// 4599           #if HAS_SOFTWARE_ENDSTOPS
// 4600             // For the initial G29 S2 save software endstop state
// 4601             enable_soft_endstops = soft_endstops_enabled;
// 4602           #endif
// 4603         }
// 4604         else {
// 4605           // For G29 S2 after adjusting Z.
// 4606           mbl.set_zigzag_z(mbl_probe_index - 1, current_position[Z_AXIS]);
// 4607           #if HAS_SOFTWARE_ENDSTOPS
// 4608             soft_endstops_enabled = enable_soft_endstops;
// 4609           #endif
// 4610         }
// 4611         // If there's another point to sample, move there with optional lift.
// 4612         if (mbl_probe_index < (GRID_MAX_POINTS_X) * (GRID_MAX_POINTS_Y)) {
// 4613           mbl.zigzag(mbl_probe_index, px, py);
// 4614           _manual_goto_xy(mbl.index_to_xpos[px], mbl.index_to_ypos[py]);
// 4615 
// 4616           #if HAS_SOFTWARE_ENDSTOPS
// 4617             // Disable software endstops to allow manual adjustment
// 4618             // If G29 is not completed, they will not be re-enabled
// 4619             soft_endstops_enabled = false;
// 4620           #endif
// 4621 
// 4622           mbl_probe_index++;
// 4623         }
// 4624         else {
// 4625           // One last "return to the bed" (as originally coded) at completion
// 4626           current_position[Z_AXIS] = LOGICAL_Z_POSITION(Z_MIN_POS) + MANUAL_PROBE_HEIGHT;
// 4627           line_to_current_position();
// 4628           stepper.synchronize();
// 4629 
// 4630           // After recording the last point, activate home and activate
// 4631           mbl_probe_index = -1;
// 4632           SERIAL_PROTOCOLLNPGM("Mesh probing done.");
// 4633           BUZZ(100, 659);
// 4634           BUZZ(100, 698);
// 4635           mesh_probing_done();
// 4636         }
// 4637         break;
// 4638 
// 4639       case MeshSet:
// 4640         if (code_seen('X')) {
// 4641           px = code_value_int() - 1;
// 4642           if (!WITHIN(px, 0, GRID_MAX_POINTS_X - 1)) {
// 4643             SERIAL_PROTOCOLLNPGM("X out of range (1-" STRINGIFY(GRID_MAX_POINTS_X) ").");
// 4644             return;
// 4645           }
// 4646         }
// 4647         else {
// 4648           SERIAL_CHAR('X'); say_not_entered();
// 4649           return;
// 4650         }
// 4651 
// 4652         if (code_seen('Y')) {
// 4653           py = code_value_int() - 1;
// 4654           if (!WITHIN(py, 0, GRID_MAX_POINTS_Y - 1)) {
// 4655             SERIAL_PROTOCOLLNPGM("Y out of range (1-" STRINGIFY(GRID_MAX_POINTS_Y) ").");
// 4656             return;
// 4657           }
// 4658         }
// 4659         else {
// 4660           SERIAL_CHAR('Y'); say_not_entered();
// 4661           return;
// 4662         }
// 4663 
// 4664         if (code_seen('Z')) {
// 4665           mbl.z_values[px][py] = code_value_linear_units();
// 4666         }
// 4667         else {
// 4668           SERIAL_CHAR('Z'); say_not_entered();
// 4669           return;
// 4670         }
// 4671         break;
// 4672 
// 4673       case MeshSetZOffset:
// 4674         if (code_seen('Z')) {
// 4675           mbl.z_offset = code_value_linear_units();
// 4676         }
// 4677         else {
// 4678           SERIAL_CHAR('Z'); say_not_entered();
// 4679           return;
// 4680         }
// 4681         break;
// 4682 
// 4683       case MeshReset:
// 4684         reset_bed_level();
// 4685         break;
// 4686 
// 4687     } // switch(state)
// 4688 
// 4689     report_current_position();
// 4690   }
// 4691 
// 4692 /*--mks cfg-- AUTO_BED_LEVELING_BILINEAR */
// 4693 //#elif HAS_ABL && DISABLED(AUTO_BED_LEVELING_UBL)
// 4694 #endif	//MESH_BED_LEVELING
// 4695 #if 1
// 4696 
// 4697 //  #if ABL_GRID
// 4698 	#if 1
// 4699     #if ENABLED(PROBE_Y_FIRST)
// 4700       #define PR_OUTER_VAR xCount
// 4701       #define PR_OUTER_END abl_grid_points_x
// 4702       #define PR_INNER_VAR yCount
// 4703       #define PR_INNER_END abl_grid_points_y
// 4704     #else
// 4705       #define PR_OUTER_VAR yCount
// 4706       #define PR_OUTER_END abl_grid_points_y
// 4707       #define PR_INNER_VAR xCount
// 4708       #define PR_INNER_END abl_grid_points_x
// 4709     #endif
// 4710   #endif
// 4711 
// 4712   /**
// 4713    * G29: Detailed Z probe, probes the bed at 3 or more points.
// 4714    *      Will fail if the printer has not been homed with G28.
// 4715    *
// 4716    * Enhanced G29 Auto Bed Leveling Probe Routine
// 4717    *
// 4718    *  D  Dry-Run mode. Just evaluate the bed Topology - Don't apply
// 4719    *     or alter the bed level data. Useful to check the topology
// 4720    *     after a first run of G29.
// 4721    *
// 4722    *  J  Jettison current bed leveling data
// 4723    *
// 4724    *  V  Set the verbose level (0-4). Example: "G29 V3"
// 4725    *
// 4726    * Parameters With LINEAR leveling only:
// 4727    *
// 4728    *  P  Set the size of the grid that will be probed (P x P points).
// 4729    *     Example: "G29 P4"
// 4730    *
// 4731    *  X  Set the X size of the grid that will be probed (X x Y points).
// 4732    *     Example: "G29 X7 Y5"
// 4733    *
// 4734    *  Y  Set the Y size of the grid that will be probed (X x Y points).
// 4735    *
// 4736    *  T  Generate a Bed Topology Report. Example: "G29 P5 T" for a detailed report.
// 4737    *     This is useful for manual bed leveling and finding flaws in the bed (to
// 4738    *     assist with part placement).
// 4739    *     Not supported by non-linear delta printer bed leveling.
// 4740    *
// 4741    * Parameters With LINEAR and BILINEAR leveling only:
// 4742    *
// 4743    *  S  Set the XY travel speed between probe points (in units/min)
// 4744    *
// 4745    *  F  Set the Front limit of the probing grid
// 4746    *  B  Set the Back limit of the probing grid
// 4747    *  L  Set the Left limit of the probing grid
// 4748    *  R  Set the Right limit of the probing grid
// 4749    *
// 4750    * Parameters with DEBUG_LEVELING_FEATURE only:
// 4751    *
// 4752    *  C  Make a totally fake grid with no actual probing.
// 4753    *     For use in testing when no probing is possible.
// 4754    *
// 4755    * Parameters with BILINEAR leveling only:
// 4756    *
// 4757    *  Z  Supply an additional Z probe offset
// 4758    *
// 4759    * Extra parameters with PROBE_MANUALLY:
// 4760    *
// 4761    *  To do manual probing simply repeat G29 until the procedure is complete.
// 4762    *  The first G29 accepts parameters. 'G29 Q' for status, 'G29 A' to abort.
// 4763    *
// 4764    *  Q  Query leveling and G29 state
// 4765    *
// 4766    *  A  Abort current leveling procedure
// 4767    *
// 4768    *  W  Write a mesh point. (Ignored during leveling.)
// 4769    *  X  Required X for mesh point
// 4770    *  Y  Required Y for mesh point
// 4771    *  Z  Required Z for mesh point
// 4772    *
// 4773    * Without PROBE_MANUALLY:
// 4774    *
// 4775    *  E  By default G29 will engage the Z probe, test the bed, then disengage.
// 4776    *     Include "E" to engage/disengage the Z probe for each sample.
// 4777    *     There's no extra effect if you have a fixed Z probe.
// 4778    *
// 4779    */
// 4780   inline void gcode_G29() {
// 4781 
// 4782     // G29 Q is also available if debugging
// 4783     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4784       const bool query = code_seen('Q');
// 4785       const uint8_t old_debug_flags = marlin_debug_flags;
// 4786       if (query) marlin_debug_flags |= DEBUG_LEVELING;
// 4787       if (DEBUGGING(LEVELING)) {
// 4788         DEBUG_POS(">>> gcode_G29", current_position);
// 4789         log_machine_info();
// 4790       }
// 4791       marlin_debug_flags = old_debug_flags;
// 4792       #if DISABLED(PROBE_MANUALLY)
// 4793         if (query) return;
// 4794       #endif
// 4795     #endif
// 4796 
// 4797     #if ENABLED(DEBUG_LEVELING_FEATURE) && DISABLED(PROBE_MANUALLY)
// 4798       const bool faux = code_seen('C') && code_value_bool();
// 4799     #else
// 4800       bool constexpr faux = false;
// 4801     #endif
// 4802 
// 4803 
// 4804     // Don't allow auto-leveling without homing first
// 4805     if (axis_unhomed_error(true, true, true)) return;
// 4806 
// 4807     // Define local vars 'static' for manual probing, 'auto' otherwise
// 4808     #if ENABLED(PROBE_MANUALLY)
// 4809       #define ABL_VAR static_nouse
// 4810     #else
// 4811       #define ABL_VAR
// 4812     #endif
// 4813 
// 4814     ABL_VAR int verbose_level=0;
// 4815     ABL_VAR float xProbe=0, yProbe=0, measured_z=0;
// 4816     ABL_VAR bool dryrun=false, abl_should_enable=false;
// 4817 
// 4818 	ABL_VAR int abl_probe_index=0;
// 4819 
// 4820     #if HAS_SOFTWARE_ENDSTOPS && ENABLED(PROBE_MANUALLY)
// 4821       ABL_VAR bool enable_soft_endstops = true;
// 4822     #endif
// 4823 
// 4824    // #if ABL_GRID
// 4825 	//if(BED_LEVELING_METHOD&ABL_GRID)  
// 4826 		//{
// 4827 	
// 4828 	#if ENABLED(PROBE_MANUALLY)
// 4829 	  ABL_VAR uint8_t PR_OUTER_VAR;
// 4830 	  ABL_VAR  int8_t PR_INNER_VAR;
// 4831 	#endif
// 4832 	
// 4833 	ABL_VAR int left_probe_bed_position=0, right_probe_bed_position=0, front_probe_bed_position=0, back_probe_bed_position=0;
// 4834 	ABL_VAR float xGridSpacing=0, yGridSpacing=0;
// 4835 #define ABL_GRID_MAX (GRID_MAX_POINTS_X) * (GRID_MAX_POINTS_Y)
// 4836 
// 4837 
// 4838 //#if ABL_PLANAR
// 4839   //if(BED_LEVELING_METHOD&ABL_PLANAR)
// 4840   	//{
// 4841   ABL_VAR uint8_t abl_grid_points_x = GRID_MAX_POINTS_X,
// 4842 				  abl_grid_points_y = GRID_MAX_POINTS_Y;
// 4843   ABL_VAR bool do_topography_map=false;
// 4844  
// 4845 
// 4846   	//}
// 4847 //#else // 3-point
// 4848 /*
// 4849 else
// 4850 {
// 4851   uint8_t constexpr abl_grid_points_x = GRID_MAX_POINTS_X,
// 4852 					abl_grid_points_y = GRID_MAX_POINTS_Y;
// 4853 }
// 4854 */
// 4855 //#endif
// 4856 //#if ENABLED(AUTO_BED_LEVELING_LINEAR) || ENABLED(PROBE_MANUALLY)
// 4857   //if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_LINEAR)
// 4858   	//{
// 4859   	int abl2;
// 4860 	  //#if ABL_PLANAR
// 4861 	  if(! (BED_LEVELING_METHOD&ABL_PLANAR)) abl2 = ABL_GRID_MAX;
// 4862 	  //#endif
// 4863   	//}
// 4864 //#endif
// 4865 
// 4866 
// 4867 
// 4868       //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 4869 	//if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_BILINEAR)
// 4870 		//{
// 4871         ABL_VAR float zoffset;
// 4872 		//}
// 4873       //#elif ENABLED(AUTO_BED_LEVELING_LINEAR)
// 4874 	  //else if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_LINEAR)
// 4875 	  	//{
// 4876         ABL_VAR int indexIntoAB[GRID_MAX_POINTS_X_MAX][GRID_MAX_POINTS_Y_MAX];
// 4877 
// 4878 /*        ABL_VAR float eqnAMatrix[ABL_GRID_MAX * 3], // "A" matrix of the linear system of equations
// 4879                      eqnBVector[ABL_GRID_MAX],     // "B" vector of Z points
// 4880                      mean;*/
// 4881 
// 4882 /*
// 4883 			  ABL_VAR float eqnAMatrix[9 * 3], // "A" matrix of the linear system of equations
// 4884 						 eqnBVector[9],	   // "B" vector of Z points
// 4885 						 mean;
// 4886 */
// 4887 
// 4888                     
// 4889 		ABL_VAR float *eqnAMatrix=NULL, // "A" matrix of the linear system of equations
// 4890 			 		 *eqnBVector=NULL,	   // "B" vector of Z points
// 4891 					 mean;
// 4892 		
// 4893 		eqnAMatrix = (float *)malloc((ABL_GRID_MAX * 3 + 1) * sizeof(float));
// 4894 		if(eqnAMatrix == NULL)
// 4895 			{
// 4896 			Running = false;
// 4897 			kill("malloc eqnAMatrix err!");
// 4898 			}
// 4899 		for(int i=0;i<ABL_GRID_MAX * 3 + 1;i++)		*(eqnAMatrix+i) = 0.0;
// 4900 
// 4901 		
// 4902 		eqnBVector = (float *)malloc((ABL_GRID_MAX + 1) * sizeof(float));
// 4903 		if(eqnBVector == NULL)
// 4904 			{
// 4905 			Running = false;
// 4906 			kill("malloc eqnBVector err!");
// 4907 			}
// 4908 		for(int i=0;i<ABL_GRID_MAX + 1;i++) 	*(eqnBVector+i) = 0.0;
// 4909 
// 4910 		
// 4911 	  //}
// 4912       //#endif
// 4913 
// 4914 		//}
// 4915     //#elif ENABLED(AUTO_BED_LEVELING_3POINT)
// 4916     //else if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_3POINT)	
// 4917 		//{
// 4918       // Probe at 3 arbitrary points
// 4919       ABL_VAR vector_3 points[3] = {
// 4920         vector_3(ABL_PROBE_PT_1_X, ABL_PROBE_PT_1_Y, 0),
// 4921         vector_3(ABL_PROBE_PT_2_X, ABL_PROBE_PT_2_Y, 0),
// 4922         vector_3(ABL_PROBE_PT_3_X, ABL_PROBE_PT_3_Y, 0)
// 4923       };
// 4924     //}
// 4925     //#endif // AUTO_BED_LEVELING_3POINT
// 4926 
// 4927     /**
// 4928      * On the initial G29 fetch command parameters.
// 4929      */
// 4930 
// 4931 	
// 4932     if (!g29_in_progress) {
// 4933 
// 4934 #if 0
// 4935       #if ENABLED(PROBE_MANUALLY) || ENABLED(AUTO_BED_LEVELING_LINEAR)
// 4936         abl_probe_index = 0;
// 4937       #endif
// 4938 #else
// 4939 		if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_LINEAR)
// 4940 			abl_probe_index = 0;
// 4941 #endif
// 4942       abl_should_enable = planner.abl_enabled;
// 4943 
// 4944       //#if ENABLED(AUTO_BED_LEVELING_BILINEAR) /*--mks cfg-- AUTO_BED_LEVELING_BILINEAR */
// 4945 	if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR) {
// 4946         if (code_seen('W')) {
// 4947           if (!bilinear_grid_spacing[X_AXIS]) {
// 4948             SERIAL_ERROR_START;
// 4949             SERIAL_ERRORLNPGM("No bilinear grid");
// 4950             return;
// 4951           }
// 4952 
// 4953           const float z = code_seen('Z') && code_has_value() ? code_value_float() : 99999;
// 4954           if (!WITHIN(z, -10, 10)) {
// 4955             SERIAL_ERROR_START;
// 4956             SERIAL_ERRORLNPGM("Bad Z value");
// 4957             return;
// 4958           }
// 4959 
// 4960           const float x = code_seen('X') && code_has_value() ? code_value_float() : 99999,
// 4961                       y = code_seen('Y') && code_has_value() ? code_value_float() : 99999;
// 4962           int8_t i = code_seen('I') && code_has_value() ? code_value_byte() : -1,
// 4963                  j = code_seen('J') && code_has_value() ? code_value_byte() : -1;
// 4964 
// 4965           if (x < 99998 && y < 99998) {
// 4966             // Get nearest i / j from x / y
// 4967             i = (x - LOGICAL_X_POSITION(bilinear_start[X_AXIS]) + 0.5 * xGridSpacing) / xGridSpacing;
// 4968             j = (y - LOGICAL_Y_POSITION(bilinear_start[Y_AXIS]) + 0.5 * yGridSpacing) / yGridSpacing;
// 4969             i = constrain(i, 0, GRID_MAX_POINTS_X - 1);
// 4970             j = constrain(j, 0, GRID_MAX_POINTS_Y - 1);
// 4971           }
// 4972           if (WITHIN(i, 0, GRID_MAX_POINTS_X - 1) && WITHIN(j, 0, GRID_MAX_POINTS_Y)) {
// 4973             set_bed_leveling_enabled(false);
// 4974             z_values[i][j] = z;
// 4975             #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 4976               bed_level_virt_interpolate();
// 4977             #endif
// 4978             set_bed_leveling_enabled(abl_should_enable);
// 4979           }
// 4980           return;
// 4981         } // code_seen('W')
// 4982 
// 4983       }//#endif
// 4984 
// 4985 
// 4986 
// 4987       //#if HAS_LEVELING
// 4988 	  if(BED_LEVELING_METHOD&HAS_LEVELING)
// 4989 	  	{
// 4990         // Jettison bed leveling data
// 4991         if (code_seen('J')) {
// 4992           reset_bed_level();
// 4993           return;
// 4994         }
// 4995 	  	}
// 4996       //#endif
// 4997 
// 4998       verbose_level = code_seen('V') && code_has_value() ? code_value_int() : 0;
// 4999       if (!WITHIN(verbose_level, 0, 4)) {
// 5000         SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-4).");
// 5001         return;
// 5002       }
// 5003 
// 5004       dryrun = code_seen('D') && code_value_bool();
// 5005 
// 5006 	  /*--mks cfg--begin AUTO_BED_LEVELING_BILINEAR */
// 5007 /*
// 5008       #if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5009 
// 5010         do_topography_map = verbose_level > 2 || code_seen('T');
// 5011 
// 5012         // X and Y specify points in each direction, overriding the default
// 5013         // These values may be saved with the completed mesh
// 5014         abl_grid_points_x = code_seen('X') ? code_value_int() : GRID_MAX_POINTS_X;
// 5015         abl_grid_points_y = code_seen('Y') ? code_value_int() : GRID_MAX_POINTS_Y;
// 5016         if (code_seen('P')) abl_grid_points_x = abl_grid_points_y = code_value_int();
// 5017 
// 5018         if (abl_grid_points_x < 2 || abl_grid_points_y < 2) {
// 5019           SERIAL_PROTOCOLLNPGM("?Number of probe points is implausible (2 minimum).");
// 5020           return;
// 5021         }
// 5022 
// 5023         abl2 = abl_grid_points_x * abl_grid_points_y;
// 5024 
// 5025       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5026 
// 5027         zoffset = code_seen('Z') ? code_value_linear_units() : 0;
// 5028 
// 5029       #endif
// 5030 */		
// 5031 
// 5032 		if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_LINEAR)  {
// 5033 
// 5034         do_topography_map = verbose_level > 2 || code_seen('T');
// 5035 
// 5036         // X and Y specify points in each direction, overriding the default
// 5037         // These values may be saved with the completed mesh
// 5038         abl_grid_points_x = code_seen('X') ? code_value_int() : GRID_MAX_POINTS_X;
// 5039         abl_grid_points_y = code_seen('Y') ? code_value_int() : GRID_MAX_POINTS_Y;
// 5040         if (code_seen('P')) abl_grid_points_x = abl_grid_points_y = code_value_int();
// 5041 
// 5042         if (abl_grid_points_x < 2 || abl_grid_points_y < 2) {
// 5043           SERIAL_PROTOCOLLNPGM("?Number of probe points is implausible (2 minimum).");
// 5044           return;
// 5045         }
// 5046 
// 5047         abl2 = abl_grid_points_x * abl_grid_points_y;
// 5048 			}
// 5049 		else if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_BILINEAR)
// 5050 			{
// 5051         	zoffset = code_seen('Z') ? code_value_linear_units() : 0;
// 5052 			}
// 5053 
// 5054 	  /*--mks cfg--end AUTO_BED_LEVELING_BILINEAR */
// 5055 
// 5056 
// 5057       //#if ABL_GRID
// 5058 	if(BED_LEVELING_METHOD&ABL_GRID)  {
// 5059 	
// 5060         xy_probe_feedrate_mm_s = MMM_TO_MMS(code_seen('S') ? code_value_linear_units() : XY_PROBE_SPEED);
// 5061 
// 5062         left_probe_bed_position = code_seen('L') ? (int)code_value_linear_units() : LOGICAL_X_POSITION(LEFT_PROBE_BED_POSITION);
// 5063         right_probe_bed_position = code_seen('R') ? (int)code_value_linear_units() : LOGICAL_X_POSITION(RIGHT_PROBE_BED_POSITION);
// 5064         front_probe_bed_position = code_seen('F') ? (int)code_value_linear_units() : LOGICAL_Y_POSITION(FRONT_PROBE_BED_POSITION);
// 5065         back_probe_bed_position = code_seen('B') ? (int)code_value_linear_units() : LOGICAL_Y_POSITION(BACK_PROBE_BED_POSITION);
// 5066 
// 5067         const bool left_out_l = left_probe_bed_position < LOGICAL_X_POSITION(MIN_PROBE_X),
// 5068                    left_out = left_out_l || left_probe_bed_position > right_probe_bed_position - (MIN_PROBE_EDGE),
// 5069                    right_out_r = right_probe_bed_position > LOGICAL_X_POSITION(MAX_PROBE_X),
// 5070                    right_out = right_out_r || right_probe_bed_position < left_probe_bed_position + MIN_PROBE_EDGE,
// 5071                    front_out_f = front_probe_bed_position < LOGICAL_Y_POSITION(MIN_PROBE_Y),
// 5072                    front_out = front_out_f || front_probe_bed_position > back_probe_bed_position - (MIN_PROBE_EDGE),
// 5073                    back_out_b = back_probe_bed_position > LOGICAL_Y_POSITION(MAX_PROBE_Y),
// 5074                    back_out = back_out_b || back_probe_bed_position < front_probe_bed_position + MIN_PROBE_EDGE;
// 5075 
// 5076         if (left_out || right_out || front_out || back_out) {
// 5077           if (left_out) {
// 5078             out_of_range_error(PSTR("(L)eft"));
// 5079             left_probe_bed_position = left_out_l ? LOGICAL_X_POSITION(MIN_PROBE_X) : right_probe_bed_position - (MIN_PROBE_EDGE);
// 5080           }
// 5081           if (right_out) {
// 5082             out_of_range_error(PSTR("(R)ight"));
// 5083             right_probe_bed_position = right_out_r ? LOGICAL_Y_POSITION(MAX_PROBE_X) : left_probe_bed_position + MIN_PROBE_EDGE;
// 5084           }
// 5085           if (front_out) {
// 5086             out_of_range_error(PSTR("(F)ront"));
// 5087             front_probe_bed_position = front_out_f ? LOGICAL_Y_POSITION(MIN_PROBE_Y) : back_probe_bed_position - (MIN_PROBE_EDGE);
// 5088           }
// 5089           if (back_out) {
// 5090             out_of_range_error(PSTR("(B)ack"));
// 5091             back_probe_bed_position = back_out_b ? LOGICAL_Y_POSITION(MAX_PROBE_Y) : front_probe_bed_position + MIN_PROBE_EDGE;
// 5092           }
// 5093           return;
// 5094         }
// 5095 
// 5096         // probe at the points of a lattice grid
// 5097         xGridSpacing = (right_probe_bed_position - left_probe_bed_position) / (abl_grid_points_x - 1);
// 5098         yGridSpacing = (back_probe_bed_position - front_probe_bed_position) / (abl_grid_points_y - 1);
// 5099 		}
// 5100       //#endif // ABL_GRID
// 5101 
// 5102       if (verbose_level > 0) {
// 5103         SERIAL_PROTOCOLLNPGM("G29 Auto Bed Leveling");
// 5104         if (dryrun) SERIAL_PROTOCOLLNPGM("Running in DRY-RUN mode");
// 5105       }
// 5106 
// 5107       stepper.synchronize();
// 5108 
// 5109       // Disable auto bed leveling during G29
// 5110       planner.abl_enabled = false;
// 5111 
// 5112       if (!dryrun) {
// 5113         // Re-orient the current position without leveling
// 5114         // based on where the steppers are positioned.
// 5115         set_current_from_steppers_for_axis(ALL_AXES);
// 5116 
// 5117         // Sync the planner to where the steppers stopped
// 5118         SYNC_PLAN_POSITION_KINEMATIC();
// 5119       }
// 5120 
// 5121       if (!faux) setup_for_endstop_or_probe_move();
// 5122 
// 5123       //xProbe = yProbe = measured_z = 0;
// 5124 
// 5125       #if HAS_BED_PROBE
// 5126         // Deploy the probe. Probe will raise if needed.
// 5127         if (DEPLOY_PROBE()) {
// 5128           planner.abl_enabled = abl_should_enable;
// 5129           return;
// 5130         }
// 5131       #endif
// 5132 
// 5133 	  /*--mks cfg--begin AUTO_BED_LEVELING_BILINEAR */
// 5134 /*
// 5135       #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5136 
// 5137         if ( xGridSpacing != bilinear_grid_spacing[X_AXIS]
// 5138           || yGridSpacing != bilinear_grid_spacing[Y_AXIS]
// 5139           || left_probe_bed_position != LOGICAL_X_POSITION(bilinear_start[X_AXIS])
// 5140           || front_probe_bed_position != LOGICAL_Y_POSITION(bilinear_start[Y_AXIS])
// 5141         ) {
// 5142           if (dryrun) {
// 5143             // Before reset bed level, re-enable to correct the position
// 5144             planner.abl_enabled = abl_should_enable;
// 5145           }
// 5146           // Reset grid to 0.0 or "not probed". (Also disables ABL)
// 5147           reset_bed_level();
// 5148 
// 5149           // Initialize a grid with the given dimensions
// 5150           bilinear_grid_spacing[X_AXIS] = xGridSpacing;
// 5151           bilinear_grid_spacing[Y_AXIS] = yGridSpacing;
// 5152           bilinear_start[X_AXIS] = RAW_X_POSITION(left_probe_bed_position);
// 5153           bilinear_start[Y_AXIS] = RAW_Y_POSITION(front_probe_bed_position);
// 5154 
// 5155           // Can't re-enable (on error) until the new grid is written
// 5156           abl_should_enable = false;
// 5157         }
// 5158 
// 5159       #elif ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5160 
// 5161         mean = 0.0;
// 5162 
// 5163       #endif // AUTO_BED_LEVELING_LINEAR
// 5164 */
// 5165 	if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
// 5166 		{
// 5167         if ( xGridSpacing != bilinear_grid_spacing[X_AXIS]
// 5168           || yGridSpacing != bilinear_grid_spacing[Y_AXIS]
// 5169           || left_probe_bed_position != LOGICAL_X_POSITION(bilinear_start[X_AXIS])
// 5170           || front_probe_bed_position != LOGICAL_Y_POSITION(bilinear_start[Y_AXIS])
// 5171         ) {
// 5172           if (dryrun) {
// 5173             // Before reset bed level, re-enable to correct the position
// 5174             planner.abl_enabled = abl_should_enable;
// 5175           }
// 5176           // Reset grid to 0.0 or "not probed". (Also disables ABL)
// 5177           reset_bed_level();
// 5178 
// 5179           // Initialize a grid with the given dimensions
// 5180           bilinear_grid_spacing[X_AXIS] = xGridSpacing;
// 5181           bilinear_grid_spacing[Y_AXIS] = yGridSpacing;
// 5182           bilinear_start[X_AXIS] = RAW_X_POSITION(left_probe_bed_position);
// 5183           bilinear_start[Y_AXIS] = RAW_Y_POSITION(front_probe_bed_position);
// 5184 
// 5185           // Can't re-enable (on error) until the new grid is written
// 5186           abl_should_enable = false;
// 5187         }
// 5188 		
// 5189 		}
// 5190 		else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_LINEAR)
// 5191 			{
// 5192 			mean = 0.0;
// 5193 			}
// 5194 	  /*--mks cfg--end AUTO_BED_LEVELING_BILINEAR */
// 5195 
// 5196 
// 5197       //#if ENABLED(AUTO_BED_LEVELING_3POINT)
// 5198 	  if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_3POINT)
// 5199 	  	{
// 5200         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5201           if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> 3-point Leveling");
// 5202         #endif
// 5203 
// 5204         // Probe at 3 arbitrary points
// 5205         points[0].z = points[1].z = points[2].z = 0;
// 5206     	}
// 5207       //#endif // AUTO_BED_LEVELING_3POINT
// 5208 
// 5209     } // !g29_in_progress
// 5210 
// 5211     #if ENABLED(PROBE_MANUALLY)
// 5212 
// 5213       // Abort current G29 procedure, go back to ABLStart
// 5214       if (code_seen('A') && g29_in_progress) {
// 5215         SERIAL_PROTOCOLLNPGM("Manual G29 aborted");
// 5216         #if HAS_SOFTWARE_ENDSTOPS
// 5217           soft_endstops_enabled = enable_soft_endstops;
// 5218         #endif
// 5219         planner.abl_enabled = abl_should_enable;
// 5220         g29_in_progress = false;
// 5221       }
// 5222 
// 5223       // Query G29 status
// 5224       if (code_seen('Q')) {
// 5225         if (!g29_in_progress)
// 5226           SERIAL_PROTOCOLLNPGM("Manual G29 idle");
// 5227         else {
// 5228           SERIAL_PROTOCOLPAIR("Manual G29 point ", abl_probe_index + 1);
// 5229           SERIAL_PROTOCOLLNPAIR(" of ", abl2);
// 5230         }
// 5231       }
// 5232 
// 5233       if (code_seen('A') || code_seen('Q')) return;
// 5234 
// 5235       // Fall through to probe the first point
// 5236       g29_in_progress = true;
// 5237 
// 5238       if (abl_probe_index == 0) {
// 5239         // For the initial G29 save software endstop state
// 5240         #if HAS_SOFTWARE_ENDSTOPS
// 5241           enable_soft_endstops = soft_endstops_enabled;
// 5242         #endif
// 5243       }
// 5244       else {
// 5245         // For G29 after adjusting Z.
// 5246         // Save the previous Z before going to the next point
// 5247         measured_z = current_position[Z_AXIS];
// 5248 
// 5249 		/*--mks cfg--begin AUTO_BED_LEVELING_BILINEAR */
// 5250 /*
// 5251         #if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5252 
// 5253           mean += measured_z;
// 5254           eqnBVector[abl_probe_index] = measured_z;
// 5255           eqnAMatrix[abl_probe_index + 0 * abl2] = xProbe;
// 5256           eqnAMatrix[abl_probe_index + 1 * abl2] = yProbe;
// 5257           eqnAMatrix[abl_probe_index + 2 * abl2] = 1;
// 5258 
// 5259         #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5260 
// 5261           z_values[xCount][yCount] = measured_z + zoffset;
// 5262 
// 5263         #elif ENABLED(AUTO_BED_LEVELING_3POINT)
// 5264 
// 5265           points[i].z = measured_z;
// 5266 
// 5267         #endif
// 5268 */
// 5269 		if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
// 5270 			z_values[xCount][yCount] = measured_z + zoffset;
// 5271 		/*--mks cfg--end AUTO_BED_LEVELING_BILINEAR */		
// 5272       }
// 5273 
// 5274       //
// 5275       // If there's another point to sample, move there with optional lift.
// 5276       //
// 5277 
// 5278       //#if ABL_GRID
// 5279 	  if(BED_LEVELING_METHOD&ABL_GRID)
// 5280 	  	{
// 5281         // Find a next point to probe
// 5282         // On the first G29 this will be the first probe point
// 5283         while (abl_probe_index < abl2) {
// 5284 
// 5285           // Set xCount, yCount based on abl_probe_index, with zig-zag
// 5286           PR_OUTER_VAR = abl_probe_index / PR_INNER_END;
// 5287           PR_INNER_VAR = abl_probe_index - (PR_OUTER_VAR * PR_INNER_END);
// 5288 
// 5289           bool zig = (PR_OUTER_VAR & 1) != ((PR_OUTER_END) & 1);
// 5290 
// 5291           if (zig) PR_INNER_VAR = (PR_INNER_END - 1) - PR_INNER_VAR;
// 5292 
// 5293           const float xBase = left_probe_bed_position + xGridSpacing * xCount,
// 5294                       yBase = front_probe_bed_position + yGridSpacing * yCount;
// 5295 
// 5296           xProbe = floor(xBase + (xBase < 0 ? 0 : 0.5));
// 5297           yProbe = floor(yBase + (yBase < 0 ? 0 : 0.5));
// 5298 
// 5299           //#if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5300 		  if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_LINEAR)
// 5301             indexIntoAB[xCount][yCount] = abl_probe_index;
// 5302           //#endif
// 5303 
// 5304           float pos[XYZ] = { xProbe, yProbe, 0 };
// 5305           if (position_is_reachable(pos)) break;
// 5306           ++abl_probe_index;
// 5307         }
// 5308 
// 5309         // Is there a next point to move to?
// 5310         if (abl_probe_index < abl2) {
// 5311           _manual_goto_xy(xProbe, yProbe); // Can be used here too!
// 5312           ++abl_probe_index;
// 5313           #if HAS_SOFTWARE_ENDSTOPS
// 5314             // Disable software endstops to allow manual adjustment
// 5315             // If G29 is not completed, they will not be re-enabled
// 5316             soft_endstops_enabled = false;
// 5317           #endif
// 5318           return;
// 5319         }
// 5320         else {
// 5321           // Then leveling is done!
// 5322           // G29 finishing code goes here
// 5323 
// 5324           // After recording the last point, activate abl
// 5325           SERIAL_PROTOCOLLNPGM("Grid probing done.");
// 5326           g29_in_progress = false;
// 5327 
// 5328           // Re-enable software endstops, if needed
// 5329           #if HAS_SOFTWARE_ENDSTOPS
// 5330             soft_endstops_enabled = enable_soft_endstops;
// 5331           #endif
// 5332         }
// 5333 	  	}
// 5334       //#elif ENABLED(AUTO_BED_LEVELING_3POINT)
// 5335 	  else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_3POINT)	{
// 5336         // Probe at 3 arbitrary points
// 5337         if (abl_probe_index < 3) {
// 5338           xProbe = LOGICAL_X_POSITION(points[i].x);
// 5339           yProbe = LOGICAL_Y_POSITION(points[i].y);
// 5340           ++abl_probe_index;
// 5341           #if HAS_SOFTWARE_ENDSTOPS
// 5342             // Disable software endstops to allow manual adjustment
// 5343             // If G29 is not completed, they will not be re-enabled
// 5344             soft_endstops_enabled = false;
// 5345           #endif
// 5346           return;
// 5347         }
// 5348         else {
// 5349 
// 5350           SERIAL_PROTOCOLLNPGM("3-point probing done.");
// 5351           g29_in_progress = false;
// 5352 
// 5353           // Re-enable software endstops, if needed
// 5354           #if HAS_SOFTWARE_ENDSTOPS
// 5355             soft_endstops_enabled = enable_soft_endstops;
// 5356           #endif
// 5357 
// 5358           if (!dryrun) {
// 5359             vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
// 5360             if (planeNormal.z < 0) {
// 5361               planeNormal.x *= -1;
// 5362               planeNormal.y *= -1;
// 5363               planeNormal.z *= -1;
// 5364             }
// 5365             planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
// 5366             ABC
// 5367             // Can't re-enable (on error) until the new grid is written
// 5368             abl_should_enable = false;
// 5369           }
// 5370 
// 5371         }
// 5372 	  }
// 5373       //#endif // AUTO_BED_LEVELING_3POINT
// 5374 
// 5375     #else // !PROBE_MANUALLY
// 5376 
// 5377       bool stow_probe_after_each = code_seen('E');
// 5378 
// 5379       //#if ABL_GRID
// 5380 		if(BED_LEVELING_METHOD&ABL_GRID)  {
// 5381 
// 5382         bool zig = PR_OUTER_END & 1;  // Always end at RIGHT and BACK_PROBE_BED_POSITION
// 5383 
// 5384         // Outer loop is Y with PROBE_Y_FIRST disabled
// 5385         for (uint8_t PR_OUTER_VAR = 0; PR_OUTER_VAR < PR_OUTER_END; PR_OUTER_VAR++) {
// 5386 
// 5387           int8_t inStart, inStop, inInc;
// 5388 
// 5389           if (zig) { // away from origin
// 5390             inStart = 0;
// 5391             inStop = PR_INNER_END;
// 5392             inInc = 1;
// 5393           }
// 5394           else {     // towards origin
// 5395             inStart = PR_INNER_END - 1;
// 5396             inStop = -1;
// 5397             inInc = -1;
// 5398           }
// 5399 
// 5400           zig ^= true; // zag
// 5401 
// 5402           // Inner loop is Y with PROBE_Y_FIRST enabled
// 5403           for (int8_t PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; PR_INNER_VAR += inInc) {
// 5404 
// 5405             float xBase = left_probe_bed_position + xGridSpacing * xCount,
// 5406                   yBase = front_probe_bed_position + yGridSpacing * yCount;
// 5407 
// 5408             xProbe = floor(xBase + (xBase < 0 ? 0 : 0.5));
// 5409             yProbe = floor(yBase + (yBase < 0 ? 0 : 0.5));
// 5410 
// 5411             //#if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5412 			if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_LINEAR)
// 5413               indexIntoAB[xCount][yCount] = ++abl_probe_index;
// 5414             //#endif
// 5415 
// 5416 			//mks_delta    begin
// 5417 			/*
// 5418             #if IS_KINEMATIC
// 5419               // Avoid probing outside the round or hexagonal area
// 5420               const float pos[XYZ] = { xProbe, yProbe, 0 };
// 5421               if (!position_is_reachable(pos, true)) continue;
// 5422             #endif
// 5423 			*/
// 5424 			const float pos[XYZ] = { xProbe, yProbe, 0 };
// 5425 			if(MACHINETPYE & IS_KINEMATIC)
// 5426 				{
// 5427 				if (!position_is_reachable(pos, true)) continue;
// 5428 				}
// 5429 			
// 5430 			//mks_delta    end
// 5431           /*--mks cfg-- random*/
// 5432             //measured_z = faux ? 0.001 * random(-100, 101) : probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
// 5433 	int16_t randData = rand()%200;
// 5434 	if(randData > 100)	randData = 100 - randData;
// 5435         measured_z = faux ? 0.001 * randData : probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
// 5436             
// 5437             if (isnan(measured_z)) {
// 5438               planner.abl_enabled = abl_should_enable;
// 5439               return;
// 5440             }
// 5441 			/*--mks cfg--begin AUTO_BED_LEVELING_BILINEAR */
// 5442 /*
// 5443             #if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5444 
// 5445               mean += measured_z;
// 5446               eqnBVector[abl_probe_index] = measured_z;
// 5447               eqnAMatrix[abl_probe_index + 0 * abl2] = xProbe;
// 5448               eqnAMatrix[abl_probe_index + 1 * abl2] = yProbe;
// 5449               eqnAMatrix[abl_probe_index + 2 * abl2] = 1;
// 5450 
// 5451             #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5452 
// 5453               z_values[xCount][yCount] = measured_z + zoffset;
// 5454 
// 5455             #endif
// 5456 */
// 5457 			if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_LINEAR)
// 5458 				{
// 5459 				mean += measured_z;
// 5460 				/*
// 5461 				eqnBVector[abl_probe_index] = measured_z;
// 5462 				eqnAMatrix[abl_probe_index + 0 * abl2] = xProbe;
// 5463 				eqnAMatrix[abl_probe_index + 1 * abl2] = yProbe;
// 5464 				eqnAMatrix[abl_probe_index + 2 * abl2] = 1;
// 5465 				*/
// 5466 					*(eqnBVector+abl_probe_index) = measured_z;
// 5467 					*(eqnAMatrix+abl_probe_index + 0 * abl2) = xProbe;
// 5468 					*(eqnAMatrix+abl_probe_index + 1 * abl2) = yProbe;
// 5469 					*(eqnAMatrix+abl_probe_index + 2 * abl2) = 1;
// 5470 				
// 5471 				}
// 5472 			else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
// 5473 				{z_values[xCount][yCount] = measured_z + zoffset;}
// 5474 			/*--mks cfg--end AUTO_BED_LEVELING_BILINEAR */
// 5475 
// 5476             abl_should_enable = false;
// 5477             idle();
// 5478 
// 5479           } // inner
// 5480         } // outer
// 5481 			}
// 5482       //#elif ENABLED(AUTO_BED_LEVELING_3POINT)
// 5483 		else if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_3POINT)  {
// 5484         // Probe at 3 arbitrary points
// 5485 
// 5486         for (uint8_t i = 0; i < 3; ++i) {
// 5487           // Retain the last probe position
// 5488           xProbe = LOGICAL_X_POSITION(points[i].x);
// 5489           yProbe = LOGICAL_Y_POSITION(points[i].y);
// 5490           /*--mks cfg-- random*/
// 5491           //measured_z = points[i].z = faux ? 0.001 * random(-100, 101) : probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
// 5492 	int16_t randData = rand()%200;
// 5493 	if(randData > 100)	randData = 100 - randData;
// 5494 	measured_z = points[i].z = faux ? 0.001 * randData : probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
// 5495         }
// 5496 
// 5497         if (isnan(measured_z)) {
// 5498           planner.abl_enabled = abl_should_enable;
// 5499           return;
// 5500         }
// 5501 
// 5502         if (!dryrun) {
// 5503           vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
// 5504           if (planeNormal.z < 0) {
// 5505             planeNormal.x *= -1;
// 5506             planeNormal.y *= -1;
// 5507             planeNormal.z *= -1;
// 5508           }
// 5509           planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
// 5510 
// 5511           // Can't re-enable (on error) until the new grid is written
// 5512           abl_should_enable = false;
// 5513         }
// 5514 			}
// 5515       //#endif // AUTO_BED_LEVELING_3POINT
// 5516 
// 5517       // Raise to _Z_CLEARANCE_DEPLOY_PROBE. Stow the probe.
// 5518       if (STOW_PROBE()) {
// 5519         planner.abl_enabled = abl_should_enable;
// 5520         return;
// 5521       }
// 5522 
// 5523     #endif // !PROBE_MANUALLY
// 5524 
// 5525     //
// 5526     // G29 Finishing Code
// 5527     //
// 5528     // Unless this is a dry run, auto bed leveling will
// 5529     // definitely be enabled after this point
// 5530     //
// 5531 
// 5532     // Restore state after probing
// 5533     if (!faux) clean_up_after_endstop_or_probe_move();
// 5534 
// 5535     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5536       if (DEBUGGING(LEVELING)) DEBUG_POS("> probing complete", current_position);
// 5537     #endif
// 5538 
// 5539     // Calculate leveling, print reports, correct the position
// 5540 /*--mks cfg--begin AUTO_BED_LEVELING_BILINEAR */    
// 5541 /*    #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5542 
// 5543       if (!dryrun) extrapolate_unprobed_bed_level();
// 5544       print_bilinear_leveling_grid();
// 5545 
// 5546       refresh_bed_level();
// 5547 
// 5548       #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 5549         bed_level_virt_print();
// 5550       #endif
// 5551 
// 5552     #elif ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5553 
// 5554       // For LINEAR leveling calculate matrix, print reports, correct the position
// 5555 
// 5556       float plane_equation_coefficients[3];
// 5557       qr_solve(plane_equation_coefficients, abl2, 3, eqnAMatrix, eqnBVector);
// 5558 
// 5559       mean /= abl2;
// 5560 
// 5561       if (verbose_level) {
// 5562         SERIAL_PROTOCOLPGM("Eqn coefficients: a: ");
// 5563         SERIAL_PROTOCOL_F(plane_equation_coefficients[0], 8);
// 5564         SERIAL_PROTOCOLPGM(" b: ");
// 5565         SERIAL_PROTOCOL_F(plane_equation_coefficients[1], 8);
// 5566         SERIAL_PROTOCOLPGM(" d: ");
// 5567         SERIAL_PROTOCOL_F(plane_equation_coefficients[2], 8);
// 5568         SERIAL_EOL;
// 5569         if (verbose_level > 2) {
// 5570           SERIAL_PROTOCOLPGM("Mean of sampled points: ");
// 5571           SERIAL_PROTOCOL_F(mean, 8);
// 5572           SERIAL_EOL;
// 5573         }
// 5574       }
// 5575 
// 5576       // Create the matrix but don't correct the position yet
// 5577       if (!dryrun) {
// 5578         planner.bed_level_matrix = matrix_3x3::create_look_at(
// 5579           vector_3(-plane_equation_coefficients[0], -plane_equation_coefficients[1], 1)
// 5580         );
// 5581       }
// 5582 
// 5583       // Show the Topography map if enabled
// 5584       if (do_topography_map) {
// 5585 
// 5586         SERIAL_PROTOCOLLNPGM("\nBed Height Topography:\n"
// 5587                                "   +--- BACK --+\n"
// 5588                                "   |           |\n"
// 5589                                " L |    (+)    | R\n"
// 5590                                " E |           | I\n"
// 5591                                " F | (-) N (+) | G\n"
// 5592                                " T |           | H\n"
// 5593                                "   |    (-)    | T\n"
// 5594                                "   |           |\n"
// 5595                                "   O-- FRONT --+\n"
// 5596                                " (0,0)");
// 5597 
// 5598         float min_diff = 999;
// 5599 
// 5600         for (int8_t yy = abl_grid_points_y - 1; yy >= 0; yy--) {
// 5601           for (uint8_t xx = 0; xx < abl_grid_points_x; xx++) {
// 5602             int ind = indexIntoAB[xx][yy];
// 5603             float diff = eqnBVector[ind] - mean,
// 5604                   x_tmp = eqnAMatrix[ind + 0 * abl2],
// 5605                   y_tmp = eqnAMatrix[ind + 1 * abl2],
// 5606                   z_tmp = 0;
// 5607 
// 5608             apply_rotation_xyz(planner.bed_level_matrix, x_tmp, y_tmp, z_tmp);
// 5609 
// 5610             NOMORE(min_diff, eqnBVector[ind] - z_tmp);
// 5611 
// 5612             if (diff >= 0.0)
// 5613               SERIAL_PROTOCOLPGM(" +");   // Include + for column alignment
// 5614             else
// 5615               SERIAL_PROTOCOLCHAR(' ');
// 5616             SERIAL_PROTOCOL_F(diff, 5);
// 5617           } // xx
// 5618           SERIAL_EOL;
// 5619         } // yy
// 5620         SERIAL_EOL;
// 5621 
// 5622         if (verbose_level > 3) {
// 5623           SERIAL_PROTOCOLLNPGM("\nCorrected Bed Height vs. Bed Topology:");
// 5624 
// 5625           for (int8_t yy = abl_grid_points_y - 1; yy >= 0; yy--) {
// 5626             for (uint8_t xx = 0; xx < abl_grid_points_x; xx++) {
// 5627               int ind = indexIntoAB[xx][yy];
// 5628               float x_tmp = eqnAMatrix[ind + 0 * abl2],
// 5629                     y_tmp = eqnAMatrix[ind + 1 * abl2],
// 5630                     z_tmp = 0;
// 5631 
// 5632               apply_rotation_xyz(planner.bed_level_matrix, x_tmp, y_tmp, z_tmp);
// 5633 
// 5634               float diff = eqnBVector[ind] - z_tmp - min_diff;
// 5635               if (diff >= 0.0)
// 5636                 SERIAL_PROTOCOLPGM(" +");
// 5637               // Include + for column alignment
// 5638               else
// 5639                 SERIAL_PROTOCOLCHAR(' ');
// 5640               SERIAL_PROTOCOL_F(diff, 5);
// 5641             } // xx
// 5642             SERIAL_EOL;
// 5643           } // yy
// 5644           SERIAL_EOL;
// 5645         }
// 5646       } //do_topography_map
// 5647 
// 5648     #endif // AUTO_BED_LEVELING_LINEAR
// 5649 */
// 5650 
// 5651 		 // #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5652 	if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)  {
// 5653 		  if (!dryrun) extrapolate_unprobed_bed_level();
// 5654 		  print_bilinear_leveling_grid();
// 5655 	
// 5656 		  refresh_bed_level();
// 5657 	
// 5658       #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 5659 			bed_level_virt_print();
// 5660       #endif
// 5661 		}
// 5662     //#elif ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5663 		else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_LINEAR)  {
// 5664 		  // For LINEAR leveling calculate matrix, print reports, correct the position
// 5665 	
// 5666 		  float plane_equation_coefficients[3];
// 5667 
// 5668 		  qr_solve(plane_equation_coefficients, abl2, 3, eqnAMatrix, eqnBVector);
// 5669 	
// 5670 		  mean /= abl2;
// 5671 	
// 5672 		  if (verbose_level) {
// 5673 			SERIAL_PROTOCOLPGM("Eqn coefficients: a: ");
// 5674 			SERIAL_PROTOCOL_F(plane_equation_coefficients[0], 8);
// 5675 			SERIAL_PROTOCOLPGM(" b: ");
// 5676 			SERIAL_PROTOCOL_F(plane_equation_coefficients[1], 8);
// 5677 			SERIAL_PROTOCOLPGM(" d: ");
// 5678 			SERIAL_PROTOCOL_F(plane_equation_coefficients[2], 8);
// 5679 			SERIAL_EOL;
// 5680 			if (verbose_level > 2) {
// 5681 			  SERIAL_PROTOCOLPGM("Mean of sampled points: ");
// 5682 			  SERIAL_PROTOCOL_F(mean, 8);
// 5683 			  SERIAL_EOL;
// 5684 			}
// 5685 		  }
// 5686 	
// 5687 		  // Create the matrix but don't correct the position yet
// 5688 		  if (!dryrun) {
// 5689 			planner.bed_level_matrix = matrix_3x3::create_look_at(
// 5690 			  vector_3(-plane_equation_coefficients[0], -plane_equation_coefficients[1], 1)
// 5691 			);
// 5692 		  }
// 5693 	
// 5694 		  // Show the Topography map if enabled
// 5695 		  if (do_topography_map) {
// 5696 	
// 5697 			SERIAL_PROTOCOLLNPGM("\nBed Height Topography:\n"
// 5698 								   "   +--- BACK --+\n"
// 5699 								   "   |		   |\n"
// 5700 								   " L |	(+)    | R\n"
// 5701 								   " E |		   | I\n"
// 5702 								   " F | (-) N (+) | G\n"
// 5703 								   " T |		   | H\n"
// 5704 								   "   |	(-)    | T\n"
// 5705 								   "   |		   |\n"
// 5706 								   "   O-- FRONT --+\n"
// 5707 								   " (0,0)");
// 5708 	
// 5709 			float min_diff = 999;
// 5710 	
// 5711 			for (int8_t yy = abl_grid_points_y - 1; yy >= 0; yy--) {
// 5712 			  for (uint8_t xx = 0; xx < abl_grid_points_x; xx++) {
// 5713 				int ind = indexIntoAB[xx][yy];
// 5714 /*				
// 5715 				float diff = eqnBVector[ind] - mean,
// 5716 					  x_tmp = eqnAMatrix[ind + 0 * abl2],
// 5717 					  y_tmp = eqnAMatrix[ind + 1 * abl2],
// 5718 					  z_tmp = 0;
// 5719 */
// 5720 	float diff = *(eqnBVector+ind) - mean,
// 5721 		  x_tmp = *(eqnAMatrix+ind + 0 * abl2),
// 5722 		  y_tmp = *(eqnAMatrix+ind + 1 * abl2),
// 5723 		  z_tmp = 0;
// 5724 				
// 5725 				apply_rotation_xyz(planner.bed_level_matrix, x_tmp, y_tmp, z_tmp);
// 5726 	
// 5727 				//NOMORE(min_diff, eqnBVector[ind] - z_tmp);
// 5728 				NOMORE(min_diff, *(eqnBVector+ind) - z_tmp);
// 5729 				if (diff >= 0.0)
// 5730 				  {SERIAL_PROTOCOLPGM(" +");}   // Include + for column alignment
// 5731 				else
// 5732                 		{ SERIAL_PROTOCOLCHAR(' ');}
// 5733 				SERIAL_PROTOCOL_F(diff, 5);
// 5734 			  } // xx
// 5735 			  SERIAL_EOL;
// 5736 			} // yy
// 5737 			SERIAL_EOL;
// 5738 	
// 5739 			if (verbose_level > 3) {
// 5740 			  SERIAL_PROTOCOLLNPGM("\nCorrected Bed Height vs. Bed Topology:");
// 5741 	
// 5742 			  for (int8_t yy = abl_grid_points_y - 1; yy >= 0; yy--) {
// 5743 				for (uint8_t xx = 0; xx < abl_grid_points_x; xx++) {
// 5744 				  int ind = indexIntoAB[xx][yy];
// 5745 /*				  
// 5746 				  float x_tmp = eqnAMatrix[ind + 0 * abl2],
// 5747 						y_tmp = eqnAMatrix[ind + 1 * abl2],
// 5748 						z_tmp = 0;
// 5749 */
// 5750 	float x_tmp = *(eqnAMatrix+ind + 0 * abl2),
// 5751 		  y_tmp = *(eqnAMatrix+ind + 1 * abl2),
// 5752 		  z_tmp = 0;
// 5753 
// 5754 
// 5755 				  apply_rotation_xyz(planner.bed_level_matrix, x_tmp, y_tmp, z_tmp);
// 5756 	
// 5757 				  //float diff = eqnBVector[ind] - z_tmp - min_diff;
// 5758 				  float diff = *(eqnBVector+ind) - z_tmp - min_diff;
// 5759 				  if (diff >= 0.0)
// 5760 				 {SERIAL_PROTOCOLPGM(" +");}
// 5761 				  // Include + for column alignment
// 5762 				  else
// 5763                  		 {SERIAL_PROTOCOLCHAR(' ');}
// 5764 				  SERIAL_PROTOCOL_F(diff, 5);
// 5765 				} // xx
// 5766 				SERIAL_EOL;
// 5767 			  } // yy
// 5768 			  SERIAL_EOL;
// 5769 			}
// 5770 		  } //do_topography_map
// 5771 			}
// 5772    // #endif // AUTO_BED_LEVELING_LINEAR
// 5773 
// 5774 
// 5775 	/*--mks cfg--end AUTO_BED_LEVELING_BILINEAR */
// 5776 
// 5777 
// 5778 	/*--mks cfg--begin AUTO_BED_LEVELING_BILINEAR */
// 5779 /*
// 5780     #if ABL_PLANAR
// 5781 
// 5782       // For LINEAR and 3POINT leveling correct the current position
// 5783 
// 5784       if (verbose_level > 0)
// 5785         planner.bed_level_matrix.debug(PSTR("\n\nBed Level Correction Matrix:"));
// 5786 
// 5787       if (!dryrun) {
// 5788         //
// 5789         // Correct the current XYZ position based on the tilted plane.
// 5790         //
// 5791 
// 5792         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5793           if (DEBUGGING(LEVELING)) DEBUG_POS("G29 uncorrected XYZ", current_position);
// 5794         #endif
// 5795 
// 5796         float converted[XYZ];
// 5797         COPY(converted, current_position);
// 5798 
// 5799         planner.abl_enabled = true;
// 5800         planner.unapply_leveling(converted); // use conversion machinery
// 5801         planner.abl_enabled = false;
// 5802 
// 5803         // Use the last measured distance to the bed, if possible
// 5804         if ( NEAR(current_position[X_AXIS], xProbe - (X_PROBE_OFFSET_FROM_EXTRUDER))
// 5805           && NEAR(current_position[Y_AXIS], yProbe - (Y_PROBE_OFFSET_FROM_EXTRUDER))
// 5806         ) {
// 5807           float simple_z = current_position[Z_AXIS] - measured_z;
// 5808           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5809             if (DEBUGGING(LEVELING)) {
// 5810               SERIAL_ECHOPAIR("Z from Probe:", simple_z);
// 5811               SERIAL_ECHOPAIR("  Matrix:", converted[Z_AXIS]);
// 5812               SERIAL_ECHOLNPAIR("  Discrepancy:", simple_z - converted[Z_AXIS]);
// 5813             }
// 5814           #endif
// 5815           converted[Z_AXIS] = simple_z;
// 5816         }
// 5817 
// 5818         // The rotated XY and corrected Z are now current_position
// 5819         COPY(current_position, converted);
// 5820 
// 5821         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5822           if (DEBUGGING(LEVELING)) DEBUG_POS("G29 corrected XYZ", current_position);
// 5823         #endif
// 5824       }
// 5825 
// 5826     #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5827 
// 5828       if (!dryrun) {
// 5829         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5830           if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("G29 uncorrected Z:", current_position[Z_AXIS]);
// 5831         #endif
// 5832 
// 5833         // Unapply the offset because it is going to be immediately applied
// 5834         // and cause compensation movement in Z
// 5835         current_position[Z_AXIS] -= bilinear_z_offset(current_position);
// 5836 
// 5837         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5838           if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR(" corrected Z:", current_position[Z_AXIS]);
// 5839         #endif
// 5840       }
// 5841 
// 5842     #endif // ABL_PLANAR
// 5843 */
// 5844 
// 5845 //#if ABL_PLANAR
// 5846    if(BED_LEVELING_METHOD&ABL_PLANAR)	{
// 5847 	 // For LINEAR and 3POINT leveling correct the current position
// 5848    
// 5849 	 if (verbose_level > 0)
// 5850 	   planner.bed_level_matrix.debug(PSTR("\n\nBed Level Correction Matrix:"));
// 5851    
// 5852 	 if (!dryrun) {
// 5853 	   //
// 5854 	   // Correct the current XYZ position based on the tilted plane.
// 5855 	   //
// 5856    
// 5857 	#if ENABLED(DEBUG_LEVELING_FEATURE)
// 5858 		 if (DEBUGGING(LEVELING)) DEBUG_POS("G29 uncorrected XYZ", current_position);
// 5859 	#endif
// 5860    
// 5861 	   float converted[XYZ];
// 5862 	   COPY(converted, current_position);
// 5863    
// 5864 	   planner.abl_enabled = true;
// 5865 	   planner.unapply_leveling(converted); // use conversion machinery
// 5866 	   planner.abl_enabled = false;
// 5867    
// 5868 	   // Use the last measured distance to the bed, if possible
// 5869 	   if ( NEAR(current_position[X_AXIS], xProbe - (X_PROBE_OFFSET_FROM_EXTRUDER))
// 5870 		 && NEAR(current_position[Y_AXIS], yProbe - (Y_PROBE_OFFSET_FROM_EXTRUDER))
// 5871 	   ) {
// 5872 		 float simple_z = current_position[Z_AXIS] - measured_z;
// 5873 	  #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5874 		   if (DEBUGGING(LEVELING)) {
// 5875 			 SERIAL_ECHOPAIR("Z from Probe:", simple_z);
// 5876 			 SERIAL_ECHOPAIR("	Matrix:", converted[Z_AXIS]);
// 5877 			 SERIAL_ECHOLNPAIR("  Discrepancy:", simple_z - converted[Z_AXIS]);
// 5878 		   }
// 5879 	  #endif
// 5880 		 converted[Z_AXIS] = simple_z;
// 5881 	   }
// 5882    
// 5883 	   // The rotated XY and corrected Z are now current_position
// 5884 	   COPY(current_position, converted);
// 5885    
// 5886 	#if ENABLED(DEBUG_LEVELING_FEATURE)
// 5887 		 if (DEBUGGING(LEVELING)) DEBUG_POS("G29 corrected XYZ", current_position);
// 5888 	#endif
// 5889 	 }
// 5890   	}
// 5891 //#elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5892    else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR) {
// 5893 	 if (!dryrun) {
// 5894 	#if ENABLED(DEBUG_LEVELING_FEATURE)
// 5895 		 if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("G29 uncorrected Z:", current_position[Z_AXIS]);
// 5896 	#endif
// 5897    
// 5898 	   // Unapply the offset because it is going to be immediately applied
// 5899 	   // and cause compensation movement in Z
// 5900 	   current_position[Z_AXIS] -= bilinear_z_offset(current_position);
// 5901    
// 5902 	#if ENABLED(DEBUG_LEVELING_FEATURE)
// 5903 		 if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR(" corrected Z:", current_position[Z_AXIS]);
// 5904 	#endif
// 5905 	 }
// 5906    	}
// 5907 //#endif // ABL_PLANAR
// 5908 	
// 5909 	/*--mks cfg--end AUTO_BED_LEVELING_BILINEAR */
// 5910 
// 5911 
// 5912     #ifdef Z_PROBE_END_SCRIPT
// 5913       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5914         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
// 5915       #endif
// 5916       enqueue_and_echo_commands_P(PSTR(Z_PROBE_END_SCRIPT));
// 5917       stepper.synchronize();
// 5918     #endif
// 5919 
// 5920     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5921       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< gcode_G29");
// 5922     #endif
// 5923 
// 5924     report_current_position();
// 5925 
// 5926     KEEPALIVE_STATE(IN_HANDLER);
// 5927 
// 5928     // Auto Bed Leveling is complete! Enable if possible.
// 5929     planner.abl_enabled = dryrun ? abl_should_enable : true;
// 5930 
// 5931     if (planner.abl_enabled)
// 5932       SYNC_PLAN_POSITION_KINEMATIC();
// 5933 
// 5934 	//if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_LINEAR)
// 5935 	
// 5936 	free(eqnBVector);
// 5937 	free(eqnAMatrix);
// 5938      
// 5939   }
// 5940 
// 5941 #endif // HAS_ABL && !AUTO_BED_LEVELING_UBL
// 5942 
// 5943 #if HAS_BED_PROBE
// 5944 
// 5945   /**
// 5946    * G30: Do a single Z probe at the current XY
// 5947    *
// 5948    * Parameters:
// 5949    *
// 5950    *   X   Probe X position (default current X)
// 5951    *   Y   Probe Y position (default current Y)
// 5952    *   S0  Leave the probe deployed
// 5953    */
// 5954   inline void gcode_G30() {
// 5955     const float xpos = code_seen('X') ? code_value_linear_units() : current_position[X_AXIS] + X_PROBE_OFFSET_FROM_EXTRUDER,
// 5956                 ypos = code_seen('Y') ? code_value_linear_units() : current_position[Y_AXIS] + Y_PROBE_OFFSET_FROM_EXTRUDER,
// 5957                 pos[XYZ] = { xpos, ypos, LOGICAL_Z_POSITION(0) };
// 5958 
// 5959     if (!position_is_reachable(pos, true)) return;
// 5960 
// 5961     // Disable leveling so the planner won't mess with us
// 5962     //#if HAS_LEVELING
// 5963 	if(BED_LEVELING_METHOD&HAS_LEVELING)
// 5964       set_bed_leveling_enabled(false);
// 5965     //#endif
// 5966 
// 5967     setup_for_endstop_or_probe_move();
// 5968 
// 5969     const float measured_z = probe_pt(xpos, ypos, !code_seen('S') || code_value_bool(), 1);
// 5970 
// 5971     SERIAL_PROTOCOLPAIR("Bed X: ", FIXFLOAT(xpos));
// 5972     SERIAL_PROTOCOLPAIR(" Y: ", FIXFLOAT(ypos));
// 5973     SERIAL_PROTOCOLLNPAIR(" Z: ", FIXFLOAT(measured_z));
// 5974 
// 5975     clean_up_after_endstop_or_probe_move();
// 5976 
// 5977     report_current_position();
// 5978   }
// 5979 
// 5980   #if ENABLED(Z_PROBE_SLED)
// 5981 
// 5982     /**
// 5983      * G31: Deploy the Z probe
// 5984      */
// 5985     inline void gcode_G31() { DEPLOY_PROBE(); }
// 5986 
// 5987     /**
// 5988      * G32: Stow the Z probe
// 5989      */
// 5990     inline void gcode_G32() { STOW_PROBE(); }
// 5991 
// 5992   #endif // Z_PROBE_SLED
// 5993 
// 5994   #if ENABLED(DELTA_AUTO_CALIBRATION)
// 5995     /**
// 5996      * G33 - Delta '1-4-7-point' Auto-Calibration
// 5997      *       Calibrate height, endstops, delta radius, and tower angles.
// 5998      *
// 5999      * Parameters:
// 6000      *
// 6001      *   P  Number of probe points:
// 6002      *
// 6003      *      P1     Probe center and set height only.
// 6004      *      P2     Probe center and towers. Set height, endstops, and delta radius.
// 6005      *      P3     Probe all positions: center, towers and opposite towers. Set all.
// 6006      *      P4-P7  Probe all positions at different locations and average them.
// 6007      *
// 6008      *   A  Abort delta height calibration after 1 probe (only P1)
// 6009      *
// 6010      *   O  Use opposite tower points instead of tower points (only P2)
// 6011      *
// 6012      *   T  Don't calibrate tower angle corrections (P3-P7)
// 6013      *
// 6014      *   V  Verbose level:
// 6015      *
// 6016      *      V0  Dry-run mode. Report settings and probe results. No calibration.
// 6017      *      V1  Report settings
// 6018      *      V2  Report settings and probe results
// 6019      */
// 6020     inline void gcode_G33() {
// 6021 
// 6022       const int8_t probe_points = code_seen('P') ? code_value_int() : DELTA_CALIBRATION_DEFAULT_POINTS;
// 6023       if (!WITHIN(probe_points, 1, 7)) {
// 6024         SERIAL_PROTOCOLLNPGM("?(P)oints is implausible (1 to 7).");
// 6025         return;
// 6026       }
// 6027 
// 6028       const int8_t verbose_level = code_seen('V') ? code_value_byte() : 1;
// 6029       if (!WITHIN(verbose_level, 0, 2)) {
// 6030         SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-2).");
// 6031         return;
// 6032       }
// 6033 
// 6034       const bool do_height_only       = probe_points == 1,
// 6035                  do_center_and_towers = probe_points == 2,
// 6036                  do_all_positions     = probe_points == 3,
// 6037                  do_circle_x2         = probe_points == 5,
// 6038                  do_circle_x3         = probe_points == 6,
// 6039                  do_circle_x4         = probe_points == 7,
// 6040                  probe_center_plus_3  = probe_points >= 3,
// 6041                  point_averaging      = probe_points >= 4,
// 6042                  probe_center_plus_6  = probe_points >= 5;
// 6043 
// 6044       const char negating_parameter = do_height_only ? 'A' : do_center_and_towers ? 'O' : 'T';
// 6045       int8_t probe_mode = code_seen(negating_parameter) && code_value_bool() ? -probe_points : probe_points;
// 6046 
// 6047       SERIAL_PROTOCOLLNPGM("G33 Auto Calibrate");
// 6048 
// 6049       //#if HAS_LEVELING
// 6050 	  if(BED_LEVELING_METHOD&HAS_LEVELING)
// 6051         set_bed_leveling_enabled(false);
// 6052       //#endif
// 6053 
// 6054       home_all_axes();
// 6055 
// 6056       const static char save_message[] PROGMEM = "Save with M500 and/or copy to Configuration.h";
// 6057       float test_precision,
// 6058             zero_std_dev = (verbose_level ? 999.0 : 0.0), // 0.0 in dry-run mode : forced end
// 6059             e_old[XYZ] = {
// 6060               endstop_adj[A_AXIS],
// 6061               endstop_adj[B_AXIS],
// 6062               endstop_adj[C_AXIS]
// 6063             },
// 6064             dr_old = delta_radius,
// 6065             zh_old = home_offset[Z_AXIS],
// 6066             alpha_old = delta_tower_angle_trim[A_AXIS],
// 6067             beta_old = delta_tower_angle_trim[B_AXIS];
// 6068 
// 6069       // print settings
// 6070 
// 6071       SERIAL_PROTOCOLPGM("Checking... AC");
// 6072       if (verbose_level == 0) SERIAL_PROTOCOLPGM(" (DRY-RUN)");
// 6073       SERIAL_EOL;
// 6074       LCD_MESSAGEPGM("Checking... AC");
// 6075 
// 6076       SERIAL_PROTOCOLPAIR(".Height:", DELTA_HEIGHT + home_offset[Z_AXIS]);
// 6077       if (!do_height_only) {
// 6078         SERIAL_PROTOCOLPGM("    Ex:");
// 6079         if (endstop_adj[A_AXIS] >= 0) SERIAL_CHAR('+');
// 6080         SERIAL_PROTOCOL_F(endstop_adj[A_AXIS], 2);
// 6081         SERIAL_PROTOCOLPGM("  Ey:");
// 6082         if (endstop_adj[B_AXIS] >= 0) SERIAL_CHAR('+');
// 6083         SERIAL_PROTOCOL_F(endstop_adj[B_AXIS], 2);
// 6084         SERIAL_PROTOCOLPGM("  Ez:");
// 6085         if (endstop_adj[C_AXIS] >= 0) SERIAL_CHAR('+');
// 6086         SERIAL_PROTOCOL_F(endstop_adj[C_AXIS], 2);
// 6087         SERIAL_PROTOCOLPAIR("    Radius:", delta_radius);
// 6088       }
// 6089       SERIAL_EOL;
// 6090       if (probe_mode > 2) { // negative disables tower angles
// 6091         SERIAL_PROTOCOLPGM(".Tower angle :    Tx:");
// 6092         if (delta_tower_angle_trim[A_AXIS] >= 0) SERIAL_CHAR('+');
// 6093         SERIAL_PROTOCOL_F(delta_tower_angle_trim[A_AXIS], 2);
// 6094         SERIAL_PROTOCOLPGM("  Ty:");
// 6095         if (delta_tower_angle_trim[B_AXIS] >= 0) SERIAL_CHAR('+');
// 6096         SERIAL_PROTOCOL_F(delta_tower_angle_trim[B_AXIS], 2);
// 6097         SERIAL_PROTOCOLPGM("  Tz:+0.00");
// 6098         SERIAL_EOL;
// 6099       }
// 6100 
// 6101       #if ENABLED(Z_PROBE_SLED)
// 6102         DEPLOY_PROBE();
// 6103       #endif
// 6104 
// 6105       int8_t iterations = 0;
// 6106 
// 6107       do {
// 6108 
// 6109         float z_at_pt[13] = { 0 },
// 6110               S1 = 0.0,
// 6111               S2 = 0.0;
// 6112         int16_t N = 0;
// 6113 
// 6114         test_precision = zero_std_dev;
// 6115         iterations++;
// 6116 
// 6117         // Probe the points
// 6118 
// 6119         if (!do_all_positions && !do_circle_x3) { // probe the center
// 6120           setup_for_endstop_or_probe_move();
// 6121           z_at_pt[0] += probe_pt(0.0, 0.0 , true, 1);
// 6122           clean_up_after_endstop_or_probe_move();
// 6123         }
// 6124         if (probe_center_plus_3) { // probe extra center points
// 6125           for (int8_t axis = probe_center_plus_6 ? 11 : 9; axis > 0; axis -= probe_center_plus_6 ? 2 : 4) {
// 6126             setup_for_endstop_or_probe_move();
// 6127             z_at_pt[0] += probe_pt(
// 6128               cos(RADIANS(180 + 30 * axis)) * (0.1 * delta_calibration_radius),
// 6129               sin(RADIANS(180 + 30 * axis)) * (0.1 * delta_calibration_radius), true, 1);
// 6130             clean_up_after_endstop_or_probe_move();
// 6131           }
// 6132           z_at_pt[0] /= float(do_circle_x2 ? 7 : probe_points);
// 6133         }
// 6134         if (!do_height_only) {  // probe the radius
// 6135           bool zig_zag = true;
// 6136           for (uint8_t axis = (probe_mode == -2 ? 3 : 1); axis < 13;
// 6137                        axis += (do_center_and_towers ? 4 : do_all_positions ? 2 : 1)) {
// 6138             float offset_circles = (do_circle_x4 ? (zig_zag ? 1.5 : 1.0) :
// 6139                                     do_circle_x3 ? (zig_zag ? 1.0 : 0.5) :
// 6140                                     do_circle_x2 ? (zig_zag ? 0.5 : 0.0) : 0);
// 6141             for (float circles = -offset_circles ; circles <= offset_circles; circles++) {
// 6142               setup_for_endstop_or_probe_move();
// 6143               z_at_pt[axis] += probe_pt(
// 6144                 cos(RADIANS(180 + 30 * axis)) * delta_calibration_radius *
// 6145                 (1 + circles * 0.1 * (zig_zag ? 1 : -1)),
// 6146                 sin(RADIANS(180 + 30 * axis)) * delta_calibration_radius *
// 6147                 (1 + circles * 0.1 * (zig_zag ? 1 : -1)), true, 1);
// 6148               clean_up_after_endstop_or_probe_move();
// 6149             }
// 6150             zig_zag = !zig_zag;
// 6151             z_at_pt[axis] /= (2 * offset_circles + 1);
// 6152           }
// 6153         }
// 6154         if (point_averaging) // average intermediates to tower and opposites
// 6155           for (uint8_t axis = 1; axis <= 11; axis += 2)
// 6156             z_at_pt[axis] = (z_at_pt[axis] + (z_at_pt[axis + 1] + z_at_pt[(axis + 10) % 12 + 1]) / 2.0) / 2.0;
// 6157 
// 6158         S1 += z_at_pt[0];
// 6159         S2 += sq(z_at_pt[0]);
// 6160         N++;
// 6161         if (!do_height_only) // std dev from zero plane
// 6162           for (uint8_t axis = (probe_mode == -2 ? 3 : 1); axis < 13; axis += (do_center_and_towers ? 4 : 2)) {
// 6163             S1 += z_at_pt[axis];
// 6164             S2 += sq(z_at_pt[axis]);
// 6165             N++;
// 6166           }
// 6167         zero_std_dev = round(sqrt(S2 / N) * 1000.0) / 1000.0 + 0.00001;
// 6168 
// 6169         // Solve matrices
// 6170 
// 6171         if (zero_std_dev < test_precision) {
// 6172           COPY(e_old, endstop_adj);
// 6173           dr_old = delta_radius;
// 6174           zh_old = home_offset[Z_AXIS];
// 6175           alpha_old = delta_tower_angle_trim[A_AXIS];
// 6176           beta_old = delta_tower_angle_trim[B_AXIS];
// 6177 
// 6178           float e_delta[XYZ] = { 0.0 }, r_delta = 0.0,
// 6179                 t_alpha = 0.0, t_beta = 0.0;
// 6180           const float r_diff = delta_radius - delta_calibration_radius,
// 6181                       h_factor = 1.00 + r_diff * 0.001,                          //1.02 for r_diff = 20mm
// 6182                       r_factor = -(1.75 + 0.005 * r_diff + 0.001 * sq(r_diff)),  //2.25 for r_diff = 20mm
// 6183                       a_factor = 100.0 / delta_calibration_radius;               //1.25 for cal_rd = 80mm
// 6184 
// 6185           #define ZP(N,I) ((N) * z_at_pt[I])
// 6186           #define Z1000(I) ZP(1.00, I)
// 6187           #define Z1050(I) ZP(h_factor, I)
// 6188           #define Z0700(I) ZP(h_factor * 2.0 / 3.00, I)
// 6189           #define Z0350(I) ZP(h_factor / 3.00, I)
// 6190           #define Z0175(I) ZP(h_factor / 6.00, I)
// 6191           #define Z2250(I) ZP(r_factor, I)
// 6192           #define Z0750(I) ZP(r_factor / 3.00, I)
// 6193           #define Z0375(I) ZP(r_factor / 6.00, I)
// 6194           #define Z0444(I) ZP(a_factor * 4.0 / 9.0, I)
// 6195           #define Z0888(I) ZP(a_factor * 8.0 / 9.0, I)
// 6196 
// 6197           switch (probe_mode) {
// 6198             case -1:
// 6199               test_precision = 0.00;
// 6200             case 1:
// 6201               LOOP_XYZ(i) e_delta[i] = Z1000(0);
// 6202               break;
// 6203 
// 6204             case 2:
// 6205               e_delta[X_AXIS] = Z1050(0) + Z0700(1) - Z0350(5) - Z0350(9);
// 6206               e_delta[Y_AXIS] = Z1050(0) - Z0350(1) + Z0700(5) - Z0350(9);
// 6207               e_delta[Z_AXIS] = Z1050(0) - Z0350(1) - Z0350(5) + Z0700(9);
// 6208               r_delta         = Z2250(0) - Z0750(1) - Z0750(5) - Z0750(9);
// 6209               break;
// 6210 
// 6211             case -2:
// 6212               e_delta[X_AXIS] = Z1050(0) - Z0700(7) + Z0350(11) + Z0350(3);
// 6213               e_delta[Y_AXIS] = Z1050(0) + Z0350(7) - Z0700(11) + Z0350(3);
// 6214               e_delta[Z_AXIS] = Z1050(0) + Z0350(7) + Z0350(11) - Z0700(3);
// 6215               r_delta         = Z2250(0) - Z0750(7) - Z0750(11) - Z0750(3);
// 6216               break;
// 6217 
// 6218             default:
// 6219               e_delta[X_AXIS] = Z1050(0) + Z0350(1) - Z0175(5) - Z0175(9) - Z0350(7) + Z0175(11) + Z0175(3);
// 6220               e_delta[Y_AXIS] = Z1050(0) - Z0175(1) + Z0350(5) - Z0175(9) + Z0175(7) - Z0350(11) + Z0175(3);
// 6221               e_delta[Z_AXIS] = Z1050(0) - Z0175(1) - Z0175(5) + Z0350(9) + Z0175(7) + Z0175(11) - Z0350(3);
// 6222               r_delta         = Z2250(0) - Z0375(1) - Z0375(5) - Z0375(9) - Z0375(7) - Z0375(11) - Z0375(3);
// 6223 
// 6224               if (probe_mode > 0) {  // negative disables tower angles
// 6225                 t_alpha = + Z0444(1) - Z0888(5) + Z0444(9) + Z0444(7) - Z0888(11) + Z0444(3);
// 6226                 t_beta  = - Z0888(1) + Z0444(5) + Z0444(9) - Z0888(7) + Z0444(11) + Z0444(3);
// 6227               }
// 6228               break;
// 6229           }
// 6230 
// 6231           LOOP_XYZ(axis) endstop_adj[axis] += e_delta[axis];
// 6232           delta_radius += r_delta;
// 6233           delta_tower_angle_trim[A_AXIS] += t_alpha;
// 6234           delta_tower_angle_trim[B_AXIS] -= t_beta;
// 6235 
// 6236           // adjust delta_height and endstops by the max amount
// 6237           const float z_temp = MAX3(endstop_adj[A_AXIS], endstop_adj[B_AXIS], endstop_adj[C_AXIS]);
// 6238           home_offset[Z_AXIS] -= z_temp;
// 6239           LOOP_XYZ(i) endstop_adj[i] -= z_temp;
// 6240 
// 6241           recalc_delta_settings(delta_radius, delta_diagonal_rod);
// 6242         }
// 6243         else {   // step one back
// 6244           COPY(endstop_adj, e_old);
// 6245           delta_radius = dr_old;
// 6246           home_offset[Z_AXIS] = zh_old;
// 6247           delta_tower_angle_trim[A_AXIS] = alpha_old;
// 6248           delta_tower_angle_trim[B_AXIS] = beta_old;
// 6249 
// 6250           recalc_delta_settings(delta_radius, delta_diagonal_rod);
// 6251         }
// 6252 
// 6253          // print report
// 6254 
// 6255         if (verbose_level != 1) {
// 6256           SERIAL_PROTOCOLPGM(".      c:");
// 6257           if (z_at_pt[0] > 0) SERIAL_CHAR('+');
// 6258           SERIAL_PROTOCOL_F(z_at_pt[0], 2);
// 6259           if (probe_mode == 2 || probe_center_plus_3) {
// 6260             SERIAL_PROTOCOLPGM("     x:");
// 6261             if (z_at_pt[1] >= 0) SERIAL_CHAR('+');
// 6262             SERIAL_PROTOCOL_F(z_at_pt[1], 2);
// 6263             SERIAL_PROTOCOLPGM("   y:");
// 6264             if (z_at_pt[5] >= 0) SERIAL_CHAR('+');
// 6265             SERIAL_PROTOCOL_F(z_at_pt[5], 2);
// 6266             SERIAL_PROTOCOLPGM("   z:");
// 6267             if (z_at_pt[9] >= 0) SERIAL_CHAR('+');
// 6268             SERIAL_PROTOCOL_F(z_at_pt[9], 2);
// 6269           }
// 6270           if (probe_mode != -2) SERIAL_EOL;
// 6271           if (probe_mode == -2 || probe_center_plus_3) {
// 6272             if (probe_center_plus_3) {
// 6273               SERIAL_CHAR('.');
// 6274               SERIAL_PROTOCOL_SP(13);
// 6275             }
// 6276             SERIAL_PROTOCOLPGM("    yz:");
// 6277             if (z_at_pt[7] >= 0) SERIAL_CHAR('+');
// 6278             SERIAL_PROTOCOL_F(z_at_pt[7], 2);
// 6279             SERIAL_PROTOCOLPGM("  zx:");
// 6280             if (z_at_pt[11] >= 0) SERIAL_CHAR('+');
// 6281             SERIAL_PROTOCOL_F(z_at_pt[11], 2);
// 6282             SERIAL_PROTOCOLPGM("  xy:");
// 6283             if (z_at_pt[3] >= 0) SERIAL_CHAR('+');
// 6284             SERIAL_PROTOCOL_F(z_at_pt[3], 2);
// 6285             SERIAL_EOL;
// 6286           }
// 6287         }
// 6288         if (test_precision != 0.0) {                                 // !forced end
// 6289           if (zero_std_dev >= test_precision) {                      // end iterations
// 6290             SERIAL_PROTOCOLPGM("Calibration OK");
// 6291             SERIAL_PROTOCOL_SP(36);
// 6292             SERIAL_PROTOCOLPGM("rolling back.");
// 6293             SERIAL_EOL;
// 6294             LCD_MESSAGEPGM("Calibration OK");
// 6295           }
// 6296           else {                                                     // !end iterations
// 6297             char mess[15] = "No convergence";
// 6298             if (iterations < 31)
// 6299               sprintf_P(mess, PSTR("Iteration : %02i"), (int)iterations);
// 6300             SERIAL_PROTOCOL(mess);
// 6301             SERIAL_PROTOCOL_SP(36);
// 6302             SERIAL_PROTOCOLPGM("std dev:");
// 6303             SERIAL_PROTOCOL_F(zero_std_dev, 3);
// 6304             SERIAL_EOL;
// 6305             lcd_setstatus(mess);
// 6306           }
// 6307           SERIAL_PROTOCOLPAIR(".Height:", DELTA_HEIGHT + home_offset[Z_AXIS]);
// 6308           if (!do_height_only) {
// 6309             SERIAL_PROTOCOLPGM("    Ex:");
// 6310             if (endstop_adj[A_AXIS] >= 0) SERIAL_CHAR('+');
// 6311             SERIAL_PROTOCOL_F(endstop_adj[A_AXIS], 2);
// 6312             SERIAL_PROTOCOLPGM("  Ey:");
// 6313             if (endstop_adj[B_AXIS] >= 0) SERIAL_CHAR('+');
// 6314             SERIAL_PROTOCOL_F(endstop_adj[B_AXIS], 2);
// 6315             SERIAL_PROTOCOLPGM("  Ez:");
// 6316             if (endstop_adj[C_AXIS] >= 0) SERIAL_CHAR('+');
// 6317             SERIAL_PROTOCOL_F(endstop_adj[C_AXIS], 2);
// 6318             SERIAL_PROTOCOLPAIR("    Radius:", delta_radius);
// 6319           }
// 6320           SERIAL_EOL;
// 6321           if (probe_mode > 2) { // negative disables tower angles
// 6322             SERIAL_PROTOCOLPGM(".Tower angle :    Tx:");
// 6323             if (delta_tower_angle_trim[A_AXIS] >= 0) SERIAL_CHAR('+');
// 6324             SERIAL_PROTOCOL_F(delta_tower_angle_trim[A_AXIS], 2);
// 6325             SERIAL_PROTOCOLPGM("  Ty:");
// 6326             if (delta_tower_angle_trim[B_AXIS] >= 0) SERIAL_CHAR('+');
// 6327             SERIAL_PROTOCOL_F(delta_tower_angle_trim[B_AXIS], 2);
// 6328             SERIAL_PROTOCOLPGM("  Tz:+0.00");
// 6329             SERIAL_EOL;
// 6330           }
// 6331           if (zero_std_dev >= test_precision)
// 6332             serialprintPGM(save_message);
// 6333             SERIAL_EOL;
// 6334         }
// 6335         else {                                                       // forced end
// 6336           if (verbose_level == 0) {
// 6337             SERIAL_PROTOCOLPGM("End DRY-RUN");
// 6338             SERIAL_PROTOCOL_SP(39);
// 6339             SERIAL_PROTOCOLPGM("std dev:");
// 6340             SERIAL_PROTOCOL_F(zero_std_dev, 3);
// 6341             SERIAL_EOL;
// 6342           }
// 6343           else {
// 6344             SERIAL_PROTOCOLLNPGM("Calibration OK");
// 6345             LCD_MESSAGEPGM("Calibration OK");
// 6346             SERIAL_PROTOCOLPAIR(".Height:", DELTA_HEIGHT + home_offset[Z_AXIS]);
// 6347             SERIAL_EOL;
// 6348             serialprintPGM(save_message);
// 6349             SERIAL_EOL;
// 6350           }
// 6351         }
// 6352 
// 6353         stepper.synchronize();
// 6354 
// 6355         home_all_axes();
// 6356 
// 6357       } while (zero_std_dev < test_precision && iterations < 31);
// 6358 
// 6359       #if ENABLED(Z_PROBE_SLED)
// 6360         RETRACT_PROBE();
// 6361       #endif
// 6362     }
// 6363 
// 6364   #endif // DELTA_AUTO_CALIBRATION
// 6365 
// 6366 #endif // HAS_BED_PROBE
// 6367 
// 6368 
// 6369 #if ENABLED(G38_PROBE_TARGET)
// 6370 
// 6371   static bool G38_run_probe() {
// 6372 
// 6373     bool G38_pass_fail = false;
// 6374 
// 6375     // Get direction of move and retract
// 6376     float retract_mm[XYZ];
// 6377     LOOP_XYZ(i) {
// 6378       float dist = destination[i] - current_position[i];
// 6379       retract_mm[i] = fabs(dist) < G38_MINIMUM_MOVE ? 0 : home_bump_mm((AxisEnum)i) * (dist > 0 ? -1 : 1);
// 6380     }
// 6381 
// 6382     stepper.synchronize();  // wait until the machine is idle
// 6383 
// 6384     // Move until destination reached or target hit
// 6385     endstops.enable(true);
// 6386     G38_move = true;
// 6387     G38_endstop_hit = false;
// 6388     prepare_move_to_destination();
// 6389     stepper.synchronize();
// 6390     G38_move = false;
// 6391 
// 6392     endstops.hit_on_purpose();
// 6393     set_current_from_steppers_for_axis(ALL_AXES);
// 6394     SYNC_PLAN_POSITION_KINEMATIC();
// 6395 
// 6396     if (G38_endstop_hit) {
// 6397 
// 6398       G38_pass_fail = true;
// 6399 
// 6400       #if ENABLED(PROBE_DOUBLE_TOUCH)
// 6401         // Move away by the retract distance
// 6402         set_destination_to_current();
// 6403         LOOP_XYZ(i) destination[i] += retract_mm[i];
// 6404         endstops.enable(false);
// 6405         prepare_move_to_destination();
// 6406         stepper.synchronize();
// 6407 
// 6408         feedrate_mm_s /= 4;
// 6409 
// 6410         // Bump the target more slowly
// 6411         LOOP_XYZ(i) destination[i] -= retract_mm[i] * 2;
// 6412 
// 6413         endstops.enable(true);
// 6414         G38_move = true;
// 6415         prepare_move_to_destination();
// 6416         stepper.synchronize();
// 6417         G38_move = false;
// 6418 
// 6419         set_current_from_steppers_for_axis(ALL_AXES);
// 6420         SYNC_PLAN_POSITION_KINEMATIC();
// 6421       #endif
// 6422     }
// 6423 
// 6424     endstops.hit_on_purpose();
// 6425     endstops.not_homing();
// 6426     return G38_pass_fail;
// 6427   }
// 6428 
// 6429   /**
// 6430    * G38.2 - probe toward workpiece, stop on contact, signal error if failure
// 6431    * G38.3 - probe toward workpiece, stop on contact
// 6432    *
// 6433    * Like G28 except uses Z min probe for all axes
// 6434    */
// 6435   inline void gcode_G38(bool is_38_2) {
// 6436     // Get X Y Z E F
// 6437     gcode_get_destination();
// 6438 
// 6439     setup_for_endstop_or_probe_move();
// 6440 
// 6441     // If any axis has enough movement, do the move
// 6442     LOOP_XYZ(i)
// 6443       if (fabs(destination[i] - current_position[i]) >= G38_MINIMUM_MOVE) {
// 6444         if (!code_seen('F')) feedrate_mm_s = homing_feedrate_mm_s[i];
// 6445         // If G38.2 fails throw an error
// 6446         if (!G38_run_probe() && is_38_2) {
// 6447           SERIAL_ERROR_START;
// 6448           SERIAL_ERRORLNPGM("Failed to reach target");
// 6449         }
// 6450         break;
// 6451       }
// 6452 
// 6453     clean_up_after_endstop_or_probe_move();
// 6454   }
// 6455 
// 6456 #endif // G38_PROBE_TARGET
// 6457 
// 6458 /**
// 6459  * G92: Set current position to given X Y Z E
// 6460  */
// 6461 inline void gcode_G92() {
// 6462   bool didXYZ = false,
// 6463        didE = code_seen('E');
// 6464 
// 6465   if (!didE) stepper.synchronize();
// 6466 
// 6467   LOOP_XYZE(i) {
// 6468     if (code_seen(axis_codes[i])) {
// 6469 //      #if IS_SCARA	//mks_delta
// 6470 		if(MACHINETPYE&IS_SCARA) {
// 6471         current_position[i] = code_value_axis_units((AxisEnum)i);
// 6472         if (i != E_AXIS) didXYZ = true;}
// 6473 //      #else
// 6474 		else {
// 6475         #if HAS_POSITION_SHIFT
// 6476           const float p = current_position[i];
// 6477         #endif
// 6478         float v = code_value_axis_units((AxisEnum)i);
// 6479 
// 6480         current_position[i] = v;
// 6481 
// 6482         if (i != E_AXIS) {
// 6483           didXYZ = true;
// 6484           #if HAS_POSITION_SHIFT
// 6485             position_shift[i] += v - p; // Offset the coordinate space
// 6486             update_software_endstops((AxisEnum)i);
// 6487           #endif
// 6488         }
// 6489       } //#endif
// 6490     }
// 6491   }
// 6492   if (didXYZ)
// 6493     SYNC_PLAN_POSITION_KINEMATIC();
// 6494   else if (didE)
// 6495     sync_plan_position_e();
// 6496 
// 6497   report_current_position();
// 6498 }
// 6499 
// 6500 #if HAS_RESUME_CONTINUE
// 6501 
// 6502   /**
// 6503    * M0: Unconditional stop - Wait for user button press on LCD
// 6504    * M1: Conditional stop   - Wait for user button press on LCD
// 6505    */
// 6506   inline void gcode_M0_M1() {
// 6507     const char * const args = current_command_args;
// 6508 
// 6509     millis_t codenum = 0;
// 6510     bool hasP = false, hasS = false;
// 6511     if (code_seen('P')) {
// 6512       codenum = code_value_millis(); // milliseconds to wait
// 6513       hasP = codenum > 0;
// 6514     }
// 6515     if (code_seen('S')) {
// 6516       codenum = code_value_millis_from_seconds(); // seconds to wait
// 6517       hasS = codenum > 0;
// 6518     }
// 6519 
// 6520     #if ENABLED(ULTIPANEL)
// 6521 
// 6522       if (!hasP && !hasS && *args != '\0')
// 6523         lcd_setstatus(args, true);
// 6524       else {
// 6525         LCD_MESSAGEPGM(MSG_USERWAIT);
// 6526         #if ENABLED(LCD_PROGRESS_BAR) && PROGRESS_MSG_EXPIRE > 0
// 6527           dontExpireStatus();
// 6528         #endif
// 6529       }
// 6530 
// 6531     #else
// 6532 
// 6533       if (!hasP && !hasS && *args != '\0') {
// 6534         SERIAL_ECHO_START;
// 6535         SERIAL_ECHOLN(args);
// 6536       }
// 6537 
// 6538     #endif
// 6539 
// 6540     KEEPALIVE_STATE(PAUSED_FOR_USER);
// 6541     wait_for_user = true;
// 6542 
// 6543     stepper.synchronize();
// 6544     refresh_cmd_timeout();
// 6545 
// 6546     if (codenum > 0) {
// 6547       codenum += previous_cmd_ms;  // wait until this time for a click
// 6548       while (PENDING(millis(), codenum) && wait_for_user) idle();
// 6549     }
// 6550     else {
// 6551       #if ENABLED(ULTIPANEL)
// 6552         if (lcd_detected()) {
// 6553           while (wait_for_user) idle();
// 6554           IS_SD_PRINTING ? LCD_MESSAGEPGM(MSG_RESUMING) : LCD_MESSAGEPGM(WELCOME_MSG);
// 6555         }
// 6556       #else
// 6557         while (wait_for_user) idle();
// 6558       #endif
// 6559     }
// 6560 
// 6561     wait_for_user = false;
// 6562     KEEPALIVE_STATE(IN_HANDLER);
// 6563   }
// 6564 
// 6565 #endif // HAS_RESUME_CONTINUE
// 6566 
// 6567 /**
// 6568  * M17: Enable power on all stepper motors
// 6569  */
// 6570 inline void gcode_M17() {
// 6571   LCD_MESSAGEPGM(MSG_NO_MOVE);
// 6572   enable_all_steppers();
// 6573 }
// 6574 
// 6575 //mks_delta		begin
// 6576 /*
// 6577 #if IS_KINEMATIC
// 6578   #define RUNPLAN(RATE_MM_S) planner.buffer_line_kinematic(destination, RATE_MM_S, active_extruder)
// 6579 #else
// 6580   #define RUNPLAN(RATE_MM_S) line_to_destination(RATE_MM_S)
// 6581 #endif
// 6582 */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock61 Using cfiCommon0
          CFI Function _Z7RUNPLANf
        THUMB
// 6583 void RUNPLAN(float RATE_MM_S)
// 6584 {
_Z7RUNPLANf:
        PUSH     {R0,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 6585 	if(MACHINETPYE & IS_KINEMATIC)
        LDR.W    R0,??DataTable136_8
        LDRH     R0,[R0, #+88]
        MOVW     R1,#+770
        TST      R0,R1
        BEQ.N    ??RUNPLAN_0
// 6586 		planner.buffer_line_kinematic(destination, RATE_MM_S, active_extruder);
        LDR.W    R0,??DataTable136_2
        LDRB     R2,[R0, #+2]
        MOV      R1,SP
        ADDS     R0,R0,#+24
          CFI FunCall _ZN7Planner21buffer_line_kinematicEPKfRS0_h
        BL       _ZN7Planner21buffer_line_kinematicEPKfRS0_h
        POP      {R0,PC}
// 6587 	else
// 6588 		line_to_destination(RATE_MM_S);
??RUNPLAN_0:
        LDR      R0,[SP, #+0]
          CFI FunCall _Z19line_to_destinationf
        BL       _Z19line_to_destinationf
// 6589 }
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock61

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable130:
        DC32     _ZN17mesh_bed_leveling8z_valuesE
// 6590 //mks_delta		end
// 6591 
// 6592 #if ENABLED(PARK_HEAD_ON_PAUSE)
// 6593   float resume_position[XYZE];
// 6594   bool move_away_flag = false;
// 6595 
// 6596   inline void move_back_on_resume() {
// 6597     if (!move_away_flag) return;
// 6598     move_away_flag = false;
// 6599 
// 6600     // Set extruder to saved position
// 6601     destination[E_AXIS] = current_position[E_AXIS] = resume_position[E_AXIS];
// 6602     planner.set_e_position_mm(current_position[E_AXIS]);
// 6603 
// 6604     //#if IS_KINEMATIC	//mks_delta
// 6605     if(MACHINETPYE & IS_KINEMATIC)
// 6606       // Move XYZ to starting position
// 6607       planner.buffer_line_kinematic(lastpos, FILAMENT_CHANGE_XY_FEEDRATE, active_extruder);
// 6608     //#else
// 6609     else
// 6610     	{
// 6611       // Move XY to starting position, then Z
// 6612       destination[X_AXIS] = resume_position[X_AXIS];
// 6613       destination[Y_AXIS] = resume_position[Y_AXIS];
// 6614       RUNPLAN(FILAMENT_CHANGE_XY_FEEDRATE);
// 6615       destination[Z_AXIS] = resume_position[Z_AXIS];
// 6616       RUNPLAN(FILAMENT_CHANGE_Z_FEEDRATE);
// 6617     	}
// 6618 	//#endif
// 6619     stepper.synchronize();
// 6620 
// 6621     #if ENABLED(FILAMENT_RUNOUT_SENSOR)
// 6622       filament_ran_out = false;
// 6623     #endif
// 6624     set_current_to_destination();
// 6625   }
// 6626 
// 6627 #endif // PARK_HEAD_ON_PAUSE
// 6628 
// 6629 #if ENABLED(SDSUPPORT)
// 6630 
// 6631   /**
// 6632    * M20: List SD card to serial output
// 6633    */
// 6634   inline void gcode_M20() {
// 6635     SERIAL_PROTOCOLLNPGM(MSG_BEGIN_FILE_LIST);
// 6636     card.ls();
// 6637     SERIAL_PROTOCOLLNPGM(MSG_END_FILE_LIST);
// 6638   }
// 6639 
// 6640   /**
// 6641    * M21: Init SD Card
// 6642    */
// 6643   inline void gcode_M21() { card.initsd(); }
// 6644 
// 6645   /**
// 6646    * M22: Release SD Card
// 6647    */
// 6648   inline void gcode_M22() { card.release(); }
// 6649 
// 6650   /**
// 6651    * M23: Open a file
// 6652    */
// 6653 #ifdef USE_MKS_WIFI    
// 6654   inline void gcode_M23() { 
// 6655   	if(card.openFile(current_command_args, true) < 0)
// 6656   	{
// 6657   		/*for 8.3 principle*/
// 6658 		char *gSuffix = strstr((char *)current_command_args, ".g");
// 6659 		if(!gSuffix)
// 6660 		{
// 6661 			gSuffix = strstr((char *)current_command_args, ".G");		
// 6662 		}
// 6663 		if(gSuffix)
// 6664 		{
// 6665 			*(gSuffix + 2) = '\0';
// 6666 			if((uint32_t)gSuffix - (uint32_t)current_command_args > 8)
// 6667 			{
// 6668 				current_command_args[7] = '~';
// 6669 				current_command_args[8] = '.';
// 6670 				current_command_args[9] = 'g';
// 6671 				current_command_args[10] = '\0';
// 6672 			}
// 6673 			card.openFile(current_command_args, true) ;
// 6674 		}
// 6675   	}
// 6676   }
// 6677 #else
// 6678 inline void gcode_M23() { card.openFile(current_command_args, true); }
// 6679 #endif
// 6680   /**
// 6681    * M24: Start or Resume SD Print
// 6682    */
// 6683   inline void gcode_M24() {
// 6684   
// 6685 	mks_resumePrint();
// 6686 
// 6687     #if ENABLED(PARK_HEAD_ON_PAUSE)
// 6688       move_back_on_resume();
// 6689     #endif
// 6690 
// 6691 #ifdef USE_MKS_WIFI
// 6692     if(card.lastOpenOk())
// 6693 #endif		
// 6694    {
// 6695     card.startFileprint();
// 6696     print_job_timer.start();
// 6697   }
// 6698   }
// 6699 
// 6700   /**
// 6701    * M25: Pause SD Print
// 6702    */
// 6703   inline void gcode_M25() {
// 6704     card.pauseSDPrint();
// 6705     print_job_timer.pause();
// 6706 
// 6707     #if ENABLED(PARK_HEAD_ON_PAUSE)
// 6708       enqueue_and_echo_commands_P(PSTR("M125")); // Must be enqueued with pauseSDPrint set to be last in the buffer
// 6709     #endif
// 6710 	mksReprint.mks_printer_state = MKS_PAUSING;
// 6711   }
// 6712 
// 6713   /**
// 6714    * M26: Set SD Card file index
// 6715    */
// 6716   inline void gcode_M26() {
// 6717     if (card.cardOK && code_seen('S'))
// 6718       card.setIndex(code_value_long());
// 6719   }
// 6720 
// 6721   /**
// 6722    * M27: Get SD Card status
// 6723    */
// 6724   inline void gcode_M27() { card.getStatus(); }
// 6725 
// 6726   /**
// 6727    * M28: Start SD Write
// 6728    */
// 6729   inline void gcode_M28() { card.openFile(current_command_args, false); }
// 6730 
// 6731   /**
// 6732    * M29: Stop SD Write
// 6733    * Processed in write to file routine above
// 6734    */
// 6735   inline void gcode_M29() {
// 6736     // card.saving = false;
// 6737   }
// 6738 
// 6739   /**
// 6740    * M30 <filename>: Delete SD Card file
// 6741    */
// 6742   inline void gcode_M30() {
// 6743     if (card.cardOK) {
// 6744       card.closefile();
// 6745       card.removeFile(current_command_args);
// 6746     }
// 6747   }
// 6748 
// 6749 #endif // SDSUPPORT
// 6750 
// 6751 /**
// 6752  * M31: Get the time since the start of SD Print (or last M109)
// 6753  */
// 6754 inline void gcode_M31() {
// 6755   char buffer[21];
// 6756   duration_t elapsed = print_job_timer.duration();
// 6757   elapsed.toString(buffer);
// 6758   lcd_setstatus(buffer);
// 6759 
// 6760   SERIAL_ECHO_START;
// 6761   SERIAL_ECHOLNPAIR("Print time: ", buffer);
// 6762 }
// 6763 
// 6764 #if ENABLED(SDSUPPORT)
// 6765 
// 6766   /**
// 6767    * M32: Select file and start SD Print
// 6768    */
// 6769   inline void gcode_M32() {
// 6770     if (card.sdprinting)
// 6771       stepper.synchronize();
// 6772 
// 6773     char* namestartpos = strchr(current_command_args, '!');  // Find ! to indicate filename string start.
// 6774     if (!namestartpos)
// 6775       namestartpos = current_command_args; // Default name position, 4 letters after the M
// 6776     else
// 6777       namestartpos++; //to skip the '!'
// 6778 
// 6779     bool call_procedure = code_seen('P') && (seen_pointer < namestartpos);
// 6780 
// 6781     if (card.cardOK) {
// 6782       card.openFile(namestartpos, true, call_procedure);
// 6783 
// 6784       if (code_seen('S') && seen_pointer < namestartpos) // "S" (must occur _before_ the filename!)
// 6785         card.setIndex(code_value_long());
// 6786 
// 6787       card.startFileprint();
// 6788 
// 6789       // Procedure calls count as normal print time.
// 6790       if (!call_procedure) print_job_timer.start();
// 6791     }
// 6792   }
// 6793 
// 6794   #if ENABLED(LONG_FILENAME_HOST_SUPPORT)
// 6795 
// 6796     /**
// 6797      * M33: Get the long full path of a file or folder
// 6798      *
// 6799      * Parameters:
// 6800      *   <dospath> Case-insensitive DOS-style path to a file or folder
// 6801      *
// 6802      * Example:
// 6803      *   M33 miscel~1/armchair/armcha~1.gco
// 6804      *
// 6805      * Output:
// 6806      *   /Miscellaneous/Armchair/Armchair.gcode
// 6807      */
// 6808     inline void gcode_M33() {
// 6809       card.printLongPath(current_command_args);
// 6810     }
// 6811 
// 6812   #endif
// 6813 
// 6814   #if ENABLED(SDCARD_SORT_ALPHA) && ENABLED(SDSORT_GCODE)
// 6815     /**
// 6816      * M34: Set SD Card Sorting Options
// 6817      */
// 6818     inline void gcode_M34() {
// 6819       if (code_seen('S')) card.setSortOn(code_value_bool());
// 6820       if (code_seen('F')) {
// 6821         int v = code_value_long();
// 6822         card.setSortFolders(v < 0 ? -1 : v > 0 ? 1 : 0);
// 6823       }
// 6824       //if (code_seen('R')) card.setSortReverse(code_value_bool());
// 6825     }
// 6826   #endif // SDCARD_SORT_ALPHA && SDSORT_GCODE
// 6827 
// 6828   /**
// 6829    * M928: Start SD Write
// 6830    */
// 6831   inline void gcode_M928() {
// 6832     card.openLogFile(current_command_args);
// 6833   }
// 6834 
// 6835 #endif // SDSUPPORT
// 6836 
// 6837 /**
// 6838  * Sensitive pin test for M42, M226
// 6839  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock62 Using cfiCommon0
          CFI Function _ZN37_INTERNAL_15_Marlin_main_cpp_3178531916pin_is_protectedEh
          CFI NoCalls
        THUMB
// 6840 static bool pin_is_protected(uint8_t pin) {
// 6841   static const int sensitive_pins[] = SENSITIVE_PINS;
// 6842   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
_ZN37_INTERNAL_15_Marlin_main_cpp_3178531916pin_is_protectedEh:
        MOVS     R1,#+0
        B.N      ??pin_is_protected_0
??pin_is_protected_1:
        ADDS     R1,R1,#+1
??pin_is_protected_0:
        MOV      R2,R1
        UXTB     R2,R2
        CMP      R2,#+40
        BCS.N    ??pin_is_protected_2
// 6843     if (sensitive_pins[i] == pin) return true;
        ADR.W    R2,`pin_is_protected(uint8_t)::sensitive_pins`
        MOV      R3,R1
        UXTB     R3,R3
        LDR      R2,[R2, R3, LSL #+2]
        MOV      R3,R0
        CMP      R2,R3
        BNE.N    ??pin_is_protected_1
        MOVS     R0,#+1
        BX       LR
// 6844   return false;
??pin_is_protected_2:
        MOVS     R0,#+0
        BX       LR               ;; return
// 6845 }
          CFI EndBlock cfiBlock62

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`pin_is_protected(uint8_t)::sensitive_pins`:
        DC32 0, 1, 3, 2, 14, 4, 4, 6, 5, 14, 7, 7, 9, 8, 14, 10, 11, 11, -1, 15
        DC32 17, -1, -1, -1, 13, 12, 30, -1, -1, 15, 79, 16, -1, 78, -1, -1, -1
        DC32 -1, -1, -1
// 6846 
// 6847 /**
// 6848  * M42: Change pin status via GCode
// 6849  *
// 6850  *  P<pin>  Pin number (LED if omitted)
// 6851  *  S<byte> Pin status from 0 - 255
// 6852  */
// 6853 inline void gcode_M42() {
// 6854   if (!code_seen('S')) return;
// 6855 
// 6856   int pin_status = code_value_int();
// 6857   if (!WITHIN(pin_status, 0, 255)) return;
// 6858 
// 6859   int pin_number = code_seen('P') ? code_value_int() : LED_PIN;
// 6860   if (pin_number < 0) return;
// 6861 
// 6862   if (pin_is_protected(pin_number)) {
// 6863     SERIAL_ERROR_START;
// 6864     SERIAL_ERRORLNPGM(MSG_ERR_PROTECTED_PIN);
// 6865     return;
// 6866   }
// 6867 
// 6868   pinMode(pin_number, OUTPUT);
// 6869   digitalWrite(pin_number, pin_status);
// 6870   //analogWrite(pin_number, pin_status);	/*--mks--*/
// 6871 
// 6872   #if FAN_COUNT > 0
// 6873     switch (pin_number) {
// 6874       #if HAS_FAN0
// 6875         case FAN_PIN: fanSpeeds[0] = pin_status; break;
// 6876       #endif
// 6877       #if HAS_FAN1
// 6878         case FAN1_PIN: fanSpeeds[1] = pin_status; break;
// 6879       #endif
// 6880       #if HAS_FAN2
// 6881         case FAN2_PIN: fanSpeeds[2] = pin_status; break;
// 6882       #endif
// 6883     }
// 6884   #endif
// 6885 }
// 6886 
// 6887 #if ENABLED(PINS_DEBUGGING)
// 6888 
// 6889   #include "pinsDebug.h"
// 6890 
// 6891   inline void toggle_pins() {
// 6892     const bool I_flag = code_seen('I') && code_value_bool();
// 6893     const int repeat = code_seen('R') ? code_value_int() : 1,
// 6894               start = code_seen('S') ? code_value_int() : 0,
// 6895               end = code_seen('E') ? code_value_int() : NUM_DIGITAL_PINS - 1,
// 6896               wait = code_seen('W') ? code_value_int() : 500;
// 6897 
// 6898     for (uint8_t pin = start; pin <= end; pin++) {
// 6899       if (!I_flag && pin_is_protected(pin)) {
// 6900         SERIAL_ECHOPAIR("Sensitive Pin: ", pin);
// 6901         SERIAL_ECHOLNPGM(" untouched.");
// 6902       }
// 6903       else {
// 6904         SERIAL_ECHOPAIR("Pulsing Pin: ", pin);
// 6905         pinMode(pin, OUTPUT);
// 6906         for (int16_t j = 0; j < repeat; j++) {
// 6907           digitalWrite(pin, 0);
// 6908           safe_delay(wait);
// 6909           digitalWrite(pin, 1);
// 6910           safe_delay(wait);
// 6911           digitalWrite(pin, 0);
// 6912           safe_delay(wait);
// 6913         }
// 6914       }
// 6915       SERIAL_CHAR('\n');
// 6916     }
// 6917     SERIAL_ECHOLNPGM("Done.");
// 6918 
// 6919   } // toggle_pins
// 6920 
// 6921   inline void servo_probe_test() {
// 6922     #if !(NUM_SERVOS > 0 && HAS_SERVO_0)
// 6923 
// 6924       SERIAL_ERROR_START;
// 6925       SERIAL_ERRORLNPGM("SERVO not setup");
// 6926 
// 6927     #elif !HAS_Z_SERVO_ENDSTOP
// 6928 
// 6929       SERIAL_ERROR_START;
// 6930       SERIAL_ERRORLNPGM("Z_ENDSTOP_SERVO_NR not setup");
// 6931 
// 6932     #else
// 6933 
// 6934       const uint8_t probe_index = code_seen('P') ? code_value_byte() : Z_ENDSTOP_SERVO_NR;
// 6935 
// 6936       SERIAL_PROTOCOLLNPGM("Servo probe test");
// 6937       SERIAL_PROTOCOLLNPAIR(".  using index:  ", probe_index);
// 6938       SERIAL_PROTOCOLLNPAIR(".  deploy angle: ", z_servo_angle[0]);
// 6939       SERIAL_PROTOCOLLNPAIR(".  stow angle:   ", z_servo_angle[1]);
// 6940 
// 6941       bool probe_inverting;
// 6942 
// 6943       //#if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
// 6944       uint8_t PROBE_TEST_PIN = 0;
// 6945 	  if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
// 6946 	  	{
// 6947 
// 6948        // #define PROBE_TEST_PIN Z_MIN_PIN
// 6949 		PROBE_TEST_PIN = Z_MIN_PIN;
// 6950 
// 6951         SERIAL_PROTOCOLLNPAIR(". probe uses Z_MIN pin: ", PROBE_TEST_PIN);
// 6952         SERIAL_PROTOCOLLNPGM(". uses Z_MIN_ENDSTOP_INVERTING (ignores Z_MIN_PROBE_ENDSTOP_INVERTING)");
// 6953         SERIAL_PROTOCOLPGM(". Z_MIN_ENDSTOP_INVERTING: ");
// 6954 
// 6955 		/*--mks cfg begin-- Z_MIN_ENDSTOP_INVERTING */
// 6956 		/*
// 6957 		#if Z_MIN_ENDSTOP_INVERTING
// 6958           SERIAL_PROTOCOLLNPGM("true");
// 6959         #else
// 6960           SERIAL_PROTOCOLLNPGM("false");
// 6961         #endif
// 6962 		*/
// 6963 		if(Z_MIN_ENDSTOP_INVERTING)
// 6964 			SERIAL_PROTOCOLLNPGM("true");
// 6965 		else
// 6966 			SERIAL_PROTOCOLLNPGM("false");
// 6967 		/*--mks cfg end-- Z_MIN_ENDSTOP_INVERTING */
// 6968 
// 6969         probe_inverting = Z_MIN_ENDSTOP_INVERTING;
// 6970 	  	}
// 6971       //#elif ENABLED(Z_MIN_PROBE_ENDSTOP)
// 6972 	  else if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN
// 6973 	  	{
// 6974 
// 6975         //#define PROBE_TEST_PIN Z_MIN_PROBE_PIN
// 6976 		PROBE_TEST_PIN = Z_MAX_PIN;
// 6977         SERIAL_PROTOCOLLNPAIR(". probe uses Z_MIN_PROBE_PIN: ", PROBE_TEST_PIN);
// 6978         SERIAL_PROTOCOLLNPGM(". uses Z_MIN_PROBE_ENDSTOP_INVERTING (ignores Z_MIN_ENDSTOP_INVERTING)");
// 6979         SERIAL_PROTOCOLPGM(". Z_MIN_PROBE_ENDSTOP_INVERTING: ");
// 6980 
// 6981 	/*--mks cfg begin-- Z_MIN_ENDSTOP_INVERTING */
// 6982 	/*
// 6983         #if Z_MIN_PROBE_ENDSTOP_INVERTING
// 6984           SERIAL_PROTOCOLLNPGM("true");
// 6985         #else
// 6986           SERIAL_PROTOCOLLNPGM("false");
// 6987         #endif
// 6988 		*/
// 6989 		if(Z_MIN_PROBE_ENDSTOP_INVERTING)
// 6990 			SERIAL_PROTOCOLLNPGM("true");
// 6991 			else
// 6992 				SERIAL_PROTOCOLLNPGM("false");
// 6993 	/*--mks cfg end-- Z_MIN_ENDSTOP_INVERTING */
// 6994 
// 6995         probe_inverting = Z_MIN_PROBE_ENDSTOP_INVERTING;
// 6996 	  	}
// 6997       //#endif
// 6998 
// 6999       SERIAL_PROTOCOLLNPGM(". deploy & stow 4 times");
// 7000       pinMode(PROBE_TEST_PIN, INPUT_PULLUP);
// 7001       bool deploy_state;
// 7002       bool stow_state;
// 7003       for (uint8_t i = 0; i < 4; i++) {
// 7004         servo[probe_index].move(z_servo_angle[0]); //deploy
// 7005         safe_delay(500);
// 7006         deploy_state = digitalRead(PROBE_TEST_PIN);
// 7007         servo[probe_index].move(z_servo_angle[1]); //stow
// 7008         safe_delay(500);
// 7009         stow_state = digitalRead(PROBE_TEST_PIN);
// 7010       }
// 7011       if (probe_inverting != deploy_state) SERIAL_PROTOCOLLNPGM("WARNING - INVERTING setting probably backwards");
// 7012 
// 7013       refresh_cmd_timeout();
// 7014 
// 7015       if (deploy_state != stow_state) {
// 7016         SERIAL_PROTOCOLLNPGM("BLTouch clone detected");
// 7017         if (deploy_state) {
// 7018           SERIAL_PROTOCOLLNPGM(".  DEPLOYED state: HIGH (logic 1)");
// 7019           SERIAL_PROTOCOLLNPGM(".  STOWED (triggered) state: LOW (logic 0)");
// 7020         }
// 7021         else {
// 7022           SERIAL_PROTOCOLLNPGM(".  DEPLOYED state: LOW (logic 0)");
// 7023           SERIAL_PROTOCOLLNPGM(".  STOWED (triggered) state: HIGH (logic 1)");
// 7024         }
// 7025         #if ENABLED(BLTOUCH)
// 7026           SERIAL_PROTOCOLLNPGM("ERROR: BLTOUCH enabled - set this device up as a Z Servo Probe with inverting as true.");
// 7027         #endif
// 7028 
// 7029       }
// 7030       else {                                           // measure active signal length
// 7031         servo[probe_index].move(z_servo_angle[0]);     // deploy
// 7032         safe_delay(500);
// 7033         SERIAL_PROTOCOLLNPGM("please trigger probe");
// 7034         uint16_t probe_counter = 0;
// 7035 
// 7036         // Allow 30 seconds max for operator to trigger probe
// 7037         for (uint16_t j = 0; j < 500 * 30 && probe_counter == 0 ; j++) {
// 7038 
// 7039           safe_delay(2);
// 7040 
// 7041           if (0 == j % (500 * 1)) // keep cmd_timeout happy
// 7042             refresh_cmd_timeout();
// 7043 
// 7044           if (deploy_state != digitalRead(PROBE_TEST_PIN)) { // probe triggered
// 7045 
// 7046             for (probe_counter = 1; probe_counter < 50 && deploy_state != digitalRead(PROBE_TEST_PIN); ++probe_counter)
// 7047               safe_delay(2);
// 7048 
// 7049             if (probe_counter == 50)
// 7050               SERIAL_PROTOCOLLNPGM("Z Servo Probe detected"); // >= 100mS active time
// 7051             else if (probe_counter >= 2)
// 7052               SERIAL_PROTOCOLLNPAIR("BLTouch compatible probe detected - pulse width (+/- 4mS): ", probe_counter * 2); // allow 4 - 100mS pulse
// 7053             else
// 7054               SERIAL_PROTOCOLLNPGM("noise detected - please re-run test"); // less than 2mS pulse
// 7055 
// 7056             servo[probe_index].move(z_servo_angle[1]); //stow
// 7057 
// 7058           }  // pulse detected
// 7059 
// 7060         } // for loop waiting for trigger
// 7061 
// 7062         if (probe_counter == 0) SERIAL_PROTOCOLLNPGM("trigger not detected");
// 7063 
// 7064       } // measure active signal length
// 7065 
// 7066     #endif
// 7067 
// 7068   } // servo_probe_test
// 7069 
// 7070   /**
// 7071    * M43: Pin debug - report pin state, watch pins, toggle pins and servo probe test/report
// 7072    *
// 7073    *  M43         - report name and state of pin(s)
// 7074    *                  P<pin>  Pin to read or watch. If omitted, reads all pins.
// 7075    *                  I       Flag to ignore Marlin's pin protection.
// 7076    *
// 7077    *  M43 W       - Watch pins -reporting changes- until reset, click, or M108.
// 7078    *                  P<pin>  Pin to read or watch. If omitted, read/watch all pins.
// 7079    *                  I       Flag to ignore Marlin's pin protection.
// 7080    *
// 7081    *  M43 E<bool> - Enable / disable background endstop monitoring
// 7082    *                  - Machine continues to operate
// 7083    *                  - Reports changes to endstops
// 7084    *                  - Toggles LED when an endstop changes
// 7085    *                  - Can not reliably catch the 5mS pulse from BLTouch type probes
// 7086    *
// 7087    *  M43 T       - Toggle pin(s) and report which pin is being toggled
// 7088    *                  S<pin>  - Start Pin number.   If not given, will default to 0
// 7089    *                  L<pin>  - End Pin number.   If not given, will default to last pin defined for this board
// 7090    *                  I       - Flag to ignore Marlin's pin protection.   Use with caution!!!!
// 7091    *                  R       - Repeat pulses on each pin this number of times before continueing to next pin
// 7092    *                  W       - Wait time (in miliseconds) between pulses.  If not given will default to 500
// 7093    *
// 7094    *  M43 S       - Servo probe test
// 7095    *                  P<index> - Probe index (optional - defaults to 0
// 7096    */
// 7097   inline void gcode_M43() {
// 7098 
// 7099     if (code_seen('T')) {   // must be first ot else it's "S" and "E" parameters will execute endstop or servo test
// 7100       toggle_pins();
// 7101       return;
// 7102     }
// 7103 
// 7104     // Enable or disable endstop monitoring
// 7105     if (code_seen('E')) {
// 7106       endstop_monitor_flag = code_value_bool();
// 7107       SERIAL_PROTOCOLPGM("endstop monitor ");
// 7108       SERIAL_PROTOCOL(endstop_monitor_flag ? "en" : "dis");
// 7109       SERIAL_PROTOCOLLNPGM("abled");
// 7110       return;
// 7111     }
// 7112 
// 7113     if (code_seen('S')) {
// 7114       servo_probe_test();
// 7115       return;
// 7116     }
// 7117 
// 7118     // Get the range of pins to test or watch
// 7119     const uint8_t first_pin = code_seen('P') ? code_value_byte() : 0,
// 7120                   last_pin = code_seen('P') ? first_pin : NUM_DIGITAL_PINS - 1;
// 7121 
// 7122     if (first_pin > last_pin) return;
// 7123 
// 7124     const bool ignore_protection = code_seen('I') && code_value_bool();
// 7125 
// 7126     // Watch until click, M108, or reset
// 7127     if (code_seen('W') && code_value_bool()) {
// 7128       SERIAL_PROTOCOLLNPGM("Watching pins");
// 7129       byte pin_state[last_pin - first_pin + 1];
// 7130       for (int8_t pin = first_pin; pin <= last_pin; pin++) {
// 7131         if (pin_is_protected(pin) && !ignore_protection) continue;
// 7132         pinMode(pin, INPUT_PULLUP);
// 7133         /*
// 7134           if (IS_ANALOG(pin))
// 7135             pin_state[pin - first_pin] = analogRead(pin - analogInputToDigitalPin(0)); // int16_t pin_state[...]
// 7136           else
// 7137         //*/
// 7138             pin_state[pin - first_pin] = digitalRead(pin);
// 7139       }
// 7140 
// 7141       #if HAS_RESUME_CONTINUE
// 7142         wait_for_user = true;
// 7143         KEEPALIVE_STATE(PAUSED_FOR_USER);
// 7144       #endif
// 7145 
// 7146       for (;;) {
// 7147         for (int8_t pin = first_pin; pin <= last_pin; pin++) {
// 7148           if (pin_is_protected(pin)) continue;
// 7149           const byte val =
// 7150             /*
// 7151               IS_ANALOG(pin)
// 7152                 ? analogRead(pin - analogInputToDigitalPin(0)) : // int16_t val
// 7153                 :
// 7154             //*/
// 7155               digitalRead(pin);
// 7156           if (val != pin_state[pin - first_pin]) {
// 7157             report_pin_state(pin);
// 7158             pin_state[pin - first_pin] = val;
// 7159           }
// 7160         }
// 7161 
// 7162         #if HAS_RESUME_CONTINUE
// 7163           if (!wait_for_user) {
// 7164             KEEPALIVE_STATE(IN_HANDLER);
// 7165             break;
// 7166           }
// 7167         #endif
// 7168 
// 7169         safe_delay(500);
// 7170       }
// 7171       return;
// 7172     }
// 7173 
// 7174     // Report current state of selected pin(s)
// 7175     for (uint8_t pin = first_pin; pin <= last_pin; pin++)
// 7176       report_pin_state_extended(pin, ignore_protection);
// 7177   }
// 7178 
// 7179 #endif // PINS_DEBUGGING
// 7180 
// 7181 #if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
// 7182 
// 7183   /**
// 7184    * M48: Z probe repeatability measurement function.
// 7185    *
// 7186    * Usage:
// 7187    *   M48 <P#> <X#> <Y#> <V#> <E> <L#>
// 7188    *     P = Number of sampled points (4-50, default 10)
// 7189    *     X = Sample X position
// 7190    *     Y = Sample Y position
// 7191    *     V = Verbose level (0-4, default=1)
// 7192    *     E = Engage Z probe for each reading
// 7193    *     L = Number of legs of movement before probe
// 7194    *     S = Schizoid (Or Star if you prefer)
// 7195    *
// 7196    * This function assumes the bed has been homed.  Specifically, that a G28 command
// 7197    * as been issued prior to invoking the M48 Z probe repeatability measurement function.
// 7198    * Any information generated by a prior G29 Bed leveling command will be lost and need to be
// 7199    * regenerated.
// 7200    */
// 7201   inline void gcode_M48() {
// 7202 
// 7203     if (axis_unhomed_error(true, true, true)) return;
// 7204 
// 7205     const int8_t verbose_level = code_seen('V') ? code_value_byte() : 1;
// 7206     if (!WITHIN(verbose_level, 0, 4)) {
// 7207 		SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-4).");
// 7208       return;
// 7209     }
// 7210 
// 7211     if (verbose_level > 0)
// 7212       SERIAL_PROTOCOLLNPGM("M48 Z-Probe Repeatability Test");
// 7213 
// 7214     int8_t n_samples = code_seen('P') ? code_value_byte() : 10;
// 7215     if (!WITHIN(n_samples, 4, 50)) {
// 7216       SERIAL_PROTOCOLLNPGM("?Sample size not plausible (4-50).");
// 7217       return;
// 7218     }
// 7219 
// 7220     float X_current = current_position[X_AXIS],
// 7221           Y_current = current_position[Y_AXIS];
// 7222 
// 7223     bool stow_probe_after_each = code_seen('E');
// 7224 
// 7225     float X_probe_location = code_seen('X') ? code_value_linear_units() : X_current + X_PROBE_OFFSET_FROM_EXTRUDER;
// 7226     #if DISABLED(DELTA)
// 7227       if (!WITHIN(X_probe_location, LOGICAL_X_POSITION(MIN_PROBE_X), LOGICAL_X_POSITION(MAX_PROBE_X))) {
// 7228         out_of_range_error(PSTR("X"));
// 7229         return;
// 7230       }
// 7231     #endif
// 7232 
// 7233     float Y_probe_location = code_seen('Y') ? code_value_linear_units() : Y_current + Y_PROBE_OFFSET_FROM_EXTRUDER;
// 7234     #if DISABLED(DELTA)
// 7235       if (!WITHIN(Y_probe_location, LOGICAL_Y_POSITION(MIN_PROBE_Y), LOGICAL_Y_POSITION(MAX_PROBE_Y))) {
// 7236         out_of_range_error(PSTR("Y"));
// 7237         return;
// 7238       }
// 7239     #else
// 7240       float pos[XYZ] = { X_probe_location, Y_probe_location, 0 };
// 7241       if (!position_is_reachable(pos, true)) {
// 7242         SERIAL_PROTOCOLLNPGM("? (X,Y) location outside of probeable radius.");
// 7243         return;
// 7244       }
// 7245     #endif
// 7246 
// 7247     bool seen_L = code_seen('L');
// 7248     uint8_t n_legs = seen_L ? code_value_byte() : 0;
// 7249     if (n_legs > 15) {
// 7250       SERIAL_PROTOCOLLNPGM("?Number of legs in movement not plausible (0-15).");
// 7251       return;
// 7252     }
// 7253     if (n_legs == 1) n_legs = 2;
// 7254 
// 7255     bool schizoid_flag = code_seen('S');
// 7256     if (schizoid_flag && !seen_L) n_legs = 7;
// 7257 
// 7258     /**
// 7259      * Now get everything to the specified probe point So we can safely do a
// 7260      * probe to get us close to the bed.  If the Z-Axis is far from the bed,
// 7261      * we don't want to use that as a starting point for each probe.
// 7262      */
// 7263     if (verbose_level > 2)
// 7264       SERIAL_PROTOCOLLNPGM("Positioning the probe...");
// 7265 
// 7266     // Disable bed level correction in M48 because we want the raw data when we probe
// 7267 
// 7268 	/*--mks cfg--begin MESH_BED_LEVELING */
// 7269 /*	
// 7270     #if HAS_LEVELING
// 7271       const bool was_enabled =
// 7272         #if ENABLED(AUTO_BED_LEVELING_UBL)
// 7273           ubl.state.active
// 7274         #elif ENABLED(MESH_BED_LEVELING)
// 7275           mbl.active()
// 7276         #else
// 7277           planner.abl_enabled
// 7278         #endif
// 7279       ;
// 7280       set_bed_leveling_enabled(false);
// 7281     #endif
// 7282 */
// 7283 	bool was_enabled;
// 7284 	if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
// 7285 		was_enabled = ubl.state.active;
// 7286 	else if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
// 7287 		was_enabled = mbl.active();
// 7288 	else if(BED_LEVELING_METHOD != NULL_BED_LEVELING)
// 7289 		was_enabled = planner.abl_enabled;
// 7290 
// 7291 	if(BED_LEVELING_METHOD != NULL_BED_LEVELING)
// 7292 		set_bed_leveling_enabled(false);
// 7293 
// 7294 	/*--mks cfg--end MESH_BED_LEVELING */
// 7295 
// 7296     setup_for_endstop_or_probe_move();
// 7297 
// 7298     // Move to the first point, deploy, and probe
// 7299     probe_pt(X_probe_location, Y_probe_location, stow_probe_after_each, verbose_level);
// 7300 
// 7301 	/*--mks cfg-random*/
// 7302     //randomSeed(millis());
// 7303 	srand(millis());
// 7304 	
// 7305     double mean = 0.0, sigma = 0.0, min = 99999.9, max = -99999.9, sample_set[n_samples];
// 7306 
// 7307     for (uint8_t n = 0; n < n_samples; n++) {
// 7308       if (n_legs) {
// 7309         int dir = (random(0, 10) > 5.0) ? -1 : 1;  // clockwise or counter clockwise
// 7310         float angle = random(0.0, 360.0),
// 7311               radius = random(
// 7312                 #if ENABLED(DELTA)
// 7313                   DELTA_PROBEABLE_RADIUS / 8, DELTA_PROBEABLE_RADIUS / 3
// 7314                 #else
// 7315                   5, X_MAX_LENGTH / 8
// 7316                 #endif
// 7317               );
// 7318 
// 7319         if (verbose_level > 3) {
// 7320           SERIAL_ECHOPAIR("Starting radius: ", radius);
// 7321           SERIAL_ECHOPAIR("   angle: ", angle);
// 7322           SERIAL_ECHOPGM(" Direction: ");
// 7323           if (dir > 0) SERIAL_ECHOPGM("Counter-");
// 7324           SERIAL_ECHOLNPGM("Clockwise");
// 7325         }
// 7326 
// 7327         for (uint8_t l = 0; l < n_legs - 1; l++) {
// 7328           double delta_angle;
// 7329 
// 7330           if (schizoid_flag)
// 7331             // The points of a 5 point star are 72 degrees apart.  We need to
// 7332             // skip a point and go to the next one on the star.
// 7333             delta_angle = dir * 2.0 * 72.0;
// 7334 
// 7335           else
// 7336             // If we do this line, we are just trying to move further
// 7337             // around the circle.
// 7338             /*--mks cfg-random*/
// 7339             delta_angle = dir * (float) random(25, 45);
// 7340 		
// 7341           angle += delta_angle;
// 7342 
// 7343           while (angle > 360.0)   // We probably do not need to keep the angle between 0 and 2*PI, but the
// 7344             angle -= 360.0;       // Arduino documentation says the trig functions should not be given values
// 7345           while (angle < 0.0)     // outside of this range.   It looks like they behave correctly with
// 7346             angle += 360.0;       // numbers outside of the range, but just to be safe we clamp them.
// 7347 
// 7348           X_current = X_probe_location - (X_PROBE_OFFSET_FROM_EXTRUDER) + cos(RADIANS(angle)) * radius;
// 7349           Y_current = Y_probe_location - (Y_PROBE_OFFSET_FROM_EXTRUDER) + sin(RADIANS(angle)) * radius;
// 7350 
// 7351           #if DISABLED(DELTA)
// 7352             X_current = constrain(X_current, X_MIN_POS, X_MAX_POS);
// 7353             Y_current = constrain(Y_current, Y_MIN_POS, Y_MAX_POS);
// 7354           #else
// 7355             // If we have gone out too far, we can do a simple fix and scale the numbers
// 7356             // back in closer to the origin.
// 7357             while (HYPOT(X_current, Y_current) > DELTA_PROBEABLE_RADIUS) {
// 7358               X_current *= 0.8;
// 7359               Y_current *= 0.8;
// 7360               if (verbose_level > 3) {
// 7361                 SERIAL_ECHOPAIR("Pulling point towards center:", X_current);
// 7362                 SERIAL_ECHOLNPAIR(", ", Y_current);
// 7363               }
// 7364             }
// 7365           #endif
// 7366           if (verbose_level > 3) {
// 7367             SERIAL_PROTOCOLPGM("Going to:");
// 7368             SERIAL_ECHOPAIR(" X", X_current);
// 7369             SERIAL_ECHOPAIR(" Y", Y_current);
// 7370             SERIAL_ECHOLNPAIR(" Z", current_position[Z_AXIS]);
// 7371           }
// 7372           do_blocking_move_to_xy(X_current, Y_current);
// 7373         } // n_legs loop
// 7374       } // n_legs
// 7375 
// 7376       // Probe a single point
// 7377       sample_set[n] = probe_pt(X_probe_location, Y_probe_location, stow_probe_after_each, 0);
// 7378 
// 7379       /**
// 7380        * Get the current mean for the data points we have so far
// 7381        */
// 7382       double sum = 0.0;
// 7383       for (uint8_t j = 0; j <= n; j++) sum += sample_set[j];
// 7384       mean = sum / (n + 1);
// 7385 
// 7386       NOMORE(min, sample_set[n]);
// 7387       NOLESS(max, sample_set[n]);
// 7388 
// 7389       /**
// 7390        * Now, use that mean to calculate the standard deviation for the
// 7391        * data points we have so far
// 7392        */
// 7393       sum = 0.0;
// 7394       for (uint8_t j = 0; j <= n; j++)
// 7395         sum += sq(sample_set[j] - mean);
// 7396 
// 7397       sigma = sqrt(sum / (n + 1));
// 7398       if (verbose_level > 0) {
// 7399         if (verbose_level > 1) {
// 7400           SERIAL_PROTOCOL(n + 1);
// 7401           SERIAL_PROTOCOLPGM(" of ");
// 7402           SERIAL_PROTOCOL((int)n_samples);
// 7403           SERIAL_PROTOCOLPGM(": z: ");
// 7404           SERIAL_PROTOCOL_F(sample_set[n], 3);
// 7405           if (verbose_level > 2) {
// 7406             SERIAL_PROTOCOLPGM(" mean: ");
// 7407             SERIAL_PROTOCOL_F(mean, 4);
// 7408             SERIAL_PROTOCOLPGM(" sigma: ");
// 7409             SERIAL_PROTOCOL_F(sigma, 6);
// 7410             SERIAL_PROTOCOLPGM(" min: ");
// 7411             SERIAL_PROTOCOL_F(min, 3);
// 7412             SERIAL_PROTOCOLPGM(" max: ");
// 7413             SERIAL_PROTOCOL_F(max, 3);
// 7414             SERIAL_PROTOCOLPGM(" range: ");
// 7415             SERIAL_PROTOCOL_F(max-min, 3);
// 7416           }
// 7417           SERIAL_EOL;
// 7418         }
// 7419       }
// 7420 
// 7421     } // End of probe loop
// 7422 
// 7423     if (STOW_PROBE()) return;
// 7424 
// 7425     SERIAL_PROTOCOLPGM("Finished!");
// 7426     SERIAL_EOL;
// 7427 
// 7428     if (verbose_level > 0) {
// 7429       SERIAL_PROTOCOLPGM("Mean: ");
// 7430       SERIAL_PROTOCOL_F(mean, 6);
// 7431       SERIAL_PROTOCOLPGM(" Min: ");
// 7432       SERIAL_PROTOCOL_F(min, 3);
// 7433       SERIAL_PROTOCOLPGM(" Max: ");
// 7434       SERIAL_PROTOCOL_F(max, 3);
// 7435       SERIAL_PROTOCOLPGM(" Range: ");
// 7436       SERIAL_PROTOCOL_F(max-min, 3);
// 7437       SERIAL_EOL;
// 7438     }
// 7439 
// 7440     SERIAL_PROTOCOLPGM("Standard Deviation: ");
// 7441     SERIAL_PROTOCOL_F(sigma, 6);
// 7442     SERIAL_EOL;
// 7443     SERIAL_EOL;
// 7444 
// 7445     clean_up_after_endstop_or_probe_move();
// 7446 
// 7447     // Re-enable bed level correction if it had been on
// 7448     //#if HAS_LEVELING
// 7449 	if(BED_LEVELING_METHOD&HAS_LEVELING)
// 7450       set_bed_leveling_enabled(was_enabled);
// 7451     //#endif
// 7452 
// 7453     report_current_position();
// 7454   }
// 7455 
// 7456 #endif // Z_MIN_PROBE_REPEATABILITY_TEST
// 7457 
// 7458 //#if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(UBL_G26_MESH_EDITING)
// 7459 #if 1
// 7460   inline void gcode_M49() {
// 7461   if(BED_LEVELING_METHOD != AUTO_BED_LEVELING_UBL) 
// 7462   	return;
// 7463   
// 7464     ubl.g26_debug_flag ^= true;
// 7465     SERIAL_PROTOCOLPGM("UBL Debug Flag turned ");
// 7466     serialprintPGM(ubl.g26_debug_flag ? PSTR("on.") : PSTR("off."));
// 7467   }
// 7468 
// 7469 #endif // AUTO_BED_LEVELING_UBL && UBL_G26_MESH_EDITING
// 7470 
// 7471 /**
// 7472  * M75: Start print timer
// 7473  */
// 7474 inline void gcode_M75() { print_job_timer.start(); }
// 7475 
// 7476 /**
// 7477  * M76: Pause print timer
// 7478  */
// 7479 inline void gcode_M76() { print_job_timer.pause(); }
// 7480 
// 7481 /**
// 7482  * M77: Stop print timer
// 7483  */
// 7484 inline void gcode_M77() { print_job_timer.stop(); }
// 7485 
// 7486 #if ENABLED(PRINTCOUNTER)
// 7487   /**
// 7488    * M78: Show print statistics
// 7489    */
// 7490   inline void gcode_M78() {
// 7491     // "M78 S78" will reset the statistics
// 7492     if (code_seen('S') && code_value_int() == 78)
// 7493       print_job_timer.initStats();
// 7494     else
// 7495       print_job_timer.showStats();
// 7496   }
// 7497 #endif
// 7498 
// 7499 /**
// 7500  * M104: Set hot end temperature
// 7501  */
// 7502 inline void gcode_M104() {
// 7503   if (get_target_extruder_from_command(104)) return;
// 7504   if (DEBUGGING(DRYRUN)) return;
// 7505 
// 7506   #if ENABLED(SINGLENOZZLE)
// 7507     if (target_extruder != active_extruder) return;
// 7508   #endif
// 7509 
// 7510   if (code_seen('S')) {
// 7511     const int16_t temp = code_value_temp_abs();
// 7512     thermalManager.setTargetHotend(temp, target_extruder);
// 7513     #if ENABLED(DUAL_X_CARRIAGE)
// 7514       if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && target_extruder == 0)
// 7515         thermalManager.setTargetHotend(temp ? temp + duplicate_extruder_temp_offset : 0, 1);
// 7516     #endif
// 7517 
// 7518     #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
// 7519       /**
// 7520        * Stop the timer at the end of print. Start is managed by 'heat and wait' M109.
// 7521        * We use half EXTRUDE_MINTEMP here to allow nozzles to be put into hot
// 7522        * standby mode, for instance in a dual extruder setup, without affecting
// 7523        * the running print timer.
// 7524        */
// 7525       if (code_value_temp_abs() <= (EXTRUDE_MINTEMP) / 2) {
// 7526         print_job_timer.stop();
// 7527         LCD_MESSAGEPGM(WELCOME_MSG);
// 7528       }
// 7529     #endif
// 7530 
// 7531 //    if (code_value_temp_abs() > thermalManager.degHotend(target_extruder)) lcd_status_printf_P(0, PSTR("E%i %s"), target_extruder + 1, MSG_HEATING);
// 7532 //	if (code_value_temp_abs() > thermalManager.degHotend(target_extruder)) LCD_MESSAGEPGM("E1 Heating..."); 	  //mks
// 7533 
// 7534 	if (code_value_temp_abs() > thermalManager.degHotend(target_extruder))
// 7535 		{
// 7536 		switch(target_extruder)
// 7537 			{
// 7538 			case 0:
// 7539 				if(mksCfg.lcd_language == 1) LCD_MESSAGEPGM("E1 \x80\xc4\x9b...");
// 7540 				else LCD_MESSAGEPGM("E1 Heating...");
// 7541 				break;
// 7542 			case 1:
// 7543 				LCD_MESSAGEPGM("E2 Heating...");
// 7544 				break;
// 7545 			case 2:
// 7546 				LCD_MESSAGEPGM("E3 Heating...");
// 7547 				break;
// 7548 			case 3:
// 7549 				LCD_MESSAGEPGM("E4 Heating...");
// 7550 				break;
// 7551 			case 4:
// 7552 				LCD_MESSAGEPGM("E5 Heating...");
// 7553 				break;
// 7554 			default: break;
// 7555 				
// 7556 			}
// 7557 		}
// 7558 
// 7559   }
// 7560 
// 7561   #if ENABLED(AUTOTEMP)
// 7562     planner.autotemp_M104_M109();
// 7563   #endif
// 7564 }
// 7565 
// 7566 //#if HAS_TEMP_HOTEND || HAS_TEMP_BED	/*--mks cfg-- HAS_TEMP_BED --*/
// 7567 #if 1

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock63 Using cfiCommon0
          CFI Function _Z18print_heaterstatesv
        THUMB
// 7568   void print_heaterstates() {
_Z18print_heaterstatesv:
        PUSH     {R2-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+32
// 7569     #if HAS_TEMP_HOTEND
// 7570       SERIAL_PROTOCOLPGM(" T:");
        ADR.N    R0,??DataTable132  ;; " T:"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 7571       SERIAL_PROTOCOL(thermalManager.degHotend(target_extruder));
        LDR.W    R4,??DataTable136_2
        LDRB     R0,[R4, #+5]
        LDR.W    R5,??DataTable136_6
        LDR.W    R6,??DataTable136_17
        LDRB     R1,[R4, #+7]
        CMP      R1,#+0
        BNE.N    ??print_heaterstates_0
          CFI FunCall _ZN11Temperature9degHotendEh
        BL       _ZN11Temperature9degHotendEh
        MOVS     R1,#+2
        STR      R1,[SP, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R6
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
        B.N      ??print_heaterstates_1
??print_heaterstates_0:
          CFI FunCall _ZN11Temperature9degHotendEh
        BL       _ZN11Temperature9degHotendEh
        MOVS     R1,#+2
        STR      R1,[SP, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R5
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
// 7572       SERIAL_PROTOCOLPGM(" /");
??print_heaterstates_1:
        ADR.W    R8,??DataTable133_1  ;; 0x20, 0x2F, 0x00, 0x00
        MOV      R0,R8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 7573       SERIAL_PROTOCOL(thermalManager.degTargetHotend(target_extruder));
        LDRB     R0,[R4, #+5]
        LDRB     R1,[R4, #+7]
        CMP      R1,#+0
        BNE.N    ??print_heaterstates_2
          CFI FunCall _ZN11Temperature15degTargetHotendEh
        BL       _ZN11Temperature15degTargetHotendEh
        MOVS     R1,#+2
        STR      R1,[SP, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R6
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
        B.N      ??print_heaterstates_3
??print_heaterstates_2:
          CFI FunCall _ZN11Temperature15degTargetHotendEh
        BL       _ZN11Temperature15degTargetHotendEh
        MOVS     R1,#+2
        STR      R1,[SP, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R5
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
// 7574       #if ENABLED(SHOW_TEMP_ADC_VALUES)
// 7575         SERIAL_PROTOCOLPAIR(" (", thermalManager.rawHotendTemp(target_extruder) / OVERSAMPLENR);
// 7576         SERIAL_PROTOCOLCHAR(')');
// 7577       #endif
// 7578        // SERIAL_PROTOCOLLNPGM(".");       //mks add
// 7579     #endif
// 7580 /*--mks cfg begin-- HAS_TEMP_BED */	
// 7581 /*    #if HAS_TEMP_BED
// 7582       SERIAL_PROTOCOLPGM(" B:");
// 7583       SERIAL_PROTOCOL(thermalManager.degBed());
// 7584       SERIAL_PROTOCOLPGM(" /");
// 7585       SERIAL_PROTOCOL(thermalManager.degTargetBed());
// 7586       #if ENABLED(SHOW_TEMP_ADC_VALUES)
// 7587         SERIAL_PROTOCOLPAIR(" (", thermalManager.rawBedTemp() / OVERSAMPLENR);
// 7588         SERIAL_PROTOCOLCHAR(')');
// 7589       #endif
// 7590     #endif
// 7591 */	
// 7592 	if(HAS_TEMP_BED)
??print_heaterstates_3:
        LDR.W    R7,??DataTable136_8
        LDRB     R0,[R7, #+54]
        CMP      R0,#+0
        BEQ.N    ??print_heaterstates_4
// 7593 		{
// 7594 		SERIAL_PROTOCOLPGM(" B:");
        ADR.N    R0,??DataTable133_2  ;; " B:"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 7595 		SERIAL_PROTOCOL(thermalManager.degBed());
        LDRB     R0,[R4, #+7]
        CMP      R0,#+0
        BNE.N    ??print_heaterstates_5
          CFI FunCall _ZN11Temperature6degBedEv
        BL       _ZN11Temperature6degBedEv
        MOVS     R1,#+2
        STR      R1,[SP, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R6
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
        B.N      ??print_heaterstates_6
??print_heaterstates_5:
          CFI FunCall _ZN11Temperature6degBedEv
        BL       _ZN11Temperature6degBedEv
        MOVS     R1,#+2
        STR      R1,[SP, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R5
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
// 7596 		SERIAL_PROTOCOLPGM(" /");
??print_heaterstates_6:
        MOV      R0,R8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 7597 		SERIAL_PROTOCOL(thermalManager.degTargetBed());
        LDRB     R0,[R4, #+7]
        CMP      R0,#+0
        BNE.N    ??print_heaterstates_7
          CFI FunCall _ZN11Temperature12degTargetBedEv
        BL       _ZN11Temperature12degTargetBedEv
        MOVS     R1,#+2
        STR      R1,[SP, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R6
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
        B.N      ??print_heaterstates_4
??print_heaterstates_7:
          CFI FunCall _ZN11Temperature12degTargetBedEv
        BL       _ZN11Temperature12degTargetBedEv
        MOVS     R1,#+2
        STR      R1,[SP, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R5
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
// 7598 		#if ENABLED(SHOW_TEMP_ADC_VALUES)
// 7599 		  SERIAL_PROTOCOLPAIR(" (", thermalManager.rawBedTemp() / OVERSAMPLENR);
// 7600 		  SERIAL_PROTOCOLCHAR(')');
// 7601 		#endif
// 7602 		}
// 7603 /*--mks cfg end-- HAS_TEMP_BED */
// 7604     #if HOTENDS > 1
// 7605       HOTEND_LOOP() {
// 7606         SERIAL_PROTOCOLPAIR(" T", e);
// 7607         SERIAL_PROTOCOLCHAR(':');
// 7608         SERIAL_PROTOCOL(thermalManager.degHotend(e));
// 7609         SERIAL_PROTOCOLPGM(" /");
// 7610         SERIAL_PROTOCOL(thermalManager.degTargetHotend(e));
// 7611         #if ENABLED(SHOW_TEMP_ADC_VALUES)
// 7612           SERIAL_PROTOCOLPAIR(" (", thermalManager.rawHotendTemp(e) / OVERSAMPLENR);
// 7613           SERIAL_PROTOCOLCHAR(')');
// 7614         #endif
// 7615       }
// 7616     #endif
// 7617     SERIAL_PROTOCOLPGM(" @:");
??print_heaterstates_4:
        ADR.N    R0,??DataTable134  ;; " @:"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 7618     SERIAL_PROTOCOL(thermalManager.getHeaterPower(target_extruder));
        LDRB     R0,[R4, #+5]
        LDRB     R1,[R4, #+7]
        CMP      R1,#+0
        BNE.N    ??print_heaterstates_8
          CFI FunCall _ZN11Temperature14getHeaterPowerEi
        BL       _ZN11Temperature14getHeaterPowerEi
        MOV      R1,R0
        MOVS     R2,#+10
        MOV      R0,R6
          CFI FunCall _ZN12MarlinSerial5printEii
        BL       _ZN12MarlinSerial5printEii
        B.N      ??print_heaterstates_9
??print_heaterstates_8:
          CFI FunCall _ZN11Temperature14getHeaterPowerEi
        BL       _ZN11Temperature14getHeaterPowerEi
        MOVS     R2,#+10
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall _ZN12MarlinSerial5printEii
        BL       _ZN12MarlinSerial5printEii
// 7619 	
// 7620    // #if HAS_TEMP_BED	/*--mks cfg-- HAS_TEMP_BED --*/
// 7621 	if(HAS_TEMP_BED) {
??print_heaterstates_9:
        LDRB     R0,[R7, #+54]
        CMP      R0,#+0
        BEQ.N    ??print_heaterstates_10
// 7622    	  SERIAL_PROTOCOLPGM(" B@:");
        ADR.W    R0,?_28
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 7623       SERIAL_PROTOCOL(thermalManager.getHeaterPower(-1));
        LDRB     R0,[R4, #+7]
        CMP      R0,#+0
        MOV      R0,#-1
        BNE.N    ??print_heaterstates_11
          CFI FunCall _ZN11Temperature14getHeaterPowerEi
        BL       _ZN11Temperature14getHeaterPowerEi
        MOVS     R2,#+10
        MOV      R1,R0
        MOV      R0,R6
        ADD      SP,SP,#+8
          CFI CFA R13+24
        POP      {R4-R8,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN12MarlinSerial5printEii
        B.W      _ZN12MarlinSerial5printEii
          CFI R4 Frame(CFA, -24)
          CFI R5 Frame(CFA, -20)
          CFI R6 Frame(CFA, -16)
          CFI R7 Frame(CFA, -12)
          CFI R8 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
??print_heaterstates_11:
          CFI FunCall _ZN11Temperature14getHeaterPowerEi
        BL       _ZN11Temperature14getHeaterPowerEi
        MOVS     R2,#+10
        MOV      R1,R0
        MOV      R0,R5
        ADD      SP,SP,#+8
          CFI CFA R13+24
        POP      {R4-R8,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN12MarlinSerial5printEii
        B.W      _ZN12MarlinSerial5printEii
          CFI R4 Frame(CFA, -24)
          CFI R5 Frame(CFA, -20)
          CFI R6 Frame(CFA, -16)
          CFI R7 Frame(CFA, -12)
          CFI R8 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
// 7624       //SERIAL_PROTOCOLLNPGM(".");       //mks add
// 7625     }//#endif
// 7626 	
// 7627     #if HOTENDS > 1
// 7628       HOTEND_LOOP() {
// 7629         SERIAL_PROTOCOLPAIR(" @", e);
// 7630         SERIAL_PROTOCOLCHAR(':');
// 7631         SERIAL_PROTOCOL(thermalManager.getHeaterPower(e));
// 7632       }
// 7633     #endif
// 7634   }
??print_heaterstates_10:
        POP      {R0,R1,R4-R8,PC}  ;; return
          CFI EndBlock cfiBlock63

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable131:
        DC32     0x40400000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable131_1:
        DC32     mksCfg+0x60

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_28:
        DC8 " B@:"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZNK10duration_t8toStringEPcEs
        DATA
// __absolute char const <_ZZNK10duration_t8toStringEPcEs>[20]
_ZZNK10duration_t8toStringEPcEs:
        DC8 "%iy %id %ih %im %is"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZNK10duration_t8toStringEPcEs_0
        DATA
// __absolute char const <_ZZNK10duration_t8toStringEPcEs_0>[16]
_ZZNK10duration_t8toStringEPcEs_0:
        DC8 "%id %ih %im %is"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZNK10duration_t8toStringEPcEs_1
        DATA
// __absolute char const <_ZZNK10duration_t8toStringEPcEs_1>[12]
_ZZNK10duration_t8toStringEPcEs_1:
        DC8 "%ih %im %is"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZNK10duration_t8toStringEPcEs_2
        DATA
// __absolute char const <_ZZNK10duration_t8toStringEPcEs_2>[8]
_ZZNK10duration_t8toStringEPcEs_2:
        DC8 "%im %is"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZNK10duration_t8toStringEPcEs_3
        DATA
// __absolute char const <_ZZNK10duration_t8toStringEPcEs_3>[4]
_ZZNK10duration_t8toStringEPcEs_3:
        DC8 "%is"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZTV6Buzzer
        DATA
// __absolute void (*const Buzzer::__vtbl[3])()
_ZTV6Buzzer:
        DC32 0H, _ZTI6Buzzer, _ZN6Buzzer4tickEv

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZTI6Buzzer
        DATA
// __absolute __class_type_info const <Typeinfo for Buzzer>
_ZTI6Buzzer:
        DC32 _ZTVN10__cxxabiv117__class_type_infoE + 8H, _ZTS6Buzzer

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs
        DATA
// __absolute char const <_ZZ19get_serial_commandsvEs>[5]
_ZZ19get_serial_commandsvEs:
        DC8 "M110"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_0
        DATA
// __absolute char const <_ZZ19get_serial_commandsvEs_0>[51]
_ZZ19get_serial_commandsvEs_0:
        DC8 4CH, 69H, 6EH, 65H, 20H, 4EH, 75H, 6DH
        DC8 62H, 65H, 72H, 20H, 69H, 73H, 20H, 6EH
        DC8 6FH, 74H, 20H, 4CH, 61H, 73H, 74H, 20H
        DC8 4CH, 69H, 6EH, 65H, 20H, 4EH, 75H, 6DH
        DC8 62H, 65H, 72H, 2BH, 31H, 2CH, 20H, 4CH
        DC8 61H, 73H, 74H, 20H, 4CH, 69H, 6EH, 65H
        DC8 3AH, 20H, 0
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_1
        DATA
// __absolute char const <_ZZ19get_serial_commandsvEs_1>[31]
_ZZ19get_serial_commandsvEs_1:
        DC8 "checksum mismatch, Last Line: "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_2
        DATA
// __absolute char const <_ZZ19get_serial_commandsvEs_2>[42]
_ZZ19get_serial_commandsvEs_2:
        DC8 "No Checksum with line number, Last Line: "
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_3
        DATA
// __absolute char const <_ZZ19get_serial_commandsvEs_3>[42]
_ZZ19get_serial_commandsvEs_3:
        DC8 "No Line Number with checksum, Last Line: "
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_4
        DATA
// __absolute char const <_ZZ19get_serial_commandsvEs_4>[119]
_ZZ19get_serial_commandsvEs_4:
        DC8 50H, 72H, 69H, 6EH, 74H, 65H, 72H, 20H
        DC8 73H, 74H, 6FH, 70H, 70H, 65H, 64H, 20H
        DC8 64H, 75H, 65H, 20H, 74H, 6FH, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 73H, 2EH, 20H, 46H
        DC8 69H, 78H, 20H, 74H, 68H, 65H, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 20H, 61H, 6EH, 64H
        DC8 20H, 75H, 73H, 65H, 20H, 4DH, 39H, 39H
        DC8 39H, 20H, 74H, 6FH, 20H, 72H, 65H, 73H
        DC8 74H, 61H, 72H, 74H, 2EH, 20H, 28H, 54H
        DC8 65H, 6DH, 70H, 65H, 72H, 61H, 74H, 75H
        DC8 72H, 65H, 20H, 69H, 73H, 20H, 72H, 65H
        DC8 73H, 65H, 74H, 2EH, 20H, 53H, 65H, 74H
        DC8 20H, 69H, 74H, 20H, 61H, 66H, 74H, 65H
        DC8 72H, 20H, 72H, 65H, 73H, 74H, 61H, 72H
        DC8 74H, 69H, 6EH, 67H, 29H, 0AH, 0
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_5
        DATA
// __absolute char const <_ZZ19get_serial_commandsvEs_5>[10]
_ZZ19get_serial_commandsvEs_5:
        DC8 "STOPPED. "
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_6
        DATA
// __absolute char const <_ZZ19get_serial_commandsvEs_6>[5]
_ZZ19get_serial_commandsvEs_6:
        DC8 "M108"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_7
        DATA
// __absolute char const <_ZZ19get_serial_commandsvEs_7>[5]
_ZZ19get_serial_commandsvEs_7:
        DC8 "M112"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_8
        DATA
// __absolute char const <_ZZ19get_serial_commandsvEs_8>[9]
_ZZ19get_serial_commandsvEs_8:
        DC8 "KILLED. "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_9
        DATA
// __absolute char const <_ZZ19get_serial_commandsvEs_9>[5]
_ZZ19get_serial_commandsvEs_9:
        DC8 "M410"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_sdcard_commandsvEs
        DATA
// __absolute char const <_ZZ19get_sdcard_commandsvEs>[20]
_ZZ19get_sdcard_commandsvEs:
        DC8 "Done printing file\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_sdcard_commandsvEs_0
        DATA
// __absolute char const <_ZZ19get_sdcard_commandsvEs_0>[15]
_ZZ19get_sdcard_commandsvEs_0:
        DC8 "SD read error\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ17get_wifi_commandsvEs
        DATA
// __absolute char const <_ZZ17get_wifi_commandsvEs>[119]
_ZZ17get_wifi_commandsvEs:
        DC8 50H, 72H, 69H, 6EH, 74H, 65H, 72H, 20H
        DC8 73H, 74H, 6FH, 70H, 70H, 65H, 64H, 20H
        DC8 64H, 75H, 65H, 20H, 74H, 6FH, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 73H, 2EH, 20H, 46H
        DC8 69H, 78H, 20H, 74H, 68H, 65H, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 20H, 61H, 6EH, 64H
        DC8 20H, 75H, 73H, 65H, 20H, 4DH, 39H, 39H
        DC8 39H, 20H, 74H, 6FH, 20H, 72H, 65H, 73H
        DC8 74H, 61H, 72H, 74H, 2EH, 20H, 28H, 54H
        DC8 65H, 6DH, 70H, 65H, 72H, 61H, 74H, 75H
        DC8 72H, 65H, 20H, 69H, 73H, 20H, 72H, 65H
        DC8 73H, 65H, 74H, 2EH, 20H, 53H, 65H, 74H
        DC8 20H, 69H, 74H, 20H, 61H, 66H, 74H, 65H
        DC8 72H, 20H, 72H, 65H, 73H, 74H, 61H, 72H
        DC8 74H, 69H, 6EH, 67H, 29H, 0AH, 0
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ17get_wifi_commandsvEs_0
        DATA
// __absolute char const <_ZZ17get_wifi_commandsvEs_0>[10]
_ZZ17get_wifi_commandsvEs_0:
        DC8 "STOPPED. "
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ17get_wifi_commandsvEs_1
        DATA
// __absolute char const <_ZZ17get_wifi_commandsvEs_1>[5]
_ZZ17get_wifi_commandsvEs_1:
        DC8 "M108"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ17get_wifi_commandsvEs_2
        DATA
// __absolute char const <_ZZ17get_wifi_commandsvEs_2>[5]
_ZZ17get_wifi_commandsvEs_2:
        DC8 "M112"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ17get_wifi_commandsvEs_3
        DATA
// __absolute char const <_ZZ17get_wifi_commandsvEs_3>[9]
_ZZ17get_wifi_commandsvEs_3:
        DC8 "KILLED. "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ17get_wifi_commandsvEs_4
        DATA
// __absolute char const <_ZZ17get_wifi_commandsvEs_4>[5]
_ZZ17get_wifi_commandsvEs_4:
        DC8 "M410"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ24get_homing_bump_feedrate8AxisEnumEs
        DATA
// __absolute char const <_ZZ24get_homing_bump_feedrate8AxisEnumEs>[34]
_ZZ24get_homing_bump_feedrate8AxisEnumEs:
        DC8 "Warning: Homing Bump Divisor < 1\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ11gcode_G2_G3bEs
        DATA
// __absolute char const <_ZZ11gcode_G2_G3bEs>[22]
_ZZ11gcode_G2_G3bEs:
        DC8 "G2/G3 bad parameters\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ8gcode_G4vEs
        DATA
// __absolute char const <_ZZ8gcode_G4vEs>[9]
_ZZ8gcode_G4vEs:
        DC8 "Sleep..."
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs
        DATA
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs>[23]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs:
        DC8 "S out of range (0-5).\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_0
        DATA
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_0>[8]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_0:
        DC8 "State: "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_1
        DATA
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_1>[32]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_1:
        DC8 "Mesh bed leveling has no data.\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_2
        DATA
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_2>[11]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_2:
        DC8 "G28\012G29 S2"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_3
        DATA
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_3>[41]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_3:
        DC8 "Start mesh probing with \"G29 S1\" first.\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_4
        DATA
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_4>[20]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_4:
        DC8 "Mesh probing done.\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_5
        DATA
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_5>[46]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_5:
        DC8 "X out of range (1-mksCfg.grid_max_points_x).\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_6
        DATA
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_6>[46]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_6:
        DC8 "Y out of range (1-mksCfg.grid_max_points_y).\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs
        DATA
// __absolute char const <_ZZ9gcode_G29vEs>[23]
_ZZ9gcode_G29vEs:
        DC8 "malloc eqnAMatrix err!"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_0
        DATA
// __absolute char const <_ZZ9gcode_G29vEs_0>[23]
_ZZ9gcode_G29vEs_0:
        DC8 "malloc eqnBVector err!"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_1
        DATA
// __absolute char const <_ZZ9gcode_G29vEs_1>[18]
_ZZ9gcode_G29vEs_1:
        DC8 "No bilinear grid\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_2
        DATA
// __absolute char const <_ZZ9gcode_G29vEs_2>[13]
_ZZ9gcode_G29vEs_2:
        DC8 "Bad Z value\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_3
        DATA
// __absolute char const <_ZZ9gcode_G29vEs_3>[40]
_ZZ9gcode_G29vEs_3:
        DC8 "?(V)erbose level is implausible (0-4).\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_4
        DATA
// __absolute char const <_ZZ9gcode_G29vEs_4>[53]
_ZZ9gcode_G29vEs_4:
        DC8 3FH, 4EH, 75H, 6DH, 62H, 65H, 72H, 20H
        DC8 6FH, 66H, 20H, 70H, 72H, 6FH, 62H, 65H
        DC8 20H, 70H, 6FH, 69H, 6EH, 74H, 73H, 20H
        DC8 69H, 73H, 20H, 69H, 6DH, 70H, 6CH, 61H
        DC8 75H, 73H, 69H, 62H, 6CH, 65H, 20H, 28H
        DC8 32H, 20H, 6DH, 69H, 6EH, 69H, 6DH, 75H
        DC8 6DH, 29H, 2EH, 0AH, 0
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_5
        DATA
// __absolute char const <_ZZ9gcode_G29vEs_5>[7]
_ZZ9gcode_G29vEs_5:
        DC8 "(L)eft"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_6
        DATA
// __absolute char const <_ZZ9gcode_G29vEs_6>[8]
_ZZ9gcode_G29vEs_6:
        DC8 "(R)ight"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_7
        DATA
// __absolute char const <_ZZ9gcode_G29vEs_7>[8]
_ZZ9gcode_G29vEs_7:
        DC8 "(F)ront"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_8
        DATA
// __absolute char const <_ZZ9gcode_G29vEs_8>[7]
_ZZ9gcode_G29vEs_8:
        DC8 "(B)ack"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_9
        DATA
// __absolute char const <_ZZ9gcode_G29vEs_9>[23]
_ZZ9gcode_G29vEs_9:
        DC8 "G29 Auto Bed Leveling\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs__10_
        DATA
// __absolute char const <_ZZ9gcode_G29vEs__10_>[25]
_ZZ9gcode_G29vEs__10_:
        DC8 "Running in DRY-RUN mode\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs__11_
        DATA
// __absolute char const <_ZZ9gcode_G29vEs__11_>[22]
_ZZ9gcode_G29vEs__11_:
        DC8 "Eqn coefficients: a: "
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs__12_
        DATA
// __absolute char const <_ZZ9gcode_G29vEs__12_>[5]
_ZZ9gcode_G29vEs__12_:
        DC8 " b: "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs__13_
        DATA
// __absolute char const <_ZZ9gcode_G29vEs__13_>[5]
_ZZ9gcode_G29vEs__13_:
        DC8 " d: "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs__14_
        DATA
// __absolute char const <_ZZ9gcode_G29vEs__14_>[25]
_ZZ9gcode_G29vEs__14_:
        DC8 "Mean of sampled points: "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs__15_
        DATA
// __absolute char const <_ZZ9gcode_G29vEs__15_>[165]
_ZZ9gcode_G29vEs__15_:
        DC8 0AH, 42H, 65H, 64H, 20H, 48H, 65H, 69H
        DC8 67H, 68H, 74H, 20H, 54H, 6FH, 70H, 6FH
        DC8 67H, 72H, 61H, 70H, 68H, 79H, 3AH, 0AH
        DC8 20H, 20H, 20H, 2BH, 2DH, 2DH, 2DH, 20H
        DC8 42H, 41H, 43H, 4BH, 20H, 2DH, 2DH, 2BH
        DC8 0AH, 20H, 20H, 20H, 7CH, 9, 9, 20H
        DC8 20H, 20H, 7CH, 0AH, 20H, 4CH, 20H, 7CH
        DC8 9, 28H, 2BH, 29H, 20H, 20H, 20H, 20H
        DC8 7CH, 20H, 52H, 0AH, 20H, 45H, 20H, 7CH
        DC8 9, 9, 20H, 20H, 20H, 7CH, 20H, 49H
        DC8 0AH, 20H, 46H, 20H, 7CH, 20H, 28H, 2DH
        DC8 29H, 20H, 4EH, 20H, 28H, 2BH, 29H, 20H
        DC8 7CH, 20H, 47H, 0AH, 20H, 54H, 20H, 7CH
        DC8 9, 9, 20H, 20H, 20H, 7CH, 20H, 48H
        DC8 0AH, 20H, 20H, 20H, 7CH, 9, 28H, 2DH
        DC8 29H, 20H, 20H, 20H, 20H, 7CH, 20H, 54H
        DC8 0AH, 20H, 20H, 20H, 7CH, 9, 9, 20H
        DC8 20H, 20H, 7CH, 0AH, 20H, 20H, 20H, 4FH
        DC8 2DH, 2DH, 20H, 46H, 52H, 4FH, 4EH, 54H
        DC8 20H, 2DH, 2DH, 2BH, 0AH, 20H, 28H, 30H
        DC8 2CH, 30H, 29H, 0AH, 0
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs__16_
        DATA
// __absolute char const <_ZZ9gcode_G29vEs__16_>[3]
_ZZ9gcode_G29vEs__16_:
        DC8 " +"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs__17_
        DATA
// __absolute char const <_ZZ9gcode_G29vEs__17_>[41]
_ZZ9gcode_G29vEs__17_:
        DC8 "\012Corrected Bed Height vs. Bed Topology:\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs__18_
        DATA
// __absolute char const <_ZZ9gcode_G29vEs__18_>[31]
_ZZ9gcode_G29vEs__18_:
        DC8 "\012\012Bed Level Correction Matrix:"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G30vEs
        DATA
// __absolute char const <_ZZ9gcode_G30vEs>[8]
_ZZ9gcode_G30vEs:
        DC8 "Bed X: "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G30vEs_0
        DATA
// __absolute char const <_ZZ9gcode_G30vEs_0>[5]
_ZZ9gcode_G30vEs_0:
        DC8 " Y: "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G30vEs_1
        DATA
// __absolute char const <_ZZ9gcode_G30vEs_1>[5]
_ZZ9gcode_G30vEs_1:
        DC8 " Z: "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ11gcode_M0_M1vEs
        DATA
// __absolute char const <_ZZ11gcode_M0_M1vEs>[15]
_ZZ11gcode_M0_M1vEs:
        DC8 "Resuming print"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M17vEs
        DATA
// __absolute char const <_ZZ9gcode_M17vEs>[9]
_ZZ9gcode_M17vEs:
        DC8 "No move."
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M20vEs
        DATA
// __absolute char const <_ZZ9gcode_M20vEs>[17]
_ZZ9gcode_M20vEs:
        DC8 "Begin file list\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M20vEs_0
        DATA
// __absolute char const <_ZZ9gcode_M20vEs_0>[15]
_ZZ9gcode_M20vEs_0:
        DC8 "End file list\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M23vEs
        DATA
// __absolute char const <_ZZ9gcode_M23vEs>[3]
_ZZ9gcode_M23vEs:
        DC8 ".g"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M23vEs_0
        DATA
// __absolute char const <_ZZ9gcode_M23vEs_0>[3]
_ZZ9gcode_M23vEs_0:
        DC8 ".G"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M31vEs
        DATA
// __absolute char const <_ZZ9gcode_M31vEs>[13]
_ZZ9gcode_M31vEs:
        DC8 "Print time: "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M42vEs
        DATA
// __absolute char const <_ZZ9gcode_M42vEs>[15]
_ZZ9gcode_M42vEs:
        DC8 "Protected Pin\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M49vEs
        DATA
// __absolute char const <_ZZ9gcode_M49vEs>[23]
_ZZ9gcode_M49vEs:
        DC8 "UBL Debug Flag turned "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M49vEs_0
        DATA
// __absolute char const <_ZZ9gcode_M49vEs_0>[4]
_ZZ9gcode_M49vEs_0:
        DC8 "on."

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M49vEs_1
        DATA
// __absolute char const <_ZZ9gcode_M49vEs_1>[5]
_ZZ9gcode_M49vEs_1:
        DC8 "off."
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M104vEs
        DATA
// __absolute char const <_ZZ10gcode_M104vEs>[10]
_ZZ10gcode_M104vEs:
        DC8 "E1 \200\304\233..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M104vEs_0
        DATA
// __absolute char const <_ZZ10gcode_M104vEs_0>[14]
_ZZ10gcode_M104vEs_0:
        DC8 "E1 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M104vEs_1
        DATA
// __absolute char const <_ZZ10gcode_M104vEs_1>[14]
_ZZ10gcode_M104vEs_1:
        DC8 "E2 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M104vEs_2
        DATA
// __absolute char const <_ZZ10gcode_M104vEs_2>[14]
_ZZ10gcode_M104vEs_2:
        DC8 "E3 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M104vEs_3
        DATA
// __absolute char const <_ZZ10gcode_M104vEs_3>[14]
_ZZ10gcode_M104vEs_3:
        DC8 "E4 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M104vEs_4
        DATA
// __absolute char const <_ZZ10gcode_M104vEs_4>[14]
_ZZ10gcode_M104vEs_4:
        DC8 "E5 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M105vEs
        DATA
// __absolute char const <_ZZ10gcode_M105vEs>[3]
_ZZ10gcode_M105vEs:
        DC8 "ok"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M112vEs
        DATA
// __absolute char const <_ZZ10gcode_M112vEs>[9]
_ZZ10gcode_M112vEs:
        DC8 "KILLED. "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs
        DATA
// __absolute char const <_ZZ10gcode_M109vEs>[14]
_ZZ10gcode_M109vEs:
        DC8 "E2 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs_0
        DATA
// __absolute char const <_ZZ10gcode_M109vEs_0>[14]
_ZZ10gcode_M109vEs_0:
        DC8 "E3 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs_1
        DATA
// __absolute char const <_ZZ10gcode_M109vEs_1>[14]
_ZZ10gcode_M109vEs_1:
        DC8 "E4 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs_2
        DATA
// __absolute char const <_ZZ10gcode_M109vEs_2>[14]
_ZZ10gcode_M109vEs_2:
        DC8 "E5 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs_3
        DATA
// __absolute char const <_ZZ10gcode_M109vEs_3>[4]
_ZZ10gcode_M109vEs_3:
        DC8 " W:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs_4
        DATA
// __absolute char const <_ZZ10gcode_M109vEs_4>[3]
_ZZ10gcode_M109vEs_4:
        DC8 "?\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M190vEs
        DATA
// __absolute char const <_ZZ10gcode_M190vEs>[4]
_ZZ10gcode_M190vEs:
        DC8 " W:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M190vEs_0
        DATA
// __absolute char const <_ZZ10gcode_M190vEs_0>[3]
_ZZ10gcode_M190vEs_0:
        DC8 "?\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vEs_4
        DATA
// __absolute char const <_ZZ10gcode_M111vEs_4>[7]
_ZZ10gcode_M111vEs_4:
        DC8 "DEBUG:"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vEs_5
        DATA
// __absolute char const <_ZZ10gcode_M111vEs_5>[4]
_ZZ10gcode_M111vEs_5:
        DC8 "off"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M113vEs
        DATA
// __absolute char const <_ZZ10gcode_M113vEs>[7]
_ZZ10gcode_M113vEs:
        DC8 "M113 S"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M145vEs
        DATA
// __absolute char const <_ZZ10gcode_M145vEs>[34]
_ZZ10gcode_M145vEs:
        DC8 "M145 S<index> out of range (0-1)\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M81vEs
        DATA
// __absolute char const <_ZZ9gcode_M81vEs>[15]
_ZZ9gcode_M81vEs:
        DC8 "3D Printer \265 ."
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M81vEs_0
        DATA
// __absolute char const <_ZZ9gcode_M81vEs_0>[16]
_ZZ9gcode_M81vEs_0:
        DC8 "3D Printer Off."

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs
        DATA
// __absolute char const <_ZZ10gcode_M115vEs>[26]
_ZZ10gcode_M115vEs:
        DC8 "FIRMWARE_NAME:RobinLite \012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M204vEs
        DATA
// __absolute char const <_ZZ10gcode_M204vEs>[40]
_ZZ10gcode_M204vEs:
        DC8 "Setting Print and Travel Acceleration: "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M204vEs_0
        DATA
// __absolute char const <_ZZ10gcode_M204vEs_0>[29]
_ZZ10gcode_M204vEs_0:
        DC8 "Setting Print Acceleration: "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M204vEs_1
        DATA
// __absolute char const <_ZZ10gcode_M204vEs_1>[31]
_ZZ10gcode_M204vEs_1:
        DC8 "Setting Retract Acceleration: "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M204vEs_2
        DATA
// __absolute char const <_ZZ10gcode_M204vEs_2>[30]
_ZZ10gcode_M204vEs_2:
        DC8 "Setting Travel Acceleration: "
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs
        DATA
// __absolute char const <_ZZ10gcode_M211vEs>[16]
_ZZ10gcode_M211vEs:
        DC8 "Soft endstops: "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs_0
        DATA
// __absolute char const <_ZZ10gcode_M211vEs_0>[8]
_ZZ10gcode_M211vEs_0:
        DC8 "  Min: "

        SECTION `.rodata`:CONST:REORDER:NOROOT(1)
        SECTION_GROUP _ZZ10gcode_M211vEs_1
        DATA
// __absolute char const <_ZZ10gcode_M211vEs_1>[2]
_ZZ10gcode_M211vEs_1:
        DC8 "X"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs_2
        DATA
// __absolute char const <_ZZ10gcode_M211vEs_2>[3]
_ZZ10gcode_M211vEs_2:
        DC8 " Y"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs_3
        DATA
// __absolute char const <_ZZ10gcode_M211vEs_3>[3]
_ZZ10gcode_M211vEs_3:
        DC8 " Z"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs_4
        DATA
// __absolute char const <_ZZ10gcode_M211vEs_4>[8]
_ZZ10gcode_M211vEs_4:
        DC8 "  Max: "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M301vEs
        DATA
// __absolute char const <_ZZ10gcode_M301vEs>[4]
_ZZ10gcode_M301vEs:
        DC8 " p:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M301vEs_0
        DATA
// __absolute char const <_ZZ10gcode_M301vEs_0>[4]
_ZZ10gcode_M301vEs_0:
        DC8 " i:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M301vEs_1
        DATA
// __absolute char const <_ZZ10gcode_M301vEs_1>[4]
_ZZ10gcode_M301vEs_1:
        DC8 " d:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M301vEs_2
        DATA
// __absolute char const <_ZZ10gcode_M301vEs_2>[17]
_ZZ10gcode_M301vEs_2:
        DC8 "Invalid extruder"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M304vEs
        DATA
// __absolute char const <_ZZ10gcode_M304vEs>[4]
_ZZ10gcode_M304vEs:
        DC8 " p:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M304vEs_0
        DATA
// __absolute char const <_ZZ10gcode_M304vEs_0>[4]
_ZZ10gcode_M304vEs_0:
        DC8 " i:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M304vEs_1
        DATA
// __absolute char const <_ZZ10gcode_M304vEs_1>[4]
_ZZ10gcode_M304vEs_1:
        DC8 " d:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M302vEs
        DATA
// __absolute char const <_ZZ10gcode_M302vEs>[19]
_ZZ10gcode_M302vEs:
        DC8 "Cold extrudes are "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M302vEs_0
        DATA
// __absolute char const <_ZZ10gcode_M302vEs_0>[3]
_ZZ10gcode_M302vEs_0:
        DC8 "en"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M302vEs_1
        DATA
// __absolute char const <_ZZ10gcode_M302vEs_1>[4]
_ZZ10gcode_M302vEs_1:
        DC8 "dis"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M302vEs_2
        DATA
// __absolute char const <_ZZ10gcode_M302vEs_2>[17]
_ZZ10gcode_M302vEs_2:
        DC8 "abled (min temp "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M302vEs_3
        DATA
// __absolute char const <_ZZ10gcode_M302vEs_3>[4]
_ZZ10gcode_M302vEs_3:
        DC8 "C)\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M303vEs
        DATA
// __absolute char const <_ZZ10gcode_M303vEs>[18]
_ZZ10gcode_M303vEs:
        DC8 "PIDTEMP disabled\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M360vEs
        DATA
// __absolute char const <_ZZ10gcode_M360vEs>[15]
_ZZ10gcode_M360vEs:
        DC8 " Cal: Theta 0\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M361vEs
        DATA
// __absolute char const <_ZZ10gcode_M361vEs>[16]
_ZZ10gcode_M361vEs:
        DC8 " Cal: Theta 90\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M362vEs
        DATA
// __absolute char const <_ZZ10gcode_M362vEs>[13]
_ZZ10gcode_M362vEs:
        DC8 " Cal: Psi 0\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M363vEs
        DATA
// __absolute char const <_ZZ10gcode_M363vEs>[14]
_ZZ10gcode_M363vEs:
        DC8 " Cal: Psi 90\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M364vEs
        DATA
// __absolute char const <_ZZ10gcode_M364vEs>[20]
_ZZ10gcode_M364vEs:
        DC8 " Cal: Theta-Psi 90\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs
        DATA
// __absolute char const <_ZZ10gcode_M420vEs>[41]
_ZZ10gcode_M420vEs:
        DC8 "?EEPROM storage not available for use.\012\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs_0
        DATA
// __absolute char const <_ZZ10gcode_M420vEs_0>[29]
_ZZ10gcode_M420vEs_0:
        DC8 "Bed Level Correction Matrix:"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs_1
        DATA
// __absolute char const <_ZZ10gcode_M420vEs_1>[22]
_ZZ10gcode_M420vEs_1:
        DC8 "Mesh Bed Level data:\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs_2
        DATA
// __absolute char const <_ZZ10gcode_M420vEs_2>[18]
_ZZ10gcode_M420vEs_2:
        DC8 "UBL_MESH_VALID = "
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs_3
        DATA
// __absolute char const <_ZZ10gcode_M420vEs_3>[23]
_ZZ10gcode_M420vEs_3:
        DC8 "eeprom_storage_slot = "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs_4
        DATA
// __absolute char const <_ZZ10gcode_M420vEs_4>[31]
_ZZ10gcode_M420vEs_4:
        DC8 "Failed to enable Bed Leveling\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs_5
        DATA
// __absolute char const <_ZZ10gcode_M420vEs_5>[14]
_ZZ10gcode_M420vEs_5:
        DC8 "Bed Leveling "
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ28gcode_M421_MESH_BED_LEVELINGvEs
        DATA
// __absolute char const <_ZZ28gcode_M421_MESH_BED_LEVELINGvEs>[31]
_ZZ28gcode_M421_MESH_BED_LEVELINGvEs:
        DC8 "Mesh point cannot be resolved\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ28gcode_M421_MESH_BED_LEVELINGvEs_0
        DATA
// __absolute char const <_ZZ28gcode_M421_MESH_BED_LEVELINGvEs_0>[34]
_ZZ28gcode_M421_MESH_BED_LEVELINGvEs_0:
        DC8 "M421 required parameters missing\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M421vEs
        DATA
// __absolute char const <_ZZ10gcode_M421vEs>[31]
_ZZ10gcode_M421vEs:
        DC8 "Mesh point cannot be resolved\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M421vEs_0
        DATA
// __absolute char const <_ZZ10gcode_M421vEs_0>[34]
_ZZ10gcode_M421vEs_0:
        DC8 "M421 required parameters missing\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M428vEs
        DATA
// __absolute char const <_ZZ10gcode_M428vEs>[30]
_ZZ10gcode_M428vEs:
        DC8 "Too far from reference point\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M428vEs_0
        DATA
// __absolute char const <_ZZ10gcode_M428vEs_0>[14]
_ZZ10gcode_M428vEs_0:
        DC8 "Err: Too far!"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M851vEs
        DATA
// __absolute char const <_ZZ10gcode_M851vEs>[10]
_ZZ10gcode_M851vEs:
        DC8 "Z Offset "
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M851vEs_0
        DATA
// __absolute char const <_ZZ10gcode_M851vEs_0>[23]
_ZZ10gcode_M851vEs_0:
        DC8 "z_min:  -20 z_max:  20"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M851vEs_1
        DATA
// __absolute char const <_ZZ10gcode_M851vEs_1>[3]
_ZZ10gcode_M851vEs_1:
        DC8 ": "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M600vEs
        DATA
// __absolute char const <_ZZ10gcode_M600vEs>[41]
_ZZ10gcode_M600vEs:
        DC8 "M600 Hotend too cold to change filament\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M355vEs
        DATA
// __absolute char const <_ZZ10gcode_M355vEs>[15]
_ZZ10gcode_M355vEs:
        DC8 "No case light\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZTS6Buzzer
        DATA
// __absolute char const <Typeinfo name for Buzzer>[8]
_ZTS6Buzzer:
        DC8 "6Buzzer"
// 7635 #endif
// 7636 
// 7637 /**
// 7638  * M105: Read hot end and bed temperature
// 7639  */
// 7640 inline void gcode_M105() {
// 7641   if (get_target_extruder_from_command(105)) return;
// 7642 
// 7643   /*--mks cfg begin-- HAS_TEMP_BED */
// 7644   /*
// 7645   #if HAS_TEMP_HOTEND || HAS_TEMP_BED
// 7646     SERIAL_PROTOCOLPGM(MSG_OK);
// 7647     print_heaterstates();
// 7648   #else // !HAS_TEMP_HOTEND && !HAS_TEMP_BED
// 7649     SERIAL_ERROR_START;
// 7650     SERIAL_ERRORLNPGM(MSG_ERR_NO_THERMISTORS);
// 7651   #endif
// 7652 */
// 7653 	  SERIAL_PROTOCOLPGM(MSG_OK);
// 7654 	  print_heaterstates();
// 7655 
// 7656   /*--mks cfg end-- HAS_TEMP_BED */
// 7657 
// 7658   SERIAL_EOL;
// 7659 }
// 7660 
// 7661 /*--mks cfg-- HAS_TEMP_BED --*/
// 7662 //#if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
// 7663 #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND )
// 7664 
// 7665   static uint8_t auto_report_temp_interval;
// 7666   static millis_t next_temp_report_ms;
// 7667 
// 7668   /**
// 7669    * M155: Set temperature auto-report interval. M155 S<seconds>
// 7670    */
// 7671   inline void gcode_M155() {
// 7672     if (code_seen('S')) {
// 7673       auto_report_temp_interval = code_value_byte();
// 7674       NOMORE(auto_report_temp_interval, 60);
// 7675       next_temp_report_ms = millis() + 1000UL * auto_report_temp_interval;
// 7676     }
// 7677   }
// 7678 
// 7679   inline void auto_report_temperatures() {
// 7680     if (auto_report_temp_interval && ELAPSED(millis(), next_temp_report_ms)) {
// 7681       next_temp_report_ms = millis() + 1000UL * auto_report_temp_interval;
// 7682       print_heaterstates();
// 7683       SERIAL_EOL;
// 7684     }
// 7685   }
// 7686 
// 7687 #endif // AUTO_REPORT_TEMPERATURES
// 7688 
// 7689 #if FAN_COUNT > 0
// 7690 
// 7691   /**
// 7692    * M106: Set Fan Speed
// 7693    *
// 7694    *  S<int>   Speed between 0-255
// 7695    *  P<index> Fan index, if more than one fan
// 7696    */
// 7697   inline void gcode_M106() {
// 7698     uint16_t s = code_seen('S') ? code_value_ushort() : 255,
// 7699              p = code_seen('P') ? code_value_ushort() : 0;
// 7700     NOMORE(s, 255);
// 7701     if (p < FAN_COUNT) 	/*--mks--*/
// 7702 		{
// 7703 		fanSpeeds[p] = s;
// 7704 		TIM1->CCR1 = s*10000/255;
// 7705 		}
// 7706   }
// 7707 
// 7708   /**
// 7709    * M107: Fan Off
// 7710    */
// 7711   inline void gcode_M107() {
// 7712     uint16_t p = code_seen('P') ? code_value_ushort() : 0;
// 7713     if (p < FAN_COUNT) 	/*--mks--*/
// 7714 		{
// 7715 		fanSpeeds[p] = 0;
// 7716 		TIM1->CCR1 = 0 ;
// 7717     	}
// 7718   }
// 7719 
// 7720 #endif // FAN_COUNT > 0
// 7721 
// 7722 #if DISABLED(EMERGENCY_PARSER)
// 7723 
// 7724   /**
// 7725    * M108: Stop the waiting for heaters in M109, M190, M303. Does not affect the target temperature.
// 7726    */
// 7727   inline void gcode_M108() { wait_for_heatup = false; }
// 7728 
// 7729 
// 7730   /**
// 7731    * M112: Emergency Stop
// 7732    */
// 7733   inline void gcode_M112() { kill(PSTR(MSG_KILLED)); }
// 7734 
// 7735 
// 7736   /**
// 7737    * M410: Quickstop - Abort all planned moves
// 7738    *
// 7739    * This will stop the carriages mid-move, so most likely they
// 7740    * will be out of sync with the stepper position after this.
// 7741    */
// 7742   inline void gcode_M410() { quickstop_stepper(); }
// 7743 
// 7744 #endif
// 7745 
// 7746 /**
// 7747  * M109: Sxxx Wait for extruder(s) to reach temperature. Waits only when heating.
// 7748  *       Rxxx Wait for extruder(s) to reach temperature. Waits when heating and cooling.
// 7749  */
// 7750 
// 7751 #ifndef MIN_COOLING_SLOPE_DEG
// 7752   #define MIN_COOLING_SLOPE_DEG 1.50
// 7753 #endif
// 7754 #ifndef MIN_COOLING_SLOPE_TIME
// 7755   #define MIN_COOLING_SLOPE_TIME 60
// 7756 #endif
// 7757 
// 7758 inline void gcode_M109() {
// 7759 
// 7760   if (get_target_extruder_from_command(109)) return;
// 7761   if (DEBUGGING(DRYRUN)) return;
// 7762 
// 7763   #if ENABLED(SINGLENOZZLE)
// 7764     if (target_extruder != active_extruder) return;
// 7765   #endif
// 7766 
// 7767   const bool no_wait_for_cooling = code_seen('S');
// 7768   if (no_wait_for_cooling || code_seen('R')) {
// 7769     const int16_t temp = code_value_temp_abs();
// 7770     thermalManager.setTargetHotend(temp, target_extruder);
// 7771     #if ENABLED(DUAL_X_CARRIAGE)
// 7772       if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && target_extruder == 0)
// 7773         thermalManager.setTargetHotend(temp ? temp + duplicate_extruder_temp_offset : 0, 1);
// 7774     #endif
// 7775 
// 7776     #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
// 7777       /**
// 7778        * Use half EXTRUDE_MINTEMP to allow nozzles to be put into hot
// 7779        * standby mode, (e.g., in a dual extruder setup) without affecting
// 7780        * the running print timer.
// 7781        */
// 7782       if (code_value_temp_abs() <= (EXTRUDE_MINTEMP) / 2) {
// 7783         print_job_timer.stop();
// 7784         LCD_MESSAGEPGM(WELCOME_MSG);
// 7785       }
// 7786       else
// 7787         print_job_timer.start();
// 7788     #endif
// 7789 
// 7790     //if (thermalManager.isHeatingHotend(target_extruder)) lcd_status_printf_P(0, PSTR("E%i %s"), target_extruder + 1, MSG_HEATING);
// 7791     //if (thermalManager.isHeatingHotend(target_extruder))  LCD_MESSAGEPGM("E1 Heating...");        //mks
// 7792 	if (code_value_temp_abs() > thermalManager.degHotend(target_extruder))
// 7793 		{
// 7794 		switch(target_extruder)
// 7795 			{
// 7796 			case 0:
// 7797 				//LCD_MESSAGEPGM("E1 Heating...");
// 7798 				LCD_MESSAGEPGM(MSG_HEATING);
// 7799 				break;
// 7800 			case 1:
// 7801 				LCD_MESSAGEPGM("E2 Heating...");
// 7802 				break;
// 7803 			case 2:
// 7804 				LCD_MESSAGEPGM("E3 Heating...");
// 7805 				break;
// 7806 			case 3:
// 7807 				LCD_MESSAGEPGM("E4 Heating...");
// 7808 				break;
// 7809 			case 4:
// 7810 				LCD_MESSAGEPGM("E5 Heating...");
// 7811 				break;
// 7812 			default: break;
// 7813 				
// 7814 			}
// 7815 		}
// 7816   }
// 7817   else return;
// 7818 
// 7819   #if ENABLED(AUTOTEMP)
// 7820     planner.autotemp_M104_M109();
// 7821   #endif
// 7822 
// 7823   #if TEMP_RESIDENCY_TIME > 0
// 7824     millis_t residency_start_ms = 0;
// 7825     // Loop until the temperature has stabilized
// 7826     #define TEMP_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_RESIDENCY_TIME) * 1000UL))
// 7827   #else
// 7828     // Loop until the temperature is very close target
// 7829     #define TEMP_CONDITIONS (wants_to_cool ? thermalManager.isCoolingHotend(target_extruder) : thermalManager.isHeatingHotend(target_extruder))
// 7830   #endif
// 7831 
// 7832   float target_temp = -1.0, old_temp = 9999.0;
// 7833   bool wants_to_cool = false;
// 7834   wait_for_heatup = true;
// 7835   millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
// 7836 
// 7837   KEEPALIVE_STATE(NOT_BUSY);
// 7838 
// 7839   #if ENABLED(PRINTER_EVENT_LEDS)
// 7840     const float start_temp = thermalManager.degHotend(target_extruder);
// 7841     uint8_t old_blue = 0;
// 7842   #endif
// 7843 
// 7844   mks_heating_busy = 1;
// 7845 
// 7846   do {
// 7847     //cancel m109 waiting for narno print_pin 
// 7848     //if(cancel_heatup) {
// 7849      // cancel_heatup = false;
// 7850      // break;
// 7851     //}
// 7852     // Target temperature might be changed during the loop
// 7853     if (target_temp != thermalManager.degTargetHotend(target_extruder)) {
// 7854       wants_to_cool = thermalManager.isCoolingHotend(target_extruder);
// 7855       target_temp = thermalManager.degTargetHotend(target_extruder);
// 7856 
// 7857       // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
// 7858       if (no_wait_for_cooling && wants_to_cool) break;
// 7859     }
// 7860 
// 7861     now = millis();
// 7862     if (ELAPSED(now, next_temp_ms)) { //Print temp & remaining time every 1s while waiting
// 7863       next_temp_ms = now + 1000UL;
// 7864       print_heaterstates();
// 7865       #if TEMP_RESIDENCY_TIME > 0
// 7866         SERIAL_PROTOCOLPGM(" W:");
// 7867         if (residency_start_ms) {
// 7868           long rem = (((TEMP_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL;
// 7869           SERIAL_PROTOCOLLN(rem);
// 7870         }
// 7871         else {
// 7872           SERIAL_PROTOCOLLNPGM("?");
// 7873         }
// 7874       #else
// 7875         SERIAL_EOL;
// 7876       #endif
// 7877     }
// 7878 
// 7879     idle();
// 7880     refresh_cmd_timeout(); // to prevent stepper_inactive_time from running out
// 7881 
// 7882     const float temp = thermalManager.degHotend(target_extruder);
// 7883 
// 7884     #if ENABLED(PRINTER_EVENT_LEDS)
// 7885       // Gradually change LED strip from violet to red as nozzle heats up
// 7886       if (!wants_to_cool) {
// 7887         const uint8_t blue = map(constrain(temp, start_temp, target_temp), start_temp, target_temp, 255, 0);
// 7888         if (blue != old_blue) set_led_color(255, 0, (old_blue = blue));
// 7889       }
// 7890     #endif
// 7891 
// 7892     #if TEMP_RESIDENCY_TIME > 0
// 7893 
// 7894       const float temp_diff = fabs(target_temp - temp);
// 7895 
// 7896       if (!residency_start_ms) {
// 7897         // Start the TEMP_RESIDENCY_TIME timer when we reach target temp for the first time.
// 7898         if (temp_diff < TEMP_WINDOW) residency_start_ms = now;
// 7899       }
// 7900       else if (temp_diff > TEMP_HYSTERESIS) {
// 7901         // Restart the timer whenever the temperature falls outside the hysteresis.
// 7902         residency_start_ms = now;
// 7903       }
// 7904 
// 7905     #endif
// 7906 
// 7907     // Prevent a wait-forever situation if R is misused i.e. M109 R0
// 7908     if (wants_to_cool) {
// 7909       // break after MIN_COOLING_SLOPE_TIME seconds
// 7910       // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG
// 7911       if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
// 7912         if (old_temp - temp < MIN_COOLING_SLOPE_DEG) break;
// 7913         next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME;
// 7914         old_temp = temp;
// 7915       }
// 7916     }
// 7917 
// 7918   } while (wait_for_heatup && TEMP_CONDITIONS);
// 7919 
// 7920   mks_heating_busy = 0;
// 7921 
// 7922   if (wait_for_heatup) {
// 7923     LCD_MESSAGEPGM(MSG_HEATING_COMPLETE);
// 7924     #if ENABLED(PRINTER_EVENT_LEDS)
// 7925       #if ENABLED(RGBW_LED)
// 7926         set_led_color(0, 0, 0, 255);  // Turn on the WHITE LED
// 7927       #else
// 7928         set_led_color(255, 255, 255); // Set LEDs All On
// 7929       #endif
// 7930     #endif
// 7931   }
// 7932 
// 7933   KEEPALIVE_STATE(IN_HANDLER);
// 7934 }
// 7935 
// 7936 /*--mks cfg-- HAS_TEMP_BED --*/
// 7937 //#if HAS_TEMP_BED
// 7938 #if 1
// 7939   #ifndef MIN_COOLING_SLOPE_DEG_BED
// 7940     #define MIN_COOLING_SLOPE_DEG_BED 1.50
// 7941   #endif
// 7942   #ifndef MIN_COOLING_SLOPE_TIME_BED
// 7943     #define MIN_COOLING_SLOPE_TIME_BED 60
// 7944   #endif
// 7945 
// 7946   /**
// 7947    * M190: Sxxx Wait for bed current temp to reach target temp. Waits only when heating
// 7948    *       Rxxx Wait for bed current temp to reach target temp. Waits when heating and cooling
// 7949    */
// 7950   inline void gcode_M190() {
// 7951     if (DEBUGGING(DRYRUN)) return;
// 7952 
// 7953     LCD_MESSAGEPGM(MSG_BED_HEATING);
// 7954     const bool no_wait_for_cooling = code_seen('S');
// 7955     if (no_wait_for_cooling || code_seen('R')) {
// 7956       thermalManager.setTargetBed(code_value_temp_abs());
// 7957       #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
// 7958         if (code_value_temp_abs() > BED_MINTEMP)
// 7959           print_job_timer.start();
// 7960       #endif
// 7961     }
// 7962     else return;
// 7963 
// 7964     #if TEMP_BED_RESIDENCY_TIME > 0
// 7965       millis_t residency_start_ms = 0;
// 7966       // Loop until the temperature has stabilized
// 7967       #define  TEMP_BED_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_BED_RESIDENCY_TIME) * 1000UL))
// 7968     #else
// 7969       // Loop until the temperature is very close target
// 7970       #define TEMP_BED_CONDITIONS (wants_to_cool ? thermalManager.isCoolingBed() : thermalManager.isHeatingBed())
// 7971     #endif
// 7972 
// 7973     float target_temp = -1.0, old_temp = 9999.0;
// 7974     bool wants_to_cool = false;
// 7975     wait_for_heatup = true;
// 7976     millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
// 7977 
// 7978     KEEPALIVE_STATE(NOT_BUSY);
// 7979 
// 7980     target_extruder = active_extruder; // for print_heaterstates
// 7981 
// 7982     #if ENABLED(PRINTER_EVENT_LEDS)
// 7983       const float start_temp = thermalManager.degBed();
// 7984       uint8_t old_red = 255;
// 7985     #endif
// 7986 	
// 7987 	mks_heating_busy = 1;
// 7988 
// 7989     do {
// 7990       // Target temperature might be changed during the loop
// 7991       if (target_temp != thermalManager.degTargetBed()) {
// 7992         wants_to_cool = thermalManager.isCoolingBed();
// 7993         target_temp = thermalManager.degTargetBed();
// 7994 
// 7995         // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
// 7996         if (no_wait_for_cooling && wants_to_cool) break;
// 7997       }
// 7998 
// 7999       now = millis();
// 8000       if (ELAPSED(now, next_temp_ms)) { //Print Temp Reading every 1 second while heating up.
// 8001         next_temp_ms = now + 1000UL;
// 8002         print_heaterstates();
// 8003         #if TEMP_BED_RESIDENCY_TIME > 0
// 8004           SERIAL_PROTOCOLPGM(" W:");
// 8005           if (residency_start_ms) {
// 8006             long rem = (((TEMP_BED_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL;
// 8007             SERIAL_PROTOCOLLN(rem);
// 8008           }
// 8009           else {
// 8010             SERIAL_PROTOCOLLNPGM("?");
// 8011           }
// 8012         #else
// 8013           SERIAL_EOL;
// 8014         #endif
// 8015       }
// 8016 
// 8017       idle();
// 8018       refresh_cmd_timeout(); // to prevent stepper_inactive_time from running out
// 8019 
// 8020       const float temp = thermalManager.degBed();
// 8021 
// 8022       #if ENABLED(PRINTER_EVENT_LEDS)
// 8023         // Gradually change LED strip from blue to violet as bed heats up
// 8024         if (!wants_to_cool) {
// 8025           const uint8_t red = map(constrain(temp, start_temp, target_temp), start_temp, target_temp, 0, 255);
// 8026           if (red != old_red) set_led_color((old_red = red), 0, 255);
// 8027         }
// 8028       }
// 8029       #endif
// 8030 
// 8031       #if TEMP_BED_RESIDENCY_TIME > 0
// 8032 
// 8033         const float temp_diff = fabs(target_temp - temp);
// 8034 
// 8035         if (!residency_start_ms) {
// 8036           // Start the TEMP_BED_RESIDENCY_TIME timer when we reach target temp for the first time.
// 8037           if (temp_diff < TEMP_BED_WINDOW) residency_start_ms = now;
// 8038         }
// 8039         else if (temp_diff > TEMP_BED_HYSTERESIS) {
// 8040           // Restart the timer whenever the temperature falls outside the hysteresis.
// 8041           residency_start_ms = now;
// 8042         }
// 8043 
// 8044       #endif // TEMP_BED_RESIDENCY_TIME > 0
// 8045 
// 8046       // Prevent a wait-forever situation if R is misused i.e. M190 R0
// 8047       if (wants_to_cool) {
// 8048         // Break after MIN_COOLING_SLOPE_TIME_BED seconds
// 8049         // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG_BED
// 8050         if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
// 8051           if (old_temp - temp < MIN_COOLING_SLOPE_DEG_BED) break;
// 8052           next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME_BED;
// 8053           old_temp = temp;
// 8054         }
// 8055       }
// 8056 
// 8057     } while (wait_for_heatup && TEMP_BED_CONDITIONS);
// 8058 	mks_heating_busy = 0;
// 8059 
// 8060     if (wait_for_heatup) LCD_MESSAGEPGM(MSG_BED_DONE);
// 8061     KEEPALIVE_STATE(IN_HANDLER);
// 8062   }
// 8063 
// 8064 #endif // HAS_TEMP_BED
// 8065 
// 8066 /**
// 8067  * M110: Set Current Line Number
// 8068  */
// 8069 inline void gcode_M110() {
// 8070   if (code_seen('N')) gcode_LastN = code_value_long();
// 8071 }
// 8072 
// 8073 /**
// 8074  * M111: Set the debug level
// 8075  */
// 8076 inline void gcode_M111() {
// 8077   marlin_debug_flags = code_seen('S') ? code_value_byte() : (uint8_t)DEBUG_NONE;
// 8078 

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vE11str_debug_1
        DATA
// 8079   const static char str_debug_1[] PROGMEM = MSG_DEBUG_ECHO;
_ZZ10gcode_M111vE11str_debug_1:
        DC8 "ECHO"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vE11str_debug_2
        DATA
// 8080   const static char str_debug_2[] PROGMEM = MSG_DEBUG_INFO;
_ZZ10gcode_M111vE11str_debug_2:
        DC8 "INFO"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vE11str_debug_4
        DATA
// 8081   const static char str_debug_4[] PROGMEM = MSG_DEBUG_ERRORS;
_ZZ10gcode_M111vE11str_debug_4:
        DC8 "ERRORS"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vE11str_debug_8
        DATA
// 8082   const static char str_debug_8[] PROGMEM = MSG_DEBUG_DRYRUN;
_ZZ10gcode_M111vE11str_debug_8:
        DC8 "DRYRUN"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vE12str_debug_16
        DATA
// 8083   const static char str_debug_16[] PROGMEM = MSG_DEBUG_COMMUNICATION;
_ZZ10gcode_M111vE12str_debug_16:
        DC8 "COMMUNICATION"
        DC8 0, 0
// 8084   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 8085     const static char str_debug_32[] PROGMEM = MSG_DEBUG_LEVELING;
// 8086   #endif
// 8087 

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vE13debug_strings
        DATA
// 8088   const static char* const debug_strings[] PROGMEM = {
_ZZ10gcode_M111vE13debug_strings:
        DC32 _ZZ10gcode_M111vE11str_debug_1, _ZZ10gcode_M111vE11str_debug_2
        DC32 _ZZ10gcode_M111vE11str_debug_4, _ZZ10gcode_M111vE11str_debug_8
        DC32 _ZZ10gcode_M111vE12str_debug_16

        SECTION `.rodata`:CONST:NOROOT(1)
        DATA
?_4:
        DC8 "X"

        SECTION `.rodata`:CONST:NOROOT(1)
        DATA
?_5:
        DC8 "Y"

        SECTION `.rodata`:CONST:NOROOT(1)
        DATA
?_6:
        DC8 "Z"

        SECTION `.rodata`:CONST:NOROOT(0)
        DATA
?_9:
        DC8 ""

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
?_24:
        DC8 " T:"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
?_25:
        DC8 " /"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
?_26:
        DC8 " B:"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
?_27:
        DC8 " @:"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
?_29:
        DC8 "X:"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
?_30:
        DC8 " Y:"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
?_31:
        DC8 " Z:"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
?_32:
        DC8 " E:"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
?_36:
        DC8 "bed leveling hasn't defined!"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(1)
        DATA
?_37:
        DC8 "/"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
?_40:
        DC8 "ok"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
?_50:
        DC8 " \012"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
?_57:
        DC8 "M29"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
?_60:
        DC8 "%d"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
?_64:
        DC8 "%f"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
?_68:
        DC8 " Y"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
?_71:
        DC8 "G28"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
?_76:
        DC8 "end"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
?_78:
        DC32 0H, 0H

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
?_79:
        DC32 0H, 0H, 0H
// 8089     str_debug_1, str_debug_2, str_debug_4, str_debug_8, str_debug_16,
// 8090     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 8091       str_debug_32
// 8092     #endif
// 8093   };
// 8094 
// 8095   SERIAL_ECHO_START;
// 8096   SERIAL_ECHOPGM(MSG_DEBUG_PREFIX);
// 8097   if (marlin_debug_flags) {
// 8098     uint8_t comma = 0;
// 8099     for (uint8_t i = 0; i < COUNT(debug_strings); i++) {
// 8100       if (TEST(marlin_debug_flags, i)) {
// 8101         if (comma++) SERIAL_CHAR(',');
// 8102         //serialprintPGM((char*)pgm_read_word(&debug_strings[i]));
// 8103         serialprintPGM((char*)&(debug_strings[i]));
// 8104 		
// 8105       }
// 8106     }
// 8107   }
// 8108   else {
// 8109     SERIAL_ECHOPGM(MSG_DEBUG_OFF);
// 8110   }
// 8111   SERIAL_EOL;
// 8112 }
// 8113 
// 8114 #if ENABLED(HOST_KEEPALIVE_FEATURE)
// 8115 
// 8116   /**
// 8117    * M113: Get or set Host Keepalive interval (0 to disable)
// 8118    *
// 8119    *   S<seconds> Optional. Set the keepalive interval.
// 8120    */
// 8121   inline void gcode_M113() {
// 8122     if (code_seen('S')) {
// 8123       host_keepalive_interval = code_value_byte();
// 8124       NOMORE(host_keepalive_interval, 60);
// 8125     }
// 8126     else {
// 8127       SERIAL_ECHO_START;
// 8128       SERIAL_ECHOLNPAIR("M113 S", (unsigned long)host_keepalive_interval);
// 8129     }
// 8130   }
// 8131 
// 8132 #endif
// 8133 
// 8134 #if ENABLED(BARICUDA)
// 8135 
// 8136   #if HAS_HEATER_1
// 8137     /**
// 8138      * M126: Heater 1 valve open
// 8139      */
// 8140     inline void gcode_M126() { baricuda_valve_pressure = code_seen('S') ? code_value_byte() : 255; }
// 8141     /**
// 8142      * M127: Heater 1 valve close
// 8143      */
// 8144     inline void gcode_M127() { baricuda_valve_pressure = 0; }
// 8145   #endif
// 8146 
// 8147   #if HAS_HEATER_2
// 8148     /**
// 8149      * M128: Heater 2 valve open
// 8150      */
// 8151     inline void gcode_M128() { baricuda_e_to_p_pressure = code_seen('S') ? code_value_byte() : 255; }
// 8152     /**
// 8153      * M129: Heater 2 valve close
// 8154      */
// 8155     inline void gcode_M129() { baricuda_e_to_p_pressure = 0; }
// 8156   #endif
// 8157 
// 8158 #endif //BARICUDA
// 8159 
// 8160 /**
// 8161  * M140: Set bed temperature
// 8162  */
// 8163 inline void gcode_M140() {
// 8164   if (DEBUGGING(DRYRUN)) return;
// 8165   if (code_seen('S')) thermalManager.setTargetBed(code_value_temp_abs());
// 8166 }
// 8167 
// 8168 #if ENABLED(ULTIPANEL)
// 8169 
// 8170   /**
// 8171    * M145: Set the heatup state for a material in the LCD menu
// 8172    *
// 8173    *   S<material> (0=PLA, 1=ABS)
// 8174    *   H<hotend temp>
// 8175    *   B<bed temp>
// 8176    *   F<fan speed>
// 8177    */
// 8178   inline void gcode_M145() {
// 8179     uint8_t material = code_seen('S') ? (uint8_t)code_value_int() : 0;
// 8180     if (material >= COUNT(lcd_preheat_hotend_temp)) {
// 8181       SERIAL_ERROR_START;
// 8182       SERIAL_ERRORLNPGM(MSG_ERR_MATERIAL_INDEX);
// 8183     }
// 8184     else {
// 8185       int v;
// 8186       if (code_seen('H')) {
// 8187         v = code_value_int();
// 8188         lcd_preheat_hotend_temp[material] = constrain(v, EXTRUDE_MINTEMP, HEATER_0_MAXTEMP - 15);
// 8189       }
// 8190       if (code_seen('F')) {
// 8191         v = code_value_int();
// 8192         lcd_preheat_fan_speed[material] = constrain(v, 0, 255);
// 8193       }
// 8194       #if TEMP_SENSOR_BED != 0
// 8195         if (code_seen('B')) {
// 8196           v = code_value_int();
// 8197           lcd_preheat_bed_temp[material] = constrain(v, BED_MINTEMP, BED_MAXTEMP - 15);
// 8198         }
// 8199       #endif
// 8200     }
// 8201   }
// 8202 
// 8203 #endif // ULTIPANEL
// 8204 
// 8205 #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
// 8206   /**
// 8207    * M149: Set temperature units
// 8208    */
// 8209   inline void gcode_M149() {
// 8210          if (code_seen('C')) set_input_temp_units(TEMPUNIT_C);
// 8211     else if (code_seen('K')) set_input_temp_units(TEMPUNIT_K);
// 8212     else if (code_seen('F')) set_input_temp_units(TEMPUNIT_F);
// 8213   }
// 8214 #endif
// 8215 
// 8216 #if HAS_POWER_SWITCH
// 8217 
// 8218   /**
// 8219    * M80: Turn on Power Supply
// 8220    */
// 8221   inline void gcode_M80() {
// 8222     OUT_WRITE(PS_ON_PIN, PS_ON_AWAKE); //GND
// 8223 
// 8224     /**
// 8225      * If you have a switch on suicide pin, this is useful
// 8226      * if you want to start another print with suicide feature after
// 8227      * a print without suicide...
// 8228      */
// 8229     #if HAS_SUICIDE
// 8230       OUT_WRITE(SUICIDE_PIN, HIGH);
// 8231     #endif
// 8232 
// 8233     #if ENABLED(HAVE_TMC2130)
// 8234       delay(100);
// 8235       tmc2130_init(); // Settings only stick when the driver has power
// 8236     #endif
// 8237 
// 8238     #if ENABLED(ULTIPANEL)
// 8239       powersupply = true;
// 8240       LCD_MESSAGEPGM(WELCOME_MSG);
// 8241     #endif
// 8242   }
// 8243 
// 8244 #endif // HAS_POWER_SWITCH
// 8245 
// 8246 /**
// 8247  * M81: Turn off Power, including Power Supply, if there is one.
// 8248  *
// 8249  *      This code should ALWAYS be available for EMERGENCY SHUTDOWN!
// 8250  */
// 8251 inline void gcode_M81() {
// 8252   thermalManager.disable_all_heaters();
// 8253   stepper.finish_and_disable();
// 8254   #if FAN_COUNT > 0
// 8255   for (uint8_t i = 0; i < FAN_COUNT; i++) fanSpeeds[i] = 0;
// 8256 	#if ENABLED(PROBING_FANS_OFF)
// 8257 	fans_paused = false;
// 8258 	ZERO(paused_fanSpeeds);
// 8259   #endif
// 8260 #endif  
// 8261   safe_delay(1000); // Wait 1 second before switching off
// 8262   #if HAS_SUICIDE
// 8263     stepper.synchronize();
// 8264     suicide();
// 8265   #elif HAS_POWER_SWITCH
// 8266     OUT_WRITE(PS_ON_PIN, PS_ON_ASLEEP);
// 8267   #endif
// 8268   #if ENABLED(ULTIPANEL)
// 8269     #if HAS_POWER_SWITCH
// 8270       powersupply = false;
// 8271     #endif
// 8272       /*--mks cfg-- LCD_LANGUAGE*/
// 8273     //LCD_MESSAGEPGM(MACHINE_NAME " " MSG_OFF ".");
// 8274       if(LCD_LANGUAGE)
// 8275         LCD_MESSAGEPGM(MACHINE_NAME " " "\xb5 " ".");
// 8276       else
// 8277         LCD_MESSAGEPGM(MACHINE_NAME " " "Off" ".");
// 8278       
// 8279   #endif
// 8280 }
// 8281 
// 8282 /**
// 8283  * M82: Set E codes absolute (default)
// 8284  */
// 8285 inline void gcode_M82() { axis_relative_modes[E_AXIS] = false; }
// 8286 
// 8287 /**
// 8288  * M83: Set E codes relative while in Absolute Coordinates (G90) mode
// 8289  */
// 8290 inline void gcode_M83() { axis_relative_modes[E_AXIS] = true; }
// 8291 
// 8292 /**
// 8293  * M18, M84: Disable all stepper motors
// 8294  */
// 8295 inline void gcode_M18_M84() {
// 8296   if (code_seen('S')) {
// 8297     stepper_inactive_time = code_value_millis_from_seconds();
// 8298   }
// 8299   else {
// 8300     bool all_axis = !((code_seen('X')) || (code_seen('Y')) || (code_seen('Z')) || (code_seen('E')));
// 8301     if (all_axis) {
// 8302       stepper.finish_and_disable();
// 8303     }
// 8304     else {
// 8305       stepper.synchronize();
// 8306       if (code_seen('X')) disable_X();
// 8307       if (code_seen('Y')) disable_Y();
// 8308       if (code_seen('Z')) disable_Z();
// 8309       #if ((E0_ENABLE_PIN != X_ENABLE_PIN) && (E1_ENABLE_PIN != Y_ENABLE_PIN)) // Only enable on boards that have seperate ENABLE_PINS
// 8310         if (code_seen('E')) disable_e_steppers();
// 8311       #endif
// 8312     }
// 8313   }
// 8314 }
// 8315 
// 8316 /**
// 8317  * M85: Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
// 8318  */
// 8319 inline void gcode_M85() {
// 8320   if (code_seen('S')) max_inactive_time = code_value_millis_from_seconds();
// 8321 }
// 8322 
// 8323 /**
// 8324  * Multi-stepper support for M92, M201, M203
// 8325  */
// 8326 #if ENABLED(DISTINCT_E_FACTORS)
// 8327   #define GET_TARGET_EXTRUDER(CMD) if (get_target_extruder_from_command(CMD)) return
// 8328   #define TARGET_EXTRUDER target_extruder
// 8329 #else
// 8330   #define GET_TARGET_EXTRUDER(CMD) NOOP
// 8331   #define TARGET_EXTRUDER 0
// 8332 #endif
// 8333 
// 8334 /**
// 8335  * M92: Set axis steps-per-unit for one or more axes, X, Y, Z, and E.
// 8336  *      (Follows the same syntax as G92)
// 8337  *
// 8338  *      With multiple extruders use T to specify which one.
// 8339  */
// 8340 inline void gcode_M92() {
// 8341 
// 8342   GET_TARGET_EXTRUDER(92);
// 8343 
// 8344   LOOP_XYZE(i) {
// 8345     if (code_seen(axis_codes[i])) {
// 8346       if (i == E_AXIS) {
// 8347         const float value = code_value_per_axis_unit((AxisEnum)(E_AXIS + TARGET_EXTRUDER));
// 8348         if (value < 20.0) {
// 8349           float factor = planner.axis_steps_per_mm[E_AXIS + TARGET_EXTRUDER] / value; // increase e constants if M92 E14 is given for netfab.
// 8350           planner.max_jerk[E_AXIS] *= factor;
// 8351           planner.max_feedrate_mm_s[E_AXIS + TARGET_EXTRUDER] *= factor;
// 8352           planner.max_acceleration_steps_per_s2[E_AXIS + TARGET_EXTRUDER] *= factor;
// 8353         }
// 8354         planner.axis_steps_per_mm[E_AXIS + TARGET_EXTRUDER] = value;
// 8355       }
// 8356       else {
// 8357         planner.axis_steps_per_mm[i] = code_value_per_axis_unit((AxisEnum)i);
// 8358       }
// 8359     }
// 8360   }
// 8361   planner.refresh_positioning();
// 8362 }
// 8363 
// 8364 /**
// 8365  * Output the current position to serial
// 8366  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock64 Using cfiCommon0
          CFI Function _ZN37_INTERNAL_15_Marlin_main_cpp_3178531923report_current_positionEv
        THUMB
// 8367 static void report_current_position() {
_ZN37_INTERNAL_15_Marlin_main_cpp_3178531923report_current_positionEv:
        PUSH     {R2-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+24
// 8368   SERIAL_PROTOCOLPGM("X:");
        ADR.N    R0,??DataTable135  ;; 0x58, 0x3A, 0x00, 0x00
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 8369   SERIAL_PROTOCOL(current_position[X_AXIS]);
        LDR.N    R4,??DataTable136_2
        LDR      R0,[R4, #+8]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        LDR.N    R5,??DataTable136_6
        LDR.N    R6,??DataTable136_17
        LDRB     R0,[R4, #+7]
        CMP      R0,#+0
        BNE.N    ??report_current_position_0
        MOVS     R0,#+2
        STR      R0,[SP, #+0]
        MOV      R0,R6
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
        B.N      ??report_current_position_1
??report_current_position_0:
        MOVS     R0,#+2
        STR      R0,[SP, #+0]
        MOV      R0,R5
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
// 8370   SERIAL_PROTOCOLPGM(" Y:");
??report_current_position_1:
        ADR.N    R0,??DataTable135_1  ;; " Y:"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 8371   SERIAL_PROTOCOL(current_position[Y_AXIS]);
        LDR      R0,[R4, #+12]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        LDRB     R0,[R4, #+7]
        CMP      R0,#+0
        BNE.N    ??report_current_position_2
        MOVS     R0,#+2
        STR      R0,[SP, #+0]
        MOV      R0,R6
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
        B.N      ??report_current_position_3
??report_current_position_2:
        MOVS     R0,#+2
        STR      R0,[SP, #+0]
        MOV      R0,R5
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
// 8372   SERIAL_PROTOCOLPGM(" Z:");
??report_current_position_3:
        ADR.N    R0,??DataTable136  ;; " Z:"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 8373   SERIAL_PROTOCOL(current_position[Z_AXIS]);
        LDR      R0,[R4, #+16]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        LDRB     R0,[R4, #+7]
        CMP      R0,#+0
        BNE.N    ??report_current_position_4
        MOVS     R0,#+2
        STR      R0,[SP, #+0]
        MOV      R0,R6
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
        B.N      ??report_current_position_5
??report_current_position_4:
        MOVS     R0,#+2
        STR      R0,[SP, #+0]
        MOV      R0,R5
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
// 8374   SERIAL_PROTOCOLPGM(" E:");
??report_current_position_5:
        ADR.N    R0,??DataTable136_1  ;; " E:"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 8375   SERIAL_PROTOCOL(current_position[E_AXIS]);
        LDR      R0,[R4, #+20]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDRB     R2,[R4, #+7]
        CMP      R2,#+0
        BNE.N    ??report_current_position_6
        MOVS     R2,#+2
        STR      R2,[SP, #+0]
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R6
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
        B.N      ??report_current_position_7
??report_current_position_6:
        MOVS     R2,#+2
        STR      R2,[SP, #+0]
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R5
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
// 8376 
// 8377   stepper.report_positions();
??report_current_position_7:
          CFI FunCall _ZN7Stepper16report_positionsEv
        BL       _ZN7Stepper16report_positionsEv
// 8378 
// 8379 //  #if IS_SCARA
// 8380 if(MACHINETPYE&IS_SCARA)  {
        LDR.N    R0,??DataTable136_8
        LDRH     R0,[R0, #+88]
        TST      R0,#0x300
        BEQ.N    ??report_current_position_8
// 8381     SERIAL_PROTOCOLPAIR("SCARA Theta:", stepper.get_axis_position_degrees(A_AXIS));
        MOVS     R0,#+0
          CFI FunCall _ZN7Stepper25get_axis_position_degreesE8AxisEnum
        BL       _ZN7Stepper25get_axis_position_degreesE8AxisEnum
        MOV      R1,R0
        ADR.W    R0,?_33
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
// 8382     SERIAL_PROTOCOLLNPAIR("   Psi+Theta:", stepper.get_axis_position_degrees(B_AXIS));
        MOVS     R0,#+1
          CFI FunCall _ZN7Stepper25get_axis_position_degreesE8AxisEnum
        BL       _ZN7Stepper25get_axis_position_degreesE8AxisEnum
        MOV      R1,R0
        ADR.W    R0,?_34
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDRB     R0,[R4, #+7]
        CMP      R0,#+0
        BNE.N    ??report_current_position_9
        MOVS     R1,#+10
        MOV      R0,R6
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??report_current_position_10
??report_current_position_9:
        MOVS     R2,#+0
        MOVS     R1,#+10
        MOV      R0,R5
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
// 8383     SERIAL_EOL; }
??report_current_position_10:
        LDRB     R0,[R4, #+7]
        CMP      R0,#+0
        BNE.N    ??report_current_position_11
        MOVS     R1,#+10
        MOV      R0,R6
        POP      {R2-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN12MarlinSerial5writeEh
        B.W      _ZN12MarlinSerial5writeEh
          CFI R4 Frame(CFA, -16)
          CFI R5 Frame(CFA, -12)
          CFI R6 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+24
??report_current_position_11:
        MOVS     R2,#+0
        MOVS     R1,#+10
        MOV      R0,R5
        ADD      SP,SP,#+8
          CFI CFA R13+16
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN12MarlinSerial5printEci
        B.W      _ZN12MarlinSerial5printEci
          CFI R4 Frame(CFA, -16)
          CFI R5 Frame(CFA, -12)
          CFI R6 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+24
// 8384  // #endif
// 8385 }
??report_current_position_8:
        POP      {R0,R1,R4-R6,PC}  ;; return
          CFI EndBlock cfiBlock64

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable132:
        DC8      " T:"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_33:
        DC8 "SCARA Theta:"
        DC8 0, 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_34:
        DC8 "   Psi+Theta:"
        DC8 0, 0
// 8386 
// 8387 /**
// 8388  * M114: Output current position to serial port
// 8389  */
// 8390 inline void gcode_M114() { stepper.synchronize(); report_current_position(); }
// 8391 
// 8392 /**
// 8393  * M115: Capabilities string
// 8394  */
// 8395 inline void gcode_M115() {
// 8396   SERIAL_PROTOCOLLNPGM(MSG_M115_REPORT);
// 8397 
// 8398   #if ENABLED(EXTENDED_CAPABILITIES_REPORT)
// 8399 
// 8400     // EEPROM (M500, M501)
// 8401     #if ENABLED(EEPROM_SETTINGS)
// 8402       SERIAL_PROTOCOLLNPGM("Cap:EEPROM:1");
// 8403     #else
// 8404       SERIAL_PROTOCOLLNPGM("Cap:EEPROM:0");
// 8405     #endif
// 8406 
// 8407     // AUTOREPORT_TEMP (M155)
// 8408     #if ENABLED(AUTO_REPORT_TEMPERATURES)
// 8409       SERIAL_PROTOCOLLNPGM("Cap:AUTOREPORT_TEMP:1");
// 8410     #else
// 8411       SERIAL_PROTOCOLLNPGM("Cap:AUTOREPORT_TEMP:0");
// 8412     #endif
// 8413 
// 8414     // PROGRESS (M530 S L, M531 <file>, M532 X L)
// 8415     SERIAL_PROTOCOLLNPGM("Cap:PROGRESS:0");
// 8416 
// 8417     // AUTOLEVEL (G29)
// 8418     //#if HAS_ABL
// 8419 	if(BED_LEVELING_METHOD&HAS_ABL)
// 8420       SERIAL_PROTOCOLLNPGM("Cap:AUTOLEVEL:1");
// 8421     //#else
// 8422     else
// 8423       SERIAL_PROTOCOLLNPGM("Cap:AUTOLEVEL:0");
// 8424     //#endif
// 8425 
// 8426     // Z_PROBE (G30)
// 8427     #if HAS_BED_PROBE
// 8428       SERIAL_PROTOCOLLNPGM("Cap:Z_PROBE:1");
// 8429     #else
// 8430       SERIAL_PROTOCOLLNPGM("Cap:Z_PROBE:0");
// 8431     #endif
// 8432 
// 8433     // MESH_REPORT (M420 V)
// 8434     //#if HAS_LEVELING
// 8435 	if(BED_LEVELING_METHOD&HAS_LEVELING)
// 8436       SERIAL_PROTOCOLLNPGM("Cap:LEVELING_DATA:1");
// 8437 	else
// 8438     //#else
// 8439       SERIAL_PROTOCOLLNPGM("Cap:LEVELING_DATA:0");
// 8440     //#endif
// 8441 
// 8442     // SOFTWARE_POWER (G30)
// 8443     #if HAS_POWER_SWITCH
// 8444       SERIAL_PROTOCOLLNPGM("Cap:SOFTWARE_POWER:1");
// 8445     #else
// 8446       SERIAL_PROTOCOLLNPGM("Cap:SOFTWARE_POWER:0");
// 8447     #endif
// 8448 
// 8449     // TOGGLE_LIGHTS (M355)
// 8450     #if HAS_CASE_LIGHT
// 8451       SERIAL_PROTOCOLLNPGM("Cap:TOGGLE_LIGHTS:1");
// 8452     #else
// 8453       SERIAL_PROTOCOLLNPGM("Cap:TOGGLE_LIGHTS:0");
// 8454     #endif
// 8455 
// 8456     // EMERGENCY_PARSER (M108, M112, M410)
// 8457     #if ENABLED(EMERGENCY_PARSER)
// 8458       SERIAL_PROTOCOLLNPGM("Cap:EMERGENCY_PARSER:1");
// 8459     #else
// 8460       SERIAL_PROTOCOLLNPGM("Cap:EMERGENCY_PARSER:0");
// 8461     #endif
// 8462 
// 8463   #endif // EXTENDED_CAPABILITIES_REPORT
// 8464 }
// 8465 
// 8466 /**
// 8467  * M117: Set LCD Status Message
// 8468  */
// 8469 inline void gcode_M117() {
// 8470   if(IS_SD_PRINTING){
// 8471      lcd_setstatus(MSG_MKSPRINTINTING);
// 8472   	}
// 8473   else{
// 8474      lcd_setstatus(current_command_args);
// 8475   }
// 8476 }
// 8477 
// 8478 /**
// 8479  * M119: Output endstop states to serial output
// 8480  */
// 8481 inline void gcode_M119() { endstops.M119(); }
// 8482 
// 8483 /**
// 8484  * M120: Enable endstops and set non-homing endstop state to "enabled"
// 8485  */
// 8486 inline void gcode_M120() { endstops.enable_globally(true); }
// 8487 
// 8488 /**
// 8489  * M121: Disable endstops and set non-homing endstop state to "disabled"
// 8490  */
// 8491 inline void gcode_M121() { endstops.enable_globally(false); }
// 8492 
// 8493 #if ENABLED(PARK_HEAD_ON_PAUSE)
// 8494 
// 8495   /**
// 8496    * M125: Store current position and move to filament change position.
// 8497    *       Called on pause (by M25) to prevent material leaking onto the
// 8498    *       object. On resume (M24) the head will be moved back and the
// 8499    *       print will resume.
// 8500    *
// 8501    *       If Marlin is compiled without SD Card support, M125 can be
// 8502    *       used directly to pause the print and move to park position,
// 8503    *       resuming with a button click or M108.
// 8504    *
// 8505    *    L = override retract length
// 8506    *    X = override X
// 8507    *    Y = override Y
// 8508    *    Z = override Z raise
// 8509    */
// 8510   inline void gcode_M125() {
// 8511     if (move_away_flag) return; // already paused
// 8512 
// 8513     const bool job_running = print_job_timer.isRunning();
// 8514 
// 8515     // there are blocks after this one, or sd printing
// 8516     move_away_flag = job_running || planner.blocks_queued()
// 8517       #if ENABLED(SDSUPPORT)
// 8518         || card.sdprinting
// 8519       #endif
// 8520     ;
// 8521 
// 8522     if (!move_away_flag) return; // nothing to pause
// 8523 
// 8524     // M125 can be used to pause a print too
// 8525     #if ENABLED(SDSUPPORT)
// 8526       card.pauseSDPrint();
// 8527     #endif
// 8528     print_job_timer.pause();
// 8529 
// 8530     // Save current position
// 8531     COPY(resume_position, current_position);
// 8532 
// 8533     set_destination_to_current();
// 8534 
// 8535     // Initial retract before move to filament change position
// 8536     destination[E_AXIS] += code_seen('L') ? code_value_axis_units(E_AXIS) : 0
// 8537       #if defined(FILAMENT_CHANGE_RETRACT_LENGTH) && FILAMENT_CHANGE_RETRACT_LENGTH > 0
// 8538         - (FILAMENT_CHANGE_RETRACT_LENGTH)
// 8539       #endif
// 8540     ;
// 8541     RUNPLAN(FILAMENT_CHANGE_RETRACT_FEEDRATE);
// 8542 
// 8543     // Lift Z axis
// 8544     const float z_lift = code_seen('Z') ? code_value_linear_units() :
// 8545       #if defined(FILAMENT_CHANGE_Z_ADD) && FILAMENT_CHANGE_Z_ADD > 0
// 8546         FILAMENT_CHANGE_Z_ADD
// 8547       #else
// 8548         0
// 8549       #endif
// 8550     ;
// 8551     if (z_lift > 0) {
// 8552       destination[Z_AXIS] += z_lift;
// 8553       NOMORE(destination[Z_AXIS], Z_MAX_POS);
// 8554       RUNPLAN(FILAMENT_CHANGE_Z_FEEDRATE);
// 8555     }
// 8556 
// 8557     // Move XY axes to filament change position or given position
// 8558     destination[X_AXIS] = code_seen('X') ? code_value_linear_units() : 0
// 8559       #ifdef FILAMENT_CHANGE_X_POS
// 8560         + FILAMENT_CHANGE_X_POS
// 8561       #endif
// 8562     ;
// 8563     destination[Y_AXIS] = code_seen('Y') ? code_value_linear_units() : 0
// 8564       #ifdef FILAMENT_CHANGE_Y_POS
// 8565         + FILAMENT_CHANGE_Y_POS
// 8566       #endif
// 8567     ;
// 8568 
// 8569     #if HOTENDS > 1 && DISABLED(DUAL_X_CARRIAGE)
// 8570       if (active_extruder > 0) {
// 8571         if (!code_seen('X')) destination[X_AXIS] += hotend_offset[X_AXIS][active_extruder];
// 8572         if (!code_seen('Y')) destination[Y_AXIS] += hotend_offset[Y_AXIS][active_extruder];
// 8573       }
// 8574     #endif
// 8575 
// 8576     clamp_to_software_endstops(destination);
// 8577     RUNPLAN(FILAMENT_CHANGE_XY_FEEDRATE);
// 8578     set_current_to_destination();
// 8579     stepper.synchronize();
// 8580     disable_e_steppers();
// 8581 
// 8582     #if DISABLED(SDSUPPORT)
// 8583       // Wait for lcd click or M108
// 8584       KEEPALIVE_STATE(PAUSED_FOR_USER);
// 8585       wait_for_user = true;
// 8586       while (wait_for_user) idle();
// 8587       KEEPALIVE_STATE(IN_HANDLER);
// 8588 
// 8589       // Return to print position and continue
// 8590       move_back_on_resume();
// 8591       if (job_running) print_job_timer.start();
// 8592       move_away_flag = false;
// 8593     #endif
// 8594   }
// 8595 
// 8596 #endif // PARK_HEAD_ON_PAUSE
// 8597 
// 8598 #if HAS_COLOR_LEDS
// 8599 
// 8600   /**
// 8601    * M150: Set Status LED Color - Use R-U-B-W for R-G-B-W
// 8602    *
// 8603    * Always sets all 3 or 4 components. If a component is left out, set to 0.
// 8604    *
// 8605    * Examples:
// 8606    *
// 8607    *   M150 R255       ; Turn LED red
// 8608    *   M150 R255 U127  ; Turn LED orange (PWM only)
// 8609    *   M150            ; Turn LED off
// 8610    *   M150 R U B      ; Turn LED white
// 8611    *   M150 W          ; Turn LED white using a white LED
// 8612    *
// 8613    */
// 8614   inline void gcode_M150() {
// 8615     set_led_color(
// 8616       code_seen('R') ? (code_has_value() ? code_value_byte() : 255) : 0,
// 8617       code_seen('U') ? (code_has_value() ? code_value_byte() : 255) : 0,
// 8618       code_seen('B') ? (code_has_value() ? code_value_byte() : 255) : 0
// 8619       #if ENABLED(RGBW_LED)
// 8620         , code_seen('W') ? (code_has_value() ? code_value_byte() : 255) : 0
// 8621       #endif
// 8622     );
// 8623   }
// 8624 
// 8625 #endif // BLINKM || RGB_LED
// 8626 
// 8627 /**
// 8628  * M200: Set filament diameter and set E axis units to cubic units
// 8629  *
// 8630  *    T<extruder> - Optional extruder number. Current extruder if omitted.
// 8631  *    D<linear> - Diameter of the filament. Use "D0" to switch back to linear units on the E axis.
// 8632  */
// 8633 inline void gcode_M200() {
// 8634 
// 8635   if (get_target_extruder_from_command(200)) return;
// 8636 
// 8637   if (code_seen('D')) {
// 8638     // setting any extruder filament size disables volumetric on the assumption that
// 8639     // slicers either generate in extruder values as cubic mm or as as filament feeds
// 8640     // for all extruders
// 8641     volumetric_enabled = (code_value_linear_units() != 0.0);
// 8642     if (volumetric_enabled) {
// 8643       filament_size[target_extruder] = code_value_linear_units();
// 8644       // make sure all extruders have some sane value for the filament size
// 8645       for (uint8_t i = 0; i < COUNT(filament_size); i++)
// 8646         if (! filament_size[i]) filament_size[i] = DEFAULT_NOMINAL_FILAMENT_DIA;
// 8647     }
// 8648   }
// 8649   calculate_volumetric_multipliers();
// 8650 }
// 8651 
// 8652 /**
// 8653  * M201: Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)
// 8654  *
// 8655  *       With multiple extruders use T to specify which one.
// 8656  */
// 8657 inline void gcode_M201() {
// 8658 
// 8659   GET_TARGET_EXTRUDER(201);
// 8660 
// 8661   LOOP_XYZE(i) {
// 8662     if (code_seen(axis_codes[i])) {
// 8663       const uint8_t a = i + (i == E_AXIS ? TARGET_EXTRUDER : 0);
// 8664       planner.max_acceleration_mm_per_s2[a] = code_value_axis_units((AxisEnum)a);
// 8665     }
// 8666   }
// 8667   // steps per sq second need to be updated to agree with the units per sq second (as they are what is used in the planner)
// 8668   planner.reset_acceleration_rates();
// 8669 }
// 8670 
// 8671 #if 0 // Not used for Sprinter/grbl gen6
// 8672   inline void gcode_M202() {
// 8673     LOOP_XYZE(i) {
// 8674       if (code_seen(axis_codes[i])) axis_travel_steps_per_sqr_second[i] = code_value_axis_units((AxisEnum)i) * planner.axis_steps_per_mm[i];
// 8675     }
// 8676   }
// 8677 #endif
// 8678 
// 8679 
// 8680 /**
// 8681  * M203: Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in units/sec
// 8682  *
// 8683  *       With multiple extruders use T to specify which one.
// 8684  */
// 8685 inline void gcode_M203() {
// 8686 
// 8687   GET_TARGET_EXTRUDER(203);
// 8688 
// 8689   LOOP_XYZE(i)
// 8690     if (code_seen(axis_codes[i])) {
// 8691       const uint8_t a = i + (i == E_AXIS ? TARGET_EXTRUDER : 0);
// 8692       planner.max_feedrate_mm_s[a] = code_value_axis_units((AxisEnum)a);
// 8693     }
// 8694 }
// 8695 
// 8696 /**
// 8697  * M204: Set Accelerations in units/sec^2 (M204 P1200 R3000 T3000)
// 8698  *
// 8699  *    P = Printing moves
// 8700  *    R = Retract only (no X, Y, Z) moves
// 8701  *    T = Travel (non printing) moves
// 8702  *
// 8703  *  Also sets minimum segment time in ms (B20000) to prevent buffer under-runs and M20 minimum feedrate
// 8704  */
// 8705 inline void gcode_M204() {
// 8706   if (code_seen('S')) {  // Kept for legacy compatibility. Should NOT BE USED for new developments.
// 8707     planner.travel_acceleration = planner.acceleration = code_value_linear_units();
// 8708     SERIAL_ECHOLNPAIR("Setting Print and Travel Acceleration: ", planner.acceleration);
// 8709   }
// 8710   if (code_seen('P')) {
// 8711     planner.acceleration = code_value_linear_units();
// 8712     SERIAL_ECHOLNPAIR("Setting Print Acceleration: ", planner.acceleration);
// 8713   }
// 8714   if (code_seen('R')) {
// 8715     planner.retract_acceleration = code_value_linear_units();
// 8716     SERIAL_ECHOLNPAIR("Setting Retract Acceleration: ", planner.retract_acceleration);
// 8717   }
// 8718   if (code_seen('T')) {
// 8719     planner.travel_acceleration = code_value_linear_units();
// 8720     SERIAL_ECHOLNPAIR("Setting Travel Acceleration: ", planner.travel_acceleration);
// 8721   }
// 8722 }
// 8723 
// 8724 /**
// 8725  * M205: Set Advanced Settings
// 8726  *
// 8727  *    S = Min Feed Rate (units/s)
// 8728  *    T = Min Travel Feed Rate (units/s)
// 8729  *    B = Min Segment Time (Âµs)
// 8730  *    X = Max X Jerk (units/sec^2)
// 8731  *    Y = Max Y Jerk (units/sec^2)
// 8732  *    Z = Max Z Jerk (units/sec^2)
// 8733  *    E = Max E Jerk (units/sec^2)
// 8734  */
// 8735 inline void gcode_M205() {
// 8736   if (code_seen('S')) planner.min_feedrate_mm_s = code_value_linear_units();
// 8737   if (code_seen('T')) planner.min_travel_feedrate_mm_s = code_value_linear_units();
// 8738   if (code_seen('B')) planner.min_segment_time = code_value_millis();
// 8739   if (code_seen('X')) planner.max_jerk[X_AXIS] = code_value_linear_units();
// 8740   if (code_seen('Y')) planner.max_jerk[Y_AXIS] = code_value_linear_units();
// 8741   if (code_seen('Z')) planner.max_jerk[Z_AXIS] = code_value_linear_units();
// 8742   if (code_seen('E')) planner.max_jerk[E_AXIS] = code_value_linear_units();
// 8743 }
// 8744 
// 8745 //#if HAS_M206_COMMAND	//mks_delta
// 8746 #if 1
// 8747   /**
// 8748    * M206: Set Additional Homing Offset (X Y Z). SCARA aliases T=X, P=Y
// 8749    */
// 8750   inline void gcode_M206() {
// 8751   	if(MACHINETPYE == DELTA) return;
// 8752     LOOP_XYZ(i)
// 8753       if (code_seen(axis_codes[i]))
// 8754         set_home_offset((AxisEnum)i, code_value_linear_units());
// 8755 
// 8756     //#if ENABLED(MORGAN_SCARA)
// 8757 	if(MACHINETPYE == MORGAN_SCARA)	{
// 8758       if (code_seen('T')) set_home_offset(A_AXIS, code_value_linear_units()); // Theta
// 8759       if (code_seen('P')) set_home_offset(B_AXIS, code_value_linear_units()); // Psi
// 8760     }//#endif
// 8761 
// 8762     SYNC_PLAN_POSITION_KINEMATIC();
// 8763     report_current_position();
// 8764   }
// 8765 
// 8766 #endif // HAS_M206_COMMAND
// 8767 
// 8768 //#if ENABLED(DELTA)	//mks_delta
// 8769 #if 1
// 8770   /**
// 8771    * M665: Set delta configurations
// 8772    *
// 8773    *    H = diagonal rod // AC-version
// 8774    *    L = diagonal rod
// 8775    *    R = delta radius
// 8776    *    S = segments per second
// 8777    *    A = Alpha (Tower 1) diagonal rod trim
// 8778    *    B = Beta (Tower 2) diagonal rod trim
// 8779    *    C = Gamma (Tower 3) diagonal rod trim
// 8780    */
// 8781   inline void gcode_M665() {
// 8782     if (code_seen('H')) {
// 8783       home_offset[Z_AXIS] = code_value_linear_units() - DELTA_HEIGHT;
// 8784       current_position[Z_AXIS] += code_value_linear_units() - DELTA_HEIGHT - home_offset[Z_AXIS];
// 8785       home_offset[Z_AXIS] = code_value_linear_units() - DELTA_HEIGHT;
// 8786       update_software_endstops(Z_AXIS);
// 8787     }
// 8788     if (code_seen('L')) delta_diagonal_rod = code_value_linear_units();
// 8789     if (code_seen('R')) delta_radius = code_value_linear_units();
// 8790     if (code_seen('S')) delta_segments_per_second = code_value_float();
// 8791     if (code_seen('B')) delta_calibration_radius = code_value_float();
// 8792     if (code_seen('X')) delta_tower_angle_trim[A_AXIS] = code_value_linear_units();
// 8793     if (code_seen('Y')) delta_tower_angle_trim[B_AXIS] = code_value_linear_units();
// 8794     if (code_seen('Z')) { // rotate all 3 axis for Z = 0
// 8795       delta_tower_angle_trim[A_AXIS] -= code_value_linear_units();
// 8796       delta_tower_angle_trim[B_AXIS] -= code_value_linear_units();
// 8797     }
// 8798     recalc_delta_settings(delta_radius, delta_diagonal_rod);
// 8799   }
// 8800   /**
// 8801    * M666: Set delta endstop adjustment
// 8802    */
// 8803   inline void gcode_M666() {
// 8804     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 8805       if (DEBUGGING(LEVELING)) {
// 8806         SERIAL_ECHOLNPGM(">>> gcode_M666");
// 8807       }
// 8808     #endif
// 8809     LOOP_XYZ(i) {
// 8810       if (code_seen(axis_codes[i])) {
// 8811         endstop_adj[i] = code_value_linear_units();
// 8812         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 8813           if (DEBUGGING(LEVELING)) {
// 8814             SERIAL_ECHOPAIR("endstop_adj[", axis_codes[i]);
// 8815             SERIAL_ECHOLNPAIR("] = ", endstop_adj[i]);
// 8816           }
// 8817         #endif
// 8818       }
// 8819     }
// 8820     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 8821       if (DEBUGGING(LEVELING)) {
// 8822         SERIAL_ECHOLNPGM("<<< gcode_M666");
// 8823       }
// 8824     #endif
// 8825     // normalize endstops so all are <=0; set the residue to delta height
// 8826     const float z_temp = MAX3(endstop_adj[A_AXIS], endstop_adj[B_AXIS], endstop_adj[C_AXIS]);
// 8827     home_offset[Z_AXIS] -= z_temp;
// 8828     LOOP_XYZ(i) endstop_adj[i] -= z_temp;
// 8829   }
// 8830 
// 8831 #elif ENABLED(Z_DUAL_ENDSTOPS) // !DELTA && ENABLED(Z_DUAL_ENDSTOPS)
// 8832 
// 8833   /**
// 8834    * M666: For Z Dual Endstop setup, set z axis offset to the z2 axis.
// 8835    */
// 8836   inline void gcode_M666() {
// 8837     if (code_seen('Z')) z_endstop_adj = code_value_linear_units();
// 8838     SERIAL_ECHOLNPAIR("Z Endstop Adjustment set to (mm):", z_endstop_adj);
// 8839   }
// 8840 
// 8841 #endif // !DELTA && Z_DUAL_ENDSTOPS
// 8842 
// 8843 #if ENABLED(FWRETRACT)
// 8844 
// 8845   /**
// 8846    * M207: Set firmware retraction values
// 8847    *
// 8848    *   S[+units]    retract_length
// 8849    *   W[+units]    retract_length_swap (multi-extruder)
// 8850    *   F[units/min] retract_feedrate_mm_s
// 8851    *   Z[units]     retract_zlift
// 8852    */
// 8853   inline void gcode_M207() {
// 8854     if (code_seen('S')) retract_length = code_value_axis_units(E_AXIS);
// 8855     if (code_seen('F')) retract_feedrate_mm_s = MMM_TO_MMS(code_value_axis_units(E_AXIS));
// 8856     if (code_seen('Z')) retract_zlift = code_value_linear_units();
// 8857     #if EXTRUDERS > 1
// 8858       if (code_seen('W')) retract_length_swap = code_value_axis_units(E_AXIS);
// 8859     #endif
// 8860   }
// 8861 
// 8862   /**
// 8863    * M208: Set firmware un-retraction values
// 8864    *
// 8865    *   S[+units]    retract_recover_length (in addition to M207 S*)
// 8866    *   W[+units]    retract_recover_length_swap (multi-extruder)
// 8867    *   F[units/min] retract_recover_feedrate_mm_s
// 8868    */
// 8869   inline void gcode_M208() {
// 8870     if (code_seen('S')) retract_recover_length = code_value_axis_units(E_AXIS);
// 8871     if (code_seen('F')) retract_recover_feedrate_mm_s = MMM_TO_MMS(code_value_axis_units(E_AXIS));
// 8872     #if EXTRUDERS > 1
// 8873       if (code_seen('W')) retract_recover_length_swap = code_value_axis_units(E_AXIS);
// 8874     #endif
// 8875   }
// 8876 
// 8877   /**
// 8878    * M209: Enable automatic retract (M209 S1)
// 8879    *   For slicers that don't support G10/11, reversed extrude-only
// 8880    *   moves will be classified as retraction.
// 8881    */
// 8882   inline void gcode_M209() {
// 8883     if (code_seen('S')) {
// 8884       autoretract_enabled = code_value_bool();
// 8885       for (int i = 0; i < EXTRUDERS; i++) retracted[i] = false;
// 8886     }
// 8887   }
// 8888 
// 8889 #endif // FWRETRACT
// 8890 
// 8891 /**
// 8892  * M211: Enable, Disable, and/or Report software endstops
// 8893  *
// 8894  * Usage: M211 S1 to enable, M211 S0 to disable, M211 alone for report
// 8895  */
// 8896 inline void gcode_M211() {
// 8897   SERIAL_ECHO_START;
// 8898   #if HAS_SOFTWARE_ENDSTOPS
// 8899     if (code_seen('S')) soft_endstops_enabled = code_value_bool();
// 8900     SERIAL_ECHOPGM(MSG_SOFT_ENDSTOPS);
// 8901     serialprintPGM(soft_endstops_enabled ? PSTR(MSG_ON) : PSTR(MSG_OFF));
// 8902   #else
// 8903     SERIAL_ECHOPGM(MSG_SOFT_ENDSTOPS);
// 8904     SERIAL_ECHOPGM(MSG_OFF);
// 8905   #endif
// 8906   SERIAL_ECHOPGM(MSG_SOFT_MIN);
// 8907   SERIAL_ECHOPAIR(    MSG_X, soft_endstop_min[X_AXIS]);
// 8908   SERIAL_ECHOPAIR(" " MSG_Y, soft_endstop_min[Y_AXIS]);
// 8909   SERIAL_ECHOPAIR(" " MSG_Z, soft_endstop_min[Z_AXIS]);
// 8910   SERIAL_ECHOPGM(MSG_SOFT_MAX);
// 8911   SERIAL_ECHOPAIR(    MSG_X, soft_endstop_max[X_AXIS]);
// 8912   SERIAL_ECHOPAIR(" " MSG_Y, soft_endstop_max[Y_AXIS]);
// 8913   SERIAL_ECHOLNPAIR(" " MSG_Z, soft_endstop_max[Z_AXIS]);
// 8914 }
// 8915 
// 8916 #if HOTENDS > 1
// 8917 
// 8918   /**
// 8919    * M218 - set hotend offset (in linear units)
// 8920    *
// 8921    *   T<tool>
// 8922    *   X<xoffset>
// 8923    *   Y<yoffset>
// 8924    *   Z<zoffset> - Available with DUAL_X_CARRIAGE and SWITCHING_EXTRUDER
// 8925    */
// 8926   inline void gcode_M218() {
// 8927     if (get_target_extruder_from_command(218) || target_extruder == 0) return;
// 8928 
// 8929     if (code_seen('X')) hotend_offset[X_AXIS][target_extruder] = code_value_linear_units();
// 8930     if (code_seen('Y')) hotend_offset[Y_AXIS][target_extruder] = code_value_linear_units();
// 8931 
// 8932     #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(SWITCHING_EXTRUDER)
// 8933       if (code_seen('Z')) hotend_offset[Z_AXIS][target_extruder] = code_value_linear_units();
// 8934     #endif
// 8935 
// 8936     SERIAL_ECHO_START;
// 8937     SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
// 8938     HOTEND_LOOP() {
// 8939       SERIAL_CHAR(' ');
// 8940       SERIAL_ECHO(hotend_offset[X_AXIS][e]);
// 8941       SERIAL_CHAR(',');
// 8942       SERIAL_ECHO(hotend_offset[Y_AXIS][e]);
// 8943       #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(SWITCHING_EXTRUDER)
// 8944         SERIAL_CHAR(',');
// 8945         SERIAL_ECHO(hotend_offset[Z_AXIS][e]);
// 8946       #endif
// 8947     }
// 8948     SERIAL_EOL;
// 8949   }
// 8950 
// 8951 #endif // HOTENDS > 1
// 8952 
// 8953 /**
// 8954  * M220: Set speed percentage factor, aka "Feed Rate" (M220 S95)
// 8955  */
// 8956 inline void gcode_M220() {
// 8957   if (code_seen('S')) feedrate_percentage = code_value_int();
// 8958 }
// 8959 
// 8960 /**
// 8961  * M221: Set extrusion percentage (M221 T0 S95)
// 8962  */
// 8963 inline void gcode_M221() {
// 8964   if (get_target_extruder_from_command(221)) return;
// 8965   if (code_seen('S'))
// 8966     flow_percentage[target_extruder] = code_value_int();
// 8967 }
// 8968 
// 8969 /**
// 8970  * M226: Wait until the specified pin reaches the state required (M226 P<pin> S<state>)
// 8971  */
// 8972 inline void gcode_M226() {
// 8973   if (code_seen('P')) {
// 8974     int pin_number = code_value_int(),
// 8975         pin_state = code_seen('S') ? code_value_int() : -1; // required pin state - default is inverted
// 8976 
// 8977     if (pin_state >= -1 && pin_state <= 1 && pin_number > -1 && !pin_is_protected(pin_number)) {
// 8978 
// 8979       int target = LOW;
// 8980 
// 8981       stepper.synchronize();
// 8982 
// 8983       pinMode(pin_number, INPUT);
// 8984       switch (pin_state) {
// 8985         case 1:
// 8986           target = HIGH;
// 8987           break;
// 8988         case 0:
// 8989           target = LOW;
// 8990           break;
// 8991         case -1:
// 8992           target = !digitalRead(pin_number);
// 8993           break;
// 8994       }
// 8995 
// 8996       while (digitalRead(pin_number) != target) idle();
// 8997 
// 8998     } // pin_state -1 0 1 && pin_number > -1
// 8999   } // code_seen('P')
// 9000 }
// 9001 
// 9002 #if ENABLED(EXPERIMENTAL_I2CBUS)
// 9003 
// 9004   /**
// 9005    * M260: Send data to a I2C slave device
// 9006    *
// 9007    * This is a PoC, the formating and arguments for the GCODE will
// 9008    * change to be more compatible, the current proposal is:
// 9009    *
// 9010    *  M260 A<slave device address base 10> ; Sets the I2C slave address the data will be sent to
// 9011    *
// 9012    *  M260 B<byte-1 value in base 10>
// 9013    *  M260 B<byte-2 value in base 10>
// 9014    *  M260 B<byte-3 value in base 10>
// 9015    *
// 9016    *  M260 S1 ; Send the buffered data and reset the buffer
// 9017    *  M260 R1 ; Reset the buffer without sending data
// 9018    *
// 9019    */
// 9020   inline void gcode_M260() {
// 9021     // Set the target address
// 9022     if (code_seen('A')) i2c.address(code_value_byte());
// 9023 
// 9024     // Add a new byte to the buffer
// 9025     if (code_seen('B')) i2c.addbyte(code_value_byte());
// 9026 
// 9027     // Flush the buffer to the bus
// 9028     if (code_seen('S')) i2c.send();
// 9029 
// 9030     // Reset and rewind the buffer
// 9031     else if (code_seen('R')) i2c.reset();
// 9032   }
// 9033 
// 9034   /**
// 9035    * M261: Request X bytes from I2C slave device
// 9036    *
// 9037    * Usage: M261 A<slave device address base 10> B<number of bytes>
// 9038    */
// 9039   inline void gcode_M261() {
// 9040     if (code_seen('A')) i2c.address(code_value_byte());
// 9041 
// 9042     uint8_t bytes = code_seen('B') ? code_value_byte() : 1;
// 9043 
// 9044     if (i2c.addr && bytes && bytes <= TWIBUS_BUFFER_SIZE) {
// 9045       i2c.relay(bytes);
// 9046     }
// 9047     else {
// 9048       SERIAL_ERROR_START;
// 9049       SERIAL_ERRORLN("Bad i2c request");
// 9050     }
// 9051   }
// 9052 
// 9053 #endif // EXPERIMENTAL_I2CBUS
// 9054 
// 9055 #if HAS_SERVOS
// 9056 
// 9057   /**
// 9058    * M280: Get or set servo position. P<index> [S<angle>]
// 9059    */
// 9060   inline void gcode_M280() {
// 9061     if (!code_seen('P')) return;
// 9062     int servo_index = code_value_int();
// 9063     if (WITHIN(servo_index, 0, NUM_SERVOS - 1)) {
// 9064       if (code_seen('S'))
// 9065         MOVE_SERVO(servo_index, code_value_int());
// 9066       else {
// 9067         SERIAL_ECHO_START;
// 9068         SERIAL_ECHOPAIR(" Servo ", servo_index);
// 9069         SERIAL_ECHOLNPAIR(": ", servo[servo_index].read());
// 9070       }
// 9071     }
// 9072     else {
// 9073       SERIAL_ERROR_START;
// 9074       SERIAL_ECHOPAIR("Servo ", servo_index);
// 9075       SERIAL_ECHOLNPGM(" out of range");
// 9076     }
// 9077   }
// 9078 
// 9079 #endif // HAS_SERVOS
// 9080 
// 9081 #if HAS_BUZZER
// 9082 //abc
// 9083   /**
// 9084    * M300: Play beep sound S<frequency Hz> P<duration ms>
// 9085    */
// 9086   inline void gcode_M300() {
// 9087     uint16_t const frequency = code_seen('S') ? code_value_ushort() : 260;
// 9088     uint16_t duration = code_seen('P') ? code_value_ushort() : 1000;
// 9089 
// 9090     // Limits the tone duration to 0-5 seconds.
// 9091     NOMORE(duration, 5000);
// 9092 
// 9093     BUZZ(duration, frequency);
// 9094 	
// 9095   }
// 9096 
// 9097 #endif // HAS_BUZZER
// 9098 
// 9099 //#if ENABLED(PIDTEMP)	/*--mks cfg--*/
// 9100 #if 1
// 9101   /**
// 9102    * M301: Set PID parameters P I D (and optionally C, L)
// 9103    *
// 9104    *   P[float] Kp term
// 9105    *   I[float] Ki term (unscaled)
// 9106    *   D[float] Kd term (unscaled)
// 9107    *
// 9108    * With PID_EXTRUSION_SCALING:
// 9109    *
// 9110    *   C[float] Kc term
// 9111    *   L[float] LPQ length
// 9112    */
// 9113   inline void gcode_M301() {
// 9114 
// 9115     // multi-extruder PID patch: M301 updates or prints a single extruder's PID values
// 9116     // default behaviour (omitting E parameter) is to update for extruder 0 only
// 9117     int e = code_seen('E') ? code_value_int() : 0; // extruder being updated
// 9118 
// 9119     if (e < HOTENDS) { // catch bad input value
// 9120       if (code_seen('P')) PID_PARAM(Kp, e) = code_value_float();
// 9121       if (code_seen('I')) PID_PARAM(Ki, e) = scalePID_i(code_value_float());
// 9122       if (code_seen('D')) PID_PARAM(Kd, e) = scalePID_d(code_value_float());
// 9123       #if ENABLED(PID_EXTRUSION_SCALING)
// 9124         if (code_seen('C')) PID_PARAM(Kc, e) = code_value_float();
// 9125         if (code_seen('L')) lpq_len = code_value_float();
// 9126         NOMORE(lpq_len, LPQ_MAX_LEN);
// 9127       #endif
// 9128 
// 9129       thermalManager.updatePID();
// 9130       SERIAL_ECHO_START;
// 9131       #if ENABLED(PID_PARAMS_PER_HOTEND)
// 9132         SERIAL_ECHOPAIR(" e:", e); // specify extruder in serial output
// 9133       #endif // PID_PARAMS_PER_HOTEND
// 9134       SERIAL_ECHOPAIR(" p:", PID_PARAM(Kp, e));
// 9135       SERIAL_ECHOPAIR(" i:", unscalePID_i(PID_PARAM(Ki, e)));
// 9136       SERIAL_ECHOPAIR(" d:", unscalePID_d(PID_PARAM(Kd, e)));
// 9137       #if ENABLED(PID_EXTRUSION_SCALING)
// 9138         //Kc does not have scaling applied above, or in resetting defaults
// 9139         SERIAL_ECHOPAIR(" c:", PID_PARAM(Kc, e));
// 9140       #endif
// 9141       SERIAL_EOL;
// 9142     }
// 9143     else {
// 9144       SERIAL_ERROR_START;
// 9145       SERIAL_ERRORLN(MSG_INVALID_EXTRUDER);
// 9146     }
// 9147   }
// 9148 
// 9149 #endif // PIDTEMP
// 9150 
// 9151 //#if ENABLED(PIDTEMPBED)	/*--mks cfg--*/
// 9152 #if 1
// 9153   inline void gcode_M304() {
// 9154     if (code_seen('P')) thermalManager.bedKp = code_value_float();
// 9155     if (code_seen('I')) thermalManager.bedKi = scalePID_i(code_value_float());
// 9156     if (code_seen('D')) thermalManager.bedKd = scalePID_d(code_value_float());
// 9157 
// 9158     thermalManager.updatePID();
// 9159 
// 9160     SERIAL_ECHO_START;
// 9161     SERIAL_ECHOPAIR(" p:", thermalManager.bedKp);
// 9162     SERIAL_ECHOPAIR(" i:", unscalePID_i(thermalManager.bedKi));
// 9163     SERIAL_ECHOLNPAIR(" d:", unscalePID_d(thermalManager.bedKd));
// 9164   }
// 9165 
// 9166 #endif // PIDTEMPBED
// 9167 
// 9168 #if defined(CHDK) || HAS_PHOTOGRAPH
// 9169 
// 9170   /**
// 9171    * M240: Trigger a camera by emulating a Canon RC-1
// 9172    *       See http://www.doc-diy.net/photo/rc-1_hacked/
// 9173    */
// 9174   inline void gcode_M240() {
// 9175     #ifdef CHDK
// 9176 
// 9177       OUT_WRITE(CHDK, HIGH);
// 9178       chdkHigh = millis();
// 9179       chdkActive = true;
// 9180 
// 9181     #elif HAS_PHOTOGRAPH
// 9182 
// 9183       const uint8_t NUM_PULSES = 16;
// 9184       const float PULSE_LENGTH = 0.01524;
// 9185       for (int i = 0; i < NUM_PULSES; i++) {
// 9186         WRITE(PHOTOGRAPH_PIN, HIGH);
// 9187         _delay_ms(PULSE_LENGTH);
// 9188         WRITE(PHOTOGRAPH_PIN, LOW);
// 9189         _delay_ms(PULSE_LENGTH);
// 9190       }
// 9191       delay(7.33);
// 9192       for (int i = 0; i < NUM_PULSES; i++) {
// 9193         WRITE(PHOTOGRAPH_PIN, HIGH);
// 9194         _delay_ms(PULSE_LENGTH);
// 9195         WRITE(PHOTOGRAPH_PIN, LOW);
// 9196         _delay_ms(PULSE_LENGTH);
// 9197       }
// 9198 
// 9199     #endif // !CHDK && HAS_PHOTOGRAPH
// 9200   }
// 9201 
// 9202 #endif // CHDK || PHOTOGRAPH_PIN
// 9203 
// 9204 #if HAS_LCD_CONTRAST
// 9205 
// 9206   /**
// 9207    * M250: Read and optionally set the LCD contrast
// 9208    */
// 9209   inline void gcode_M250() {
// 9210     if (code_seen('C')) set_lcd_contrast(code_value_int());
// 9211     SERIAL_PROTOCOLPGM("lcd contrast value: ");
// 9212     SERIAL_PROTOCOL(lcd_contrast);
// 9213     SERIAL_EOL;
// 9214   }
// 9215 
// 9216 #endif // HAS_LCD_CONTRAST
// 9217 
// 9218 #if ENABLED(PREVENT_COLD_EXTRUSION)
// 9219 
// 9220   /**
// 9221    * M302: Allow cold extrudes, or set the minimum extrude temperature
// 9222    *
// 9223    *       S<temperature> sets the minimum extrude temperature
// 9224    *       P<bool> enables (1) or disables (0) cold extrusion
// 9225    *
// 9226    *  Examples:
// 9227    *
// 9228    *       M302         ; report current cold extrusion state
// 9229    *       M302 P0      ; enable cold extrusion checking
// 9230    *       M302 P1      ; disables cold extrusion checking
// 9231    *       M302 S0      ; always allow extrusion (disables checking)
// 9232    *       M302 S170    ; only allow extrusion above 170
// 9233    *       M302 S170 P1 ; set min extrude temp to 170 but leave disabled
// 9234    */
// 9235   inline void gcode_M302() {
// 9236     bool seen_S = code_seen('S');
// 9237     if (seen_S) {
// 9238       thermalManager.extrude_min_temp = code_value_temp_abs();
// 9239       thermalManager.allow_cold_extrude = (thermalManager.extrude_min_temp == 0);
// 9240     }
// 9241 
// 9242     if (code_seen('P'))
// 9243       thermalManager.allow_cold_extrude = (thermalManager.extrude_min_temp == 0) || code_value_bool();
// 9244     else if (!seen_S) {
// 9245       // Report current state
// 9246       SERIAL_ECHO_START;
// 9247       SERIAL_ECHOPAIR("Cold extrudes are ", (thermalManager.allow_cold_extrude ? "en" : "dis"));
// 9248       SERIAL_ECHOPAIR("abled (min temp ", int(thermalManager.extrude_min_temp + 0.5));
// 9249       SERIAL_ECHOLNPGM("C)");
// 9250     }
// 9251   }
// 9252 
// 9253 #endif // PREVENT_COLD_EXTRUSION
// 9254 
// 9255 /**
// 9256  * M303: PID relay autotune
// 9257  *
// 9258  *       S<temperature> sets the target temperature. (default 150C)
// 9259  *       E<extruder> (-1 for the bed) (default 0)
// 9260  *       C<cycles>
// 9261  *       U<bool> with a non-zero value will apply the result to current settings
// 9262  */
// 9263 inline void gcode_M303() {
// 9264   //#if HAS_PID_HEATING
// 9265   if(HAS_PID_HEATING) {
// 9266     const int e = code_seen('E') ? code_value_int() : 0,
// 9267               c = code_seen('C') ? code_value_int() : 5;
// 9268     const bool u = code_seen('U') && code_value_bool();
// 9269 
// 9270     int16_t temp = code_seen('S') ? code_value_temp_abs() : (e < 0 ? 70 : 150);
// 9271 
// 9272     if (WITHIN(e, 0, HOTENDS - 1))
// 9273       target_extruder = e;
// 9274 
// 9275     KEEPALIVE_STATE(NOT_BUSY); // don't send "busy: processing" messages during autotune output
// 9276 
// 9277     thermalManager.PID_autotune(temp, e, c, u);
// 9278 
// 9279     KEEPALIVE_STATE(IN_HANDLER);
// 9280   }//#else
// 9281   else {
// 9282     SERIAL_ERROR_START;
// 9283     SERIAL_ERRORLNPGM(MSG_ERR_M303_DISABLED);
// 9284   }//#endif
// 9285 }
// 9286 
// 9287 //#if ENABLED(MORGAN_SCARA)	//mks_delta
// 9288 #if 1

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock65 Using cfiCommon0
          CFI Function _Z17SCARA_move_to_calhh
        THUMB
// 9289   bool SCARA_move_to_cal(uint8_t delta_a, uint8_t delta_b) {
_Z17SCARA_move_to_calhh:
        PUSH     {R1-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+24
        MOV      R4,R0
        MOV      R5,R1
// 9290     if (IsRunning()) {
          CFI FunCall _Z9IsRunningv
        BL       _Z9IsRunningv
        CMP      R0,#+0
        BEQ.N    ??SCARA_move_to_cal_0
// 9291       forward_kinematics_SCARA(delta_a, delta_b);
        MOV      R0,R4
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        STR      R0,[SP, #+4]
        MOV      R0,R5
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        STR      R0,[SP, #+0]
        MOV      R1,SP
        ADD      R0,SP,#+4
          CFI FunCall _Z24forward_kinematics_SCARARKfS0_
        BL       _Z24forward_kinematics_SCARARKfS0_
// 9292       destination[X_AXIS] = LOGICAL_X_POSITION(cartes[X_AXIS]);
        LDR.N    R4,??DataTable136_2
        LDR.W    R5,??DataTable139
        LDR      R1,[R5, #+40]
        LDR      R0,[R4, #+68]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+24]
// 9293       destination[Y_AXIS] = LOGICAL_Y_POSITION(cartes[Y_AXIS]);
        LDR      R1,[R5, #+44]
        LDR      R0,[R4, #+72]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+28]
// 9294       destination[Z_AXIS] = current_position[Z_AXIS];
        LDR      R0,[R4, #+16]
        STR      R0,[R4, #+32]
// 9295       prepare_move_to_destination();
          CFI FunCall _Z27prepare_move_to_destinationv
        BL       _Z27prepare_move_to_destinationv
// 9296       return true;
        MOVS     R0,#+1
        POP      {R1-R5,PC}
// 9297     }
// 9298     return false;
??SCARA_move_to_cal_0:
        MOVS     R0,#+0
        POP      {R1-R5,PC}       ;; return
// 9299   }
          CFI EndBlock cfiBlock65

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable133:
        DC32     0x3ff00000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable133_1:
        DC8      0x20, 0x2F, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable133_2:
        DC8      " B:"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable133_3:
        DC32     mks_heating_busy+0x398

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable133_4:
        DC32     0x9999999a

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable133_5:
        DC32     0x3ff19999
// 9300 
// 9301   /**
// 9302    * M360: SCARA calibration: Move to cal-position ThetaA (0 deg calibration)
// 9303    */
// 9304   inline bool gcode_M360() {
// 9305     SERIAL_ECHOLNPGM(" Cal: Theta 0");
// 9306     return SCARA_move_to_cal(0, 120);
// 9307   }
// 9308 
// 9309   /**
// 9310    * M361: SCARA calibration: Move to cal-position ThetaB (90 deg calibration - steps per degree)
// 9311    */
// 9312   inline bool gcode_M361() {
// 9313     SERIAL_ECHOLNPGM(" Cal: Theta 90");
// 9314     return SCARA_move_to_cal(90, 130);
// 9315   }
// 9316 
// 9317   /**
// 9318    * M362: SCARA calibration: Move to cal-position PsiA (0 deg calibration)
// 9319    */
// 9320   inline bool gcode_M362() {
// 9321     SERIAL_ECHOLNPGM(" Cal: Psi 0");
// 9322     return SCARA_move_to_cal(60, 180);
// 9323   }
// 9324 
// 9325   /**
// 9326    * M363: SCARA calibration: Move to cal-position PsiB (90 deg calibration - steps per degree)
// 9327    */
// 9328   inline bool gcode_M363() {
// 9329     SERIAL_ECHOLNPGM(" Cal: Psi 90");
// 9330     return SCARA_move_to_cal(50, 90);
// 9331   }
// 9332 
// 9333   /**
// 9334    * M364: SCARA calibration: Move to cal-position PSIC (90 deg to Theta calibration position)
// 9335    */
// 9336   inline bool gcode_M364() {
// 9337     SERIAL_ECHOLNPGM(" Cal: Theta-Psi 90");
// 9338     return SCARA_move_to_cal(45, 135);
// 9339   }
// 9340 
// 9341 #endif // SCARA
// 9342 
// 9343 #if ENABLED(EXT_SOLENOID)
// 9344 
// 9345   void enable_solenoid(const uint8_t num) {
// 9346     switch (num) {
// 9347       case 0:
// 9348         OUT_WRITE(SOL0_PIN, HIGH);
// 9349         break;
// 9350         #if HAS_SOLENOID_1 && EXTRUDERS > 1
// 9351           case 1:
// 9352             OUT_WRITE(SOL1_PIN, HIGH);
// 9353             break;
// 9354         #endif
// 9355         #if HAS_SOLENOID_2 && EXTRUDERS > 2
// 9356           case 2:
// 9357             OUT_WRITE(SOL2_PIN, HIGH);
// 9358             break;
// 9359         #endif
// 9360         #if HAS_SOLENOID_3 && EXTRUDERS > 3
// 9361           case 3:
// 9362             OUT_WRITE(SOL3_PIN, HIGH);
// 9363             break;
// 9364         #endif
// 9365         #if HAS_SOLENOID_4 && EXTRUDERS > 4
// 9366           case 4:
// 9367             OUT_WRITE(SOL4_PIN, HIGH);
// 9368             break;
// 9369         #endif
// 9370       default:
// 9371         SERIAL_ECHO_START;
// 9372         SERIAL_ECHOLNPGM(MSG_INVALID_SOLENOID);
// 9373         break;
// 9374     }
// 9375   }
// 9376 
// 9377   void enable_solenoid_on_active_extruder() { enable_solenoid(active_extruder); }
// 9378 
// 9379   void disable_all_solenoids() {
// 9380     OUT_WRITE(SOL0_PIN, LOW);
// 9381     #if HAS_SOLENOID_1 && EXTRUDERS > 1
// 9382       OUT_WRITE(SOL1_PIN, LOW);
// 9383     #endif
// 9384     #if HAS_SOLENOID_2 && EXTRUDERS > 2
// 9385       OUT_WRITE(SOL2_PIN, LOW);
// 9386     #endif
// 9387     #if HAS_SOLENOID_3 && EXTRUDERS > 3
// 9388       OUT_WRITE(SOL3_PIN, LOW);
// 9389     #endif
// 9390     #if HAS_SOLENOID_4 && EXTRUDERS > 4
// 9391       OUT_WRITE(SOL4_PIN, LOW);
// 9392     #endif
// 9393   }
// 9394 
// 9395   /**
// 9396    * M380: Enable solenoid on the active extruder
// 9397    */
// 9398   inline void gcode_M380() { enable_solenoid_on_active_extruder(); }
// 9399 
// 9400   /**
// 9401    * M381: Disable all solenoids
// 9402    */
// 9403   inline void gcode_M381() { disable_all_solenoids(); }
// 9404 
// 9405 #endif // EXT_SOLENOID
// 9406 
// 9407 /**
// 9408  * M400: Finish all moves
// 9409  */
// 9410 inline void gcode_M400() { stepper.synchronize(); }
// 9411 
// 9412 #if HAS_BED_PROBE
// 9413 
// 9414   /**
// 9415    * M401: Engage Z Servo endstop if available
// 9416    */
// 9417   inline void gcode_M401() { DEPLOY_PROBE(); }
// 9418 
// 9419   /**
// 9420    * M402: Retract Z Servo endstop if enabled
// 9421    */
// 9422   inline void gcode_M402() { STOW_PROBE(); }
// 9423 
// 9424 #endif // HAS_BED_PROBE
// 9425 
// 9426 #if ENABLED(FILAMENT_WIDTH_SENSOR)
// 9427 
// 9428   /**
// 9429    * M404: Display or set (in current units) the nominal filament width (3mm, 1.75mm ) W<3.0>
// 9430    */
// 9431   inline void gcode_M404() {
// 9432     if (code_seen('W')) {
// 9433       filament_width_nominal = code_value_linear_units();
// 9434     }
// 9435     else {
// 9436       SERIAL_PROTOCOLPGM("Filament dia (nominal mm):");
// 9437       SERIAL_PROTOCOLLN(filament_width_nominal);
// 9438     }
// 9439   }
// 9440 
// 9441   /**
// 9442    * M405: Turn on filament sensor for control
// 9443    */
// 9444   inline void gcode_M405() {
// 9445     // This is technically a linear measurement, but since it's quantized to centimeters and is a different unit than
// 9446     // everything else, it uses code_value_int() instead of code_value_linear_units().
// 9447     if (code_seen('D')) meas_delay_cm = code_value_int();
// 9448     NOMORE(meas_delay_cm, MAX_MEASUREMENT_DELAY);
// 9449 
// 9450     if (filwidth_delay_index[1] == -1) { // Initialize the ring buffer if not done since startup
// 9451       const int temp_ratio = thermalManager.widthFil_to_size_ratio() - 100; // -100 to scale within a signed byte
// 9452 
// 9453       for (uint8_t i = 0; i < COUNT(measurement_delay); ++i)
// 9454         measurement_delay[i] = temp_ratio;
// 9455 
// 9456       filwidth_delay_index[0] = filwidth_delay_index[1] = 0;
// 9457     }
// 9458 
// 9459     filament_sensor = true;
// 9460 
// 9461     //SERIAL_PROTOCOLPGM("Filament dia (measured mm):");
// 9462     //SERIAL_PROTOCOL(filament_width_meas);
// 9463     //SERIAL_PROTOCOLPGM("Extrusion ratio(%):");
// 9464     //SERIAL_PROTOCOL(flow_percentage[active_extruder]);
// 9465   }
// 9466 
// 9467   /**
// 9468    * M406: Turn off filament sensor for control
// 9469    */
// 9470   inline void gcode_M406() { filament_sensor = false; }
// 9471 
// 9472   /**
// 9473    * M407: Get measured filament diameter on serial output
// 9474    */
// 9475   inline void gcode_M407() {
// 9476     SERIAL_PROTOCOLPGM("Filament dia (measured mm):");
// 9477     SERIAL_PROTOCOLLN(filament_width_meas);
// 9478   }
// 9479 
// 9480 #endif // FILAMENT_WIDTH_SENSOR
// 9481 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock66 Using cfiCommon0
          CFI Function _Z17quickstop_stepperv
        THUMB
// 9482 void quickstop_stepper() {
_Z17quickstop_stepperv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 9483   stepper.quick_stop();
          CFI FunCall _ZN7Stepper10quick_stopEv
        BL       _ZN7Stepper10quick_stopEv
// 9484   stepper.synchronize();
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
// 9485   set_current_from_steppers_for_axis(ALL_AXES);
        MOVS     R0,#+100
          CFI FunCall _Z34set_current_from_steppers_for_axis8AxisEnum
        BL       _Z34set_current_from_steppers_for_axis8AxisEnum
// 9486   SYNC_PLAN_POSITION_KINEMATIC();
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        B.W      _Z28SYNC_PLAN_POSITION_KINEMATICv
// 9487 }
          CFI EndBlock cfiBlock66
// 9488 
// 9489 //#if HAS_LEVELING
// 9490 #if 1
// 9491   /**
// 9492    * M420: Enable/Disable Bed Leveling and/or set the Z fade height.
// 9493    *
// 9494    *   S[bool]   Turns leveling on or off
// 9495    *   Z[height] Sets the Z fade height (0 or none to disable)
// 9496    *   V[bool]   Verbose - Print the leveling grid
// 9497    *
// 9498    * With AUTO_BED_LEVELING_UBL only:
// 9499    *
// 9500    *   L[index]  Load UBL mesh from index (0 is default)
// 9501    */
// 9502   inline void gcode_M420() {
// 9503 
// 9504     //#if ENABLED(AUTO_BED_LEVELING_UBL)
// 9505 	if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)	{
// 9506       // L to load a mesh from the EEPROM
// 9507       if (code_seen('L')) {
// 9508         const int8_t storage_slot = code_has_value() ? code_value_int() : ubl.state.eeprom_storage_slot;
// 9509         const int16_t j = (UBL_LAST_EEPROM_INDEX - ubl.eeprom_start) / sizeof(ubl.z_values);
// 9510         if (!WITHIN(storage_slot, 0, j - 1) || ubl.eeprom_start <= 0) {
// 9511           SERIAL_PROTOCOLLNPGM("?EEPROM storage not available for use.\n");
// 9512           return;
// 9513         }
// 9514 
// 9515         ubl.load_mesh(storage_slot);
// 9516         ubl.state.eeprom_storage_slot = storage_slot;
// 9517       }
// 9518 	}
// 9519     //#endif // AUTO_BED_LEVELING_UBL
// 9520 
// 9521     // V to print the matrix or mesh
// 9522     if (code_seen('V')) {
// 9523 /*--mks cfg--begin MESH_BED_LEVELING */		
// 9524 /*
// 9525 	  #if ABL_PLANAR
// 9526         planner.bed_level_matrix.debug(PSTR("Bed Level Correction Matrix:"));
// 9527       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 9528         if (bilinear_grid_spacing[X_AXIS]) {
// 9529           print_bilinear_leveling_grid();
// 9530           #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 9531             bed_level_virt_print();
// 9532           #endif
// 9533         }
// 9534       #elif ENABLED(MESH_BED_LEVELING)
// 9535         if (mbl.has_mesh()) {
// 9536           SERIAL_ECHOLNPGM("Mesh Bed Level data:");
// 9537           mbl_mesh_report();
// 9538         }
// 9539       #endif
// 9540 */
// 9541 	  if(BED_LEVELING_METHOD&ABL_PLANAR)
// 9542 	  	{
// 9543 	  	planner.bed_level_matrix.debug(PSTR("Bed Level Correction Matrix:"));
// 9544 	  	}
// 9545 		else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
// 9546 			{
// 9547 				if (bilinear_grid_spacing[X_AXIS]) {
// 9548 				  print_bilinear_leveling_grid();
// 9549 				#if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 9550 					bed_level_virt_print();
// 9551 				#endif
// 9552 				}
// 9553 			}
// 9554 	  else if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
// 9555 	  	{
// 9556 		  if (mbl.has_mesh()) {
// 9557 			SERIAL_ECHOLNPGM("Mesh Bed Level data:");
// 9558 			mbl_mesh_report();
// 9559 		  }
// 9560 	  	}
// 9561 /*--mks cfg--end MESH_BED_LEVELING */	  
// 9562     }
// 9563 
// 9564    // #if ENABLED(AUTO_BED_LEVELING_UBL)
// 9565 	if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)	{
// 9566       // L to load a mesh from the EEPROM
// 9567       if (code_seen('L') || code_seen('V')) {
// 9568         ubl.display_map(0);  // Currently only supports one map type
// 9569         SERIAL_ECHOLNPAIR("UBL_MESH_VALID = ", UBL_MESH_VALID);
// 9570         SERIAL_ECHOLNPAIR("eeprom_storage_slot = ", ubl.state.eeprom_storage_slot);
// 9571       }
// 9572 		}
// 9573     //#endif
// 9574 
// 9575     bool to_enable = false;
// 9576     if (code_seen('S')) {
// 9577       to_enable = code_value_bool();
// 9578       set_bed_leveling_enabled(to_enable);
// 9579     }
// 9580 
// 9581     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
// 9582 	if((MACHINETPYE != DELTA) && (BED_LEVELING_METHOD&HAS_FADE))	//mks_delta
// 9583       {if (code_seen('Z')) set_z_fade_height(code_value_linear_units()); }
// 9584     #endif
// 9585 
// 9586 	/*--mks cfg--begin MESH_BED_LEVELING */
// 9587 /*
// 9588     const bool new_status =
// 9589       #if ENABLED(MESH_BED_LEVELING)
// 9590         mbl.active()
// 9591       #elif ENABLED(AUTO_BED_LEVELING_UBL)
// 9592         ubl.state.active
// 9593       #else
// 9594         planner.abl_enabled
// 9595       #endif
// 9596     ;
// 9597 */	  
// 9598 	  bool new_status;
// 9599 
// 9600 	  if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
// 9601 	  	new_status = mbl.active();
// 9602 	  else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
// 9603 	  	new_status = ubl.state.active;
// 9604 	  else
// 9605 		new_status = planner.abl_enabled;
// 9606 	  
// 9607 	  /*--mks cfg--end MESH_BED_LEVELING */
// 9608 
// 9609     if (to_enable && !new_status) {
// 9610       SERIAL_ERROR_START;
// 9611       SERIAL_ERRORLNPGM(MSG_ERR_M420_FAILED);
// 9612     }
// 9613 
// 9614     SERIAL_ECHO_START;
// 9615     SERIAL_ECHOLNPAIR("Bed Leveling ", new_status ? MSG_ON : MSG_OFF);
// 9616   }
// 9617 #endif
// 9618 
// 9619 //#if ENABLED(MESH_BED_LEVELING)
// 9620 #if 1 /*--mks cfg-- MESH_BED_LEVELING */
// 9621   /**
// 9622    * M421: Set a single Mesh Bed Leveling Z coordinate
// 9623    * Use either 'M421 X<linear> Y<linear> Z<linear>' or 'M421 I<xindex> J<yindex> Z<linear>'
// 9624    */
// 9625 //  inline void gcode_M421() {	/*--mks cfg-- MESH_BED_LEVELING */
// 9626   inline void gcode_M421_MESH_BED_LEVELING() {
// 9627     int8_t px = 0, py = 0;
// 9628     float z = 0;
// 9629     bool hasX, hasY, hasZ, hasI, hasJ;
// 9630     if ((hasX = code_seen('X'))) px = mbl.probe_index_x(code_value_linear_units());
// 9631     if ((hasY = code_seen('Y'))) py = mbl.probe_index_y(code_value_linear_units());
// 9632     if ((hasI = code_seen('I'))) px = code_value_linear_units();
// 9633     if ((hasJ = code_seen('J'))) py = code_value_linear_units();
// 9634     if ((hasZ = code_seen('Z'))) z = code_value_linear_units();
// 9635 
// 9636     if (hasX && hasY && hasZ) {
// 9637 
// 9638       if (px >= 0 && py >= 0)
// 9639         mbl.set_z(px, py, z);
// 9640       else {
// 9641         SERIAL_ERROR_START;
// 9642         SERIAL_ERRORLNPGM(MSG_ERR_MESH_XY);
// 9643       }
// 9644     }
// 9645     else if (hasI && hasJ && hasZ) {
// 9646       if (WITHIN(px, 0, GRID_MAX_POINTS_X - 1) && WITHIN(py, 0, GRID_MAX_POINTS_Y - 1))
// 9647         mbl.set_z(px, py, z);
// 9648       else {
// 9649         SERIAL_ERROR_START;
// 9650         SERIAL_ERRORLNPGM(MSG_ERR_MESH_XY);
// 9651       }
// 9652     }
// 9653     else {
// 9654       SERIAL_ERROR_START;
// 9655       SERIAL_ERRORLNPGM(MSG_ERR_M421_PARAMETERS);
// 9656     }
// 9657   }
// 9658 
// 9659 /*--mks cfg-- AUTO_BED_LEVELING_BILINEAR */
// 9660 #endif
// 9661 //#elif ENABLED(AUTO_BED_LEVELING_BILINEAR) || ENABLED(AUTO_BED_LEVELING_UBL)
// 9662 #if 1
// 9663   /**
// 9664    * M421: Set a single Mesh Bed Leveling Z coordinate
// 9665    *
// 9666    *   M421 I<xindex> J<yindex> Z<linear>
// 9667    */
// 9668   inline void gcode_M421() {
// 9669     int8_t px = 0, py = 0;
// 9670     float z = 0;
// 9671     bool hasI, hasJ, hasZ;
// 9672     if ((hasI = code_seen('I'))) px = code_value_linear_units();
// 9673     if ((hasJ = code_seen('J'))) py = code_value_linear_units();
// 9674     if ((hasZ = code_seen('Z'))) z = code_value_linear_units();
// 9675 
// 9676     if (hasI && hasJ && hasZ) {
// 9677       if (WITHIN(px, 0, GRID_MAX_POINTS_X - 1) && WITHIN(py, 0, GRID_MAX_POINTS_X - 1)) {
// 9678         //#if ENABLED(AUTO_BED_LEVELING_UBL)
// 9679 		if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
// 9680           ubl.z_values[px][py] = z;
// 9681         //#else
// 9682         else {
// 9683           z_values[px][py] = z;
// 9684           #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 9685             bed_level_virt_interpolate();
// 9686           #endif
// 9687         }//#endif
// 9688       }
// 9689       else {
// 9690         SERIAL_ERROR_START;
// 9691         SERIAL_ERRORLNPGM(MSG_ERR_MESH_XY);
// 9692       }
// 9693     }
// 9694     else {
// 9695       SERIAL_ERROR_START;
// 9696       SERIAL_ERRORLNPGM(MSG_ERR_M421_PARAMETERS);
// 9697     }
// 9698   }
// 9699 
// 9700 #endif
// 9701 
// 9702 //#if HAS_M206_COMMAND	//mks_delta
// 9703 #if 1
// 9704   /**
// 9705    * M428: Set home_offset based on the distance between the
// 9706    *       current_position and the nearest "reference point."
// 9707    *       If an axis is past center its endstop position
// 9708    *       is the reference-point. Otherwise it uses 0. This allows
// 9709    *       the Z offset to be set near the bed when using a max endstop.
// 9710    *
// 9711    *       M428 can't be used more than 2cm away from 0 or an endstop.
// 9712    *
// 9713    *       Use M206 to set these values directly.
// 9714    */
// 9715   inline void gcode_M428() {
// 9716   	if(MACHINETPYE == DELTA) return;
// 9717     bool err = false;
// 9718     LOOP_XYZ(i) {
// 9719       if (axis_homed[i]) {
// 9720         float base = (current_position[i] > (soft_endstop_min[i] + soft_endstop_max[i]) * 0.5) ? base_home_pos((AxisEnum)i) : 0,
// 9721               diff = current_position[i] - LOGICAL_POSITION(base, i);
// 9722         if (WITHIN(diff, -20, 20)) {
// 9723           set_home_offset((AxisEnum)i, home_offset[i] - diff);
// 9724         }
// 9725         else {
// 9726           SERIAL_ERROR_START;
// 9727           SERIAL_ERRORLNPGM(MSG_ERR_M428_TOO_FAR);
// 9728           LCD_ALERTMESSAGEPGM("Err: Too far!");
// 9729 		  BUZZ(200, 40);
// 9730           err = true;
// 9731           break;
// 9732         }
// 9733       }
// 9734     }
// 9735 
// 9736     if (!err) {
// 9737       SYNC_PLAN_POSITION_KINEMATIC();
// 9738       report_current_position();
// 9739       LCD_MESSAGEPGM(MSG_HOME_OFFSETS_APPLIED);
// 9740 	  BUZZ(100, 659);
// 9741 	  BUZZ(100, 698);
// 9742     }
// 9743   }
// 9744 
// 9745 #endif // HAS_M206_COMMAND
// 9746 
// 9747 /**
// 9748  * M500: Store settings in EEPROM
// 9749  */
// 9750 inline void gcode_M500() {
// 9751   (void)settings.save();
// 9752 }
// 9753 
// 9754 /**
// 9755  * M501: Read settings from EEPROM
// 9756  */
// 9757 inline void gcode_M501() {
// 9758   (void)settings.load();
// 9759 }
// 9760 
// 9761 /**
// 9762  * M502: Revert to default settings
// 9763  */
// 9764 inline void gcode_M502() {
// 9765   (void)settings.reset();
// 9766 }
// 9767 
// 9768 /**
// 9769  * M503: print settings currently in memory
// 9770  */
// 9771 inline void gcode_M503() {
// 9772   (void)settings.report(code_seen('S') && !code_value_bool());
// 9773 }
// 9774 
// 9775 #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
// 9776 
// 9777   /**
// 9778    * M540: Set whether SD card print should abort on endstop hit (M540 S<0|1>)
// 9779    */
// 9780   inline void gcode_M540() {
// 9781     if (code_seen('S')) stepper.abort_on_endstop_hit = code_value_bool();
// 9782   }
// 9783 
// 9784 #endif // ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
// 9785 
// 9786 #if HAS_BED_PROBE
// 9787 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock67 Using cfiCommon0
          CFI Function _Z22refresh_zprobe_zoffsetb
        THUMB
// 9788   void refresh_zprobe_zoffset(const bool no_babystep/*=false*/) {
_Z22refresh_zprobe_zoffsetb:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
// 9789     static float last_zoffset = NAN;
// 9790 
// 9791     if (!isnan(last_zoffset)) {
        LDR.W    R4,??DataTable139
        LDR      R0,[R4, #+92]
          CFI FunCall _Z5isnanf
        BL       _Z5isnanf
        CMP      R0,#+0
        BNE.N    ??refresh_zprobe_zoffset_0
// 9792 
// 9793 	  /*--mks cfg--begin AUTO_BED_LEVELING_BILINEAR */
// 9794 /*
// 9795       #if ENABLED(AUTO_BED_LEVELING_BILINEAR) || ENABLED(BABYSTEP_ZPROBE_OFFSET) || ENABLED(DELTA)
// 9796         const float diff = zprobe_zoffset - last_zoffset;
// 9797       #endif
// 9798 */			  
// 9799 	  float diff;
// 9800 //#if  ENABLED(BABYSTEP_ZPROBE_OFFSET) || ENABLED(DELTA)
// 9801 	if(MACHINETPYE == DELTA)
        LDR.N    R5,??DataTable136_8
        ADD      R8,R5,#+64
        LDRSH    R6,[R8, #+24]
        CMP      R6,#+2
        BNE.N    ??refresh_zprobe_zoffset_1
// 9802 		diff = zprobe_zoffset - last_zoffset;
        LDR      R0,[R4, #+72]
        LDR      R1,[R4, #+92]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R7,R0
// 9803 //#endif	  
// 9804 	if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
??refresh_zprobe_zoffset_1:
        LDRB     R8,[R8, #+0]
        CMP      R8,#+8
        BNE.N    ??refresh_zprobe_zoffset_2
// 9805 		diff = zprobe_zoffset - last_zoffset;
        LDR      R0,[R4, #+72]
        LDR      R1,[R4, #+92]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R7,R0
// 9806 	  /*--mks cfg--end AUTO_BED_LEVELING_BILINEAR */
// 9807 
// 9808 	  /*--mks cfg--begin AUTO_BED_LEVELING_BILINEAR */
// 9809 /*
// 9810       #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 9811         // Correct bilinear grid for new probe offset
// 9812         if (diff) {
// 9813           for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
// 9814             for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
// 9815               z_values[x][y] -= diff;
// 9816         }
// 9817         #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 9818           bed_level_virt_interpolate();
// 9819         #endif
// 9820       #endif
// 9821 */
// 9822 	if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
??refresh_zprobe_zoffset_2:
        CMP      R8,#+8
        BNE.N    ??refresh_zprobe_zoffset_3
// 9823 		{
// 9824         // Correct bilinear grid for new probe offset
// 9825         if (diff) {
        MOV      R0,R7
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??refresh_zprobe_zoffset_3
// 9826           for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
        MOV      R9,R1
        ADD      R8,R5,#+96
        B.N      ??refresh_zprobe_zoffset_4
// 9827             for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
// 9828               z_values[x][y] -= diff;
??refresh_zprobe_zoffset_5:
        LDR.W    R0,??DataTable139_1
        ADD      R11,R0,R9, LSL #+6
        LDR      R0,[R11, R10, LSL #+2]
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R11, R10, LSL #+2]
        ADD      R10,R10,#+1
        UXTB     R10,R10
??refresh_zprobe_zoffset_6:
        LDRB     R0,[R8, #+1]
        CMP      R10,R0
        BLT.N    ??refresh_zprobe_zoffset_5
        ADD      R9,R9,#+1
        UXTB     R9,R9
??refresh_zprobe_zoffset_4:
        LDRB     R0,[R8, #+0]
        CMP      R9,R0
        BGE.N    ??refresh_zprobe_zoffset_3
        MOV      R10,#+0
        B.N      ??refresh_zprobe_zoffset_6
// 9829         }
// 9830   #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 9831           bed_level_virt_interpolate();
// 9832   #endif
// 9833 		}
// 9834 	  /*--mks cfg--end AUTO_BED_LEVELING_BILINEAR */
// 9835 
// 9836       #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
// 9837         if (!no_babystep && planner.abl_enabled)
// 9838           thermalManager.babystep_axis(Z_AXIS, -lround(diff * planner.axis_steps_per_mm[Z_AXIS]));
// 9839       #else
// 9840         UNUSED(no_babystep);
// 9841       #endif
// 9842 
// 9843       //#if ENABLED(DELTA) // correct the delta_height
// 9844 	  if(MACHINETPYE == DELTA)
??refresh_zprobe_zoffset_3:
        CMP      R6,#+2
        BNE.N    ??refresh_zprobe_zoffset_0
// 9845         home_offset[Z_AXIS] -= diff;
        LDR.N    R5,??DataTable136_2
        LDR      R0,[R5, #+64]
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R5, #+64]
// 9846      // #endif
// 9847     }
// 9848 
// 9849     last_zoffset = zprobe_zoffset;
??refresh_zprobe_zoffset_0:
        LDR      R0,[R4, #+72]
        STR      R0,[R4, #+92]
// 9850   }
        POP      {R0,R4-R11,PC}   ;; return
          CFI EndBlock cfiBlock67

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable134:
        DC8      " @:"
// 9851 
// 9852   inline void gcode_M851() {
// 9853     SERIAL_ECHO_START;
// 9854     SERIAL_ECHOPGM(MSG_ZPROBE_ZOFFSET " ");
// 9855     if (code_seen('Z')) {
// 9856       const float value = code_value_linear_units();
// 9857       if (WITHIN(value, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
// 9858         zprobe_zoffset = value;
// 9859         refresh_zprobe_zoffset();
// 9860         SERIAL_ECHO(zprobe_zoffset);
// 9861       }
// 9862       else
// 9863         SERIAL_ECHOPGM(MSG_Z_MIN " " STRINGIFY(Z_PROBE_OFFSET_RANGE_MIN) " " MSG_Z_MAX " " STRINGIFY(Z_PROBE_OFFSET_RANGE_MAX));
// 9864     }
// 9865     else
// 9866       SERIAL_ECHOPAIR(": ", zprobe_zoffset);
// 9867 
// 9868     SERIAL_EOL;
// 9869   }
// 9870 
// 9871 #endif // HAS_BED_PROBE
// 9872 
// 9873 #if ENABLED(FILAMENT_CHANGE_FEATURE)
// 9874 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock68 Using cfiCommon0
          CFI Function _Z20filament_change_beepb
        THUMB
// 9875   void filament_change_beep(const bool init=false) {
_Z20filament_change_beepb:
        PUSH     {R2-R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+16
// 9876     static millis_t next_buzz = 0;
// 9877     static uint16_t runout_beep = 0;
// 9878 
// 9879     if (init) next_buzz = runout_beep = 0;
        LDR.W    R4,??DataTable139_2
        CMP      R0,#+0
        BEQ.N    ??filament_change_beep_0
        MOVS     R0,#+0
        STRH     R0,[R4, #+0]
        STR      R0,[R4, #+4]
// 9880 
// 9881     const millis_t ms = millis();
??filament_change_beep_0:
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
// 9882     if (ELAPSED(ms, next_buzz)) {
        LDR      R1,[R4, #+4]
        SUBS     R1,R0,R1
        BMI.N    ??filament_change_beep_1
// 9883       if (runout_beep <= FILAMENT_CHANGE_NUMBER_OF_ALERT_BEEPS + 5) { // Only beep as long as we're supposed to
        LDRH     R1,[R4, #+0]
        CMP      R1,#+11
        BGE.N    ??filament_change_beep_1
// 9884         next_buzz = ms + (runout_beep <= FILAMENT_CHANGE_NUMBER_OF_ALERT_BEEPS ? 2500 : 400);
        CMP      R1,#+6
        BGE.N    ??filament_change_beep_2
        MOVW     R1,#+2500
        B.N      ??filament_change_beep_3
??filament_change_beep_2:
        MOV      R1,#+400
??filament_change_beep_3:
        ADDS     R0,R1,R0
        STR      R0,[R4, #+4]
// 9885 		BUZZ(300, 2000);
        MOV      R0,#+300
        STRH     R0,[SP, #+2]
        MOV      R0,#+2000
        STRH     R0,[SP, #+0]
        MOV      R2,SP
        ADD      R1,SP,#+2
        LDR.W    R0,??DataTable139_3
          CFI FunCall _ZN6Buzzer4toneERKtS1_
        BL       _ZN6Buzzer4toneERKtS1_
// 9886         runout_beep++;
        LDRH     R0,[R4, #+0]
        ADDS     R0,R0,#+1
        STRH     R0,[R4, #+0]
// 9887       }
// 9888     }
// 9889   }
??filament_change_beep_1:
        POP      {R0,R1,R4,PC}    ;; return
          CFI EndBlock cfiBlock68

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable135:
        DC8      0x58, 0x3A, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable135_1:
        DC8      " Y:"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable135_2:
        DC32     endstop_adj
// 9890 
// 9891   static bool busy_doing_M600 = false;
// 9892 
// 9893   /**
// 9894    * M600: Pause for filament change
// 9895    *
// 9896    *  E[distance] - Retract the filament this far (negative value)
// 9897    *  Z[distance] - Move the Z axis by this distance
// 9898    *  X[position] - Move to this X position, with Y
// 9899    *  Y[position] - Move to this Y position, with X
// 9900    *  L[distance] - Retract distance for removal (manual reload)
// 9901    *
// 9902    *  Default values are used for omitted arguments.
// 9903    *
// 9904    */
// 9905   inline void gcode_M600() {
// 9906 
// 9907     if (!DEBUGGING(DRYRUN) && thermalManager.tooColdToExtrude(active_extruder)) {
// 9908       SERIAL_ERROR_START;
// 9909       SERIAL_ERRORLNPGM(MSG_TOO_COLD_FOR_M600);
// 9910       return;
// 9911     }
// 9912 
// 9913     busy_doing_M600 = true;  // Stepper Motors can't timeout when this is set
// 9914 	
// 9915 
// 9916     // Pause the print job timer
// 9917     const bool job_running = print_job_timer.isRunning();
// 9918 
// 9919     print_job_timer.pause();
// 9920 
// 9921     // Show initial message and wait for synchronize steppers
// 9922     lcd_filament_change_show_message(FILAMENT_CHANGE_MESSAGE_INIT);
// 9923     stepper.synchronize();
// 9924 
// 9925     // Save current position of all axes
// 9926     float lastpos[XYZE];
// 9927     COPY(lastpos, current_position);
// 9928     set_destination_to_current();
// 9929 
// 9930     // Initial retract before move to filament change position
// 9931     destination[E_AXIS] += code_seen('E') ? code_value_axis_units(E_AXIS) : 0
// 9932       #if defined(FILAMENT_CHANGE_RETRACT_LENGTH) && FILAMENT_CHANGE_RETRACT_LENGTH > 0
// 9933         - (FILAMENT_CHANGE_RETRACT_LENGTH)
// 9934       #endif
// 9935     ;
// 9936 
// 9937     RUNPLAN(FILAMENT_CHANGE_RETRACT_FEEDRATE);
// 9938 
// 9939     // Lift Z axis
// 9940 /*    
// 9941     float z_lift = code_seen('Z') ? code_value_linear_units() :
// 9942       #if defined(FILAMENT_CHANGE_Z_ADD) && FILAMENT_CHANGE_Z_ADD > 0
// 9943         FILAMENT_CHANGE_Z_ADD
// 9944       #else
// 9945         0
// 9946       #endif
// 9947     ;
// 9948 */
// 9949     float z_lift = code_seen('Z') ? code_value_linear_units() :FILAMENT_CHANGE_Z_ADD;
// 9950     
// 9951     if (z_lift > 0) {
// 9952       destination[Z_AXIS] += z_lift;
// 9953       NOMORE(destination[Z_AXIS], Z_MAX_POS);
// 9954       RUNPLAN(FILAMENT_CHANGE_Z_FEEDRATE);
// 9955     }
// 9956 
// 9957     // Move XY axes to filament exchange position
// 9958     if (code_seen('X')) destination[X_AXIS] = code_value_linear_units();
// 9959     #ifdef FILAMENT_CHANGE_X_POS
// 9960       else destination[X_AXIS] = FILAMENT_CHANGE_X_POS;
// 9961     #endif
// 9962 
// 9963     if (code_seen('Y')) destination[Y_AXIS] = code_value_linear_units();
// 9964     #ifdef FILAMENT_CHANGE_Y_POS
// 9965       else destination[Y_AXIS] = FILAMENT_CHANGE_Y_POS;
// 9966     #endif
// 9967 
// 9968     RUNPLAN(FILAMENT_CHANGE_XY_FEEDRATE);
// 9969 
// 9970     stepper.synchronize();
// 9971     lcd_filament_change_show_message(FILAMENT_CHANGE_MESSAGE_UNLOAD);
// 9972     idle();
// 9973 
// 9974     // Unload filament
// 9975     destination[E_AXIS] += code_seen('L') ? code_value_axis_units(E_AXIS) : 0
// 9976       #if FILAMENT_CHANGE_UNLOAD_LENGTH > 0
// 9977         - (FILAMENT_CHANGE_UNLOAD_LENGTH)
// 9978       #endif
// 9979     ;
// 9980 
// 9981     RUNPLAN(FILAMENT_CHANGE_UNLOAD_FEEDRATE);
// 9982 
// 9983     // Synchronize steppers and then disable extruders steppers for manual filament changing
// 9984     stepper.synchronize();
// 9985     disable_e_steppers();
// 9986     safe_delay(100);
// 9987 
// 9988     const millis_t nozzle_timeout = millis() + (millis_t)(FILAMENT_CHANGE_NOZZLE_TIMEOUT) * 1000UL;
// 9989     bool nozzle_timed_out = false;
// 9990 
// 9991     // Wait for filament insert by user and press button
// 9992     lcd_filament_change_show_message(FILAMENT_CHANGE_MESSAGE_INSERT);
// 9993 
// 9994     #if HAS_BUZZER
// 9995       filament_change_beep(true);
// 9996     #endif
// 9997 
// 9998     idle();
// 9999 
// 10000     int16_t temps[HOTENDS];
// 10001     HOTEND_LOOP() temps[e] = thermalManager.target_temperature[e]; // Save nozzle temps
// 10002 
// 10003     KEEPALIVE_STATE(PAUSED_FOR_USER);
// 10004     wait_for_user = true;    // LCD click or M108 will clear this
// 10005     while (wait_for_user) {
// 10006 
// 10007       if (nozzle_timed_out)
// 10008         lcd_filament_change_show_message(FILAMENT_CHANGE_MESSAGE_CLICK_TO_HEAT_NOZZLE);
// 10009 
// 10010       #if HAS_BUZZER
// 10011         filament_change_beep();
// 10012       #endif
// 10013 
// 10014       if (!nozzle_timed_out && ELAPSED(millis(), nozzle_timeout)) {
// 10015         nozzle_timed_out = true; // on nozzle timeout remember the nozzles need to be reheated
// 10016         HOTEND_LOOP() thermalManager.setTargetHotend(0, e); // Turn off all the nozzles
// 10017         lcd_filament_change_show_message(FILAMENT_CHANGE_MESSAGE_CLICK_TO_HEAT_NOZZLE);
// 10018       }
// 10019       idle(true);
// 10020     }
// 10021     KEEPALIVE_STATE(IN_HANDLER);
// 10022 
// 10023     if (nozzle_timed_out)      // Turn nozzles back on if they were turned off
// 10024       HOTEND_LOOP() thermalManager.setTargetHotend(temps[e], e);
// 10025 
// 10026     // Show "wait for heating"
// 10027     lcd_filament_change_show_message(FILAMENT_CHANGE_MESSAGE_WAIT_FOR_NOZZLES_TO_HEAT);
// 10028 
// 10029     wait_for_heatup = true;
// 10030     while (wait_for_heatup) {
// 10031       idle();
// 10032       wait_for_heatup = false;
// 10033       HOTEND_LOOP() {
// 10034 	  	
// 10035         if (abs(thermalManager.degHotend(e) - temps[e]) > 3) {
// 10036           wait_for_heatup = true;
// 10037           break;
// 10038         }
// 10039       }
// 10040     }
// 10041 
// 10042     // Show "insert filament"
// 10043     if (nozzle_timed_out)
// 10044       lcd_filament_change_show_message(FILAMENT_CHANGE_MESSAGE_INSERT);
// 10045 
// 10046     #if HAS_BUZZER
// 10047       filament_change_beep(true);
// 10048     #endif
// 10049 
// 10050     KEEPALIVE_STATE(PAUSED_FOR_USER);
// 10051     wait_for_user = true;    // LCD click or M108 will clear this
// 10052     while (wait_for_user && nozzle_timed_out) {
// 10053       #if HAS_BUZZER
// 10054         filament_change_beep();
// 10055       #endif
// 10056       idle(true);
// 10057     }
// 10058     KEEPALIVE_STATE(IN_HANDLER);
// 10059 
// 10060     // Show "load" message
// 10061     lcd_filament_change_show_message(FILAMENT_CHANGE_MESSAGE_LOAD);
// 10062 
// 10063     // Load filament
// 10064     destination[E_AXIS] += code_seen('L') ? -code_value_axis_units(E_AXIS) : 0
// 10065       #if FILAMENT_CHANGE_LOAD_LENGTH > 0
// 10066         + FILAMENT_CHANGE_LOAD_LENGTH
// 10067       #endif
// 10068     ;
// 10069 
// 10070     RUNPLAN(FILAMENT_CHANGE_LOAD_FEEDRATE);
// 10071     stepper.synchronize();
// 10072 
// 10073     #if defined(FILAMENT_CHANGE_EXTRUDE_LENGTH) && FILAMENT_CHANGE_EXTRUDE_LENGTH > 0
// 10074 
// 10075       do {
// 10076         // "Wait for filament extrude"
// 10077         lcd_filament_change_show_message(FILAMENT_CHANGE_MESSAGE_EXTRUDE);
// 10078 
// 10079         // Extrude filament to get into hotend
// 10080         destination[E_AXIS] += FILAMENT_CHANGE_EXTRUDE_LENGTH;
// 10081         RUNPLAN(FILAMENT_CHANGE_EXTRUDE_FEEDRATE);
// 10082         stepper.synchronize();
// 10083 
// 10084         // Show "Extrude More" / "Resume" menu and wait for reply
// 10085         KEEPALIVE_STATE(PAUSED_FOR_USER);
// 10086         wait_for_user = false;
// 10087         lcd_filament_change_show_message(FILAMENT_CHANGE_MESSAGE_OPTION);
// 10088         while (filament_change_menu_response == FILAMENT_CHANGE_RESPONSE_WAIT_FOR) idle(true);
// 10089         KEEPALIVE_STATE(IN_HANDLER);
// 10090 
// 10091         // Keep looping if "Extrude More" was selected
// 10092       } while (filament_change_menu_response == FILAMENT_CHANGE_RESPONSE_EXTRUDE_MORE);
// 10093 
// 10094     #endif
// 10095 
// 10096     // "Wait for print to resume"
// 10097     lcd_filament_change_show_message(FILAMENT_CHANGE_MESSAGE_RESUME);
// 10098 
// 10099     // Set extruder to saved position
// 10100     destination[E_AXIS] = current_position[E_AXIS] = lastpos[E_AXIS];
// 10101     planner.set_e_position_mm(current_position[E_AXIS]);
// 10102 
// 10103    //if IS_KINEMATIC	//mks_delta
// 10104 	if(MACHINETPYE & IS_KINEMATIC)
// 10105       // Move XYZ to starting position
// 10106       planner.buffer_line_kinematic(lastpos, FILAMENT_CHANGE_XY_FEEDRATE, active_extruder);
// 10107     //#else
// 10108     else{
// 10109       // Move XY to starting position, then Z
// 10110       destination[X_AXIS] = lastpos[X_AXIS];
// 10111       destination[Y_AXIS] = lastpos[Y_AXIS];
// 10112       RUNPLAN(FILAMENT_CHANGE_XY_FEEDRATE);
// 10113       destination[Z_AXIS] = lastpos[Z_AXIS];
// 10114       RUNPLAN(FILAMENT_CHANGE_Z_FEEDRATE);}
// 10115     //#endif
// 10116     stepper.synchronize();
// 10117 
// 10118     #if ENABLED(FILAMENT_RUNOUT_SENSOR)
// 10119       filament_ran_out = false;
// 10120     #endif
// 10121 
// 10122     // Show status screen
// 10123     lcd_filament_change_show_message(FILAMENT_CHANGE_MESSAGE_STATUS);
// 10124 
// 10125     // Resume the print job timer if it was running
// 10126     if (job_running) print_job_timer.start();
// 10127 
// 10128     busy_doing_M600 = false;  // Allow Stepper Motors to be turned off during inactivity
// 10129   }
// 10130 
// 10131 #endif // FILAMENT_CHANGE_FEATURE
// 10132 
// 10133 #if ENABLED(DUAL_X_CARRIAGE)
// 10134 
// 10135   /**
// 10136    * M605: Set dual x-carriage movement mode
// 10137    *
// 10138    *    M605 S0: Full control mode. The slicer has full control over x-carriage movement
// 10139    *    M605 S1: Auto-park mode. The inactive head will auto park/unpark without slicer involvement
// 10140    *    M605 S2 [Xnnn] [Rmmm]: Duplication mode. The second extruder will duplicate the first with nnn
// 10141    *                         units x-offset and an optional differential hotend temperature of
// 10142    *                         mmm degrees. E.g., with "M605 S2 X100 R2" the second extruder will duplicate
// 10143    *                         the first with a spacing of 100mm in the x direction and 2 degrees hotter.
// 10144    *
// 10145    *    Note: the X axis should be homed after changing dual x-carriage mode.
// 10146    */
// 10147   inline void gcode_M605() {
// 10148     stepper.synchronize();
// 10149     if (code_seen('S')) dual_x_carriage_mode = (DualXMode)code_value_byte();
// 10150     switch (dual_x_carriage_mode) {
// 10151       case DXC_FULL_CONTROL_MODE:
// 10152       case DXC_AUTO_PARK_MODE:
// 10153         break;
// 10154       case DXC_DUPLICATION_MODE:
// 10155         if (code_seen('X')) duplicate_extruder_x_offset = max(code_value_linear_units(), X2_MIN_POS - x_home_pos(0));
// 10156         if (code_seen('R')) duplicate_extruder_temp_offset = code_value_temp_diff();
// 10157         SERIAL_ECHO_START;
// 10158         SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
// 10159         SERIAL_CHAR(' ');
// 10160         SERIAL_ECHO(hotend_offset[X_AXIS][0]);
// 10161         SERIAL_CHAR(',');
// 10162         SERIAL_ECHO(hotend_offset[Y_AXIS][0]);
// 10163         SERIAL_CHAR(' ');
// 10164         SERIAL_ECHO(duplicate_extruder_x_offset);
// 10165         SERIAL_CHAR(',');
// 10166         SERIAL_ECHOLN(hotend_offset[Y_AXIS][1]);
// 10167         break;
// 10168       default:
// 10169         dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
// 10170         break;
// 10171     }
// 10172     active_extruder_parked = false;
// 10173     extruder_duplication_enabled = false;
// 10174     delayed_move_time = 0;
// 10175   }
// 10176 
// 10177 #elif ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
// 10178 
// 10179   inline void gcode_M605() {
// 10180     stepper.synchronize();
// 10181     extruder_duplication_enabled = code_seen('S') && code_value_int() == (int)DXC_DUPLICATION_MODE;
// 10182     SERIAL_ECHO_START;
// 10183     SERIAL_ECHOLNPAIR(MSG_DUPLICATION_MODE, extruder_duplication_enabled ? MSG_ON : MSG_OFF);
// 10184   }
// 10185 
// 10186 #endif // DUAL_NOZZLE_DUPLICATION_MODE
// 10187 
// 10188 #if ENABLED(LIN_ADVANCE)
// 10189   /**
// 10190    * M900: Set and/or Get advance K factor and WH/D ratio
// 10191    *
// 10192    *  K<factor>                  Set advance K factor
// 10193    *  R<ratio>                   Set ratio directly (overrides WH/D)
// 10194    *  W<width> H<height> D<diam> Set ratio from WH/D
// 10195    */
// 10196   inline void gcode_M900() {
// 10197     stepper.synchronize();
// 10198 
// 10199     const float newK = code_seen('K') ? code_value_float() : -1;
// 10200     if (newK >= 0) planner.extruder_advance_k = newK;
// 10201 
// 10202     float newR = code_seen('R') ? code_value_float() : -1;
// 10203     if (newR < 0) {
// 10204       const float newD = code_seen('D') ? code_value_float() : -1,
// 10205                   newW = code_seen('W') ? code_value_float() : -1,
// 10206                   newH = code_seen('H') ? code_value_float() : -1;
// 10207       if (newD >= 0 && newW >= 0 && newH >= 0)
// 10208         newR = newD ? (newW * newH) / (sq(newD * 0.5) * M_PI) : 0;
// 10209     }
// 10210     if (newR >= 0) planner.advance_ed_ratio = newR;
// 10211 
// 10212     SERIAL_ECHO_START;
// 10213     SERIAL_ECHOPAIR("Advance K=", planner.extruder_advance_k);
// 10214     SERIAL_ECHOPGM(" E/D=");
// 10215     const float ratio = planner.advance_ed_ratio;
// 10216     if (ratio) SERIAL_ECHO(ratio); else SERIAL_ECHOPGM("Auto");
// 10217     SERIAL_EOL;
// 10218   }
// 10219 #endif // LIN_ADVANCE
// 10220 
// 10221 #if ENABLED(HAVE_TMC2130)
// 10222 
// 10223   static void tmc2130_get_current(TMC2130Stepper &st, const char name) {
// 10224     SERIAL_CHAR(name);
// 10225     SERIAL_ECHOPGM(" axis driver current: ");
// 10226     SERIAL_ECHOLN(st.getCurrent());
// 10227   }
// 10228   static void tmc2130_set_current(TMC2130Stepper &st, const char name, const int mA) {
// 10229     st.setCurrent(mA, R_SENSE, HOLD_MULTIPLIER);
// 10230     tmc2130_get_current(st, name);
// 10231   }
// 10232 
// 10233   static void tmc2130_report_otpw(TMC2130Stepper &st, const char name) {
// 10234     SERIAL_CHAR(name);
// 10235     SERIAL_ECHOPGM(" axis temperature prewarn triggered: ");
// 10236     serialprintPGM(st.getOTPW() ? PSTR("true") : PSTR("false"));
// 10237     SERIAL_EOL;
// 10238   }
// 10239   static void tmc2130_clear_otpw(TMC2130Stepper &st, const char name) {
// 10240     st.clear_otpw();
// 10241     SERIAL_CHAR(name);
// 10242     SERIAL_ECHOLNPGM(" prewarn flag cleared");
// 10243   }
// 10244 
// 10245   static void tmc2130_get_pwmthrs(TMC2130Stepper &st, const char name, const uint16_t spmm) {
// 10246     SERIAL_CHAR(name);
// 10247     SERIAL_ECHOPGM(" stealthChop max speed set to ");
// 10248     SERIAL_ECHOLN(12650000UL * st.microsteps() / (256 * st.stealth_max_speed() * spmm));
// 10249   }
// 10250   static void tmc2130_set_pwmthrs(TMC2130Stepper &st, const char name, const int32_t thrs, const uint32_t spmm) {
// 10251     st.stealth_max_speed(12650000UL * st.microsteps() / (256 * thrs * spmm));
// 10252     tmc2130_get_pwmthrs(st, name, spmm);
// 10253   }
// 10254 
// 10255   static void tmc2130_get_sgt(TMC2130Stepper &st, const char name) {
// 10256     SERIAL_CHAR(name);
// 10257     SERIAL_ECHOPGM(" driver homing sensitivity set to ");
// 10258     SERIAL_ECHOLN(st.sgt());
// 10259   }
// 10260   static void tmc2130_set_sgt(TMC2130Stepper &st, const char name, const int8_t sgt_val) {
// 10261     st.sgt(sgt_val);
// 10262     tmc2130_get_sgt(st, name);
// 10263   }
// 10264 
// 10265   /**
// 10266    * M906: Set motor current in milliamps using axis codes X, Y, Z, E
// 10267    * Report driver currents when no axis specified
// 10268    *
// 10269    * S1: Enable automatic current control
// 10270    * S0: Disable
// 10271    */
// 10272   inline void gcode_M906() {
// 10273     uint16_t values[XYZE];
// 10274     LOOP_XYZE(i)
// 10275       values[i] = code_seen(axis_codes[i]) ? code_value_int() : 0;
// 10276 
// 10277     #if ENABLED(X_IS_TMC2130)
// 10278       if (values[X_AXIS]) tmc2130_set_current(stepperX, 'X', values[X_AXIS]);
// 10279       else tmc2130_get_current(stepperX, 'X');
// 10280     #endif
// 10281     #if ENABLED(Y_IS_TMC2130)
// 10282       if (values[Y_AXIS]) tmc2130_set_current(stepperY, 'Y', values[Y_AXIS]);
// 10283       else tmc2130_get_current(stepperY, 'Y');
// 10284     #endif
// 10285     #if ENABLED(Z_IS_TMC2130)
// 10286       if (values[Z_AXIS]) tmc2130_set_current(stepperZ, 'Z', values[Z_AXIS]);
// 10287       else tmc2130_get_current(stepperZ, 'Z');
// 10288     #endif
// 10289     #if ENABLED(E0_IS_TMC2130)
// 10290       if (values[E_AXIS]) tmc2130_set_current(stepperE0, 'E', values[E_AXIS]);
// 10291       else tmc2130_get_current(stepperE0, 'E');
// 10292     #endif
// 10293 
// 10294     #if ENABLED(AUTOMATIC_CURRENT_CONTROL)
// 10295       if (code_seen('S')) auto_current_control = code_value_bool();
// 10296     #endif
// 10297   }
// 10298 
// 10299   /**
// 10300    * M911: Report TMC2130 stepper driver overtemperature pre-warn flag
// 10301    * The flag is held by the library and persist until manually cleared by M912
// 10302    */
// 10303   inline void gcode_M911() {
// 10304     const bool reportX = code_seen('X'), reportY = code_seen('Y'), reportZ = code_seen('Z'), reportE = code_seen('E'),
// 10305              reportAll = (!reportX && !reportY && !reportZ && !reportE) || (reportX && reportY && reportZ && reportE);
// 10306     #if ENABLED(X_IS_TMC2130)
// 10307       if (reportX || reportAll) tmc2130_report_otpw(stepperX, 'X');
// 10308     #endif
// 10309     #if ENABLED(Y_IS_TMC2130)
// 10310       if (reportY || reportAll) tmc2130_report_otpw(stepperY, 'Y');
// 10311     #endif
// 10312     #if ENABLED(Z_IS_TMC2130)
// 10313       if (reportZ || reportAll) tmc2130_report_otpw(stepperZ, 'Z');
// 10314     #endif
// 10315     #if ENABLED(E0_IS_TMC2130)
// 10316       if (reportE || reportAll) tmc2130_report_otpw(stepperE0, 'E');
// 10317     #endif
// 10318   }
// 10319 
// 10320   /**
// 10321    * M912: Clear TMC2130 stepper driver overtemperature pre-warn flag held by the library
// 10322    */
// 10323   inline void gcode_M912() {
// 10324     const bool clearX = code_seen('X'), clearY = code_seen('Y'), clearZ = code_seen('Z'), clearE = code_seen('E'),
// 10325              clearAll = (!clearX && !clearY && !clearZ && !clearE) || (clearX && clearY && clearZ && clearE);
// 10326     #if ENABLED(X_IS_TMC2130)
// 10327       if (clearX || clearAll) tmc2130_clear_otpw(stepperX, 'X');
// 10328     #endif
// 10329     #if ENABLED(Y_IS_TMC2130)
// 10330       if (clearY || clearAll) tmc2130_clear_otpw(stepperY, 'Y');
// 10331     #endif
// 10332     #if ENABLED(Z_IS_TMC2130)
// 10333       if (clearZ || clearAll) tmc2130_clear_otpw(stepperZ, 'Z');
// 10334     #endif
// 10335     #if ENABLED(E0_IS_TMC2130)
// 10336       if (clearE || clearAll) tmc2130_clear_otpw(stepperE0, 'E');
// 10337     #endif
// 10338   }
// 10339 
// 10340   /**
// 10341    * M913: Set HYBRID_THRESHOLD speed.
// 10342    */
// 10343   #if ENABLED(HYBRID_THRESHOLD)
// 10344     inline void gcode_M913() {
// 10345       uint16_t values[XYZE];
// 10346       LOOP_XYZE(i)
// 10347         values[i] = code_seen(axis_codes[i]) ? code_value_int() : 0;
// 10348 
// 10349       #if ENABLED(X_IS_TMC2130)
// 10350         if (values[X_AXIS]) tmc2130_set_pwmthrs(stepperX, 'X', values[X_AXIS], planner.axis_steps_per_mm[X_AXIS]);
// 10351         else tmc2130_get_pwmthrs(stepperX, 'X', planner.axis_steps_per_mm[X_AXIS]);
// 10352       #endif
// 10353       #if ENABLED(Y_IS_TMC2130)
// 10354         if (values[Y_AXIS]) tmc2130_set_pwmthrs(stepperY, 'Y', values[Y_AXIS], planner.axis_steps_per_mm[Y_AXIS]);
// 10355         else tmc2130_get_pwmthrs(stepperY, 'Y', planner.axis_steps_per_mm[Y_AXIS]);
// 10356       #endif
// 10357       #if ENABLED(Z_IS_TMC2130)
// 10358         if (values[Z_AXIS]) tmc2130_set_pwmthrs(stepperZ, 'Z', values[Z_AXIS], planner.axis_steps_per_mm[Z_AXIS]);
// 10359         else tmc2130_get_pwmthrs(stepperZ, 'Z', planner.axis_steps_per_mm[Z_AXIS]);
// 10360       #endif
// 10361       #if ENABLED(E0_IS_TMC2130)
// 10362         if (values[E_AXIS]) tmc2130_set_pwmthrs(stepperE0, 'E', values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
// 10363         else tmc2130_get_pwmthrs(stepperE0, 'E', planner.axis_steps_per_mm[E_AXIS]);
// 10364       #endif
// 10365     }
// 10366   #endif // HYBRID_THRESHOLD
// 10367 
// 10368   /**
// 10369    * M914: Set SENSORLESS_HOMING sensitivity.
// 10370    */
// 10371   #if ENABLED(SENSORLESS_HOMING)
// 10372     inline void gcode_M914() {
// 10373       #if ENABLED(X_IS_TMC2130)
// 10374         if (code_seen(axis_codes[X_AXIS])) tmc2130_set_sgt(stepperX, 'X', code_value_int());
// 10375         else tmc2130_get_sgt(stepperX, 'X');
// 10376       #endif
// 10377       #if ENABLED(Y_IS_TMC2130)
// 10378         if (code_seen(axis_codes[Y_AXIS])) tmc2130_set_sgt(stepperY, 'Y', code_value_int());
// 10379         else tmc2130_get_sgt(stepperY, 'Y');
// 10380       #endif
// 10381     }
// 10382   #endif // SENSORLESS_HOMING
// 10383 
// 10384 #endif // HAVE_TMC2130
// 10385 
// 10386 /**
// 10387  * M907: Set digital trimpot motor current using axis codes X, Y, Z, E, B, S
// 10388  */
// 10389 inline void gcode_M907() {
// 10390   #if HAS_DIGIPOTSS
// 10391     LOOP_XYZE(i) if (code_seen(axis_codes[i])) stepper.digipot_current(i, code_value_int());
// 10392     if (code_seen('B')) stepper.digipot_current(4, code_value_int());
// 10393     if (code_seen('S')) for (uint8_t i = 0; i <= 4; i++) stepper.digipot_current(i, code_value_int());
// 10394   #elif HAS_MOTOR_CURRENT_PWM
// 10395     #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
// 10396       if (code_seen('X')) stepper.digipot_current(0, code_value_int());
// 10397     #endif
// 10398     #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
// 10399       if (code_seen('Z')) stepper.digipot_current(1, code_value_int());
// 10400     #endif
// 10401     #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
// 10402       if (code_seen('E')) stepper.digipot_current(2, code_value_int());
// 10403     #endif
// 10404   #endif
// 10405   #if ENABLED(DIGIPOT_I2C)
// 10406     // this one uses actual amps in floating point
// 10407     LOOP_XYZE(i) if (code_seen(axis_codes[i])) digipot_i2c_set_current(i, code_value_float());
// 10408     // for each additional extruder (named B,C,D,E..., channels 4,5,6,7...)
// 10409     for (uint8_t i = NUM_AXIS; i < DIGIPOT_I2C_NUM_CHANNELS; i++) if (code_seen('B' + i - (NUM_AXIS))) digipot_i2c_set_current(i, code_value_float());
// 10410   #endif
// 10411   #if ENABLED(DAC_STEPPER_CURRENT)
// 10412     if (code_seen('S')) {
// 10413       const float dac_percent = code_value_float();
// 10414       for (uint8_t i = 0; i <= 4; i++) dac_current_percent(i, dac_percent);
// 10415     }
// 10416     LOOP_XYZE(i) if (code_seen(axis_codes[i])) dac_current_percent(i, code_value_float());
// 10417   #endif
// 10418 }
// 10419 
// 10420 #if HAS_DIGIPOTSS || ENABLED(DAC_STEPPER_CURRENT)
// 10421 
// 10422   /**
// 10423    * M908: Control digital trimpot directly (M908 P<pin> S<current>)
// 10424    */
// 10425   inline void gcode_M908() {
// 10426     #if HAS_DIGIPOTSS
// 10427       stepper.digitalPotWrite(
// 10428         code_seen('P') ? code_value_int() : 0,
// 10429         code_seen('S') ? code_value_int() : 0
// 10430       );
// 10431     #endif
// 10432     #ifdef DAC_STEPPER_CURRENT
// 10433       dac_current_raw(
// 10434         code_seen('P') ? code_value_byte() : -1,
// 10435         code_seen('S') ? code_value_ushort() : 0
// 10436       );
// 10437     #endif
// 10438   }
// 10439 
// 10440   #if ENABLED(DAC_STEPPER_CURRENT) // As with Printrbot RevF
// 10441 
// 10442     inline void gcode_M909() { dac_print_values(); }
// 10443 
// 10444     inline void gcode_M910() { dac_commit_eeprom(); }
// 10445 
// 10446   #endif
// 10447 
// 10448 #endif // HAS_DIGIPOTSS || DAC_STEPPER_CURRENT
// 10449 
// 10450 #if HAS_MICROSTEPS
// 10451 
// 10452   // M350 Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.
// 10453   inline void gcode_M350() {
// 10454     if (code_seen('S')) for (int i = 0; i <= 4; i++) stepper.microstep_mode(i, code_value_byte());
// 10455     LOOP_XYZE(i) if (code_seen(axis_codes[i])) stepper.microstep_mode(i, code_value_byte());
// 10456     if (code_seen('B')) stepper.microstep_mode(4, code_value_byte());
// 10457     stepper.microstep_readings();
// 10458   }
// 10459 
// 10460   /**
// 10461    * M351: Toggle MS1 MS2 pins directly with axis codes X Y Z E B
// 10462    *       S# determines MS1 or MS2, X# sets the pin high/low.
// 10463    */
// 10464   inline void gcode_M351() {
// 10465     if (code_seen('S')) switch (code_value_byte()) {
// 10466       case 1:
// 10467         LOOP_XYZE(i) if (code_seen(axis_codes[i])) stepper.microstep_ms(i, code_value_byte(), -1);
// 10468         if (code_seen('B')) stepper.microstep_ms(4, code_value_byte(), -1);
// 10469         break;
// 10470       case 2:
// 10471         LOOP_XYZE(i) if (code_seen(axis_codes[i])) stepper.microstep_ms(i, -1, code_value_byte());
// 10472         if (code_seen('B')) stepper.microstep_ms(4, -1, code_value_byte());
// 10473         break;
// 10474     }
// 10475     stepper.microstep_readings();
// 10476   }
// 10477 
// 10478 #endif // HAS_MICROSTEPS
// 10479 
// 10480 #if HAS_CASE_LIGHT
// 10481 
// 10482   uint8_t case_light_brightness = 255;
// 10483 
// 10484   void update_case_light() {
// 10485     WRITE(CASE_LIGHT_PIN, case_light_on != INVERT_CASE_LIGHT ? HIGH : LOW);
// 10486     analogWrite(CASE_LIGHT_PIN, case_light_on != INVERT_CASE_LIGHT ? case_light_brightness : 0);
// 10487   }
// 10488 
// 10489 #endif // HAS_CASE_LIGHT
// 10490 
// 10491 /**
// 10492  * M355: Turn case lights on/off and set brightness
// 10493  *
// 10494  *   S<bool>  Turn case light on or off
// 10495  *   P<byte>  Set case light brightness (PWM pin required)
// 10496  */
// 10497 inline void gcode_M355() {
// 10498   #if HAS_CASE_LIGHT
// 10499     if (code_seen('P')) case_light_brightness = code_value_byte();
// 10500     if (code_seen('S')) case_light_on = code_value_bool();
// 10501     update_case_light();
// 10502     SERIAL_ECHO_START;
// 10503     SERIAL_ECHOPGM("Case lights ");
// 10504     case_light_on ? SERIAL_ECHOLNPGM("on") : SERIAL_ECHOLNPGM("off");
// 10505   #else
// 10506     SERIAL_ERROR_START;
// 10507     SERIAL_ERRORLNPGM(MSG_ERR_M355_NONE);
// 10508   #endif // HAS_CASE_LIGHT
// 10509 }
// 10510 
// 10511 #if ENABLED(MIXING_EXTRUDER)
// 10512 
// 10513   /**
// 10514    * M163: Set a single mix factor for a mixing extruder
// 10515    *       This is called "weight" by some systems.
// 10516    *
// 10517    *   S[index]   The channel index to set
// 10518    *   P[float]   The mix value
// 10519    *
// 10520    */
// 10521   inline void gcode_M163() {
// 10522     const int mix_index = code_seen('S') ? code_value_int() : 0;
// 10523     if (mix_index < MIXING_STEPPERS) {
// 10524       float mix_value = code_seen('P') ? code_value_float() : 0.0;
// 10525       NOLESS(mix_value, 0.0);
// 10526       mixing_factor[mix_index] = RECIPROCAL(mix_value);
// 10527     }
// 10528   }
// 10529 
// 10530   #if MIXING_VIRTUAL_TOOLS > 1
// 10531 
// 10532     /**
// 10533      * M164: Store the current mix factors as a virtual tool.
// 10534      *
// 10535      *   S[index]   The virtual tool to store
// 10536      *
// 10537      */
// 10538     inline void gcode_M164() {
// 10539       const int tool_index = code_seen('S') ? code_value_int() : 0;
// 10540       if (tool_index < MIXING_VIRTUAL_TOOLS) {
// 10541         normalize_mix();
// 10542         for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
// 10543           mixing_virtual_tool_mix[tool_index][i] = mixing_factor[i];
// 10544       }
// 10545     }
// 10546 
// 10547   #endif
// 10548 
// 10549   #if ENABLED(DIRECT_MIXING_IN_G1)
// 10550     /**
// 10551      * M165: Set multiple mix factors for a mixing extruder.
// 10552      *       Factors that are left out will be set to 0.
// 10553      *       All factors together must add up to 1.0.
// 10554      *
// 10555      *   A[factor] Mix factor for extruder stepper 1
// 10556      *   B[factor] Mix factor for extruder stepper 2
// 10557      *   C[factor] Mix factor for extruder stepper 3
// 10558      *   D[factor] Mix factor for extruder stepper 4
// 10559      *   H[factor] Mix factor for extruder stepper 5
// 10560      *   I[factor] Mix factor for extruder stepper 6
// 10561      *
// 10562      */
// 10563     inline void gcode_M165() { gcode_get_mix(); }
// 10564   #endif
// 10565 
// 10566 #endif // MIXING_EXTRUDER
// 10567 
// 10568 /**
// 10569  * M999: Restart after being stopped
// 10570  *
// 10571  * Default behaviour is to flush the serial buffer and request
// 10572  * a resend to the host starting on the last N line received.
// 10573  *
// 10574  * Sending "M999 S1" will resume printing without flushing the
// 10575  * existing command buffer.
// 10576  *
// 10577  */
// 10578 inline void gcode_M999() {
// 10579   Running = true;
// 10580   lcd_reset_alert_level();
// 10581 
// 10582   if (code_seen('S') && code_value_bool()) return;
// 10583 
// 10584   // gcode_LastN = Stopped_gcode_LastN;
// 10585   FlushSerialRequestResend();
// 10586 }
// 10587 
// 10588 #if ENABLED(SWITCHING_EXTRUDER)
// 10589   inline void move_extruder_servo(uint8_t e) {
// 10590     const int angles[2] = SWITCHING_EXTRUDER_SERVO_ANGLES;
// 10591     MOVE_SERVO(SWITCHING_EXTRUDER_SERVO_NR, angles[e]);
// 10592     safe_delay(500);
// 10593   }
// 10594 #endif
// 10595 
// 10596 inline void invalid_extruder_error(const uint8_t &e) {
// 10597   SERIAL_ECHO_START;
// 10598   SERIAL_CHAR('T');
// 10599   SERIAL_ECHO_F(e, DEC);
// 10600   SERIAL_ECHOLN(MSG_INVALID_EXTRUDER);
// 10601 }
// 10602 
// 10603 /**
// 10604  * Perform a tool-change, which may result in moving the
// 10605  * previous tool out of the way and the new tool into place.
// 10606  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock69 Using cfiCommon0
          CFI Function _Z11tool_changehfb
        THUMB
// 10607 void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
_Z11tool_changehfb:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 10608   #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
// 10609 
// 10610     if (tmp_extruder >= MIXING_VIRTUAL_TOOLS)
// 10611       return invalid_extruder_error(tmp_extruder);
// 10612 
// 10613     // T0-Tnnn: Switch virtual tool by changing the mix
// 10614     for (uint8_t j = 0; j < MIXING_STEPPERS; j++)
// 10615       mixing_factor[j] = mixing_virtual_tool_mix[tmp_extruder][j];
// 10616 
// 10617   #else //!MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
// 10618 
// 10619     #if HOTENDS > 1
// 10620 
// 10621       if (tmp_extruder >= EXTRUDERS)
// 10622         return invalid_extruder_error(tmp_extruder);
// 10623 
// 10624       const float old_feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : feedrate_mm_s;
// 10625 
// 10626       feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
// 10627 
// 10628       if (tmp_extruder != active_extruder) {
// 10629         if (!no_move && axis_unhomed_error(true, true, true)) {
// 10630           SERIAL_ECHOLNPGM("No move on toolchange");
// 10631           no_move = true;
// 10632         }
// 10633 
// 10634         // Save current position to destination, for use later
// 10635         set_destination_to_current();
// 10636 
// 10637         #if ENABLED(DUAL_X_CARRIAGE)
// 10638 
// 10639           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 10640             if (DEBUGGING(LEVELING)) {
// 10641               SERIAL_ECHOPGM("Dual X Carriage Mode ");
// 10642               switch (dual_x_carriage_mode) {
// 10643                 case DXC_FULL_CONTROL_MODE: SERIAL_ECHOLNPGM("DXC_FULL_CONTROL_MODE"); break;
// 10644                 case DXC_AUTO_PARK_MODE: SERIAL_ECHOLNPGM("DXC_AUTO_PARK_MODE"); break;
// 10645                 case DXC_DUPLICATION_MODE: SERIAL_ECHOLNPGM("DXC_DUPLICATION_MODE"); break;
// 10646               }
// 10647             }
// 10648           #endif
// 10649 
// 10650           const float xhome = x_home_pos(active_extruder);
// 10651           if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE
// 10652               && IsRunning()
// 10653               && (delayed_move_time || current_position[X_AXIS] != xhome)
// 10654           ) {
// 10655             float raised_z = current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT;
// 10656             //#if ENABLED(MAX_SOFTWARE_ENDSTOPS)	/*--mks cfg--*/
// 10657 			if(mksCfg.max_software_endstops){
// 10658               NOMORE(raised_z, soft_endstop_max[Z_AXIS]);
// 10659             }//#endif
// 10660             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 10661               if (DEBUGGING(LEVELING)) {
// 10662                 SERIAL_ECHOLNPAIR("Raise to ", raised_z);
// 10663                 SERIAL_ECHOLNPAIR("MoveX to ", xhome);
// 10664                 SERIAL_ECHOLNPAIR("Lower to ", current_position[Z_AXIS]);
// 10665               }
// 10666             #endif
// 10667             // Park old head: 1) raise 2) move to park position 3) lower
// 10668             for (uint8_t i = 0; i < 3; i++)
// 10669               planner.buffer_line(
// 10670                 i == 0 ? current_position[X_AXIS] : xhome,
// 10671                 current_position[Y_AXIS],
// 10672                 i == 2 ? current_position[Z_AXIS] : raised_z,
// 10673                 current_position[E_AXIS],
// 10674                 planner.max_feedrate_mm_s[i == 1 ? X_AXIS : Z_AXIS],
// 10675                 active_extruder
// 10676               );
// 10677             stepper.synchronize();
// 10678           }
// 10679 
// 10680           // Apply Y & Z extruder offset (X offset is used as home pos with Dual X)
// 10681           current_position[Y_AXIS] -= hotend_offset[Y_AXIS][active_extruder] - hotend_offset[Y_AXIS][tmp_extruder];
// 10682           current_position[Z_AXIS] -= hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
// 10683 
// 10684           // Activate the new extruder
// 10685           active_extruder = tmp_extruder;
// 10686 
// 10687           // This function resets the max/min values - the current position may be overwritten below.
// 10688           set_axis_is_at_home(X_AXIS);
// 10689 
// 10690           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 10691             if (DEBUGGING(LEVELING)) DEBUG_POS("New Extruder", current_position);
// 10692           #endif
// 10693 
// 10694           // Only when auto-parking are carriages safe to move
// 10695           if (dual_x_carriage_mode != DXC_AUTO_PARK_MODE) no_move = true;
// 10696 
// 10697           switch (dual_x_carriage_mode) {
// 10698             case DXC_FULL_CONTROL_MODE:
// 10699               // New current position is the position of the activated extruder
// 10700               current_position[X_AXIS] = LOGICAL_X_POSITION(inactive_extruder_x_pos);
// 10701               // Save the inactive extruder's position (from the old current_position)
// 10702               inactive_extruder_x_pos = RAW_X_POSITION(destination[X_AXIS]);
// 10703               break;
// 10704             case DXC_AUTO_PARK_MODE:
// 10705               // record raised toolhead position for use by unpark
// 10706               COPY(raised_parked_position, current_position);
// 10707               raised_parked_position[Z_AXIS] += TOOLCHANGE_UNPARK_ZLIFT;
// 10708 			  //#if ENABLED(MAX_SOFTWARE_ENDSTOPS)	  /*--mks cfg--*/
// 10709 			  if(mksCfg.max_software_endstops){
// 10710                 NOMORE(raised_parked_position[Z_AXIS], soft_endstop_max[Z_AXIS]);
// 10711               }//#endif
// 10712               active_extruder_parked = true;
// 10713               delayed_move_time = 0;
// 10714               break;
// 10715             case DXC_DUPLICATION_MODE:
// 10716               // If the new extruder is the left one, set it "parked"
// 10717               // This triggers the second extruder to move into the duplication position
// 10718               active_extruder_parked = (active_extruder == 0);
// 10719 
// 10720               if (active_extruder_parked)
// 10721                 current_position[X_AXIS] = LOGICAL_X_POSITION(inactive_extruder_x_pos);
// 10722               else
// 10723                 current_position[X_AXIS] = destination[X_AXIS] + duplicate_extruder_x_offset;
// 10724               inactive_extruder_x_pos = RAW_X_POSITION(destination[X_AXIS]);
// 10725               extruder_duplication_enabled = false;
// 10726               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 10727                 if (DEBUGGING(LEVELING)) {
// 10728                   SERIAL_ECHOLNPAIR("Set inactive_extruder_x_pos=", inactive_extruder_x_pos);
// 10729                   SERIAL_ECHOLNPGM("Clear extruder_duplication_enabled");
// 10730                 }
// 10731               #endif
// 10732               break;
// 10733           }
// 10734 
// 10735           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 10736             if (DEBUGGING(LEVELING)) {
// 10737               SERIAL_ECHOLNPAIR("Active extruder parked: ", active_extruder_parked ? "yes" : "no");
// 10738               DEBUG_POS("New extruder (parked)", current_position);
// 10739             }
// 10740           #endif
// 10741 
// 10742           // No extra case for HAS_ABL in DUAL_X_CARRIAGE. Does that mean they don't work together?
// 10743         #else // !DUAL_X_CARRIAGE
// 10744 
// 10745           #if ENABLED(SWITCHING_EXTRUDER)
// 10746             // <0 if the new nozzle is higher, >0 if lower. A bigger raise when lower.
// 10747             const float z_diff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder],
// 10748                         z_raise = 0.3 + (z_diff > 0.0 ? z_diff : 0.0);
// 10749 
// 10750             // Always raise by some amount (destination copied from current_position earlier)
// 10751             current_position[Z_AXIS] += z_raise;
// 10752             planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
// 10753             stepper.synchronize();
// 10754 
// 10755             move_extruder_servo(active_extruder);
// 10756           #endif
// 10757 
// 10758           /**
// 10759            * Set current_position to the position of the new nozzle.
// 10760            * Offsets are based on linear distance, so we need to get
// 10761            * the resulting position in coordinate space.
// 10762            *
// 10763            * - With grid or 3-point leveling, offset XYZ by a tilted vector
// 10764            * - With mesh leveling, update Z for the new position
// 10765            * - Otherwise, just use the raw linear distance
// 10766            *
// 10767            * Software endstops are altered here too. Consider a case where:
// 10768            *   E0 at X=0 ... E1 at X=10
// 10769            * When we switch to E1 now X=10, but E1 can't move left.
// 10770            * To express this we apply the change in XY to the software endstops.
// 10771            * E1 can move farther right than E0, so the right limit is extended.
// 10772            *
// 10773            * Note that we don't adjust the Z software endstops. Why not?
// 10774            * Consider a case where Z=0 (here) and switching to E1 makes Z=1
// 10775            * because the bed is 1mm lower at the new position. As long as
// 10776            * the first nozzle is out of the way, the carriage should be
// 10777            * allowed to move 1mm lower. This technically "breaks" the
// 10778            * Z software endstop. But this is technically correct (and
// 10779            * there is no viable alternative).
// 10780            */
// 10781 
// 10782 /*--mks cfg--begin MESH_BED_LEVELING */		
// 10783 /*		  
// 10784           #if ABL_PLANAR
// 10785             // Offset extruder, make sure to apply the bed level rotation matrix
// 10786             vector_3 tmp_offset_vec = vector_3(hotend_offset[X_AXIS][tmp_extruder],
// 10787                                                hotend_offset[Y_AXIS][tmp_extruder],
// 10788                                                0),
// 10789                      act_offset_vec = vector_3(hotend_offset[X_AXIS][active_extruder],
// 10790                                                hotend_offset[Y_AXIS][active_extruder],
// 10791                                                0),
// 10792                      offset_vec = tmp_offset_vec - act_offset_vec;
// 10793 
// 10794             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 10795               if (DEBUGGING(LEVELING)) {
// 10796                 tmp_offset_vec.debug(PSTR("tmp_offset_vec"));
// 10797                 act_offset_vec.debug(PSTR("act_offset_vec"));
// 10798                 offset_vec.debug(PSTR("offset_vec (BEFORE)"));
// 10799               }
// 10800             #endif
// 10801 
// 10802             offset_vec.apply_rotation(planner.bed_level_matrix.transpose(planner.bed_level_matrix));
// 10803 
// 10804             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 10805               if (DEBUGGING(LEVELING)) offset_vec.debug(PSTR("offset_vec (AFTER)"));
// 10806             #endif
// 10807 
// 10808             // Adjustments to the current position
// 10809             const float xydiff[2] = { offset_vec.x, offset_vec.y };
// 10810             current_position[Z_AXIS] += offset_vec.z;
// 10811 
// 10812           #else // !ABL_PLANAR
// 10813 
// 10814             const float xydiff[2] = {
// 10815               hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder],
// 10816               hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder]
// 10817             };
// 10818 
// 10819             #if ENABLED(MESH_BED_LEVELING)
// 10820 
// 10821               if (mbl.active()) {
// 10822                 #if ENABLED(DEBUG_LEVELING_FEATURE)
// 10823                   if (DEBUGGING(LEVELING)) SERIAL_ECHOPAIR("Z before MBL: ", current_position[Z_AXIS]);
// 10824                 #endif
// 10825                 float x2 = current_position[X_AXIS] + xydiff[X_AXIS],
// 10826                       y2 = current_position[Y_AXIS] + xydiff[Y_AXIS],
// 10827                       z1 = current_position[Z_AXIS], z2 = z1;
// 10828                 planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], z1);
// 10829                 planner.apply_leveling(x2, y2, z2);
// 10830                 current_position[Z_AXIS] += z2 - z1;
// 10831                 #if ENABLED(DEBUG_LEVELING_FEATURE)
// 10832                   if (DEBUGGING(LEVELING))
// 10833                     SERIAL_ECHOLNPAIR(" after: ", current_position[Z_AXIS]);
// 10834                 #endif
// 10835               }
// 10836 
// 10837             #endif // MESH_BED_LEVELING
// 10838 
// 10839           #endif // !HAS_ABL
// 10840 */
// 10841 //#if ABL_PLANAR
// 10842 if(BED_LEVELING_METHOD&ABL_PLANAR)
// 10843 {
// 10844 		  // Offset extruder, make sure to apply the bed level rotation matrix
// 10845 		  vector_3 tmp_offset_vec = vector_3(hotend_offset[X_AXIS][tmp_extruder],
// 10846 											 hotend_offset[Y_AXIS][tmp_extruder],
// 10847 											 0),
// 10848 				   act_offset_vec = vector_3(hotend_offset[X_AXIS][active_extruder],
// 10849 											 hotend_offset[Y_AXIS][active_extruder],
// 10850 											 0),
// 10851 				   offset_vec = tmp_offset_vec - act_offset_vec;
// 10852 		  
// 10853 		#if ENABLED(DEBUG_LEVELING_FEATURE)
// 10854 			if (DEBUGGING(LEVELING)) {
// 10855 			  tmp_offset_vec.debug(PSTR("tmp_offset_vec"));
// 10856 			  act_offset_vec.debug(PSTR("act_offset_vec"));
// 10857 			  offset_vec.debug(PSTR("offset_vec (BEFORE)"));
// 10858 			}
// 10859 		#endif
// 10860 		 	 offset_vec.apply_rotation(planner.bed_level_matrix.transpose(planner.bed_level_matrix));
// 10861 		  
// 10862 		#if ENABLED(DEBUG_LEVELING_FEATURE)
// 10863 			if (DEBUGGING(LEVELING)) offset_vec.debug(PSTR("offset_vec (AFTER)"));
// 10864 		#endif
// 10865 		  
// 10866 		  // Adjustments to the current position
// 10867 		  const float xydiff[2] = { offset_vec.x, offset_vec.y };
// 10868 
// 10869 			  current_position[Z_AXIS] += offset_vec.z;
// 10870 //#else
// 10871 }	
// 10872 else
// 10873 {
// 10874 		  const float xydiff[2] = {
// 10875 			hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder],
// 10876 			hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder]
// 10877 		  };
// 10878 		  if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
// 10879 		  	{
// 10880               if (mbl.active()) {
// 10881   				#if ENABLED(DEBUG_LEVELING_FEATURE)
// 10882                   if (DEBUGGING(LEVELING)) SERIAL_ECHOPAIR("Z before MBL: ", current_position[Z_AXIS]);
// 10883   				#endif
// 10884                 float x2 = current_position[X_AXIS] + xydiff[X_AXIS],
// 10885                       y2 = current_position[Y_AXIS] + xydiff[Y_AXIS],
// 10886                       z1 = current_position[Z_AXIS], z2 = z1;
// 10887                 planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], z1);
// 10888                 planner.apply_leveling(x2, y2, z2);
// 10889                 current_position[Z_AXIS] += z2 - z1;
// 10890  			 	#if ENABLED(DEBUG_LEVELING_FEATURE)
// 10891                   if (DEBUGGING(LEVELING))
// 10892                     SERIAL_ECHOLNPAIR(" after: ", current_position[Z_AXIS]);
// 10893   				#endif
// 10894               }
// 10895 
// 10896 		  	}
// 10897 }		  
// 10898 		  /*--mks cfg--end MESH_BED_LEVELING */
// 10899 
// 10900           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 10901             if (DEBUGGING(LEVELING)) {
// 10902               SERIAL_ECHOPAIR("Offset Tool XY by { ", xydiff[X_AXIS]);
// 10903               SERIAL_ECHOPAIR(", ", xydiff[Y_AXIS]);
// 10904               SERIAL_ECHOLNPGM(" }");
// 10905             }
// 10906           #endif
// 10907 
// 10908           // The newly-selected extruder XY is actually at...
// 10909           current_position[X_AXIS] += xydiff[X_AXIS];
// 10910           current_position[Y_AXIS] += xydiff[Y_AXIS];
// 10911           #if HAS_WORKSPACE_OFFSET || ENABLED(DUAL_X_CARRIAGE)
// 10912             for (uint8_t i = X_AXIS; i <= Y_AXIS; i++) {
// 10913               #if HAS_POSITION_SHIFT
// 10914                 position_shift[i] += xydiff[i];
// 10915               #endif
// 10916               update_software_endstops((AxisEnum)i);
// 10917             }
// 10918           #endif
// 10919 
// 10920           // Set the new active extruder
// 10921           active_extruder = tmp_extruder;
// 10922 
// 10923         #endif // !DUAL_X_CARRIAGE
// 10924 
// 10925         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 10926           if (DEBUGGING(LEVELING)) DEBUG_POS("Sync After Toolchange", current_position);
// 10927         #endif
// 10928 
// 10929         // Tell the planner the new "current position"
// 10930         SYNC_PLAN_POSITION_KINEMATIC();
// 10931 
// 10932         // Move to the "old position" (move the extruder into place)
// 10933         if (!no_move && IsRunning()) {
// 10934           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 10935             if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
// 10936           #endif
// 10937           prepare_move_to_destination();
// 10938         }
// 10939 
// 10940         #if ENABLED(SWITCHING_EXTRUDER)
// 10941           // Move back down, if needed. (Including when the new tool is higher.)
// 10942           if (z_raise != z_diff) {
// 10943             destination[Z_AXIS] += z_diff;
// 10944             feedrate_mm_s = planner.max_feedrate_mm_s[Z_AXIS];
// 10945             prepare_move_to_destination();
// 10946           }
// 10947         #endif
// 10948 
// 10949       } // (tmp_extruder != active_extruder)
// 10950 
// 10951       stepper.synchronize();
// 10952 
// 10953       #if ENABLED(EXT_SOLENOID)
// 10954         disable_all_solenoids();
// 10955         enable_solenoid_on_active_extruder();
// 10956       #endif // EXT_SOLENOID
// 10957 
// 10958       feedrate_mm_s = old_feedrate_mm_s;
// 10959 
// 10960     #else // HOTENDS <= 1
// 10961 
// 10962       // Set the new active extruder
// 10963       active_extruder = tmp_extruder;
        LDR.N    R4,??DataTable136_2
        STRB     R0,[R4, #+2]
// 10964 
// 10965       UNUSED(fr_mm_s);
// 10966       UNUSED(no_move);
// 10967 
// 10968     #endif // HOTENDS <= 1
// 10969 
// 10970     SERIAL_ECHO_START;
        LDR.N    R0,??DataTable136_5
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 10971     SERIAL_ECHOLNPAIR(MSG_ACTIVE_EXTRUDER, (int)active_extruder);
        LDRB     R1,[R4, #+2]
        ADR.W    R0,?_35
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        LDRB     R0,[R4, #+7]
        CMP      R0,#+0
        BNE.N    ??tool_change_0
        MOVS     R1,#+10
        LDR.N    R0,??DataTable136_17
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN12MarlinSerial5writeEh
        B.W      _ZN12MarlinSerial5writeEh
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??tool_change_0:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.N    R0,??DataTable136_6
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN12MarlinSerial5printEci
        B.W      _ZN12MarlinSerial5printEci
// 10972 
// 10973   #endif //!MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
// 10974 }
          CFI EndBlock cfiBlock69

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable136:
        DC8      " Z:"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable136_1:
        DC8      " E:"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable136_2:
        DC32     mks_heating_busy

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable136_3:
        DC32     axis_relative_modes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable136_4:
        DC32     0x42700000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable136_5:
        DC32     echomagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable136_6:
        DC32     serial2

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable136_7:
        DC32     host_keepalive_interval

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable136_8:
        DC32     mksCfg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable136_9:
        DC32     0x43960000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable136_10:
        DC32     0xc2c80000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable136_11:
        DC32     0x42600000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable136_12:
        DC32     0xeb1c432d

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable136_13:
        DC32     0xbf1a36e2

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable136_14:
        DC32     0x3f1a36e2

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable136_15:
        DC32     0x3fb99999

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable136_16:
        DC32     _ZN17mesh_bed_leveling8z_offsetE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable136_17:
        DC32     customizedSerial

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_35:
        DC8 "Active Extruder: "
        DC8 0, 0
// 10975 
// 10976 /**
// 10977  * T0-T3: Switch tool, usually switching extruders
// 10978  *
// 10979  *   F[units/min] Set the movement feedrate
// 10980  *   S1           Don't move the tool in XY after change
// 10981  */
// 10982 inline void gcode_T(uint8_t tmp_extruder) {
// 10983 
// 10984   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 10985     if (DEBUGGING(LEVELING)) {
// 10986       SERIAL_ECHOPAIR(">>> gcode_T(", tmp_extruder);
// 10987       SERIAL_CHAR(')');
// 10988       SERIAL_EOL;
// 10989       DEBUG_POS("BEFORE", current_position);
// 10990     }
// 10991   #endif
// 10992 
// 10993   #if HOTENDS == 1 || (ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1)
// 10994 
// 10995     tool_change(tmp_extruder);
// 10996 
// 10997   #elif HOTENDS > 1
// 10998 
// 10999     tool_change(
// 11000       tmp_extruder,
// 11001       code_seen('F') ? MMM_TO_MMS(code_value_linear_units()) : 0.0,
// 11002       (tmp_extruder == active_extruder) || (code_seen('S') && code_value_bool())
// 11003     );
// 11004 
// 11005   #endif
// 11006 
// 11007   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 11008     if (DEBUGGING(LEVELING)) {
// 11009       DEBUG_POS("AFTER", current_position);
// 11010       SERIAL_ECHOLNPGM("<<< gcode_T");
// 11011     }
// 11012   #endif
// 11013 }
// 11014 
// 11015 /**
// 11016  * Process a single command and dispatch it to its handler
// 11017  * This is called from the main loop()
// 11018  */

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock70 Using cfiCommon0
          CFI Function _Z20process_next_commandv
        THUMB
// 11019 void process_next_command() {
_Z20process_next_commandv:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
// 11020   current_command = command_queue[cmd_queue_index_r];
        MOVS     R5,#+96
        LDR.W    R7,??DataTable140
        LDR.W    R0,??DataTable140_1
        LDRB     R1,[R7, #+9]
        MULS     R1,R5,R1
        ADD      R0,R0,R1
        STR      R0,[R7, #+36]
// 11021 
// 11022   if (DEBUGGING(ECHO)) {
        LDR.W    R4,??DataTable140_2
        LDRB     R0,[R4, #+1]
        LSLS     R0,R0,#+31
        BPL.N    ??process_next_command_1
// 11023     SERIAL_ECHO_START;
        LDR.W    R0,??DataTable140_4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 11024     SERIAL_ECHOLN(current_command);
        LDR      R1,[R7, #+36]
        LDRB     R0,[R4, #+7]
        CMP      R0,#+0
        BNE.N    ??process_next_command_2
        LDR.W    R0,??DataTable140_5
          CFI FunCall _ZN12MarlinSerial5printEPKc
        BL       _ZN12MarlinSerial5printEPKc
        B.N      ??process_next_command_3
??process_next_command_2:
        LDR.W    R0,??DataTable140_6
          CFI FunCall _ZN12MarlinSerial5printEPKc
        BL       _ZN12MarlinSerial5printEPKc
??process_next_command_3:
        LDRB     R0,[R4, #+7]
        CMP      R0,#+0
        BNE.N    ??process_next_command_4
        MOVS     R1,#+10
        LDR.W    R0,??DataTable140_5
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??process_next_command_1
??process_next_command_4:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.W    R0,??DataTable140_6
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
// 11025     #if ENABLED(M100_FREE_MEMORY_WATCHER)
// 11026       SERIAL_ECHOPAIR("slot:", cmd_queue_index_r);
// 11027       M100_dump_routine("   Command Queue:", &command_queue[0][0], &command_queue[BUFSIZE][MAX_CMD_SIZE]);
// 11028     #endif
// 11029   }
// 11030   
// 11031   if((mksReprint.mks_printer_state == MKS_WORKING))
??process_next_command_1:
        LDR.W    R6,??DataTable140_7
        LDRB     R0,[R6, #+104]
        CMP      R0,#+167
        BNE.N    ??process_next_command_5
// 11032   {
// 11033         memset(command_queue_bak[cmd_queue_index_r_bak],0,96);
        LDRB     R8,[R7, #+11]
        MOV      R0,R8
        MULS     R5,R5,R0
        ADDS     R0,R4,R5
        ADD      R5,R0,#+136
        MOVS     R2,#+0
        MOVS     R1,#+96
        MOV      R0,R5
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
// 11034         strcpy((char*)&command_queue_bak[cmd_queue_index_r_bak],current_command);
        LDR      R1,[R7, #+36]
        MOV      R0,R5
          CFI FunCall strcpy
        BL       strcpy
// 11035         cmd_queue_index_r_bak++;
        ADD      R8,R8,#+1
        STRB     R8,[R7, #+11]
// 11036         if(cmd_queue_index_r_bak>=(4+4))
        UXTB     R8,R8
        CMP      R8,#+7
        BLE.N    ??process_next_command_5
// 11037             cmd_queue_index_r_bak=0;
        MOVS     R0,#+0
        STRB     R0,[R7, #+11]
        B.N      ??process_next_command_5
// 11038   }
// 11039 
// 11040   // Sanitize the current command:
// 11041   //  - Skip leading spaces
// 11042   //  - Bypass N[-0-9][0-9]*[ ]*
// 11043   //  - Overwrite * with nul to mark the end
// 11044   while (*current_command == ' ') ++current_command;
??process_next_command_6:
        ADDS     R0,R0,#+1
        STR      R0,[R7, #+36]
??process_next_command_5:
        LDR      R0,[R7, #+36]
        LDRSB    R1,[R0, #+0]
        CMP      R1,#+32
        BEQ.N    ??process_next_command_6
// 11045   if (*current_command == 'N' && NUMERIC_SIGNED(current_command[1])) {
        CMP      R1,#+78
        BNE.W    ??process_next_command_7
        LDRSB    R1,[R0, #+1]
        MOV      R2,R1
        SUBS     R2,R2,#+48
        CMP      R2,#+10
        BCC.N    ??process_next_command_8
        CMP      R1,#+45
        BNE.W    ??process_next_command_7
// 11046     current_command += 2; // skip N[-0-9]
??process_next_command_8:
        ADDS     R0,R0,#+2
        STR      R0,[R7, #+36]
        B.N      ??process_next_command_9
// 11047     while (NUMERIC(*current_command)) ++current_command; // skip [0-9]*
??process_next_command_10:
        ADDS     R0,R0,#+1
        STR      R0,[R7, #+36]
??process_next_command_9:
        LDR      R0,[R7, #+36]
        LDRSB    R1,[R0, #+0]
        SUBS     R1,R1,#+48
        CMP      R1,#+10
        BCC.N    ??process_next_command_10
// 11048     while (*current_command == ' ') ++current_command; // skip [ ]*
??process_next_command_11:
        LDR      R0,[R7, #+36]
        LDRSB    R1,[R0, #+0]
        CMP      R1,#+32
        BNE.W    ??process_next_command_7
        ADDS     R0,R0,#+1
        STR      R0,[R7, #+36]
        B.N      ??process_next_command_11
// 11049   }
// 11050   char* starpos = strchr(current_command, '*');  // * should always be the last parameter
// 11051   if (starpos) while (*starpos == ' ' || *starpos == '*') *starpos-- = '\0'; // nullify '*' and ' '
??process_next_command_12:
        MOVS     R1,#+0
        STRB     R1,[R0], #-1
??process_next_command_13:
        LDRSB    R1,[R0, #+0]
        CMP      R1,#+32
        BEQ.N    ??process_next_command_12
        CMP      R1,#+42
        BEQ.N    ??process_next_command_12
// 11052 
// 11053   char *cmd_ptr = current_command;
// 11054 
// 11055   // Get the command code, which must be G, M, or T
// 11056   char command_code = *cmd_ptr++;
??process_next_command_14:
        LDRSB    R1,[R8], #+1
        B.N      ??process_next_command_15
// 11057 
// 11058   // Skip spaces to get the numeric part
// 11059   while (*cmd_ptr == ' ') cmd_ptr++;
??process_next_command_16:
        ADD      R8,R8,#+1
??process_next_command_15:
        LDRSB    R2,[R8, #+0]
        CMP      R2,#+32
        BEQ.N    ??process_next_command_16
// 11060 
// 11061   // Allow for decimal point in command
// 11062   #if ENABLED(G38_PROBE_TARGET)
// 11063     uint8_t subcode = 0;
// 11064   #endif
// 11065 
// 11066   uint16_t codenum = 0; // define ahead of goto
        MOVS     R0,#+0
// 11067 
// 11068   // Bail early if there's no code
// 11069   bool code_is_good = NUMERIC(*cmd_ptr);
        SUBS     R2,R2,#+48
        CMP      R2,#+10
        SBCS     R5,R5,R5
        LSRS     R5,R5,#+31
// 11070   if (!code_is_good) goto ExitUnknownCommand;
        BEQ.W    ??process_next_command_17
// 11071 
// 11072   // Get and skip the code number
// 11073   do {
// 11074     codenum = (codenum * 10) + (*cmd_ptr - '0');
??process_next_command_18:
        ADD      R2,R0,R0, LSL #+2
        LDRSB    R0,[R8, #+0]
        ADD      R0,R0,R2, LSL #+1
        SUBS     R0,R0,#+48
// 11075     cmd_ptr++;
// 11076   } while (NUMERIC(*cmd_ptr));
        LDRSB    R2,[R8, #+1]!
        SUBS     R2,R2,#+48
        CMP      R2,#+10
        BCC.N    ??process_next_command_18
// 11077 
// 11078   // Allow for decimal point in command
// 11079   #if ENABLED(G38_PROBE_TARGET)
// 11080     if (*cmd_ptr == '.') {
// 11081       cmd_ptr++;
// 11082       while (NUMERIC(*cmd_ptr))
// 11083         subcode = (subcode * 10) + (*cmd_ptr++ - '0');
// 11084     }
// 11085   #endif
// 11086 
// 11087   // Skip all spaces to get to the first argument, or nul
// 11088   while (*cmd_ptr == ' ') cmd_ptr++;
??process_next_command_19:
        LDRSB    R2,[R8, #+0]
        CMP      R2,#+32
        BNE.W    ??process_next_command_20
        ADD      R8,R8,#+1
        B.N      ??process_next_command_19
// 11089 
// 11090   // The command's arguments (if any) start here, for sure!
// 11091   current_command_args = cmd_ptr;
// 11092 
// 11093   KEEPALIVE_STATE(IN_HANDLER);
// 11094 
// 11095   // Handle a known G, M, or T
// 11096   switch (command_code) {
// 11097     case 'G': switch (codenum) {
// 11098 
// 11099       // G0, G1
// 11100       case 0:
// 11101       case 1:
// 11102       //  #if IS_SCARA
// 11103 		if(MACHINETPYE&IS_SCARA)
// 11104           gcode_G0_G1_SCARA(codenum == 0);
// 11105         //#else
// 11106         else
// 11107           gcode_G0_G1();
??process_next_command_21:
          CFI FunCall _Z11gcode_G0_G1v
        BL       _Z11gcode_G0_G1v
        B.N      ??process_next_command_22
// 11108         //#endif
// 11109         break;
// 11110 
// 11111       // G2, G3
// 11112       #if ENABLED(ARC_SUPPORT) && DISABLED(SCARA)
// 11113         case 2: // G2  - CW ARC
// 11114         case 3: // G3  - CCW ARC
// 11115           gcode_G2_G3(codenum == 2);
??process_next_command_23:
        UXTH     R0,R0
        CMP      R0,#+2
        BNE.N    ??process_next_command_24
        MOV      R0,R2
        B.N      ??process_next_command_25
??process_next_command_24:
        MOVS     R0,#+0
??process_next_command_25:
          CFI FunCall _Z11gcode_G2_G3b
        BL       _Z11gcode_G2_G3b
// 11116           break;
        B.N      ??process_next_command_22
// 11117       #endif
// 11118 
// 11119       // G4 Dwell
// 11120       case 4:
// 11121         gcode_G4();
??process_next_command_26:
          CFI FunCall _Z8gcode_G4v
        BL       _Z8gcode_G4v
// 11122         break;
        B.N      ??process_next_command_22
// 11123 
// 11124       #if ENABLED(BEZIER_CURVE_SUPPORT)
// 11125         // G5
// 11126         case 5: // G5  - Cubic B_spline
// 11127           gcode_G5();
// 11128           break;
// 11129       #endif // BEZIER_CURVE_SUPPORT
// 11130 
// 11131       #if ENABLED(FWRETRACT)
// 11132         case 10: // G10: retract
// 11133         case 11: // G11: retract_recover
// 11134           gcode_G10_G11(codenum == 10);
// 11135           break;
// 11136       #endif // FWRETRACT
// 11137 
// 11138       #if ENABLED(NOZZLE_CLEAN_FEATURE)
// 11139         case 12:
// 11140           gcode_G12(); // G12: Nozzle Clean
// 11141           break;
// 11142       #endif // NOZZLE_CLEAN_FEATURE
// 11143 
// 11144       #if ENABLED(INCH_MODE_SUPPORT)
// 11145         case 20: //G20: Inch Mode
// 11146           gcode_G20();
// 11147           break;
// 11148 
// 11149         case 21: //G21: MM Mode
// 11150           gcode_G21();
// 11151           break;
// 11152       #endif // INCH_MODE_SUPPORT
// 11153 
// 11154 //      #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(UBL_G26_MESH_EDITING)
// 11155 	  #if 1
// 11156         case 26: // G26: Mesh Validation Pattern generation
// 11157 		if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_UBL)
??process_next_command_27:
        LDR.W    R0,??DataTable141
        LDRB     R0,[R0, #+12]
        LSLS     R0,R0,#+27
        BPL.W    ??process_next_command_22
// 11158 	          gcode_G26();
          CFI FunCall _Z9gcode_G26v
        BL       _Z9gcode_G26v
        B.N      ??process_next_command_22
// 11159           break;
// 11160       #endif // AUTO_BED_LEVELING_UBL
// 11161 
// 11162       #if ENABLED(NOZZLE_PARK_FEATURE)
// 11163         case 27: // G27: Nozzle Park
// 11164           gcode_G27();
// 11165           break;
// 11166       #endif // NOZZLE_PARK_FEATURE
// 11167 
// 11168       case 28: // G28: Home all axes, one at a time
// 11169         gcode_G28();
??process_next_command_28:
          CFI FunCall _Z9gcode_G28v
        BL       _Z9gcode_G28v
// 11170 
// 11171 		if((BED_LEVELING_METHOD & HAS_LEVELING) && (BED_LEVELING_METHOD != AUTO_BED_LEVELING_UBL))
        LDR.W    R6,??DataTable141
        LDRB     R0,[R6, #+12]
        TST      R0,#0x3E
        BEQ.W    ??process_next_command_22
        CMP      R0,#+16
        BEQ.W    ??process_next_command_22
// 11172 			{
// 11173 			  set_bed_leveling_enabled(true);
        MOVS     R0,#+1
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
// 11174 		#if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
// 11175 			if((MACHINETPYE != DELTA) && (BED_LEVELING_METHOD&HAS_FADE))	//mks_delta
        LDRSH    R0,[R6, #+36]
        CMP      R0,#+2
        BEQ.W    ??process_next_command_22
        LDRB     R0,[R6, #+12]
        LSLS     R0,R0,#+27
        BPL.W    ??process_next_command_22
// 11176 			 { if (code_seen('Z')) set_z_fade_height(code_value_linear_units());}
        MOVS     R0,#+90
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.W    ??process_next_command_22
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
          CFI FunCall _Z17set_z_fade_heightf
        BL       _Z17set_z_fade_heightf
        B.N      ??process_next_command_22
// 11177 		#endif
// 11178 
// 11179 
// 11180 			}
// 11181         break;
// 11182 
// 11183       //#if HAS_LEVELING
// 11184         case 29: // G29 Detailed Z probe, probes the bed at 3 or more points,
// 11185                  // or provides access to the UBL System if enabled.
// 11186 		if(BED_LEVELING_METHOD&HAS_LEVELING)	
??process_next_command_29:
        LDR.W    R0,??DataTable141
        LDRB     R0,[R0, #+12]
        TST      R0,#0x3E
        BEQ.N    ??process_next_command_30
// 11187 			{
// 11188 			switch(BED_LEVELING_METHOD)		/*--mks cfg-- MESH_BED_LEVELING */ 
        CMP      R0,#+2
        BEQ.N    ??process_next_command_31
        CMP      R0,#+4
        BEQ.N    ??process_next_command_31
        CMP      R0,#+8
        BEQ.N    ??process_next_command_31
        CMP      R0,#+16
        BEQ.N    ??process_next_command_32
        CMP      R0,#+32
        BNE.N    ??process_next_command_33
// 11189 				{
// 11190 				case MESH_BED_LEVELING:
// 11191 					gcode_G29_MESH_BED_LEVELING();
          CFI FunCall _Z27gcode_G29_MESH_BED_LEVELINGv
        BL       _Z27gcode_G29_MESH_BED_LEVELINGv
// 11192 					(void)settings.save();
          CFI FunCall _ZN14MarlinSettings4saveEv
        BL       _ZN14MarlinSettings4saveEv
// 11193 					break;
        B.N      ??process_next_command_22
// 11194 				case AUTO_BED_LEVELING_3POINT:
// 11195 				case AUTO_BED_LEVELING_LINEAR:
// 11196 				case AUTO_BED_LEVELING_BILINEAR:
// 11197 					gcode_G29();
??process_next_command_31:
          CFI FunCall _Z9gcode_G29v
        BL       _Z9gcode_G29v
// 11198 					(void)settings.save();
          CFI FunCall _ZN14MarlinSettings4saveEv
        BL       _ZN14MarlinSettings4saveEv
// 11199 					break;
        B.N      ??process_next_command_22
// 11200 				case AUTO_BED_LEVELING_UBL:
// 11201 					gcode_G29_UBL();
??process_next_command_32:
          CFI FunCall _Z13gcode_G29_UBLv
        BL       _Z13gcode_G29_UBLv
// 11202 					break;
        B.N      ??process_next_command_22
// 11203 				default:
// 11204 					SERIAL_PROTOCOL("bed leveling hasn't defined!");
??process_next_command_33:
        LDR.W    R1,??DataTable141_1
        LDRB     R0,[R4, #+7]
        CMP      R0,#+0
        BNE.N    ??process_next_command_34
        LDR.W    R0,??DataTable140_5
          CFI FunCall _ZN12MarlinSerial5printEPKc
        BL       _ZN12MarlinSerial5printEPKc
        B.N      ??process_next_command_35
??process_next_command_34:
        LDR.W    R0,??DataTable140_6
          CFI FunCall _ZN12MarlinSerial5printEPKc
        BL       _ZN12MarlinSerial5printEPKc
// 11205 					SERIAL_EOL;
??process_next_command_35:
        LDRB     R0,[R4, #+7]
        CMP      R0,#+0
        BNE.N    ??process_next_command_36
        MOVS     R1,#+10
        LDR.W    R0,??DataTable140_5
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??process_next_command_22
??process_next_command_36:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.W    R0,??DataTable140_6
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
        B.N      ??process_next_command_22
// 11206 					break;
// 11207 				}
// 11208 			}
// 11209                 else
// 11210                 {
// 11211 		SERIAL_PROTOCOL("bed leveling hasn't defined!");
??process_next_command_30:
        LDR.W    R1,??DataTable141_1
        LDRB     R0,[R4, #+7]
        CMP      R0,#+0
        BNE.N    ??process_next_command_37
        LDR.W    R0,??DataTable140_5
          CFI FunCall _ZN12MarlinSerial5printEPKc
        BL       _ZN12MarlinSerial5printEPKc
        B.N      ??process_next_command_38
??process_next_command_37:
        LDR.W    R0,??DataTable140_6
          CFI FunCall _ZN12MarlinSerial5printEPKc
        BL       _ZN12MarlinSerial5printEPKc
// 11212 		SERIAL_EOL;
??process_next_command_38:
        LDRB     R0,[R4, #+7]
        CMP      R0,#+0
        BNE.N    ??process_next_command_39
        MOVS     R1,#+10
        LDR.W    R0,??DataTable140_5
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??process_next_command_22
??process_next_command_39:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.W    R0,??DataTable140_6
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
        B.N      ??process_next_command_22
// 11213                 }
// 11214 		
// 11215           break;
// 11216       //#endif // HAS_LEVELING
// 11217 
// 11218       #if HAS_BED_PROBE
// 11219 
// 11220         case 30: // G30 Single Z probe
// 11221           gcode_G30();
??process_next_command_40:
          CFI FunCall _Z9gcode_G30v
        BL       _Z9gcode_G30v
// 11222           break;
        B.N      ??process_next_command_22
// 11223 
// 11224         #if ENABLED(Z_PROBE_SLED)
// 11225 
// 11226             case 31: // G31: dock the sled
// 11227               gcode_G31();
// 11228               break;
// 11229 
// 11230             case 32: // G32: undock the sled
// 11231               gcode_G32();
// 11232               break;
// 11233 
// 11234         #endif // Z_PROBE_SLED
// 11235 
// 11236         #if ENABLED(DELTA_AUTO_CALIBRATION)
// 11237 
// 11238           case 33: // G33: Delta Auto-Calibration
// 11239             gcode_G33();
// 11240             break;
// 11241 
// 11242         #endif // DELTA_AUTO_CALIBRATION
// 11243 
// 11244       #endif // HAS_BED_PROBE
// 11245 
// 11246       #if ENABLED(G38_PROBE_TARGET)
// 11247         case 38: // G38.2 & G38.3
// 11248           if (subcode == 2 || subcode == 3)
// 11249             gcode_G38(subcode == 2);
// 11250           break;
// 11251       #endif
// 11252 
// 11253       case 90: // G90
// 11254         relative_mode = false;
??process_next_command_41:
        MOVS     R0,#+0
        STRB     R0,[R7, #+12]
// 11255         break;
        B.N      ??process_next_command_22
// 11256       case 91: // G91
// 11257         relative_mode = true;
??process_next_command_42:
        MOV      R0,R2
        STRB     R0,[R7, #+12]
// 11258         break;
        B.N      ??process_next_command_22
// 11259 
// 11260       case 92: // G92
// 11261         gcode_G92();
??process_next_command_43:
          CFI FunCall _Z9gcode_G92v
        BL       _Z9gcode_G92v
// 11262         break;
        B.N      ??process_next_command_22
// 11263     }
// 11264     break;
// 11265 
// 11266     case 'M': switch (codenum) {
??process_next_command_44:
        UXTH     R0,R0
        CMP      R0,#+1
        BLS.W    ??process_next_command_45
        SUBS     R0,R0,#+17
        BEQ.W    ??process_next_command_46
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_47
        SUBS     R0,R0,#+2
        BEQ.W    ??process_next_command_48
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_49
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_50
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_51
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_52
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_53
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_54
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_55
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_56
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_57
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_58
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_59
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_60
        SUBS     R0,R0,#+10
        BEQ.W    ??process_next_command_61
        SUBS     R0,R0,#+7
        BEQ.W    ??process_next_command_62
        SUBS     R0,R0,#+26
        BEQ.W    ??process_next_command_63
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_64
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_65
        SUBS     R0,R0,#+4
        BEQ.W    ??process_next_command_66
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_67
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_68
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_47
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_69
        SUBS     R0,R0,#+7
        BEQ.W    ??process_next_command_70
        SUBS     R0,R0,#+12
        BEQ.W    ??process_next_command_71
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_72
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_73
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_74
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_75
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_76
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_77
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_78
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_79
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_80
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_81
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_82
        SUBS     R0,R0,#+2
        BEQ.W    ??process_next_command_83
        SUBS     R0,R0,#+2
        BEQ.W    ??process_next_command_84
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_85
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_86
        SUBS     R0,R0,#+19
        BEQ.W    ??process_next_command_87
        SUBS     R0,R0,#+5
        BEQ.W    ??process_next_command_88
        SUBS     R0,R0,#+45
        BEQ.W    ??process_next_command_89
        SUBS     R0,R0,#+10
        BEQ.W    ??process_next_command_90
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_91
        SUBS     R0,R0,#+2
        BEQ.W    ??process_next_command_92
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_93
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_94
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_95
        SUBS     R0,R0,#+5
        BEQ.W    ??process_next_command_96
        SUBS     R0,R0,#+9
        BEQ.W    ??process_next_command_97
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_98
        SUBS     R0,R0,#+5
        BEQ.W    ??process_next_command_99
        SUBS     R0,R0,#+74
        BEQ.W    ??process_next_command_100
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_101
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_102
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_103
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_104
        SUBS     R0,R0,#+51
        BEQ.W    ??process_next_command_105
        SUBS     R0,R0,#+5
        BEQ.W    ??process_next_command_106
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_107
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_108
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_109
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_110
        SUBS     R0,R0,#+36
        BEQ.W    ??process_next_command_111
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_112
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_113
        SUBS     R0,R0,#+8
        BEQ.W    ??process_next_command_114
        SUBS     R0,R0,#+10
        BEQ.W    ??process_next_command_115
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_116
        SUBS     R0,R0,#+7
        BEQ.W    ??process_next_command_117
        SUBS     R0,R0,#+72
        BEQ.W    ??process_next_command_118
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_119
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_120
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_121
        SUBS     R0,R0,#+97
        BEQ.W    ??process_next_command_122
        SUBS     R0,R0,#+65
        BEQ.W    ??process_next_command_123
        SUBS     R0,R0,#+1
        BEQ.W    ??process_next_command_124
        SUBS     R0,R0,#+185
        BEQ.W    ??process_next_command_125
        SUBS     R0,R0,#+56
        BEQ.W    ??process_next_command_126
        SUBS     R0,R0,#+21
        BEQ.N    ??process_next_command_127
        SUBS     R0,R0,#+71
        BEQ.W    ??process_next_command_128
        B.N      ??process_next_command_22
// 11267       #if HAS_RESUME_CONTINUE
// 11268         case 0: // M0: Unconditional stop - Wait for user button press on LCD
// 11269         case 1: // M1: Conditional stop - Wait for user button press on LCD
// 11270           gcode_M0_M1();
??process_next_command_45:
          CFI FunCall _Z11gcode_M0_M1v
        BL       _Z11gcode_M0_M1v
// 11271           break;
        B.N      ??process_next_command_22
// 11272       #endif // ULTIPANEL
// 11273 
// 11274       case 17: // M17: Enable all stepper motors
// 11275         gcode_M17();
??process_next_command_46:
          CFI FunCall _Z9gcode_M17v
        BL       _Z9gcode_M17v
// 11276         break;
        B.N      ??process_next_command_22
// 11277 
// 11278       #if ENABLED(SDSUPPORT)
// 11279         case 20: // M20: list SD card
// 11280           gcode_M20(); break;
??process_next_command_48:
          CFI FunCall _Z9gcode_M20v
        BL       _Z9gcode_M20v
        B.N      ??process_next_command_22
// 11281         case 21: // M21: init SD card
// 11282           gcode_M21(); break;
??process_next_command_49:
          CFI FunCall _Z9gcode_M21v
        BL       _Z9gcode_M21v
        B.N      ??process_next_command_22
// 11283         case 22: // M22: release SD card
// 11284           gcode_M22(); break;
??process_next_command_50:
          CFI FunCall _Z9gcode_M22v
        BL       _Z9gcode_M22v
        B.N      ??process_next_command_22
// 11285         case 23: // M23: Select file
// 11286           memset(mksReprint.filename,0,sizeof(mksReprint.filename));
??process_next_command_51:
        MOVS     R2,#+0
        MOVS     R1,#+30
        ADD      R0,R6,#+20
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
// 11287           char *tmp_index = NULL;
// 11288 /*		  
// 11289           tmp_index = (char *)strstr(current_command_args, ",");
// 11290           if(tmp_index) *tmp_index = 0;
// 11291 		  
// 11292 		 if(mksReprint.dirname[0] == 0 || tmp_index != NULL)
// 11293 	  		{
// 11294 	  		strcpy(mksReprint.filename,current_command_args);
// 11295 	  		}
// 11296 	  	else
// 11297 	  		{
// 11298 	  		strcpy(mksReprint.filename,mksReprint.dirname);
// 11299 		  	strcat(mksReprint.filename,"/");
// 11300             strcat(mksReprint.filename,current_command_args);
// 11301 	  		}
// 11302 */
// 11303 	  tmp_index = (char *)strstr(current_command_args, "/");
        LDR      R7,[R7, #+40]
        ADR.W    R8,??process_next_command_0  ;; "/"
        MOV      R1,R8
        MOV      R0,R7
          CFI FunCall __iar_Strstr
        BL       __iar_Strstr
// 11304 	  if(tmp_index)
        CMP      R0,#+0
        BEQ.N    ??process_next_command_129
// 11305 	  	{
// 11306 		  	strcpy(mksReprint.filename,current_command_args);
        MOV      R1,R7
        ADD      R0,R6,#+20
          CFI FunCall strcpy
        BL       strcpy
        B.N      ??process_next_command_130
        DATA
??process_next_command_0:
        DC8      "/",0x0,0x0
        THUMB
// 11307 	  	}
// 11308 	  else
// 11309 	  	{
// 11310 	  	if(mksReprint.dirname[0] != 0)
??process_next_command_129:
        LDRSB    R0,[R6, #+0]
        CMP      R0,#+0
        BEQ.N    ??process_next_command_131
// 11311 	  		{
// 11312 			  strcpy(mksReprint.filename,mksReprint.dirname);
        MOV      R1,R6
        ADD      R0,R6,#+20
          CFI FunCall strcpy
        BL       strcpy
// 11313 			  strcat(mksReprint.filename,"/");
        MOV      R1,R8
        ADD      R0,R6,#+20
          CFI FunCall strcat
        BL       strcat
// 11314 	  		}
// 11315 		  strcat(mksReprint.filename,current_command_args);
??process_next_command_131:
        MOV      R1,R7
        ADD      R0,R6,#+20
          CFI FunCall strcat
        BL       strcat
// 11316 	  	
// 11317 	  	}
// 11318 		memset(mksReprint.dirname,0,sizeof(mksReprint.dirname));	//Ä¿Â¼ÃûÇåÁã
??process_next_command_130:
        MOVS     R2,#+0
        MOVS     R1,#+20
        MOV      R0,R6
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
// 11319 		
// 11320 	  //±£´æÎÄ¼þÃû
// 11321           epr_write_data(EPR_SAV_FILENAME, (uint8_t *)&mksReprint.filename[0],sizeof(mksReprint.filename));	
        MOVS     R2,#+30
        ADD      R1,R6,#+20
        MOVW     R0,#+1462
          CFI FunCall epr_write_data
        BL       epr_write_data
// 11322 		  mks_clearDir();	
          CFI FunCall mks_clearDir
        BL       mks_clearDir
// 11323 	  //Çå³ý ±£´æ¼ÇÂ¼
// 11324  	  	  mks_clearFile();
          CFI FunCall mks_clearFile
        BL       mks_clearFile
// 11325           gcode_M23(); 
          CFI FunCall _Z9gcode_M23v
        BL       _Z9gcode_M23v
// 11326           break;
        B.N      ??process_next_command_22
// 11327         case 24: // M24: Start SD print
// 11328           gcode_M24(); break;
??process_next_command_52:
          CFI FunCall _Z9gcode_M24v
        BL       _Z9gcode_M24v
        B.N      ??process_next_command_22
// 11329         case 25: // M25: Pause SD print
// 11330           gcode_M25(); break;
??process_next_command_53:
          CFI FunCall _Z9gcode_M25v
        BL       _Z9gcode_M25v
        B.N      ??process_next_command_22
// 11331         case 26: // M26: Set SD index
// 11332           gcode_M26(); break;
??process_next_command_54:
          CFI FunCall _Z9gcode_M26v
        BL       _Z9gcode_M26v
        B.N      ??process_next_command_22
// 11333         case 27: // M27: Get SD status
// 11334           gcode_M27(); break;
??process_next_command_55:
          CFI FunCall _Z9gcode_M27v
        BL       _Z9gcode_M27v
        B.N      ??process_next_command_22
// 11335         case 28: // M28: Start SD write
// 11336           gcode_M28(); break;
??process_next_command_56:
          CFI FunCall _Z9gcode_M28v
        BL       _Z9gcode_M28v
        B.N      ??process_next_command_22
// 11337         case 29: // M29: Stop SD write
// 11338           gcode_M29(); break;
??process_next_command_57:
          CFI FunCall _Z9gcode_M29v
        BL       _Z9gcode_M29v
        B.N      ??process_next_command_22
// 11339         case 30: // M30 <filename> Delete File
// 11340           gcode_M30(); break;
??process_next_command_58:
          CFI FunCall _Z9gcode_M30v
        BL       _Z9gcode_M30v
        B.N      ??process_next_command_22
// 11341         case 32: // M32: Select file and start SD print
// 11342           gcode_M32(); break;
??process_next_command_60:
          CFI FunCall _Z9gcode_M32v
        BL       _Z9gcode_M32v
        B.N      ??process_next_command_22
// 11343 
// 11344         #if ENABLED(LONG_FILENAME_HOST_SUPPORT)
// 11345           case 33: // M33: Get the long full path to a file or folder
// 11346             gcode_M33(); break;
// 11347         #endif
// 11348 
// 11349         #if ENABLED(SDCARD_SORT_ALPHA) && ENABLED(SDSORT_GCODE)
// 11350           case 34: //M34 - Set SD card sorting options
// 11351             gcode_M34(); break;
// 11352         #endif // SDCARD_SORT_ALPHA && SDSORT_GCODE
// 11353 
// 11354         case 928: // M928: Start SD write
// 11355           gcode_M928(); break;
??process_next_command_127:
          CFI FunCall _Z10gcode_M928v
        BL       _Z10gcode_M928v
        B.N      ??process_next_command_22
// 11356       #endif //SDSUPPORT
// 11357 
// 11358       case 31: // M31: Report time since the start of SD print or last M109
// 11359         gcode_M31(); break;
??process_next_command_59:
          CFI FunCall _Z9gcode_M31v
        BL       _Z9gcode_M31v
        B.N      ??process_next_command_22
// 11360 
// 11361       case 42: // M42: Change pin state
// 11362         gcode_M42(); break;
??process_next_command_61:
          CFI FunCall _Z9gcode_M42v
        BL       _Z9gcode_M42v
        B.N      ??process_next_command_22
// 11363 
// 11364       #if ENABLED(PINS_DEBUGGING)
// 11365         case 43: // M43: Read pin state
// 11366           gcode_M43(); break;
// 11367       #endif
// 11368 
// 11369 
// 11370       #if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
// 11371         case 48: // M48: Z probe repeatability test
// 11372           gcode_M48();
// 11373           break;
// 11374       #endif // Z_MIN_PROBE_REPEATABILITY_TEST
// 11375 
// 11376       //#if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(UBL_G26_MESH_EDITING)
// 11377 	  	#if 1
// 11378         case 49: // M49: Turn on or off G26 debug flag for verbose output
// 11379           if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_UBL)
??process_next_command_62:
        LDR.W    R0,??DataTable141
        LDRB     R0,[R0, #+12]
        LSLS     R0,R0,#+27
        BPL.W    ??process_next_command_22
// 11380           	gcode_M49();
          CFI FunCall _Z9gcode_M49v
        BL       _Z9gcode_M49v
        B.N      ??process_next_command_22
// 11381           break;
// 11382       #endif // AUTO_BED_LEVELING_UBL && UBL_G26_MESH_EDITING
// 11383 
// 11384       case 75: // M75: Start print timer
// 11385         gcode_M75(); break;
??process_next_command_63:
          CFI FunCall _Z9gcode_M75v
        BL       _Z9gcode_M75v
        B.N      ??process_next_command_22
// 11386       case 76: // M76: Pause print timer
// 11387         gcode_M76(); break;
??process_next_command_64:
          CFI FunCall _Z9gcode_M76v
        BL       _Z9gcode_M76v
        B.N      ??process_next_command_22
// 11388       case 77: // M77: Stop print timer
// 11389         gcode_M77(); break;
??process_next_command_65:
          CFI FunCall _Z9gcode_M77v
        BL       _Z9gcode_M77v
        B.N      ??process_next_command_22
// 11390 
// 11391       #if ENABLED(PRINTCOUNTER)
// 11392         case 78: // M78: Show print statistics
// 11393           gcode_M78(); break;
// 11394       #endif
// 11395 
// 11396       #if ENABLED(M100_FREE_MEMORY_WATCHER)
// 11397         case 100: // M100: Free Memory Report
// 11398           gcode_M100();
// 11399           break;
// 11400       #endif
// 11401 
// 11402       case 104: // M104: Set hot end temperature
// 11403         gcode_M104();
??process_next_command_71:
          CFI FunCall _Z10gcode_M104v
        BL       _Z10gcode_M104v
// 11404         break;
        B.N      ??process_next_command_22
// 11405 
// 11406       case 110: // M110: Set Current Line Number
// 11407         gcode_M110();
??process_next_command_77:
          CFI FunCall _Z10gcode_M110v
        BL       _Z10gcode_M110v
// 11408         break;
        B.N      ??process_next_command_22
// 11409 
// 11410       case 111: // M111: Set debug level
// 11411         gcode_M111();
??process_next_command_78:
          CFI FunCall _Z10gcode_M111v
        BL       _Z10gcode_M111v
// 11412         break;
        B.N      ??process_next_command_22
// 11413 
// 11414       #if DISABLED(EMERGENCY_PARSER)
// 11415 
// 11416         case 108: // M108: Cancel Waiting
// 11417           gcode_M108();
??process_next_command_75:
          CFI FunCall _Z10gcode_M108v
        BL       _Z10gcode_M108v
// 11418           break;
        B.N      ??process_next_command_22
// 11419 
// 11420         case 112: // M112: Emergency Stop
// 11421           gcode_M112();
??process_next_command_79:
          CFI FunCall _Z10gcode_M112v
        BL       _Z10gcode_M112v
// 11422           break;
        B.N      ??process_next_command_22
// 11423 
// 11424         case 410: // M410 quickstop - Abort all the planned moves.
// 11425           gcode_M410();
??process_next_command_114:
          CFI FunCall _Z10gcode_M410v
        BL       _Z10gcode_M410v
// 11426           break;
        B.N      ??process_next_command_22
// 11427 
// 11428       #endif
// 11429 
// 11430       #if ENABLED(HOST_KEEPALIVE_FEATURE)
// 11431         case 113: // M113: Set Host Keepalive interval
// 11432           gcode_M113();
??process_next_command_80:
          CFI FunCall _Z10gcode_M113v
        BL       _Z10gcode_M113v
// 11433           break;
        B.N      ??process_next_command_22
// 11434       #endif
// 11435       case 140: // M140: Set bed temperature
// 11436 	if(HAS_TEMP_BED)	/*--mks cfg-- HAS_TEMP_BED --*/
??process_next_command_87:
        LDR.W    R0,??DataTable141
        LDRB     R0,[R0, #+2]
        CMP      R0,#+0
        BEQ.N    ??process_next_command_132
// 11437           gcode_M140();
          CFI FunCall _Z10gcode_M140v
        BL       _Z10gcode_M140v
        B.N      ??process_next_command_22
// 11438         else
// 11439           SERIAL_PROTOCOLLNPGM("HAS_NO_TEMP_BED!"); 
??process_next_command_132:
        ADR.W    R0,?_38
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.N      ??process_next_command_22
// 11440         break;
// 11441       case 105: // M105: Report current temperature
// 11442         gcode_M105();
??process_next_command_72:
          CFI FunCall _Z10gcode_M105v
        BL       _Z10gcode_M105v
// 11443         KEEPALIVE_STATE(NOT_BUSY);
        MOVS     R0,#+0
        STRB     R0,[R4, #+6]
// 11444         return; // "ok" already printed
        B.N      ??process_next_command_133
// 11445         
// 11446 		/*--mks cfg-- HAS_TEMP_BED --*/
// 11447       //#if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
// 11448 		#if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND)
// 11449         case 155: // M155: Set temperature auto-report interval
// 11450           gcode_M155();
// 11451           break;
// 11452       #endif
// 11453 
// 11454       case 109: // M109: Wait for hotend temperature to reach target
// 11455         gcode_M109();
??process_next_command_76:
          CFI FunCall _Z10gcode_M109v
        BL       _Z10gcode_M109v
// 11456         break;
        B.N      ??process_next_command_22
// 11457 
// 11458      // #if HAS_TEMP_BED	/*--mks cfg-- HAS_TEMP_BED --*/
// 11459         case 190: // M190: Wait for bed temperature to reach target
// 11460          if(HAS_TEMP_BED) 
??process_next_command_89:
        LDR.W    R0,??DataTable141
        LDRB     R0,[R0, #+2]
        CMP      R0,#+0
        BEQ.N    ??process_next_command_134
// 11461           gcode_M190();
          CFI FunCall _Z10gcode_M190v
        BL       _Z10gcode_M190v
        B.N      ??process_next_command_22
// 11462          else
// 11463            SERIAL_PROTOCOLLNPGM("HAS_NO_TEMP_BED!");
??process_next_command_134:
        ADR.W    R0,?_38
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.N      ??process_next_command_22
// 11464           break;
// 11465       //#endif // HAS_TEMP_BED
// 11466 
// 11467       #if FAN_COUNT > 0
// 11468         case 106: // M106: Fan On
// 11469           gcode_M106();
??process_next_command_73:
          CFI FunCall _Z10gcode_M106v
        BL       _Z10gcode_M106v
// 11470           break;
        B.N      ??process_next_command_22
// 11471         case 107: // M107: Fan Off
// 11472           gcode_M107();
??process_next_command_74:
          CFI FunCall _Z10gcode_M107v
        BL       _Z10gcode_M107v
// 11473           break;
        B.N      ??process_next_command_22
// 11474       #endif // FAN_COUNT > 0
// 11475 
// 11476       #if ENABLED(PARK_HEAD_ON_PAUSE)
// 11477         case 125: // M125: Store current position and move to filament change position
// 11478           gcode_M125(); break;
// 11479       #endif
// 11480 
// 11481       #if ENABLED(BARICUDA)
// 11482         // PWM for HEATER_1_PIN
// 11483         #if HAS_HEATER_1
// 11484           case 126: // M126: valve open
// 11485             gcode_M126();
// 11486             break;
// 11487           case 127: // M127: valve closed
// 11488             gcode_M127();
// 11489             break;
// 11490         #endif // HAS_HEATER_1
// 11491 
// 11492         // PWM for HEATER_2_PIN
// 11493         #if HAS_HEATER_2
// 11494           case 128: // M128: valve open
// 11495             gcode_M128();
// 11496             break;
// 11497           case 129: // M129: valve closed
// 11498             gcode_M129();
// 11499             break;
// 11500         #endif // HAS_HEATER_2
// 11501       #endif // BARICUDA
// 11502 
// 11503       #if HAS_POWER_SWITCH
// 11504 
// 11505         case 80: // M80: Turn on Power Supply
// 11506           gcode_M80();
// 11507           break;
// 11508 
// 11509       #endif // HAS_POWER_SWITCH
// 11510 
// 11511       case 81: // M81: Turn off Power, including Power Supply, if possible
// 11512         gcode_M81();
??process_next_command_66:
          CFI FunCall _Z9gcode_M81v
        BL       _Z9gcode_M81v
// 11513         break;
        B.N      ??process_next_command_22
// 11514 
// 11515       case 82: // M83: Set E axis normal mode (same as other axes)
// 11516         gcode_M82();
??process_next_command_67:
          CFI FunCall _Z9gcode_M82v
        BL       _Z9gcode_M82v
// 11517         break;
        B.N      ??process_next_command_22
// 11518       case 83: // M83: Set E axis relative mode
// 11519         gcode_M83();
??process_next_command_68:
          CFI FunCall _Z9gcode_M83v
        BL       _Z9gcode_M83v
// 11520         break;
        B.N      ??process_next_command_22
// 11521       case 18: // M18 => M84
// 11522       case 84: // M84: Disable all steppers or set timeout
// 11523         gcode_M18_M84();
??process_next_command_47:
          CFI FunCall _Z13gcode_M18_M84v
        BL       _Z13gcode_M18_M84v
// 11524         break;
        B.N      ??process_next_command_22
// 11525       case 85: // M85: Set inactivity stepper shutdown timeout
// 11526         gcode_M85();
??process_next_command_69:
          CFI FunCall _Z9gcode_M85v
        BL       _Z9gcode_M85v
// 11527         break;
        B.N      ??process_next_command_22
// 11528       case 92: // M92: Set the steps-per-unit for one or more axes
// 11529         gcode_M92();
??process_next_command_70:
          CFI FunCall _Z9gcode_M92v
        BL       _Z9gcode_M92v
// 11530         break;
        B.N      ??process_next_command_22
// 11531       case 114: // M114: Report current position
// 11532         gcode_M114();
??process_next_command_81:
          CFI FunCall _Z10gcode_M114v
        BL       _Z10gcode_M114v
// 11533         break;
        B.N      ??process_next_command_22
// 11534       case 115: // M115: Report capabilities
// 11535         gcode_M115();
??process_next_command_82:
          CFI FunCall _Z10gcode_M115v
        BL       _Z10gcode_M115v
// 11536         break;
        B.N      ??process_next_command_22
// 11537       case 117: // M117: Set LCD message text, if possible
// 11538         gcode_M117();
??process_next_command_83:
          CFI FunCall _Z10gcode_M117v
        BL       _Z10gcode_M117v
// 11539         break;
        B.N      ??process_next_command_22
// 11540       case 119: // M119: Report endstop states
// 11541         gcode_M119();
??process_next_command_84:
          CFI FunCall _Z10gcode_M119v
        BL       _Z10gcode_M119v
// 11542         break;
        B.N      ??process_next_command_22
// 11543       case 120: // M120: Enable endstops
// 11544         gcode_M120();
??process_next_command_85:
          CFI FunCall _Z10gcode_M120v
        BL       _Z10gcode_M120v
// 11545         break;
        B.N      ??process_next_command_22
// 11546       case 121: // M121: Disable endstops
// 11547         gcode_M121();
??process_next_command_86:
          CFI FunCall _Z10gcode_M121v
        BL       _Z10gcode_M121v
// 11548         break;
        B.N      ??process_next_command_22
// 11549 
// 11550       #if ENABLED(ULTIPANEL)
// 11551 
// 11552         case 145: // M145: Set material heatup parameters
// 11553           gcode_M145();
??process_next_command_88:
          CFI FunCall _Z10gcode_M145v
        BL       _Z10gcode_M145v
// 11554           break;
        B.N      ??process_next_command_22
// 11555 
// 11556       #endif
// 11557 
// 11558       #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
// 11559         case 149: // M149: Set temperature units
// 11560           gcode_M149();
// 11561           break;
// 11562       #endif
// 11563 
// 11564       #if HAS_COLOR_LEDS
// 11565 
// 11566         case 150: // M150: Set Status LED Color
// 11567           gcode_M150();
// 11568           break;
// 11569 
// 11570       #endif // BLINKM
// 11571 
// 11572       #if ENABLED(MIXING_EXTRUDER)
// 11573         case 163: // M163: Set a component weight for mixing extruder
// 11574           gcode_M163();
// 11575           break;
// 11576         #if MIXING_VIRTUAL_TOOLS > 1
// 11577           case 164: // M164: Save current mix as a virtual extruder
// 11578             gcode_M164();
// 11579             break;
// 11580         #endif
// 11581         #if ENABLED(DIRECT_MIXING_IN_G1)
// 11582           case 165: // M165: Set multiple mix weights
// 11583             gcode_M165();
// 11584             break;
// 11585         #endif
// 11586       #endif
// 11587 
// 11588       case 200: // M200: Set filament diameter, E to cubic units
// 11589         gcode_M200();
??process_next_command_90:
          CFI FunCall _Z10gcode_M200v
        BL       _Z10gcode_M200v
// 11590         break;
        B.N      ??process_next_command_22
// 11591       case 201: // M201: Set max acceleration for print moves (units/s^2)
// 11592         gcode_M201();
??process_next_command_91:
          CFI FunCall _Z10gcode_M201v
        BL       _Z10gcode_M201v
// 11593         break;
        B.N      ??process_next_command_22
// 11594       #if 0 // Not used for Sprinter/grbl gen6
// 11595         case 202: // M202
// 11596           gcode_M202();
// 11597           break;
// 11598       #endif
// 11599       case 203: // M203: Set max feedrate (units/sec)
// 11600         gcode_M203();
??process_next_command_92:
          CFI FunCall _Z10gcode_M203v
        BL       _Z10gcode_M203v
// 11601         break;
        B.N      ??process_next_command_22
// 11602       case 204: // M204: Set acceleration
// 11603         gcode_M204();
??process_next_command_93:
          CFI FunCall _Z10gcode_M204v
        BL       _Z10gcode_M204v
// 11604         break;
        B.N      ??process_next_command_22
// 11605       case 205: //M205: Set advanced settings
// 11606         gcode_M205();
??process_next_command_94:
          CFI FunCall _Z10gcode_M205v
        BL       _Z10gcode_M205v
// 11607         break;
        B.N      ??process_next_command_22
// 11608 
// 11609       //#if HAS_M206_COMMAND	//mks_delta
// 11610         case 206: // M206: Set home offsets
// 11611         if(MACHINETPYE != DELTA)
??process_next_command_95:
        LDR.W    R0,??DataTable141
        LDRSH    R0,[R0, #+36]
        CMP      R0,#+2
        BEQ.W    ??process_next_command_22
// 11612           gcode_M206();
          CFI FunCall _Z10gcode_M206v
        BL       _Z10gcode_M206v
        B.N      ??process_next_command_22
// 11613           break;
// 11614       //#endif
// 11615 
// 11616       //#if ENABLED(DELTA)
// 11617         case 665: // M665: Set delta configurations
// 11618         	if(MACHINETPYE == DELTA)
??process_next_command_123:
        LDR.W    R0,??DataTable141
        LDRSH    R0,[R0, #+36]
        CMP      R0,#+2
        BNE.W    ??process_next_command_22
// 11619           gcode_M665();
          CFI FunCall _Z10gcode_M665v
        BL       _Z10gcode_M665v
        B.N      ??process_next_command_22
// 11620           break;
// 11621       //#endif
// 11622 
// 11623       //#if ENABLED(DELTA) || ENABLED(Z_DUAL_ENDSTOPS)
// 11624         case 666: // M666: Set delta or dual endstop adjustment
// 11625         if(MACHINETPYE == DELTA)
??process_next_command_124:
        LDR.W    R0,??DataTable141
        LDRSH    R0,[R0, #+36]
        CMP      R0,#+2
        BNE.W    ??process_next_command_22
// 11626           gcode_M666();
          CFI FunCall _Z10gcode_M666v
        BL       _Z10gcode_M666v
        B.N      ??process_next_command_22
// 11627           break;
// 11628       //#endif
// 11629 
// 11630       #if ENABLED(FWRETRACT)
// 11631         case 207: // M207: Set Retract Length, Feedrate, and Z lift
// 11632           gcode_M207();
// 11633           break;
// 11634         case 208: // M208: Set Recover (unretract) Additional Length and Feedrate
// 11635           gcode_M208();
// 11636           break;
// 11637         case 209: // M209: Turn Automatic Retract Detection on/off
// 11638           gcode_M209();
// 11639           break;
// 11640       #endif // FWRETRACT
// 11641 
// 11642       case 211: // M211: Enable, Disable, and/or Report software endstops
// 11643         gcode_M211();
??process_next_command_96:
          CFI FunCall _Z10gcode_M211v
        BL       _Z10gcode_M211v
// 11644         break;
        B.N      ??process_next_command_22
// 11645 
// 11646       #if HOTENDS > 1
// 11647         case 218: // M218: Set a tool offset
// 11648           gcode_M218();
// 11649           break;
// 11650       #endif
// 11651 
// 11652       case 220: // M220: Set Feedrate Percentage: S<percent> ("FR" on your LCD)
// 11653         gcode_M220();
??process_next_command_97:
          CFI FunCall _Z10gcode_M220v
        BL       _Z10gcode_M220v
// 11654         break;
        B.N      ??process_next_command_22
// 11655 
// 11656       case 221: // M221: Set Flow Percentage
// 11657         gcode_M221();
??process_next_command_98:
          CFI FunCall _Z10gcode_M221v
        BL       _Z10gcode_M221v
// 11658         break;
        B.N      ??process_next_command_22
// 11659 
// 11660       case 226: // M226: Wait until a pin reaches a state
// 11661         gcode_M226();
??process_next_command_99:
          CFI FunCall _Z10gcode_M226v
        BL       _Z10gcode_M226v
// 11662         break;
        B.N      ??process_next_command_22
// 11663 
// 11664       #if HAS_SERVOS
// 11665         case 280: // M280: Set servo position absolute
// 11666           gcode_M280();
// 11667           break;
// 11668       #endif // HAS_SERVOS
// 11669 
// 11670       #if HAS_BUZZER
// 11671         case 300: // M300: Play beep tone
// 11672           gcode_M300();
??process_next_command_100:
          CFI FunCall _Z10gcode_M300v
        BL       _Z10gcode_M300v
// 11673           break;
        B.N      ??process_next_command_22
// 11674       #endif // HAS_BUZZER
// 11675 
// 11676       //#if ENABLED(PIDTEMP)	/*--mks cfg--*/
// 11677         case 301: // M301: Set hotend PID parameters
// 11678 		if(PIDTEMP) 
??process_next_command_101:
        LDR.W    R0,??DataTable145
        LDRB     R0,[R0, #+52]
        CMP      R0,#+0
        BEQ.W    ??process_next_command_22
// 11679           gcode_M301();
          CFI FunCall _Z10gcode_M301v
        BL       _Z10gcode_M301v
        B.N      ??process_next_command_22
// 11680           break;
// 11681       //#endif // PIDTEMP
// 11682 
// 11683       //#if ENABLED(PIDTEMPBED)	/*--mks cfg--*/
// 11684         case 304: // M304: Set bed PID parameters
// 11685 		if(PIDTEMPBED) 
??process_next_command_104:
        LDR.W    R0,??DataTable141
        LDRB     R0,[R0, #+1]
        CMP      R0,#+0
        BEQ.W    ??process_next_command_22
// 11686           gcode_M304();
          CFI FunCall _Z10gcode_M304v
        BL       _Z10gcode_M304v
        B.N      ??process_next_command_22
// 11687           break;
// 11688       //#endif // PIDTEMPBED
// 11689 
// 11690       #if defined(CHDK) || HAS_PHOTOGRAPH
// 11691         case 240: // M240: Trigger a camera by emulating a Canon RC-1 : http://www.doc-diy.net/photo/rc-1_hacked/
// 11692           gcode_M240();
// 11693           break;
// 11694       #endif // CHDK || PHOTOGRAPH_PIN
// 11695 
// 11696       #if HAS_LCD_CONTRAST
// 11697         case 250: // M250: Set LCD contrast
// 11698           gcode_M250();
// 11699           break;
// 11700       #endif // HAS_LCD_CONTRAST
// 11701 
// 11702       #if ENABLED(EXPERIMENTAL_I2CBUS)
// 11703 
// 11704         case 260: // M260: Send data to an i2c slave
// 11705           gcode_M260();
// 11706           break;
// 11707 
// 11708         case 261: // M261: Request data from an i2c slave
// 11709           gcode_M261();
// 11710           break;
// 11711 
// 11712       #endif // EXPERIMENTAL_I2CBUS
// 11713 
// 11714       #if ENABLED(PREVENT_COLD_EXTRUSION)
// 11715         case 302: // M302: Allow cold extrudes (set the minimum extrude temperature)
// 11716           gcode_M302();
??process_next_command_102:
          CFI FunCall _Z10gcode_M302v
        BL       _Z10gcode_M302v
// 11717           break;
        B.N      ??process_next_command_22
// 11718       #endif // PREVENT_COLD_EXTRUSION
// 11719 
// 11720       case 303: // M303: PID autotune
// 11721         gcode_M303();
??process_next_command_103:
          CFI FunCall _Z10gcode_M303v
        BL       _Z10gcode_M303v
// 11722         break;
        B.N      ??process_next_command_22
// 11723 
// 11724       //#if ENABLED(MORGAN_SCARA)
// 11725         case 360:  // M360: SCARA Theta pos1
// 11726         	if(MACHINETPYE == MORGAN_SCARA)
??process_next_command_106:
        LDR.W    R0,??DataTable141
        LDRSH    R0,[R0, #+36]
        CMP      R0,#+256
        BNE.N    ??process_next_command_22
// 11727           if (gcode_M360()) return;
          CFI FunCall _Z10gcode_M360v
        BL       _Z10gcode_M360v
        CMP      R0,#+0
        BEQ.N    ??process_next_command_22
        B.N      ??process_next_command_133
// 11728           break;
// 11729         case 361:  // M361: SCARA Theta pos2
// 11730         	if(MACHINETPYE == MORGAN_SCARA)
??process_next_command_107:
        LDR.W    R0,??DataTable141
        LDRSH    R0,[R0, #+36]
        CMP      R0,#+256
        BNE.N    ??process_next_command_22
// 11731           if (gcode_M361()) return;
          CFI FunCall _Z10gcode_M361v
        BL       _Z10gcode_M361v
        CMP      R0,#+0
        BEQ.N    ??process_next_command_22
        B.N      ??process_next_command_133
// 11732           break;
// 11733         case 362:  // M362: SCARA Psi pos1
// 11734        	 if(MACHINETPYE == MORGAN_SCARA)
??process_next_command_108:
        LDR.W    R0,??DataTable141
        LDRSH    R0,[R0, #+36]
        CMP      R0,#+256
        BNE.N    ??process_next_command_22
// 11735           if (gcode_M362()) return;
          CFI FunCall _Z10gcode_M362v
        BL       _Z10gcode_M362v
        CMP      R0,#+0
        BEQ.N    ??process_next_command_22
        B.N      ??process_next_command_133
// 11736           break;
// 11737         case 363:  // M363: SCARA Psi pos2
// 11738         	if(MACHINETPYE == MORGAN_SCARA)
??process_next_command_109:
        LDR.W    R0,??DataTable141
        LDRSH    R0,[R0, #+36]
        CMP      R0,#+256
        BNE.N    ??process_next_command_22
// 11739           if (gcode_M363()) return;
          CFI FunCall _Z10gcode_M363v
        BL       _Z10gcode_M363v
        CMP      R0,#+0
        BEQ.N    ??process_next_command_22
        B.N      ??process_next_command_133
// 11740           break;
// 11741         case 364:  // M364: SCARA Psi pos3 (90 deg to Theta)
// 11742         	if(MACHINETPYE == MORGAN_SCARA)
??process_next_command_110:
        LDR.W    R0,??DataTable141
        LDRSH    R0,[R0, #+36]
        CMP      R0,#+256
        BNE.N    ??process_next_command_22
// 11743           if (gcode_M364()) return;
          CFI FunCall _Z10gcode_M364v
        BL       _Z10gcode_M364v
        CMP      R0,#+0
        BEQ.N    ??process_next_command_22
        B.N      ??process_next_command_133
// 11744           break;
// 11745       //#endif // SCARA
// 11746 
// 11747       case 400: // M400: Finish all moves
// 11748         gcode_M400();
??process_next_command_111:
          CFI FunCall _Z10gcode_M400v
        BL       _Z10gcode_M400v
// 11749         break;
        B.N      ??process_next_command_22
// 11750 
// 11751       #if HAS_BED_PROBE
// 11752         case 401: // M401: Deploy probe
// 11753           gcode_M401();
??process_next_command_112:
          CFI FunCall _Z10gcode_M401v
        BL       _Z10gcode_M401v
// 11754           break;
        B.N      ??process_next_command_22
// 11755         case 402: // M402: Stow probe
// 11756           gcode_M402();
??process_next_command_113:
          CFI FunCall _Z10gcode_M402v
        BL       _Z10gcode_M402v
// 11757           break;
        B.N      ??process_next_command_22
// 11758       #endif // HAS_BED_PROBE
// 11759 
// 11760       #if ENABLED(FILAMENT_WIDTH_SENSOR)
// 11761         case 404:  // M404: Enter the nominal filament width (3mm, 1.75mm ) N<3.0> or display nominal filament width
// 11762           gcode_M404();
// 11763           break;
// 11764         case 405:  // M405: Turn on filament sensor for control
// 11765           gcode_M405();
// 11766           break;
// 11767         case 406:  // M406: Turn off filament sensor for control
// 11768           gcode_M406();
// 11769           break;
// 11770         case 407:   // M407: Display measured filament diameter
// 11771           gcode_M407();
// 11772           break;
// 11773       #endif // FILAMENT_WIDTH_SENSOR
// 11774 
// 11775       //#if HAS_LEVELING
// 11776         case 420: // M420: Enable/Disable Bed Leveling
// 11777         if(BED_LEVELING_METHOD&HAS_LEVELING)
??process_next_command_115:
        LDR.W    R0,??DataTable141
        LDRB     R0,[R0, #+12]
        TST      R0,#0x3E
        BEQ.N    ??process_next_command_22
// 11778           gcode_M420();
          CFI FunCall _Z10gcode_M420v
        BL       _Z10gcode_M420v
        B.N      ??process_next_command_22
// 11779           break;
// 11780       //#endif
// 11781 
// 11782 	  /*--mks cfg-- MESH_BED_LEVELING */
// 11783 //      #if ENABLED(MESH_BED_LEVELING) || ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 11784 		#if 1
// 11785         case 421: // M421: Set a Mesh Bed Leveling Z coordinate
// 11786         if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
??process_next_command_116:
        LDR.W    R0,??DataTable141
        LDRB     R0,[R0, #+12]
        CMP      R0,#+32
        BNE.N    ??process_next_command_135
// 11787           gcode_M421_MESH_BED_LEVELING();
          CFI FunCall _Z28gcode_M421_MESH_BED_LEVELINGv
        BL       _Z28gcode_M421_MESH_BED_LEVELINGv
        B.N      ??process_next_command_22
// 11788 		else
// 11789 		  gcode_M421();
??process_next_command_135:
          CFI FunCall _Z10gcode_M421v
        BL       _Z10gcode_M421v
        B.N      ??process_next_command_22
// 11790           break;
// 11791       #endif
// 11792 
// 11793       //#if HAS_M206_COMMAND	//mks_delta
// 11794         case 428: // M428: Apply current_position to home_offset
// 11795         if(MACHINETPYE != DELTA)
??process_next_command_117:
        LDR.W    R0,??DataTable141
        LDRSH    R0,[R0, #+36]
        CMP      R0,#+2
        BEQ.N    ??process_next_command_22
// 11796           gcode_M428();
          CFI FunCall _Z10gcode_M428v
        BL       _Z10gcode_M428v
        B.N      ??process_next_command_22
// 11797           break;
// 11798       //#endif
// 11799 
// 11800       case 500: // M500: Store settings in EEPROM
// 11801         gcode_M500();
??process_next_command_118:
          CFI FunCall _Z10gcode_M500v
        BL       _Z10gcode_M500v
// 11802         break;
        B.N      ??process_next_command_22
// 11803       case 501: // M501: Read settings from EEPROM
// 11804         gcode_M501();
??process_next_command_119:
          CFI FunCall _Z10gcode_M501v
        BL       _Z10gcode_M501v
// 11805         break;
        B.N      ??process_next_command_22
// 11806       case 502: // M502: Revert to default settings
// 11807         gcode_M502();
??process_next_command_120:
          CFI FunCall _Z10gcode_M502v
        BL       _Z10gcode_M502v
// 11808         break;
        B.N      ??process_next_command_22
// 11809       case 503: // M503: print settings currently in memory
// 11810         gcode_M503();
??process_next_command_121:
          CFI FunCall _Z10gcode_M503v
        BL       _Z10gcode_M503v
// 11811         break;
        B.N      ??process_next_command_22
// 11812 
// 11813       #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
// 11814         case 540: // M540: Set abort on endstop hit for SD printing
// 11815           gcode_M540();
// 11816           break;
// 11817       #endif
// 11818 
// 11819       #if HAS_BED_PROBE
// 11820         case 851: // M851: Set Z Probe Z Offset
// 11821           gcode_M851();
??process_next_command_125:
          CFI FunCall _Z10gcode_M851v
        BL       _Z10gcode_M851v
// 11822           break;
        B.N      ??process_next_command_22
// 11823       #endif // HAS_BED_PROBE
// 11824 
// 11825       #if ENABLED(FILAMENT_CHANGE_FEATURE)
// 11826         case 600: // M600: Pause for filament change
// 11827           gcode_M600();
??process_next_command_122:
          CFI FunCall _Z10gcode_M600v
        BL       _Z10gcode_M600v
// 11828           break;
        B.N      ??process_next_command_22
// 11829       #endif // FILAMENT_CHANGE_FEATURE
// 11830 
// 11831       #if ENABLED(DUAL_X_CARRIAGE)
// 11832         case 605: // M605: Set Dual X Carriage movement mode
// 11833           gcode_M605();
// 11834           break;
// 11835       #endif // DUAL_X_CARRIAGE
// 11836 
// 11837       #if ENABLED(LIN_ADVANCE)
// 11838         case 900: // M900: Set advance K factor.
// 11839           gcode_M900();
// 11840           break;
// 11841       #endif
// 11842 
// 11843       #if ENABLED(HAVE_TMC2130)
// 11844         case 906: // M906: Set motor current in milliamps using axis codes X, Y, Z, E
// 11845           gcode_M906();
// 11846           break;
// 11847       #endif
// 11848 
// 11849       case 907: // M907: Set digital trimpot motor current using axis codes.
// 11850         gcode_M907();
??process_next_command_126:
          CFI FunCall _Z10gcode_M907v
        BL       _Z10gcode_M907v
// 11851         break;
        B.N      ??process_next_command_22
// 11852 
// 11853       #if HAS_DIGIPOTSS || ENABLED(DAC_STEPPER_CURRENT)
// 11854 
// 11855         case 908: // M908: Control digital trimpot directly.
// 11856           gcode_M908();
// 11857           break;
// 11858 
// 11859         #if ENABLED(DAC_STEPPER_CURRENT) // As with Printrbot RevF
// 11860 
// 11861           case 909: // M909: Print digipot/DAC current value
// 11862             gcode_M909();
// 11863             break;
// 11864 
// 11865           case 910: // M910: Commit digipot/DAC value to external EEPROM
// 11866             gcode_M910();
// 11867             break;
// 11868 
// 11869         #endif
// 11870 
// 11871       #endif // HAS_DIGIPOTSS || DAC_STEPPER_CURRENT
// 11872 
// 11873       #if ENABLED(HAVE_TMC2130)
// 11874         case 911: // M911: Report TMC2130 prewarn triggered flags
// 11875           gcode_M911();
// 11876           break;
// 11877 
// 11878         case 912: // M911: Clear TMC2130 prewarn triggered flags
// 11879           gcode_M912();
// 11880           break;
// 11881 
// 11882         #if ENABLED(HYBRID_THRESHOLD)
// 11883           case 913: // M913: Set HYBRID_THRESHOLD speed.
// 11884             gcode_M913();
// 11885             break;
// 11886         #endif
// 11887 
// 11888         #if ENABLED(SENSORLESS_HOMING)
// 11889           case 914: // M914: Set SENSORLESS_HOMING sensitivity.
// 11890             gcode_M914();
// 11891             break;
// 11892         #endif
// 11893       #endif
// 11894 
// 11895       #if HAS_MICROSTEPS
// 11896 
// 11897         case 350: // M350: Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.
// 11898           gcode_M350();
// 11899           break;
// 11900 
// 11901         case 351: // M351: Toggle MS1 MS2 pins directly, S# determines MS1 or MS2, X# sets the pin high/low.
// 11902           gcode_M351();
// 11903           break;
// 11904 
// 11905       #endif // HAS_MICROSTEPS
// 11906 
// 11907       case 355: // M355 Turn case lights on/off
// 11908         gcode_M355();
??process_next_command_105:
          CFI FunCall _Z10gcode_M355v
        BL       _Z10gcode_M355v
// 11909         break;
        B.N      ??process_next_command_22
// 11910 
// 11911       case 999: // M999: Restart after being Stopped
// 11912         gcode_M999();
??process_next_command_128:
          CFI FunCall _Z10gcode_M999v
        BL       _Z10gcode_M999v
// 11913         break;
        B.N      ??process_next_command_22
// 11914     }
// 11915     break;
// 11916 
// 11917     case 'T':
// 11918       gcode_T(codenum);
??process_next_command_136:
        UXTB     R0,R0
          CFI FunCall _Z7gcode_Th
        BL       _Z7gcode_Th
// 11919       break;
        B.N      ??process_next_command_22
// 11920 
// 11921     default: code_is_good = false;
??process_next_command_137:
        MOVS     R5,#+0
// 11922   }
// 11923 
// 11924   KEEPALIVE_STATE(NOT_BUSY);
??process_next_command_22:
        MOVS     R0,#+0
        STRB     R0,[R4, #+6]
// 11925 
// 11926 ExitUnknownCommand:
// 11927 
// 11928   // Still unknown command? Throw an error
// 11929   if (!code_is_good) unknown_command_error();
??process_next_command_17:
        CMP      R5,#+0
        BNE.N    ??process_next_command_138
          CFI FunCall _Z21unknown_command_errorv
        BL       _Z21unknown_command_errorv
// 11930 
// 11931   ok_to_send();
??process_next_command_138:
        POP      {R4-R8,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z10ok_to_sendv
        B.N      _Z10ok_to_sendv
          CFI R4 Frame(CFA, -24)
          CFI R5 Frame(CFA, -20)
          CFI R6 Frame(CFA, -16)
          CFI R7 Frame(CFA, -12)
          CFI R8 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+24
??process_next_command_133:
        POP      {R4-R8,PC}       ;; return
??process_next_command_7:
        LDR      R8,[R7, #+36]
        MOVS     R1,#+42
        MOV      R0,R8
          CFI FunCall __iar_Strchr
        BL       __iar_Strchr
        CMP      R0,#+0
        BEQ.W    ??process_next_command_14
        B.N      ??process_next_command_13
??process_next_command_20:
        STR      R8,[R7, #+40]
        MOVS     R2,#+1
        STRB     R2,[R4, #+6]
        CMP      R1,#+71
        BEQ.N    ??process_next_command_139
        CMP      R1,#+77
        BEQ.W    ??process_next_command_44
        CMP      R1,#+84
        BEQ.N    ??process_next_command_136
        B.N      ??process_next_command_137
??process_next_command_139:
        MOV      R1,R0
        UXTH     R1,R1
        CMP      R1,#+0
        BEQ.N    ??process_next_command_140
        CMP      R1,#+1
        BEQ.N    ??process_next_command_140
        CMP      R1,#+2
        BEQ.W    ??process_next_command_23
        CMP      R1,#+3
        BEQ.W    ??process_next_command_23
        CMP      R1,#+4
        BEQ.W    ??process_next_command_26
        CMP      R1,#+26
        BEQ.W    ??process_next_command_27
        CMP      R1,#+28
        BEQ.W    ??process_next_command_28
        CMP      R1,#+29
        BEQ.W    ??process_next_command_29
        CMP      R1,#+30
        BEQ.W    ??process_next_command_40
        CMP      R1,#+90
        BEQ.W    ??process_next_command_41
        CMP      R1,#+91
        BEQ.W    ??process_next_command_42
        CMP      R1,#+92
        BEQ.W    ??process_next_command_43
        B.N      ??process_next_command_22
??process_next_command_140:
        LDR.W    R1,??DataTable141
        LDRH     R1,[R1, #+36]
        TST      R1,#0x300
        BEQ.W    ??process_next_command_21
        MOV      R1,R0
        UXTH     R1,R1
        SUBS     R1,R1,#+1
        SBCS     R1,R1,R1
        LSRS     R1,R1,#+31
        MOV      R0,R1
          CFI FunCall _Z17gcode_G0_G1_SCARAb
        BL       _Z17gcode_G0_G1_SCARAb
        B.N      ??process_next_command_22
// 11932 }
          CFI EndBlock cfiBlock70

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_38:
        DC8 "HAS_NO_TEMP_BED!\012"
        DC8 0, 0
// 11933 
// 11934 /**
// 11935  * Send a "Resend: nnn" message to the host to
// 11936  * indicate that a command needs to be re-sent.
// 11937  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock71 Using cfiCommon0
          CFI Function _Z24FlushSerialRequestResendv
          CFI TailCall _Z10ok_to_sendv
        THUMB
// 11938 void FlushSerialRequestResend() {
_Z24FlushSerialRequestResendv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
// 11939   //char command_queue[cmd_queue_index_r][100]="Resend:";
// 11940   MYSERIAL.flush();
        LDR.N    R4,??DataTable140_5
        MOV      R0,R4
          CFI FunCall _ZN12MarlinSerial5flushEv
        BL       _ZN12MarlinSerial5flushEv
// 11941   SERIAL_PROTOCOLPGM(MSG_RESEND);
        ADR.W    R0,?_39
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 11942   SERIAL_PROTOCOLLN(gcode_LastN + 1);
        LDR.N    R0,??DataTable140
        LDR      R1,[R0, #+32]
        ADDS     R1,R1,#+1
        LDR.N    R5,??DataTable140_2
        LDRB     R0,[R5, #+7]
        CMP      R0,#+0
        BNE.N    ??FlushSerialRequestResend_0
        MOVS     R2,#+10
        MOV      R0,R4
          CFI FunCall _ZN12MarlinSerial5printEli
        BL       _ZN12MarlinSerial5printEli
        B.N      ??FlushSerialRequestResend_1
??FlushSerialRequestResend_0:
        MOVS     R2,#+10
        LDR.N    R0,??DataTable140_6
          CFI FunCall _ZN12MarlinSerial5printEli
        BL       _ZN12MarlinSerial5printEli
??FlushSerialRequestResend_1:
        LDRB     R0,[R5, #+7]
        CMP      R0,#+0
        BNE.N    ??FlushSerialRequestResend_2
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??FlushSerialRequestResend_3
??FlushSerialRequestResend_2:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.N    R0,??DataTable140_6
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
// 11943   ok_to_send();
??FlushSerialRequestResend_3:
        POP      {R0,R4,R5,LR}
          CFI EndBlock cfiBlock71
        REQUIRE _Z10ok_to_sendv
        ;; // Fall through to label ok_to_send()
// 11944 }
// 11945 
// 11946 /**
// 11947  * Send an "ok" message to the host, indicating
// 11948  * that a command was successfully processed.
// 11949  *
// 11950  * If ADVANCED_OK is enabled also include:
// 11951  *   N<int>  Line number of the command, if any
// 11952  *   P<int>  Planner space remaining
// 11953  *   B<int>  Block queue space remaining
// 11954  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock72 Using cfiCommon0
          CFI Function _Z10ok_to_sendv
        THUMB
// 11955 void ok_to_send() {
_Z10ok_to_sendv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 11956   refresh_cmd_timeout();
          CFI FunCall _Z19refresh_cmd_timeoutv
        BL       _Z19refresh_cmd_timeoutv
// 11957   if (!send_ok[cmd_queue_index_r]) return;
        LDR.N    R0,??DataTable140
        LDRB     R1,[R0, #+9]
        ADD      R0,R0,R1
        LDRB     R0,[R0, #+20]
        CMP      R0,#+0
        BEQ.N    ??ok_to_send_0
// 11958   SERIAL_PROTOCOLPGM(MSG_OK);
        ADR.N    R0,??DataTable140_3  ;; 0x6F, 0x6B, 0x00, 0x00
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 11959   #if ENABLED(ADVANCED_OK)
// 11960     char* p = command_queue[cmd_queue_index_r];
// 11961     if (*p == 'N') {
// 11962       SERIAL_PROTOCOL(' ');
// 11963       SERIAL_ECHO(*p++);
// 11964       while (NUMERIC_SIGNED(*p))
// 11965         SERIAL_ECHO(*p++);
// 11966     }
// 11967     SERIAL_PROTOCOLPGM(" P"); SERIAL_PROTOCOL(int(BLOCK_BUFFER_SIZE - planner.movesplanned() - 1));
// 11968     SERIAL_PROTOCOLPGM(" B"); SERIAL_PROTOCOL(BUFSIZE - commands_in_queue);
// 11969   #endif
// 11970   SERIAL_EOL;
        LDR.N    R0,??DataTable140_2
        LDRB     R0,[R0, #+7]
        CMP      R0,#+0
        BNE.N    ??ok_to_send_1
        MOVS     R1,#+10
        LDR.N    R0,??DataTable140_5
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN12MarlinSerial5writeEh
        B.W      _ZN12MarlinSerial5writeEh
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??ok_to_send_1:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.N    R0,??DataTable140_6
        POP      {R3,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN12MarlinSerial5printEci
        B.W      _ZN12MarlinSerial5printEci
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 11971 }
??ok_to_send_0:
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock72

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_39:
        DC8 "Resend: "
        DC8 0, 0, 0
// 11972 
// 11973 #if HAS_SOFTWARE_ENDSTOPS
// 11974 
// 11975   /**
// 11976    * Constrain the given coordinates to the software endstops.
// 11977    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock73 Using cfiCommon0
          CFI Function _Z26clamp_to_software_endstopsPf
        THUMB
// 11978   void clamp_to_software_endstops(float target[XYZ]) {
_Z26clamp_to_software_endstopsPf:
        MOV      R2,R0
        LDR.W    R0,??DataTable147
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??clamp_to_software_endstops_0
        BX       LR
??clamp_to_software_endstops_0:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 11979     if (!soft_endstops_enabled) return;
// 11980     //#if ENABLED(MIN_SOFTWARE_ENDSTOPS)	/*--mks cfg--*/
// 11981     if(mksCfg.min_software_endstops){
        LDR.W    R3,??DataTable147_1
        LDR.N    R4,??DataTable140_2
        LDRB     R0,[R3, #+0]
        CMP      R0,#+0
        BEQ.N    ??clamp_to_software_endstops_1
// 11982       NOLESS(target[X_AXIS], soft_endstop_min[X_AXIS]);
        LDR      R1,[R4, #+80]
        LDR      R0,[R2, #+0]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??clamp_to_software_endstops_2
        STR      R1,[R2, #+0]
// 11983       NOLESS(target[Y_AXIS], soft_endstop_min[Y_AXIS]);
??clamp_to_software_endstops_2:
        LDR      R1,[R4, #+84]
        LDR      R0,[R2, #+4]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??clamp_to_software_endstops_3
        STR      R1,[R2, #+4]
// 11984       NOLESS(target[Z_AXIS], soft_endstop_min[Z_AXIS]);
??clamp_to_software_endstops_3:
        LDR      R1,[R4, #+88]
        LDR      R0,[R2, #+8]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??clamp_to_software_endstops_1
        STR      R1,[R2, #+8]
// 11985     }//#endif
// 11986     //#if ENABLED(MAX_SOFTWARE_ENDSTOPS)	/*--mks cfg--*/
// 11987     if(mksCfg.max_software_endstops){
??clamp_to_software_endstops_1:
        LDRB     R0,[R3, #+1]
        CMP      R0,#+0
        BEQ.N    ??clamp_to_software_endstops_4
// 11988       NOMORE(target[X_AXIS], soft_endstop_max[X_AXIS]);
        LDR      R0,[R4, #+92]
        LDR      R1,[R2, #+0]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??clamp_to_software_endstops_5
        STR      R0,[R2, #+0]
// 11989       NOMORE(target[Y_AXIS], soft_endstop_max[Y_AXIS]);
??clamp_to_software_endstops_5:
        LDR      R0,[R4, #+96]
        LDR      R1,[R2, #+4]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??clamp_to_software_endstops_6
        STR      R0,[R2, #+4]
// 11990       NOMORE(target[Z_AXIS], soft_endstop_max[Z_AXIS]);
??clamp_to_software_endstops_6:
        LDR      R0,[R4, #+100]
        LDR      R1,[R2, #+8]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??clamp_to_software_endstops_4
        STR      R0,[R2, #+8]
// 11991     }//#endif
// 11992   }
??clamp_to_software_endstops_4:
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock73

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable139:
        DC32     axis_homed

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable139_1:
        DC32     z_values

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable139_2:
        DC32     `filament_change_beep(bool)::runout_beep`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable139_3:
        DC32     mks_heating_busy+0x398
// 11993 
// 11994 #endif
// 11995 
// 11996 //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 11997 #if 1 /*--mks cfg-- AUTO_BED_LEVELING_BILINEAR */
// 11998   #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 11999     #define ABL_BG_SPACING(A) bilinear_grid_spacing_virt[A]
// 12000     #define ABL_BG_FACTOR(A)  bilinear_grid_factor_virt[A]
// 12001     #define ABL_BG_POINTS_X   ABL_GRID_POINTS_VIRT_X
// 12002     #define ABL_BG_POINTS_Y   ABL_GRID_POINTS_VIRT_Y
// 12003     #define ABL_BG_GRID(X,Y)  z_values_virt[X][Y]
// 12004   #else
// 12005     #define ABL_BG_SPACING(A) bilinear_grid_spacing[A]
// 12006     #define ABL_BG_FACTOR(A)  bilinear_grid_factor[A]
// 12007     #define ABL_BG_POINTS_X   GRID_MAX_POINTS_X
// 12008     #define ABL_BG_POINTS_Y   GRID_MAX_POINTS_Y
// 12009     #define ABL_BG_GRID(X,Y)  z_values[X][Y]
// 12010   #endif
// 12011 
// 12012   // Get the Z adjustment for non-linear bed leveling

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock74 Using cfiCommon0
          CFI Function _Z17bilinear_z_offsetPKf
        THUMB
// 12013   float bilinear_z_offset(const float logical[XYZ]) {
_Z17bilinear_z_offsetPKf:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        MOV      R5,R0
// 12014 
// 12015     static float z1, d2, z3, d4, L, D, ratio_x, ratio_y,
// 12016                  last_x = -999.999, last_y = -999.999;
// 12017 
// 12018     // Whole units for the grid line indices. Constrained within bounds.
// 12019     static int8_t gridx, gridy, nextx, nexty,
// 12020                   last_gridx = -99, last_gridy = -99;
// 12021 
// 12022     // XY relative to the probed area
// 12023     const float x = RAW_X_POSITION(logical[X_AXIS]) - bilinear_start[X_AXIS],
        LDR.W    R4,??DataTable147_2
        LDR.N    R6,??DataTable140_2
        LDR      R0,[R5, #+0]
        LDR      R1,[R6, #+68]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R7,R0
        LDR      R0,[R4, #+16]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R7,R0
// 12024                 y = RAW_Y_POSITION(logical[Y_AXIS]) - bilinear_start[Y_AXIS];
        LDR      R0,[R5, #+4]
        LDR      R1,[R6, #+72]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R5,R0
        LDR      R0,[R4, #+20]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R6,R0
// 12025 
// 12026     #if ENABLED(EXTRAPOLATE_BEYOND_GRID)
// 12027       // Keep using the last grid box
// 12028       #define FAR_EDGE_OR_BOX 2
// 12029     #else
// 12030       // Just use the grid far edge
// 12031       #define FAR_EDGE_OR_BOX 1
// 12032     #endif
// 12033 
// 12034     if (last_x != x) {
        LDR.W    R5,??DataTable147_3
        LDR      R0,[R4, #+68]
        MOV      R1,R7
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??bilinear_z_offset_0
// 12035       last_x = x;
        STR      R7,[R4, #+68]
// 12036       ratio_x = x * ABL_BG_FACTOR(X_AXIS);
        LDR      R0,[R4, #+24]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
        STR      R7,[R4, #+60]
// 12037       const float gx = constrain(floor(ratio_x), 0, ABL_BG_POINTS_X - FAR_EDGE_OR_BOX);
          CFI FunCall floorf
        BL       floorf
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??bilinear_z_offset_1
        MOV      R8,R1
        B.N      ??bilinear_z_offset_2
??bilinear_z_offset_1:
        LDRB     R0,[R5, #+0]
        SUBS     R0,R0,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R8,R0
        MOV      R0,R7
          CFI FunCall floorf
        BL       floorf
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??bilinear_z_offset_2
        MOV      R0,R7
          CFI FunCall floorf
        BL       floorf
        MOV      R8,R0
// 12038       ratio_x -= gx;      // Subtract whole to get the ratio within the grid box
??bilinear_z_offset_2:
        MOV      R0,R7
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+60]
// 12039 
// 12040       #if DISABLED(EXTRAPOLATE_BEYOND_GRID)
// 12041         // Beyond the grid maintain height at grid edges
// 12042         NOLESS(ratio_x, 0); // Never < 0.0. (> 1.0 is ok when nextx==gridx.)
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??bilinear_z_offset_3
        MOV      R0,R1
        STR      R0,[R4, #+60]
// 12043       #endif
// 12044 
// 12045       gridx = gx;
??bilinear_z_offset_3:
        MOV      R0,R8
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        STRB     R0,[R4, #+1]
// 12046       nextx = min(gridx + 1, ABL_BG_POINTS_X - 1);
        LDRB     R1,[R5, #+0]
        MOV      R2,R0
        SXTB     R2,R2
        ADDS     R2,R2,#+1
        MOV      R3,R1
        SUBS     R3,R3,#+1
        CMP      R2,R3
        BGE.N    ??bilinear_z_offset_4
        ADDS     R0,R0,#+1
        STRB     R0,[R4, #+3]
        B.N      ??bilinear_z_offset_0
??bilinear_z_offset_4:
        SUBS     R0,R1,#+1
        STRB     R0,[R4, #+3]
// 12047     }
// 12048 
// 12049     if (last_y != y || last_gridx != gridx) {
??bilinear_z_offset_0:
        LDR      R2,[R4, #+72]
        MOV      R0,R2
        MOV      R1,R6
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??bilinear_z_offset_5
        LDRSB    R0,[R4, #+5]
        LDRSB    R1,[R4, #+1]
        CMP      R0,R1
        BEQ.N    ??bilinear_z_offset_6
// 12050 
// 12051       if (last_y != y) {
??bilinear_z_offset_5:
        MOV      R0,R2
        MOV      R1,R6
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??bilinear_z_offset_7
// 12052         last_y = y;
        STR      R6,[R4, #+72]
// 12053         ratio_y = y * ABL_BG_FACTOR(Y_AXIS);
        LDR      R0,[R4, #+28]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
        STR      R6,[R4, #+64]
// 12054         const float gy = constrain(floor(ratio_y), 0, ABL_BG_POINTS_Y - FAR_EDGE_OR_BOX);
          CFI FunCall floorf
        BL       floorf
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??bilinear_z_offset_8
        MOV      R7,R1
        B.N      ??bilinear_z_offset_9
??bilinear_z_offset_8:
        LDRB     R0,[R5, #+1]
        SUBS     R0,R0,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R7,R0
        MOV      R0,R6
          CFI FunCall floorf
        BL       floorf
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??bilinear_z_offset_9
        MOV      R0,R6
          CFI FunCall floorf
        BL       floorf
        MOV      R7,R0
// 12055         ratio_y -= gy;
??bilinear_z_offset_9:
        MOV      R0,R6
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+64]
// 12056 
// 12057         #if DISABLED(EXTRAPOLATE_BEYOND_GRID)
// 12058           // Beyond the grid maintain height at grid edges
// 12059           NOLESS(ratio_y, 0); // Never < 0.0. (> 1.0 is ok when nexty==gridy.)
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??bilinear_z_offset_10
        MOV      R0,R1
        STR      R0,[R4, #+64]
// 12060         #endif
// 12061 
// 12062         gridy = gy;
??bilinear_z_offset_10:
        MOV      R0,R7
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        STRB     R0,[R4, #+2]
// 12063         nexty = min(gridy + 1, ABL_BG_POINTS_Y - 1);
        LDRB     R1,[R5, #+1]
        MOV      R2,R0
        SXTB     R2,R2
        ADDS     R2,R2,#+1
        MOV      R3,R1
        SUBS     R3,R3,#+1
        CMP      R2,R3
        BGE.N    ??bilinear_z_offset_11
        ADDS     R0,R0,#+1
        STRB     R0,[R4, #+4]
        B.N      ??bilinear_z_offset_7
??bilinear_z_offset_11:
        SUBS     R0,R1,#+1
        STRB     R0,[R4, #+4]
// 12064       }
// 12065 
// 12066       if (last_gridx != gridx || last_gridy != gridy) {
??bilinear_z_offset_7:
        LDRSB    R5,[R4, #+2]
        LDRSB    R0,[R4, #+1]
        LDRSB    R1,[R4, #+5]
        CMP      R1,R0
        BNE.N    ??bilinear_z_offset_12
        LDRSB    R1,[R4, #+6]
        CMP      R1,R5
        BEQ.N    ??bilinear_z_offset_13
// 12067         last_gridx = gridx;
??bilinear_z_offset_12:
        STRB     R0,[R4, #+5]
// 12068         last_gridy = gridy;
        STRB     R5,[R4, #+6]
// 12069         // Z at the box corners
// 12070         z1 = ABL_BG_GRID(gridx, gridy);       // left-front
        LDR.W    R6,??DataTable148
        ADD      R0,R6,R0, LSL #+6
        LDR      R1,[R0, R5, LSL #+2]
        STR      R1,[R4, #+36]
// 12071         d2 = ABL_BG_GRID(gridx, nexty) - z1;  // left-back (delta)
        LDRSB    R7,[R4, #+4]
        LDR      R0,[R0, R7, LSL #+2]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+40]
// 12072         z3 = ABL_BG_GRID(nextx, gridy);       // right-front
        LDRSB    R0,[R4, #+3]
        ADD      R0,R6,R0, LSL #+6
        LDR      R1,[R0, R5, LSL #+2]
        STR      R1,[R4, #+44]
// 12073         d4 = ABL_BG_GRID(nextx, nexty) - z3;  // right-back (delta)
        LDR      R0,[R0, R7, LSL #+2]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+48]
// 12074       }
// 12075 
// 12076       // Bilinear interpolate. Needed since y or gridx has changed.
// 12077                   L = z1 + d2 * ratio_y;   // Linear interp. LF -> LB
??bilinear_z_offset_13:
        LDR      R5,[R4, #+64]
        LDR      R0,[R4, #+40]
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR      R1,[R4, #+36]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R6,R0
        STR      R6,[R4, #+52]
// 12078       const float R = z3 + d4 * ratio_y;   // Linear interp. RF -> RB
// 12079 
// 12080       D = R - L;
        LDR      R0,[R4, #+48]
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR      R1,[R4, #+44]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R6
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+56]
// 12081     }
// 12082 
// 12083     const float offset = L + ratio_x * D;   // the offset almost always changes
// 12084 
// 12085     /*
// 12086     static float last_offset = 0;
// 12087     if (fabs(last_offset - offset) > 0.2) {
// 12088       SERIAL_ECHOPGM("Sudden Shift at ");
// 12089       SERIAL_ECHOPAIR("x=", x);
// 12090       SERIAL_ECHOPAIR(" / ", bilinear_grid_spacing[X_AXIS]);
// 12091       SERIAL_ECHOLNPAIR(" -> gridx=", gridx);
// 12092       SERIAL_ECHOPAIR(" y=", y);
// 12093       SERIAL_ECHOPAIR(" / ", bilinear_grid_spacing[Y_AXIS]);
// 12094       SERIAL_ECHOLNPAIR(" -> gridy=", gridy);
// 12095       SERIAL_ECHOPAIR(" ratio_x=", ratio_x);
// 12096       SERIAL_ECHOLNPAIR(" ratio_y=", ratio_y);
// 12097       SERIAL_ECHOPAIR(" z1=", z1);
// 12098       SERIAL_ECHOPAIR(" z2=", z2);
// 12099       SERIAL_ECHOPAIR(" z3=", z3);
// 12100       SERIAL_ECHOLNPAIR(" z4=", z4);
// 12101       SERIAL_ECHOPAIR(" L=", L);
// 12102       SERIAL_ECHOPAIR(" R=", R);
// 12103       SERIAL_ECHOLNPAIR(" offset=", offset);
// 12104     }
// 12105     last_offset = offset;
// 12106     //*/
// 12107 
// 12108     return offset;
??bilinear_z_offset_6:
        LDR      R1,[R4, #+60]
        LDR      R0,[R4, #+56]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR      R1,[R4, #+52]
        POP      {R4-R8,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall __aeabi_fadd
        B.W      __aeabi_fadd
// 12109   }
          CFI EndBlock cfiBlock74

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140:
        DC32     axis_relative_modes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_1:
        DC32     command_queue

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_2:
        DC32     mks_heating_busy

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_3:
        DC8      0x6F, 0x6B, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_4:
        DC32     echomagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_5:
        DC32     customizedSerial

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_6:
        DC32     serial2

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_7:
        DC32     mksReprint

        SECTION `.data`:DATA:REORDER:NOROOT(2)
        DATA
Running:
        DC8 1
        DC8 0
        DC8 0
        DC8 0
        DC8 0
        DC8 -99
        DC8 -99
        DC8 0
bilinear_grid_spacing:
        DC8 0, 0, 0, 0, 0, 0, 0, 0
bilinear_start:
        DC8 0, 0, 0, 0, 0, 0, 0, 0
bilinear_grid_factor:
        DC8 0, 0, 0, 0, 0, 0, 0, 0
        DC32 0
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC32 0C479FFF0H
        DC32 0C479FFF0H

        SECTION `.data`:DATA:REORDER:NOROOT(2)
        DATA
axis_homed:
        DC8 0, 0, 0, 0
delta_tower:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0
delta_diagonal_rod_2_tower:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
cartes:
        DC32 0H
        DC8 0, 0, 0, 0, 0, 0, 0, 0
delta_tower_angle_trim:
        DC8 0, 0, 0, 0, 0, 0, 0, 0
position_shift:
        DC32 0H
        DC8 0, 0, 0, 0, 0, 0, 0, 0
zprobe_zoffset:
        DC32 3F4CCCCDH
delta_radius:
        DC8 0, 0, 0, 0
delta_diagonal_rod:
        DC8 0, 0, 0, 0
delta_calibration_radius:
        DC8 0, 0, 0, 0
delta_segments_per_second:
        DC8 0, 0, 0, 0
        DC32 7FFFFFFFH
// 12110 
// 12111 #endif // AUTO_BED_LEVELING_BILINEAR
// 12112 
// 12113 //#if ENABLED(DELTA)	//mks-delta
// 12114 #if 1
// 12115   /**
// 12116    * Recalculate factors used for delta kinematics whenever
// 12117    * settings have been changed (e.g., by M665).
// 12118    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock75 Using cfiCommon0
          CFI Function _Z21recalc_delta_settingsff
        THUMB
// 12119   void recalc_delta_settings(float radius, float diagonal_rod) {
_Z21recalc_delta_settingsff:
        PUSH     {R2-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+40
        MOV      R7,R0
        MOV      R10,R1
// 12120     const float trt[ABC] = DELTA_RADIUS_TRIM_TOWER,
// 12121                 drt[ABC] = DELTA_DIAGONAL_ROD_TRIM_TOWER;
// 12122     delta_tower[A_AXIS][X_AXIS] = cos(RADIANS(210 + delta_tower_angle_trim[A_AXIS])) * (radius + trt[A_AXIS]); // front left tower
        LDR.W    R6,??DataTable148_1
        LDR.W    R8,??DataTable148_2  ;; 0x54442d18
        LDR.W    R9,??DataTable149  ;; 0x400921fb
        LDR      R1,[R6, #+52]
        LDR.W    R0,??DataTable149_1  ;; 0x43520000
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??DataTable149_2  ;; 0x40668000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R4,R0
        MOV      R5,R1
        MOVS     R0,#+0
        MOV      R1,R7
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R7,R0
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        STRD     R0,R1,[SP, #+0]
        MOV      R0,R4
        MOV      R1,R5
          CFI FunCall cos
        BL       cos
        LDRD     R2,R3,[SP, #+0]
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R6, #+4]
// 12123     delta_tower[A_AXIS][Y_AXIS] = sin(RADIANS(210 + delta_tower_angle_trim[A_AXIS])) * (radius + trt[A_AXIS]);
        MOV      R0,R7
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        STRD     R0,R1,[SP, #+0]
        MOV      R0,R4
        MOV      R1,R5
          CFI FunCall sin
        BL       sin
        LDRD     R2,R3,[SP, #+0]
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R6, #+8]
// 12124     delta_tower[B_AXIS][X_AXIS] = cos(RADIANS(330 + delta_tower_angle_trim[B_AXIS])) * (radius + trt[B_AXIS]); // front right tower
        LDR      R1,[R6, #+56]
        LDR.W    R0,??DataTable149_3  ;; 0x43a50000
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??DataTable149_2  ;; 0x40668000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R4,R0
        MOV      R5,R1
        MOV      R0,R7
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R8,R0
        MOV      R9,R1
        MOV      R0,R4
        MOV      R1,R5
          CFI FunCall cos
        BL       cos
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R6, #+12]
// 12125     delta_tower[B_AXIS][Y_AXIS] = sin(RADIANS(330 + delta_tower_angle_trim[B_AXIS])) * (radius + trt[B_AXIS]);
        MOV      R0,R7
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R8,R0
        MOV      R9,R1
        MOV      R0,R4
        MOV      R1,R5
          CFI FunCall sin
        BL       sin
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R6, #+16]
// 12126     delta_tower[C_AXIS][X_AXIS] = 0.0; // back middle tower
        MOVS     R0,#+0
        STR      R0,[R6, #+20]
// 12127     delta_tower[C_AXIS][Y_AXIS] = (radius + trt[C_AXIS]);
        STR      R7,[R6, #+24]
// 12128     delta_diagonal_rod_2_tower[A_AXIS] = sq(diagonal_rod + drt[A_AXIS]);
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R7,R0
        MOV      R8,R7
        MOVS     R4,#+2
        MOV      R5,#+1065353216
        MOV      R9,R5
        B.N      ??recalc_delta_settings_0
??recalc_delta_settings_1:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??recalc_delta_settings_0:
        LSLS     R0,R4,#+31
        BPL.N    ??recalc_delta_settings_2
        MOV      R0,R9
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??recalc_delta_settings_2:
        LSRS     R4,R4,#+1
        BNE.N    ??recalc_delta_settings_1
        STR      R9,[R6, #+28]
// 12129     delta_diagonal_rod_2_tower[B_AXIS] = sq(diagonal_rod + drt[B_AXIS]);
        MOV      R8,R7
        MOVS     R4,#+2
        MOV      R9,R5
        B.N      ??recalc_delta_settings_3
??recalc_delta_settings_4:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??recalc_delta_settings_3:
        LSLS     R0,R4,#+31
        BPL.N    ??recalc_delta_settings_5
        MOV      R0,R9
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??recalc_delta_settings_5:
        LSRS     R4,R4,#+1
        BNE.N    ??recalc_delta_settings_4
        STR      R9,[R6, #+32]
// 12130     delta_diagonal_rod_2_tower[C_AXIS] = sq(diagonal_rod + drt[C_AXIS]);
        MOVS     R4,#+2
        B.N      ??recalc_delta_settings_6
??recalc_delta_settings_7:
        MOV      R0,R7
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??recalc_delta_settings_6:
        LSLS     R0,R4,#+31
        BPL.N    ??recalc_delta_settings_8
        MOV      R0,R5
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
??recalc_delta_settings_8:
        LSRS     R4,R4,#+1
        BNE.N    ??recalc_delta_settings_7
        STR      R5,[R6, #+36]
// 12131   }
        POP      {R0,R1,R4-R10,PC}  ;; return
          CFI EndBlock cfiBlock75

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable141:
        DC32     mksCfg+0x34

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable141_1:
        DC32     ?_36
// 12132 
// 12133   #if ENABLED(DELTA_FAST_SQRT)
// 12134     /**
// 12135      * Fast inverse sqrt from Quake III Arena
// 12136      * See: https://en.wikipedia.org/wiki/Fast_inverse_square_root
// 12137      */
// 12138     float Q_rsqrt(float number) {
// 12139       long i;
// 12140       float x2, y;
// 12141       const float threehalfs = 1.5f;
// 12142       x2 = number * 0.5f;
// 12143       y  = number;
// 12144       i  = * ( long * ) &y;                       // evil floating point bit level hacking
// 12145       i  = 0x5F3759DF - ( i >> 1 );               // what the f***?
// 12146       y  = * ( float * ) &i;
// 12147       y  = y * ( threehalfs - ( x2 * y * y ) );   // 1st iteration
// 12148       // y  = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, this can be removed
// 12149       return y;
// 12150     }
// 12151 
// 12152     #define _SQRT(n) (1.0f / Q_rsqrt(n))
// 12153 
// 12154   #else
// 12155 
// 12156     #define _SQRT(n) sqrt(n)
// 12157 
// 12158   #endif
// 12159 
// 12160   /**
// 12161    * Delta Inverse Kinematics
// 12162    *
// 12163    * Calculate the tower positions for a given logical
// 12164    * position, storing the result in the delta[] array.
// 12165    *
// 12166    * This is an expensive calculation, requiring 3 square
// 12167    * roots per segmented linear move, and strains the limits
// 12168    * of a Mega2560 with a Graphical Display.
// 12169    *
// 12170    * Suggested optimizations include:
// 12171    *
// 12172    * - Disable the home_offset (M206) and/or position_shift (G92)
// 12173    *   features to remove up to 12 float additions.
// 12174    *
// 12175    * - Use a fast-inverse-sqrt function and add the reciprocal.
// 12176    *   (see above)
// 12177    */
// 12178 
// 12179   // Macro to obtain the Z position of an individual tower
// 12180   #define DELTA_Z(T) raw[Z_AXIS] + _SQRT(     \ 
// 12181     delta_diagonal_rod_2_tower[T] - HYPOT2(   \ 
// 12182         delta_tower[T][X_AXIS] - raw[X_AXIS], \ 
// 12183         delta_tower[T][Y_AXIS] - raw[Y_AXIS]  \ 
// 12184       )                                       \ 
// 12185     )
// 12186 
// 12187   #define DELTA_RAW_IK() do {        \ 
// 12188     delta[A_AXIS] = DELTA_Z(A_AXIS); \ 
// 12189     delta[B_AXIS] = DELTA_Z(B_AXIS); \ 
// 12190     delta[C_AXIS] = DELTA_Z(C_AXIS); \ 
// 12191   } while(0)
// 12192 
// 12193   #define DELTA_LOGICAL_IK() do {      \ 
// 12194     const float raw[XYZ] = {           \ 
// 12195       RAW_X_POSITION(logical[X_AXIS]), \ 
// 12196       RAW_Y_POSITION(logical[Y_AXIS]), \ 
// 12197       RAW_Z_POSITION(logical[Z_AXIS])  \ 
// 12198     };                                 \ 
// 12199     DELTA_RAW_IK();                    \ 
// 12200   } while(0)
// 12201 
// 12202   #define DELTA_DEBUG() do { \ 
// 12203       SERIAL_ECHOPAIR("cartesian X:", raw[X_AXIS]); \ 
// 12204       SERIAL_ECHOPAIR(" Y:", raw[Y_AXIS]);          \ 
// 12205       SERIAL_ECHOLNPAIR(" Z:", raw[Z_AXIS]);        \ 
// 12206       SERIAL_ECHOPAIR("delta A:", delta[A_AXIS]);   \ 
// 12207       SERIAL_ECHOPAIR(" B:", delta[B_AXIS]);        \ 
// 12208       SERIAL_ECHOLNPAIR(" C:", delta[C_AXIS]);      \ 
// 12209     } while(0)
// 12210 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock76 Using cfiCommon0
          CFI Function _Z18inverse_kinematicsPKf
        THUMB
// 12211   void inverse_kinematics(const float logical[XYZ]) {
_Z18inverse_kinematicsPKf:
        PUSH     {R1-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+48
        MOV      R4,R0
// 12212     DELTA_LOGICAL_IK();
        LDR.W    R5,??DataTable146
        LDR      R0,[R4, #+0]
        LDR      R1,[R5, #+68]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+4]
        LDR      R0,[R4, #+4]
        LDR      R1,[R5, #+72]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+0]
        LDR      R0,[R4, #+8]
        LDR      R1,[R5, #+76]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R6,R0
        LDR.W    R7,??DataTable148_1
        LDR      R0,[R7, #+4]
        LDR      R1,[SP, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R10,R0
        MOVS     R4,#+2
        MOV      R8,#+1065353216
        MOV      R9,R8
        B.N      ??inverse_kinematics_0
??inverse_kinematics_1:
        MOV      R0,R10
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??inverse_kinematics_0:
        LSLS     R0,R4,#+31
        BPL.N    ??inverse_kinematics_2
        MOV      R0,R9
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??inverse_kinematics_2:
        LSRS     R4,R4,#+1
        BNE.N    ??inverse_kinematics_1
        LDR      R0,[R7, #+8]
        LDR      R1,[SP, #+0]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R10,R0
        MOVS     R4,#+2
        MOV      R11,R8
        B.N      ??inverse_kinematics_3
??inverse_kinematics_4:
        MOV      R0,R10
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??inverse_kinematics_3:
        LSLS     R0,R4,#+31
        BPL.N    ??inverse_kinematics_5
        MOV      R0,R11
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??inverse_kinematics_5:
        LSRS     R4,R4,#+1
        BNE.N    ??inverse_kinematics_4
        MOV      R0,R9
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        LDR      R0,[R7, #+28]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R1,R6
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+104]
        LDR      R0,[R7, #+12]
        LDR      R1,[SP, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R10,R0
        MOVS     R4,#+2
        MOV      R9,R8
        B.N      ??inverse_kinematics_6
??inverse_kinematics_7:
        MOV      R0,R10
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??inverse_kinematics_6:
        LSLS     R0,R4,#+31
        BPL.N    ??inverse_kinematics_8
        MOV      R0,R9
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??inverse_kinematics_8:
        LSRS     R4,R4,#+1
        BNE.N    ??inverse_kinematics_7
        LDR      R0,[R7, #+16]
        LDR      R1,[SP, #+0]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R10,R0
        MOVS     R4,#+2
        MOV      R11,R8
        B.N      ??inverse_kinematics_9
??inverse_kinematics_10:
        MOV      R0,R10
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??inverse_kinematics_9:
        LSLS     R0,R4,#+31
        BPL.N    ??inverse_kinematics_11
        MOV      R0,R11
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??inverse_kinematics_11:
        LSRS     R4,R4,#+1
        BNE.N    ??inverse_kinematics_10
        MOV      R0,R9
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        LDR      R0,[R7, #+32]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R1,R6
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+108]
        LDR      R0,[R7, #+20]
        LDR      R1,[SP, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R10,R0
        MOVS     R4,#+2
        MOV      R9,R8
        B.N      ??inverse_kinematics_12
??inverse_kinematics_13:
        MOV      R0,R10
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??inverse_kinematics_12:
        LSLS     R0,R4,#+31
        BPL.N    ??inverse_kinematics_14
        MOV      R0,R9
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??inverse_kinematics_14:
        LSRS     R4,R4,#+1
        BNE.N    ??inverse_kinematics_13
        LDR      R0,[R7, #+24]
        LDR      R1,[SP, #+0]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R10,R0
        MOVS     R4,#+2
        B.N      ??inverse_kinematics_15
??inverse_kinematics_16:
        MOV      R0,R10
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??inverse_kinematics_15:
        LSLS     R0,R4,#+31
        BPL.N    ??inverse_kinematics_17
        MOV      R0,R8
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??inverse_kinematics_17:
        LSRS     R4,R4,#+1
        BNE.N    ??inverse_kinematics_16
        MOV      R0,R9
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        LDR      R0,[R7, #+36]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R1,R6
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+112]
// 12213     // DELTA_DEBUG();
// 12214   }
        POP      {R0-R2,R4-R11,PC}  ;; return
          CFI EndBlock cfiBlock76
// 12215 
// 12216   /**
// 12217    * Calculate the highest Z position where the
// 12218    * effector has the full range of XY motion.
// 12219    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock77 Using cfiCommon0
          CFI Function _Z28delta_safe_distance_from_topv
        THUMB
// 12220   float delta_safe_distance_from_top() {
_Z28delta_safe_distance_from_topv:
        PUSH     {R1-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+32
// 12221     float cartesian[XYZ] = {
// 12222       LOGICAL_X_POSITION(0),
// 12223       LOGICAL_Y_POSITION(0),
// 12224       LOGICAL_Z_POSITION(0)
// 12225     };
        LDR.W    R4,??DataTable146
        LDR      R0,[R4, #+68]
        STR      R0,[SP, #+0]
        MOV      R5,SP
        LDR      R0,[R4, #+72]
        STR      R0,[R5, #+4]
        LDR      R0,[R4, #+76]
        STR      R0,[SP, #+8]
// 12226 	if(MACHINETPYE == MORGAN_SCARA)
        LDR.W    R6,??DataTable145
        LDRSH    R0,[R6, #+88]
        CMP      R0,#+256
        MOV      R0,SP
        BNE.N    ??delta_safe_distance_from_top_0
// 12227 		inverse_kinematics_MORGAN_SCARA(cartesian);
          CFI FunCall _Z31inverse_kinematics_MORGAN_SCARAPKf
        BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
        B.N      ??delta_safe_distance_from_top_1
// 12228 	else
// 12229 	    inverse_kinematics(cartesian);
??delta_safe_distance_from_top_0:
          CFI FunCall _Z18inverse_kinematicsPKf
        BL       _Z18inverse_kinematicsPKf
// 12230 	
// 12231     float distance = delta[A_AXIS];
??delta_safe_distance_from_top_1:
        LDR      R7,[R4, #+104]
// 12232     cartesian[Y_AXIS] = LOGICAL_Y_POSITION(DELTA_PRINTABLE_RADIUS);
        LDR      R1,[R6, #+84]
        LDR      R0,[R4, #+72]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+4]
// 12233 	
// 12234 	if(MACHINETPYE == MORGAN_SCARA)
        LDRSH    R0,[R6, #+88]
        CMP      R0,#+256
        MOV      R0,SP
        BNE.N    ??delta_safe_distance_from_top_2
// 12235 		inverse_kinematics_MORGAN_SCARA(cartesian);
          CFI FunCall _Z31inverse_kinematics_MORGAN_SCARAPKf
        BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
        B.N      ??delta_safe_distance_from_top_3
// 12236 	else
// 12237 	    inverse_kinematics(cartesian);
??delta_safe_distance_from_top_2:
          CFI FunCall _Z18inverse_kinematicsPKf
        BL       _Z18inverse_kinematicsPKf
// 12238 	
// 12239     return abs(distance - delta[A_AXIS]);
??delta_safe_distance_from_top_3:
        MOV      R0,R7
        LDR      R1,[R4, #+104]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        BIC      R0,R0,#0x80000000
        POP      {R1-R7,PC}       ;; return
// 12240   }
          CFI EndBlock cfiBlock77
// 12241 
// 12242   /**
// 12243    * Delta Forward Kinematics
// 12244    *
// 12245    * See the Wikipedia article "Trilateration"
// 12246    * https://en.wikipedia.org/wiki/Trilateration
// 12247    *
// 12248    * Establish a new coordinate system in the plane of the
// 12249    * three carriage points. This system has its origin at
// 12250    * tower1, with tower2 on the X axis. Tower3 is in the X-Y
// 12251    * plane with a Z component of zero.
// 12252    * We will define unit vectors in this coordinate system
// 12253    * in our original coordinate system. Then when we calculate
// 12254    * the Xnew, Ynew and Znew values, we can translate back into
// 12255    * the original system by moving along those unit vectors
// 12256    * by the corresponding values.
// 12257    *
// 12258    * Variable names matched to Marlin, c-version, and avoid the
// 12259    * use of any vector library.
// 12260    *
// 12261    * by Andreas Hardtung 2016-06-07
// 12262    * based on a Java function from "Delta Robot Kinematics V3"
// 12263    * by Steve Graves
// 12264    *
// 12265    * The result is stored in the cartes[] array.
// 12266    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock78 Using cfiCommon0
          CFI Function _Z24forward_kinematics_DELTAfff
        THUMB
// 12267   void forward_kinematics_DELTA(float z1, float z2, float z3) {
_Z24forward_kinematics_DELTAfff:
        PUSH     {R0,R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        SUB      SP,SP,#+40
          CFI CFA R13+80
        MOV      R4,R1
        MOV      R7,R2
// 12268     // Create a vector in old coordinates along x axis of new coordinate
// 12269     float p12[3] = { delta_tower[B_AXIS][X_AXIS] - delta_tower[A_AXIS][X_AXIS], delta_tower[B_AXIS][Y_AXIS] - delta_tower[A_AXIS][Y_AXIS], z2 - z1 };
        LDR.W    R5,??DataTable148_1
        LDR      R0,[R5, #+12]
        LDR      R1,[R5, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+4]
        LDR      R0,[R5, #+16]
        LDR      R1,[R5, #+8]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R8,R0
        MOV      R0,R4
        LDR      R1,[SP, #+40]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
// 12270 
// 12271     // Get the Magnitude of vector.
// 12272     float d = sqrt( sq(p12[0]) + sq(p12[1]) + sq(p12[2]) );
        LDR      R6,[SP, #+4]
        MOVS     R5,#+2
        MOV      R4,#+1065353216
        B.N      ??forward_kinematics_DELTA_0
??forward_kinematics_DELTA_1:
        MOV      R0,R6
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
??forward_kinematics_DELTA_0:
        LSLS     R0,R5,#+31
        BPL.N    ??forward_kinematics_DELTA_2
        MOV      R0,R4
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
??forward_kinematics_DELTA_2:
        LSRS     R5,R5,#+1
        BNE.N    ??forward_kinematics_DELTA_1
        MOV      R10,R8
        MOVS     R6,#+2
        MOV      R5,#+1065353216
        B.N      ??forward_kinematics_DELTA_3
??forward_kinematics_DELTA_4:
        MOV      R0,R10
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??forward_kinematics_DELTA_3:
        LSLS     R0,R6,#+31
        BPL.N    ??forward_kinematics_DELTA_5
        MOV      R0,R5
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
??forward_kinematics_DELTA_5:
        LSRS     R6,R6,#+1
        BNE.N    ??forward_kinematics_DELTA_4
        MOV      R10,R9
        MOVS     R6,#+2
        MOV      R11,#+1065353216
        B.N      ??forward_kinematics_DELTA_6
??forward_kinematics_DELTA_7:
        MOV      R0,R10
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??forward_kinematics_DELTA_6:
        LSLS     R0,R6,#+31
        BPL.N    ??forward_kinematics_DELTA_8
        MOV      R0,R11
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??forward_kinematics_DELTA_8:
        LSRS     R6,R6,#+1
        BNE.N    ??forward_kinematics_DELTA_7
        MOV      R6,R7
        MOV      R0,R4
        MOV      R1,R5
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall sqrtf
        BL       sqrtf
        STR      R0,[SP, #+0]
// 12273 
// 12274     // Create unit vector by dividing by magnitude.
// 12275     float ex[3] = { p12[0] / d, p12[1] / d, p12[2] / d };
        LDR      R0,[SP, #+4]
        LDR      R1,[SP, #+0]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[SP, #+16]
        MOV      R0,R8
        LDR      R1,[SP, #+0]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[SP, #+12]
        MOV      R0,R9
        LDR      R1,[SP, #+0]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[SP, #+8]
// 12276 
// 12277     // Get the vector from the origin of the new system to the third point.
// 12278     float p13[3] = { delta_tower[C_AXIS][X_AXIS] - delta_tower[A_AXIS][X_AXIS], delta_tower[C_AXIS][Y_AXIS] - delta_tower[A_AXIS][Y_AXIS], z3 - z1 };
        LDR.W    R7,??DataTable148_1
        LDR      R0,[R7, #+20]
        LDR      R1,[R7, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R8,R0
        LDR      R0,[R7, #+24]
        LDR      R1,[R7, #+8]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R4,R0
        MOV      R0,R6
        LDR      R1,[SP, #+40]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R6,R0
// 12279 
// 12280     // Use the dot product to find the component of this vector on the X axis.
// 12281     float i = ex[0] * p13[0] + ex[1] * p13[1] + ex[2] * p13[2];
        LDR      R0,[SP, #+16]
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
        LDR      R0,[SP, #+12]
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R5
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R5,R0
        LDR      R0,[SP, #+8]
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R5
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R5,R0
// 12282 
// 12283     // Create a vector along the x axis that represents the x component of p13.
// 12284     float iex[3] = { ex[0] * i, ex[1] * i, ex[2] * i };
// 12285 
// 12286     // Subtract the X component from the original vector leaving only Y. We use the
// 12287     // variable that will be the unit vector after we scale it.
// 12288     float ey[3] = { p13[0] - iex[0], p13[1] - iex[1], p13[2] - iex[2] };
        LDR      R0,[SP, #+16]
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R8,R0
        LDR      R0,[SP, #+12]
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+28]
        LDR      R0,[SP, #+8]
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R6
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+24]
// 12289 
// 12290     // The magnitude of Y component
// 12291     float j = sqrt( sq(ey[0]) + sq(ey[1]) + sq(ey[2]) );
        MOV      R9,R8
        MOVS     R6,#+2
        MOV      R4,#+1065353216
        B.N      ??forward_kinematics_DELTA_9
??forward_kinematics_DELTA_10:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??forward_kinematics_DELTA_9:
        LSLS     R0,R6,#+31
        BPL.N    ??forward_kinematics_DELTA_11
        MOV      R0,R4
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
??forward_kinematics_DELTA_11:
        LSRS     R6,R6,#+1
        BNE.N    ??forward_kinematics_DELTA_10
        LDR      R10,[SP, #+28]
        MOVS     R6,#+2
        MOV      R9,#+1065353216
        B.N      ??forward_kinematics_DELTA_12
??forward_kinematics_DELTA_13:
        MOV      R0,R10
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??forward_kinematics_DELTA_12:
        LSLS     R0,R6,#+31
        BPL.N    ??forward_kinematics_DELTA_14
        MOV      R0,R9
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??forward_kinematics_DELTA_14:
        LSRS     R6,R6,#+1
        BNE.N    ??forward_kinematics_DELTA_13
        LDR      R10,[SP, #+24]
        MOVS     R6,#+2
        MOV      R11,#+1065353216
        B.N      ??forward_kinematics_DELTA_15
??forward_kinematics_DELTA_16:
        MOV      R0,R10
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??forward_kinematics_DELTA_15:
        LSLS     R0,R6,#+31
        BPL.N    ??forward_kinematics_DELTA_17
        MOV      R0,R11
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??forward_kinematics_DELTA_17:
        LSRS     R6,R6,#+1
        BNE.N    ??forward_kinematics_DELTA_16
        MOV      R0,R4
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall sqrtf
        BL       sqrtf
        STR      R0,[SP, #+4]
// 12292 
// 12293     // Convert to a unit vector
// 12294     ey[0] /= j; ey[1] /= j;  ey[2] /= j;
        MOV      R0,R8
        LDR      R1,[SP, #+4]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[SP, #+20]
        LDR      R0,[SP, #+28]
        LDR      R1,[SP, #+4]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R8,R0
        LDR      R0,[SP, #+24]
        LDR      R1,[SP, #+4]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R9,R0
// 12295 
// 12296     // The cross product of the unit x and y is the unit z
// 12297     // float[] ez = vectorCrossProd(ex, ey);
// 12298     float ez[3] = {
// 12299       ex[1] * ey[2] - ex[2] * ey[1],
// 12300       ex[2] * ey[0] - ex[0] * ey[2],
// 12301       ex[0] * ey[1] - ex[1] * ey[0]
// 12302     };
        LDR      R0,[SP, #+12]
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
        LDR      R0,[SP, #+8]
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+32]
        LDR      R1,[SP, #+8]
        LDR      R0,[SP, #+20]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
        LDR      R0,[SP, #+16]
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+28]
        LDR      R0,[SP, #+16]
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
        LDR      R1,[SP, #+12]
        LDR      R0,[SP, #+20]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+24]
// 12303 
// 12304     // We now have the d, i and j values defined in Wikipedia.
// 12305     // Plug them into the equations defined in Wikipedia for Xnew, Ynew and Znew
// 12306     float Xnew = (delta_diagonal_rod_2_tower[A_AXIS] - delta_diagonal_rod_2_tower[B_AXIS] + sq(d)) / (d * 2),
        LDR      R6,[SP, #+0]
        MOVS     R4,#+2
        MOV      R10,#+1065353216
        B.N      ??forward_kinematics_DELTA_18
??forward_kinematics_DELTA_19:
        MOV      R0,R6
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
??forward_kinematics_DELTA_18:
        LSLS     R0,R4,#+31
        BPL.N    ??forward_kinematics_DELTA_20
        MOV      R0,R10
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??forward_kinematics_DELTA_20:
        LSRS     R4,R4,#+1
        BNE.N    ??forward_kinematics_DELTA_19
        LDR      R0,[R7, #+28]
        LDR      R1,[R7, #+32]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R4,R0
        LDR      R1,[SP, #+0]
        MOV      R0,#+1073741824
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[SP, #+0]
// 12307           Ynew = ((delta_diagonal_rod_2_tower[A_AXIS] - delta_diagonal_rod_2_tower[C_AXIS] + HYPOT2(i, j)) / 2 - i * Xnew) / j,
        MOV      R10,R5
        MOVS     R4,#+2
        MOV      R6,#+1065353216
        B.N      ??forward_kinematics_DELTA_21
??forward_kinematics_DELTA_22:
        MOV      R0,R10
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??forward_kinematics_DELTA_21:
        LSLS     R0,R4,#+31
        BPL.N    ??forward_kinematics_DELTA_23
        MOV      R0,R6
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
??forward_kinematics_DELTA_23:
        LSRS     R4,R4,#+1
        BNE.N    ??forward_kinematics_DELTA_22
        LDR      R10,[SP, #+4]
        MOVS     R4,#+2
        MOV      R11,#+1065353216
        B.N      ??forward_kinematics_DELTA_24
??forward_kinematics_DELTA_25:
        MOV      R0,R10
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??forward_kinematics_DELTA_24:
        LSLS     R0,R4,#+31
        BPL.N    ??forward_kinematics_DELTA_26
        MOV      R0,R11
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??forward_kinematics_DELTA_26:
        LSRS     R4,R4,#+1
        BNE.N    ??forward_kinematics_DELTA_25
        LDR      R0,[R7, #+28]
        LDR      R1,[R7, #+36]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R4,R0
        MOV      R0,R6
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R4
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,#+1056964608
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
        LDR      R0,[SP, #+0]
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[SP, #+4]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R10,R0
// 12308           Znew = sqrt(delta_diagonal_rod_2_tower[A_AXIS] - HYPOT2(Xnew, Ynew));
        LDR      R6,[SP, #+0]
        MOVS     R4,#+2
        MOV      R11,#+1065353216
        MOV      R5,R11
        B.N      ??forward_kinematics_DELTA_27
??forward_kinematics_DELTA_28:
        MOV      R0,R6
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
??forward_kinematics_DELTA_27:
        LSLS     R0,R4,#+31
        BPL.N    ??forward_kinematics_DELTA_29
        MOV      R0,R5
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
??forward_kinematics_DELTA_29:
        LSRS     R4,R4,#+1
        BNE.N    ??forward_kinematics_DELTA_28
        MOV      R6,R10
        MOVS     R4,#+2
        B.N      ??forward_kinematics_DELTA_30
??forward_kinematics_DELTA_31:
        MOV      R0,R6
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
??forward_kinematics_DELTA_30:
        LSLS     R0,R4,#+31
        BPL.N    ??forward_kinematics_DELTA_32
        MOV      R0,R11
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??forward_kinematics_DELTA_32:
        LSRS     R4,R4,#+1
        BNE.N    ??forward_kinematics_DELTA_31
        MOV      R0,R5
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        LDR      R0,[R7, #+28]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R4,R0
// 12309 
// 12310     // Start from the origin of the old coordinates and add vectors in the
// 12311     // old coords that represent the Xnew, Ynew and Znew to find the point
// 12312     // in the old system.
// 12313     cartes[X_AXIS] = delta_tower[A_AXIS][X_AXIS] + ex[0] * Xnew + ey[0] * Ynew - ez[0] * Znew;
        LDR      R1,[SP, #+16]
        LDR      R0,[SP, #+0]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR      R1,[R7, #+4]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R5,R0
        LDR      R0,[SP, #+20]
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R5
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R5,R0
        LDR      R0,[SP, #+32]
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R7, #+40]
// 12314     cartes[Y_AXIS] = delta_tower[A_AXIS][Y_AXIS] + ex[1] * Xnew + ey[1] * Ynew - ez[1] * Znew;
        LDR      R1,[SP, #+12]
        LDR      R0,[SP, #+0]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR      R1,[R7, #+8]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R5,R0
        MOV      R0,R8
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R5
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R5,R0
        LDR      R0,[SP, #+28]
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R7, #+44]
// 12315     cartes[Z_AXIS] =             z1 + ex[2] * Xnew + ey[2] * Ynew - ez[2] * Znew;
        LDR      R1,[SP, #+8]
        LDR      R0,[SP, #+0]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR      R1,[SP, #+40]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R5,R0
        MOV      R0,R9
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R5
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R5,R0
        LDR      R0,[SP, #+24]
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R7, #+48]
// 12316   }
        ADD      SP,SP,#+44
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
          CFI EndBlock cfiBlock78
// 12317 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock79 Using cfiCommon0
          CFI Function _Z24forward_kinematics_DELTAPf
        THUMB
// 12318   void forward_kinematics_DELTA(float point[ABC]) {
// 12319     forward_kinematics_DELTA(point[A_AXIS], point[B_AXIS], point[C_AXIS]);
_Z24forward_kinematics_DELTAPf:
        LDR      R2,[R0, #+8]
        LDR      R1,[R0, #+4]
        LDR      R0,[R0, #+0]
          CFI FunCall _Z24forward_kinematics_DELTAfff
        B.N      _Z24forward_kinematics_DELTAfff
// 12320   }
          CFI EndBlock cfiBlock79
// 12321 
// 12322 #endif // DELTA
// 12323 
// 12324 /**
// 12325  * Get the stepper positions in the cartes[] array.
// 12326  * Forward kinematics are applied for DELTA and SCARA.
// 12327  *
// 12328  * The result is in the current coordinate space with
// 12329  * leveling applied. The coordinates need to be run through
// 12330  * unapply_leveling to obtain the "ideal" coordinates
// 12331  * suitable for current_position, etc.
// 12332  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock80 Using cfiCommon0
          CFI Function _Z27get_cartesian_from_steppersv
        THUMB
// 12333 void get_cartesian_from_steppers() {
_Z27get_cartesian_from_steppersv:
        PUSH     {R2-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+24
// 12334  // #if ENABLED(DELTA)
// 12335   if(MACHINETPYE == DELTA)  {
        LDR.N    R0,??DataTable145
        LDRSH    R0,[R0, #+88]
        LDR.W    R4,??DataTable148_1
        CMP      R0,#+2
        BNE.N    ??get_cartesian_from_steppers_0
// 12336     forward_kinematics_DELTA(
// 12337       stepper.get_axis_position_mm(A_AXIS),
// 12338       stepper.get_axis_position_mm(B_AXIS),
// 12339       stepper.get_axis_position_mm(C_AXIS)
// 12340     );
        MOVS     R0,#+2
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
        MOV      R5,R0
        MOVS     R0,#+1
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
        MOV      R6,R0
        MOVS     R0,#+0
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
        MOV      R2,R5
        MOV      R1,R6
          CFI FunCall _Z24forward_kinematics_DELTAfff
        BL       _Z24forward_kinematics_DELTAfff
// 12341     cartes[X_AXIS] += LOGICAL_X_POSITION(0);
        LDR.W    R5,??DataTable157
        LDR      R1,[R4, #+40]
        LDR      R0,[R5, #+68]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+40]
// 12342     cartes[Y_AXIS] += LOGICAL_Y_POSITION(0);
        LDR      R1,[R4, #+44]
        LDR      R0,[R5, #+72]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+44]
// 12343     cartes[Z_AXIS] += LOGICAL_Z_POSITION(0); }
        LDR      R1,[R4, #+48]
        LDR      R0,[R5, #+76]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+48]
        POP      {R0,R1,R4-R6,PC}
// 12344 //  #elif IS_SCARA
// 12345   else if(MACHINETPYE&IS_SCARA) {
??get_cartesian_from_steppers_0:
        TST      R0,#0x300
        BEQ.N    ??get_cartesian_from_steppers_1
// 12346     forward_kinematics_SCARA(
// 12347       stepper.get_axis_position_degrees(A_AXIS),
// 12348       stepper.get_axis_position_degrees(B_AXIS)
// 12349     );
        MOVS     R0,#+0
          CFI FunCall _ZN7Stepper25get_axis_position_degreesE8AxisEnum
        BL       _ZN7Stepper25get_axis_position_degreesE8AxisEnum
        STR      R0,[SP, #+0]
        MOVS     R0,#+1
          CFI FunCall _ZN7Stepper25get_axis_position_degreesE8AxisEnum
        BL       _ZN7Stepper25get_axis_position_degreesE8AxisEnum
        STR      R0,[SP, #+4]
        ADD      R1,SP,#+4
        MOV      R0,SP
          CFI FunCall _Z24forward_kinematics_SCARARKfS0_
        BL       _Z24forward_kinematics_SCARARKfS0_
// 12350     cartes[X_AXIS] += LOGICAL_X_POSITION(0);
        LDR.W    R5,??DataTable157
        LDR      R1,[R4, #+40]
        LDR      R0,[R5, #+68]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+40]
// 12351     cartes[Y_AXIS] += LOGICAL_Y_POSITION(0);
        LDR      R1,[R4, #+44]
        LDR      R0,[R5, #+72]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+44]
// 12352     cartes[Z_AXIS] = stepper.get_axis_position_mm(Z_AXIS);  }
        MOVS     R0,#+2
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
        STR      R0,[R4, #+48]
        POP      {R0,R1,R4-R6,PC}
// 12353   //#else
// 12354   else {
// 12355     cartes[X_AXIS] = stepper.get_axis_position_mm(X_AXIS);
??get_cartesian_from_steppers_1:
        MOVS     R0,#+0
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
        STR      R0,[R4, #+40]
// 12356     cartes[Y_AXIS] = stepper.get_axis_position_mm(Y_AXIS);
        MOVS     R0,#+1
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
        STR      R0,[R4, #+44]
// 12357     cartes[Z_AXIS] = stepper.get_axis_position_mm(Z_AXIS);  }
        MOVS     R0,#+2
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
        STR      R0,[R4, #+48]
// 12358  // #endif
// 12359 }
        POP      {R0,R1,R4-R6,PC}  ;; return
          CFI EndBlock cfiBlock80

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable145:
        DC32     mksCfg
// 12360 
// 12361 /**
// 12362  * Set the current_position for an axis based on
// 12363  * the stepper positions, removing any leveling that
// 12364  * may have been applied.
// 12365  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock81 Using cfiCommon0
          CFI Function _Z34set_current_from_steppers_for_axis8AxisEnum
        THUMB
// 12366 void set_current_from_steppers_for_axis(const AxisEnum axis) {
_Z34set_current_from_steppers_for_axis8AxisEnum:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
// 12367   get_cartesian_from_steppers();
          CFI FunCall _Z27get_cartesian_from_steppersv
        BL       _Z27get_cartesian_from_steppersv
// 12368   //#if PLANNER_LEVELING
// 12369   if(BED_LEVELING_METHOD&PLANNER_LEVELING)
        LDR.W    R5,??DataTable148_1
        LDR.W    R0,??DataTable153
        LDRB     R0,[R0, #+64]
        TST      R0,#0x2E
        BEQ.N    ??set_current_from_steppers_for_axis_0
// 12370     planner.unapply_leveling(cartes);
        ADD      R0,R5,#+40
          CFI FunCall _ZN7Planner16unapply_levelingEPf
        BL       _ZN7Planner16unapply_levelingEPf
// 12371   //#endif
// 12372   if (axis == ALL_AXES)
??set_current_from_steppers_for_axis_0:
        LDR.W    R0,??DataTable157
        MOV      R1,R4
        CMP      R1,#+100
        BNE.N    ??set_current_from_steppers_for_axis_1
// 12373     COPY(current_position, cartes);
        MOVS     R2,#+12
        ADD      R1,R5,#+40
        ADDS     R0,R0,#+8
        POP      {R3-R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall __aeabi_memcpy
        B.W      __aeabi_memcpy
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
// 12374   else
// 12375     current_position[axis] = cartes[axis];
??set_current_from_steppers_for_axis_1:
        ADD      R1,R5,#+40
        LDR      R1,[R1, R4, LSL #+2]
        ADDS     R0,R0,#+8
        STR      R1,[R0, R4, LSL #+2]
// 12376 }
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock81

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable146:
        DC32     mks_heating_busy
// 12377 
// 12378 //#if ENABLED(MESH_BED_LEVELING)
// 12379 #if 1	/*--mks cfg-- MESH_BED_LEVELING */
// 12380   /**
// 12381    * Prepare a mesh-leveled linear move in a Cartesian setup,
// 12382    * splitting the move where it crosses mesh borders.
// 12383    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock82 Using cfiCommon0
          CFI Function _Z24mesh_line_to_destinationfhh
        THUMB
// 12384   void mesh_line_to_destination(float fr_mm_s, uint8_t x_splits = 0xFF, uint8_t y_splits = 0xFF) {
_Z24mesh_line_to_destinationfhh:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        SUB      SP,SP,#+20
          CFI CFA R13+56
        MOV      R10,R0
        MOV      R5,R1
        MOV      R6,R2
// 12385     int cx1 = mbl.cell_index_x(RAW_CURRENT_POSITION(X)),
        LDR.W    R4,??DataTable157
        LDR      R0,[R4, #+8]
        LDR      R1,[R4, #+68]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+0]
        MOV      R0,SP
          CFI FunCall _ZN17mesh_bed_leveling12cell_index_xERKf
        BL       _ZN17mesh_bed_leveling12cell_index_xERKf
        MOV      R7,R0
// 12386         cy1 = mbl.cell_index_y(RAW_CURRENT_POSITION(Y)),
        LDR      R0,[R4, #+12]
        LDR      R1,[R4, #+72]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+0]
        MOV      R0,SP
          CFI FunCall _ZN17mesh_bed_leveling12cell_index_yERKf
        BL       _ZN17mesh_bed_leveling12cell_index_yERKf
        MOV      R8,R0
// 12387         cx2 = mbl.cell_index_x(RAW_X_POSITION(destination[X_AXIS])),
        LDR      R0,[R4, #+24]
        LDR      R1,[R4, #+68]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+0]
        MOV      R0,SP
          CFI FunCall _ZN17mesh_bed_leveling12cell_index_xERKf
        BL       _ZN17mesh_bed_leveling12cell_index_xERKf
        MOV      R9,R0
// 12388         cy2 = mbl.cell_index_y(RAW_Y_POSITION(destination[Y_AXIS]));
        LDR      R0,[R4, #+28]
        LDR      R1,[R4, #+72]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+0]
        MOV      R0,SP
          CFI FunCall _ZN17mesh_bed_leveling12cell_index_yERKf
        BL       _ZN17mesh_bed_leveling12cell_index_yERKf
        MOV      R1,R0
// 12389     NOMORE(cx1, GRID_MAX_POINTS_X - 2);
        LDR.N    R0,??DataTable147_3
        LDRB     R2,[R0, #+0]
        SUBS     R2,R2,#+2
        CMP      R2,R7
        BGE.N    ??mesh_line_to_destination_0
        MOV      R7,R2
// 12390     NOMORE(cy1, GRID_MAX_POINTS_Y - 2);
??mesh_line_to_destination_0:
        LDRB     R0,[R0, #+1]
        SUBS     R0,R0,#+2
        CMP      R0,R8
        BGE.N    ??mesh_line_to_destination_1
        MOV      R8,R0
// 12391     NOMORE(cx2, GRID_MAX_POINTS_X - 2);
??mesh_line_to_destination_1:
        CMP      R2,R9
        BGE.N    ??mesh_line_to_destination_2
        MOV      R9,R2
// 12392     NOMORE(cy2, GRID_MAX_POINTS_Y - 2);
??mesh_line_to_destination_2:
        CMP      R0,R1
        BGE.N    ??mesh_line_to_destination_3
        MOV      R1,R0
??mesh_line_to_destination_3:
        STR      R10,[SP, #+0]
// 12393 
// 12394     if (cx1 == cx2 && cy1 == cy2) {
        CMP      R7,R9
        BNE.N    ??mesh_line_to_destination_4
        CMP      R8,R1
        BEQ.W    ??mesh_line_to_destination_5
// 12395       // Start and end on same mesh square
// 12396       line_to_destination(fr_mm_s);
// 12397       set_current_to_destination();
// 12398       return;
// 12399     }
// 12400 
// 12401     #define MBL_SEGMENT_END(A) (current_position[A ##_AXIS] + (destination[A ##_AXIS] - current_position[A ##_AXIS]) * normalized_dist)
// 12402 
// 12403     float normalized_dist, end[XYZE];
// 12404 
// 12405     // Split at the left/front border of the right/top square
// 12406     const int8_t gcx = max(cx1, cx2), gcy = max(cy1, cy2);
??mesh_line_to_destination_4:
        MOV      R10,R7
        CMP      R7,R9
        BGE.N    ??mesh_line_to_destination_6
        MOV      R10,R9
??mesh_line_to_destination_6:
        MOV      R11,R8
        CMP      R8,R1
        BGE.N    ??mesh_line_to_destination_7
        MOV      R11,R1
// 12407     if (cx2 != cx1 && TEST(x_splits, gcx)) {
??mesh_line_to_destination_7:
        CMP      R9,R7
        BEQ.N    ??mesh_line_to_destination_8
        MOVS     R7,#+1
        LSL      R7,R7,R10
        MOV      R0,R5
        TST      R0,R7
        BEQ.N    ??mesh_line_to_destination_8
// 12408       COPY(end, destination);
        MOVS     R2,#+16
        ADD      R1,R4,#+24
        ADD      R0,SP,#+4
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 12409       destination[X_AXIS] = LOGICAL_X_POSITION(mbl.index_to_xpos[gcx]);
        LDR.W    R0,??DataTable158
        SXTB     R10,R10
        LDR      R1,[R0, R10, LSL #+2]
        LDR      R0,[R4, #+68]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+24]
// 12410       normalized_dist = (destination[X_AXIS] - current_position[X_AXIS]) / (end[X_AXIS] - current_position[X_AXIS]);
        MOV      R1,R4
        LDR      R8,[R1, #+8]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
        LDR      R0,[SP, #+4]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R0
        MOV      R0,R9
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R8,R0
// 12411       destination[Y_AXIS] = MBL_SEGMENT_END(Y);
        MOV      R0,R4
        LDR      R9,[R0, #+12]
        LDR      R0,[R4, #+28]
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+28]
// 12412       CBI(x_splits, gcx);
        BICS     R5,R5,R7
// 12413     }
// 12414     else if (cy2 != cy1 && TEST(y_splits, gcy)) {
// 12415       COPY(end, destination);
// 12416       destination[Y_AXIS] = LOGICAL_Y_POSITION(mbl.index_to_ypos[gcy]);
// 12417       normalized_dist = (destination[Y_AXIS] - current_position[Y_AXIS]) / (end[Y_AXIS] - current_position[Y_AXIS]);
// 12418       destination[X_AXIS] = MBL_SEGMENT_END(X);
// 12419       CBI(y_splits, gcy);
// 12420     }
// 12421     else {
// 12422       // Already split on a border
// 12423       line_to_destination(fr_mm_s);
// 12424       set_current_to_destination();
// 12425       return;
// 12426     }
// 12427 
// 12428     destination[Z_AXIS] = MBL_SEGMENT_END(Z);
??mesh_line_to_destination_9:
        LDR      R7,[R4, #+16]
        LDR      R0,[R4, #+32]
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R7
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+32]
// 12429     destination[E_AXIS] = MBL_SEGMENT_END(E);
        LDR      R7,[R4, #+20]
        LDR      R0,[R4, #+36]
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R7
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+36]
// 12430 
// 12431     // Do the split and look for more borders
// 12432     mesh_line_to_destination(fr_mm_s, x_splits, y_splits);
        MOV      R2,R6
        MOV      R1,R5
        LDR      R0,[SP, #+0]
          CFI FunCall _Z24mesh_line_to_destinationfhh
        BL       _Z24mesh_line_to_destinationfhh
// 12433 
// 12434     // Restore destination from stack
// 12435     COPY(destination, end);
        MOVS     R2,#+16
        ADD      R1,SP,#+4
        ADD      R0,R4,#+24
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 12436     mesh_line_to_destination(fr_mm_s, x_splits, y_splits);
        MOV      R2,R6
        MOV      R1,R5
        LDR      R0,[SP, #+0]
          CFI FunCall _Z24mesh_line_to_destinationfhh
        BL       _Z24mesh_line_to_destinationfhh
// 12437   }
??mesh_line_to_destination_10:
        ADD      SP,SP,#+20
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
          CFI CFA R13+56
??mesh_line_to_destination_8:
        CMP      R1,R8
        BEQ.N    ??mesh_line_to_destination_5
        MOVS     R7,#+1
        LSL      R7,R7,R11
        MOV      R0,R6
        TST      R0,R7
        BEQ.N    ??mesh_line_to_destination_5
        MOVS     R2,#+16
        ADD      R1,R4,#+24
        ADD      R0,SP,#+4
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        LDR.W    R0,??DataTable163
        SXTB     R11,R11
        LDR      R1,[R0, R11, LSL #+2]
        LDR      R0,[R4, #+72]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+28]
        MOV      R1,R4
        LDR      R8,[R1, #+12]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
        LDR      R0,[SP, #+8]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R0
        MOV      R0,R9
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R8,R0
        MOV      R0,R4
        LDR      R9,[R0, #+8]
        LDR      R0,[R4, #+24]
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+24]
        BICS     R6,R6,R7
        B.N      ??mesh_line_to_destination_9
??mesh_line_to_destination_5:
        LDR      R0,[SP, #+0]
          CFI FunCall _Z19line_to_destinationf
        BL       _Z19line_to_destinationf
          CFI FunCall _Z26set_current_to_destinationv
        BL       _Z26set_current_to_destinationv
        B.N      ??mesh_line_to_destination_10
          CFI EndBlock cfiBlock82

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable147:
        DC32     soft_endstops_enabled

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable147_1:
        DC32     mksCfg+0x20

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable147_2:
        DC32     Running

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable147_3:
        DC32     mksCfg+0x60
// 12438 
// 12439 /*--mks cfg-- AUTO_BED_LEVELING_BILINEAR */
// 12440 #endif
// 12441 //#elif ENABLED(AUTO_BED_LEVELING_BILINEAR) && !IS_KINEMATIC
// 12442 //#if(!IS_KINEMATIC)	//mks_delta
// 12443 #if 1
// 12444   #define CELL_INDEX(A,V) ((RAW_##A##_POSITION(V) - bilinear_start[A##_AXIS]) * ABL_BG_FACTOR(A##_AXIS))
// 12445 
// 12446   /**
// 12447    * Prepare a bilinear-leveled linear move on Cartesian,
// 12448    * splitting the move where it crosses grid borders.
// 12449    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock83 Using cfiCommon0
          CFI Function _Z28bilinear_line_to_destinationftt
        THUMB
// 12450   void bilinear_line_to_destination(float fr_mm_s, uint16_t x_splits = 0xFFFF, uint16_t y_splits = 0xFFFF) {
_Z28bilinear_line_to_destinationftt:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        SUB      SP,SP,#+24
          CFI CFA R13+64
        MOV      R11,R0
        MOV      R5,R1
        MOV      R6,R2
// 12451     int cx1 = CELL_INDEX(X, current_position[X_AXIS]),
        LDR.W    R7,??DataTable160
        LDR      R0,[R7, #+16]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R10,R0
        LDR.W    R4,??DataTable157
        LDR      R0,[R4, #+8]
        LDR      R1,[R4, #+68]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R10
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[R7, #+24]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R8,R0
// 12452         cy1 = CELL_INDEX(Y, current_position[Y_AXIS]),
        LDR      R0,[R7, #+20]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        STR      R0,[SP, #+0]
        LDR      R0,[R4, #+12]
        LDR      R1,[R4, #+72]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[SP, #+0]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[R7, #+28]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R9,R0
// 12453         cx2 = CELL_INDEX(X, destination[X_AXIS]),
        LDR      R0,[R4, #+24]
        LDR      R1,[R4, #+68]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R10
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[R7, #+24]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R10,R0
// 12454         cy2 = CELL_INDEX(Y, destination[Y_AXIS]);
        LDR      R0,[R4, #+28]
        LDR      R1,[R4, #+72]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[SP, #+0]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[R7, #+28]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R1,R0
// 12455     cx1 = constrain(cx1, 0, ABL_BG_POINTS_X - 2);
        LDR.W    R0,??DataTable163_1
        CMP      R8,#+0
        BPL.N    ??bilinear_line_to_destination_0
        MOV      R8,#+0
        B.N      ??bilinear_line_to_destination_1
??bilinear_line_to_destination_0:
        LDRB     R2,[R0, #+0]
        SUBS     R2,R2,#+2
        CMP      R2,R8
        BGE.N    ??bilinear_line_to_destination_1
        MOV      R8,R2
// 12456     cy1 = constrain(cy1, 0, ABL_BG_POINTS_Y - 2);
??bilinear_line_to_destination_1:
        CMP      R9,#+0
        BPL.N    ??bilinear_line_to_destination_2
        MOV      R9,#+0
        B.N      ??bilinear_line_to_destination_3
??bilinear_line_to_destination_2:
        LDRB     R2,[R0, #+1]
        SUBS     R2,R2,#+2
        CMP      R2,R9
        BGE.N    ??bilinear_line_to_destination_3
        MOV      R9,R2
// 12457     cx2 = constrain(cx2, 0, ABL_BG_POINTS_X - 2);
??bilinear_line_to_destination_3:
        CMP      R10,#+0
        BPL.N    ??bilinear_line_to_destination_4
        MOV      R10,#+0
        B.N      ??bilinear_line_to_destination_5
??bilinear_line_to_destination_4:
        LDRB     R2,[R0, #+0]
        SUBS     R2,R2,#+2
        CMP      R2,R10
        BGE.N    ??bilinear_line_to_destination_5
        MOV      R10,R2
// 12458     cy2 = constrain(cy2, 0, ABL_BG_POINTS_Y - 2);
??bilinear_line_to_destination_5:
        CMP      R1,#+0
        BPL.N    ??bilinear_line_to_destination_6
        MOVS     R1,#+0
        B.N      ??bilinear_line_to_destination_7
??bilinear_line_to_destination_6:
        LDRB     R0,[R0, #+1]
        SUBS     R0,R0,#+2
        CMP      R0,R1
        BGE.N    ??bilinear_line_to_destination_7
        MOV      R1,R0
??bilinear_line_to_destination_7:
        STR      R11,[SP, #+0]
// 12459 
// 12460     if (cx1 == cx2 && cy1 == cy2) {
        CMP      R8,R10
        BNE.N    ??bilinear_line_to_destination_8
        CMP      R9,R1
        BEQ.W    ??bilinear_line_to_destination_9
// 12461       // Start and end on same mesh square
// 12462       line_to_destination(fr_mm_s);
// 12463       set_current_to_destination();
// 12464       return;
// 12465     }
// 12466 
// 12467     #define LINE_SEGMENT_END(A) (current_position[A ##_AXIS] + (destination[A ##_AXIS] - current_position[A ##_AXIS]) * normalized_dist)
// 12468 
// 12469     float normalized_dist, end[XYZE];
// 12470 
// 12471     // Split at the left/front border of the right/top square
// 12472     const int8_t gcx = max(cx1, cx2), gcy = max(cy1, cy2);
??bilinear_line_to_destination_8:
        MOV      R0,R8
        CMP      R8,R10
        BGE.N    ??bilinear_line_to_destination_10
        MOV      R0,R10
??bilinear_line_to_destination_10:
        STR      R0,[SP, #+4]
        MOV      R11,R9
        CMP      R9,R1
        BGE.N    ??bilinear_line_to_destination_11
        MOV      R11,R1
// 12473     if (cx2 != cx1 && TEST(x_splits, gcx)) {
??bilinear_line_to_destination_11:
        CMP      R10,R8
        BEQ.N    ??bilinear_line_to_destination_12
        MOVS     R0,#+1
        LDR      R8,[SP, #+4]
        LSL      R8,R0,R8
        MOV      R0,R5
        TST      R0,R8
        BEQ.N    ??bilinear_line_to_destination_12
// 12474       COPY(end, destination);
        MOVS     R2,#+16
        ADD      R1,R4,#+24
        ADD      R0,SP,#+8
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 12475       destination[X_AXIS] = LOGICAL_X_POSITION(bilinear_start[X_AXIS] + ABL_BG_SPACING(X_AXIS) * gcx);
        LDR      R0,[R7, #+16]
        LDR      R2,[R7, #+8]
        ADD      R1,SP,#+4
        LDRSB    R1,[R1, #+0]
        MLA      R0,R1,R2,R0
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R4, #+68]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+24]
// 12476       normalized_dist = (destination[X_AXIS] - current_position[X_AXIS]) / (end[X_AXIS] - current_position[X_AXIS]);
        MOV      R1,R4
        LDR      R7,[R1, #+8]
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
        LDR      R0,[SP, #+8]
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R0
        MOV      R0,R9
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R7,R0
// 12477       destination[Y_AXIS] = LINE_SEGMENT_END(Y);
        MOV      R0,R4
        LDR      R9,[R0, #+12]
        LDR      R0,[R4, #+28]
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+28]
// 12478       CBI(x_splits, gcx);
        BIC      R5,R5,R8
// 12479     }
// 12480     else if (cy2 != cy1 && TEST(y_splits, gcy)) {
// 12481       COPY(end, destination);
// 12482       destination[Y_AXIS] = LOGICAL_Y_POSITION(bilinear_start[Y_AXIS] + ABL_BG_SPACING(Y_AXIS) * gcy);
// 12483       normalized_dist = (destination[Y_AXIS] - current_position[Y_AXIS]) / (end[Y_AXIS] - current_position[Y_AXIS]);
// 12484       destination[X_AXIS] = LINE_SEGMENT_END(X);
// 12485       CBI(y_splits, gcy);
// 12486     }
// 12487     else {
// 12488       // Already split on a border
// 12489       line_to_destination(fr_mm_s);
// 12490       set_current_to_destination();
// 12491       return;
// 12492     }
// 12493 
// 12494     destination[Z_AXIS] = LINE_SEGMENT_END(Z);
??bilinear_line_to_destination_13:
        LDR      R8,[R4, #+16]
        LDR      R0,[R4, #+32]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+32]
// 12495     destination[E_AXIS] = LINE_SEGMENT_END(E);
        LDR      R8,[R4, #+20]
        LDR      R0,[R4, #+36]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+36]
// 12496 
// 12497     // Do the split and look for more borders
// 12498     bilinear_line_to_destination(fr_mm_s, x_splits, y_splits);
        MOV      R2,R6
        MOV      R1,R5
        LDR      R0,[SP, #+0]
          CFI FunCall _Z28bilinear_line_to_destinationftt
        BL       _Z28bilinear_line_to_destinationftt
// 12499 
// 12500     // Restore destination from stack
// 12501     COPY(destination, end);
        MOVS     R2,#+16
        ADD      R1,SP,#+8
        ADD      R0,R4,#+24
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 12502     bilinear_line_to_destination(fr_mm_s, x_splits, y_splits);
        MOV      R2,R6
        MOV      R1,R5
        LDR      R0,[SP, #+0]
          CFI FunCall _Z28bilinear_line_to_destinationftt
        BL       _Z28bilinear_line_to_destinationftt
// 12503   }
??bilinear_line_to_destination_14:
        ADD      SP,SP,#+28
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
          CFI CFA R13+64
??bilinear_line_to_destination_12:
        CMP      R1,R9
        BEQ.N    ??bilinear_line_to_destination_9
        MOV      R8,#+1
        LSL      R8,R8,R11
        MOV      R0,R6
        TST      R0,R8
        BEQ.N    ??bilinear_line_to_destination_9
        MOVS     R2,#+16
        ADD      R1,R4,#+24
        ADD      R0,SP,#+8
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        LDR      R0,[R7, #+20]
        LDR      R1,[R7, #+12]
        SXTB     R11,R11
        MLA      R11,R11,R1,R0
        MOV      R0,R11
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R4, #+72]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+28]
        MOV      R1,R4
        LDR      R7,[R1, #+12]
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
        LDR      R0,[SP, #+12]
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R0
        MOV      R0,R9
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R7,R0
        MOV      R0,R4
        LDR      R9,[R0, #+8]
        LDR      R0,[R4, #+24]
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+24]
        BIC      R6,R6,R8
        B.N      ??bilinear_line_to_destination_13
??bilinear_line_to_destination_9:
        LDR      R0,[SP, #+0]
          CFI FunCall _Z19line_to_destinationf
        BL       _Z19line_to_destinationf
          CFI FunCall _Z26set_current_to_destinationv
        BL       _Z26set_current_to_destinationv
        B.N      ??bilinear_line_to_destination_14
          CFI EndBlock cfiBlock83

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable148:
        DC32     z_values

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable148_1:
        DC32     axis_homed

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable148_2:
        DC32     0x54442d18
// 12504 
// 12505 #endif // AUTO_BED_LEVELING_BILINEAR
// 12506 
// 12507 //#if IS_KINEMATIC	//mks_delta
// 12508 #if 1
// 12509   /**
// 12510    * Prepare a linear move in a DELTA or SCARA setup.
// 12511    *
// 12512    * This calls planner.buffer_line several times, adding
// 12513    * small incremental moves for DELTA or SCARA.
// 12514    */
// 12515   inline bool prepare_kinematic_move_to(float ltarget[XYZE]) {
// 12516 
// 12517     // Get the top feedrate of the move in the XY plane
// 12518     float _feedrate_mm_s = MMS_SCALED(feedrate_mm_s);
// 12519 
// 12520     // If the move is only in Z/E don't split up the move
// 12521     if (ltarget[X_AXIS] == current_position[X_AXIS] && ltarget[Y_AXIS] == current_position[Y_AXIS]) {
// 12522       planner.buffer_line_kinematic(ltarget, _feedrate_mm_s, active_extruder);
// 12523       return false;
// 12524     }
// 12525 
// 12526     // Get the cartesian distances moved in XYZE
// 12527     float difference[XYZE];
// 12528     LOOP_XYZE(i) difference[i] = ltarget[i] - current_position[i];
// 12529 
// 12530     // Get the linear distance in XYZ
// 12531     float cartesian_mm = sqrt(sq(difference[X_AXIS]) + sq(difference[Y_AXIS]) + sq(difference[Z_AXIS]));
// 12532 
// 12533     // If the move is very short, check the E move distance
// 12534     if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = abs(difference[E_AXIS]);
// 12535 
// 12536     // No E move either? Game over.
// 12537     if (UNEAR_ZERO(cartesian_mm)) return true;
// 12538 
// 12539     // Minimum number of seconds to move the given distance
// 12540     float seconds = cartesian_mm / _feedrate_mm_s;
// 12541 
// 12542     // The number of segments-per-second times the duration
// 12543     // gives the number of segments
// 12544     uint16_t segments = delta_segments_per_second * seconds;
// 12545 
// 12546     // For SCARA minimum segment size is 0.25mm
// 12547     //#if IS_SCARA
// 12548 	if(MACHINETPYE&IS_SCARA)
// 12549       NOMORE(segments, cartesian_mm * 4);
// 12550     //#endif
// 12551 
// 12552     // At least one segment is required
// 12553     NOLESS(segments, 1);
// 12554 
// 12555     // The approximate length of each segment
// 12556     const float inv_segments = 1.0 / float(segments),
// 12557                 segment_distance[XYZE] = {
// 12558                   difference[X_AXIS] * inv_segments,
// 12559                   difference[Y_AXIS] * inv_segments,
// 12560                   difference[Z_AXIS] * inv_segments,
// 12561                   difference[E_AXIS] * inv_segments
// 12562                 };
// 12563 
// 12564     // SERIAL_ECHOPAIR("mm=", cartesian_mm);
// 12565     // SERIAL_ECHOPAIR(" seconds=", seconds);
// 12566     // SERIAL_ECHOLNPAIR(" segments=", segments);
// 12567 
// 12568     //#if IS_SCARA	//mks_delta
// 12569 	#if 1
// 12570       // SCARA needs to scale the feed rate from mm/s to degrees/s
// 12571       const float inv_segment_length = min(10.0, float(segments) / cartesian_mm), // 1/mm/segs
// 12572                   feed_factor = inv_segment_length * _feedrate_mm_s;
// 12573       float oldA = stepper.get_axis_position_degrees(A_AXIS),
// 12574             oldB = stepper.get_axis_position_degrees(B_AXIS);
// 12575     #endif
// 12576 
// 12577     // Get the logical current position as starting point
// 12578     float logical[XYZE];
// 12579     COPY(logical, current_position);
// 12580 
// 12581     // Drop one segment so the last move is to the exact target.
// 12582     // If there's only 1 segment, loops will be skipped entirely.
// 12583     --segments;
// 12584 
// 12585     // Calculate and execute the segments
// 12586     for (uint16_t s = segments + 1; --s;) {
// 12587       LOOP_XYZE(i) logical[i] += segment_distance[i];
// 12588 /*	  
// 12589       #if ENABLED(DELTA)
// 12590         DELTA_LOGICAL_IK(); // Delta can inline its kinematics
// 12591       #else
// 12592         inverse_kinematics(logical);
// 12593       #endif
// 12594 */
// 12595 	  if(MACHINETPYE == DELTA)
// 12596 	  	DELTA_LOGICAL_IK(); // Delta can inline its kinematics
// 12597 	  else
// 12598 	  	{
// 12599 	  		if(MACHINETPYE == MORGAN_SCARA)
// 12600 				inverse_kinematics_MORGAN_SCARA(logical);
// 12601 			else
// 12602 				inverse_kinematics(logical);
// 12603 	  	}
// 12604 
// 12605 
// 12606       ADJUST_DELTA(logical); // Adjust Z if bed leveling is enabled
// 12607 
// 12608 //mks_delta 	begin
// 12609 /*
// 12610       #if IS_SCARA
// 12611         // For SCARA scale the feed rate from mm/s to degrees/s
// 12612         // Use ratio between the length of the move and the larger angle change
// 12613         const float adiff = abs(delta[A_AXIS] - oldA),
// 12614                     bdiff = abs(delta[B_AXIS] - oldB);
// 12615         planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], logical[E_AXIS], max(adiff, bdiff) * feed_factor, active_extruder);
// 12616         oldA = delta[A_AXIS];
// 12617         oldB = delta[B_AXIS];
// 12618       #else
// 12619         planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], logical[E_AXIS], _feedrate_mm_s, active_extruder);
// 12620       #endif
// 12621 */      
// 12622 ///////
// 12623 	  float adiff,bdiff;
// 12624 
// 12625 	if(MACHINETPYE&IS_SCARA)
// 12626 		{
// 12627          adiff = abs(delta[A_AXIS] - oldA);
// 12628          bdiff = abs(delta[B_AXIS] - oldB);
// 12629         planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], logical[E_AXIS], max(adiff, bdiff) * feed_factor, active_extruder);
// 12630         oldA = delta[A_AXIS];
// 12631         oldB = delta[B_AXIS];
// 12632 		}
// 12633 	else
// 12634 		{
// 12635 		planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], logical[E_AXIS], _feedrate_mm_s, active_extruder);		
// 12636 		}
// 12637 	  
// 12638  //mks_delta	  end
// 12639 
// 12640     }
// 12641 
// 12642     // Since segment_distance is only approximate,
// 12643     // the final move must be to the exact destination.
// 12644 /*
// 12645     #if IS_SCARA
// 12646       // For SCARA scale the feed rate from mm/s to degrees/s
// 12647       // With segments > 1 length is 1 segment, otherwise total length
// 12648       inverse_kinematics(ltarget);
// 12649       ADJUST_DELTA(logical);
// 12650       const float adiff = abs(delta[A_AXIS] - oldA),
// 12651                   bdiff = abs(delta[B_AXIS] - oldB);
// 12652       planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], logical[E_AXIS], max(adiff, bdiff) * feed_factor, active_extruder);
// 12653     #else
// 12654       planner.buffer_line_kinematic(ltarget, _feedrate_mm_s, active_extruder);
// 12655     #endif
// 12656 */    
// 12657 /////////
// 12658 	float adiff,bdiff;
// 12659 	if(MACHINETPYE&IS_SCARA)
// 12660 		{
// 12661 		
// 12662 		if(MACHINETPYE == MORGAN_SCARA)
// 12663 			inverse_kinematics_MORGAN_SCARA(ltarget);
// 12664 		else
// 12665 			inverse_kinematics(ltarget);
// 12666 		ADJUST_DELTA(logical);
// 12667 		adiff = abs(delta[A_AXIS] - oldA);
// 12668 		bdiff = abs(delta[B_AXIS] - oldB);
// 12669 		planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], logical[E_AXIS], max(adiff, bdiff) * feed_factor, active_extruder);
// 12670 		}
// 12671 	else
// 12672 		{
// 12673 		planner.buffer_line_kinematic(ltarget, _feedrate_mm_s, active_extruder);
// 12674 		}
// 12675 
// 12676 	
// 12677     return false;
// 12678   }
// 12679 
// 12680 #endif
// 12681 //#else // !IS_KINEMATIC
// 12682 #if 1
// 12683   /**
// 12684    * Prepare a linear move in a Cartesian setup.
// 12685    * If Mesh Bed Leveling is enabled, perform a mesh move.
// 12686    *
// 12687    * Returns true if the caller didn't update current_position.
// 12688    */
// 12689   inline bool prepare_move_to_destination_cartesian() {
// 12690     // Do not use feedrate_percentage for E or Z only moves
// 12691     if (current_position[X_AXIS] == destination[X_AXIS] && current_position[Y_AXIS] == destination[Y_AXIS]) 
// 12692 	{
// 12693       line_to_destination();
// 12694     }
// 12695     else {
// 12696 /*--mks cfg--begin MESH_BED_LEVELING */	
// 12697 /*
// 12698       #if ENABLED(MESH_BED_LEVELING)
// 12699         if (mbl.active()) {
// 12700           mesh_line_to_destination(MMS_SCALED(feedrate_mm_s));
// 12701           return true;
// 12702         }
// 12703         else
// 12704       #elif ENABLED(AUTO_BED_LEVELING_UBL)
// 12705         if (ubl.state.active) {
// 12706           ubl_line_to_destination(MMS_SCALED(feedrate_mm_s), active_extruder);
// 12707           return true;
// 12708         }
// 12709         else
// 12710       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 12711         if (planner.abl_enabled) {
// 12712           bilinear_line_to_destination(MMS_SCALED(feedrate_mm_s));
// 12713           return true;
// 12714         }
// 12715         else
// 12716       #endif
// 12717           line_to_destination(MMS_SCALED(feedrate_mm_s));
// 12718 */
// 12719 	if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
// 12720 		{
// 12721         if (mbl.active()) {
// 12722           mesh_line_to_destination(MMS_SCALED(feedrate_mm_s));
// 12723           return true;
// 12724         }
// 12725         else
// 12726 			line_to_destination(MMS_SCALED(feedrate_mm_s));
// 12727 		}
// 12728 	else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
// 12729 		{
// 12730         if (ubl.state.active) {
// 12731           ubl_line_to_destination(MMS_SCALED(feedrate_mm_s), active_extruder);
// 12732           return true;
// 12733         }
// 12734         else
// 12735 			line_to_destination(MMS_SCALED(feedrate_mm_s));
// 12736 		}
// 12737 
// 12738 	else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
// 12739 		{
// 12740         if (planner.abl_enabled) {
// 12741           bilinear_line_to_destination(MMS_SCALED(feedrate_mm_s));
// 12742           return true;
// 12743         }
// 12744         else
// 12745 			line_to_destination(MMS_SCALED(feedrate_mm_s));
// 12746 		}
// 12747 	else
// 12748 		{
// 12749 		line_to_destination(MMS_SCALED(feedrate_mm_s));
// 12750 		}
// 12751 	/*--mks cfg--end MESH_BED_LEVELING */
// 12752 
// 12753 	}
// 12754     return false;
// 12755   }
// 12756 
// 12757 #endif // !IS_KINEMATIC
// 12758 
// 12759 #if ENABLED(DUAL_X_CARRIAGE)
// 12760 
// 12761   /**
// 12762    * Prepare a linear move in a dual X axis setup
// 12763    */
// 12764   inline bool prepare_move_to_destination_dualx() {
// 12765     if (active_extruder_parked) {
// 12766       switch (dual_x_carriage_mode) {
// 12767         case DXC_FULL_CONTROL_MODE:
// 12768           break;
// 12769         case DXC_AUTO_PARK_MODE:
// 12770           if (current_position[E_AXIS] == destination[E_AXIS]) {
// 12771             // This is a travel move (with no extrusion)
// 12772             // Skip it, but keep track of the current position
// 12773             // (so it can be used as the start of the next non-travel move)
// 12774             if (delayed_move_time != 0xFFFFFFFFUL) {
// 12775               set_current_to_destination();
// 12776               NOLESS(raised_parked_position[Z_AXIS], destination[Z_AXIS]);
// 12777               delayed_move_time = millis();
// 12778               return true;
// 12779             }
// 12780           }
// 12781           // unpark extruder: 1) raise, 2) move into starting XY position, 3) lower
// 12782           for (uint8_t i = 0; i < 3; i++)
// 12783             planner.buffer_line(
// 12784               i == 0 ? raised_parked_position[X_AXIS] : current_position[X_AXIS],
// 12785               i == 0 ? raised_parked_position[Y_AXIS] : current_position[Y_AXIS],
// 12786               i == 2 ? current_position[Z_AXIS] : raised_parked_position[Z_AXIS],
// 12787               current_position[E_AXIS],
// 12788               i == 1 ? PLANNER_XY_FEEDRATE() : planner.max_feedrate_mm_s[Z_AXIS],
// 12789               active_extruder
// 12790             );
// 12791           delayed_move_time = 0;
// 12792           active_extruder_parked = false;
// 12793           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12794             if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Clear active_extruder_parked");
// 12795           #endif
// 12796           break;
// 12797         case DXC_DUPLICATION_MODE:
// 12798           if (active_extruder == 0) {
// 12799             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12800               if (DEBUGGING(LEVELING)) {
// 12801                 SERIAL_ECHOPAIR("Set planner X", LOGICAL_X_POSITION(inactive_extruder_x_pos));
// 12802                 SERIAL_ECHOLNPAIR(" ... Line to X", current_position[X_AXIS] + duplicate_extruder_x_offset);
// 12803               }
// 12804             #endif
// 12805             // move duplicate extruder into correct duplication position.
// 12806             planner.set_position_mm(
// 12807               LOGICAL_X_POSITION(inactive_extruder_x_pos),
// 12808               current_position[Y_AXIS],
// 12809               current_position[Z_AXIS],
// 12810               current_position[E_AXIS]
// 12811             );
// 12812             planner.buffer_line(
// 12813               current_position[X_AXIS] + duplicate_extruder_x_offset,
// 12814               current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS],
// 12815               planner.max_feedrate_mm_s[X_AXIS], 1
// 12816             );
// 12817             SYNC_PLAN_POSITION_KINEMATIC();
// 12818             stepper.synchronize();
// 12819             extruder_duplication_enabled = true;
// 12820             active_extruder_parked = false;
// 12821             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12822               if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Set extruder_duplication_enabled\nClear active_extruder_parked");
// 12823             #endif
// 12824           }
// 12825           else {
// 12826             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12827               if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Active extruder not 0");
// 12828             #endif
// 12829           }
// 12830           break;
// 12831       }
// 12832     }
// 12833     return false;
// 12834   }
// 12835 
// 12836 #endif // DUAL_X_CARRIAGE
// 12837 
// 12838 /**
// 12839  * Prepare a single move and get ready for the next one
// 12840  *
// 12841  * This may result in several calls to planner.buffer_line to
// 12842  * do smaller moves for DELTA, SCARA, mesh moves, etc.
// 12843  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock84 Using cfiCommon0
          CFI Function _Z27prepare_move_to_destinationv
        THUMB
// 12844 void prepare_move_to_destination() {
_Z27prepare_move_to_destinationv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
// 12845   clamp_to_software_endstops(destination);
        LDR.W    R4,??DataTable157
        ADD      R0,R4,#+24
          CFI FunCall _Z26clamp_to_software_endstopsPf
        BL       _Z26clamp_to_software_endstopsPf
// 12846   refresh_cmd_timeout();
          CFI FunCall _Z19refresh_cmd_timeoutv
        BL       _Z19refresh_cmd_timeoutv
// 12847 
// 12848   #if ENABLED(PREVENT_COLD_EXTRUSION)
// 12849 
// 12850     if (!DEBUGGING(DRYRUN)) {
        LDRB     R0,[R4, #+1]
        LSLS     R0,R0,#+28
        BMI.N    ??prepare_move_to_destination_0
// 12851       if (destination[E_AXIS] != current_position[E_AXIS]) {
        LDR      R5,[R4, #+36]
        MOV      R0,R5
        LDR      R1,[R4, #+20]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??prepare_move_to_destination_0
// 12852         if (thermalManager.tooColdToExtrude(active_extruder)) {
        LDRB     R0,[R4, #+2]
          CFI FunCall _ZN11Temperature16tooColdToExtrudeEh
        BL       _ZN11Temperature16tooColdToExtrudeEh
        CMP      R0,#+0
        BEQ.N    ??prepare_move_to_destination_1
// 12853           current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
        STR      R5,[R4, #+20]
// 12854           SERIAL_ECHO_START;
        LDR.W    R0,??DataTable163_2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 12855           SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
        ADR.W    R0,?_41
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 12856         }
// 12857         #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
// 12858           if (labs(destination[E_AXIS] - current_position[E_AXIS]) > EXTRUDE_MAXLENGTH) {
??prepare_move_to_destination_1:
        LDR      R5,[R4, #+36]
        MOV      R0,R5
        LDR      R1,[R4, #+20]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
          CFI FunCall labs
        BL       labs
        MOVW     R1,#+301
        CMP      R0,R1
        BLT.N    ??prepare_move_to_destination_0
// 12859             current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
        STR      R5,[R4, #+20]
// 12860             SERIAL_ECHO_START;
        LDR.W    R0,??DataTable163_2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 12861             SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
        ADR.W    R0,?_42
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 12862           }
// 12863         #endif
// 12864       }
// 12865     }
// 12866 
// 12867   #endif
// 12868 
// 12869 //mks_delta    begin
// 12870 /*
// 12871   #if IS_KINEMATIC
// 12872     if (prepare_kinematic_move_to(destination)) return;
// 12873   #else
// 12874     #if ENABLED(DUAL_X_CARRIAGE)
// 12875       if (prepare_move_to_destination_dualx()) return;
// 12876     #endif
// 12877     if (prepare_move_to_destination_cartesian()) return;
// 12878   #endif
// 12879 */
// 12880 	if(MACHINETPYE & IS_KINEMATIC)
??prepare_move_to_destination_0:
        LDR.W    R0,??DataTable153
        LDRH     R0,[R0, #+88]
        MOVW     R1,#+770
        TST      R0,R1
        BEQ.N    ??prepare_move_to_destination_2
// 12881         {
// 12882   		if (prepare_kinematic_move_to(destination)) return;
        ADD      R0,R4,#+24
          CFI FunCall _Z25prepare_kinematic_move_toPf
        BL       _Z25prepare_kinematic_move_toPf
        CMP      R0,#+0
        BEQ.N    ??prepare_move_to_destination_3
        POP      {R0,R4,R5,PC}
// 12883         }
// 12884 	else
// 12885 	{
// 12886 		#if ENABLED(DUAL_X_CARRIAGE)
// 12887 		  	if (prepare_move_to_destination_dualx()) return;
// 12888 		#endif
// 12889 			if (prepare_move_to_destination_cartesian()) return;
??prepare_move_to_destination_2:
          CFI FunCall _Z37prepare_move_to_destination_cartesianv
        BL       _Z37prepare_move_to_destination_cartesianv
        CMP      R0,#+0
        BNE.N    ??prepare_move_to_destination_4
// 12890 	}
// 12891   //mks_delta	 end
// 12892 
// 12893   set_current_to_destination();
??prepare_move_to_destination_3:
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z26set_current_to_destinationv
        B.W      _Z26set_current_to_destinationv
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??prepare_move_to_destination_4:
        POP      {R0,R4,R5,PC}    ;; return
// 12894 }
          CFI EndBlock cfiBlock84

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable149:
        DC32     0x400921fb

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable149_1:
        DC32     0x43520000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable149_2:
        DC32     0x40668000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable149_3:
        DC32     0x43a50000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_41:
        DC8 " cold extrusion prevented\012"
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_42:
        DC8 " too long extrusion prevented\012"
        DC8 0
// 12895 
// 12896 #if ENABLED(ARC_SUPPORT)
// 12897   /**
// 12898    * Plan an arc in 2 dimensions
// 12899    *
// 12900    * The arc is approximated by generating many small linear segments.
// 12901    * The length of each segment is configured in MM_PER_ARC_SEGMENT (Default 1mm)
// 12902    * Arcs should only be made relatively large (over 5mm), as larger arcs with
// 12903    * larger segments will tend to be more efficient. Your slicer should have
// 12904    * options for G2/G3 arc generation. In future these options may be GCode tunable.
// 12905    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock85 Using cfiCommon0
          CFI Function _Z8plan_arcPfS_h
        THUMB
// 12906   void plan_arc(
// 12907     float logical[XYZE], // Destination position
// 12908     float *offset,       // Center of rotation relative to current_position
// 12909     uint8_t clockwise    // Clockwise?
// 12910   ) {
_Z8plan_arcPfS_h:
        PUSH     {R0,R1,R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+44
        SUB      SP,SP,#+52
          CFI CFA R13+96
        MOV      R7,R0
        MOV      R4,R2
// 12911 
// 12912     float r_X = -offset[X_AXIS],  // Radius vector from center to current location
        MOV      R0,R1
        LDR      R0,[R0, #+0]
        EOR      R0,R0,#0x80000000
        STR      R0,[SP, #+12]
// 12913           r_Y = -offset[Y_AXIS];
        LDR      R0,[SP, #+56]
        LDR      R0,[R0, #+4]
        EOR      R0,R0,#0x80000000
        STR      R0,[SP, #+8]
// 12914 
// 12915     const float radius = HYPOT(r_X, r_Y),
        LDR      R9,[SP, #+12]
        MOVS     R6,#+2
        MOV      R5,#+1065353216
        MOV      R8,R5
        B.N      ??plan_arc_0
??plan_arc_1:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??plan_arc_0:
        LSLS     R0,R6,#+31
        BPL.N    ??plan_arc_2
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??plan_arc_2:
        LSRS     R6,R6,#+1
        BNE.N    ??plan_arc_1
        LDR      R10,[SP, #+8]
        MOVS     R6,#+2
        MOV      R9,R5
        B.N      ??plan_arc_3
??plan_arc_4:
        MOV      R0,R10
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??plan_arc_3:
        LSLS     R0,R6,#+31
        BPL.N    ??plan_arc_5
        MOV      R0,R9
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??plan_arc_5:
        LSRS     R6,R6,#+1
        BNE.N    ??plan_arc_4
        STR      R7,[SP, #+4]
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R8,R0
// 12916                 center_X = current_position[X_AXIS] - r_X,
        LDR.W    R0,??DataTable157
        LDR      R0,[R0, #+8]
        STR      R0,[SP, #+24]
        LDR      R1,[SP, #+12]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+20]
// 12917                 center_Y = current_position[Y_AXIS] - r_Y,
        LDR.W    R0,??DataTable157
        LDR      R6,[R0, #+12]
        MOV      R0,R6
        LDR      R1,[SP, #+8]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+16]
// 12918                 rt_X = logical[X_AXIS] - center_X,
        LDR      R0,[SP, #+4]
        LDR      R0,[R0, #+0]
        LDR      R1,[SP, #+20]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R10,R0
// 12919                 rt_Y = logical[Y_AXIS] - center_Y,
        LDR      R0,[SP, #+4]
        LDR      R0,[R0, #+4]
        LDR      R1,[SP, #+16]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R11,R0
// 12920                 linear_travel = logical[Z_AXIS] - current_position[Z_AXIS],
        LDR.W    R0,??DataTable157
        LDR      R0,[R0, #+16]
        STR      R0,[SP, #+28]
        LDR      R0,[SP, #+4]
        LDR      R0,[R0, #+8]
        LDR      R1,[SP, #+28]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
// 12921                 extruder_travel = logical[E_AXIS] - current_position[E_AXIS];
        LDR.W    R0,??DataTable157
        LDR      R7,[R0, #+20]
        LDR      R0,[SP, #+4]
        LDR      R0,[R0, #+12]
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+48]
// 12922 
// 12923     // CCW angle of rotation between position and target from the circle center. Only one atan2() trig computation required.
// 12924     float angular_travel = atan2(r_X * rt_Y - r_Y * rt_X, r_X * rt_X + r_Y * rt_Y);
        LDR      R0,[SP, #+12]
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[SP, #+0]
        LDR      R0,[SP, #+8]
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR      R1,[SP, #+0]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        STR      R1,[SP, #+0]
        LDR      R0,[SP, #+12]
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
        LDR      R0,[SP, #+8]
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R11
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[SP, #+0]
          CFI FunCall atan2f
        BL       atan2f
        MOV      R10,R0
// 12925     if (angular_travel < 0) angular_travel += RADIANS(360);
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??plan_arc_6
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable166_1  ;; 0x54442d18
        LDR.W    R3,??DataTable166_2  ;; 0x401921fb
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R10,R0
// 12926     if (clockwise) angular_travel -= RADIANS(360);
??plan_arc_6:
        CMP      R4,#+0
        BEQ.N    ??plan_arc_7
        MOV      R0,R10
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable166_1  ;; 0x54442d18
        LDR.W    R3,??DataTable166_3  ;; 0xc01921fb
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R10,R0
// 12927 
// 12928     // Make a circle if the angular rotation is 0
// 12929     if (angular_travel == 0 && current_position[X_AXIS] == logical[X_AXIS] && current_position[Y_AXIS] == logical[Y_AXIS])
??plan_arc_7:
        MOV      R0,R10
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??plan_arc_8
        LDR      R0,[SP, #+24]
        LDR      R1,[SP, #+4]
        LDR      R1,[R1, #+0]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??plan_arc_8
        MOV      R0,R6
        LDR      R1,[SP, #+4]
        LDR      R1,[R1, #+4]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??plan_arc_8
// 12930       angular_travel += RADIANS(360);
        LDR.W    R10,??DataTable166_4  ;; 0x40c90fdb
// 12931 
// 12932     float mm_of_travel = HYPOT(angular_travel * radius, fabs(linear_travel));
??plan_arc_8:
        MOV      R0,R10
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
        MOVS     R4,#+2
        MOV      R6,R5
        B.N      ??plan_arc_9
??plan_arc_10:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??plan_arc_9:
        LSLS     R0,R4,#+31
        BPL.N    ??plan_arc_11
        MOV      R0,R6
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
??plan_arc_11:
        LSRS     R4,R4,#+1
        BNE.N    ??plan_arc_10
        BIC      R8,R9,#0x80000000
        MOVS     R4,#+2
        MOV      R11,R5
        B.N      ??plan_arc_12
??plan_arc_13:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??plan_arc_12:
        LSLS     R0,R4,#+31
        BPL.N    ??plan_arc_14
        MOV      R0,R11
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??plan_arc_14:
        LSRS     R4,R4,#+1
        BNE.N    ??plan_arc_13
        MOV      R0,R6
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall sqrtf
        BL       sqrtf
// 12933     if (mm_of_travel < 0.001) return;
        LDR.W    R1,??DataTable166_5  ;; 0x3a83126f
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.W    ??plan_arc_15
// 12934 
// 12935     uint16_t segments = floor(mm_of_travel / (MM_PER_ARC_SEGMENT));
          CFI FunCall floorf
        BL       floorf
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R4,R0
        UXTH     R4,R4
// 12936     if (segments == 0) segments = 1;
        CMP      R4,#+0
        BNE.N    ??plan_arc_16
        MOVS     R4,#+1
// 12937 
// 12938     /**
// 12939      * Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,
// 12940      * and phi is the angle of rotation. Based on the solution approach by Jens Geisler.
// 12941      *     r_T = [cos(phi) -sin(phi);
// 12942      *            sin(phi)  cos(phi)] * r ;
// 12943      *
// 12944      * For arc generation, the center of the circle is the axis of rotation and the radius vector is
// 12945      * defined from the circle center to the initial position. Each line segment is formed by successive
// 12946      * vector rotations. This requires only two cos() and sin() computations to form the rotation
// 12947      * matrix for the duration of the entire arc. Error may accumulate from numerical round-off, since
// 12948      * all double numbers are single precision on the Arduino. (True double precision will not have
// 12949      * round off issues for CNC applications.) Single precision error can accumulate to be greater than
// 12950      * tool precision in some cases. Therefore, arc path correction is implemented.
// 12951      *
// 12952      * Small angle approximation may be used to reduce computation overhead further. This approximation
// 12953      * holds for everything, but very small circles and large MM_PER_ARC_SEGMENT values. In other words,
// 12954      * theta_per_segment would need to be greater than 0.1 rad and N_ARC_CORRECTION would need to be large
// 12955      * to cause an appreciable drift error. N_ARC_CORRECTION~=25 is more than small enough to correct for
// 12956      * numerical drift error. N_ARC_CORRECTION may be on the order a hundred(s) before error becomes an
// 12957      * issue for CNC machines with the single precision Arduino calculations.
// 12958      *
// 12959      * This approximation also allows plan_arc to immediately insert a line segment into the planner
// 12960      * without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
// 12961      * a correction, the planner should have caught up to the lag caused by the initial plan_arc overhead.
// 12962      * This is important when there are successive arc motions.
// 12963      */
// 12964     // Vector rotation matrix values
// 12965     float arc_target[XYZE];
// 12966     const float theta_per_segment = angular_travel / segments,
??plan_arc_16:
        MOV      R0,R4
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R6,R0
        MOV      R0,R10
        MOV      R1,R6
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R8,R0
// 12967                 linear_per_segment = linear_travel / segments,
        MOV      R0,R9
        MOV      R1,R6
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[SP, #+24]
// 12968                 extruder_per_segment = extruder_travel / segments,
        LDR      R0,[SP, #+48]
        MOV      R1,R6
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R6,R0
// 12969                 sin_T = theta_per_segment,
// 12970                 cos_T = 1 - 0.5 * sq(theta_per_segment); // Small angle approximation
        MOV      R10,R8
        MOV      R9,#+2
        B.N      ??plan_arc_17
??plan_arc_18:
        MOV      R0,R10
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??plan_arc_17:
        LSLS     R0,R9,#+31
        BPL.N    ??plan_arc_19
        MOV      R0,R5
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
??plan_arc_19:
        LSRS     R9,R9,#+1
        BNE.N    ??plan_arc_18
        MOV      R0,R5
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        LDR.W    R3,??DataTable166_6  ;; 0x3fe00000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R0
        MOV      R3,R1
        MOVS     R0,#+0
        LDR.W    R1,??DataTable167  ;; 0x3ff00000
          CFI FunCall __aeabi_dsub
        BL       __aeabi_dsub
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R5,R0
// 12971 
// 12972     // Initialize the linear axis
// 12973     arc_target[Z_AXIS] = current_position[Z_AXIS];
        LDR      R0,[SP, #+28]
        STR      R0,[SP, #+40]
// 12974 
// 12975     // Initialize the extruder axis
// 12976     arc_target[E_AXIS] = current_position[E_AXIS];
        STR      R7,[SP, #+44]
// 12977 
// 12978     const float fr_mm_s = MMS_SCALED(feedrate_mm_s);
        LDR.W    R0,??DataTable157
        LDR      R0,[R0, #+120]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR.W    R1,??DataTable157
        LDR      R1,[R1, #+116]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable167_1  ;; 0x47ae147b
        LDR.W    R3,??DataTable167_2  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+0]
// 12979 
// 12980     millis_t next_idle_ms = millis() + 200UL;
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        ADDS     R0,R0,#+200
// 12981 
// 12982     int8_t count = 0;
        MOVS     R2,#+0
// 12983     for (uint16_t i = 1; i < segments; i++) { // Iterate (segments-1) times
        MOVS     R1,#+1
        LDR      R7,[SP, #+12]
        LDR      R9,[SP, #+8]
        STR      R4,[SP, #+28]
        STR      R6,[SP, #+12]
        STR      R5,[SP, #+8]
        MOV      R5,R0
        MOV      R6,R2
        MOV      R4,R1
??plan_arc_20:
        LDR      R0,[SP, #+28]
        CMP      R4,R0
        BGE.W    ??plan_arc_21
// 12984 
// 12985       thermalManager.manage_heater();
          CFI FunCall _ZN11Temperature13manage_heaterEv
        BL       _ZN11Temperature13manage_heaterEv
// 12986       if (ELAPSED(millis(), next_idle_ms)) {
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        SUBS     R0,R0,R5
        BMI.N    ??plan_arc_22
// 12987         next_idle_ms = millis() + 200UL;
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        MOV      R5,R0
        ADDS     R5,R5,#+200
// 12988         idle();
        MOVS     R0,#+0
          CFI FunCall _Z4idleb
        BL       _Z4idleb
// 12989       }
// 12990 
// 12991       if (++count < N_ARC_CORRECTION) {
??plan_arc_22:
        ADDS     R6,R6,#+1
        MOV      R0,R6
        SXTB     R0,R0
        CMP      R0,#+25
        BLT.N    ??plan_arc_23
// 12992         // Apply vector rotation matrix to previous r_X / 1
// 12993         const float r_new_Y = r_X * sin_T + r_Y * cos_T;
// 12994         r_X = r_X * cos_T - r_Y * sin_T;
// 12995         r_Y = r_new_Y;
// 12996       }
// 12997       else {
// 12998         // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments.
// 12999         // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
// 13000         // To reduce stuttering, the sin and cos could be computed at different times.
// 13001         // For now, compute both at the same time.
// 13002         const float cos_Ti = cos(i * theta_per_segment),
        MOV      R0,R4
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
          CFI FunCall cosf
        BL       cosf
        MOV      R6,R0
// 13003                     sin_Ti = sin(i * theta_per_segment);
        MOV      R0,R7
          CFI FunCall sinf
        BL       sinf
        MOV      R9,R0
// 13004         r_X = -offset[X_AXIS] * cos_Ti + offset[Y_AXIS] * sin_Ti;
        LDR      R0,[SP, #+56]
        LDR      R10,[R0, #+4]
        LDR      R11,[R0, #+0]
        MOV      R0,R10
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
        MOV      R0,R11
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R7,R0
// 13005         r_Y = -offset[X_AXIS] * sin_Ti - offset[Y_AXIS] * cos_Ti;
        MOV      R0,R11
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        EOR      R0,R0,#0x80000000
        MOV      R9,R0
        MOV      R0,R10
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
// 13006         count = 0;
        MOVS     R6,#+0
        B.N      ??plan_arc_24
// 13007       }
??plan_arc_23:
        MOV      R0,R7
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
        LDR      R0,[SP, #+8]
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R10,R0
        LDR      R0,[SP, #+8]
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
        MOV      R0,R9
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R7,R0
        MOV      R9,R10
// 13008 
// 13009       // Update arc_target location
// 13010       arc_target[X_AXIS] = center_X + r_X;
??plan_arc_24:
        LDR      R0,[SP, #+20]
        MOV      R1,R7
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[SP, #+32]
// 13011       arc_target[Y_AXIS] = center_Y + r_Y;
        ADD      R10,SP,#+32
        LDR      R0,[SP, #+16]
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R10, #+4]
// 13012       arc_target[Z_AXIS] += linear_per_segment;
        LDR      R0,[R10, #+8]
        LDR      R1,[SP, #+24]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R10, #+8]
// 13013       arc_target[E_AXIS] += extruder_per_segment;
        LDR      R0,[R10, #+12]
        LDR      R1,[SP, #+12]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R10, #+12]
// 13014 
// 13015       clamp_to_software_endstops(arc_target);
        ADD      R0,SP,#+32
          CFI FunCall _Z26clamp_to_software_endstopsPf
        BL       _Z26clamp_to_software_endstopsPf
// 13016 
// 13017       planner.buffer_line_kinematic(arc_target, fr_mm_s, active_extruder);
        LDR.W    R0,??DataTable157
        LDRB     R2,[R0, #+2]
        MOV      R1,SP
        ADD      R0,SP,#+32
          CFI FunCall _ZN7Planner21buffer_line_kinematicEPKfRS0_h
        BL       _ZN7Planner21buffer_line_kinematicEPKfRS0_h
// 13018     }
        ADDS     R4,R4,#+1
        UXTH     R4,R4
        B.N      ??plan_arc_20
// 13019 
// 13020     // Ensure last segment arrives at target location.
// 13021     planner.buffer_line_kinematic(logical, fr_mm_s, active_extruder);
??plan_arc_21:
        LDR.N    R0,??DataTable157
        LDRB     R2,[R0, #+2]
        MOV      R1,SP
        LDR      R0,[SP, #+4]
          CFI FunCall _ZN7Planner21buffer_line_kinematicEPKfRS0_h
        BL       _ZN7Planner21buffer_line_kinematicEPKfRS0_h
// 13022 
// 13023     // As far as the parser is concerned, the position is now == target. In reality the
// 13024     // motion control system might still be processing the action and the real tool position
// 13025     // in any intermediate location.
// 13026     set_current_to_destination();
          CFI FunCall _Z26set_current_to_destinationv
        BL       _Z26set_current_to_destinationv
// 13027   }
??plan_arc_15:
        ADD      SP,SP,#+60
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
          CFI EndBlock cfiBlock85
// 13028 #endif
// 13029 
// 13030 #if ENABLED(BEZIER_CURVE_SUPPORT)
// 13031 
// 13032   void plan_cubic_move(const float offset[4]) {
// 13033     cubic_b_spline(current_position, destination, offset, MMS_SCALED(feedrate_mm_s), active_extruder);
// 13034 
// 13035     // As far as the parser is concerned, the position is now == destination. In reality the
// 13036     // motion control system might still be processing the action and the real tool position
// 13037     // in any intermediate location.
// 13038     set_current_to_destination();
// 13039   }
// 13040 
// 13041 #endif // BEZIER_CURVE_SUPPORT
// 13042 
// 13043 #if ENABLED(USE_CONTROLLER_FAN)
// 13044 
// 13045   void controllerFan() {
// 13046     static millis_t lastMotorOn = 0, // Last time a motor was turned on
// 13047                     nextMotorCheck = 0; // Last time the state was checked
// 13048     const millis_t ms = millis();
// 13049     if (ELAPSED(ms, nextMotorCheck)) {
// 13050       nextMotorCheck = ms + 2500UL; // Not a time critical function, so only check every 2.5s
// 13051       if (X_ENABLE_READ == X_ENABLE_ON || Y_ENABLE_READ == Y_ENABLE_ON || Z_ENABLE_READ == Z_ENABLE_ON || thermalManager.soft_pwm_bed > 0
// 13052           || E0_ENABLE_READ == E_ENABLE_ON // If any of the drivers are enabled...
// 13053           #if E_STEPPERS > 1
// 13054             || E1_ENABLE_READ == E_ENABLE_ON
// 13055             #if HAS_X2_ENABLE
// 13056               || X2_ENABLE_READ == X_ENABLE_ON
// 13057             #endif
// 13058             #if E_STEPPERS > 2
// 13059               || E2_ENABLE_READ == E_ENABLE_ON
// 13060               #if E_STEPPERS > 3
// 13061                 || E3_ENABLE_READ == E_ENABLE_ON
// 13062                 #if E_STEPPERS > 4
// 13063                   || E4_ENABLE_READ == E_ENABLE_ON
// 13064                 #endif // E_STEPPERS > 4
// 13065               #endif // E_STEPPERS > 3
// 13066             #endif // E_STEPPERS > 2
// 13067           #endif // E_STEPPERS > 1
// 13068       ) {
// 13069         lastMotorOn = ms; //... set time to NOW so the fan will turn on
// 13070       }
// 13071 
// 13072       // Fan off if no steppers have been enabled for CONTROLLERFAN_SECS seconds
// 13073       uint8_t speed = (!lastMotorOn || ELAPSED(ms, lastMotorOn + (CONTROLLERFAN_SECS) * 1000UL)) ? 0 : CONTROLLERFAN_SPEED;
// 13074 
// 13075       // allows digital or PWM fan output to be used (see M42 handling)
// 13076       WRITE(CONTROLLER_FAN_PIN, speed);
// 13077       analogWrite(CONTROLLER_FAN_PIN, speed);
// 13078     }
// 13079   }
// 13080 
// 13081 #endif // USE_CONTROLLER_FAN
// 13082 
// 13083 //#if ENABLED(MORGAN_SCARA)	//mks_delta
// 13084 #if 1
// 13085   /**
// 13086    * Morgan SCARA Forward Kinematics. Results in cartes[].
// 13087    * Maths and first version by QHARLEY.
// 13088    * Integrated into Marlin and slightly restructured by Joachim Cerny.
// 13089    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock86 Using cfiCommon0
          CFI Function _Z24forward_kinematics_SCARARKfS0_
        THUMB
// 13090   void forward_kinematics_SCARA(const float &a, const float &b) {
_Z24forward_kinematics_SCARARKfS0_:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
        MOV      R9,R0
        MOV      R10,R1
// 13091 
// 13092     float a_sin = sin(RADIANS(a)) * L1,
        MOVS     R6,#+0
        LDR.W    R7,??DataTable169  ;; 0x4062c000
        LDR.W    R4,??DataTable166_1  ;; 0x54442d18
        LDR.W    R5,??DataTable169_1  ;; 0x400921fb
        LDR      R0,[R9, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R6
        LDR.W    R3,??DataTable169_2  ;; 0x40668000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall sin
        BL       sin
        MOV      R2,R6
        MOV      R3,R7
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R8,R0
// 13093           a_cos = cos(RADIANS(a)) * L1,
        LDR      R0,[R9, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R6
        LDR.W    R3,??DataTable169_2  ;; 0x40668000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall cos
        BL       cos
        MOV      R2,R6
        MOV      R3,R7
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R9,R0
// 13094           b_sin = sin(RADIANS(b)) * L2,
        LDR      R0,[R10, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R6
        LDR.W    R3,??DataTable169_2  ;; 0x40668000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall sin
        BL       sin
        MOV      R2,R6
        MOV      R3,R7
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R8,R0
// 13095           b_cos = cos(RADIANS(b)) * L2;
        LDR      R0,[R10, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R6
        LDR.W    R3,??DataTable169_2  ;; 0x40668000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall cos
        BL       cos
        MOV      R2,R6
        MOV      R3,R7
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
// 13096 
// 13097     cartes[X_AXIS] = a_cos + b_cos + SCARA_OFFSET_X;  //theta
        LDR.W    R4,??DataTable169_3
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR.W    R1,??DataTable169_4  ;; 0x42c80000
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+40]
// 13098     cartes[Y_AXIS] = a_sin + b_sin + SCARA_OFFSET_Y;  //theta+phi
        LDR.W    R0,??DataTable171  ;; 0xc2600000
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+44]
// 13099 
// 13100     /*
// 13101       SERIAL_ECHOPAIR("SCARA FK Angle a=", a);
// 13102       SERIAL_ECHOPAIR(" b=", b);
// 13103       SERIAL_ECHOPAIR(" a_sin=", a_sin);
// 13104       SERIAL_ECHOPAIR(" a_cos=", a_cos);
// 13105       SERIAL_ECHOPAIR(" b_sin=", b_sin);
// 13106       SERIAL_ECHOLNPAIR(" b_cos=", b_cos);
// 13107       SERIAL_ECHOPAIR(" cartes[X_AXIS]=", cartes[X_AXIS]);
// 13108       SERIAL_ECHOLNPAIR(" cartes[Y_AXIS]=", cartes[Y_AXIS]);
// 13109     //*/
// 13110   }
        POP      {R4-R10,PC}      ;; return
          CFI EndBlock cfiBlock86
// 13111 
// 13112   /**
// 13113    * Morgan SCARA Inverse Kinematics. Results in delta[].
// 13114    *
// 13115    * See http://forums.reprap.org/read.php?185,283327
// 13116    *
// 13117    * Maths and first version by QHARLEY.
// 13118    * Integrated into Marlin and slightly restructured by Joachim Cerny.
// 13119    */
// 13120 //  void inverse_kinematics(const float logical[XYZ]) {		//mks_delta

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock87 Using cfiCommon0
          CFI Function _Z31inverse_kinematics_MORGAN_SCARAPKf
        THUMB
// 13121   void inverse_kinematics_MORGAN_SCARA(const float logical[XYZ]) {
_Z31inverse_kinematics_MORGAN_SCARAPKf:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R6,R0
// 13122 
// 13123 
// 13124     static float C2, S2, SK1, SK2, THETA, PSI;
// 13125 
// 13126     float sx = RAW_X_POSITION(logical[X_AXIS]) - SCARA_OFFSET_X,  // Translate SCARA to standard X Y
        LDR.N    R7,??DataTable157
        LDR      R0,[R6, #+0]
        LDR      R1,[R7, #+68]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR.W    R1,??DataTable169_5  ;; 0xc2c80000
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[SP, #+0]
// 13127           sy = RAW_Y_POSITION(logical[Y_AXIS]) - SCARA_OFFSET_Y;  // With scaling factor.
        LDR      R0,[R6, #+4]
        LDR      R1,[R7, #+72]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR.W    R1,??DataTable169_6  ;; 0x42600000
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R5,R0
// 13128 
// 13129     if (L1 == L2)
// 13130       C2 = HYPOT2(sx, sy) / L1_2_2 - 1;
        LDR      R8,[SP, #+0]
        MOVS     R4,#+2
        MOV      R9,#+1065353216
        MOV      R10,R9
        B.N      ??inverse_kinematics_MORGAN_SCARA_0
??inverse_kinematics_MORGAN_SCARA_1:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??inverse_kinematics_MORGAN_SCARA_0:
        LSLS     R0,R4,#+31
        BPL.N    ??inverse_kinematics_MORGAN_SCARA_2
        MOV      R0,R10
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??inverse_kinematics_MORGAN_SCARA_2:
        LSRS     R4,R4,#+1
        BNE.N    ??inverse_kinematics_MORGAN_SCARA_1
        MOV      R8,R5
        MOVS     R4,#+2
        MOV      R11,R9
        B.N      ??inverse_kinematics_MORGAN_SCARA_3
??inverse_kinematics_MORGAN_SCARA_4:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??inverse_kinematics_MORGAN_SCARA_3:
        LSLS     R0,R4,#+31
        BPL.N    ??inverse_kinematics_MORGAN_SCARA_5
        MOV      R0,R11
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??inverse_kinematics_MORGAN_SCARA_5:
        LSRS     R4,R4,#+1
        BNE.N    ??inverse_kinematics_MORGAN_SCARA_4
        LDR.W    R8,??DataTable170
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR      R1,[R8, #+56]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        LDR.W    R1,??DataTable170_1  ;; 0xbf800000
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R10,R0
        STR      R10,[R8, #+64]
// 13131     else
// 13132       C2 = (HYPOT2(sx, sy) - (L1_2 + L2_2)) / (2.0 * L1 * L2);
// 13133 
// 13134     S2 = sqrt(sq(C2) - 1);
        MOVS     R4,#+2
        MOV      R11,R9
        MOV      R9,R0
        B.N      ??inverse_kinematics_MORGAN_SCARA_6
??inverse_kinematics_MORGAN_SCARA_7:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??inverse_kinematics_MORGAN_SCARA_6:
        LSLS     R0,R4,#+31
        BPL.N    ??inverse_kinematics_MORGAN_SCARA_8
        MOV      R0,R11
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??inverse_kinematics_MORGAN_SCARA_8:
        LSRS     R4,R4,#+1
        BNE.N    ??inverse_kinematics_MORGAN_SCARA_7
        LDR.W    R0,??DataTable170_1  ;; 0xbf800000
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R4,R0
        STR      R4,[R8, #+68]
// 13135 
// 13136     // Unrotated Arm1 plus rotated Arm2 gives the distance from Center to End
// 13137     SK1 = L1 + L2 * C2;
        LDR.W    R9,??DataTable171_1  ;; 0x43160000
        MOV      R0,R10
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R11,R0
        STR      R11,[R8, #+72]
// 13138 
// 13139     // Rotated Arm2 gives the distance from Arm1 to Arm2
// 13140     SK2 = L2 * S2;
        MOV      R0,R4
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        STR      R1,[R8, #+76]
// 13141 
// 13142     // Angle of Arm1 is the difference between Center-to-End angle and the Center-to-Elbow
// 13143     THETA = atan2(SK1, SK2) - atan2(sx, sy);
        MOV      R0,R11
          CFI FunCall atan2f
        BL       atan2f
        MOV      R9,R0
        MOV      R1,R5
        LDR      R0,[SP, #+0]
          CFI FunCall atan2f
        BL       atan2f
        MOV      R1,R0
        MOV      R0,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R8, #+80]
// 13144 
// 13145     // Angle of Arm2
// 13146     PSI = atan2(S2, C2);
        MOV      R1,R10
        MOV      R0,R4
          CFI FunCall atan2f
        BL       atan2f
        MOV      R9,R0
        STR      R9,[R8, #+84]
// 13147 
// 13148     delta[A_AXIS] = DEGREES(THETA);        // theta is support arm angle
        LDR      R8,[R8, #+80]
        MOVS     R4,#+0
        LDR.W    R5,??DataTable169_2  ;; 0x40668000
        MOV      R0,R8
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        LDR.W    R2,??DataTable166_1  ;; 0x54442d18
        LDR.W    R3,??DataTable169_1  ;; 0x400921fb
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R7, #+104]
// 13149     delta[B_AXIS] = DEGREES(THETA + PSI);  // equal to sub arm angle (inverted motor)
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        LDR.W    R2,??DataTable166_1  ;; 0x54442d18
        LDR.W    R3,??DataTable169_1  ;; 0x400921fb
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R7, #+108]
// 13150     delta[C_AXIS] = logical[Z_AXIS];
        LDR      R0,[R6, #+8]
        STR      R0,[R7, #+112]
// 13151 
// 13152     /*
// 13153       DEBUG_POS("SCARA IK", logical);
// 13154       DEBUG_POS("SCARA IK", delta);
// 13155       SERIAL_ECHOPAIR("  SCARA (x,y) ", sx);
// 13156       SERIAL_ECHOPAIR(",", sy);
// 13157       SERIAL_ECHOPAIR(" C2=", C2);
// 13158       SERIAL_ECHOPAIR(" S2=", S2);
// 13159       SERIAL_ECHOPAIR(" Theta=", THETA);
// 13160       SERIAL_ECHOLNPAIR(" Phi=", PHI);
// 13161     //*/
// 13162   }
        POP      {R0,R4-R11,PC}   ;; return
          CFI EndBlock cfiBlock87

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        DATA
home_dir_P:
        DS8 4
base_min_pos_P:
        DS8 12
base_max_pos_P:
        DS8 12
base_home_pos_P:
        DS8 12
max_length_P:
        DS8 12
        DS8 4
        DS8 4
        DS8 4
        DS8 4
        DS8 4
        DS8 4
        DS8 4
        DS8 4
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvE18serial_line_buffer
        DATA
_ZZ19get_serial_commandsvE18serial_line_buffer:
        DS8 96

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
        SECTION_GROUP _ZZ19get_serial_commandsvE19serial_comment_mode
        DATA
_ZZ19get_serial_commandsvE19serial_comment_mode:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvE14last_wait_time
        DATA
_ZZ19get_serial_commandsvE14last_wait_time:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
        SECTION_GROUP _ZZ19get_sdcard_commandsvE14stop_buffering
        DATA
_ZZ19get_sdcard_commandsvE14stop_buffering:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
        SECTION_GROUP _ZZ19get_sdcard_commandsvE15sd_comment_mode
        DATA
_ZZ19get_sdcard_commandsvE15sd_comment_mode:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ17get_wifi_commandsvE16wifi_line_buffer
        DATA
_ZZ17get_wifi_commandsvE16wifi_line_buffer:
        DS8 96

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
        SECTION_GROUP _ZZ17get_wifi_commandsvE17wifi_comment_mode
        DATA
_ZZ17get_wifi_commandsvE17wifi_comment_mode:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvE20enable_soft_endstops
        DATA
_ZZ27gcode_G29_MESH_BED_LEVELINGvE20enable_soft_endstops:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        DATA
`filament_change_beep(bool)::runout_beep`:
        DS8 2
        DS8 2
        DS8 4
// 13163 
// 13164 #endif // MORGAN_SCARA
// 13165 
// 13166 #if ENABLED(TEMP_STAT_LEDS)
// 13167 
// 13168   static bool red_led = false;
// 13169   static millis_t next_status_led_update_ms = 0;
// 13170 
// 13171   void handle_status_leds(void) {
// 13172     if (ELAPSED(millis(), next_status_led_update_ms)) {
// 13173       next_status_led_update_ms += 500; // Update every 0.5s
// 13174       float max_temp = 0.0;
// 13175       //#if HAS_TEMP_BED	/*--mks cfg-- HAS_TEMP_BED --*/
// 13176 		if(HAS_TEMP_BED)
// 13177 	  	max_temp = MAX3(max_temp, thermalManager.degTargetBed(), thermalManager.degBed());
// 13178       //#endif
// 13179       HOTEND_LOOP() {
// 13180         max_temp = MAX3(max_temp, thermalManager.degHotend(e), thermalManager.degTargetHotend(e));
// 13181       }
// 13182       bool new_led = (max_temp > 55.0) ? true : (max_temp < 54.0) ? false : red_led;
// 13183       if (new_led != red_led) {
// 13184         red_led = new_led;
// 13185         #if PIN_EXISTS(STAT_LED_RED)
// 13186           WRITE(STAT_LED_RED_PIN, new_led ? HIGH : LOW);
// 13187           #if PIN_EXISTS(STAT_LED_BLUE)
// 13188             WRITE(STAT_LED_BLUE_PIN, new_led ? LOW : HIGH);
// 13189           #endif
// 13190         #else
// 13191           WRITE(STAT_LED_BLUE_PIN, new_led ? HIGH : LOW);
// 13192         #endif
// 13193       }
// 13194     }
// 13195   }
// 13196 
// 13197 #endif
// 13198 
// 13199 #if ENABLED(FILAMENT_RUNOUT_SENSOR)
// 13200 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock88 Using cfiCommon0
          CFI Function _Z22handle_filament_runoutv
        THUMB
// 13201   void handle_filament_runout() {
_Z22handle_filament_runoutv:
        LDR.W    R1,??DataTable173
        LDRB     R0,[R1, #+13]
        CMP      R0,#+0
        BEQ.N    ??handle_filament_runout_0
        BX       LR
??handle_filament_runout_0:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 13202     if (!filament_ran_out) {
// 13203       filament_ran_out = true;
        MOVS     R0,#+1
        STRB     R0,[R1, #+13]
// 13204       enqueue_and_echo_commands_P(PSTR(FILAMENT_RUNOUT_SCRIPT));
        ADR.W    R0,?_43
          CFI FunCall _Z27enqueue_and_echo_commands_PPKc
        BL       _Z27enqueue_and_echo_commands_PPKc
// 13205       stepper.synchronize();
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Stepper11synchronizeEv
        B.W      _ZN7Stepper11synchronizeEv
// 13206     }
// 13207   }
          CFI EndBlock cfiBlock88

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable153:
        DC32     mksCfg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_43:
        DC8 "M600"
        DC8 0, 0, 0
// 13208 
// 13209 #endif // FILAMENT_RUNOUT_SENSOR
// 13210 
// 13211 #if ENABLED(FAST_PWM_FAN)
// 13212 
// 13213   void setPwmFrequency(uint8_t pin, int val) {
// 13214     val &= 0x07;
// 13215     switch (digitalPinToTimer(pin)) {
// 13216       #ifdef TCCR0A
// 13217         case TIMER0A:
// 13218         case TIMER0B:
// 13219           //_SET_CS(0, val);
// 13220           break;
// 13221       #endif
// 13222       #ifdef TCCR1A
// 13223         case TIMER1A:
// 13224         case TIMER1B:
// 13225           //_SET_CS(1, val);
// 13226           break;
// 13227       #endif
// 13228       #ifdef TCCR2
// 13229         case TIMER2:
// 13230         case TIMER2:
// 13231           _SET_CS(2, val);
// 13232           break;
// 13233       #endif
// 13234       #ifdef TCCR2A
// 13235         case TIMER2A:
// 13236         case TIMER2B:
// 13237           _SET_CS(2, val);
// 13238           break;
// 13239       #endif
// 13240       #ifdef TCCR3A
// 13241         case TIMER3A:
// 13242         case TIMER3B:
// 13243         case TIMER3C:
// 13244           _SET_CS(3, val);
// 13245           break;
// 13246       #endif
// 13247       #ifdef TCCR4A
// 13248         case TIMER4A:
// 13249         case TIMER4B:
// 13250         case TIMER4C:
// 13251           _SET_CS(4, val);
// 13252           break;
// 13253       #endif
// 13254       #ifdef TCCR5A
// 13255         case TIMER5A:
// 13256         case TIMER5B:
// 13257         case TIMER5C:
// 13258           _SET_CS(5, val);
// 13259           break;
// 13260       #endif
// 13261     }
// 13262   }
// 13263 
// 13264 #endif // FAST_PWM_FAN
// 13265 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock89 Using cfiCommon0
          CFI Function _Z31calculate_volumetric_multiplierf
        THUMB
// 13266 float calculate_volumetric_multiplier(float diameter) {
_Z31calculate_volumetric_multiplierf:
        PUSH     {R4,R6-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        MOV      R2,R0
// 13267   if (!volumetric_enabled || diameter == 0) return 1.0;
        LDR.W    R0,??DataTable172
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??calculate_volumetric_multiplier_0
        MOV      R0,R2
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??calculate_volumetric_multiplier_1
??calculate_volumetric_multiplier_0:
        MOV      R0,#+1065353216
        B.N      ??calculate_volumetric_multiplier_2
// 13268   return 1.0 / (M_PI * sq(diameter * 0.5));
??calculate_volumetric_multiplier_1:
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        LDR.W    R3,??DataTable166_6  ;; 0x3fe00000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R6,R0
        MOV      R7,R1
        MOVS     R4,#+2
        MOV      R8,#+0
        LDR.W    R9,??DataTable167  ;; 0x3ff00000
        B.N      ??calculate_volumetric_multiplier_3
??calculate_volumetric_multiplier_4:
        MOV      R0,R6
        MOV      R1,R7
        MOV      R2,R6
        MOV      R3,R7
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R6,R0
        MOV      R7,R1
??calculate_volumetric_multiplier_3:
        LSLS     R0,R4,#+31
        BPL.N    ??calculate_volumetric_multiplier_5
        MOV      R2,R6
        MOV      R3,R7
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R8,R0
        MOV      R9,R1
??calculate_volumetric_multiplier_5:
        LSRS     R4,R4,#+1
        BNE.N    ??calculate_volumetric_multiplier_4
        LDR.W    R0,??DataTable169_7  ;; 0x54442d18
        LDR.W    R1,??DataTable169_1  ;; 0x400921fb
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R0
        MOV      R3,R1
        MOVS     R0,#+0
        LDR.W    R1,??DataTable167  ;; 0x3ff00000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        POP      {R4,R6-R9,LR}
          CFI R4 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall __aeabi_d2f
        B.W      __aeabi_d2f
          CFI R4 Frame(CFA, -24)
          CFI R6 Frame(CFA, -20)
          CFI R7 Frame(CFA, -16)
          CFI R8 Frame(CFA, -12)
          CFI R9 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+24
??calculate_volumetric_multiplier_2:
        POP      {R4,R6-R9,PC}    ;; return
// 13269 }
          CFI EndBlock cfiBlock89
// 13270 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock90 Using cfiCommon0
          CFI Function _Z32calculate_volumetric_multipliersv
        THUMB
// 13271 void calculate_volumetric_multipliers() {
_Z32calculate_volumetric_multipliersv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 13272   for (uint8_t i = 0; i < COUNT(filament_size); i++)
        MOVS     R0,#+0
        LDR.W    R4,??DataTable172
        B.N      ??calculate_volumetric_multipliers_0
// 13273     volumetric_multiplier[i] = calculate_volumetric_multiplier(filament_size[i]);
??calculate_volumetric_multipliers_1:
        LDR      R0,[R4, #+4]
          CFI FunCall _Z31calculate_volumetric_multiplierf
        BL       _Z31calculate_volumetric_multiplierf
        STR      R0,[R4, #+8]
        MOVS     R0,#+1
??calculate_volumetric_multipliers_0:
        CMP      R0,#+0
        BEQ.N    ??calculate_volumetric_multipliers_1
// 13274 }
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock90
// 13275 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock91 Using cfiCommon0
          CFI Function _Z19enable_all_steppersv
        THUMB
// 13276 void enable_all_steppers() {
_Z19enable_all_steppersv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
// 13277   enable_X();
        LDR.W    R4,??DataTable173_1
        LDR.W    R5,??DataTable173_2
        MOVS     R2,#+0
        LDRH     R1,[R5, #+28]
        LDR      R0,[R4, #+56]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
// 13278   enable_Y();
        MOVS     R2,#+0
        LDRH     R1,[R5, #+28]
        LDR      R0,[R4, #+56]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
// 13279   enable_Z();
        MOVS     R2,#+0
        LDRH     R1,[R5, #+28]
        LDR      R0,[R4, #+56]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
// 13280   enable_E0();
        MOVS     R2,#+0
        LDRH     R1,[R5, #+60]
        LDR      R0,[R4, #+120]
        POP      {R3-R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall HAL_GPIO_WritePin
        B.W      HAL_GPIO_WritePin
// 13281   enable_E1();
// 13282   enable_E2();
// 13283   enable_E3();
// 13284   enable_E4();
// 13285 }
          CFI EndBlock cfiBlock91
// 13286 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock92 Using cfiCommon0
          CFI Function _Z18disable_e_steppersv
        THUMB
// 13287 void disable_e_steppers() {
// 13288   disable_E0();
_Z18disable_e_steppersv:
        MOVS     R2,#+1
        LDR.W    R0,??DataTable173_2
        LDRH     R1,[R0, #+60]
        LDR.W    R0,??DataTable173_1
        LDR      R0,[R0, #+120]
          CFI FunCall HAL_GPIO_WritePin
        B.W      HAL_GPIO_WritePin
// 13289   disable_E1();
// 13290   disable_E2();
// 13291   disable_E3();
// 13292   disable_E4();
// 13293 }
          CFI EndBlock cfiBlock92

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable157:
        DC32     mks_heating_busy
// 13294 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock93 Using cfiCommon0
          CFI Function _Z20disable_all_steppersv
        THUMB
// 13295 void disable_all_steppers() {
_Z20disable_all_steppersv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
// 13296   disable_X();
        LDR.W    R4,??DataTable173_1
        LDR.W    R5,??DataTable173_2
        MOVS     R2,#+1
        LDRH     R1,[R5, #+28]
        LDR      R0,[R4, #+56]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        LDR.W    R6,??DataTable174
        MOVS     R0,#+0
        STRB     R0,[R6, #+4]
// 13297   disable_Y();
        MOVS     R2,#+1
        LDRH     R1,[R5, #+28]
        LDR      R0,[R4, #+56]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        STRB     R0,[R6, #+5]
// 13298   disable_Z();
        MOVS     R2,#+1
        LDRH     R1,[R5, #+28]
        LDR      R0,[R4, #+56]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        STRB     R0,[R6, #+6]
// 13299   disable_e_steppers();
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z18disable_e_steppersv
        B.N      _Z18disable_e_steppersv
// 13300 }
          CFI EndBlock cfiBlock93

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable158:
        DC32     _ZN17mesh_bed_leveling13index_to_xposE
// 13301 
// 13302 #if ENABLED(HAVE_TMC2130)
// 13303 
// 13304   void automatic_current_control(TMC2130Stepper &st, String axisID) {
// 13305     // Check otpw even if we don't use automatic control. Allows for flag inspection.
// 13306     const bool is_otpw = st.checkOT();
// 13307 
// 13308     // Report if a warning was triggered
// 13309     static bool previous_otpw = false;
// 13310     if (is_otpw && !previous_otpw) {
// 13311       char timestamp[10];
// 13312       duration_t elapsed = print_job_timer.duration();
// 13313       const bool has_days = (elapsed.value > 60*60*24L);
// 13314       (void)elapsed.toDigital(timestamp, has_days);
// 13315       SERIAL_ECHO(timestamp);
// 13316       SERIAL_ECHO(": ");
// 13317       SERIAL_ECHO(axisID);
// 13318       SERIAL_ECHOLNPGM(" driver overtemperature warning!");
// 13319     }
// 13320     previous_otpw = is_otpw;
// 13321 
// 13322     #if CURRENT_STEP > 0 && ENABLED(AUTOMATIC_CURRENT_CONTROL)
// 13323       // Return if user has not enabled current control start with M906 S1.
// 13324       if (!auto_current_control) return;
// 13325 
// 13326       /**
// 13327        * Decrease current if is_otpw is true.
// 13328        * Bail out if driver is disabled.
// 13329        * Increase current if OTPW has not been triggered yet.
// 13330        */
// 13331       uint16_t current = st.getCurrent();
// 13332       if (is_otpw) {
// 13333         st.setCurrent(current - CURRENT_STEP, R_SENSE, HOLD_MULTIPLIER);
// 13334         #if ENABLED(REPORT_CURRENT_CHANGE)
// 13335           SERIAL_ECHO(axisID);
// 13336           SERIAL_ECHOPAIR(" current decreased to ", st.getCurrent());
// 13337         #endif
// 13338       }
// 13339 
// 13340       else if (!st.isEnabled())
// 13341         return;
// 13342 
// 13343       else if (!is_otpw && !st.getOTPW()) {
// 13344         current += CURRENT_STEP;
// 13345         if (current <= AUTO_ADJUST_MAX) {
// 13346           st.setCurrent(current, R_SENSE, HOLD_MULTIPLIER);
// 13347           #if ENABLED(REPORT_CURRENT_CHANGE)
// 13348             SERIAL_ECHO(axisID);
// 13349             SERIAL_ECHOPAIR(" current increased to ", st.getCurrent());
// 13350           #endif
// 13351         }
// 13352       }
// 13353       SERIAL_EOL;
// 13354     #endif
// 13355   }
// 13356 
// 13357   void checkOverTemp() {
// 13358     static millis_t next_cOT = 0;
// 13359     if (ELAPSED(millis(), next_cOT)) {
// 13360       next_cOT = millis() + 5000;
// 13361       #if ENABLED(X_IS_TMC2130)
// 13362         automatic_current_control(stepperX, "X");
// 13363       #endif
// 13364       #if ENABLED(Y_IS_TMC2130)
// 13365         automatic_current_control(stepperY, "Y");
// 13366       #endif
// 13367       #if ENABLED(Z_IS_TMC2130)
// 13368         automatic_current_control(stepperZ, "Z");
// 13369       #endif
// 13370       #if ENABLED(X2_IS_TMC2130)
// 13371         automatic_current_control(stepperX2, "X2");
// 13372       #endif
// 13373       #if ENABLED(Y2_IS_TMC2130)
// 13374         automatic_current_control(stepperY2, "Y2");
// 13375       #endif
// 13376       #if ENABLED(Z2_IS_TMC2130)
// 13377         automatic_current_control(stepperZ2, "Z2");
// 13378       #endif
// 13379       #if ENABLED(E0_IS_TMC2130)
// 13380         automatic_current_control(stepperE0, "E0");
// 13381       #endif
// 13382       #if ENABLED(E1_IS_TMC2130)
// 13383         automatic_current_control(stepperE1, "E1");
// 13384       #endif
// 13385       #if ENABLED(E2_IS_TMC2130)
// 13386         automatic_current_control(stepperE2, "E2");
// 13387       #endif
// 13388       #if ENABLED(E3_IS_TMC2130)
// 13389         automatic_current_control(stepperE3, "E3");
// 13390       #endif
// 13391       #if ENABLED(E4_IS_TMC2130)
// 13392         automatic_current_control(stepperE4, "E4");
// 13393       #endif
// 13394       #if ENABLED(E4_IS_TMC2130)
// 13395         automatic_current_control(stepperE4);
// 13396       #endif
// 13397     }
// 13398   }
// 13399 
// 13400 #endif // HAVE_TMC2130
// 13401 
// 13402 /**
// 13403  * Manage several activities:
// 13404  *  - Check for Filament Runout
// 13405  *  - Keep the command buffer full
// 13406  *  - Check for maximum inactive time between commands
// 13407  *  - Check for maximum inactive time between stepper commands
// 13408  *  - Check if pin CHDK needs to go LOW
// 13409  *  - Check for KILL button held down
// 13410  *  - Check for HOME button held down
// 13411  *  - Check if cooling fan needs to be switched on
// 13412  *  - Check if an idle but hot extruder needs filament extruded (EXTRUDER_RUNOUT_PREVENT)
// 13413  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock94 Using cfiCommon0
          CFI Function _Z17manage_inactivityb
        THUMB
// 13414 void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
_Z17manage_inactivityb:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R4,R0
// 13415 
// 13416   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
// 13417     if ((IS_SD_PRINTING || print_job_timer.isRunning()) && (READ(FIL_RUNOUT_PIN) == FIL_RUNOUT_INVERTING))
        LDR.W    R0,??DataTable173_3
        LDRB     R0,[R0, #+2]
        CMP      R0,#+0
        BNE.N    ??manage_inactivity_0
        LDR.W    R0,??DataTable173_4
          CFI FunCall _ZN9Stopwatch9isRunningEv
        BL       _ZN9Stopwatch9isRunningEv
        CMP      R0,#+0
        BEQ.N    ??manage_inactivity_1
??manage_inactivity_0:
        LDR.W    R0,??DataTable175
        LDRH     R1,[R0, #+38]
        LDR.W    R0,??DataTable174_1
        LDR      R0,[R0, #+76]
          CFI FunCall HAL_GPIO_ReadPin
        BL       HAL_GPIO_ReadPin
        LDR.W    R1,??DataTable174_2
        LDRB     R1,[R1, #+208]
        CMP      R0,R1
        BNE.N    ??manage_inactivity_1
// 13418       handle_filament_runout();
          CFI FunCall _Z22handle_filament_runoutv
        BL       _Z22handle_filament_runoutv
// 13419   #endif
// 13420 
// 13421   if (commands_in_queue < BUFSIZE) get_available_commands();
??manage_inactivity_1:
        LDR.W    R5,??DataTable173
        LDRB     R0,[R5, #+8]
        CMP      R0,#+4
        BGE.N    ??manage_inactivity_2
          CFI FunCall _Z22get_available_commandsv
        BL       _Z22get_available_commandsv
// 13422 
// 13423   const millis_t ms = millis();
??manage_inactivity_2:
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        MOV      R6,R0
// 13424 
// 13425   if (max_inactive_time && ELAPSED(ms, previous_cmd_ms + max_inactive_time)) {
        LDR      R0,[R5, #+60]
        CMP      R0,#+0
        BEQ.N    ??manage_inactivity_3
        LDR      R1,[R5, #+56]
        SUBS     R1,R6,R1
        SUBS     R0,R1,R0
        BMI.N    ??manage_inactivity_3
// 13426     SERIAL_ERROR_START;
        LDR.W    R0,??DataTable175_1
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 13427     SERIAL_ECHOLNPAIR(MSG_KILL_INACTIVE_TIME, current_command);
        LDR      R1,[R5, #+36]
        ADR.W    R0,?_44
          CFI FunCall _Z17serial_echopair_PPKcS0_
        BL       _Z17serial_echopair_PPKcS0_
        LDR.W    R0,??DataTable174_3
        LDRB     R0,[R0, #+7]
        CMP      R0,#+0
        BNE.N    ??manage_inactivity_4
        MOVS     R1,#+10
        LDR.W    R0,??DataTable174_4
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??manage_inactivity_5
??manage_inactivity_4:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.W    R0,??DataTable174_5
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
// 13428     kill(PSTR(MSG_KILLED));
??manage_inactivity_5:
        ADR.W    R0,?_45
          CFI FunCall _Z4killPKc
        BL       _Z4killPKc
// 13429   }
// 13430 
// 13431   // Prevent steppers timing-out in the middle of M600
// 13432   #if ENABLED(FILAMENT_CHANGE_FEATURE) && ENABLED(FILAMENT_CHANGE_NO_STEPPER_TIMEOUT)
// 13433     #define M600_TEST !busy_doing_M600
// 13434   #else
// 13435     #define M600_TEST true
// 13436   #endif
// 13437 
// 13438   if (M600_TEST && stepper_inactive_time && ELAPSED(ms, previous_cmd_ms + stepper_inactive_time)
// 13439       && !ignore_stepper_queue && !planner.blocks_queued()) {
??manage_inactivity_3:
        LDRB     R0,[R5, #+15]
        CMP      R0,#+0
        BNE.N    ??manage_inactivity_6
        LDR      R0,[R5, #+64]
        CMP      R0,#+0
        BEQ.N    ??manage_inactivity_6
        LDR      R1,[R5, #+56]
        SUBS     R6,R6,R1
        SUBS     R6,R6,R0
        BMI.N    ??manage_inactivity_6
        CMP      R4,#+0
        BNE.N    ??manage_inactivity_6
          CFI FunCall _ZN7Planner13blocks_queuedEv
        BL       _ZN7Planner13blocks_queuedEv
        CMP      R0,#+0
        BNE.N    ??manage_inactivity_6
// 13440     #if ENABLED(DISABLE_INACTIVE_X)
// 13441       disable_X();
        LDR.W    R4,??DataTable174_1
        LDR.W    R6,??DataTable175
        MOVS     R2,#+1
        LDRH     R1,[R6, #+0]
        LDR      R0,[R4, #+0]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        STRB     R0,[R5, #+4]
// 13442     #endif
// 13443     #if ENABLED(DISABLE_INACTIVE_Y)
// 13444       disable_Y();
        MOVS     R2,#+1
        LDRH     R1,[R6, #+0]
        LDR      R0,[R4, #+0]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        STRB     R0,[R5, #+5]
// 13445     #endif
// 13446     #if ENABLED(DISABLE_INACTIVE_Z)
// 13447       disable_Z();
        MOVS     R2,#+1
        LDRH     R1,[R6, #+0]
        LDR      R0,[R4, #+0]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        STRB     R0,[R5, #+6]
// 13448     #endif
// 13449     #if ENABLED(DISABLE_INACTIVE_E)
// 13450       disable_e_steppers();
          CFI FunCall _Z18disable_e_steppersv
        BL       _Z18disable_e_steppersv
// 13451     #endif
// 13452   }
// 13453 
// 13454   #ifdef CHDK // Check if pin should be set to LOW after M240 set it to HIGH
// 13455     if (chdkActive && ELAPSED(ms, chdkHigh + CHDK_DELAY)) {
// 13456       chdkActive = false;
// 13457       WRITE(CHDK, LOW);
// 13458     }
// 13459   #endif
// 13460 
// 13461   #if HAS_KILL
// 13462 
// 13463     // Check if the kill button was pressed and wait just in case it was an accidental
// 13464     // key kill key press
// 13465     // -------------------------------------------------------------------------------
// 13466     static int killCount = 0;   // make the inactivity button a bit less responsive
// 13467     const int KILL_DELAY = 750;
// 13468     if (!READ(KILL_PIN))
// 13469       killCount++;
// 13470     else if (killCount > 0)
// 13471       killCount--;
// 13472 
// 13473     // Exceeded threshold and we can confirm that it was not accidental
// 13474     // KILL the machine
// 13475     // ----------------------------------------------------------------
// 13476     if (killCount >= KILL_DELAY) {
// 13477       SERIAL_ERROR_START;
// 13478       SERIAL_ERRORLNPGM(MSG_KILL_BUTTON);
// 13479       kill(PSTR(MSG_KILLED));
// 13480     }
// 13481   #endif
// 13482 
// 13483   #if HAS_HOME
// 13484     // Check to see if we have to home, use poor man's debouncer
// 13485     // ---------------------------------------------------------
// 13486     static int homeDebounceCount = 0;   // poor man's debouncing count
// 13487     const int HOME_DEBOUNCE_DELAY = 2500;
// 13488     if (!IS_SD_PRINTING && !READ(HOME_PIN)) {
// 13489       if (!homeDebounceCount) {
// 13490         enqueue_and_echo_commands_P(PSTR("G28"));
// 13491         LCD_MESSAGEPGM(MSG_AUTO_HOME);
// 13492       }
// 13493       if (homeDebounceCount < HOME_DEBOUNCE_DELAY)
// 13494         homeDebounceCount++;
// 13495       else
// 13496         homeDebounceCount = 0;
// 13497     }
// 13498   #endif
// 13499 
// 13500 #if ENABLED(USE_CONTROLLER_FAN)
// 13501     controllerFan(); // Check if fan should be turned on to cool stepper drivers down
// 13502   #endif
// 13503 
// 13504   #if ENABLED(EXTRUDER_RUNOUT_PREVENT)
// 13505     if (ELAPSED(ms, previous_cmd_ms + (EXTRUDER_RUNOUT_SECONDS) * 1000UL)
// 13506       && thermalManager.degHotend(active_extruder) > EXTRUDER_RUNOUT_MINTEMP) {
// 13507       bool oldstatus;
// 13508       #if ENABLED(SWITCHING_EXTRUDER)
// 13509         oldstatus = E0_ENABLE_READ;
// 13510         enable_E0();
// 13511       #else // !SWITCHING_EXTRUDER
// 13512         switch (active_extruder) {
// 13513           case 0: oldstatus = E0_ENABLE_READ; enable_E0(); break;
// 13514           #if E_STEPPERS > 1
// 13515             case 1: oldstatus = E1_ENABLE_READ; enable_E1(); break;
// 13516             #if E_STEPPERS > 2
// 13517               case 2: oldstatus = E2_ENABLE_READ; enable_E2(); break;
// 13518               #if E_STEPPERS > 3
// 13519                 case 3: oldstatus = E3_ENABLE_READ; enable_E3(); break;
// 13520                 #if E_STEPPERS > 4
// 13521                   case 4: oldstatus = E4_ENABLE_READ; enable_E4(); break;
// 13522                 #endif // E_STEPPERS > 4
// 13523               #endif // E_STEPPERS > 3
// 13524             #endif // E_STEPPERS > 2
// 13525           #endif // E_STEPPERS > 1
// 13526         }
// 13527       #endif // !SWITCHING_EXTRUDER
// 13528 
// 13529       previous_cmd_ms = ms; // refresh_cmd_timeout()
// 13530 
// 13531       const float olde = current_position[E_AXIS];
// 13532       current_position[E_AXIS] += EXTRUDER_RUNOUT_EXTRUDE;
// 13533       planner.buffer_line_kinematic(current_position, MMM_TO_MMS(EXTRUDER_RUNOUT_SPEED), active_extruder);
// 13534       current_position[E_AXIS] = olde;
// 13535       planner.set_e_position_mm(olde);
// 13536       stepper.synchronize();
// 13537       #if ENABLED(SWITCHING_EXTRUDER)
// 13538         E0_ENABLE_WRITE(oldstatus);
// 13539       #else
// 13540         switch (active_extruder) {
// 13541           case 0: E0_ENABLE_WRITE(oldstatus); break;
// 13542           #if E_STEPPERS > 1
// 13543             case 1: E1_ENABLE_WRITE(oldstatus); break;
// 13544             #if E_STEPPERS > 2
// 13545               case 2: E2_ENABLE_WRITE(oldstatus); break;
// 13546               #if E_STEPPERS > 3
// 13547                 case 3: E3_ENABLE_WRITE(oldstatus); break;
// 13548                 #if E_STEPPERS > 4
// 13549                   case 4: E4_ENABLE_WRITE(oldstatus); break;
// 13550                 #endif // E_STEPPERS > 4
// 13551               #endif // E_STEPPERS > 3
// 13552             #endif // E_STEPPERS > 2
// 13553           #endif // E_STEPPERS > 1
// 13554         }
// 13555       #endif // !SWITCHING_EXTRUDER
// 13556     }
// 13557   #endif // EXTRUDER_RUNOUT_PREVENT
// 13558 
// 13559   #if ENABLED(DUAL_X_CARRIAGE)
// 13560     // handle delayed move timeout
// 13561     if (delayed_move_time && ELAPSED(ms, delayed_move_time + 1000UL) && IsRunning()) {
// 13562       // travel moves have been received so enact them
// 13563       delayed_move_time = 0xFFFFFFFFUL; // force moves to be done
// 13564       set_destination_to_current();
// 13565       prepare_move_to_destination();
// 13566     }
// 13567   #endif
// 13568 
// 13569   #if ENABLED(TEMP_STAT_LEDS)
// 13570     handle_status_leds();
// 13571   #endif
// 13572 
// 13573   #if ENABLED(HAVE_TMC2130)
// 13574     checkOverTemp();
// 13575   #endif
// 13576 
// 13577   planner.check_axes_activity();
??manage_inactivity_6:
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Planner19check_axes_activityEv
        B.W      _ZN7Planner19check_axes_activityEv
// 13578 }
          CFI EndBlock cfiBlock94

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_44:
        DC8 4BH, 49H, 4CH, 4CH, 20H, 63H, 61H, 75H
        DC8 73H, 65H, 64H, 20H, 62H, 79H, 20H, 74H
        DC8 6FH, 6FH, 20H, 6DH, 75H, 63H, 68H, 20H
        DC8 69H, 6EH, 61H, 63H, 74H, 69H, 76H, 65H
        DC8 20H, 74H, 69H, 6DH, 65H, 20H, 2DH, 20H
        DC8 63H, 75H, 72H, 72H, 65H, 6EH, 74H, 20H
        DC8 63H, 6FH, 6DH, 6DH, 61H, 6EH, 64H, 3AH
        DC8 20H, 0
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_45:
        DC8 "KILLED. "
        DC8 0, 0, 0
// 13579 
// 13580 /**
// 13581  * Standard idle routine keeps the machine alive
// 13582  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock95 Using cfiCommon0
          CFI Function _Z4idleb
        THUMB
// 13583 void idle(
// 13584   #if ENABLED(FILAMENT_CHANGE_FEATURE)
// 13585     bool no_stepper_sleep/*=false*/
// 13586   #endif
// 13587 ) {
_Z4idleb:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
// 13588   lcd_update();
          CFI FunCall _Z10lcd_updatev
        BL       _Z10lcd_updatev
// 13589 //#if MASK_FOR_SPACE
// 13590   host_keepalive();
          CFI FunCall _Z14host_keepalivev
        BL       _Z14host_keepalivev
// 13591 
// 13592   //#if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)	/*--mks cfg-- HAS_TEMP_BED --*/
// 13593   #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND)	
// 13594   auto_report_temperatures();
// 13595   #endif
// 13596 
// 13597 
// 13598   manage_inactivity(
// 13599     #if ENABLED(FILAMENT_CHANGE_FEATURE)
// 13600       no_stepper_sleep
// 13601     #endif
// 13602   );
        MOV      R0,R4
          CFI FunCall _Z17manage_inactivityb
        BL       _Z17manage_inactivityb
// 13603 
// 13604 
// 13605   thermalManager.manage_heater();
          CFI FunCall _ZN11Temperature13manage_heaterEv
        BL       _ZN11Temperature13manage_heaterEv
// 13606  // #endif
// 13607 
// 13608 
// 13609   #if ENABLED(PRINTCOUNTER)
// 13610     print_job_timer.tick();
// 13611   #endif
// 13612 
// 13613   #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
// 13614     buzzer.tick();
        LDR.W    R0,??DataTable178
          CFI FunCall _ZN6Buzzer4tickEv
        BL       _ZN6Buzzer4tickEv
// 13615   #endif
// 13616 
// 13617 #ifdef USE_MKS_WIFI  
// 13618   	wifi_looping();
          CFI FunCall wifi_looping
        BL       wifi_looping
// 13619 #endif
// 13620   
// 13621    BlinkLed();
          CFI FunCall _Z8BlinkLedv
        BL       _Z8BlinkLedv
// 13622    GoHomeCheck();
          CFI FunCall _Z11GoHomeCheckv
        BL       _Z11GoHomeCheckv
// 13623    PrintOneKey();
          CFI FunCall _Z11PrintOneKeyv
        BL       _Z11PrintOneKeyv
// 13624    LoadFilament();
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z12LoadFilamentv
        B.W      _Z12LoadFilamentv
// 13625 }
          CFI EndBlock cfiBlock95

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable160:
        DC32     Running
// 13626 
// 13627 /**
// 13628  * Kill all activity and lock the machine.
// 13629  * After this the machine will need to be reset.
// 13630  */
// 13631 extern "C" void kill_c(const char* lcd_msg);

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock96 Using cfiCommon0
          CFI Function kill_c
        THUMB
// 13632 void kill_c(const char* lcd_msg) {
kill_c:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
// 13633   SERIAL_ERROR_START;
        LDR.W    R0,??DataTable175_1
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 13634   SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
        ADR.W    R0,?_46
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 13635 
// 13636   thermalManager.disable_all_heaters();
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
// 13637   disable_all_steppers();
          CFI FunCall _Z20disable_all_steppersv
        BL       _Z20disable_all_steppersv
// 13638 
// 13639   #if ENABLED(ULTRA_LCD)
// 13640     kill_screen(lcd_msg);
        MOV      R0,R4
          CFI FunCall _Z11kill_screenPKc
        BL       _Z11kill_screenPKc
// 13641   #else
// 13642     UNUSED(lcd_msg);
// 13643   #endif
// 13644 
// 13645   _delay_ms(600); // Wait a short time (allows messages to get out before shutting down.
        MOV      R0,#+600
          CFI FunCall HAL_Delay
        BL       HAL_Delay
// 13646   cli(); // Stop interrupts
        cpsid i
// 13647 
// 13648   _delay_ms(250); //Wait to ensure all interrupts routines stopped
        MOVS     R0,#+250
          CFI FunCall HAL_Delay
        BL       HAL_Delay
// 13649   thermalManager.disable_all_heaters(); //turn off heaters again
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
// 13650 
// 13651   #if HAS_POWER_SWITCH
// 13652     SET_INPUT(PS_ON_PIN);
// 13653   #endif
// 13654 
// 13655   suicide();
          CFI FunCall _Z7suicidev
        BL       _Z7suicidev
// 13656   while (1) {
??kill_c_0:
        B.N      ??kill_c_0
// 13657     #if ENABLED(USE_WATCHDOG)
// 13658       watchdog_reset();
// 13659     #endif
// 13660   } // Wait for reset
// 13661 }
          CFI EndBlock cfiBlock96
// 13662 
// 13663 
// 13664 
// 13665 

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock97 Using cfiCommon0
          CFI Function _Z4killPKc
        THUMB
// 13666 void kill(const char* lcd_msg) {
_Z4killPKc:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
// 13667   SERIAL_ERROR_START;
        LDR.W    R0,??DataTable175_1
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 13668   SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
        ADR.W    R0,?_46
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 13669 
// 13670   thermalManager.disable_all_heaters();
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
// 13671   disable_all_steppers();
          CFI FunCall _Z20disable_all_steppersv
        BL       _Z20disable_all_steppersv
// 13672 
// 13673   #if ENABLED(ULTRA_LCD)
// 13674     kill_screen(lcd_msg);
        MOV      R0,R4
          CFI FunCall _Z11kill_screenPKc
        BL       _Z11kill_screenPKc
// 13675   #else
// 13676     UNUSED(lcd_msg);
// 13677   #endif
// 13678 
// 13679   _delay_ms(600); // Wait a short time (allows messages to get out before shutting down.
        MOV      R0,#+600
          CFI FunCall HAL_Delay
        BL       HAL_Delay
// 13680   cli(); // Stop interrupts
        cpsid i
// 13681 
// 13682   _delay_ms(250); //Wait to ensure all interrupts routines stopped
        MOVS     R0,#+250
          CFI FunCall HAL_Delay
        BL       HAL_Delay
// 13683   thermalManager.disable_all_heaters(); //turn off heaters again
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
// 13684 
// 13685   #if HAS_POWER_SWITCH
// 13686     SET_INPUT(PS_ON_PIN);
// 13687   #endif
// 13688 
// 13689   suicide();
          CFI FunCall _Z7suicidev
        BL       _Z7suicidev
// 13690   while (1) {
??kill_0:
        B.N      ??kill_0
// 13691     #if ENABLED(USE_WATCHDOG)
// 13692       watchdog_reset();
// 13693     #endif
// 13694   } // Wait for reset
// 13695 }
          CFI EndBlock cfiBlock97

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_46:
        DC8 "Printer halted. kill() called!\012"
// 13696 
// 13697 /**
// 13698  * Turn off heaters and stop the print in progress
// 13699  * After a stop the machine may be resumed with M999
// 13700  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock98 Using cfiCommon0
          CFI Function _Z4stopv
        THUMB
// 13701 void stop() {
_Z4stopv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 13702 	thermalManager.disable_all_heaters(); // 'unpause' taken care of in here
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
// 13703 	
// 13704 #if ENABLED(PROBING_FANS_OFF)
// 13705 	  if (fans_paused) fans_pause(false); // put things back the way they were
// 13706 #endif
// 13707   if (IsRunning()) {
          CFI FunCall _Z9IsRunningv
        BL       _Z9IsRunningv
        CMP      R0,#+0
        BEQ.N    ??stop_0
// 13708     Stopped_gcode_LastN = gcode_LastN; // Save last g_code for restart
        LDR.W    R4,??DataTable177
        LDR.W    R0,??DataTable173
        LDR      R0,[R0, #+32]
        STR      R0,[R4, #+32]
// 13709     SERIAL_ERROR_START;
        LDR.W    R0,??DataTable178_1
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 13710     SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
        ADR.W    R0,?_47
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 13711     LCD_MESSAGEPGM(MSG_STOPPED);
        MOVS     R1,#+0
        ADR.W    R0,?_48
          CFI FunCall _Z16lcd_setstatuspgmPKch
        BL       _Z16lcd_setstatuspgmPKch
// 13712     safe_delay(350);       // allow enough time for messages to get out before stopping
        MOV      R0,#+350
          CFI FunCall _Z10safe_delaym
        BL       _Z10safe_delaym
// 13713     Running = false;
        MOVS     R0,#+0
        STRB     R0,[R4, #+0]
// 13714   }
// 13715 }
??stop_0:
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock98

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable163:
        DC32     _ZN17mesh_bed_leveling13index_to_yposE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable163_1:
        DC32     mksCfg+0x60

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable163_2:
        DC32     echomagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_47:
        DC8 50H, 72H, 69H, 6EH, 74H, 65H, 72H, 20H
        DC8 73H, 74H, 6FH, 70H, 70H, 65H, 64H, 20H
        DC8 64H, 75H, 65H, 20H, 74H, 6FH, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 73H, 2EH, 20H, 46H
        DC8 69H, 78H, 20H, 74H, 68H, 65H, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 20H, 61H, 6EH, 64H
        DC8 20H, 75H, 73H, 65H, 20H, 4DH, 39H, 39H
        DC8 39H, 20H, 74H, 6FH, 20H, 72H, 65H, 73H
        DC8 74H, 61H, 72H, 74H, 2EH, 20H, 28H, 54H
        DC8 65H, 6DH, 70H, 65H, 72H, 61H, 74H, 75H
        DC8 72H, 65H, 20H, 69H, 73H, 20H, 72H, 65H
        DC8 73H, 65H, 74H, 2EH, 20H, 53H, 65H, 74H
        DC8 20H, 69H, 74H, 20H, 61H, 66H, 74H, 65H
        DC8 72H, 20H, 72H, 65H, 73H, 74H, 61H, 72H
        DC8 74H, 69H, 6EH, 67H, 29H, 0AH, 0
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_48:
        DC8 "STOPPED. "
        DC8 0, 0
// 13716 
// 13717 /**
// 13718  * Marlin entry-point: Set up before the program loop
// 13719  *  - Set up the kill pin, filament runout, power hold
// 13720  *  - Start the serial port
// 13721  *  - Print startup messages and diagnostics
// 13722  *  - Get EEPROM or default settings
// 13723  *  - Initialize managers for:
// 13724  *    â?temperature
// 13725  *    â?planner
// 13726  *    â?watchdog
// 13727  *    â?stepper
// 13728  *    â?photo pin
// 13729  *    â?servos
// 13730  *    â?LCD controller
// 13731  *    â?Digipot I2C
// 13732  *    â?Z probe sled
// 13733  *    â?status LEDs
// 13734  */
// 13735 /*--mks--*/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock99 Using cfiCommon0
          CFI Function setup
        THUMB
// 13736 void setup() {
setup:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
// 13737 /*	
// 13738   #ifdef DISABLE_JTAG
// 13739     // Disable JTAG on AT90USB chips to free up pins for IO
// 13740     MCUCR = 0x80;
// 13741     MCUCR = 0x80;
// 13742   #endif
// 13743 */
// 13744   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
// 13745     setup_filrunoutpin();
          CFI FunCall _Z18setup_filrunoutpinv
        BL       _Z18setup_filrunoutpinv
// 13746   #endif
// 13747 
// 13748   setup_killpin();
          CFI FunCall _Z13setup_killpinv
        BL       _Z13setup_killpinv
// 13749 
// 13750   //setup_powerhold();	/*--mks--*/
// 13751 
// 13752   #if HAS_STEPPER_RESET
// 13753     disableStepperDrivers();
// 13754   #endif
// 13755 
// 13756   //MYSERIAL.begin(BAUDRATE);	/*--mks--*/
// 13757 //  SERIAL_PROTOCOLLNPGM("start");
// 13758 //  SERIAL_ECHO_START;
// 13759 
// 13760   // Check startup - does nothing if bootloader sets MCUSR to 0
// 13761   byte mcu = MCUSR;
// 13762   if (mcu & 1) SERIAL_ECHOLNPGM(MSG_POWERUP);
// 13763   if (mcu & 2) SERIAL_ECHOLNPGM(MSG_EXTERNAL_RESET);
// 13764   if (mcu & 4) SERIAL_ECHOLNPGM(MSG_BROWNOUT_RESET);
// 13765   if (mcu & 8) SERIAL_ECHOLNPGM(MSG_WATCHDOG_RESET);
// 13766   if (mcu & 32) SERIAL_ECHOLNPGM(MSG_SOFTWARE_RESET);
// 13767   //MCUSR = 0; /*--mks--*/
// 13768 
// 13769   SERIAL_ECHOPGM(MSG_MARLIN);
        ADR.W    R0,?_49
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 13770   SERIAL_CHAR(' ');
        LDR.W    R4,??DataTable174_3
        LDRB     R0,[R4, #+7]
        CMP      R0,#+0
        BNE.N    ??setup_0
        MOVS     R1,#+32
        LDR.W    R0,??DataTable174_4
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??setup_1
??setup_0:
        MOVS     R2,#+0
        MOVS     R1,#+32
        LDR.W    R0,??DataTable174_5
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
// 13771   SERIAL_ECHOLNPGM(SHORT_BUILD_VERSION);
??setup_1:
        ADR.N    R0,??DataTable166  ;; 0x20, 0x0A, 0x00, 0x00
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 13772   SERIAL_EOL;
        LDRB     R0,[R4, #+7]
        CMP      R0,#+0
        BNE.N    ??setup_2
        MOVS     R1,#+10
        LDR.W    R0,??DataTable174_4
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??setup_3
??setup_2:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.W    R0,??DataTable174_5
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
// 13773 
// 13774   #if defined(STRING_DISTRIBUTION_DATE) && defined(STRING_CONFIG_H_AUTHOR)
// 13775     SERIAL_ECHO_START;
??setup_3:
        LDR.W    R5,??DataTable179
        MOV      R0,R5
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 13776     SERIAL_ECHOPGM(MSG_CONFIGURATION_VER);
        ADR.W    R0,?_51
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 13777     SERIAL_ECHOPGM(STRING_DISTRIBUTION_DATE);
        ADR.W    R0,?_52
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 13778     SERIAL_ECHOLNPGM(MSG_AUTHOR STRING_CONFIG_H_AUTHOR);
        ADR.W    R0,?_53
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 13779     SERIAL_ECHOLNPGM("Compiled: " __DATE__);
        ADR.W    R0,?_54
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 13780   #endif
// 13781 
// 13782   SERIAL_ECHO_START;
        MOV      R0,R5
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 13783   SERIAL_ECHOPAIR(MSG_FREE_MEMORY, freeMemory());
          CFI FunCall _Z10freeMemoryv
        BL       _Z10freeMemoryv
        MOV      R1,R0
        ADR.W    R0,?_55
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
// 13784   SERIAL_ECHOLNPAIR(MSG_PLANNER_BUFFER_BYTES, (int)sizeof(block_t)*BLOCK_BUFFER_SIZE);
        MOV      R1,#+1344
        ADR.W    R0,?_56
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        LDRB     R0,[R4, #+7]
        CMP      R0,#+0
        BNE.N    ??setup_4
        MOVS     R1,#+10
        LDR.W    R0,??DataTable174_4
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??setup_5
??setup_4:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.W    R0,??DataTable174_5
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
// 13785 
// 13786   // Send "ok" after commands by default
// 13787   for (int8_t i = 0; i < BUFSIZE; i++) send_ok[i] = true;
??setup_5:
        MOVS     R0,#+0
        MOVS     R2,#+1
        LDR.W    R3,??DataTable173
        B.N      ??setup_6
??setup_7:
        ADD      R1,R3,R1
        STRB     R2,[R1, #+20]
        ADDS     R0,R0,#+1
??setup_6:
        MOV      R1,R0
        SXTB     R1,R1
        CMP      R1,#+4
        BLT.N    ??setup_7
// 13788 
// 13789   // Load data from EEPROM if available (or use defaults)
// 13790   // This also updates variables in the planner, elsewhere
// 13791   (void)settings.load();
          CFI FunCall _ZN14MarlinSettings4loadEv
        BL       _ZN14MarlinSettings4loadEv
// 13792 
// 13793   //#if HAS_M206_COMMAND			//mks_delta
// 13794   if(MACHINETPYE != DELTA)
        LDR.W    R0,??DataTable174_2
        LDRSH    R0,[R0, #+88]
        CMP      R0,#+2
        BEQ.N    ??setup_8
// 13795     // Initialize current position based on home_offset
// 13796     COPY(current_position, home_offset);
        MOVS     R2,#+12
        ADD      R1,R4,#+56
        ADD      R0,R4,#+8
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        B.N      ??setup_9
// 13797   //#else
// 13798   else
// 13799     ZERO(current_position);
??setup_8:
        MOVS     R2,#+0
        MOVS     R1,#+16
        ADD      R0,R4,#+8
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
// 13800 //  #endif
// 13801 
// 13802   // Vital to init stepper/planner equivalent for current_position
// 13803   SYNC_PLAN_POSITION_KINEMATIC();
??setup_9:
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
// 13804 
// 13805   thermalManager.init();    // Initialize temperature loop
        LDR.W    R0,??DataTable180_1
          CFI FunCall _ZN11Temperature4initEv
        BL       _ZN11Temperature4initEv
// 13806 
// 13807   #if ENABLED(USE_WATCHDOG)
// 13808     watchdog_init();
// 13809   #endif
// 13810 
// 13811   stepper.init();    // Initialize stepper, this enables interrupts!
          CFI FunCall _ZN7Stepper4initEv
        BL       _ZN7Stepper4initEv
// 13812   servo_init();
          CFI FunCall _Z10servo_initv
        BL       _Z10servo_initv
// 13813 
// 13814   #if HAS_PHOTOGRAPH
// 13815     OUT_WRITE(PHOTOGRAPH_PIN, LOW);
// 13816   #endif
// 13817 
// 13818   #if HAS_CASE_LIGHT
// 13819     update_case_light();
// 13820   #endif
// 13821 
// 13822   #if HAS_BED_PROBE
// 13823     endstops.enable_z_probe(false);
        MOVS     R0,#+0
          CFI FunCall _ZN8Endstops14enable_z_probeEb
        BL       _ZN8Endstops14enable_z_probeEb
// 13824   #endif
// 13825 
// 13826 #if ENABLED(USE_CONTROLLER_FAN)
// 13827     SET_OUTPUT(CONTROLLER_FAN_PIN); //Set pin used for driver cooling fan
// 13828   #endif
// 13829 
// 13830   #if HAS_STEPPER_RESET
// 13831     enableStepperDrivers();
// 13832   #endif
// 13833 
// 13834   #if ENABLED(DIGIPOT_I2C)
// 13835     digipot_i2c_init();
// 13836   #endif
// 13837 
// 13838   #if ENABLED(DAC_STEPPER_CURRENT)
// 13839     dac_init();
// 13840   #endif
// 13841 
// 13842   #if (ENABLED(Z_PROBE_SLED) || ENABLED(SOLENOID_PROBE)) && HAS_SOLENOID_1
// 13843     OUT_WRITE(SOL1_PIN, LOW); // turn it off
// 13844   #endif
// 13845 
// 13846   setup_homepin();
          CFI FunCall _Z13setup_homepinv
        BL       _Z13setup_homepinv
// 13847 
// 13848   #if PIN_EXISTS(STAT_LED_RED)
// 13849     OUT_WRITE(STAT_LED_RED_PIN, LOW); // turn it off
// 13850   #endif
// 13851 
// 13852   #if PIN_EXISTS(STAT_LED_BLUE)
// 13853     OUT_WRITE(STAT_LED_BLUE_PIN, LOW); // turn it off
// 13854   #endif
// 13855 
// 13856   #if ENABLED(RGB_LED) || ENABLED(RGBW_LED)
// 13857     SET_OUTPUT(RGB_LED_R_PIN);
// 13858     SET_OUTPUT(RGB_LED_G_PIN);
// 13859     SET_OUTPUT(RGB_LED_B_PIN);
// 13860     #if ENABLED(RGBW_LED)
// 13861       SET_OUTPUT(RGB_LED_W_PIN);
// 13862     #endif
// 13863   #endif
// 13864 
// 13865   lcd_init();
          CFI FunCall _Z8lcd_initv
        BL       _Z8lcd_initv
// 13866   #if ENABLED(SHOW_BOOTSCREEN)
// 13867     #if ENABLED(DOGLCD)
// 13868       safe_delay(BOOTSCREEN_TIMEOUT);
        MOVW     R0,#+2500
          CFI FunCall _Z10safe_delaym
        BL       _Z10safe_delaym
// 13869     #elif ENABLED(ULTRA_LCD)
// 13870       bootscreen();
// 13871       #if DISABLED(SDSUPPORT)
// 13872         lcd_init();
// 13873       #endif
// 13874     #endif
// 13875   #endif
// 13876 
// 13877   #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
// 13878     // Initialize mixing to 100% color 1
// 13879     for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
// 13880       mixing_factor[i] = (i == 0) ? 1.0 : 0.0;
// 13881     for (uint8_t t = 0; t < MIXING_VIRTUAL_TOOLS; t++)
// 13882       for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
// 13883         mixing_virtual_tool_mix[t][i] = mixing_factor[i];
// 13884   #endif
// 13885 
// 13886   #if ENABLED(BLTOUCH)
// 13887     // Make sure any BLTouch error condition is cleared
// 13888     bltouch_command(BLTOUCH_RESET);
// 13889     set_bltouch_deployed(true);
// 13890     set_bltouch_deployed(false);
// 13891   #endif
// 13892 
// 13893   #if ENABLED(EXPERIMENTAL_I2CBUS) && I2C_SLAVE_ADDRESS > 0
// 13894     i2c.onReceive(i2c_on_receive);
// 13895     i2c.onRequest(i2c_on_request);
// 13896   #endif
// 13897 
// 13898   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
// 13899     setup_endstop_interrupts();
// 13900   #endif
// 13901     
// 13902   BLINK_LED(LED_ON);
        MOV      R0,#+4000
        LDR.W    R1,??DataTable183
        STRH     R0,[R1, #+0]
// 13903 }
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock99

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_49:
        DC8 "Marlin"
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_51:
        DC8 " Last Updated: "

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_52:
        DC8 "2017-05-12 12:00"
        DC8 0, 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_53:
        DC8 " | Author: (none, default config)\012"
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_54:
        DC8 "Compiled: May  7 2021\012"
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_55:
        DC8 " Free Memory: "
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_56:
        DC8 "  PlannerBufferBytes: "
        DC8 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock100 Using cfiCommon0
          CFI Function loop
        THUMB
loop:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        LDR.W    R4,??DataTable173
        LDRB     R0,[R4, #+8]
        CMP      R0,#+4
        BGE.N    ??loop_0
          CFI FunCall _Z22get_available_commandsv
        BL       _Z22get_available_commandsv
??loop_0:
        LDR.W    R5,??DataTable173_3
        MOVS     R1,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader14checkautostartEb
        BL       _ZN10CardReader14checkautostartEb
        LDRB     R0,[R4, #+8]
        CMP      R0,#+0
        BEQ.N    ??loop_1
        LDRB     R0,[R5, #+0]
        CMP      R0,#+0
        BEQ.N    ??loop_2
        LDR.W    R0,??DataTable184
        LDRB     R1,[R4, #+9]
        ADD      R2,R1,R1, LSL #+1
        ADDS     R6,R0,R2, LSL #+5
        ADR.N    R1,??DataTable168  ;; "M29"
        MOV      R0,R6
          CFI FunCall __iar_Strstr
        BL       __iar_Strstr
        CMP      R0,#+0
        BEQ.N    ??loop_3
        MOVS     R1,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader9closefileEb
        BL       _ZN10CardReader9closefileEb
        ADR.W    R0,?_58
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
          CFI FunCall _Z10ok_to_sendv
        BL       _Z10ok_to_sendv
        MOV      R0,#+4000
        LDR.W    R1,??DataTable183
        STRH     R0,[R1, #+0]
        B.N      ??loop_4
??loop_3:
        MOV      R1,R6
        MOV      R0,R5
          CFI FunCall _ZN10CardReader13write_commandEPc
        BL       _ZN10CardReader13write_commandEPc
        LDRB     R0,[R5, #+1]
        CMP      R0,#+0
        BEQ.N    ??loop_5
          CFI FunCall _Z20process_next_commandv
        BL       _Z20process_next_commandv
        B.N      ??loop_4
??loop_5:
          CFI FunCall _Z10ok_to_sendv
        BL       _Z10ok_to_sendv
        B.N      ??loop_4
??loop_2:
          CFI FunCall _Z20process_next_commandv
        BL       _Z20process_next_commandv
??loop_4:
        LDRB     R0,[R4, #+8]
        CMP      R0,#+0
        BEQ.N    ??loop_1
        SUBS     R0,R0,#+1
        STRB     R0,[R4, #+8]
        LDRB     R0,[R4, #+9]
        ADDS     R0,R0,#+1
        STRB     R0,[R4, #+9]
        UXTB     R0,R0
        CMP      R0,#+4
        BLT.N    ??loop_1
        MOVS     R0,#+0
        STRB     R0,[R4, #+9]
??loop_1:
          CFI FunCall _ZN8Endstops12report_stateEv
        BL       _ZN8Endstops12report_stateEv
        MOVS     R0,#+0
          CFI FunCall _Z4idleb
        BL       _Z4idleb
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall mks_PrintStatePolling
        B.N      mks_PrintStatePolling
          CFI EndBlock cfiBlock100

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_58:
        DC8 "Done saving file.\012"
        DC8 0

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        DATA
// __absolute DATA_REPRINT_ITMES mksReprint
mksReprint:
        DS8 1048

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock101 Using cfiCommon0
          CFI Function mks_initPrint
        THUMB
// __interwork __softfp void mks_initPrint()
mks_initPrint:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.W    R0,??DataTable183_1
        LDR.W    R4,??DataTable183_2
        LDR      R1,[R0, #+0]
        STR      R1,[R4, #+52]
        LDR      R1,[R0, #+4]
        STR      R1,[R4, #+56]
        LDR      R0,[R0, #+8]
        STR      R0,[R4, #+60]
        LDR.W    R0,??DataTable186  ;; 0x40a00000
        STR      R0,[R4, #+64]
        MOVS     R0,#+0
        STR      R0,[R4, #+68]
        ADD      R5,R4,#+104
        MOVS     R0,#+166
        STRB     R0,[R5, #+0]
        MOVS     R0,#+0
        STR      R0,[R5, #+4]
        MOV      R2,R0
        MOVS     R1,#+20
        MOV      R0,R4
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        MOVS     R2,#+0
        MOVS     R1,#+30
        ADD      R0,R4,#+20
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        MOVS     R0,#+0
        STRH     R0,[R5, #+40]
        STRH     R0,[R5, #+10]
        STRH     R0,[R5, #+12]
        STRB     R0,[R4, #+1044]
        STRB     R0,[R5, #+8]
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock101

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable166:
        DC8      0x20, 0x0A, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable166_1:
        DC32     0x54442d18

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable166_2:
        DC32     0x401921fb

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable166_3:
        DC32     0xc01921fb

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable166_4:
        DC32     0x40c90fdb

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable166_5:
        DC32     0x3a83126f

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable166_6:
        DC32     0x3fe00000

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock102 Using cfiCommon0
          CFI Function _Z14mks_WriteToEprv
        THUMB
// __interwork __softfp void mks_WriteToEpr()
_Z14mks_WriteToEprv:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        LDR.W    R4,??DataTable183_2
        ADD      R5,R4,#+108
        LDR.W    R0,??DataTable173_3
          CFI FunCall _ZN10CardReader8getsdposEv
        BL       _ZN10CardReader8getsdposEv
        STR      R0,[R5, #+0]
        MOVS     R2,#+4
        MOV      R1,R5
        MOVW     R0,#+1401
          CFI FunCall epr_write_data
        BL       epr_write_data
        LDR.W    R0,??DataTable184_2
        LDR      R0,[R0, #+0]
        STRH     R0,[R5, #+6]
        MOVS     R2,#+2
        ADD      R1,R4,#+114
        MOVW     R0,#+1405
          CFI FunCall epr_write_data
        BL       epr_write_data
        LDR.W    R0,??DataTable174_2
        LDRB     R0,[R0, #+54]
        CMP      R0,#+0
        BEQ.N    ??mks_WriteToEpr_0
        LDR.W    R0,??DataTable184_3
        LDR      R0,[R0, #+0]
        STRH     R0,[R5, #+8]
        MOVS     R2,#+2
        ADD      R1,R4,#+116
        MOVW     R0,#+1407
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_WriteToEpr_0:
        MOVS     R2,#+4
        ADD      R1,R4,#+72
        MOVW     R0,#+1409
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R4,#+76
        MOVW     R0,#+1413
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R4,#+80
        MOVW     R0,#+1417
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R4,#+84
        MOVW     R0,#+1421
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R4,#+88
        MOVW     R0,#+1425
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R4,#+92
        MOVW     R0,#+1429
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R4,#+96
        MOVW     R0,#+1433
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R4,#+100
        MOVW     R0,#+1437
          CFI FunCall epr_write_data
        BL       epr_write_data
        ADD      R6,R4,#+128
        ADD      R7,R4,#+132
        ADD      R8,R4,#+136
        MOV      R3,R8
        MOV      R2,R7
        MOV      R1,R6
        LDR.W    R0,??DataTable173_4
          CFI FunCall _ZN9Stopwatch7getTimeEPmS0_S0_
        BL       _ZN9Stopwatch7getTimeEPmS0_S0_
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        STR      R0,[R5, #+32]
        MOVS     R2,#+4
        MOV      R1,R6
        MOVW     R0,#+1446
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        MOV      R1,R7
        MOVW     R0,#+1450
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        MOV      R1,R8
        MOVW     R0,#+1454
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R4,#+140
        MOVW     R0,#+1458
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R4,#+124
        MOVW     R0,#+1445
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R4,#+120
        MOVW     R0,#+1441
        POP      {R4-R8,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall epr_write_data
        B.W      epr_write_data
          CFI EndBlock cfiBlock102

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable167:
        DC32     0x3ff00000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable167_1:
        DC32     0x47ae147b

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable167_2:
        DC32     0x3f847ae1

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock103 Using cfiCommon0
          CFI Function mks_ReadFromEpr
        THUMB
// __interwork __softfp void mks_ReadFromEpr()
mks_ReadFromEpr:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.W    R4,??DataTable183_2
        MOVS     R2,#+30
        ADD      R1,R4,#+20
        MOVW     R0,#+1462
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+108
        MOVW     R0,#+1401
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+114
        MOVW     R0,#+1405
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDR.W    R0,??DataTable174_2
        LDRB     R0,[R0, #+54]
        CMP      R0,#+0
        BEQ.N    ??mks_ReadFromEpr_0
        MOVS     R2,#+2
        ADD      R1,R4,#+116
        MOVW     R0,#+1407
          CFI FunCall epr_read_data
        BL       epr_read_data
??mks_ReadFromEpr_0:
        MOVS     R2,#+4
        ADD      R1,R4,#+72
        MOVW     R0,#+1409
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+76
        MOVW     R0,#+1413
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+80
        MOVW     R0,#+1417
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+84
        MOVW     R0,#+1421
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+88
        MOVW     R0,#+1425
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+92
        MOVW     R0,#+1429
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+96
        MOVW     R0,#+1433
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+100
        MOVW     R0,#+1437
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+128
        MOVW     R0,#+1446
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+132
        MOVW     R0,#+1450
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+136
        MOVW     R0,#+1454
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+140
        MOVW     R0,#+1458
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+124
        MOVW     R0,#+1445
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+120
        MOVW     R0,#+1441
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall epr_read_data
        B.W      epr_read_data
          CFI EndBlock cfiBlock103

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable168:
        DC8      "M29"

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock104 Using cfiCommon0
          CFI Function mks_resumePrint
        THUMB
// __interwork __softfp void mks_resumePrint()
mks_resumePrint:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.W    R4,??DataTable183_2
        LDRB     R0,[R4, #+104]
        CMP      R0,#+169
        BNE.N    ??mks_resumePrint_0
        MOVS     R0,#+167
        STRB     R0,[R4, #+104]
        LDR      R0,[R4, #+64]
          CFI FunCall mks_preExtrude
        BL       mks_preExtrude
        LDR      R1,[R4, #+92]
        LDR      R0,[R4, #+88]
          CFI FunCall mks_moveXY
        BL       mks_moveXY
        MOVS     R0,#+0
          CFI FunCall mks_moveZ
        BL       mks_moveZ
        MOVS     R1,#+0
        ADD      R0,R4,#+20
          CFI FunCall _Z13lcd_setstatusPKcb
        BL       _Z13lcd_setstatusPKcb
??mks_resumePrint_0:
        LDRB     R0,[R4, #+104]
        CMP      R0,#+170
        BNE.N    ??mks_resumePrint_1
        MOVS     R0,#+171
        STRB     R0,[R4, #+104]
??mks_resumePrint_1:
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock104

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable169:
        DC32     0x4062c000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable169_1:
        DC32     0x400921fb

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable169_2:
        DC32     0x40668000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable169_3:
        DC32     axis_homed

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable169_4:
        DC32     0x42c80000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable169_5:
        DC32     0xc2c80000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable169_6:
        DC32     0x42600000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable169_7:
        DC32     0x54442d18

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock105 Using cfiCommon0
          CFI Function _Z17pause_file_offsetv
        THUMB
// __interwork __softfp uint32_t pause_file_offset()
_Z17pause_file_offsetv:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
        MOVS     R5,#+0
        MOV      R8,#+96
        LDR.W    R9,??DataTable173
        LDR.W    R0,??DataTable174_3
        LDRB     R1,[R9, #+17]
        MUL      R1,R8,R1
        ADD      R0,R0,R1
        ADD      R1,R0,#+136
        ADD      R0,R9,#+72
          CFI FunCall strcpy
        BL       strcpy
        LDR.N    R7,??DataTable173_3
        LDR      R1,[R7, #+52]
        CMP      R1,#+1024
        BCS.N    ??pause_file_offset_0
        MOV      R1,R5
        MOV      R0,R7
          CFI FunCall _ZN10CardReader8setIndexEl
        BL       _ZN10CardReader8setIndexEl
        B.N      ??pause_file_offset_1
??pause_file_offset_0:
        SUB      R1,R1,#+1024
        MOV      R0,R7
          CFI FunCall _ZN10CardReader8setIndexEl
        BL       _ZN10CardReader8setIndexEl
??pause_file_offset_1:
        MOV      R0,R5
        STR      R0,[R9, #+68]
        STRH     R0,[R9, #+24]
        MOV      R0,R7
          CFI FunCall _ZN10CardReader3eofEv
        BL       _ZN10CardReader3eofEv
        MOV      R4,R0
        B.N      ??pause_file_offset_2
??pause_file_offset_3:
        MOV      R2,R5
        MOV      R1,R8
        MOV      R0,R6
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
        MOV      R0,R5
        STR      R0,[R9, #+68]
??pause_file_offset_2:
        CMP      R4,#+0
        BNE.N    ??pause_file_offset_4
        LDRH     R0,[R9, #+24]
        CMP      R0,#+1024
        BGE.N    ??pause_file_offset_4
        MOV      R0,R7
          CFI FunCall _ZN10CardReader3getEv
        BL       _ZN10CardReader3getEv
        MOV      R10,R0
        MOV      R6,R10
        SXTB     R6,R6
        MOV      R0,R7
          CFI FunCall _ZN10CardReader3eofEv
        BL       _ZN10CardReader3eofEv
        MOV      R4,R0
        LDRH     R0,[R9, #+24]
        ADDS     R0,R0,#+1
        STRH     R0,[R9, #+24]
        CMP      R4,#+0
        BNE.N    ??pause_file_offset_5
        CMN      R10,#+1
        BEQ.N    ??pause_file_offset_5
        CMP      R6,#+10
        BEQ.N    ??pause_file_offset_5
        CMP      R6,#+13
        BEQ.N    ??pause_file_offset_5
        CMP      R6,#+35
        BEQ.N    ??pause_file_offset_6
        CMP      R6,#+58
        BNE.N    ??pause_file_offset_7
??pause_file_offset_6:
        LDRB     R0,[R9, #+18]
        CMP      R0,#+0
        BNE.N    ??pause_file_offset_7
??pause_file_offset_5:
        CMP      R4,#+0
        BNE.N    ??pause_file_offset_4
        MOVS     R0,#+0
        STRB     R0,[R9, #+18]
        CMP      R5,#+0
        BEQ.N    ??pause_file_offset_2
        LDR.W    R0,??DataTable184
        LDRB     R1,[R9, #+10]
        MUL      R1,R8,R1
        ADDS     R6,R0,R1
        MOVS     R0,#+0
        STRB     R0,[R6, R5]
        MOV      R5,R0
        MOV      R1,R6
        ADD      R0,R9,#+72
          CFI FunCall strcmp
        BL       strcmp
        CMP      R0,#+0
        BNE.N    ??pause_file_offset_3
        LDR      R1,[R7, #+52]
        LDR      R0,[R9, #+68]
        SUBS     R1,R1,R0
        SUBS     R1,R1,#+1
        MOV      R0,R7
          CFI FunCall _ZN10CardReader8setIndexEl
        BL       _ZN10CardReader8setIndexEl
        LDR      R0,[R7, #+52]
        B.N      ??pause_file_offset_8
??pause_file_offset_7:
        CMP      R5,#+95
        BLT.N    ??pause_file_offset_9
        LDR      R0,[R9, #+68]
        ADDS     R0,R0,#+1
        STR      R0,[R9, #+68]
        B.N      ??pause_file_offset_2
??pause_file_offset_9:
        CMP      R6,#+59
        BNE.N    ??pause_file_offset_10
        MOVS     R0,#+1
        STRB     R0,[R9, #+18]
        LDR      R0,[R9, #+68]
        ADDS     R0,R0,#+1
        STR      R0,[R9, #+68]
??pause_file_offset_10:
        LDRB     R0,[R9, #+18]
        CMP      R0,#+0
        BNE.N    ??pause_file_offset_2
        LDR.W    R0,??DataTable184
        LDRB     R1,[R9, #+10]
        MUL      R1,R8,R1
        ADD      R0,R0,R1
        STRB     R6,[R0, R5]
        ADDS     R5,R5,#+1
        UXTH     R5,R5
        LDR      R0,[R9, #+68]
        ADDS     R0,R0,#+1
        STR      R0,[R9, #+68]
        B.N      ??pause_file_offset_2
??pause_file_offset_4:
        MOVS     R0,#+0
??pause_file_offset_8:
        POP      {R4-R10,PC}      ;; return
          CFI EndBlock cfiBlock105

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable170:
        DC32     home_dir_P

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable170_1:
        DC32     0xbf800000

        SECTION `.data`:DATA:REORDER:NOROOT(2)
        DATA
axis_relative_modes:
        DC8 0, 0, 0, 0
axis_known_position:
        DC8 0, 0, 0, 0
commands_in_queue:
        DC8 0
        DC8 0
        DC8 0
cmd_queue_index_r_bak:
        DC8 0
        DC8 0
        DC8 0
serial_wait_tick:
        DC8 0
        DC8 0
// __absolute uint8_t cmd_id_bak
cmd_id_bak:
        DC8 0
// __absolute uint8_t cmd_id_bak_temp
cmd_id_bak_temp:
        DC8 0
        DC8 0
        DC8 0
        DC8 0, 0, 0, 0
        DC16 0
filament_change_menu_response:
        DC8 0
        DC8 0
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC32 0
        DC32 0
previous_cmd_ms:
        DC32 0
        DC32 0
        DC32 120000
// __absolute uint32_t volatile cmd_length
cmd_length:
        DC32 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        SECTION `.data`:DATA:REORDER:NOROOT(2)
        DATA
flow_percentage:
        DC32 100

        SECTION `.data`:DATA:REORDER:NOROOT(2)
        DATA
volumetric_enabled:
        DC8 0
        DC8 0, 0, 0
filament_size:
        DC32 40400000H
volumetric_multiplier:
        DC32 3F800000H

        SECTION `.data`:DATA:REORDER:NOROOT(0)
        DATA
soft_endstops_enabled:
        DC8 1

        SECTION `.data`:DATA:REORDER:NOROOT(2)
        DATA
host_keepalive_interval:
        DC8 2
        DC8 0, 0, 0
        DC32 0

        SECTION `.data`:DATA:REORDER:NOROOT(2)
        DATA
home_bump_mm_P:
        DC32 40A00000H, 40A00000H, 40A00000H

        SECTION `.data`:DATA:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvE15mbl_probe_index
        DATA
_ZZ27gcode_G29_MESH_BED_LEVELINGvE15mbl_probe_index:
        DC32 -1

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock106 Using cfiCommon0
          CFI Function mks_pausePrint
        THUMB
// __interwork __softfp void mks_pausePrint()
mks_pausePrint:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        LDR.W    R4,??DataTable183_2
        LDR.N    R0,??DataTable174_3
        LDR      R1,[R0, #+8]
        STR      R1,[R4, #+72]
        LDR      R1,[R0, #+12]
        STR      R1,[R4, #+76]
        LDR      R1,[R0, #+16]
        STR      R1,[R4, #+80]
        LDR      R1,[R0, #+20]
        STR      R1,[R4, #+84]
        LDR      R1,[R0, #+24]
        STR      R1,[R4, #+88]
        LDR      R1,[R0, #+28]
        STR      R1,[R4, #+92]
        LDR      R1,[R0, #+32]
        STR      R1,[R4, #+96]
        LDR      R1,[R0, #+36]
        STR      R1,[R4, #+100]
        LDR.W    R1,??DataTable189_1
        LDR      R1,[R1, #+0]
        STRB     R1,[R4, #+124]
        LDR      R0,[R0, #+116]
        STR      R0,[R4, #+120]
        MOV      R0,#-1073741824
          CFI FunCall mks_preExtrude
        BL       mks_preExtrude
        LDR      R0,[R4, #+60]
          CFI FunCall mks_moveZ
        BL       mks_moveZ
        LDR      R1,[R4, #+56]
        LDR      R0,[R4, #+52]
          CFI FunCall mks_moveXY
        BL       mks_moveXY
          CFI FunCall _Z17pause_file_offsetv
        BL       _Z17pause_file_offsetv
        LDR.N    R1,??DataTable173_3
        STR      R0,[R1, #+52]
          CFI FunCall _Z14mks_WriteToEprv
        BL       _Z14mks_WriteToEprv
        MOVS     R1,#+0
        LDR.W    R0,??DataTable192_1
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z13lcd_setstatusPKcb
        B.W      _Z13lcd_setstatusPKcb
          CFI EndBlock cfiBlock106

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable171:
        DC32     0xc2600000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable171_1:
        DC32     0x43160000

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock107 Using cfiCommon0
          CFI Function _Z16find_pause_e_posv
        THUMB
// __interwork __softfp void find_pause_e_pos()
_Z16find_pause_e_posv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+24
          CFI CFA R13+40
        MOVS     R4,#+0
        MOVS     R0,#+1
        STRB     R0,[SP, #+1]
        MOV      R0,R4
        STRB     R0,[SP, #+0]
        LDR.N    R0,??DataTable173
        LDRB     R0,[R0, #+17]
        STRB     R0,[SP, #+0]
        LDR.N    R5,??DataTable174_3
        LDR.W    R6,??DataTable192_2
??find_pause_e_pos_0:
        CMP      R4,#+8
        BGE.N    ??find_pause_e_pos_1
        ADDS     R4,R4,#+1
        LDRSB    R0,[SP, #+1]
        CMP      R0,#+1
        BNE.N    ??find_pause_e_pos_2
        LDRB     R0,[SP, #+0]
        ADD      R1,R0,R0, LSL #+1
        ADD      R0,R5,R1, LSL #+5
        ADDS     R0,R0,#+136
        MOVS     R1,#+69
          CFI FunCall __iar_Strchr
        BL       __iar_Strchr
        MOVS     R1,#+0
        CMP      R0,#+0
        ADD      R3,SP,#+4
        BEQ.N    ??find_pause_e_pos_2
??find_pause_e_pos_3:
        ADDS     R2,R0,R1
        LDRSB    R2,[R2, #+1]
        CMP      R2,#+32
        BEQ.N    ??find_pause_e_pos_4
        CMP      R2,#+59
        BEQ.N    ??find_pause_e_pos_4
        CMP      R2,#+13
        BEQ.N    ??find_pause_e_pos_4
        CMP      R2,#+10
        BEQ.N    ??find_pause_e_pos_4
        CMP      R1,#+20
        BGE.N    ??find_pause_e_pos_4
        STRB     R2,[R3, R1]
        ADDS     R1,R1,#+1
        B.N      ??find_pause_e_pos_3
??find_pause_e_pos_5:
        LDRB     R0,[SP, #+0]
        SUBS     R0,R0,#+1
        STRB     R0,[SP, #+0]
??find_pause_e_pos_6:
        LDRSB    R0,[SP, #+1]
        CMP      R0,#+0
        BNE.N    ??find_pause_e_pos_0
??find_pause_e_pos_1:
        ADD      SP,SP,#+24
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
          CFI CFA R13+40
??find_pause_e_pos_4:
        ADD      R0,SP,#+4
          CFI FunCall atof
        BL       atof
        MOVS     R2,#+0
        MOV      R3,#-1073741824
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R6, #+84]
        STR      R0,[R5, #+20]
        STR      R0,[R5, #+36]
        MOVS     R0,#+0
        STRB     R0,[SP, #+1]
??find_pause_e_pos_2:
        LDRB     R0,[SP, #+0]
        CMP      R0,#+0
        BNE.N    ??find_pause_e_pos_5
        MOVS     R0,#+7
        STRB     R0,[SP, #+0]
        B.N      ??find_pause_e_pos_6
          CFI EndBlock cfiBlock107

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable172:
        DC32     volumetric_enabled

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock108 Using cfiCommon0
          CFI Function _Z11quick_pausev
        THUMB
// __interwork __softfp void quick_pause()
_Z11quick_pausev:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.N    R5,??DataTable173
        MOVS     R0,#+0
        STRH     R0,[R5, #+8]
        STRB     R0,[R5, #+10]
        LDR.W    R4,??DataTable192_4
        MOV      R0,R4
          CFI FunCall HAL_TIM_Base_Stop_IT
        BL       HAL_TIM_Base_Stop_IT
        LDRB     R0,[R5, #+16]
        CMP      R0,#+0
        BNE.N    ??quick_pause_0
        MOVS     R0,#+7
        STRB     R0,[R5, #+17]
        B.N      ??quick_pause_1
??quick_pause_0:
        SUBS     R0,R0,#+1
        STRB     R0,[R5, #+17]
        B.N      ??quick_pause_1
??quick_pause_2:
          CFI FunCall _ZN7Planner21discard_current_blockEv
        BL       _ZN7Planner21discard_current_blockEv
??quick_pause_1:
          CFI FunCall _ZN7Planner13blocks_queuedEv
        BL       _ZN7Planner13blocks_queuedEv
        CMP      R0,#+0
        BNE.N    ??quick_pause_2
        MOVS     R0,#+0
        LDR.W    R1,??DataTable192_6
        STR      R0,[R1, #+0]
          CFI FunCall _Z16find_pause_e_posv
        BL       _Z16find_pause_e_posv
        MOVS     R0,#+100
          CFI FunCall _Z34set_current_from_steppers_for_axis8AxisEnum
        BL       _Z34set_current_from_steppers_for_axis8AxisEnum
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
        LDR.N    R0,??DataTable174_3
        LDR      R1,[R0, #+8]
        STR      R1,[R0, #+24]
        LDR      R1,[R0, #+12]
        STR      R1,[R0, #+28]
        LDR      R1,[R0, #+16]
        STR      R1,[R0, #+32]
        MOV      R0,R4
          CFI FunCall HAL_TIM_Base_Start_IT
        BL       HAL_TIM_Base_Start_IT
        LDR.W    R0,??DataTable192_2
        MOVS     R1,#+169
        STRB     R1,[R0, #+104]
        MOVS     R2,#+1
        ADD      R1,R0,#+104
        MOV      R0,#+1400
          CFI FunCall epr_write_data
        BL       epr_write_data
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall mks_pausePrint
        B.N      mks_pausePrint
          CFI EndBlock cfiBlock108

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable173:
        DC32     axis_relative_modes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable173_1:
        DC32     gArrayGpioPort

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable173_2:
        DC32     gArrayGpioPin

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable173_3:
        DC32     card

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable173_4:
        DC32     mks_heating_busy+0x388

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock109 Using cfiCommon0
          CFI Function mks_PrintStatePolling
        THUMB
// __interwork __softfp void mks_PrintStatePolling()
mks_PrintStatePolling:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        LDR.W    R4,??DataTable183_2
        ADD      R5,R4,#+104
        LDRB     R0,[R5, #+0]
        CMP      R0,#+168
        BNE.N    ??mks_PrintStatePolling_0
          CFI FunCall _Z11quick_pausev
        BL       _Z11quick_pausev
??mks_PrintStatePolling_0:
        LDRB     R0,[R5, #+0]
        CMP      R0,#+169
        BNE.N    ??mks_PrintStatePolling_1
        LDR.N    R6,??DataTable174_3
        LDR      R7,[R6, #+8]
        LDR.W    R8,??DataTable192_7  ;; 0x38d1b718
        LDR      R0,[R4, #+72]
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        BIC      R0,R0,#0x80000000
        MOV      R1,R8
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??mks_PrintStatePolling_2
        STR      R7,[R4, #+72]
        MOVS     R2,#+4
        ADD      R1,R4,#+72
        MOVW     R0,#+1409
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_PrintStatePolling_2:
        LDR      R7,[R6, #+12]
        LDR      R0,[R4, #+76]
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        BIC      R0,R0,#0x80000000
        MOV      R1,R8
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??mks_PrintStatePolling_3
        STR      R7,[R4, #+76]
        MOVS     R2,#+4
        ADD      R1,R4,#+76
        MOVW     R0,#+1413
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_PrintStatePolling_3:
        LDR      R6,[R6, #+16]
        LDR      R0,[R4, #+80]
        MOV      R1,R6
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        BIC      R0,R0,#0x80000000
        MOV      R1,R8
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??mks_PrintStatePolling_1
        STR      R6,[R4, #+80]
        MOVS     R2,#+4
        ADD      R1,R4,#+80
        MOVW     R0,#+1417
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_PrintStatePolling_1:
        LDRB     R0,[R5, #+0]
        CMP      R0,#+167
        BNE.N    ??mks_PrintStatePolling_4
        LDR.W    R0,??DataTable192_8
        LDRB     R0,[R0, #+2]
        CMP      R0,#+0
        BNE.N    ??mks_PrintStatePolling_5
        LDRH     R0,[R5, #+40]
        ADDS     R0,R0,#+1
        STRH     R0,[R5, #+40]
        B.N      ??mks_PrintStatePolling_6
??mks_PrintStatePolling_5:
        MOVS     R0,#+0
        STRH     R0,[R5, #+40]
??mks_PrintStatePolling_6:
        LDRH     R0,[R5, #+40]
        CMP      R0,#+21
        BLT.N    ??mks_PrintStatePolling_4
        MOVS     R0,#+0
        STRH     R0,[R5, #+40]
        MOVS     R0,#+166
        STRB     R0,[R5, #+0]
        MOVS     R2,#+1
        MOV      R1,R5
        MOV      R0,#+1400
          CFI FunCall epr_write_data
        BL       epr_write_data
          CFI FunCall mks_clearFile
        BL       mks_clearFile
??mks_PrintStatePolling_4:
        LDRB     R0,[R5, #+0]
        CMP      R0,#+171
        BNE.N    ??mks_PrintStatePolling_7
        LDR.W    R0,??DataTable192_9
        LDRSH    R0,[R0, #+88]
        CMP      R0,#+1
        BEQ.N    ??mks_PrintStatePolling_8
        CMP      R0,#+2
        BEQ.N    ??mks_PrintStatePolling_9
        CMP      R0,#+4
        BEQ.N    ??mks_PrintStatePolling_8
        CMP      R0,#+8
        BNE.N    ??mks_PrintStatePolling_7
??mks_PrintStatePolling_8:
        LDRSB    R0,[R4, #+1044]
        CMP      R0,#+1
        BNE.N    ??mks_PrintStatePolling_10
        POP      {R4-R8,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall mks_contiuePrintPause
        B.N      mks_contiuePrintPause
          CFI R4 Frame(CFA, -24)
          CFI R5 Frame(CFA, -20)
          CFI R6 Frame(CFA, -16)
          CFI R7 Frame(CFA, -12)
          CFI R8 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+24
??mks_PrintStatePolling_10:
        CMP      R0,#+2
        BNE.N    ??mks_PrintStatePolling_7
        POP      {R4-R8,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall mks_contiuePrintPwdwn
        B.N      mks_contiuePrintPwdwn
          CFI R4 Frame(CFA, -24)
          CFI R5 Frame(CFA, -20)
          CFI R6 Frame(CFA, -16)
          CFI R7 Frame(CFA, -12)
          CFI R8 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+24
??mks_PrintStatePolling_9:
        POP      {R4-R8,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall mks_contiuePrintDelta
        B.N      mks_contiuePrintDelta
          CFI R4 Frame(CFA, -24)
          CFI R5 Frame(CFA, -20)
          CFI R6 Frame(CFA, -16)
          CFI R7 Frame(CFA, -12)
          CFI R8 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+24
??mks_PrintStatePolling_7:
        POP      {R4-R8,PC}       ;; return
          CFI EndBlock cfiBlock109

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable174:
        DC32     axis_relative_modes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable174_1:
        DC32     gArrayGpioPort+0x38

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable174_2:
        DC32     mksCfg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable174_3:
        DC32     mks_heating_busy

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable174_4:
        DC32     customizedSerial

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable174_5:
        DC32     serial2

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock110 Using cfiCommon0
          CFI Function _Z18mks_setTemperaturev
        THUMB
// __interwork __softfp void mks_setTemperature()
_Z18mks_setTemperaturev:
        PUSH     {R4-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+20
        SUB      SP,SP,#+20
          CFI CFA R13+40
        LDR.W    R4,??DataTable183_2
        ADD      R5,R4,#+114
        LDR.W    R6,??DataTable192_9
        LDRB     R0,[R6, #+54]
        CMP      R0,#+0
        BEQ.N    ??mks_setTemperature_0
        LDRH     R0,[R5, #+2]
        CMP      R0,#+0
        BEQ.N    ??mks_setTemperature_0
        ADD      R7,R4,#+146
        MOVS     R2,#+0
        MOVS     R1,#+96
        MOV      R0,R7
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
        MOVS     R2,#+7
        ADR.W    R1,?_59
        MOV      R0,R7
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        LDRH     R2,[R5, #+2]
        ADR.N    R1,??DataTable180  ;; 0x25, 0x64, 0x00, 0x00
        MOV      R0,SP
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,SP
        MOV      R0,R7
          CFI FunCall strcat
        BL       strcat
        ADD      R0,R4,#+151
        LDR.W    R1,??DataTable192_10
        STR      R0,[R1, #+40]
          CFI FunCall _Z10gcode_M140v
        BL       _Z10gcode_M140v
??mks_setTemperature_0:
        LDRH     R0,[R5, #+0]
        CMP      R0,#+0
        BEQ.N    ??mks_setTemperature_1
        ADD      R7,R4,#+146
        MOVS     R2,#+0
        MOVS     R1,#+96
        MOV      R0,R7
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
        MOVS     R2,#+7
        ADR.W    R1,?_61
        MOV      R0,R7
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        LDRH     R2,[R5, #+0]
        ADR.N    R1,??DataTable180  ;; 0x25, 0x64, 0x00, 0x00
        MOV      R0,SP
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,SP
        MOV      R0,R7
          CFI FunCall strcat
        BL       strcat
        ADD      R0,R4,#+151
        LDR.W    R1,??DataTable192_10
        STR      R0,[R1, #+40]
          CFI FunCall _Z10gcode_M109v
        BL       _Z10gcode_M109v
??mks_setTemperature_1:
        LDRB     R0,[R6, #+54]
        CMP      R0,#+0
        BEQ.N    ??mks_setTemperature_2
        LDRH     R0,[R5, #+2]
        CMP      R0,#+0
        BEQ.N    ??mks_setTemperature_2
        ADD      R6,R4,#+146
        MOVS     R2,#+0
        MOVS     R1,#+96
        MOV      R0,R6
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
        MOVS     R2,#+7
        ADR.W    R1,?_62
        MOV      R0,R6
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        LDRH     R2,[R5, #+2]
        ADR.N    R1,??DataTable180  ;; 0x25, 0x64, 0x00, 0x00
        MOV      R0,SP
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,SP
        MOV      R0,R6
          CFI FunCall strcat
        BL       strcat
        ADD      R0,R4,#+151
        LDR.W    R1,??DataTable192_10
        STR      R0,[R1, #+40]
          CFI FunCall _Z10gcode_M190v
        BL       _Z10gcode_M190v
??mks_setTemperature_2:
        ADD      SP,SP,#+20
          CFI CFA R13+20
        POP      {R4-R7,PC}       ;; return
          CFI EndBlock cfiBlock110

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable175:
        DC32     gArrayGpioPin+0x1C

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable175_1:
        DC32     errormagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_59:
        DC8 "M140 S"
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_61:
        DC8 "M109 S"
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_62:
        DC8 "M190 S"
        DC8 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock111 Using cfiCommon0
          CFI Function mks_setPositionZ
        THUMB
// __interwork __softfp void mks_setPositionZ()
mks_setPositionZ:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        SUB      SP,SP,#+20
          CFI CFA R13+32
        LDR.N    R4,??DataTable183_2
        ADD      R5,R4,#+146
        MOVS     R2,#+0
        MOVS     R1,#+96
        MOV      R0,R5
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
        MOVS     R2,#+6
        ADR.W    R1,?_63
        MOV      R0,R5
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R2,#+0
        MOVS     R1,#+20
        MOV      R0,SP
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        LDR      R0,[R4, #+80]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        ADR.N    R1,??DataTable182  ;; 0x25, 0x66, 0x00, 0x00
        MOV      R0,SP
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,SP
        MOV      R0,R5
          CFI FunCall strcat
        BL       strcat
        ADD      R0,R4,#+150
        LDR.W    R1,??DataTable192_10
        STR      R0,[R1, #+40]
          CFI FunCall _Z9gcode_G92v
        BL       _Z9gcode_G92v
        MOVS     R0,#+0
        LDR.W    R1,??DataTable192_11
        STR      R0,[R1, #+88]
        ADD      SP,SP,#+20
          CFI CFA R13+12
        POP      {R4,R5,PC}       ;; return
          CFI EndBlock cfiBlock111

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_63:
        DC8 "G92 Z"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock112 Using cfiCommon0
          CFI Function _Z15mks_setFeedratev
          CFI NoCalls
        THUMB
// __interwork __softfp void mks_setFeedrate()
_Z15mks_setFeedratev:
        LDR.N    R0,??DataTable183_2
        LDR      R0,[R0, #+120]
        LDR.W    R1,??DataTable192_11
        STR      R0,[R1, #+116]
        BX       LR               ;; return
          CFI EndBlock cfiBlock112

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable177:
        DC32     Running

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock113 Using cfiCommon0
          CFI Function mks_preExtrude
        THUMB
// __interwork __softfp void mks_preExtrude(float)
mks_preExtrude:
        PUSH     {R3-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+28
        SUB      SP,SP,#+20
          CFI CFA R13+48
        MOV      R8,R0
        LDR.W    R4,??DataTable192_10
        MOVS     R0,#+1
        STRB     R0,[R4, #+12]
        LDR.N    R5,??DataTable183_2
        ADD      R6,R5,#+146
        MOVS     R2,#+0
        MOVS     R1,#+96
        MOV      R0,R6
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
        MOVS     R2,#+5
        ADR.W    R1,?_65
        MOV      R0,R6
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R2,#+0
        MOVS     R1,#+20
        MOV      R0,SP
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        ADR.N    R7,??DataTable182  ;; 0x25, 0x66, 0x00, 0x00
        MOV      R0,R8
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R1,R7
        MOV      R0,SP
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,SP
        MOV      R0,R6
          CFI FunCall strcat
        BL       strcat
        ADD      R0,R5,#+149
        STR      R0,[R4, #+40]
          CFI FunCall _Z11gcode_G0_G1v
        BL       _Z11gcode_G0_G1v
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        MOVS     R0,#+0
        STRB     R0,[R4, #+12]
        MOV      R2,R0
        MOVS     R1,#+96
        MOV      R0,R6
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
        MOVS     R2,#+6
        ADR.W    R1,?_66
        MOV      R0,R6
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R2,#+0
        MOVS     R1,#+20
        MOV      R0,SP
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        LDR      R0,[R5, #+100]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R1,R7
        MOV      R0,SP
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,SP
        MOV      R0,R6
          CFI FunCall strcat
        BL       strcat
        ADD      R0,R5,#+150
        STR      R0,[R4, #+40]
          CFI FunCall _Z9gcode_G92v
        BL       _Z9gcode_G92v
        ADD      SP,SP,#+24
          CFI CFA R13+24
        POP      {R4-R8,PC}       ;; return
          CFI EndBlock cfiBlock113

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable178:
        DC32     mks_heating_busy+0x398

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable178_1:
        DC32     errormagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_65:
        DC8 "G1 E"
        DC8 0, 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_66:
        DC8 "G92 E"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock114 Using cfiCommon0
          CFI Function mks_moveXY
        THUMB
// __interwork __softfp void mks_moveXY(float, float)
mks_moveXY:
        PUSH     {R3-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+28
        SUB      SP,SP,#+20
          CFI CFA R13+48
        MOV      R8,R0
        MOV      R4,R1
        LDR.N    R5,??DataTable183_2
        ADD      R6,R5,#+146
        MOVS     R2,#+0
        MOVS     R1,#+96
        MOV      R0,R6
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
        MOVS     R2,#+5
        ADR.W    R1,?_67
        MOV      R0,R6
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R2,#+0
        MOVS     R1,#+20
        MOV      R0,SP
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        ADR.N    R7,??DataTable182  ;; 0x25, 0x66, 0x00, 0x00
        MOV      R0,R8
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R1,R7
        MOV      R0,SP
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,SP
        MOV      R0,R6
          CFI FunCall strcat
        BL       strcat
        ADR.N    R1,??DataTable184_1  ;; 0x20, 0x59, 0x00, 0x00
        MOV      R0,R6
          CFI FunCall strcat
        BL       strcat
        MOVS     R2,#+0
        MOVS     R1,#+20
        MOV      R0,SP
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        MOV      R0,R4
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R1,R7
        MOV      R0,SP
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,SP
        MOV      R0,R6
          CFI FunCall strcat
        BL       strcat
        ADD      R0,R5,#+149
        LDR.W    R1,??DataTable192_10
        STR      R0,[R1, #+40]
          CFI FunCall _Z11gcode_G0_G1v
        BL       _Z11gcode_G0_G1v
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        ADD      SP,SP,#+24
          CFI CFA R13+24
        POP      {R4-R8,PC}       ;; return
          CFI EndBlock cfiBlock114

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable179:
        DC32     echomagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_67:
        DC8 "G1 X"
        DC8 0, 0, 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock115 Using cfiCommon0
          CFI Function mks_moveZ
        THUMB
// __interwork __softfp void mks_moveZ(float)
mks_moveZ:
        PUSH     {R3-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+20
        SUB      SP,SP,#+20
          CFI CFA R13+40
        MOV      R4,R0
        LDR.N    R5,??DataTable183_2
        ADD      R6,R5,#+146
        MOVS     R2,#+0
        MOVS     R1,#+96
        MOV      R0,R6
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
        MOVS     R2,#+5
        ADR.W    R1,?_69
        MOV      R0,R6
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R2,#+0
        MOVS     R1,#+20
        MOV      R0,SP
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        LDR      R1,[R5, #+96]
        MOV      R0,R4
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        ADR.N    R1,??DataTable182  ;; 0x25, 0x66, 0x00, 0x00
        MOV      R0,SP
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,SP
        MOV      R0,R6
          CFI FunCall strcat
        BL       strcat
        ADD      R0,R5,#+149
        LDR.W    R1,??DataTable192_10
        STR      R0,[R1, #+40]
          CFI FunCall _Z11gcode_G0_G1v
        BL       _Z11gcode_G0_G1v
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        ADD      SP,SP,#+24
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock115

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable180:
        DC8      0x25, 0x64, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable180_1:
        DC32     thermalManager

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_69:
        DC8 "G1 Z"
        DC8 0, 0, 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock116 Using cfiCommon0
          CFI Function _Z7mks_G28Pc
        THUMB
// __interwork __softfp void mks_G28(char *)
_Z7mks_G28Pc:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R4,R0
        LDR.N    R5,??DataTable183_2
        ADD      R6,R5,#+146
        MOVS     R2,#+0
        MOVS     R1,#+96
        MOV      R0,R6
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
        MOV      R1,R4
        MOV      R0,R6
          CFI FunCall strcpy
        BL       strcpy
        ADD      R0,R5,#+150
        LDR.W    R1,??DataTable192_10
        STR      R0,[R1, #+40]
          CFI FunCall _Z9gcode_G28v
        BL       _Z9gcode_G28v
        LDR.W    R4,??DataTable192_12
        LDRB     R0,[R4, #+0]
        TST      R0,#0x3E
        BEQ.N    ??mks_G28_0
        CMP      R0,#+16
        BEQ.N    ??mks_G28_0
        MOVS     R0,#+1
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
        LDRSH    R0,[R4, #+24]
        CMP      R0,#+2
        BEQ.N    ??mks_G28_0
        LDRB     R0,[R4, #+0]
        LSLS     R0,R0,#+27
        BPL.N    ??mks_G28_0
        MOVS     R0,#+90
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??mks_G28_0
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z17set_z_fade_heightf
        B.W      _Z17set_z_fade_heightf
          CFI R4 Frame(CFA, -16)
          CFI R5 Frame(CFA, -12)
          CFI R6 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??mks_G28_0:
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock116

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock117 Using cfiCommon0
          CFI Function mks_contiuePrintPause
        THUMB
// __interwork __softfp void mks_contiuePrintPause()
mks_contiuePrintPause:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R0,#+1
        LDR.W    R1,??DataTable192_8
        STRB     R0,[R1, #+2]
          CFI FunCall _Z18mks_setTemperaturev
        BL       _Z18mks_setTemperaturev
        ADR.W    R0,?_70
          CFI FunCall _Z7mks_G28Pc
        BL       _Z7mks_G28Pc
        LDR.N    R4,??DataTable183_2
        LDR      R0,[R4, #+64]
          CFI FunCall mks_preExtrude
        BL       mks_preExtrude
        LDR      R1,[R4, #+92]
        LDR      R0,[R4, #+88]
          CFI FunCall mks_moveXY
        BL       mks_moveXY
          CFI FunCall mks_setPositionZ
        BL       mks_setPositionZ
        MOVS     R0,#+0
          CFI FunCall mks_moveZ
        BL       mks_moveZ
          CFI FunCall _Z15mks_setFeedratev
        BL       _Z15mks_setFeedratev
        LDRB     R1,[R4, #+124]
        LDR.W    R0,??DataTable189_1
        STR      R1,[R0, #+0]
        MOVW     R0,#+10000
        MULS     R1,R0,R1
        MOVS     R0,#+255
        SDIV     R0,R1,R0
        LDR.W    R1,??DataTable192_13  ;; 0x40012c34
        STR      R0,[R1, #+0]
        MOVS     R1,#+0
        ADD      R0,R4,#+20
          CFI FunCall _Z13lcd_setstatusPKcb
        BL       _Z13lcd_setstatusPKcb
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z9gcode_M24v
        B.W      _Z9gcode_M24v
          CFI EndBlock cfiBlock117

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable182:
        DC8      0x25, 0x66, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock118 Using cfiCommon0
          CFI Function mks_contiuePrintPwdwn
        THUMB
// __interwork __softfp void mks_contiuePrintPwdwn()
mks_contiuePrintPwdwn:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R0,#+1
        LDR.W    R1,??DataTable192_8
        STRB     R0,[R1, #+2]
          CFI FunCall _Z18mks_setTemperaturev
        BL       _Z18mks_setTemperaturev
          CFI FunCall mks_setPositionZ
        BL       mks_setPositionZ
        MOV      R0,#-1073741824
          CFI FunCall mks_preExtrude
        BL       mks_preExtrude
        LDR.N    R5,??DataTable183_2
        LDR      R0,[R5, #+60]
          CFI FunCall mks_moveZ
        BL       mks_moveZ
        ADR.W    R0,?_70
          CFI FunCall _Z7mks_G28Pc
        BL       _Z7mks_G28Pc
        MOVW     R0,#+3000
          CFI FunCall HAL_Delay
        BL       HAL_Delay
        LDR      R0,[R5, #+64]
          CFI FunCall mks_preExtrude
        BL       mks_preExtrude
        LDR      R1,[R5, #+92]
        LDR      R0,[R5, #+88]
          CFI FunCall mks_moveXY
        BL       mks_moveXY
        MOVS     R0,#+0
          CFI FunCall mks_moveZ
        BL       mks_moveZ
          CFI FunCall _Z15mks_setFeedratev
        BL       _Z15mks_setFeedratev
        ADD      R4,R5,#+112
        LDRB     R1,[R4, #+12]
        LDR.W    R0,??DataTable189_1
        STR      R1,[R0, #+0]
        MOVW     R0,#+10000
        MULS     R1,R0,R1
        MOVS     R0,#+255
        SDIV     R0,R1,R0
        LDR.W    R1,??DataTable192_13  ;; 0x40012c34
        STR      R0,[R1, #+0]
        MOVS     R1,#+0
        ADD      R0,R5,#+20
          CFI FunCall _Z13lcd_setstatusPKcb
        BL       _Z13lcd_setstatusPKcb
          CFI FunCall _Z9gcode_M24v
        BL       _Z9gcode_M24v
        MOVS     R0,#+0
        STRB     R0,[R4, #+0]
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock118

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable183:
        DC32     blink_time

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable183_1:
        DC32     mksCfg+0xD4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable183_2:
        DC32     mksReprint

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_70:
        DC8 "G28 X0 Y0"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock119 Using cfiCommon0
          CFI Function mks_contiuePrintDelta
        THUMB
// __interwork __softfp void mks_contiuePrintDelta()
mks_contiuePrintDelta:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R0,#+1
        LDR.W    R1,??DataTable192_8
        STRB     R0,[R1, #+2]
          CFI FunCall _Z18mks_setTemperaturev
        BL       _Z18mks_setTemperaturev
        ADR.N    R0,??DataTable188  ;; "G28"
          CFI FunCall _Z7mks_G28Pc
        BL       _Z7mks_G28Pc
        LDR.W    R5,??DataTable192_2
        LDR      R0,[R5, #+60]
          CFI FunCall mks_moveZ
        BL       mks_moveZ
        LDR      R0,[R5, #+64]
          CFI FunCall mks_preExtrude
        BL       mks_preExtrude
        LDR      R1,[R5, #+92]
        LDR      R0,[R5, #+88]
          CFI FunCall mks_moveXY
        BL       mks_moveXY
        MOVS     R0,#+0
          CFI FunCall mks_moveZ
        BL       mks_moveZ
          CFI FunCall _Z15mks_setFeedratev
        BL       _Z15mks_setFeedratev
        ADD      R4,R5,#+112
        LDRB     R1,[R4, #+12]
        LDR.W    R0,??DataTable189_1
        STR      R1,[R0, #+0]
        MOVW     R0,#+10000
        MULS     R1,R0,R1
        MOVS     R0,#+255
        SDIV     R0,R1,R0
        LDR.W    R1,??DataTable192_13  ;; 0x40012c34
        STR      R0,[R1, #+0]
        MOVS     R1,#+0
        ADD      R0,R5,#+20
          CFI FunCall _Z13lcd_setstatusPKcb
        BL       _Z13lcd_setstatusPKcb
          CFI FunCall _Z9gcode_M24v
        BL       _Z9gcode_M24v
        MOVS     R0,#+0
        STRB     R0,[R4, #+0]
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock119

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable184:
        DC32     command_queue

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable184_1:
        DC8      0x20, 0x59, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable184_2:
        DC32     _ZN11Temperature18target_temperatureE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable184_3:
        DC32     _ZN11Temperature22target_temperature_bedE

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock120 Using cfiCommon0
          CFI Function _Z19mks_getPositionXYZEv
        THUMB
// __interwork __softfp void mks_getPositionXYZE()
_Z19mks_getPositionXYZEv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        LDR.W    R5,??DataTable192_8
        LDR.W    R4,??DataTable192_2
        LDR      R1,[R4, #+108]
        MOV      R0,R5
          CFI FunCall _ZN10CardReader8setIndexEl
        BL       _ZN10CardReader8setIndexEl
        MOVS     R0,#+1
        STRB     R0,[R5, #+2]
          CFI FunCall _Z19get_sdcard_commandsv
        BL       _Z19get_sdcard_commandsv
        MOVS     R0,#+0
        STRB     R0,[R5, #+2]
        STRB     R0,[R4, #+112]
        MOV      R2,R0
        B.N      ??mks_getPositionXYZE_0
??mks_getPositionXYZE_1:
        LDR.W    R1,??DataTable192_11
        ADD      R3,R1,#+8
        STR      R2,[R3, R0, LSL #+2]
        ADDS     R1,R1,#+24
        STR      R2,[R1, R0, LSL #+2]
        ADDS     R0,R0,#+1
??mks_getPositionXYZE_0:
        CMP      R0,#+4
        BLT.N    ??mks_getPositionXYZE_1
        MOV      R5,R2
        B.N      ??mks_getPositionXYZE_2
??mks_getPositionXYZE_3:
        ADD      R2,R4,R3, LSL #+2
        LDR      R0,[R2, #+88]
        BIC      R0,R0,#0x80000000
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??mks_getPositionXYZE_4
        LDR.W    R0,??DataTable192_14
        LDR      R6,[R0, R3, LSL #+2]
        BIC      R0,R6,#0x80000000
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??mks_getPositionXYZE_4
        STR      R6,[R2, #+88]
??mks_getPositionXYZE_4:
        ADDS     R3,R3,#+1
??mks_getPositionXYZE_5:
        CMP      R3,#+4
        BLT.N    ??mks_getPositionXYZE_3
        ADDS     R5,R5,#+1
??mks_getPositionXYZE_2:
        MOV      R0,R5
        UXTB     R0,R0
        CMP      R0,#+4
        BGE.N    ??mks_getPositionXYZE_6
        LDR.W    R1,??DataTable192_15
        ADD      R2,R0,R0, LSL #+1
        ADD      R0,R1,R2, LSL #+5
        LDR.W    R1,??DataTable192_10
        STR      R0,[R1, #+40]
          CFI FunCall _Z21gcode_get_destinationv
        BL       _Z21gcode_get_destinationv
        MOVS     R3,#+0
        LDR.W    R1,??DataTable192_7  ;; 0x38d1b718
        B.N      ??mks_getPositionXYZE_5
??mks_getPositionXYZE_6:
        LDR      R0,[R4, #+96]
        STR      R0,[R4, #+80]
        LDR      R0,[R4, #+100]
        STR      R0,[R4, #+84]
        MOVS     R1,#+0
        MOV      R2,R1
        B.N      ??mks_getPositionXYZE_7
??mks_getPositionXYZE_8:
        LDR.W    R0,??DataTable192_11
        ADD      R3,R0,#+8
        STR      R2,[R3, R1, LSL #+2]
        ADDS     R0,R0,#+24
        STR      R2,[R0, R1, LSL #+2]
        ADDS     R1,R1,#+1
??mks_getPositionXYZE_7:
        CMP      R1,#+4
        BLT.N    ??mks_getPositionXYZE_8
        MOV      R4,R2
        B.N      ??mks_getPositionXYZE_9
??mks_getPositionXYZE_10:
        MOVS     R2,#+0
        MOVS     R1,#+96
        LDR.W    R0,??DataTable192_15
        ADD      R3,R4,R4, LSL #+1
        ADD      R0,R0,R3, LSL #+5
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
        ADDS     R4,R4,#+1
??mks_getPositionXYZE_9:
        CMP      R4,#+4
        BLT.N    ??mks_getPositionXYZE_10
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z19clear_command_queuev
        B.W      _Z19clear_command_queuev
          CFI EndBlock cfiBlock120

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock121 Using cfiCommon0
          CFI Function mks_clearDir
        THUMB
// __interwork __softfp void mks_clearDir()
mks_clearDir:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        SUB      SP,SP,#+32
          CFI CFA R13+40
        LDR.W    R4,??DataTable192_2
        B.N      ??mks_clearDir_0
??mks_clearDir_1:
        ADDS     R1,R0,#+1
        MOV      R0,SP
          CFI FunCall strcpy
        BL       strcpy
        MOV      R1,R0
        ADD      R0,R4,#+20
          CFI FunCall strcpy
        BL       strcpy
??mks_clearDir_0:
        ADR.N    R1,??DataTable189  ;; "/"
        ADD      R0,R4,#+20
          CFI FunCall __iar_Strstr
        BL       __iar_Strstr
        CMP      R0,#+0
        BNE.N    ??mks_clearDir_1
        ADD      SP,SP,#+32
          CFI CFA R13+8
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock121

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable186:
        DC32     0x40a00000

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock122 Using cfiCommon0
          CFI Function mks_contiuePrint_UI
        THUMB
// __interwork __softfp void mks_contiuePrint_UI()
mks_contiuePrint_UI:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOVS     R1,#+0
        ADR.W    R0,?_72
          CFI FunCall _Z13lcd_setstatusPKcb
        BL       _Z13lcd_setstatusPKcb
        LDR.W    R4,??DataTable192_8
        LDR.W    R5,??DataTable192_2
        MOVS     R3,#+0
        MOVS     R2,#+1
        ADD      R1,R5,#+20
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8openFileEPcbb
        BL       _ZN10CardReader8openFileEPcbb
        MOV      R0,R4
          CFI FunCall _ZN10CardReader10isFileOpenEv
        BL       _ZN10CardReader10isFileOpenEv
        CMP      R0,#+0
        BNE.N    ??mks_contiuePrint_UI_0
        ADD      R1,R5,#+104
        MOVS     R0,#+166
        STRB     R0,[R1, #+0]
        MOVS     R2,#+1
        MOV      R0,#+1400
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R1,#+0
        ADR.W    R0,?_73
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z13lcd_setstatusPKcb
        B.W      _Z13lcd_setstatusPKcb
          CFI R4 Frame(CFA, -16)
          CFI R5 Frame(CFA, -12)
          CFI R6 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??mks_contiuePrint_UI_0:
        MOVS     R0,#+0
        STRB     R0,[R4, #+2]
        LDRSB    R0,[R5, #+1044]
        CMP      R0,#+2
        BNE.N    ??mks_contiuePrint_UI_1
          CFI FunCall _Z19mks_getPositionXYZEv
        BL       _Z19mks_getPositionXYZEv
??mks_contiuePrint_UI_1:
        ADD      R6,R5,#+104
        LDR      R1,[R6, #+4]
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8setIndexEl
        BL       _ZN10CardReader8setIndexEl
        LDR.W    R4,??DataTable192_11
        LDR      R3,[R6, #+32]
        LDR      R2,[R6, #+28]
        LDR      R1,[R6, #+24]
        ADD      R0,R4,#+904
          CFI FunCall _ZN9Stopwatch7setTimeEmmm
        BL       _ZN9Stopwatch7setTimeEmmm
        cpsid i
        LDR      R0,[R6, #+36]
          CFI FunCall HAL_SetTick
        BL       HAL_SetTick
        cpsie i
        LDR      R0,[R5, #+72]
        STR      R0,[R4, #+8]
        LDR      R0,[R5, #+76]
        STR      R0,[R4, #+12]
        LDR      R0,[R5, #+80]
        STR      R0,[R4, #+16]
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall mks_clearDir
        B.N      mks_clearDir
          CFI EndBlock cfiBlock122

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock123 Using cfiCommon0
          CFI Function mks_rePrintCheck
        THUMB
// __interwork __softfp void mks_rePrintCheck()
mks_rePrintCheck:
        LDR.W    R0,??DataTable192_8
        LDRB     R0,[R0, #+3]
        CMP      R0,#+0
        BNE.N    ??mks_rePrintCheck_0
        BX       LR
??mks_rePrintCheck_0:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.W    R4,??DataTable192_2
        ADD      R5,R4,#+104
        MOVS     R2,#+1
        MOV      R1,R5
        MOV      R0,#+1400
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDRB     R0,[R5, #+0]
        CMP      R0,#+169
        BNE.N    ??mks_rePrintCheck_1
        MOVS     R0,#+170
        STRB     R0,[R5, #+0]
          CFI FunCall mks_ReadFromEpr
        BL       mks_ReadFromEpr
        LDR      R0,[R5, #+4]
        MOVW     R1,#+5001
        CMP      R0,R1
        BCC.N    ??mks_rePrintCheck_2
        MOVS     R0,#+1
        STRB     R0,[R4, #+1044]
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall mks_contiuePrint_UI
        B.N      mks_contiuePrint_UI
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??mks_rePrintCheck_1:
        CMP      R0,#+167
        BNE.N    ??mks_rePrintCheck_2
        MOVS     R0,#+170
        STRB     R0,[R5, #+0]
        MOVS     R2,#+30
        ADD      R1,R4,#+20
        MOVW     R0,#+1462
          CFI FunCall epr_read_data
        BL       epr_read_data
          CFI FunCall mks_ReadFromFile
        BL       mks_ReadFromFile
        CMP      R0,#+0
        BEQ.N    ??mks_rePrintCheck_3
        LDR      R0,[R5, #+4]
        MOVW     R1,#+5001
        CMP      R0,R1
        BCC.N    ??mks_rePrintCheck_3
        MOVS     R0,#+2
        STRB     R0,[R4, #+1044]
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall mks_contiuePrint_UI
        B.N      mks_contiuePrint_UI
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??mks_rePrintCheck_3:
        MOVS     R0,#+166
        STRB     R0,[R5, #+0]
        MOVS     R2,#+1
        MOV      R1,R5
        MOV      R0,#+1400
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R1,#+0
        LDR.N    R0,??DataTable192_16
        POP      {R2,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z13lcd_setstatusPKcb
        B.W      _Z13lcd_setstatusPKcb
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??mks_rePrintCheck_2:
        MOVS     R0,#+166
        STRB     R0,[R5, #+0]
        MOVS     R2,#+1
        MOV      R1,R5
        MOV      R0,#+1400
        POP      {R3-R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall epr_write_data
        B.W      epr_write_data
          CFI EndBlock cfiBlock123

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable188:
        DC8      "G28"

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock124 Using cfiCommon0
          CFI Function mks_WriteToFile
        THUMB
// __interwork __softfp void mks_WriteToFile()
mks_WriteToFile:
        PUSH     {R3-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+28
        SUB      SP,SP,#+20
          CFI CFA R13+48
        LDR.N    R5,??DataTable192_2
        ADD      R4,R5,#+244
        MOVS     R3,#+0
        MOV      R2,R3
        ADR.W    R1,?_74
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8openFileEPcbb
        BL       _ZN10CardReader8openFileEPcbb
        MOV      R0,R4
          CFI FunCall _ZN10CardReader10isFileOpenEv
        BL       _ZN10CardReader10isFileOpenEv
        CMP      R0,#+0
        BEQ.W    ??mks_WriteToFile_0
        MOVS     R2,#+0
        MOVS     R1,#+20
        MOV      R0,SP
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        MOVS     R2,#+6
        ADR.W    R1,?_75
        MOV      R0,SP
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        MOV      R1,SP
        MOV      R0,R4
          CFI FunCall _ZN10CardReader13write_commandEPc
        BL       _ZN10CardReader13write_commandEPc
        MOVS     R2,#+0
        MOVS     R1,#+20
        MOV      R0,SP
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        ADR.N    R6,??DataTable192  ;; 0x25, 0x64, 0x00, 0x00
        LDR      R2,[R5, #+108]
        MOV      R1,R6
        MOV      R0,SP
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,SP
        MOV      R0,R4
          CFI FunCall _ZN10CardReader13write_commandEPc
        BL       _ZN10CardReader13write_commandEPc
        MOVS     R2,#+0
        MOVS     R1,#+20
        MOV      R0,SP
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        LDR.N    R0,??DataTable192_17
        LDR      R2,[R0, #+0]
        MOV      R1,R6
        MOV      R0,SP
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,SP
        MOV      R0,R4
          CFI FunCall _ZN10CardReader13write_commandEPc
        BL       _ZN10CardReader13write_commandEPc
        MOVS     R2,#+0
        MOVS     R1,#+20
        MOV      R0,SP
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        LDR.N    R0,??DataTable192_18
        LDR      R2,[R0, #+0]
        MOV      R1,R6
        MOV      R0,SP
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,SP
        MOV      R0,R4
          CFI FunCall _ZN10CardReader13write_commandEPc
        BL       _ZN10CardReader13write_commandEPc
        ADD      R7,R5,#+132
        LDR.W    R8,??DataTable192_11
        ADD      R3,R5,#+136
        MOV      R2,R7
        ADD      R1,R5,#+128
        ADD      R0,R8,#+904
          CFI FunCall _ZN9Stopwatch7getTimeEPmS0_S0_
        BL       _ZN9Stopwatch7getTimeEPmS0_S0_
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        STR      R0,[R7, #+8]
        LDR      R1,[R7, #+4]
        LDR      R2,[R7, #+0]
        CMP      R1,R2
        BCS.N    ??mks_WriteToFile_1
        STR      R0,[R7, #+4]
??mks_WriteToFile_1:
        MOVS     R2,#+0
        MOVS     R1,#+20
        MOV      R0,SP
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        LDR      R2,[R5, #+128]
        MOV      R1,R6
        MOV      R0,SP
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,SP
        MOV      R0,R4
          CFI FunCall _ZN10CardReader13write_commandEPc
        BL       _ZN10CardReader13write_commandEPc
        MOVS     R2,#+0
        MOVS     R1,#+20
        MOV      R0,SP
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        LDR      R2,[R7, #+0]
        MOV      R1,R6
        MOV      R0,SP
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,SP
        MOV      R0,R4
          CFI FunCall _ZN10CardReader13write_commandEPc
        BL       _ZN10CardReader13write_commandEPc
        MOVS     R2,#+0
        MOVS     R1,#+20
        MOV      R0,SP
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        LDR      R2,[R7, #+4]
        MOV      R1,R6
        MOV      R0,SP
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,SP
        MOV      R0,R4
          CFI FunCall _ZN10CardReader13write_commandEPc
        BL       _ZN10CardReader13write_commandEPc
        MOVS     R2,#+0
        MOVS     R1,#+20
        MOV      R0,SP
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        LDR      R2,[R7, #+8]
        MOV      R1,R6
        MOV      R0,SP
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,SP
        MOV      R0,R4
          CFI FunCall _ZN10CardReader13write_commandEPc
        BL       _ZN10CardReader13write_commandEPc
        MOVS     R2,#+0
        MOVS     R1,#+20
        MOV      R0,SP
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        LDR.N    R0,??DataTable189_1
        LDR      R2,[R0, #+0]
        MOV      R1,R6
        MOV      R0,SP
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,SP
        MOV      R0,R4
          CFI FunCall _ZN10CardReader13write_commandEPc
        BL       _ZN10CardReader13write_commandEPc
        MOVS     R2,#+0
        MOVS     R1,#+20
        MOV      R0,SP
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        LDR      R0,[R8, #+116]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        ADR.N    R1,??DataTable192_3  ;; 0x25, 0x66, 0x00, 0x00
        MOV      R0,SP
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,SP
        MOV      R0,R4
          CFI FunCall _ZN10CardReader13write_commandEPc
        BL       _ZN10CardReader13write_commandEPc
        MOVS     R2,#+0
        MOVS     R1,#+20
        MOV      R0,SP
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        MOVS     R2,#+4
        ADR.N    R1,??DataTable192_5  ;; "end"
        MOV      R0,SP
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        MOV      R1,SP
        MOV      R0,R4
          CFI FunCall _ZN10CardReader13write_commandEPc
        BL       _ZN10CardReader13write_commandEPc
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall _ZN10CardReader9closefileEb
        BL       _ZN10CardReader9closefileEb
??mks_WriteToFile_0:
        ADD      SP,SP,#+24
          CFI CFA R13+24
        POP      {R4-R8,PC}       ;; return
          CFI EndBlock cfiBlock124

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable189:
        DC8      "/",0x0,0x0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable189_1:
        DC32     fanSpeeds

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock125 Using cfiCommon0
          CFI Function _Z16mks_get_commandsv
        THUMB
// __interwork __softfp bool mks_get_commands()
_Z16mks_get_commandsv:
        PUSH     {R3-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+36
        SUB      SP,SP,#+20
          CFI CFA R13+56
        MOVS     R7,#+0
        MOV      R10,R7
        LDR.N    R5,??DataTable192_2
        ADD      R6,R5,#+244
        MOV      R0,R6
          CFI FunCall _ZN10CardReader3eofEv
        BL       _ZN10CardReader3eofEv
        MOV      R8,R0
        MOV      R4,R7
        B.N      ??mks_get_commands_1
??mks_get_commands_2:
        ADR.N    R1,??DataTable192_5  ;; "end"
        MOV      R0,SP
          CFI FunCall strcmp
        BL       strcmp
        CMP      R0,#+0
        BNE.N    ??mks_get_commands_3
        MOVS     R4,#+1
??mks_get_commands_3:
        MOV      R10,#+0
        MOV      R2,R10
        MOVS     R1,#+20
        MOV      R0,SP
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        ADDS     R7,R7,#+1
??mks_get_commands_1:
        CMP      R8,#+0
        BNE.N    ??mks_get_commands_4
        MOV      R0,R6
          CFI FunCall _ZN10CardReader3getEv
        BL       _ZN10CardReader3getEv
        MOV      R9,R0
        MOV      R0,R6
          CFI FunCall _ZN10CardReader3eofEv
        BL       _ZN10CardReader3eofEv
        MOV      R8,R0
        MOV      R0,R10
        UXTH     R0,R0
        MOV      R1,R9
        SXTB     R1,R1
        CMP      R1,#+10
        BNE.N    ??mks_get_commands_5
        MOVS     R1,#+0
        MOV      R2,SP
        ADD      R0,R2,R0
        STRB     R1,[R0, #-1]
        MOV      R0,R7
        SXTB     R0,R0
        SUBS     R0,R0,#+1
        CMP      R0,#+9
        BHI.N    ??mks_get_commands_3
        TBB      [PC, R0]
        DATA
??mks_get_commands_0:
        DC8      0x7,0xC,0x13,0x1A
        DC8      0x21,0x28,0x2F,0x36
        DC8      0x3D,0x6
        THUMB
??mks_get_commands_6:
        B.N      ??mks_get_commands_3
??mks_get_commands_7:
        B.N      ??mks_get_commands_2
??mks_get_commands_8:
        MOV      R0,SP
          CFI FunCall atoi
        BL       atoi
        STR      R0,[R5, #+108]
        B.N      ??mks_get_commands_3
??mks_get_commands_9:
        MOV      R0,SP
          CFI FunCall atoi
        BL       atoi
        ADD      R1,R5,#+108
        STRH     R0,[R1, #+6]
        B.N      ??mks_get_commands_3
??mks_get_commands_10:
        MOV      R0,SP
          CFI FunCall atoi
        BL       atoi
        ADD      R1,R5,#+108
        STRH     R0,[R1, #+8]
        B.N      ??mks_get_commands_3
??mks_get_commands_11:
        MOV      R0,SP
          CFI FunCall atoi
        BL       atoi
        ADD      R1,R5,#+108
        STR      R0,[R1, #+20]
        B.N      ??mks_get_commands_3
??mks_get_commands_12:
        MOV      R0,SP
          CFI FunCall atoi
        BL       atoi
        ADD      R1,R5,#+108
        STR      R0,[R1, #+24]
        B.N      ??mks_get_commands_3
??mks_get_commands_13:
        MOV      R0,SP
          CFI FunCall atoi
        BL       atoi
        ADD      R1,R5,#+108
        STR      R0,[R1, #+28]
        B.N      ??mks_get_commands_3
??mks_get_commands_14:
        MOV      R0,SP
          CFI FunCall atoi
        BL       atoi
        ADD      R1,R5,#+108
        STR      R0,[R1, #+32]
        B.N      ??mks_get_commands_3
??mks_get_commands_15:
        MOV      R0,SP
          CFI FunCall atoi
        BL       atoi
        ADD      R1,R5,#+108
        STRB     R0,[R1, #+16]
        B.N      ??mks_get_commands_3
??mks_get_commands_16:
        MOV      R0,SP
          CFI FunCall atof
        BL       atof
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        ADD      R1,R5,#+108
        STR      R0,[R1, #+12]
        B.N      ??mks_get_commands_3
??mks_get_commands_5:
        MOV      R1,SP
        STRB     R9,[R1, R0]
        ADD      R10,R10,#+1
        B.N      ??mks_get_commands_1
??mks_get_commands_4:
        MOV      R0,R4
        ADD      SP,SP,#+24
          CFI CFA R13+32
        POP      {R4-R10,PC}      ;; return
          CFI EndBlock cfiBlock125

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock126 Using cfiCommon0
          CFI Function mks_ReadFromFile
        THUMB
// __interwork __softfp bool mks_ReadFromFile()
mks_ReadFromFile:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R4,#+0
        LDR.N    R5,??DataTable192_19
        MOV      R3,R4
        MOVS     R2,#+1
        ADR.W    R1,?_74
        MOV      R0,R5
          CFI FunCall _ZN10CardReader8openFileEPcbb
        BL       _ZN10CardReader8openFileEPcbb
        MOV      R0,R5
          CFI FunCall _ZN10CardReader10isFileOpenEv
        BL       _ZN10CardReader10isFileOpenEv
        CMP      R0,#+0
        BEQ.N    ??mks_ReadFromFile_0
          CFI FunCall _Z16mks_get_commandsv
        BL       _Z16mks_get_commandsv
        MOV      R4,R0
        MOVS     R1,#+1
        MOV      R0,R5
          CFI FunCall _ZN10CardReader9closefileEb
        BL       _ZN10CardReader9closefileEb
??mks_ReadFromFile_0:
        MOV      R0,R4
        POP      {R1,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock126

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock127 Using cfiCommon0
          CFI Function mks_clearFile
        THUMB
// __interwork __softfp void mks_clearFile()
mks_clearFile:
        PUSH     {R3,R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+12
        SUB      SP,SP,#+20
          CFI CFA R13+32
        MOV      R0,SP
        ADR.W    R1,?_77
        MOVS     R2,#+20
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        LDR.N    R4,??DataTable192_19
        MOVS     R3,#+0
        MOV      R2,R3
        ADR.W    R1,?_74
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8openFileEPcbb
        BL       _ZN10CardReader8openFileEPcbb
        MOV      R1,SP
        MOV      R0,R4
          CFI FunCall _ZN10CardReader13write_commandEPc
        BL       _ZN10CardReader13write_commandEPc
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall _ZN10CardReader9closefileEb
        BL       _ZN10CardReader9closefileEb
        ADD      SP,SP,#+24
          CFI CFA R13+8
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock127

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192:
        DC8      0x25, 0x64, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_1:
        DC32     MSG_PAUSE_PRINT

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_2:
        DC32     mksReprint

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_3:
        DC8      0x25, 0x66, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_4:
        DC32     htim2

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_5:
        DC8      "end"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_6:
        DC32     _ZN7Stepper13current_blockE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_7:
        DC32     0x38d1b718

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_8:
        DC32     card

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_9:
        DC32     mksCfg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_10:
        DC32     axis_relative_modes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_11:
        DC32     mks_heating_busy

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_12:
        DC32     mksCfg+0x40

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_13:
        DC32     0x40012c34

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_14:
        DC32     mks_heating_busy+0x18

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_15:
        DC32     command_queue

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_16:
        DC32     WELCOME_MSG

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_17:
        DC32     _ZN11Temperature18target_temperatureE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_18:
        DC32     _ZN11Temperature22target_temperature_bedE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_19:
        DC32     mksReprint+0xF4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_72:
        DC8 "Resume print?"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_73:
        DC8 "Resume print failed!"
        DC8 0, 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_74:
        DC8 "mks_pft.sys"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_75:
        DC8 "start"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
?_77:
        DC8 "clear"
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z5isnanf
          CFI Block cfiBlock128 Using cfiCommon0
          CFI Function _Z5isnanf
          CFI NoCalls
        THUMB
// __interwork __softfp bool isnan(float)
_Z5isnanf:
        LSLS     R0,R0,#+1
        MOV      R1,R0
        ASRS     R1,R1,#+24
        ADDS     R1,R1,#+1
        BEQ.N    ??isnan_0
        MOVS     R0,#+0
        B.N      ??isnan_1
??isnan_0:
        LSLS     R0,R0,#+8
??isnan_1:
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
        BX       LR               ;; return
          CFI EndBlock cfiBlock128

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN12MarlinSerial9availableEv
          CFI Block cfiBlock129 Using cfiCommon0
          CFI Function _ZN12MarlinSerial9availableEv
          CFI FunCall BSP_UartGetNbRxAvalaibleBytes
        THUMB
// __interwork __softfp int MarlinSerial::available()
_ZN12MarlinSerial9availableEv:
        B.W      BSP_UartGetNbRxAvalaibleBytes
          CFI EndBlock cfiBlock129

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN12MarlinSerial5writeEh
          CFI Block cfiBlock130 Using cfiCommon0
          CFI Function _ZN12MarlinSerial5writeEh
        THUMB
// __interwork __softfp void MarlinSerial::write(uint8_t)
_ZN12MarlinSerial5writeEh:
        PUSH     {R1,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R2,#+1
        MOV      R1,SP
          CFI FunCall BSP_UartIfQueueTxData
        BL       BSP_UartIfQueueTxData
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock130

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN12MarlinSerial5writeEPKc
          CFI Block cfiBlock131 Using cfiCommon0
          CFI Function _ZN12MarlinSerial5writeEPKc
        THUMB
// __interwork __softfp void MarlinSerial::write(char const *)
_ZN12MarlinSerial5writeEPKc:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        MOV      R5,R1
        MOV      R0,R5
          CFI FunCall strlen
        BL       strlen
        MOV      R2,R0
        UXTB     R2,R2
        MOV      R1,R5
        MOV      R0,R4
        POP      {R3-R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall BSP_UartIfQueueTxData
        B.W      BSP_UartIfQueueTxData
          CFI EndBlock cfiBlock131

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN12MarlinSerial5printEPKc
          CFI Block cfiBlock132 Using cfiCommon0
          CFI Function _ZN12MarlinSerial5printEPKc
        THUMB
// __interwork __softfp void MarlinSerial::print(char const *)
_ZN12MarlinSerial5printEPKc:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        MOV      R5,R1
        MOV      R0,R5
          CFI FunCall strlen
        BL       strlen
        CMP      R0,#+0
        BEQ.N    ??print_1
        LDR.N    R0,??print_0
        LDRB     R0,[R0, #+7]
        CMP      R0,#+0
        BNE.N    ??print_2
        MOV      R1,R5
        MOV      R0,R4
        POP      {R2,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN12MarlinSerial5writeEPKc
        B.W      _ZN12MarlinSerial5writeEPKc
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??print_2:
        MOV      R0,R5
          CFI FunCall strlen
        BL       strlen
        MOV      R2,R0
        MOV      R1,R5
        MOVS     R0,#+2
        POP      {R3-R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall package_to_wifi
        B.W      package_to_wifi
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??print_1:
        POP      {R0,R4,R5,PC}    ;; return
        Nop      
        DATA
??print_0:
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock132

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z17serial_echopair_PPKch
          CFI Block cfiBlock133 Using cfiCommon0
          CFI Function _Z17serial_echopair_PPKch
          CFI FunCall _Z17serial_echopair_PPKci
        THUMB
// __interwork __softfp void serial_echopair_P(char const *, uint8_t)
_Z17serial_echopair_PPKch:
        B.W      _Z17serial_echopair_PPKci
          CFI EndBlock cfiBlock133

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z17serial_echopair_PPKcb
          CFI Block cfiBlock134 Using cfiCommon0
          CFI Function _Z17serial_echopair_PPKcb
          CFI FunCall _Z17serial_echopair_PPKci
        THUMB
// __interwork __softfp void serial_echopair_P(char const *, bool)
_Z17serial_echopair_PPKcb:
        B.W      _Z17serial_echopair_PPKci
          CFI EndBlock cfiBlock134

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z14serialprintPGMPKc
          CFI Block cfiBlock135 Using cfiCommon0
          CFI Function _Z14serialprintPGMPKc
        THUMB
// __interwork __softfp void serialprintPGM(char const *)
_Z14serialprintPGMPKc:
        MOV      R1,R0
        LDR.N    R0,??serialprintPGM_0
        LDRB     R0,[R0, #+7]
        CMP      R0,#+0
        BNE.N    ??serialprintPGM_1
        LDR.N    R0,??serialprintPGM_0+0x4
          CFI FunCall _ZN12MarlinSerial5writeEPKc
        B.W      _ZN12MarlinSerial5writeEPKc
??serialprintPGM_1:
        LDR.N    R0,??serialprintPGM_0+0x8
          CFI FunCall _ZN12MarlinSerial5printEPKc
        B.W      _ZN12MarlinSerial5printEPKc
        Nop      
        DATA
??serialprintPGM_0:
        DC32     mks_heating_busy
        DC32     customizedSerial
        DC32     serial2
          CFI EndBlock cfiBlock135

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9IsRunningv
          CFI Block cfiBlock136 Using cfiCommon0
          CFI Function _Z9IsRunningv
          CFI NoCalls
        THUMB
// __interwork __softfp bool IsRunning()
_Z9IsRunningv:
        LDR.N    R0,??IsRunning_0
        LDRB     R0,[R0, #+0]
        BX       LR               ;; return
        Nop      
        DATA
??IsRunning_0:
        DC32     Running
          CFI EndBlock cfiBlock136

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9IsStoppedv
          CFI Block cfiBlock137 Using cfiCommon0
          CFI Function _Z9IsStoppedv
          CFI NoCalls
        THUMB
// __interwork __softfp bool IsStopped()
_Z9IsStoppedv:
        LDR.N    R0,??IsStopped_0
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        LSRS     R0,R0,#+31
        BX       LR               ;; return
        DATA
??IsStopped_0:
        DC32     Running
          CFI EndBlock cfiBlock137

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z19refresh_cmd_timeoutv
          CFI Block cfiBlock138 Using cfiCommon0
          CFI Function _Z19refresh_cmd_timeoutv
        THUMB
// __interwork __softfp void refresh_cmd_timeout()
_Z19refresh_cmd_timeoutv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        LDR.N    R1,??refresh_cmd_timeout_0
        STR      R0,[R1, #+56]
        POP      {R0,PC}          ;; return
        DATA
??refresh_cmd_timeout_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock138

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN7Planner14apply_levelingEPf
          CFI Block cfiBlock139 Using cfiCommon0
          CFI Function _ZN7Planner14apply_levelingEPf
        THUMB
// __interwork __softfp void Planner::apply_leveling(float *)
_ZN7Planner14apply_levelingEPf:
        ADD      R2,R0,#+8
        ADDS     R1,R0,#+4
          CFI FunCall _ZN7Planner14apply_levelingERfS0_S0_
        B.W      _ZN7Planner14apply_levelingERfS0_S0_
          CFI EndBlock cfiBlock139

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Planner11buffer_lineEfffRKfS1_h
          CFI Block cfiBlock140 Using cfiCommon0
          CFI Function _ZN7Planner11buffer_lineEfffRKfS1_h
        THUMB
// __interwork __softfp void Planner::buffer_line(float, float, float, float const &, float const &, uint8_t)
_ZN7Planner11buffer_lineEfffRKfS1_h:
        PUSH     {R0-R2,R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+20
        SUB      SP,SP,#+12
          CFI CFA R13+32
        MOV      R4,R3
        LDR.N    R0,??buffer_line_0
        LDRB     R1,[R0, #+0]
        TST      R1,#0x2E
        BEQ.N    ??buffer_line_1
        LDRSH    R0,[R0, #+24]
        CMP      R0,#+1
        BNE.N    ??buffer_line_1
        ADD      R2,SP,#+20
        ADD      R1,SP,#+16
        ADD      R0,SP,#+12
          CFI FunCall _ZN7Planner14apply_levelingERfS0_S0_
        BL       _ZN7Planner14apply_levelingERfS0_S0_
??buffer_line_1:
        LDR      R0,[SP, #+36]
        LDR      R1,[SP, #+32]
        STR      R0,[SP, #+4]
        LDR      R0,[R1, #+0]
        STR      R0,[SP, #+0]
        MOV      R3,R4
        ADD      R2,SP,#+20
        ADD      R1,SP,#+16
        ADD      R0,SP,#+12
          CFI FunCall _ZN7Planner12_buffer_lineERKfS1_S1_S1_fh
        BL       _ZN7Planner12_buffer_lineERKfS1_S1_S1_fh
        ADD      SP,SP,#+24
          CFI CFA R13+8
        POP      {R4,PC}          ;; return
        DATA
??buffer_line_0:
        DC32     mksCfg+0x40
          CFI EndBlock cfiBlock140

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Planner21buffer_line_kinematicEPKfRS0_h
          CFI Block cfiBlock141 Using cfiCommon0
          CFI Function _ZN7Planner21buffer_line_kinematicEPKfRS0_h
        THUMB
// __interwork __softfp void Planner::buffer_line_kinematic(float const *, float const &, uint8_t)
_ZN7Planner21buffer_line_kinematicEPKfRS0_h:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        SUB      SP,SP,#+24
          CFI CFA R13+48
        MOV      R4,R0
        MOV      R5,R1
        MOV      R6,R2
        LDR      R0,[R4, #+0]
        STR      R0,[SP, #+8]
        ADD      R0,SP,#+8
        LDR      R1,[R4, #+4]
        STR      R1,[R0, #+4]
        LDR      R1,[R4, #+8]
        STR      R1,[R0, #+8]
        LDR      R1,[R4, #+12]
        STR      R1,[R0, #+12]
        LDR.N    R7,??buffer_line_kinematic_0
        LDRB     R0,[R7, #+0]
        TST      R0,#0x2E
        BEQ.N    ??buffer_line_kinematic_1
        ADD      R0,SP,#+8
          CFI FunCall _ZN7Planner14apply_levelingEPf
        BL       _ZN7Planner14apply_levelingEPf
??buffer_line_kinematic_1:
        LDRSH    R0,[R7, #+24]
        MOVW     R1,#+770
        TST      R0,R1
        BEQ.N    ??buffer_line_kinematic_2
        CMP      R0,#+256
        ADD      R0,SP,#+8
        BNE.N    ??buffer_line_kinematic_3
          CFI FunCall _Z31inverse_kinematics_MORGAN_SCARAPKf
        BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
        B.N      ??buffer_line_kinematic_4
??buffer_line_kinematic_3:
          CFI FunCall _Z18inverse_kinematicsPKf
        BL       _Z18inverse_kinematicsPKf
??buffer_line_kinematic_4:
        LDR.N    R0,??buffer_line_kinematic_0+0x4
        STR      R6,[SP, #+4]
        LDR      R1,[R5, #+0]
        STR      R1,[SP, #+0]
        ADD      R3,R4,#+12
        ADD      R2,R0,#+112
        ADD      R1,R0,#+108
        ADDS     R0,R0,#+104
          CFI FunCall _ZN7Planner12_buffer_lineERKfS1_S1_S1_fh
        BL       _ZN7Planner12_buffer_lineERKfS1_S1_S1_fh
        B.N      ??buffer_line_kinematic_5
??buffer_line_kinematic_2:
        STR      R6,[SP, #+4]
        LDR      R0,[R5, #+0]
        STR      R0,[SP, #+0]
        ADD      R3,R4,#+12
        ADD      R2,SP,#+16
        ADD      R1,SP,#+12
        ADD      R0,SP,#+8
          CFI FunCall _ZN7Planner12_buffer_lineERKfS1_S1_S1_fh
        BL       _ZN7Planner12_buffer_lineERKfS1_S1_S1_fh
??buffer_line_kinematic_5:
        ADD      SP,SP,#+28
          CFI CFA R13+20
        POP      {R4-R7,PC}       ;; return
        Nop      
        DATA
??buffer_line_kinematic_0:
        DC32     mksCfg+0x40
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock141

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Planner15set_position_mmEfffRKf
          CFI Block cfiBlock142 Using cfiCommon0
          CFI Function _ZN7Planner15set_position_mmEfffRKf
        THUMB
// __interwork __softfp void Planner::set_position_mm(float, float, float, float const &)
_ZN7Planner15set_position_mmEfffRKf:
        PUSH     {R0-R2,R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+20
        SUB      SP,SP,#+4
          CFI CFA R13+24
        MOV      R4,R3
        LDR.N    R0,??set_position_mm_0
        LDRB     R1,[R0, #+0]
        TST      R1,#0x2E
        BEQ.N    ??set_position_mm_1
        LDRSH    R0,[R0, #+24]
        CMP      R0,#+1
        BNE.N    ??set_position_mm_1
        ADD      R2,SP,#+12
        ADD      R1,SP,#+8
        ADD      R0,SP,#+4
          CFI FunCall _ZN7Planner14apply_levelingERfS0_S0_
        BL       _ZN7Planner14apply_levelingERfS0_S0_
??set_position_mm_1:
        MOV      R3,R4
        ADD      R2,SP,#+12
        ADD      R1,SP,#+8
        ADD      R0,SP,#+4
          CFI FunCall _ZN7Planner16_set_position_mmERKfS1_S1_S1_
        BL       _ZN7Planner16_set_position_mmERKfS1_S1_S1_
        POP      {R0-R4,PC}       ;; return
        DATA
??set_position_mm_0:
        DC32     mksCfg+0x40
          CFI EndBlock cfiBlock142

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN7Planner17set_e_position_mmERKf
          CFI Block cfiBlock143 Using cfiCommon0
          CFI Function _ZN7Planner17set_e_position_mmERKf
        THUMB
// __interwork __softfp void Planner::set_e_position_mm(float const &)
_ZN7Planner17set_e_position_mmERKf:
        MOV      R1,R0
        MOVS     R0,#+3
          CFI FunCall _ZN7Planner15set_position_mmE8AxisEnumRKf
        B.W      _ZN7Planner15set_position_mmE8AxisEnumRKf
          CFI EndBlock cfiBlock143

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Planner13blocks_queuedEv
          CFI Block cfiBlock144 Using cfiCommon0
          CFI Function _ZN7Planner13blocks_queuedEv
          CFI NoCalls
        THUMB
// __interwork __softfp bool Planner::blocks_queued()
_ZN7Planner13blocks_queuedEv:
        LDR.N    R0,??blocks_queued_0
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??blocks_queued_0+0x4
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BEQ.N    ??blocks_queued_1
        MOVS     R0,#+1
        BX       LR
??blocks_queued_1:
        MOVS     R0,#+0
        BX       LR               ;; return
        DATA
??blocks_queued_0:
        DC32     _ZN7Planner17block_buffer_headE
        DC32     _ZN7Planner17block_buffer_tailE
          CFI EndBlock cfiBlock144

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Planner21discard_current_blockEv
          CFI Block cfiBlock145 Using cfiCommon0
          CFI Function _ZN7Planner21discard_current_blockEv
        THUMB
// __interwork __softfp void Planner::discard_current_block()
_ZN7Planner21discard_current_blockEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN7Planner13blocks_queuedEv
        BL       _ZN7Planner13blocks_queuedEv
        CMP      R0,#+0
        BEQ.N    ??discard_current_block_1
        LDR.N    R0,??discard_current_block_0
        LDRB     R1,[R0, #+0]
        ADDS     R1,R1,#+1
        AND      R1,R1,#0xF
        STRB     R1,[R0, #+0]
??discard_current_block_1:
        POP      {R0,PC}          ;; return
        DATA
??discard_current_block_0:
        DC32     _ZN7Planner17block_buffer_tailE
          CFI EndBlock cfiBlock145

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN7Stepper25get_axis_position_degreesE8AxisEnum
          CFI Block cfiBlock146 Using cfiCommon0
          CFI Function _ZN7Stepper25get_axis_position_degreesE8AxisEnum
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        THUMB
// __interwork __softfp float Stepper::get_axis_position_degrees(AxisEnum)
_ZN7Stepper25get_axis_position_degreesE8AxisEnum:
        B.W      _ZN7Stepper20get_axis_position_mmE8AxisEnum
          CFI EndBlock cfiBlock146

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN8Endstops15enable_globallyEb
          CFI Block cfiBlock147 Using cfiCommon0
          CFI Function _ZN8Endstops15enable_globallyEb
          CFI NoCalls
        THUMB
// __interwork __softfp void Endstops::enable_globally(bool)
_ZN8Endstops15enable_globallyEb:
        LDR.N    R1,??enable_globally_0
        STRB     R0,[R1, #+0]
        LDR.N    R1,??enable_globally_0+0x4
        STRB     R0,[R1, #+0]
        BX       LR               ;; return
        Nop      
        DATA
??enable_globally_0:
        DC32     _ZN8Endstops7enabledE
        DC32     _ZN8Endstops16enabled_globallyE
          CFI EndBlock cfiBlock147

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN8Endstops6enableEb
          CFI Block cfiBlock148 Using cfiCommon0
          CFI Function _ZN8Endstops6enableEb
          CFI NoCalls
        THUMB
// __interwork __softfp void Endstops::enable(bool)
_ZN8Endstops6enableEb:
        LDR.N    R1,??enable_0
        STRB     R0,[R1, #+0]
        BX       LR               ;; return
        Nop      
        DATA
??enable_0:
        DC32     _ZN8Endstops7enabledE
          CFI EndBlock cfiBlock148

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN8Endstops10not_homingEv
          CFI Block cfiBlock149 Using cfiCommon0
          CFI Function _ZN8Endstops10not_homingEv
          CFI NoCalls
        THUMB
// __interwork __softfp void Endstops::not_homing()
_ZN8Endstops10not_homingEv:
        LDR.N    R0,??not_homing_0
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??not_homing_0+0x4
        STRB     R0,[R1, #+0]
        BX       LR               ;; return
        Nop      
        DATA
??not_homing_0:
        DC32     _ZN8Endstops16enabled_globallyE
        DC32     _ZN8Endstops7enabledE
          CFI EndBlock cfiBlock149

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN8Endstops14hit_on_purposeEv
          CFI Block cfiBlock150 Using cfiCommon0
          CFI Function _ZN8Endstops14hit_on_purposeEv
          CFI NoCalls
        THUMB
// __interwork __softfp void Endstops::hit_on_purpose()
_ZN8Endstops14hit_on_purposeEv:
        MOVS     R0,#+0
        LDR.N    R1,??hit_on_purpose_0
        STRB     R0,[R1, #+0]
        BX       LR               ;; return
        DATA
??hit_on_purpose_0:
        DC32     _ZN8Endstops16endstop_hit_bitsE
          CFI EndBlock cfiBlock150

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN8Endstops14enable_z_probeEb
          CFI Block cfiBlock151 Using cfiCommon0
          CFI Function _ZN8Endstops14enable_z_probeEb
          CFI NoCalls
        THUMB
// __interwork __softfp void Endstops::enable_z_probe(bool)
_ZN8Endstops14enable_z_probeEb:
        LDR.N    R1,??enable_z_probe_0
        STRB     R0,[R1, #+0]
        BX       LR               ;; return
        Nop      
        DATA
??enable_z_probe_0:
        DC32     _ZN8Endstops15z_probe_enabledE
          CFI EndBlock cfiBlock151

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature16tooColdToExtrudeEh
          CFI Block cfiBlock152 Using cfiCommon0
          CFI Function _ZN11Temperature16tooColdToExtrudeEh
        THUMB
// __interwork __softfp bool Temperature::tooColdToExtrude(uint8_t)
_ZN11Temperature16tooColdToExtrudeEh:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??tooColdToExtrude_0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??tooColdToExtrude_1
        MOVS     R0,#+0
        POP      {R1,PC}
??tooColdToExtrude_1:
        MOVS     R0,#+0
          CFI FunCall _ZN11Temperature9degHotendEh
        BL       _ZN11Temperature9degHotendEh
        LDR.N    R1,??tooColdToExtrude_0+0x4
        LDR      R1,[R1, #+0]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??tooColdToExtrude_2
        MOVS     R0,#+1
        POP      {R1,PC}
??tooColdToExtrude_2:
        MOVS     R0,#+0
        POP      {R1,PC}          ;; return
        Nop      
        DATA
??tooColdToExtrude_0:
        DC32     _ZN11Temperature18allow_cold_extrudeE
        DC32     _ZN11Temperature16extrude_min_tempE
          CFI EndBlock cfiBlock152

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature9degHotendEh
          CFI Block cfiBlock153 Using cfiCommon0
          CFI Function _ZN11Temperature9degHotendEh
          CFI NoCalls
        THUMB
// __interwork __softfp float Temperature::degHotend(uint8_t)
_ZN11Temperature9degHotendEh:
        LDR.N    R0,??degHotend_0
        LDR      R0,[R0, #+0]
        BX       LR               ;; return
        Nop      
        DATA
??degHotend_0:
        DC32     _ZN11Temperature19current_temperatureE
          CFI EndBlock cfiBlock153

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature6degBedEv
          CFI Block cfiBlock154 Using cfiCommon0
          CFI Function _ZN11Temperature6degBedEv
          CFI NoCalls
        THUMB
// __interwork __softfp float Temperature::degBed()
_ZN11Temperature6degBedEv:
        LDR.N    R0,??degBed_0
        LDR      R0,[R0, #+0]
        BX       LR               ;; return
        Nop      
        DATA
??degBed_0:
        DC32     _ZN11Temperature23current_temperature_bedE
          CFI EndBlock cfiBlock154

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature15degTargetHotendEh
          CFI Block cfiBlock155 Using cfiCommon0
          CFI Function _ZN11Temperature15degTargetHotendEh
        THUMB
// __interwork __softfp float Temperature::degTargetHotend(uint8_t)
_ZN11Temperature15degTargetHotendEh:
        LDR.N    R0,??degTargetHotend_0
        LDR      R0,[R0, #+0]
          CFI FunCall __aeabi_i2f
        B.W      __aeabi_i2f
        DATA
??degTargetHotend_0:
        DC32     _ZN11Temperature18target_temperatureE
          CFI EndBlock cfiBlock155

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature12degTargetBedEv
          CFI Block cfiBlock156 Using cfiCommon0
          CFI Function _ZN11Temperature12degTargetBedEv
        THUMB
// __interwork __softfp float Temperature::degTargetBed()
_ZN11Temperature12degTargetBedEv:
        LDR.N    R0,??degTargetBed_0
        LDR      R0,[R0, #+0]
          CFI FunCall __aeabi_i2f
        B.W      __aeabi_i2f
        DATA
??degTargetBed_0:
        DC32     _ZN11Temperature22target_temperature_bedE
          CFI EndBlock cfiBlock156

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature15setTargetHotendEfh
          CFI Block cfiBlock157 Using cfiCommon0
          CFI Function _ZN11Temperature15setTargetHotendEfh
        THUMB
// __interwork __softfp void Temperature::setTargetHotend(float, uint8_t)
_ZN11Temperature15setTargetHotendEfh:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        LDR.N    R1,??setTargetHotend_0
        STR      R0,[R1, #+0]
        MOVS     R0,#+0
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN11Temperature21start_watching_heaterEh
        B.W      _ZN11Temperature21start_watching_heaterEh
        DATA
??setTargetHotend_0:
        DC32     _ZN11Temperature18target_temperatureE
          CFI EndBlock cfiBlock157

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature12setTargetBedEf
          CFI Block cfiBlock158 Using cfiCommon0
          CFI Function _ZN11Temperature12setTargetBedEf
        THUMB
// __interwork __softfp void Temperature::setTargetBed(float)
_ZN11Temperature12setTargetBedEf:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        LDR.N    R1,??setTargetBed_0
        STR      R0,[R1, #+0]
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN11Temperature18start_watching_bedEv
        B.W      _ZN11Temperature18start_watching_bedEv
        Nop      
        DATA
??setTargetBed_0:
        DC32     _ZN11Temperature22target_temperature_bedE
          CFI EndBlock cfiBlock158

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature15isCoolingHotendEh
          CFI Block cfiBlock159 Using cfiCommon0
          CFI Function _ZN11Temperature15isCoolingHotendEh
        THUMB
// __interwork __softfp bool Temperature::isCoolingHotend(uint8_t)
_ZN11Temperature15isCoolingHotendEh:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??isCoolingHotend_0
        LDR      R0,[R0, #+0]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR.N    R1,??isCoolingHotend_0+0x4
        LDR      R1,[R1, #+0]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??isCoolingHotend_1
        MOVS     R0,#+1
        POP      {R1,PC}
??isCoolingHotend_1:
        MOVS     R0,#+0
        POP      {R1,PC}          ;; return
        DATA
??isCoolingHotend_0:
        DC32     _ZN11Temperature18target_temperatureE
        DC32     _ZN11Temperature19current_temperatureE
          CFI EndBlock cfiBlock159

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature12isCoolingBedEv
          CFI Block cfiBlock160 Using cfiCommon0
          CFI Function _ZN11Temperature12isCoolingBedEv
        THUMB
// __interwork __softfp bool Temperature::isCoolingBed()
_ZN11Temperature12isCoolingBedEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??isCoolingBed_0
        LDR      R0,[R0, #+0]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR.N    R1,??isCoolingBed_0+0x4
        LDR      R1,[R1, #+0]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??isCoolingBed_1
        MOVS     R0,#+1
        POP      {R1,PC}
??isCoolingBed_1:
        MOVS     R0,#+0
        POP      {R1,PC}          ;; return
        DATA
??isCoolingBed_0:
        DC32     _ZN11Temperature22target_temperature_bedE
        DC32     _ZN11Temperature23current_temperature_bedE
          CFI EndBlock cfiBlock160

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN10SdBaseFileD2Ev
          CFI Block cfiBlock161 Using cfiCommon0
          CFI Function _ZN10SdBaseFileD2Ev
          CFI FunCall _ZN10SdBaseFileD1Ev
        THUMB
// __code __interwork __softfp SdBaseFile::subobject ~SdBaseFile()
_ZN10SdBaseFileD2Ev:
        B.W      _ZN10SdBaseFileD1Ev
          CFI EndBlock cfiBlock161

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN10SdBaseFileD1Ev
          CFI Block cfiBlock162 Using cfiCommon0
          CFI Function _ZN10SdBaseFileD1Ev
        THUMB
// __code __interwork __softfp SdBaseFile::~SdBaseFile()
_ZN10SdBaseFileD1Ev:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
          CFI FunCall _ZNK10SdBaseFile6isOpenEv
        BL       _ZNK10SdBaseFile6isOpenEv
        CMP      R0,#+0
        BEQ.N    `?~SdBaseFile_0`
        MOV      R0,R4
          CFI FunCall _ZN10SdBaseFile5closeEv
        BL       _ZN10SdBaseFile5closeEv
`?~SdBaseFile_0`:
        MOV      R0,R4
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock162

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZNK10SdBaseFile11curPositionEv
          CFI Block cfiBlock163 Using cfiCommon0
          CFI Function _ZNK10SdBaseFile11curPositionEv
          CFI NoCalls
        THUMB
// __interwork __softfp uint32_t SdBaseFile::curPosition() const
_ZNK10SdBaseFile11curPositionEv:
        LDR      R0,[R0, #+8]
        BX       LR               ;; return
          CFI EndBlock cfiBlock163

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZNK10SdBaseFile6isOpenEv
          CFI Block cfiBlock164 Using cfiCommon0
          CFI Function _ZNK10SdBaseFile6isOpenEv
          CFI NoCalls
        THUMB
// __interwork __softfp bool SdBaseFile::isOpen() const
_ZNK10SdBaseFile6isOpenEv:
        LDRB     R0,[R0, #+3]
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
        BX       LR               ;; return
          CFI EndBlock cfiBlock164

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN6SdFileD1Ev
          CFI Block cfiBlock165 Using cfiCommon0
          CFI Function _ZN6SdFileD1Ev
        THUMB
// __code __interwork __softfp SdFile::~SdFile()
_ZN6SdFileD1Ev:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
        ADD      R0,R4,#+8
          CFI FunCall _ZN10SdBaseFileD2Ev
        BL       _ZN10SdBaseFileD2Ev
        MOV      R0,R4
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock165

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN10CardReaderD1Ev
          CFI Block cfiBlock166 Using cfiCommon0
          CFI Function _ZN10CardReaderD1Ev
        THUMB
// __code __interwork __softfp CardReader::~CardReader()
_ZN10CardReaderD1Ev:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
        ADD      R0,R4,#+588
          CFI FunCall _ZN6SdFileD1Ev
        BL       _ZN6SdFileD1Ev
        MOVS     R3,#+10
        MOVS     R2,#+40
        LDR.N    R1,`?~CardReader_0`
        ADD      R0,R4,#+140
          CFI FunCall __aeabi_vec_dtor
        BL       __aeabi_vec_dtor
        ADD      R0,R4,#+100
          CFI FunCall _ZN6SdFileD1Ev
        BL       _ZN6SdFileD1Ev
        ADD      R0,R4,#+56
          CFI FunCall _ZN6SdFileD1Ev
        BL       _ZN6SdFileD1Ev
        MOV      R0,R4
        POP      {R4,PC}          ;; return
        Nop      
        DATA
`?~CardReader_0`:
        DC32     _ZN6SdFileD1Ev
          CFI EndBlock cfiBlock166

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN10CardReader12pauseSDPrintEv
          CFI Block cfiBlock167 Using cfiCommon0
          CFI Function _ZN10CardReader12pauseSDPrintEv
          CFI NoCalls
        THUMB
// __interwork __softfp void CardReader::pauseSDPrint()
_ZN10CardReader12pauseSDPrintEv:
        MOVS     R1,#+0
        STRB     R1,[R0, #+2]
        BX       LR               ;; return
          CFI EndBlock cfiBlock167

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN10CardReader10isFileOpenEv
          CFI Block cfiBlock168 Using cfiCommon0
          CFI Function _ZN10CardReader10isFileOpenEv
        THUMB
// __interwork __softfp bool CardReader::isFileOpen()
_ZN10CardReader10isFileOpenEv:
        ADD      R0,R0,#+596
          CFI FunCall _ZNK10SdBaseFile6isOpenEv
        B.W      _ZNK10SdBaseFile6isOpenEv
          CFI EndBlock cfiBlock168

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN10CardReader3eofEv
          CFI Block cfiBlock169 Using cfiCommon0
          CFI Function _ZN10CardReader3eofEv
          CFI NoCalls
        THUMB
// __interwork __softfp bool CardReader::eof()
_ZN10CardReader3eofEv:
        LDR      R1,[R0, #+52]
        LDR      R0,[R0, #+780]
        CMP      R1,R0
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
        BX       LR               ;; return
          CFI EndBlock cfiBlock169

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN10CardReader3getEv
          CFI Block cfiBlock170 Using cfiCommon0
          CFI Function _ZN10CardReader3getEv
        THUMB
// __interwork __softfp int16_t CardReader::get()
_ZN10CardReader3getEv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        ADD      R5,R4,#+596
        MOV      R0,R5
          CFI FunCall _ZNK10SdBaseFile11curPositionEv
        BL       _ZNK10SdBaseFile11curPositionEv
        STR      R0,[R4, #+52]
        MOV      R0,R5
        POP      {R1,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10SdBaseFile4readEv
        B.W      _ZN10SdBaseFile4readEv
          CFI EndBlock cfiBlock170

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN10CardReader8setIndexEl
          CFI Block cfiBlock171 Using cfiCommon0
          CFI Function _ZN10CardReader8setIndexEl
        THUMB
// __interwork __softfp void CardReader::setIndex(long)
_ZN10CardReader8setIndexEl:
        STR      R1,[R0, #+52]
        ADD      R0,R0,#+596
          CFI FunCall _ZN10SdBaseFile7seekSetEj
        B.W      _ZN10SdBaseFile7seekSetEj
          CFI EndBlock cfiBlock171

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN10CardReader10lastOpenOkEv
          CFI Block cfiBlock172 Using cfiCommon0
          CFI Function _ZN10CardReader10lastOpenOkEv
          CFI NoCalls
        THUMB
// __interwork __softfp bool CardReader::lastOpenOk()
_ZN10CardReader10lastOpenOkEv:
        LDRB     R0,[R0, #+796]
        BX       LR               ;; return
          CFI EndBlock cfiBlock172

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN10duration_tC1ERKj
          CFI Block cfiBlock173 Using cfiCommon0
          CFI Function _ZN10duration_tC1ERKj
          CFI NoCalls
        THUMB
// __code __interwork __softfp duration_t::duration_t(uint32_t const &)
_ZN10duration_tC1ERKj:
        LDR      R1,[R1, #+0]
        STR      R1,[R0, #+0]
        BX       LR               ;; return
          CFI EndBlock cfiBlock173

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZNK10duration_t4yearEv
          CFI Block cfiBlock174 Using cfiCommon0
          CFI Function _ZNK10duration_t4yearEv
        THUMB
// __interwork __softfp uint8_t duration_t::year() const
_ZNK10duration_t4yearEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZNK10duration_t3dayEv
        BL       _ZNK10duration_t3dayEv
        MOVW     R1,#+365
        SDIV     R0,R0,R1
        UXTB     R0,R0
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock174

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZNK10duration_t3dayEv
          CFI Block cfiBlock175 Using cfiCommon0
          CFI Function _ZNK10duration_t3dayEv
        THUMB
// __interwork __softfp uint16_t duration_t::day() const
_ZNK10duration_t3dayEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZNK10duration_t4hourEv
        BL       _ZNK10duration_t4hourEv
        MOVS     R1,#+24
        UDIV     R0,R0,R1
        UXTH     R0,R0
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock175

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZNK10duration_t4hourEv
          CFI Block cfiBlock176 Using cfiCommon0
          CFI Function _ZNK10duration_t4hourEv
        THUMB
// __interwork __softfp uint32_t duration_t::hour() const
_ZNK10duration_t4hourEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZNK10duration_t6minuteEv
        BL       _ZNK10duration_t6minuteEv
        MOVS     R1,#+60
        UDIV     R0,R0,R1
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock176

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZNK10duration_t6minuteEv
          CFI Block cfiBlock177 Using cfiCommon0
          CFI Function _ZNK10duration_t6minuteEv
        THUMB
// __interwork __softfp uint32_t duration_t::minute() const
_ZNK10duration_t6minuteEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZNK10duration_t6secondEv
        BL       _ZNK10duration_t6secondEv
        MOVS     R1,#+60
        UDIV     R0,R0,R1
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock177

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZNK10duration_t6secondEv
          CFI Block cfiBlock178 Using cfiCommon0
          CFI Function _ZNK10duration_t6secondEv
          CFI NoCalls
        THUMB
// __interwork __softfp uint32_t duration_t::second() const
_ZNK10duration_t6secondEv:
        LDR      R0,[R0, #+0]
        BX       LR               ;; return
          CFI EndBlock cfiBlock178

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZNK10duration_t8toStringEPc
          CFI Block cfiBlock179 Using cfiCommon0
          CFI Function _ZNK10duration_t8toStringEPc
        THUMB
// __interwork __softfp void duration_t::toString(char *) const
_ZNK10duration_t8toStringEPc:
        PUSH     {R0-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+48
        MOV      R10,R0
        MOV      R8,R1
          CFI FunCall _ZNK10duration_t4yearEv
        BL       _ZNK10duration_t4yearEv
        MOV      R4,R0
        MOV      R0,R10
          CFI FunCall _ZNK10duration_t3dayEv
        BL       _ZNK10duration_t3dayEv
        MOVW     R1,#+365
        SDIV     R7,R0,R1
        MLS      R7,R1,R7,R0
        MOV      R0,R10
          CFI FunCall _ZNK10duration_t4hourEv
        BL       _ZNK10duration_t4hourEv
        MOV      R5,R0
        MOVS     R0,#+24
        UDIV     R0,R5,R0
        ADD      R1,R0,R0, LSL #+1
        SUB      R5,R5,R1, LSL #+3
        MOV      R0,R10
          CFI FunCall _ZNK10duration_t6minuteEv
        BL       _ZNK10duration_t6minuteEv
        MOV      R9,#+60
        MOV      R1,R9
        UDIV     R6,R0,R1
        MLS      R6,R9,R6,R0
        MOV      R0,R10
          CFI FunCall _ZNK10duration_t6secondEv
        BL       _ZNK10duration_t6secondEv
        MOV      R1,R9
        UDIV     R2,R0,R1
        MLS      R2,R9,R2,R0
        CMP      R4,#+0
        BEQ.N    ??toString_1
        STR      R2,[SP, #+8]
        STR      R6,[SP, #+4]
        STR      R5,[SP, #+0]
        MOV      R3,R7
        MOV      R2,R4
        LDR.N    R1,??toString_0
        MOV      R0,R8
          CFI FunCall sprintf
        BL       sprintf
        B.N      ??toString_2
??toString_1:
        CMP      R7,#+0
        BEQ.N    ??toString_3
        STR      R2,[SP, #+4]
        STR      R6,[SP, #+0]
        MOV      R3,R5
        MOV      R2,R7
        LDR.N    R1,??toString_0+0x4
        MOV      R0,R8
          CFI FunCall sprintf
        BL       sprintf
        B.N      ??toString_2
??toString_3:
        CMP      R5,#+0
        BEQ.N    ??toString_4
        STR      R2,[SP, #+0]
        MOV      R3,R6
        MOV      R2,R5
        LDR.N    R1,??toString_0+0x8
        MOV      R0,R8
          CFI FunCall sprintf
        BL       sprintf
        B.N      ??toString_2
??toString_4:
        CMP      R6,#+0
        BEQ.N    ??toString_5
        MOV      R3,R2
        MOV      R2,R6
        LDR.N    R1,??toString_0+0xC
        MOV      R0,R8
        ADD      SP,SP,#+16
          CFI CFA R13+32
        POP      {R4-R10,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall sprintf
        B.W      sprintf
          CFI R4 Frame(CFA, -32)
          CFI R5 Frame(CFA, -28)
          CFI R6 Frame(CFA, -24)
          CFI R7 Frame(CFA, -20)
          CFI R8 Frame(CFA, -16)
          CFI R9 Frame(CFA, -12)
          CFI R10 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+48
??toString_5:
        LDR.N    R1,??toString_0+0x10
        MOV      R0,R8
        ADD      SP,SP,#+16
          CFI CFA R13+32
        POP      {R4-R10,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall sprintf
        B.W      sprintf
          CFI R4 Frame(CFA, -32)
          CFI R5 Frame(CFA, -28)
          CFI R6 Frame(CFA, -24)
          CFI R7 Frame(CFA, -20)
          CFI R8 Frame(CFA, -16)
          CFI R9 Frame(CFA, -12)
          CFI R10 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+48
??toString_2:
        POP      {R0-R10,PC}      ;; return
        DATA
??toString_0:
        DC32     _ZZNK10duration_t8toStringEPcEs
        DC32     _ZZNK10duration_t8toStringEPcEs_0
        DC32     _ZZNK10duration_t8toStringEPcEs_1
        DC32     _ZZNK10duration_t8toStringEPcEs_2
        DC32     _ZZNK10duration_t8toStringEPcEs_3
          CFI EndBlock cfiBlock179

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN18DATA_REPRINT_ITMESC1Ev
          CFI Block cfiBlock180 Using cfiCommon0
          CFI Function _ZN18DATA_REPRINT_ITMESC1Ev
        THUMB
// __code __interwork __softfp DATA_REPRINT_ITMES::<_ZN18DATA_REPRINT_ITMESC1Ev>()
_ZN18DATA_REPRINT_ITMESC1Ev:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
        ADD      R0,R4,#+244
          CFI FunCall _ZN10CardReaderC1Ev
        BL       _ZN10CardReaderC1Ev
        MOV      R0,R4
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock180

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN18DATA_REPRINT_ITMESD1Ev
          CFI Block cfiBlock181 Using cfiCommon0
          CFI Function _ZN18DATA_REPRINT_ITMESD1Ev
        THUMB
// __code __interwork __softfp DATA_REPRINT_ITMES::~<unnamed>()
_ZN18DATA_REPRINT_ITMESD1Ev:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
        ADD      R0,R4,#+244
          CFI FunCall _ZN10CardReaderD1Ev
        BL       _ZN10CardReaderD1Ev
        MOV      R0,R4
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock181

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN17mesh_bed_leveling5set_zEaaRKf
          CFI Block cfiBlock182 Using cfiCommon0
          CFI Function _ZN17mesh_bed_leveling5set_zEaaRKf
          CFI NoCalls
        THUMB
// __interwork __softfp void mesh_bed_leveling::set_z(int8_t, int8_t, float const &)
_ZN17mesh_bed_leveling5set_zEaaRKf:
        LDR.N    R3,??set_z_0
        ADD      R0,R3,R0, LSL #+6
        LDR      R2,[R2, #+0]
        STR      R2,[R0, R1, LSL #+2]
        BX       LR               ;; return
        Nop      
        DATA
??set_z_0:
        DC32     _ZN17mesh_bed_leveling8z_valuesE
          CFI EndBlock cfiBlock182

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN17mesh_bed_leveling6activeEv
          CFI Block cfiBlock183 Using cfiCommon0
          CFI Function _ZN17mesh_bed_leveling6activeEv
          CFI NoCalls
        THUMB
// __interwork __softfp bool mesh_bed_leveling::active()
_ZN17mesh_bed_leveling6activeEv:
        LDR.N    R0,??active_0
        LDRB     R0,[R0, #+0]
        LSRS     R0,R0,#+1
        AND      R0,R0,#0x1
        BX       LR               ;; return
        DATA
??active_0:
        DC32     _ZN17mesh_bed_leveling6statusE
          CFI EndBlock cfiBlock183

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN17mesh_bed_leveling10set_activeEb
          CFI Block cfiBlock184 Using cfiCommon0
          CFI Function _ZN17mesh_bed_leveling10set_activeEb
          CFI NoCalls
        THUMB
// __interwork __softfp void mesh_bed_leveling::set_active(bool)
_ZN17mesh_bed_leveling10set_activeEb:
        LDR.N    R1,??set_active_0
        LDRB     R2,[R1, #+0]
        CMP      R0,#+0
        BEQ.N    ??set_active_1
        ORR      R2,R2,#0x2
        STRB     R2,[R1, #+0]
        BX       LR
??set_active_1:
        AND      R2,R2,#0xFD
        STRB     R2,[R1, #+0]
        BX       LR               ;; return
        DATA
??set_active_0:
        DC32     _ZN17mesh_bed_leveling6statusE
          CFI EndBlock cfiBlock184

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN17mesh_bed_leveling8has_meshEv
          CFI Block cfiBlock185 Using cfiCommon0
          CFI Function _ZN17mesh_bed_leveling8has_meshEv
          CFI NoCalls
        THUMB
// __interwork __softfp bool mesh_bed_leveling::has_mesh()
_ZN17mesh_bed_leveling8has_meshEv:
        LDR.N    R0,??has_mesh_0
        LDRB     R0,[R0, #+0]
        AND      R0,R0,#0x1
        BX       LR               ;; return
        Nop      
        DATA
??has_mesh_0:
        DC32     _ZN17mesh_bed_leveling6statusE
          CFI EndBlock cfiBlock185

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN17mesh_bed_leveling12set_has_meshEb
          CFI Block cfiBlock186 Using cfiCommon0
          CFI Function _ZN17mesh_bed_leveling12set_has_meshEb
          CFI NoCalls
        THUMB
// __interwork __softfp void mesh_bed_leveling::set_has_mesh(bool)
_ZN17mesh_bed_leveling12set_has_meshEb:
        LDR.N    R1,??set_has_mesh_0
        LDRB     R2,[R1, #+0]
        CMP      R0,#+0
        BEQ.N    ??set_has_mesh_1
        ORR      R2,R2,#0x1
        STRB     R2,[R1, #+0]
        BX       LR
??set_has_mesh_1:
        AND      R2,R2,#0xFE
        STRB     R2,[R1, #+0]
        BX       LR               ;; return
        DATA
??set_has_mesh_0:
        DC32     _ZN17mesh_bed_leveling6statusE
          CFI EndBlock cfiBlock186

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN17mesh_bed_leveling6zigzagEaRaS0_
          CFI Block cfiBlock187 Using cfiCommon0
          CFI Function _ZN17mesh_bed_leveling6zigzagEaRaS0_
          CFI NoCalls
        THUMB
// __interwork __softfp void mesh_bed_leveling::zigzag(int8_t, int8_t &, int8_t &)
_ZN17mesh_bed_leveling6zigzagEaRaS0_:
        PUSH     {R4,R5}
          CFI R5 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R3,??zigzag_0
        LDRB     R4,[R3, #+96]
        SDIV     R5,R0,R4
        MLS      R4,R4,R5,R0
        STRB     R4,[R1, #+0]
        LDRB     R4,[R3, #+96]
        SDIV     R0,R0,R4
        STRB     R0,[R2, #+0]
        LDRB     R0,[R2, #+0]
        LSLS     R0,R0,#+31
        BPL.N    ??zigzag_1
        LDRSB    R0,[R3, #+96]
        SUBS     R2,R0,#+1
        LDRB     R0,[R1, #+0]
        SUBS     R2,R2,R0
        STRB     R2,[R1, #+0]
??zigzag_1:
        POP      {R4,R5}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
        Nop      
        DATA
??zigzag_0:
        DC32     mksCfg
          CFI EndBlock cfiBlock187

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN17mesh_bed_leveling12set_zigzag_zEaRKf
          CFI Block cfiBlock188 Using cfiCommon0
          CFI Function _ZN17mesh_bed_leveling12set_zigzag_zEaRKf
        THUMB
// __interwork __softfp void mesh_bed_leveling::set_zigzag_z(int8_t, float const &)
_ZN17mesh_bed_leveling12set_zigzag_zEaRKf:
        PUSH     {R2-R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+16
        MOV      R4,R1
        MOV      R2,SP
        ADD      R1,SP,#+1
          CFI FunCall _ZN17mesh_bed_leveling6zigzagEaRaS0_
        BL       _ZN17mesh_bed_leveling6zigzagEaRaS0_
        MOV      R2,R4
        LDRSB    R1,[SP, #+0]
        LDRSB    R0,[SP, #+1]
          CFI FunCall _ZN17mesh_bed_leveling5set_zEaaRKf
        BL       _ZN17mesh_bed_leveling5set_zEaaRKf
        POP      {R0,R1,R4,PC}    ;; return
          CFI EndBlock cfiBlock188

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN17mesh_bed_leveling12cell_index_xERKf
          CFI Block cfiBlock189 Using cfiCommon0
          CFI Function _ZN17mesh_bed_leveling12cell_index_xERKf
        THUMB
// __interwork __softfp int8_t mesh_bed_leveling::cell_index_x(float const &)
_ZN17mesh_bed_leveling12cell_index_xERKf:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R9,R0
        LDR.N    R6,??cell_index_x_0
        LDRB     R0,[R6, #+152]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R7,R0
        LDR      R0,[R6, #+8]
        MOV      R1,R7
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R8,R0
        LDRB     R4,[R6, #+96]
        MOV      R5,R4
        LDR      R0,[R9, #+0]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R10,R0
        MOV      R11,R1
        LDR      R0,[R6, #+20]
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R6,R0
        SUBS     R0,R5,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R6
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOVS     R0,#+0
        LDR.N    R1,??cell_index_x_0+0x4  ;; 0x3ff00000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R10
        MOV      R3,R11
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
        MOV      R1,R0
        SXTB     R1,R1
        CMP      R1,#+0
        BPL.N    ??cell_index_x_1
        MOVS     R0,#+0
        B.N      ??cell_index_x_2
??cell_index_x_1:
        SUBS     R5,R5,#+2
        CMP      R5,R1
        BGE.N    ??cell_index_x_2
        SUBS     R0,R4,#+2
??cell_index_x_2:
        SXTB     R0,R0
        POP      {R1,R4-R11,PC}   ;; return
        DATA
??cell_index_x_0:
        DC32     mksCfg
        DC32     0x3ff00000
          CFI EndBlock cfiBlock189

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN17mesh_bed_leveling12cell_index_yERKf
          CFI Block cfiBlock190 Using cfiCommon0
          CFI Function _ZN17mesh_bed_leveling12cell_index_yERKf
        THUMB
// __interwork __softfp int8_t mesh_bed_leveling::cell_index_y(float const &)
_ZN17mesh_bed_leveling12cell_index_yERKf:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R9,R0
        LDR.N    R6,??cell_index_y_0
        LDRB     R0,[R6, #+152]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R7,R0
        LDR      R0,[R6, #+12]
        MOV      R1,R7
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R8,R0
        LDRB     R4,[R6, #+97]
        MOV      R5,R4
        LDR      R0,[R9, #+0]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R10,R0
        MOV      R11,R1
        LDR      R0,[R6, #+24]
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R6,R0
        SUBS     R0,R5,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R6
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOVS     R0,#+0
        LDR.N    R1,??cell_index_y_0+0x4  ;; 0x3ff00000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R10
        MOV      R3,R11
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
        MOV      R1,R0
        SXTB     R1,R1
        CMP      R1,#+0
        BPL.N    ??cell_index_y_1
        MOVS     R0,#+0
        B.N      ??cell_index_y_2
??cell_index_y_1:
        SUBS     R5,R5,#+2
        CMP      R5,R1
        BGE.N    ??cell_index_y_2
        SUBS     R0,R4,#+2
??cell_index_y_2:
        SXTB     R0,R0
        POP      {R1,R4-R11,PC}   ;; return
        DATA
??cell_index_y_0:
        DC32     mksCfg
        DC32     0x3ff00000
          CFI EndBlock cfiBlock190

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN17mesh_bed_leveling13probe_index_xERKf
          CFI Block cfiBlock191 Using cfiCommon0
          CFI Function _ZN17mesh_bed_leveling13probe_index_xERKf
        THUMB
// __interwork __softfp int8_t mesh_bed_leveling::probe_index_x(float const &)
_ZN17mesh_bed_leveling13probe_index_xERKf:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        MOV      R4,R0
        LDR.N    R5,??probe_index_x_0
        LDRB     R6,[R5, #+96]
        SUBS     R6,R6,#+1
        LDRB     R0,[R5, #+152]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R7,R0
        LDR      R0,[R5, #+8]
        MOV      R1,R7
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R8,R0
        LDR      R0,[R5, #+20]
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R5,R0
        MOV      R0,R6
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R7,R0
        LDR      R0,[R4, #+0]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R4,R0
        MOV      R5,R1
        MOV      R0,R7
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        LDR.N    R3,??probe_index_x_0+0x4  ;; 0x3fe00000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R4,R0
        MOV      R5,R1
        MOV      R0,R7
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOVS     R0,#+0
        LDR.N    R1,??probe_index_x_0+0x8  ;; 0x3ff00000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
        MOV      R1,R0
        SXTB     R1,R1
        CMP      R1,#+0
        BMI.N    ??probe_index_x_1
        CMP      R6,R1
        BGE.N    ??probe_index_x_2
??probe_index_x_1:
        MOV      R0,#-1
??probe_index_x_2:
        SXTB     R0,R0
        POP      {R4-R8,PC}       ;; return
        DATA
??probe_index_x_0:
        DC32     mksCfg
        DC32     0x3fe00000
        DC32     0x3ff00000
          CFI EndBlock cfiBlock191

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN17mesh_bed_leveling13probe_index_yERKf
          CFI Block cfiBlock192 Using cfiCommon0
          CFI Function _ZN17mesh_bed_leveling13probe_index_yERKf
        THUMB
// __interwork __softfp int8_t mesh_bed_leveling::probe_index_y(float const &)
_ZN17mesh_bed_leveling13probe_index_yERKf:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        MOV      R4,R0
        LDR.N    R5,??probe_index_y_0
        LDRB     R6,[R5, #+97]
        SUBS     R6,R6,#+1
        LDRB     R0,[R5, #+152]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R7,R0
        LDR      R0,[R5, #+12]
        MOV      R1,R7
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R8,R0
        LDR      R0,[R5, #+24]
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R5,R0
        MOV      R0,R6
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R7,R0
        LDR      R0,[R4, #+0]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R4,R0
        MOV      R5,R1
        MOV      R0,R7
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        LDR.N    R3,??probe_index_y_0+0x4  ;; 0x3fe00000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R4,R0
        MOV      R5,R1
        MOV      R0,R7
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOVS     R0,#+0
        LDR.N    R1,??probe_index_y_0+0x8  ;; 0x3ff00000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
        MOV      R1,R0
        SXTB     R1,R1
        CMP      R1,#+0
        BMI.N    ??probe_index_y_1
        CMP      R6,R1
        BGE.N    ??probe_index_y_2
??probe_index_y_1:
        MOV      R0,#-1
??probe_index_y_2:
        SXTB     R0,R0
        POP      {R4-R8,PC}       ;; return
        DATA
??probe_index_y_0:
        DC32     mksCfg
        DC32     0x3fe00000
        DC32     0x3ff00000
          CFI EndBlock cfiBlock192

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN13CircularQueueI6tone_tLh4EEC1Ev
          CFI Block cfiBlock193 Using cfiCommon0
          CFI Function _ZN13CircularQueueI6tone_tLh4EEC1Ev
          CFI NoCalls
        THUMB
// __code __interwork __softfp CircularQueue<tone_t, (uint8_t)'\004'>::CircularQueue()
_ZN13CircularQueueI6tone_tLh4EEC1Ev:
        MOVS     R1,#+4
        STRB     R1,[R0, #+3]
        MOVS     R1,#+0
        STRB     R1,[R0, #+1]
        STRB     R1,[R0, #+0]
        STRB     R1,[R0, #+2]
        BX       LR               ;; return
          CFI EndBlock cfiBlock193

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN13CircularQueueI6tone_tLh4EE7dequeueEv
          CFI Block cfiBlock194 Using cfiCommon0
          CFI Function _ZN13CircularQueueI6tone_tLh4EE7dequeueEv
        THUMB
// __interwork __softfp tone_t CircularQueue<tone_t, (uint8_t)'\004'>::dequeue()
_ZN13CircularQueueI6tone_tLh4EE7dequeueEv:
        PUSH     {R2-R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+16
        MOV      R4,R0
          CFI FunCall _ZN13CircularQueueI6tone_tLh4EE7isEmptyEv
        BL       _ZN13CircularQueueI6tone_tLh4EE7isEmptyEv
        CMP      R0,#+0
        BEQ.N    ??dequeue_0
        MOVS     R2,#+0
        MOVS     R1,#+4
        MOV      R0,SP
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        LDR      R0,[SP, #+0]
        POP      {R1,R2,R4,PC}
??dequeue_0:
        LDRB     R0,[R4, #+0]
        LDRB     R1,[R4, #+2]
        SUBS     R1,R1,#+1
        STRB     R1,[R4, #+2]
        LDRB     R1,[R4, #+0]
        ADDS     R1,R1,#+1
        STRB     R1,[R4, #+0]
        LDRB     R2,[R4, #+3]
        UXTB     R1,R1
        CMP      R1,R2
        BNE.N    ??dequeue_1
        MOVS     R1,#+0
        STRB     R1,[R4, #+0]
??dequeue_1:
        ADD      R0,R4,R0, LSL #+2
        LDR      R0,[R0, #+4]
        STR      R0,[SP, #+0]
        POP      {R1,R2,R4,PC}    ;; return
          CFI EndBlock cfiBlock194

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN13CircularQueueI6tone_tLh4EE7enqueueERKS0_
          CFI Block cfiBlock195 Using cfiCommon0
          CFI Function _ZN13CircularQueueI6tone_tLh4EE7enqueueERKS0_
        THUMB
// __interwork __softfp bool CircularQueue<tone_t, (uint8_t)'\004'>::enqueue(tone_t const &)
_ZN13CircularQueueI6tone_tLh4EE7enqueueERKS0_:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        MOV      R5,R1
          CFI FunCall _ZN13CircularQueueI6tone_tLh4EE6isFullEv
        BL       _ZN13CircularQueueI6tone_tLh4EE6isFullEv
        CMP      R0,#+0
        BEQ.N    ??enqueue_0
        MOVS     R0,#+0
        POP      {R1,R4,R5,PC}
??enqueue_0:
        LDRB     R0,[R4, #+1]
        ADD      R0,R4,R0, LSL #+2
        LDR      R1,[R5, #+0]
        STR      R1,[R0, #+4]
        LDRB     R0,[R4, #+2]
        ADDS     R0,R0,#+1
        STRB     R0,[R4, #+2]
        LDRB     R0,[R4, #+1]
        ADDS     R0,R0,#+1
        STRB     R0,[R4, #+1]
        LDRB     R1,[R4, #+3]
        UXTB     R0,R0
        CMP      R0,R1
        BNE.N    ??enqueue_1
        MOVS     R0,#+0
        STRB     R0,[R4, #+1]
??enqueue_1:
        MOVS     R0,#+1
        POP      {R1,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock195

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN13CircularQueueI6tone_tLh4EE7isEmptyEv
          CFI Block cfiBlock196 Using cfiCommon0
          CFI Function _ZN13CircularQueueI6tone_tLh4EE7isEmptyEv
          CFI NoCalls
        THUMB
// __interwork __softfp bool CircularQueue<tone_t, (uint8_t)'\004'>::isEmpty()
_ZN13CircularQueueI6tone_tLh4EE7isEmptyEv:
        LDRB     R0,[R0, #+2]
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        LSRS     R0,R0,#+31
        BX       LR               ;; return
          CFI EndBlock cfiBlock196

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN13CircularQueueI6tone_tLh4EE6isFullEv
          CFI Block cfiBlock197 Using cfiCommon0
          CFI Function _ZN13CircularQueueI6tone_tLh4EE6isFullEv
          CFI NoCalls
        THUMB
// __interwork __softfp bool CircularQueue<tone_t, (uint8_t)'\004'>::isFull()
_ZN13CircularQueueI6tone_tLh4EE6isFullEv:
        LDRB     R1,[R0, #+2]
        LDRB     R0,[R0, #+3]
        CMP      R1,R0
        BNE.N    ??isFull_0
        MOVS     R0,#+1
        BX       LR
??isFull_0:
        MOVS     R0,#+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock197

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN6Buzzer3offEv
          CFI Block cfiBlock198 Using cfiCommon0
          CFI Function _ZN6Buzzer3offEv
        THUMB
// __interwork __softfp void Buzzer::off()
_ZN6Buzzer3offEv:
        MOVS     R2,#+0
        LDR.N    R0,??off_0
        LDRH     R1,[R0, #+70]
        LDR.N    R0,??off_0+0x4
        LDR      R0,[R0, #+140]
          CFI FunCall HAL_GPIO_WritePin
        B.W      HAL_GPIO_WritePin
        Nop      
        DATA
??off_0:
        DC32     gArrayGpioPin
        DC32     gArrayGpioPort
          CFI EndBlock cfiBlock198

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN6Buzzer2onEv
          CFI Block cfiBlock199 Using cfiCommon0
          CFI Function _ZN6Buzzer2onEv
        THUMB
// __interwork __softfp void Buzzer::on()
_ZN6Buzzer2onEv:
        MOVS     R2,#+1
        LDR.N    R0,??on_0
        LDRH     R1,[R0, #+70]
        LDR.N    R0,??on_0+0x4
        LDR      R0,[R0, #+140]
          CFI FunCall HAL_GPIO_WritePin
        B.W      HAL_GPIO_WritePin
        Nop      
        DATA
??on_0:
        DC32     gArrayGpioPin
        DC32     gArrayGpioPort
          CFI EndBlock cfiBlock199

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN6Buzzer5resetEv
          CFI Block cfiBlock200 Using cfiCommon0
          CFI Function _ZN6Buzzer5resetEv
        THUMB
// __interwork __softfp void Buzzer::reset()
_ZN6Buzzer5resetEv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
          CFI FunCall _ZN6Buzzer3offEv
        BL       _ZN6Buzzer3offEv
        MOVS     R0,#+0
        STR      R0,[R4, #+8]
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock200

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN6BuzzerC1Ev
          CFI Block cfiBlock201 Using cfiCommon0
          CFI Function _ZN6BuzzerC1Ev
        THUMB
// __code __interwork __softfp Buzzer::Buzzer()
_ZN6BuzzerC1Ev:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
        LDR.N    R0,??Buzzer_0
        STR      R0,[R4, #+0]
        ADD      R0,R4,#+12
          CFI FunCall _ZN13CircularQueueI6tone_tLh4EEC1Ev
        BL       _ZN13CircularQueueI6tone_tLh4EEC1Ev
        MOV      R0,R4
          CFI FunCall _ZN6Buzzer5resetEv
        BL       _ZN6Buzzer5resetEv
        MOV      R0,R4
        POP      {R4,PC}          ;; return
        Nop      
        DATA
??Buzzer_0:
        DC32     _ZTV6Buzzer+0x8
          CFI EndBlock cfiBlock201

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN6Buzzer4toneERKtS1_
          CFI Block cfiBlock202 Using cfiCommon0
          CFI Function _ZN6Buzzer4toneERKtS1_
        THUMB
// __interwork __softfp void Buzzer::tone(uint16_t const &, uint16_t const &)
_ZN6Buzzer4toneERKtS1_:
        PUSH     {R2-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+24
        MOV      R4,R0
        MOV      R5,R1
        MOV      R6,R2
        B.N      ??tone_0
??tone_1:
        MOV      R0,R4
        LDR      R1,[R4, #+0]
        LDR      R1,[R1, #+0]
          CFI FunCall
        BLX      R1
          CFI FunCall _ZN11Temperature13manage_heaterEv
        BL       _ZN11Temperature13manage_heaterEv
??tone_0:
        ADD      R0,R4,#+12
          CFI FunCall _ZN13CircularQueueI6tone_tLh4EE6isFullEv
        BL       _ZN13CircularQueueI6tone_tLh4EE6isFullEv
        CMP      R0,#+0
        BNE.N    ??tone_1
        LDRH     R0,[R5, #+0]
        STRH     R0,[SP, #+0]
        LDRH     R0,[R6, #+0]
        STRH     R0,[SP, #+2]
        MOV      R1,SP
        ADD      R0,R4,#+12
          CFI FunCall _ZN13CircularQueueI6tone_tLh4EE7enqueueERKS0_
        BL       _ZN13CircularQueueI6tone_tLh4EE7enqueueERKS0_
        POP      {R0,R1,R4-R6,PC}  ;; return
          CFI EndBlock cfiBlock202

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN6Buzzer4tickEv
          CFI Block cfiBlock203 Using cfiCommon0
          CFI Function _ZN6Buzzer4tickEv
        THUMB
// __interwork __softfp void Buzzer::tick()
_ZN6Buzzer4tickEv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        MOV      R5,R0
        LDR      R0,[R4, #+8]
        CMP      R0,#+0
        BNE.N    ??tick_0
        ADD      R0,R4,#+12
          CFI FunCall _ZN13CircularQueueI6tone_tLh4EE7isEmptyEv
        BL       _ZN13CircularQueueI6tone_tLh4EE7isEmptyEv
        CMP      R0,#+0
        BNE.N    ??tick_1
        ADD      R0,R4,#+12
          CFI FunCall _ZN13CircularQueueI6tone_tLh4EE7dequeueEv
        BL       _ZN13CircularQueueI6tone_tLh4EE7dequeueEv
        STR      R0,[R4, #+4]
        LDRH     R0,[R4, #+4]
        ADDS     R5,R0,R5
        STR      R5,[R4, #+8]
        LDRH     R0,[R4, #+6]
        CMP      R0,#+0
        BEQ.N    ??tick_1
        MOV      R0,R4
        POP      {R1,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN6Buzzer2onEv
        B.W      _ZN6Buzzer2onEv
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??tick_0:
        SUBS     R5,R5,R0
        BMI.N    ??tick_1
        MOV      R0,R4
        POP      {R1,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN6Buzzer5resetEv
        B.W      _ZN6Buzzer5resetEv
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??tick_1:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock203

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z18sync_plan_positionv
          CFI Block cfiBlock204 Using cfiCommon0
          CFI Function _Z18sync_plan_positionv
        THUMB
_Z18sync_plan_positionv:
        LDR.N    R0,??sync_plan_position_0
        ADD      R3,R0,#+20
        LDR      R2,[R0, #+16]
        LDR      R1,[R0, #+12]
        LDR      R0,[R0, #+8]
          CFI FunCall _ZN7Planner15set_position_mmEfffRKf
        B.W      _ZN7Planner15set_position_mmEfffRKf
        DATA
??sync_plan_position_0:
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock204

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z20sync_plan_position_ev
          CFI Block cfiBlock205 Using cfiCommon0
          CFI Function _Z20sync_plan_position_ev
        THUMB
_Z20sync_plan_position_ev:
        LDR.N    R0,??sync_plan_position_e_0
          CFI FunCall _ZN7Planner17set_e_position_mmERKf
        B.W      _ZN7Planner17set_e_position_mmERKf
        Nop      
        DATA
??sync_plan_position_e_0:
        DC32     mks_heating_busy+0x14
          CFI EndBlock cfiBlock205

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z28sync_plan_position_kinematicv
          CFI Block cfiBlock206 Using cfiCommon0
          CFI Function _Z28sync_plan_position_kinematicv
        THUMB
_Z28sync_plan_position_kinematicv:
        LDR.N    R0,??sync_plan_position_kinematic_0
          CFI FunCall _ZN7Planner25set_position_mm_kinematicEPKf
        B.W      _ZN7Planner25set_position_mm_kinematicEPKf
        Nop      
        DATA
??sync_plan_position_kinematic_0:
        DC32     mks_heating_busy+0x8
          CFI EndBlock cfiBlock206

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z15_commit_commandb
          CFI Block cfiBlock207 Using cfiCommon0
          CFI Function _Z15_commit_commandb
          CFI NoCalls
        THUMB
_Z15_commit_commandb:
        LDR.N    R1,??_commit_command_0
        LDRB     R2,[R1, #+10]
        MOV      R3,R2
        ADD      R3,R1,R3
        STRB     R0,[R3, #+20]
        ADDS     R2,R2,#+1
        STRB     R2,[R1, #+10]
        UXTB     R2,R2
        CMP      R2,#+4
        BLT.N    ??_commit_command_1
        MOVS     R0,#+0
        STRB     R0,[R1, #+10]
??_commit_command_1:
        LDRB     R0,[R1, #+8]
        ADDS     R0,R0,#+1
        STRB     R0,[R1, #+8]
        BX       LR               ;; return
        DATA
??_commit_command_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock207

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z15_enqueuecommandPKcb
          CFI Block cfiBlock208 Using cfiCommon0
          CFI Function _Z15_enqueuecommandPKcb
        THUMB
_Z15_enqueuecommandPKcb:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R1
        LDRSB    R1,[R0, #+0]
        CMP      R1,#+59
        BEQ.N    ??_enqueuecommand_1
        LDR.N    R2,??_enqueuecommand_0
        LDRB     R1,[R2, #+8]
        CMP      R1,#+4
        BLT.N    ??_enqueuecommand_2
??_enqueuecommand_1:
        MOVS     R0,#+0
        POP      {R4,PC}
??_enqueuecommand_2:
        MOV      R1,R0
        LDR.N    R0,??_enqueuecommand_0+0x4
        LDRB     R2,[R2, #+10]
        ADD      R3,R2,R2, LSL #+1
        ADD      R0,R0,R3, LSL #+5
          CFI FunCall strcpy
        BL       strcpy
        MOV      R0,R4
          CFI FunCall _Z15_commit_commandb
        BL       _Z15_commit_commandb
        MOVS     R0,#+1
        POP      {R4,PC}          ;; return
        DATA
??_enqueuecommand_0:
        DC32     axis_relative_modes
        DC32     command_queue
          CFI EndBlock cfiBlock208

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z19get_serial_commandsv
          CFI Block cfiBlock209 Using cfiCommon0
          CFI Function _Z19get_serial_commandsv
        THUMB
_Z19get_serial_commandsv:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        MOV      R4,R0
        LDR.N    R6,??get_serial_commands_0
        LDRB     R0,[R6, #+8]
        CMP      R0,#+0
        BNE.W    ??get_serial_commands_1
        LDR.N    R0,??get_serial_commands_0+0x4
          CFI FunCall _ZN12MarlinSerial9availableEv
        BL       _ZN12MarlinSerial9availableEv
        CMP      R0,#+0
        BNE.W    ??get_serial_commands_1
        LDR.N    R0,??get_serial_commands_0+0x8
        LDR      R1,[R0, #+0]
        SUBS     R1,R4,R1
        SUBS     R1,R1,#+1000
        BMI.W    ??get_serial_commands_1
        LDRB     R1,[R6, #+14]
        MOV      R2,R1
        CMP      R2,#+6
        BGE.N    ??get_serial_commands_2
        ADDS     R1,R1,#+1
        STRB     R1,[R6, #+14]
??get_serial_commands_2:
        STR      R4,[R0, #+0]
        B.N      ??get_serial_commands_1
??get_serial_commands_3:
        ADD      R9,R9,#+1
??get_serial_commands_4:
        LDRSB    R0,[R9, #+0]
        CMP      R0,#+32
        BEQ.N    ??get_serial_commands_3
        CMP      R0,#+78
        BNE.N    ??get_serial_commands_5
        MOV      R5,R9
        B.N      ??get_serial_commands_6
??get_serial_commands_5:
        MOV      R5,R1
??get_serial_commands_6:
        MOVS     R1,#+42
        MOV      R0,R9
          CFI FunCall __iar_Strchr
        BL       __iar_Strchr
        MOV      R4,R0
        CMP      R5,#+0
        BEQ.W    ??get_serial_commands_7
        LDR.N    R1,??get_serial_commands_0+0xC
        MOV      R0,R9
          CFI FunCall __iar_Strstr
        BL       __iar_Strstr
        CMP      R0,#+0
        BEQ.N    ??get_serial_commands_8
        MOV      R10,#+1
        B.N      ??get_serial_commands_9
??get_serial_commands_8:
        MOV      R10,#+0
??get_serial_commands_9:
        MOV      R0,R10
        CMP      R0,#+0
        BEQ.N    ??get_serial_commands_10
        MOVS     R1,#+78
        ADD      R0,R9,#+4
          CFI FunCall __iar_Strchr
        BL       __iar_Strchr
        CMP      R0,#+0
        BEQ.N    ??get_serial_commands_10
        MOV      R5,R0
??get_serial_commands_10:
        MOVS     R2,#+10
        MOVS     R1,#+0
        ADDS     R0,R5,#+1
          CFI FunCall strtol
        BL       strtol
        STR      R0,[R6, #+28]
        LDR      R1,[R6, #+32]
        ADDS     R1,R1,#+1
        CMP      R0,R1
        BEQ.N    ??get_serial_commands_11
        CMP      R10,#+0
        BEQ.N    ??get_serial_commands_12
??get_serial_commands_11:
        CMP      R4,#+0
        BEQ.N    ??get_serial_commands_13
        MOVS     R5,#+0
        MOV      R0,R5
        B.N      ??get_serial_commands_14
??get_serial_commands_12:
        MOVS     R1,#+1
        LDR.N    R0,??get_serial_commands_0+0x10
        POP      {R4-R10,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z16gcode_line_errorPKcb
        B.W      _Z16gcode_line_errorPKcb
          CFI R4 Frame(CFA, -32)
          CFI R5 Frame(CFA, -28)
          CFI R6 Frame(CFA, -24)
          CFI R7 Frame(CFA, -20)
          CFI R8 Frame(CFA, -16)
          CFI R9 Frame(CFA, -12)
          CFI R10 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
??get_serial_commands_15:
        EORS     R5,R1,R5
        ADDS     R0,R0,#+1
??get_serial_commands_14:
        MOV      R1,R0
        UXTB     R1,R1
        LDRSB    R1,[R9, R1]
        CMP      R1,#+42
        BNE.N    ??get_serial_commands_15
        MOVS     R2,#+10
        MOVS     R1,#+0
        ADDS     R0,R4,#+1
          CFI FunCall strtol
        BL       strtol
        UXTB     R5,R5
        CMP      R0,R5
        BNE.N    ??get_serial_commands_16
        LDR      R0,[R6, #+28]
        STR      R0,[R6, #+32]
??get_serial_commands_17:
          CFI FunCall _Z9IsStoppedv
        BL       _Z9IsStoppedv
        CMP      R0,#+0
        BEQ.N    ??get_serial_commands_18
        MOVS     R1,#+71
        MOV      R0,R9
          CFI FunCall __iar_Strchr
        BL       __iar_Strchr
        CMP      R0,#+0
        BEQ.N    ??get_serial_commands_18
        MOVS     R2,#+10
        MOVS     R1,#+0
        ADDS     R0,R0,#+1
          CFI FunCall strtol
        BL       strtol
        CMP      R0,#+3
        BLS.N    ??get_serial_commands_19
??get_serial_commands_18:
        LDR.N    R1,??get_serial_commands_0+0x14
        MOV      R0,R9
          CFI FunCall strcmp
        BL       strcmp
        CMP      R0,#+0
        BNE.N    ??get_serial_commands_20
        MOVS     R0,#+0
        STRB     R0,[R7, #+3]
        STRB     R0,[R7, #+4]
??get_serial_commands_20:
        LDR.N    R1,??get_serial_commands_0+0x18
        MOV      R0,R9
          CFI FunCall strcmp
        BL       strcmp
        CMP      R0,#+0
        BNE.N    ??get_serial_commands_21
        LDR.N    R0,??get_serial_commands_0+0x1C
          CFI FunCall _Z4killPKc
        BL       _Z4killPKc
??get_serial_commands_21:
        LDR.N    R1,??get_serial_commands_0+0x20
        MOV      R0,R9
          CFI FunCall strcmp
        BL       strcmp
        CMP      R0,#+0
        BNE.N    ??get_serial_commands_22
          CFI FunCall _Z17quickstop_stepperv
        BL       _Z17quickstop_stepperv
??get_serial_commands_22:
        MOVS     R1,#+1
        MOV      R0,R8
          CFI FunCall _Z15_enqueuecommandPKcb
        BL       _Z15_enqueuecommandPKcb
??get_serial_commands_1:
        LDRB     R0,[R6, #+8]
        CMP      R0,#+4
        BGE.N    ??get_serial_commands_23
        LDR.N    R4,??get_serial_commands_0+0x4
        MOV      R0,R4
          CFI FunCall _ZN12MarlinSerial9availableEv
        BL       _ZN12MarlinSerial9availableEv
        CMP      R0,#+0
        BLE.N    ??get_serial_commands_23
        MOV      R0,R4
          CFI FunCall _ZN12MarlinSerial4readEv
        BL       _ZN12MarlinSerial4readEv
        SXTB     R0,R0
        MOVS     R1,#+0
        STRB     R1,[R6, #+14]
        LDR.N    R7,??get_serial_commands_0+0x24
        STRB     R1,[R7, #+7]
        CMP      R0,#+10
        BEQ.N    ??get_serial_commands_24
        CMP      R0,#+13
        BNE.N    ??get_serial_commands_25
??get_serial_commands_24:
        MOV      R0,R1
        LDR.N    R1,??get_serial_commands_0+0x28
        STRB     R0,[R1, #+0]
        LDR      R0,[R6, #+48]
        CMP      R0,#+0
        BEQ.N    ??get_serial_commands_1
        LDR.W    R8,??get_serial_commands_0+0x2C
        MOVS     R1,#+0
        STRB     R1,[R8, R0]
        MOV      R0,R1
        STR      R0,[R6, #+48]
        MOV      R9,R8
        B.N      ??get_serial_commands_4
??get_serial_commands_16:
        MOVS     R1,#+1
        LDR.N    R0,??get_serial_commands_0+0x30
        POP      {R4-R10,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z16gcode_line_errorPKcb
        B.W      _Z16gcode_line_errorPKcb
          CFI R4 Frame(CFA, -32)
          CFI R5 Frame(CFA, -28)
          CFI R6 Frame(CFA, -24)
          CFI R7 Frame(CFA, -20)
          CFI R8 Frame(CFA, -16)
          CFI R9 Frame(CFA, -12)
          CFI R10 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
??get_serial_commands_19:
        LDR.N    R0,??get_serial_commands_0+0x34
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R1,#+0
        LDR.N    R0,??get_serial_commands_0+0x38
          CFI FunCall _Z16lcd_setstatuspgmPKch
        BL       _Z16lcd_setstatuspgmPKch
        B.N      ??get_serial_commands_18
??get_serial_commands_13:
        MOVS     R1,#+1
        LDR.N    R0,??get_serial_commands_0+0x3C
        POP      {R4-R10,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z16gcode_line_errorPKcb
        B.W      _Z16gcode_line_errorPKcb
          CFI R4 Frame(CFA, -32)
          CFI R5 Frame(CFA, -28)
          CFI R6 Frame(CFA, -24)
          CFI R7 Frame(CFA, -20)
          CFI R8 Frame(CFA, -16)
          CFI R9 Frame(CFA, -12)
          CFI R10 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
??get_serial_commands_7:
        CMP      R4,#+0
        BEQ.N    ??get_serial_commands_17
        MOVS     R1,#+0
        LDR.N    R0,??get_serial_commands_0+0x40
        POP      {R4-R10,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z16gcode_line_errorPKcb
        B.W      _Z16gcode_line_errorPKcb
          CFI R4 Frame(CFA, -32)
          CFI R5 Frame(CFA, -28)
          CFI R6 Frame(CFA, -24)
          CFI R7 Frame(CFA, -20)
          CFI R8 Frame(CFA, -16)
          CFI R9 Frame(CFA, -12)
          CFI R10 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
??get_serial_commands_25:
        LDR      R1,[R6, #+48]
        CMP      R1,#+95
        BGE.N    ??get_serial_commands_1
        CMP      R0,#+92
        BNE.N    ??get_serial_commands_26
        MOV      R0,R4
          CFI FunCall _ZN12MarlinSerial9availableEv
        BL       _ZN12MarlinSerial9availableEv
        CMP      R0,#+0
        BLE.N    ??get_serial_commands_1
        MOV      R0,R4
          CFI FunCall _ZN12MarlinSerial4readEv
        BL       _ZN12MarlinSerial4readEv
        LDR.N    R1,??get_serial_commands_0+0x28
        LDRB     R1,[R1, #+0]
        CMP      R1,#+0
        BNE.N    ??get_serial_commands_1
        B.N      ??get_serial_commands_27
??get_serial_commands_26:
        LDR.N    R1,??get_serial_commands_0+0x28
        CMP      R0,#+59
        BNE.N    ??get_serial_commands_28
        MOVS     R2,#+1
        STRB     R2,[R1, #+0]
??get_serial_commands_28:
        LDRB     R1,[R1, #+0]
        CMP      R1,#+0
        BNE.N    ??get_serial_commands_1
??get_serial_commands_27:
        LDR      R1,[R6, #+48]
        LDR.N    R2,??get_serial_commands_0+0x2C
        STRB     R0,[R2, R1]
        ADDS     R1,R1,#+1
        STR      R1,[R6, #+48]
        B.N      ??get_serial_commands_1
??get_serial_commands_23:
        POP      {R4-R10,PC}      ;; return
        Nop      
        DATA
??get_serial_commands_0:
        DC32     axis_relative_modes
        DC32     customizedSerial
        DC32     _ZZ19get_serial_commandsvE14last_wait_time
        DC32     _ZZ19get_serial_commandsvEs
        DC32     _ZZ19get_serial_commandsvEs_0
        DC32     _ZZ19get_serial_commandsvEs_6
        DC32     _ZZ19get_serial_commandsvEs_7
        DC32     _ZZ19get_serial_commandsvEs_8
        DC32     _ZZ19get_serial_commandsvEs_9
        DC32     mks_heating_busy
        DC32     _ZZ19get_serial_commandsvE19serial_comment_mode
        DC32     _ZZ19get_serial_commandsvE18serial_line_buffer
        DC32     _ZZ19get_serial_commandsvEs_1
        DC32     _ZZ19get_serial_commandsvEs_4
        DC32     _ZZ19get_serial_commandsvEs_5
        DC32     _ZZ19get_serial_commandsvEs_2
        DC32     _ZZ19get_serial_commandsvEs_3
          CFI EndBlock cfiBlock209

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z19get_sdcard_commandsv
          CFI Block cfiBlock210 Using cfiCommon0
          CFI Function _Z19get_sdcard_commandsv
        THUMB
_Z19get_sdcard_commandsv:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
        LDR.N    R6,??get_sdcard_commands_0
        LDRB     R0,[R6, #+2]
        CMP      R0,#+0
        BEQ.W    ??get_sdcard_commands_1
        LDR.N    R7,??get_sdcard_commands_0+0x4
        LDRB     R0,[R7, #+8]
        CMP      R0,#+0
        BNE.N    ??get_sdcard_commands_2
        MOVS     R0,#+0
        LDR.N    R1,??get_sdcard_commands_0+0x8
        STRB     R0,[R1, #+0]
??get_sdcard_commands_2:
        MOVS     R5,#+0
        MOV      R0,R6
          CFI FunCall _ZN10CardReader3eofEv
        BL       _ZN10CardReader3eofEv
        MOV      R4,R0
        LDR.W    R9,??get_sdcard_commands_0+0x8
        B.N      ??get_sdcard_commands_3
??get_sdcard_commands_4:
        CMN      R10,#+1
        BNE.N    ??get_sdcard_commands_5
        LDR.N    R0,??get_sdcard_commands_0+0xC
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??get_sdcard_commands_0+0x10
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??get_sdcard_commands_5:
        CMP      R8,#+35
        BNE.N    ??get_sdcard_commands_6
        MOVS     R0,#+1
        STRB     R0,[R9, #+0]
??get_sdcard_commands_6:
        MOVS     R0,#+0
        LDR.N    R1,??get_sdcard_commands_0+0x14
        STRB     R0,[R1, #+0]
        CMP      R5,#+0
        BEQ.N    ??get_sdcard_commands_3
        LDR.N    R0,??get_sdcard_commands_0+0x18
        LDRB     R1,[R7, #+10]
        ADD      R2,R1,R1, LSL #+1
        ADD      R0,R0,R2, LSL #+5
        MOVS     R1,#+0
        STRB     R1,[R0, R5]
        MOV      R5,R1
        MOV      R0,R1
          CFI FunCall _Z15_commit_commandb
        BL       _Z15_commit_commandb
??get_sdcard_commands_3:
        LDRB     R0,[R7, #+8]
        CMP      R0,#+4
        BGE.N    ??get_sdcard_commands_1
        CMP      R4,#+0
        BNE.N    ??get_sdcard_commands_1
        LDRB     R0,[R9, #+0]
        CMP      R0,#+0
        BNE.N    ??get_sdcard_commands_1
        MOV      R0,R6
          CFI FunCall _ZN10CardReader3getEv
        BL       _ZN10CardReader3getEv
        MOV      R10,R0
        MOV      R8,R10
        SXTB     R8,R8
        MOV      R0,R6
          CFI FunCall _ZN10CardReader3eofEv
        BL       _ZN10CardReader3eofEv
        MOVS     R4,R0
        BNE.N    ??get_sdcard_commands_7
        CMN      R10,#+1
        BEQ.N    ??get_sdcard_commands_7
        CMP      R8,#+10
        BEQ.N    ??get_sdcard_commands_7
        CMP      R8,#+13
        BEQ.N    ??get_sdcard_commands_7
        CMP      R8,#+35
        BEQ.N    ??get_sdcard_commands_8
        CMP      R8,#+58
        BNE.N    ??get_sdcard_commands_9
??get_sdcard_commands_8:
        LDR.N    R0,??get_sdcard_commands_0+0x14
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??get_sdcard_commands_9
??get_sdcard_commands_7:
        CMP      R4,#+0
        BEQ.N    ??get_sdcard_commands_4
        LDR.N    R0,??get_sdcard_commands_0+0x1C
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOV      R0,R6
          CFI FunCall _ZN10CardReader19printingHasFinishedEv
        BL       _ZN10CardReader19printingHasFinishedEv
        MOVS     R1,#+1
        MOV      R0,R6
          CFI FunCall _ZN10CardReader14checkautostartEb
        BL       _ZN10CardReader14checkautostartEb
        B.N      ??get_sdcard_commands_5
??get_sdcard_commands_9:
        CMP      R5,#+95
        BGE.N    ??get_sdcard_commands_3
        LDR.N    R0,??get_sdcard_commands_0+0x14
        CMP      R8,#+59
        BNE.N    ??get_sdcard_commands_10
        MOVS     R1,#+1
        STRB     R1,[R0, #+0]
??get_sdcard_commands_10:
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??get_sdcard_commands_3
        LDR.N    R0,??get_sdcard_commands_0+0x18
        LDRB     R1,[R7, #+10]
        ADD      R2,R1,R1, LSL #+1
        ADD      R0,R0,R2, LSL #+5
        STRB     R8,[R0, R5]
        ADDS     R5,R5,#+1
        UXTH     R5,R5
        CMP      R8,#+90
        BNE.N    ??get_sdcard_commands_3
        LDR.W    R8,??get_sdcard_commands_0+0x20
        MOV      R0,R6
          CFI FunCall _ZN10CardReader8getsdposEv
        BL       _ZN10CardReader8getsdposEv
        SUBS     R0,R0,#+3
        STR      R0,[R8, #+0]
        MOVS     R0,#+1
        STRB     R0,[R8, #+4]
        B.N      ??get_sdcard_commands_3
??get_sdcard_commands_1:
        POP      {R4-R10,PC}      ;; return
        Nop      
        DATA
??get_sdcard_commands_0:
        DC32     card
        DC32     axis_relative_modes
        DC32     _ZZ19get_sdcard_commandsvE14stop_buffering
        DC32     errormagic
        DC32     _ZZ19get_sdcard_commandsvEs_0
        DC32     _ZZ19get_sdcard_commandsvE15sd_comment_mode
        DC32     command_queue
        DC32     _ZZ19get_sdcard_commandsvEs
        DC32     mksReprint+0x6C
          CFI EndBlock cfiBlock210

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z17get_wifi_commandsv
          CFI Block cfiBlock211 Using cfiCommon0
          CFI Function _Z17get_wifi_commandsv
        THUMB
_Z17get_wifi_commandsv:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        LDR.N    R4,??get_wifi_commands_0
        LDR.N    R5,??get_wifi_commands_0+0x4
        LDRB     R0,[R5, #+14]
        CMP      R0,#+6
        BLT.N    ??get_wifi_commands_1
        MOVS     R0,#+1
        STRB     R0,[R4, #+7]
        B.N      ??get_wifi_commands_2
??get_wifi_commands_3:
        ADDS     R7,R7,#+1
??get_wifi_commands_4:
        LDRSB    R0,[R7, #+0]
        CMP      R0,#+32
        BEQ.N    ??get_wifi_commands_3
          CFI FunCall _Z9IsStoppedv
        BL       _Z9IsStoppedv
        CMP      R0,#+0
        BEQ.N    ??get_wifi_commands_5
        MOVS     R1,#+71
        MOV      R0,R7
          CFI FunCall __iar_Strchr
        BL       __iar_Strchr
        CMP      R0,#+0
        BEQ.N    ??get_wifi_commands_5
        MOVS     R2,#+10
        MOVS     R1,#+0
        ADDS     R0,R0,#+1
          CFI FunCall strtol
        BL       strtol
        CMP      R0,#+3
        BHI.N    ??get_wifi_commands_5
        LDR.N    R0,??get_wifi_commands_0+0x8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R1,#+0
        LDR.N    R0,??get_wifi_commands_0+0xC
          CFI FunCall _Z16lcd_setstatuspgmPKch
        BL       _Z16lcd_setstatuspgmPKch
??get_wifi_commands_5:
        LDR.N    R1,??get_wifi_commands_0+0x10
        MOV      R0,R7
          CFI FunCall strcmp
        BL       strcmp
        CMP      R0,#+0
        BNE.N    ??get_wifi_commands_6
        MOVS     R0,#+0
        STRB     R0,[R4, #+3]
        STRB     R0,[R4, #+4]
??get_wifi_commands_6:
        LDR.N    R1,??get_wifi_commands_0+0x14
        MOV      R0,R7
          CFI FunCall strcmp
        BL       strcmp
        CMP      R0,#+0
        BNE.N    ??get_wifi_commands_7
        LDR.N    R0,??get_wifi_commands_0+0x18
          CFI FunCall _Z4killPKc
        BL       _Z4killPKc
??get_wifi_commands_7:
        LDR.N    R1,??get_wifi_commands_0+0x1C
        MOV      R0,R7
          CFI FunCall strcmp
        BL       strcmp
        CMP      R0,#+0
        BNE.N    ??get_wifi_commands_8
          CFI FunCall _Z17quickstop_stepperv
        BL       _Z17quickstop_stepperv
??get_wifi_commands_8:
        MOVS     R1,#+1
        MOV      R0,R6
          CFI FunCall _Z15_enqueuecommandPKcb
        BL       _Z15_enqueuecommandPKcb
??get_wifi_commands_2:
        LDRB     R0,[R5, #+8]
        CMP      R0,#+3
        BGT.N    ??get_wifi_commands_9
        LDR.N    R0,??get_wifi_commands_0+0x20
        LDR      R1,[R0, #+96]
        LDR      R2,[R0, #+100]
        CMP      R1,R2
        BEQ.N    ??get_wifi_commands_9
        LDRSB    R2,[R0, R1]
        ADDS     R1,R1,#+1
        MOVS     R3,#+96
        UDIV     R3,R1,R3
        ADD      R6,R3,R3, LSL #+1
        SUB      R1,R1,R6, LSL #+5
        STR      R1,[R0, #+96]
        CMP      R2,#+10
        BEQ.N    ??get_wifi_commands_10
        CMP      R2,#+13
        BNE.N    ??get_wifi_commands_11
??get_wifi_commands_10:
        MOVS     R0,#+0
        LDR.N    R1,??get_wifi_commands_0+0x24
        STRB     R0,[R1, #+0]
        LDR      R0,[R5, #+52]
        CMP      R0,#+0
        BEQ.N    ??get_wifi_commands_2
        LDR.N    R6,??get_wifi_commands_0+0x28
        MOVS     R1,#+0
        STRB     R1,[R6, R0]
        MOV      R0,R1
        STR      R0,[R5, #+52]
        MOV      R7,R6
        B.N      ??get_wifi_commands_4
??get_wifi_commands_11:
        LDR      R1,[R5, #+52]
        CMP      R1,#+95
        BGE.N    ??get_wifi_commands_2
        LDR.N    R0,??get_wifi_commands_0+0x24
        CMP      R2,#+59
        BNE.N    ??get_wifi_commands_12
        MOVS     R3,#+1
        STRB     R3,[R0, #+0]
??get_wifi_commands_12:
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??get_wifi_commands_2
        LDR.N    R0,??get_wifi_commands_0+0x28
        STRB     R2,[R0, R1]
        ADDS     R1,R1,#+1
        STR      R1,[R5, #+52]
        B.N      ??get_wifi_commands_2
??get_wifi_commands_1:
        MOVS     R0,#+0
        STRB     R0,[R4, #+7]
??get_wifi_commands_9:
        POP      {R0,R4-R7,PC}    ;; return
        DATA
??get_wifi_commands_0:
        DC32     mks_heating_busy
        DC32     axis_relative_modes
        DC32     _ZZ17get_wifi_commandsvEs
        DC32     _ZZ17get_wifi_commandsvEs_0
        DC32     _ZZ17get_wifi_commandsvEs_1
        DC32     _ZZ17get_wifi_commandsvEs_2
        DC32     _ZZ17get_wifi_commandsvEs_3
        DC32     _ZZ17get_wifi_commandsvEs_4
        DC32     espGcodeFifo
        DC32     _ZZ17get_wifi_commandsvE17wifi_comment_mode
        DC32     _ZZ17get_wifi_commandsvE16wifi_line_buffer
          CFI EndBlock cfiBlock211

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z14code_has_valuev
          CFI Block cfiBlock212 Using cfiCommon0
          CFI Function _Z14code_has_valuev
          CFI NoCalls
        THUMB
_Z14code_has_valuev:
        MOVS     R0,#+1
        LDR.N    R1,??code_has_value_0
        LDR      R1,[R1, #+44]
        LDRSB    R2,[R1, #+1]
        B.N      ??code_has_value_1
??code_has_value_2:
        ADDS     R0,R0,#+1
        LDRSB    R2,[R1, R0]
??code_has_value_1:
        CMP      R2,#+32
        BEQ.N    ??code_has_value_2
        CMP      R2,#+45
        BEQ.N    ??code_has_value_3
        CMP      R2,#+43
        BNE.N    ??code_has_value_4
??code_has_value_3:
        ADDS     R0,R0,#+1
        LDRSB    R2,[R1, R0]
??code_has_value_4:
        CMP      R2,#+46
        BNE.N    ??code_has_value_5
        ADDS     R1,R1,#+1
        LDRSB    R2,[R1, R0]
??code_has_value_5:
        SUBS     R2,R2,#+48
        CMP      R2,#+10
        SBCS     R0,R0,R0
        LSRS     R0,R0,#+31
        BX       LR               ;; return
        Nop      
        DATA
??code_has_value_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock212

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z16code_value_floatv
          CFI Block cfiBlock213 Using cfiCommon0
          CFI Function _Z16code_value_floatv
        THUMB
_Z16code_value_floatv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.N    R0,??code_value_float_0
        LDR      R5,[R0, #+44]
        MOVS     R1,#+69
        MOV      R0,R5
          CFI FunCall __iar_Strchr
        BL       __iar_Strchr
        MOVS     R4,R0
        BNE.N    ??code_value_float_1
        MOVS     R1,#+0
        ADDS     R0,R5,#+1
          CFI FunCall strtod
        BL       strtod
        POP      {R2,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall __aeabi_d2f
        B.W      __aeabi_d2f
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??code_value_float_1:
        MOVS     R0,#+0
        STRB     R0,[R4, #+0]
        MOV      R1,R0
        ADDS     R0,R5,#+1
          CFI FunCall strtod
        BL       strtod
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOVS     R1,#+69
        STRB     R1,[R4, #+0]
        POP      {R1,R4,R5,PC}    ;; return
        DATA
??code_value_float_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock213

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z16code_value_ulongv
          CFI Block cfiBlock214 Using cfiCommon0
          CFI Function _Z16code_value_ulongv
        THUMB
_Z16code_value_ulongv:
        MOVS     R2,#+10
        MOVS     R1,#+0
        LDR.N    R0,??code_value_ulong_0
        LDR      R0,[R0, #+44]
        ADDS     R0,R0,#+1
          CFI FunCall strtoul
        B.W      strtoul
        Nop      
        DATA
??code_value_ulong_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock214

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z15code_value_longv
          CFI Block cfiBlock215 Using cfiCommon0
          CFI Function _Z15code_value_longv
        THUMB
_Z15code_value_longv:
        MOVS     R2,#+10
        MOVS     R1,#+0
        LDR.N    R0,??code_value_long_0
        LDR      R0,[R0, #+44]
        ADDS     R0,R0,#+1
          CFI FunCall strtol
        B.W      strtol
        Nop      
        DATA
??code_value_long_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock215

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z14code_value_intv
          CFI Block cfiBlock216 Using cfiCommon0
          CFI Function _Z14code_value_intv
        THUMB
_Z14code_value_intv:
        MOVS     R2,#+10
        MOVS     R1,#+0
        LDR.N    R0,??code_value_int_0
        LDR      R0,[R0, #+44]
        ADDS     R0,R0,#+1
          CFI FunCall strtol
        B.W      strtol
        Nop      
        DATA
??code_value_int_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock216

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z17code_value_ushortv
          CFI Block cfiBlock217 Using cfiCommon0
          CFI Function _Z17code_value_ushortv
        THUMB
_Z17code_value_ushortv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R2,#+10
        MOVS     R1,#+0
        LDR.N    R0,??code_value_ushort_0
        LDR      R0,[R0, #+44]
        ADDS     R0,R0,#+1
          CFI FunCall strtoul
        BL       strtoul
        UXTH     R0,R0
        POP      {R1,PC}          ;; return
        DATA
??code_value_ushort_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock217

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z15code_value_bytev
          CFI Block cfiBlock218 Using cfiCommon0
          CFI Function _Z15code_value_bytev
        THUMB
_Z15code_value_bytev:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R4,??code_value_byte_0
        MOVS     R2,#+10
        MOVS     R1,#+0
        LDR      R0,[R4, #+44]
        ADDS     R0,R0,#+1
          CFI FunCall strtol
        BL       strtol
        CMP      R0,#+0
        BPL.N    ??code_value_byte_1
        MOVS     R0,#+0
        B.N      ??code_value_byte_2
??code_value_byte_1:
        MOVS     R2,#+10
        MOVS     R1,#+0
        LDR      R0,[R4, #+44]
        ADDS     R0,R0,#+1
          CFI FunCall strtol
        BL       strtol
        CMP      R0,#+256
        BLT.N    ??code_value_byte_3
        MOVS     R0,#+255
        B.N      ??code_value_byte_2
??code_value_byte_3:
        MOVS     R2,#+10
        MOVS     R1,#+0
        LDR      R0,[R4, #+44]
        ADDS     R0,R0,#+1
          CFI FunCall strtol
        BL       strtol
??code_value_byte_2:
        UXTB     R0,R0
        POP      {R4,PC}          ;; return
        Nop      
        DATA
??code_value_byte_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock218

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z15code_value_boolv
          CFI Block cfiBlock219 Using cfiCommon0
          CFI Function _Z15code_value_boolv
        THUMB
_Z15code_value_boolv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _Z14code_has_valuev
        BL       _Z14code_has_valuev
        CMP      R0,#+0
        BEQ.N    ??code_value_bool_0
          CFI FunCall _Z15code_value_bytev
        BL       _Z15code_value_bytev
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
        POP      {R1,PC}
??code_value_bool_0:
        MOVS     R0,#+1
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock219

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z17code_value_millisv
          CFI Block cfiBlock220 Using cfiCommon0
          CFI Function _Z17code_value_millisv
          CFI FunCall _Z16code_value_ulongv
        THUMB
_Z17code_value_millisv:
        B.W      _Z16code_value_ulongv
          CFI EndBlock cfiBlock220

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z30code_value_millis_from_secondsv
          CFI Block cfiBlock221 Using cfiCommon0
          CFI Function _Z30code_value_millis_from_secondsv
        THUMB
_Z30code_value_millis_from_secondsv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        LDR.N    R1,??code_value_millis_from_seconds_0  ;; 0x447a0000
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall __aeabi_f2uiz
        B.W      __aeabi_f2uiz
        DATA
??code_value_millis_from_seconds_0:
        DC32     0x447a0000
          CFI EndBlock cfiBlock221

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z24get_homing_bump_feedrate8AxisEnum
          CFI Block cfiBlock222 Using cfiCommon0
          CFI Function _Z24get_homing_bump_feedrate8AxisEnum
        THUMB
_Z24get_homing_bump_feedrate8AxisEnum:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        SUB      SP,SP,#+16
          CFI CFA R13+32
        MOV      R4,R0
        MOV      R0,SP
        LDR.N    R1,??get_homing_bump_feedrate_0
        LDRSH    R1,[R1, #+88]
        CMP      R1,#+2
        BNE.N    ??get_homing_bump_feedrate_1
        MOVS     R1,#+10
        STR      R1,[SP, #+0]
        STR      R1,[R0, #+4]
        STR      R1,[R0, #+8]
        B.N      ??get_homing_bump_feedrate_2
??get_homing_bump_feedrate_1:
        MOVS     R1,#+2
        STR      R1,[SP, #+0]
        STR      R1,[R0, #+4]
        MOVS     R1,#+4
        STR      R1,[R0, #+8]
??get_homing_bump_feedrate_2:
        LDR      R5,[R0, R4, LSL #+2]
        CMP      R5,#+1
        BGE.N    ??get_homing_bump_feedrate_3
        MOVS     R5,#+10
        LDR.N    R0,??get_homing_bump_feedrate_0+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??get_homing_bump_feedrate_0+0x8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??get_homing_bump_feedrate_3:
        MOV      R0,R5
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        LDR.N    R0,??get_homing_bump_feedrate_0+0xC
        ADD      R0,R0,R4, LSL #+2
        LDR      R0,[R0, #+40]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        ADD      SP,SP,#+20
          CFI CFA R13+12
        POP      {R4,R5,PC}       ;; return
        DATA
??get_homing_bump_feedrate_0:
        DC32     mksCfg
        DC32     echomagic
        DC32     _ZZ24get_homing_bump_feedrate8AxisEnumEs
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock222

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z24line_to_current_positionv
          CFI Block cfiBlock223 Using cfiCommon0
          CFI Function _Z24line_to_current_positionv
        THUMB
_Z24line_to_current_positionv:
        PUSH     {R5-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
        LDR.N    R0,??line_to_current_position_0
        LDRB     R1,[R0, #+2]
        STR      R1,[SP, #+4]
        ADD      R1,R0,#+116
        STR      R1,[SP, #+0]
        ADD      R3,R0,#+20
        LDR      R2,[R0, #+16]
        LDR      R1,[R0, #+12]
        LDR      R0,[R0, #+8]
          CFI FunCall _ZN7Planner11buffer_lineEfffRKfS1_h
        BL       _ZN7Planner11buffer_lineEfffRKfS1_h
        POP      {R0-R2,PC}       ;; return
        Nop      
        DATA
??line_to_current_position_0:
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock223

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z19line_to_destinationf
          CFI Block cfiBlock224 Using cfiCommon0
          CFI Function _Z19line_to_destinationf
        THUMB
_Z19line_to_destinationf:
        PUSH     {R0,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        SUB      SP,SP,#+8
          CFI CFA R13+16
        LDR.N    R0,??line_to_destination_0
        LDRB     R1,[R0, #+2]
        STR      R1,[SP, #+4]
        ADD      R1,SP,#+8
        STR      R1,[SP, #+0]
        ADD      R3,R0,#+36
        LDR      R2,[R0, #+32]
        LDR      R1,[R0, #+28]
        LDR      R0,[R0, #+24]
          CFI FunCall _ZN7Planner11buffer_lineEfffRKfS1_h
        BL       _ZN7Planner11buffer_lineEfffRKfS1_h
        POP      {R0-R2,PC}       ;; return
        Nop      
        DATA
??line_to_destination_0:
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock224

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z19line_to_destinationv
          CFI Block cfiBlock225 Using cfiCommon0
          CFI Function _Z19line_to_destinationv
        THUMB
_Z19line_to_destinationv:
        LDR.N    R0,??line_to_destination_1
        LDR      R0,[R0, #+116]
          CFI FunCall _Z19line_to_destinationf
        B.W      _Z19line_to_destinationf
        DATA
??line_to_destination_1:
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock225

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z26set_current_to_destinationv
          CFI Block cfiBlock226 Using cfiCommon0
          CFI Function _Z26set_current_to_destinationv
        THUMB
_Z26set_current_to_destinationv:
        LDR.N    R0,??set_current_to_destination_0
        MOVS     R2,#+16
        ADD      R1,R0,#+24
        ADDS     R0,R0,#+8
          CFI FunCall __aeabi_memcpy
        B.W      __aeabi_memcpy
        Nop      
        DATA
??set_current_to_destination_0:
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock226

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z26set_destination_to_currentv
          CFI Block cfiBlock227 Using cfiCommon0
          CFI Function _Z26set_destination_to_currentv
        THUMB
_Z26set_destination_to_currentv:
        LDR.N    R0,??set_destination_to_current_0
        MOVS     R2,#+16
        ADD      R1,R0,#+8
        ADDS     R0,R0,#+24
          CFI FunCall __aeabi_memcpy
        B.W      __aeabi_memcpy
        Nop      
        DATA
??set_destination_to_current_0:
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock227

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z14do_probe_raisef
          CFI Block cfiBlock228 Using cfiCommon0
          CFI Function _Z14do_probe_raisef
        THUMB
_Z14do_probe_raisef:
        PUSH     {R2-R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+16
        MOV      R1,R0
        LDR.N    R4,??do_probe_raise_0
        LDR      R0,[R4, #+76]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[SP, #+0]
        LDR.N    R0,??do_probe_raise_0+0x4
        LDR      R2,[R0, #+72]
        MOV      R0,R2
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_probe_raise_1
        LDR      R0,[SP, #+0]
        MOV      R1,R2
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+0]
??do_probe_raise_1:
        LDR.N    R0,??do_probe_raise_0+0x8
        LDRSH    R0,[R0, #+88]
        CMP      R0,#+2
        BNE.N    ??do_probe_raise_2
        LDR      R0,[SP, #+0]
        LDR      R1,[R4, #+64]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+0]
??do_probe_raise_2:
        LDR      R0,[R4, #+16]
        LDR      R1,[SP, #+0]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_probe_raise_3
        MOVS     R0,#+0
        STR      R0,[SP, #+4]
        ADD      R1,SP,#+4
        MOV      R0,SP
          CFI FunCall _Z21do_blocking_move_to_zRKfS0_
        BL       _Z21do_blocking_move_to_zRKfS0_
??do_probe_raise_3:
        POP      {R0,R1,R4,PC}    ;; return
        Nop      
        DATA
??do_probe_raise_0:
        DC32     mks_heating_busy
        DC32     axis_homed
        DC32     mksCfg
          CFI EndBlock cfiBlock228

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z11gcode_G0_G1v
          CFI Block cfiBlock229 Using cfiCommon0
          CFI Function _Z11gcode_G0_G1v
        THUMB
_Z11gcode_G0_G1v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _Z9IsRunningv
        BL       _Z9IsRunningv
        CMP      R0,#+0
        BEQ.N    ??gcode_G0_G1_0
          CFI FunCall _Z21gcode_get_destinationv
        BL       _Z21gcode_get_destinationv
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z27prepare_move_to_destinationv
        B.W      _Z27prepare_move_to_destinationv
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_G0_G1_0:
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock229

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z17gcode_G0_G1_SCARAb
          CFI Block cfiBlock230 Using cfiCommon0
          CFI Function _Z17gcode_G0_G1_SCARAb
        THUMB
_Z17gcode_G0_G1_SCARAb:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
          CFI FunCall _Z9IsRunningv
        BL       _Z9IsRunningv
        CMP      R0,#+0
        BEQ.N    ??gcode_G0_G1_SCARA_0
          CFI FunCall _Z21gcode_get_destinationv
        BL       _Z21gcode_get_destinationv
        CMP      R4,#+0
        BEQ.N    ??gcode_G0_G1_SCARA_1
        MOVS     R0,#+0
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z42prepare_uninterpolated_move_to_destinationf
        B.W      _Z42prepare_uninterpolated_move_to_destinationf
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_G0_G1_SCARA_1:
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z27prepare_move_to_destinationv
        B.W      _Z27prepare_move_to_destinationv
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_G0_G1_SCARA_0:
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock230

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z11gcode_G2_G3b
          CFI Block cfiBlock231 Using cfiCommon0
          CFI Function _Z11gcode_G2_G3b
        THUMB
_Z11gcode_G2_G3b:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        SUB      SP,SP,#+36
          CFI CFA R13+72
        MOV      R4,R0
          CFI FunCall _Z9IsRunningv
        BL       _Z9IsRunningv
        CMP      R0,#+0
        BEQ.W    ??gcode_G2_G3_1
          CFI FunCall _Z21gcode_get_destinationv
        BL       _Z21gcode_get_destinationv
        ADD      R0,SP,#+20
        MOVS     R1,#+0
        MOV      R2,R1
        STRD     R1,R2,[R0, #+0]
        STRB     R4,[SP, #+0]
        MOVS     R0,#+82
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.W    ??gcode_G2_G3_2
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        MOV      R5,R0
        LDR.N    R0,??gcode_G2_G3_0
        LDR      R1,[R0, #+8]
        STR      R1,[SP, #+8]
        LDR      R1,[R0, #+12]
        STR      R1,[SP, #+4]
        LDR      R1,[R0, #+24]
        STR      R1,[SP, #+16]
        LDR      R0,[R0, #+28]
        STR      R0,[SP, #+12]
        MOV      R0,R5
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.W    ??gcode_G2_G3_3
        LDR      R0,[SP, #+16]
        LDR      R1,[SP, #+8]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??gcode_G2_G3_4
        LDR      R0,[SP, #+12]
        LDR      R1,[SP, #+4]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.W    ??gcode_G2_G3_3
??gcode_G2_G3_4:
        MOV      R0,R5
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_G2_G3_5
        MOVS     R0,#+1
        B.N      ??gcode_G2_G3_6
??gcode_G2_G3_5:
        MOV      R0,R1
??gcode_G2_G3_6:
        MOV      R7,#+1065353216
        LDRB     R1,[SP, #+0]
        TEQ      R0,R1
        BEQ.N    ??gcode_G2_G3_7
        LDR.N    R6,??gcode_G2_G3_0+0x4  ;; 0xbf800000
        B.N      ??gcode_G2_G3_8
??gcode_G2_G3_7:
        MOV      R6,R7
??gcode_G2_G3_8:
        LDR      R0,[SP, #+16]
        LDR      R1,[SP, #+8]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+32]
        LDR      R0,[SP, #+12]
        LDR      R1,[SP, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+28]
        LDR      R9,[SP, #+32]
        MOVS     R4,#+2
        MOV      R8,R7
        B.N      ??gcode_G2_G3_9
??gcode_G2_G3_10:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??gcode_G2_G3_9:
        LSLS     R0,R4,#+31
        BPL.N    ??gcode_G2_G3_11
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??gcode_G2_G3_11:
        LSRS     R4,R4,#+1
        BNE.N    ??gcode_G2_G3_10
        LDR      R9,[SP, #+28]
        MOVS     R4,#+2
        MOV      R10,R7
        B.N      ??gcode_G2_G3_12
??gcode_G2_G3_13:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??gcode_G2_G3_12:
        LSLS     R0,R4,#+31
        BPL.N    ??gcode_G2_G3_14
        MOV      R0,R10
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??gcode_G2_G3_14:
        LSRS     R4,R4,#+1
        BNE.N    ??gcode_G2_G3_13
        MOV      R0,R8
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R10,R0
        MOVS     R4,#+2
        B.N      ??gcode_G2_G3_15
??gcode_G2_G3_16:
        MOV      R0,R5
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
??gcode_G2_G3_15:
        LSLS     R0,R4,#+31
        BPL.N    ??gcode_G2_G3_17
        MOV      R0,R7
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??gcode_G2_G3_17:
        LSRS     R4,R4,#+1
        BNE.N    ??gcode_G2_G3_16
        MOV      R0,R10
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        LDR.N    R3,??gcode_G2_G3_0+0x8  ;; 0x3fe00000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R11,#+2
        MOVS     R4,#+0
        LDR.N    R5,??gcode_G2_G3_0+0xC  ;; 0x3ff00000
        MOV      R8,R0
        MOV      R9,R1
        B.N      ??gcode_G2_G3_18
??gcode_G2_G3_19:
        MOV      R0,R8
        MOV      R1,R9
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R8,R0
        MOV      R9,R1
??gcode_G2_G3_18:
        LSLS     R0,R11,#+31
        BPL.N    ??gcode_G2_G3_20
        MOV      R2,R8
        MOV      R3,R9
        MOV      R0,R4
        MOV      R1,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R4,R0
        MOV      R5,R1
??gcode_G2_G3_20:
        LSRS     R11,R11,#+1
        BNE.N    ??gcode_G2_G3_19
        MOV      R0,R7
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dsub
        BL       __aeabi_dsub
          CFI FunCall sqrt
        BL       sqrt
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R1,R0
        MOV      R0,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
        MOV      R5,#+1056964608
        LDR      R1,[SP, #+8]
        LDR      R0,[SP, #+16]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
        LDR      R0,[SP, #+28]
        MOV      R1,R10
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R6
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[SP, #+8]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+20]
        LDR      R1,[SP, #+4]
        LDR      R0,[SP, #+12]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
        LDR      R0,[SP, #+32]
        MOV      R1,R10
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R5
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR      R1,[SP, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+24]
        B.N      ??gcode_G2_G3_3
??gcode_G2_G3_2:
        MOVS     R0,#+73
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_G2_G3_21
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        STR      R0,[SP, #+20]
??gcode_G2_G3_21:
        MOVS     R0,#+74
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_G2_G3_3
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        STR      R0,[SP, #+24]
??gcode_G2_G3_3:
        LDR      R0,[SP, #+20]
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??gcode_G2_G3_22
        LDR      R0,[SP, #+24]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??gcode_G2_G3_23
??gcode_G2_G3_22:
        LDRB     R2,[SP, #+0]
        ADD      R1,SP,#+20
        LDR.N    R0,??gcode_G2_G3_0+0x10
          CFI FunCall _Z8plan_arcPfS_h
        BL       _Z8plan_arcPfS_h
          CFI FunCall _Z19refresh_cmd_timeoutv
        BL       _Z19refresh_cmd_timeoutv
        B.N      ??gcode_G2_G3_1
??gcode_G2_G3_23:
        LDR.N    R0,??gcode_G2_G3_0+0x14
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_G2_G3_0+0x18
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_G2_G3_1:
        ADD      SP,SP,#+36
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
        Nop      
        DATA
??gcode_G2_G3_0:
        DC32     mks_heating_busy
        DC32     0xbf800000
        DC32     0x3fe00000
        DC32     0x3ff00000
        DC32     mks_heating_busy+0x18
        DC32     errormagic
        DC32     _ZZ11gcode_G2_G3bEs
          CFI EndBlock cfiBlock231

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z8gcode_G4v
          CFI Block cfiBlock232 Using cfiCommon0
          CFI Function _Z8gcode_G4v
        THUMB
_Z8gcode_G4v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R4,#+0
        MOVS     R0,#+80
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_G4_1
          CFI FunCall _Z17code_value_millisv
        BL       _Z17code_value_millisv
        MOV      R4,R0
??gcode_G4_1:
        MOVS     R0,#+83
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_G4_2
          CFI FunCall _Z30code_value_millis_from_secondsv
        BL       _Z30code_value_millis_from_secondsv
        MOV      R4,R0
??gcode_G4_2:
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
          CFI FunCall _Z19refresh_cmd_timeoutv
        BL       _Z19refresh_cmd_timeoutv
        LDR.N    R0,??gcode_G4_0
        LDR      R0,[R0, #+56]
        ADDS     R4,R0,R4
          CFI FunCall _Z13lcd_hasstatusv
        BL       _Z13lcd_hasstatusv
        CMP      R0,#+0
        BNE.N    ??gcode_G4_3
        MOVS     R1,#+0
        LDR.N    R0,??gcode_G4_0+0x4
          CFI FunCall _Z16lcd_setstatuspgmPKch
        BL       _Z16lcd_setstatuspgmPKch
        B.N      ??gcode_G4_3
??gcode_G4_4:
        MOVS     R0,#+0
          CFI FunCall _Z4idleb
        BL       _Z4idleb
??gcode_G4_3:
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        SUBS     R0,R0,R4
        BMI.N    ??gcode_G4_4
        POP      {R4,PC}          ;; return
        DATA
??gcode_G4_0:
        DC32     axis_relative_modes
        DC32     _ZZ8gcode_G4vEs
          CFI EndBlock cfiBlock232

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10home_deltav
          CFI Block cfiBlock233 Using cfiCommon0
          CFI Function _Z10home_deltav
        THUMB
_Z10home_deltav:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R4,??home_delta_0
        MOVS     R2,#+0
        MOVS     R1,#+16
        ADD      R0,R4,#+8
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
          CFI FunCall _Z18sync_plan_positionv
        BL       _Z18sync_plan_positionv
        LDR.N    R1,??home_delta_0+0x4
        LDR      R0,[R1, #+28]
        LDR      R1,[R1, #+16]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR.N    R1,??home_delta_0+0x8  ;; 0x41200000
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+16]
        STR      R0,[R4, #+12]
        STR      R0,[R4, #+8]
        LDR      R0,[R4, #+40]
        STR      R0,[R4, #+116]
          CFI FunCall _Z24line_to_current_positionv
        BL       _Z24line_to_current_positionv
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
          CFI FunCall _ZN8Endstops14hit_on_purposeEv
        BL       _ZN8Endstops14hit_on_purposeEv
        MOVS     R0,#+0
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_317853198homeaxisE8AxisEnum
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_317853198homeaxisE8AxisEnum
        MOVS     R0,#+1
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_317853198homeaxisE8AxisEnum
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_317853198homeaxisE8AxisEnum
        MOVS     R0,#+2
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_317853198homeaxisE8AxisEnum
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_317853198homeaxisE8AxisEnum
        MOVS     R4,#+0
        B.N      ??home_delta_1
??home_delta_2:
        MOV      R0,R4
        SXTB     R0,R0
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531919set_axis_is_at_homeE8AxisEnum
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531919set_axis_is_at_homeE8AxisEnum
        ADDS     R4,R4,#+1
??home_delta_1:
        MOV      R0,R4
        UXTB     R0,R0
        CMP      R0,#+3
        BLT.N    ??home_delta_2
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        B.W      _Z28SYNC_PLAN_POSITION_KINEMATICv
        Nop      
        DATA
??home_delta_0:
        DC32     mks_heating_busy
        DC32     mksCfg
        DC32     0x41200000
          CFI EndBlock cfiBlock233

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_G28v
          CFI Block cfiBlock234 Using cfiCommon0
          CFI Function _Z9gcode_G28v
        THUMB
_Z9gcode_G28v:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        LDR.W    R11,??gcode_G28_0
        ADD      R9,R11,#+63
        LDRB     R0,[R9, #+1]
        CMP      R0,#+16
        BNE.N    ??gcode_G28_1
        LDR.N    R1,??gcode_G28_0+0x4
        LDRB     R10,[R1, #+0]
??gcode_G28_1:
        TST      R0,#0x3E
        BEQ.N    ??gcode_G28_2
        MOVS     R0,#+0
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
??gcode_G28_2:
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531931setup_for_endstop_or_probe_moveEv
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531931setup_for_endstop_or_probe_moveEv
        MOVS     R0,#+1
          CFI FunCall _ZN8Endstops6enableEb
        BL       _ZN8Endstops6enableEb
        LDRSH    R0,[R11, #+88]
        CMP      R0,#+2
        BNE.N    ??gcode_G28_3
          CFI FunCall _Z10home_deltav
        BL       _Z10home_deltav
        B.N      ??gcode_G28_4
??gcode_G28_3:
        MOVS     R0,#+88
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        MOV      R6,R0
        MOVS     R0,#+89
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        MOV      R5,R0
        MOVS     R0,#+90
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        MOV      R7,R0
        ORR      R8,R5,R6
        ORRS     R0,R7,R8
        BEQ.N    ??gcode_G28_5
        CMP      R6,#+0
        BEQ.N    ??gcode_G28_6
        CMP      R5,#+0
        BEQ.N    ??gcode_G28_6
        MOV      R4,R7
        SUBS     R4,R4,#+1
        SBCS     R4,R4,R4
        MVNS     R4,R4
        LSRS     R4,R4,#+31
        B.N      ??gcode_G28_7
??gcode_G28_5:
        MOVS     R4,#+1
        B.N      ??gcode_G28_7
??gcode_G28_6:
        MOVS     R4,#+0
??gcode_G28_7:
          CFI FunCall _Z26set_destination_to_currentv
        BL       _Z26set_destination_to_currentv
        LDRSB    R0,[R11, #+6]
        CMP      R0,#+0
        BLE.N    ??gcode_G28_8
        CMP      R4,#+0
        BNE.N    ??gcode_G28_9
        CMP      R7,#+0
        BEQ.N    ??gcode_G28_10
??gcode_G28_9:
        MOVS     R0,#+2
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_317853198homeaxisE8AxisEnum
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_317853198homeaxisE8AxisEnum
        B.N      ??gcode_G28_10
??gcode_G28_8:
        CMP      R4,#+0
        BNE.N    ??gcode_G28_11
        CMP      R8,#+0
        BEQ.N    ??gcode_G28_10
??gcode_G28_11:
        LDR.N    R0,??gcode_G28_0+0x8
        LDRB     R0,[R0, #+104]
        CMP      R0,#+171
        BEQ.N    ??gcode_G28_10
        LDR.N    R2,??gcode_G28_0+0xC
        LDR      R1,[R2, #+76]
        STR      R1,[R2, #+32]
        LDR      R0,[R2, #+16]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_G28_10
        MOVS     R0,#+0
        STR      R0,[SP, #+0]
        MOV      R1,SP
        ADD      R0,R2,#+32
          CFI FunCall _Z21do_blocking_move_to_zRKfS0_
        BL       _Z21do_blocking_move_to_zRKfS0_
??gcode_G28_10:
        LDRH     R0,[R11, #+88]
        TST      R0,#0x300
        BEQ.N    ??gcode_G28_12
        CMP      R4,#+0
        BNE.N    ??gcode_G28_13
        CMP      R6,#+0
        BEQ.N    ??gcode_G28_12
        CMP      R5,#+0
        BEQ.N    ??gcode_G28_12
??gcode_G28_13:
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531913quick_home_xyEv
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531913quick_home_xyEv
??gcode_G28_12:
        LDRB     R0,[R9, #+0]
        CMP      R0,#+0
        BEQ.N    ??gcode_G28_14
        CMP      R4,#+0
        BNE.N    ??gcode_G28_15
        CMP      R5,#+0
        BEQ.N    ??gcode_G28_14
??gcode_G28_15:
        MOVS     R0,#+1
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_317853198homeaxisE8AxisEnum
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_317853198homeaxisE8AxisEnum
??gcode_G28_14:
        CMP      R4,#+0
        BNE.N    ??gcode_G28_16
        CMP      R6,#+0
        BEQ.N    ??gcode_G28_17
??gcode_G28_16:
        MOVS     R0,#+0
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_317853198homeaxisE8AxisEnum
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_317853198homeaxisE8AxisEnum
??gcode_G28_17:
        LDRB     R0,[R9, #+0]
        CMP      R0,#+0
        BNE.N    ??gcode_G28_18
        CMP      R4,#+0
        BNE.N    ??gcode_G28_19
        CMP      R5,#+0
        BEQ.N    ??gcode_G28_18
??gcode_G28_19:
        MOVS     R0,#+1
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_317853198homeaxisE8AxisEnum
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_317853198homeaxisE8AxisEnum
??gcode_G28_18:
        LDRSB    R0,[R11, #+6]
        CMP      R0,#+0
        BPL.N    ??gcode_G28_20
        CMP      R4,#+0
        BNE.N    ??gcode_G28_21
        CMP      R7,#+0
        BEQ.N    ??gcode_G28_20
??gcode_G28_21:
        MOVS     R0,#+2
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_317853198homeaxisE8AxisEnum
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_317853198homeaxisE8AxisEnum
??gcode_G28_20:
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
??gcode_G28_4:
          CFI FunCall _ZN8Endstops10not_homingEv
        BL       _ZN8Endstops10not_homingEv
        LDRB     R0,[R9, #+1]
        CMP      R0,#+16
        BNE.N    ??gcode_G28_22
        MOV      R0,R10
        UXTB     R0,R0
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
??gcode_G28_22:
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531936clean_up_after_endstop_or_probe_moveEv
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531936clean_up_after_endstop_or_probe_moveEv
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531923report_current_positionEv
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531923report_current_positionEv
        POP      {R0,R4-R11,PC}   ;; return
        DATA
??gcode_G28_0:
        DC32     mksCfg
        DC32     _ZN20unified_bed_leveling5stateE
        DC32     mksReprint
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock234

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z15_manual_goto_xyRKfS0_
          CFI Block cfiBlock235 Using cfiCommon0
          CFI Function _Z15_manual_goto_xyRKfS0_
        THUMB
_Z15_manual_goto_xyRKfS0_:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        MOV      R6,R0
        MOV      R7,R1
        LDR.N    R4,??_manual_goto_xy_0
        LDR      R5,[R4, #+116]
        LDR      R0,[R4, #+48]
        STR      R0,[R4, #+116]
        LDR.W    R8,??_manual_goto_xy_0+0x4
        LDR      R1,[R8, #+16]
        LDR      R0,[R4, #+76]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR      R1,[R8, #+104]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+16]
          CFI FunCall _Z24line_to_current_positionv
        BL       _Z24line_to_current_positionv
        LDR      R0,[R8, #+116]
        LDR.N    R1,??_manual_goto_xy_0+0x8  ;; 0x42700000
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[R4, #+116]
        LDR      R1,[R6, #+0]
        LDR      R0,[R4, #+68]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+8]
        LDR      R1,[R7, #+0]
        LDR      R0,[R4, #+72]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+12]
          CFI FunCall _Z24line_to_current_positionv
        BL       _Z24line_to_current_positionv
        LDR      R0,[R4, #+48]
        STR      R0,[R4, #+116]
        LDR      R1,[R8, #+16]
        LDR      R0,[R4, #+76]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??_manual_goto_xy_0+0xC  ;; 0x9999999a
        LDR.N    R3,??_manual_goto_xy_0+0x10  ;; 0x3fc99999
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R4, #+16]
          CFI FunCall _Z24line_to_current_positionv
        BL       _Z24line_to_current_positionv
        STR      R5,[R4, #+116]
        POP      {R4-R8,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Stepper11synchronizeEv
        B.W      _ZN7Stepper11synchronizeEv
        Nop      
        DATA
??_manual_goto_xy_0:
        DC32     mks_heating_busy
        DC32     mksCfg
        DC32     0x42700000
        DC32     0x9999999a
        DC32     0x3fc99999
          CFI EndBlock cfiBlock235

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z27gcode_G29_MESH_BED_LEVELINGv
          CFI Block cfiBlock236 Using cfiCommon0
          CFI Function _Z27gcode_G29_MESH_BED_LEVELINGv
        THUMB
_Z27gcode_G29_MESH_BED_LEVELINGv:
        PUSH     {R2-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+24
        MOVS     R0,#+83
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_MESH_BED_LEVELING_2
          CFI FunCall _Z15code_value_bytev
        BL       _Z15code_value_bytev
        SXTB     R0,R0
        B.N      ??gcode_G29_MESH_BED_LEVELING_3
??gcode_G29_MESH_BED_LEVELING_2:
        MOVS     R0,#+0
??gcode_G29_MESH_BED_LEVELING_3:
        CMP      R0,#+6
        BCC.N    ??gcode_G29_MESH_BED_LEVELING_4
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        POP      {R0,R1,R4-R6,PC}
??gcode_G29_MESH_BED_LEVELING_4:
        CMP      R0,#+5
        BHI.W    ??gcode_G29_MESH_BED_LEVELING_5
        TBH      [PC, R0, LSL #+1]
        DATA
??gcode_G29_MESH_BED_LEVELING_0:
        DC16     0x6,0x29,0x32,0x9A
        DC16     0x105,0x120
          CFI FunCall _ZN17mesh_bed_leveling8has_meshEv
        THUMB
??gcode_G29_MESH_BED_LEVELING_6:
        BL       _ZN17mesh_bed_leveling8has_meshEv
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_MESH_BED_LEVELING_7
          CFI FunCall _ZN17mesh_bed_leveling6activeEv
        BL       _ZN17mesh_bed_leveling6activeEv
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_MESH_BED_LEVELING_8
        LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_1+0x4
        B.N      ??gcode_G29_MESH_BED_LEVELING_9
??gcode_G29_MESH_BED_LEVELING_8:
        LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_1+0x8
??gcode_G29_MESH_BED_LEVELING_9:
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0xC
          CFI FunCall _Z17serial_echopair_PPKcS0_
        BL       _Z17serial_echopair_PPKcS0_
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x10
        LDRB     R0,[R0, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_MESH_BED_LEVELING_10
        MOVS     R1,#+10
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x14
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??gcode_G29_MESH_BED_LEVELING_11
??gcode_G29_MESH_BED_LEVELING_10:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x18
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
??gcode_G29_MESH_BED_LEVELING_11:
          CFI FunCall _Z15mbl_mesh_reportv
        BL       _Z15mbl_mesh_reportv
        B.N      ??gcode_G29_MESH_BED_LEVELING_5
??gcode_G29_MESH_BED_LEVELING_7:
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x1C
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.N      ??gcode_G29_MESH_BED_LEVELING_5
??gcode_G29_MESH_BED_LEVELING_12:
          CFI FunCall _ZN17mesh_bed_leveling5resetEv
        BL       _ZN17mesh_bed_leveling5resetEv
        MOVS     R0,#+0
        LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_1+0x20
        STR      R0,[R1, #+0]
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x24
          CFI FunCall _Z27enqueue_and_echo_commands_PPKc
        BL       _Z27enqueue_and_echo_commands_PPKc
        B.N      ??gcode_G29_MESH_BED_LEVELING_5
??gcode_G29_MESH_BED_LEVELING_13:
        LDR.N    R4,??gcode_G29_MESH_BED_LEVELING_1+0x20
        LDR      R0,[R4, #+0]
        CMP      R0,#+0
        BPL.N    ??gcode_G29_MESH_BED_LEVELING_14
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x28
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        POP      {R0,R1,R4-R6,PC}
??gcode_G29_MESH_BED_LEVELING_14:
        LDR.N    R6,??gcode_G29_MESH_BED_LEVELING_1+0x2C
        LDR.N    R5,??gcode_G29_MESH_BED_LEVELING_1+0x30
        BNE.N    ??gcode_G29_MESH_BED_LEVELING_15
        LDRB     R0,[R5, #+0]
        STRB     R0,[R6, #+0]
        B.N      ??gcode_G29_MESH_BED_LEVELING_16
??gcode_G29_MESH_BED_LEVELING_15:
        LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_1+0x34
        SUBS     R0,R0,#+1
        SXTB     R0,R0
          CFI FunCall _ZN17mesh_bed_leveling12set_zigzag_zEaRKf
        BL       _ZN17mesh_bed_leveling12set_zigzag_zEaRKf
        LDRB     R0,[R6, #+0]
        STRB     R0,[R5, #+0]
??gcode_G29_MESH_BED_LEVELING_16:
        LDR      R0,[R4, #+0]
        LDR.N    R2,??gcode_G29_MESH_BED_LEVELING_1+0x38
        ADD      R6,R2,#+96
        LDRB     R3,[R6, #+0]
        LDRB     R1,[R6, #+1]
        MULS     R3,R1,R3
        CMP      R0,R3
        BGE.N    ??gcode_G29_MESH_BED_LEVELING_17
        MOV      R2,SP
        ADD      R1,SP,#+1
        SXTB     R0,R0
          CFI FunCall _ZN17mesh_bed_leveling6zigzagEaRaS0_
        BL       _ZN17mesh_bed_leveling6zigzagEaRaS0_
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x3C
        LDRSB    R1,[SP, #+0]
        ADD      R1,R0,R1, LSL #+2
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x40
        LDRSB    R2,[SP, #+1]
        ADD      R0,R0,R2, LSL #+2
          CFI FunCall _Z15_manual_goto_xyRKfS0_
        BL       _Z15_manual_goto_xyRKfS0_
        MOVS     R0,#+0
        STRB     R0,[R5, #+0]
        LDR      R0,[R4, #+0]
        ADDS     R0,R0,#+1
        STR      R0,[R4, #+0]
        B.N      ??gcode_G29_MESH_BED_LEVELING_5
??gcode_G29_MESH_BED_LEVELING_17:
        LDR.N    R5,??gcode_G29_MESH_BED_LEVELING_1+0x10
        LDR      R1,[R2, #+16]
        LDR      R0,[R5, #+76]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR      R1,[R6, #+8]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+16]
          CFI FunCall _Z24line_to_current_positionv
        BL       _Z24line_to_current_positionv
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        MOV      R0,#-1
        STR      R0,[R4, #+0]
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x44
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R0,#+100
        STRH     R0,[SP, #+4]
        MOVW     R0,#+659
        STRH     R0,[SP, #+2]
        ADD      R4,R5,#+920
        ADD      R2,SP,#+2
        ADD      R1,SP,#+4
        MOV      R0,R4
          CFI FunCall _ZN6Buzzer4toneERKtS1_
        BL       _ZN6Buzzer4toneERKtS1_
        MOVS     R0,#+100
        STRH     R0,[SP, #+4]
        MOVW     R0,#+698
        STRH     R0,[SP, #+2]
        ADD      R2,SP,#+2
        ADD      R1,SP,#+4
        MOV      R0,R4
          CFI FunCall _ZN6Buzzer4toneERKtS1_
        BL       _ZN6Buzzer4toneERKtS1_
          CFI FunCall _Z17mesh_probing_donev
        BL       _Z17mesh_probing_donev
        B.N      ??gcode_G29_MESH_BED_LEVELING_5
??gcode_G29_MESH_BED_LEVELING_18:
        MOVS     R0,#+88
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_MESH_BED_LEVELING_19
          CFI FunCall _Z14code_value_intv
        BL       _Z14code_value_intv
        SUBS     R0,R0,#+1
        STRB     R0,[SP, #+1]
        LDRSB    R0,[SP, #+1]
        CMP      R0,#+0
        BMI.N    ??gcode_G29_MESH_BED_LEVELING_20
        LDR.N    R4,??gcode_G29_MESH_BED_LEVELING_1+0x48
        LDRB     R1,[R4, #+0]
        SUBS     R1,R1,#+1
        CMP      R1,R0
        BGE.N    ??gcode_G29_MESH_BED_LEVELING_21
??gcode_G29_MESH_BED_LEVELING_20:
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x4C
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        POP      {R0,R1,R4-R6,PC}
??gcode_G29_MESH_BED_LEVELING_21:
        MOVS     R0,#+89
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BNE.N    ??gcode_G29_MESH_BED_LEVELING_22
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x10
        LDRB     R0,[R0, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_MESH_BED_LEVELING_23
        MOVS     R1,#+89
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x14
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??gcode_G29_MESH_BED_LEVELING_24
??gcode_G29_MESH_BED_LEVELING_19:
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x10
        LDRB     R0,[R0, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_MESH_BED_LEVELING_25
        MOVS     R1,#+88
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x14
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??gcode_G29_MESH_BED_LEVELING_24
??gcode_G29_MESH_BED_LEVELING_25:
        MOVS     R2,#+0
        MOVS     R1,#+88
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x18
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
        B.N      ??gcode_G29_MESH_BED_LEVELING_24
??gcode_G29_MESH_BED_LEVELING_22:
          CFI FunCall _Z14code_value_intv
        BL       _Z14code_value_intv
        SUBS     R0,R0,#+1
        STRB     R0,[SP, #+0]
        LDRSB    R0,[SP, #+0]
        CMP      R0,#+0
        BMI.N    ??gcode_G29_MESH_BED_LEVELING_26
        LDRB     R1,[R4, #+1]
        SUBS     R1,R1,#+1
        CMP      R1,R0
        BGE.N    ??gcode_G29_MESH_BED_LEVELING_27
??gcode_G29_MESH_BED_LEVELING_26:
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x50
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        POP      {R0,R1,R4-R6,PC}
??gcode_G29_MESH_BED_LEVELING_27:
        MOVS     R0,#+90
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BNE.N    ??gcode_G29_MESH_BED_LEVELING_28
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x10
        LDRB     R0,[R0, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_MESH_BED_LEVELING_29
        MOVS     R1,#+90
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x14
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??gcode_G29_MESH_BED_LEVELING_24
??gcode_G29_MESH_BED_LEVELING_23:
        MOVS     R2,#+0
        MOVS     R1,#+89
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x18
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
        B.N      ??gcode_G29_MESH_BED_LEVELING_24
??gcode_G29_MESH_BED_LEVELING_28:
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_1+0x54
        LDRSB    R2,[SP, #+1]
        ADD      R1,R1,R2, LSL #+6
        LDRSB    R2,[SP, #+0]
        STR      R0,[R1, R2, LSL #+2]
        B.N      ??gcode_G29_MESH_BED_LEVELING_5
??gcode_G29_MESH_BED_LEVELING_29:
        MOVS     R2,#+0
        MOVS     R1,#+90
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x18
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
        B.N      ??gcode_G29_MESH_BED_LEVELING_24
??gcode_G29_MESH_BED_LEVELING_30:
        MOVS     R0,#+90
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_MESH_BED_LEVELING_31
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_1+0x58
        STR      R0,[R1, #+0]
        B.N      ??gcode_G29_MESH_BED_LEVELING_5
??gcode_G29_MESH_BED_LEVELING_31:
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x10
        LDRB     R0,[R0, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_MESH_BED_LEVELING_32
        MOVS     R1,#+90
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x14
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??gcode_G29_MESH_BED_LEVELING_24
??gcode_G29_MESH_BED_LEVELING_32:
        MOVS     R2,#+0
        MOVS     R1,#+90
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x18
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
??gcode_G29_MESH_BED_LEVELING_24:
          CFI FunCall _Z15say_not_enteredv
        BL       _Z15say_not_enteredv
        POP      {R0,R1,R4-R6,PC}
??gcode_G29_MESH_BED_LEVELING_33:
          CFI FunCall _Z15reset_bed_levelv
        BL       _Z15reset_bed_levelv
??gcode_G29_MESH_BED_LEVELING_5:
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531923report_current_positionEv
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531923report_current_positionEv
        POP      {R0,R1,R4-R6,PC}  ;; return
        Nop      
        DATA
??gcode_G29_MESH_BED_LEVELING_1:
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs
        DC32     MSG_ON
        DC32     MSG_OFF
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_0
        DC32     mks_heating_busy
        DC32     customizedSerial
        DC32     serial2
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_1
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvE15mbl_probe_index
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_2
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_3
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvE20enable_soft_endstops
        DC32     soft_endstops_enabled
        DC32     mks_heating_busy+0x10
        DC32     mksCfg
        DC32     _ZN17mesh_bed_leveling13index_to_yposE
        DC32     _ZN17mesh_bed_leveling13index_to_xposE
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_4
        DC32     mksCfg+0x60
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_5
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_6
        DC32     _ZN17mesh_bed_leveling8z_valuesE
        DC32     _ZN17mesh_bed_leveling8z_offsetE
          CFI EndBlock cfiBlock236

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_G29v
          CFI Block cfiBlock237 Using cfiCommon0
          CFI Function _Z9gcode_G29v
        THUMB
_Z9gcode_G29v:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        SUB      SP,SP,#+1208
          CFI CFA R13+1248
        MOVS     R2,#+1
        MOV      R1,R2
        MOV      R0,R1
          CFI FunCall _Z18axis_unhomed_errorbbb
        BL       _Z18axis_unhomed_errorbbb
        CMP      R0,#+0
        BNE.W    ??gcode_G29_3
        MOVS     R0,#+0
        STR      R0,[SP, #+48]
        STR      R0,[SP, #+68]
        STR      R0,[SP, #+64]
        STR      R0,[SP, #+60]
        STR      R0,[SP, #+88]
        STR      R0,[SP, #+8]
        STR      R0,[SP, #+4]
        STR      R0,[SP, #+24]
        STR      R0,[SP, #+20]
        LDR.W    R6,??gcode_G29_0
        ADD      R0,R6,#+96
        STR      R0,[SP, #+36]
        LDRB     R0,[R0, #+0]
        MOV      R1,R0
        STR      R1,[SP, #+44]
        LDR      R1,[SP, #+36]
        LDRB     R1,[R1, #+1]
        MOV      R2,R1
        STR      R2,[SP, #+16]
        MOVS     R2,#+0
        STRB     R2,[SP, #+12]
        MULS     R0,R1,R0
        ADD      R1,R6,#+64
        STR      R1,[SP, #+52]
        LDRB     R1,[R1, #+0]
        TST      R1,#0x6
        BNE.N    ??gcode_G29_4
        STR      R0,[SP, #+40]
??gcode_G29_4:
        ADD      R4,R6,#+96
        ADD      R0,R0,R0, LSL #+1
        ADDS     R0,R0,#+1
        LSLS     R0,R0,#+2
          CFI FunCall malloc
        BL       malloc
        MOVS     R5,R0
        BNE.N    ??gcode_G29_5
        MOVS     R0,#+0
        LDR.W    R1,??gcode_G29_0+0x4
        STRB     R0,[R1, #+0]
        LDR.W    R0,??gcode_G29_0+0x8
          CFI FunCall _Z4killPKc
        BL       _Z4killPKc
??gcode_G29_5:
        MOVS     R1,#+0
        B.N      ??gcode_G29_6
??gcode_G29_7:
        MOVS     R0,#+0
        STR      R0,[R5, R1, LSL #+2]
        ADDS     R1,R1,#+1
??gcode_G29_6:
        LDRB     R0,[R4, #+0]
        LDRB     R2,[R4, #+1]
        MULS     R0,R2,R0
        ADD      R2,R0,R0, LSL #+1
        ADDS     R2,R2,#+1
        CMP      R1,R2
        BLT.N    ??gcode_G29_7
        ADD      R7,R6,#+96
        ADDS     R0,R0,#+1
        LSLS     R0,R0,#+2
          CFI FunCall malloc
        BL       malloc
        MOVS     R4,R0
        BNE.N    ??gcode_G29_8
        MOVS     R0,#+0
        LDR.W    R1,??gcode_G29_0+0x4
        STRB     R0,[R1, #+0]
        LDR.W    R0,??gcode_G29_0+0xC
          CFI FunCall _Z4killPKc
        BL       _Z4killPKc
??gcode_G29_8:
        MOVS     R0,#+0
        MOV      R8,R4
        B.N      ??gcode_G29_9
??gcode_G29_10:
        MOVS     R1,#+0
        STR      R1,[R8, R0, LSL #+2]
        ADDS     R0,R0,#+1
??gcode_G29_9:
        LDRB     R1,[R7, #+0]
        LDRB     R2,[R7, #+1]
        MULS     R1,R2,R1
        ADDS     R1,R1,#+1
        CMP      R0,R1
        BLT.N    ??gcode_G29_10
        ADD      R0,R6,#+96
        STR      R0,[SP, #+36]
        MOVS     R3,#+0
        LDR      R2,[R0, #+64]
        LDR      R1,[R0, #+60]
        ADD      R0,SP,#+100
          CFI FunCall _ZN8vector_3C1Efff
        BL       _ZN8vector_3C1Efff
        MOVS     R3,#+0
        LDR      R0,[SP, #+36]
        LDR      R2,[R0, #+72]
        LDR      R1,[R0, #+68]
        ADD      R0,SP,#+112
          CFI FunCall _ZN8vector_3C1Efff
        BL       _ZN8vector_3C1Efff
        MOVS     R3,#+0
        LDR      R0,[SP, #+36]
        LDR      R2,[R0, #+80]
        LDR      R1,[R0, #+76]
        ADD      R0,SP,#+124
          CFI FunCall _ZN8vector_3C1Efff
        BL       _ZN8vector_3C1Efff
        LDR.W    R0,??gcode_G29_0+0x10
        LDRB     R0,[R0, #+0]
        STRB     R0,[SP, #+32]
        LDR      R0,[SP, #+52]
        LDRB     R0,[R0, #+0]
        CMP      R0,#+8
        BNE.W    ??gcode_G29_11
        MOVS     R0,#+87
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.W    ??gcode_G29_11
        LDR.W    R4,??gcode_G29_0+0x4
        LDR      R0,[R4, #+8]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_12
        LDR.W    R0,??gcode_G29_0+0x14
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R0,??gcode_G29_0+0x18
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.W      ??gcode_G29_3
??gcode_G29_12:
        MOVS     R0,#+90
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_13
          CFI FunCall _Z14code_has_valuev
        BL       _Z14code_has_valuev
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_13
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        MOV      R5,R0
        B.N      ??gcode_G29_14
??gcode_G29_13:
        LDR.W    R5,??gcode_G29_0+0x1C  ;; 0x47c34f80
??gcode_G29_14:
        MOV      R0,R5
        LDR.W    R1,??gcode_G29_0+0x20  ;; 0xc1200000
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_G29_15
        LDR.W    R1,??gcode_G29_0+0x24  ;; 0x41200001
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_G29_16
??gcode_G29_15:
        LDR.W    R0,??gcode_G29_0+0x14
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R0,??gcode_G29_0+0x28
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.W      ??gcode_G29_3
??gcode_G29_16:
        MOVS     R0,#+88
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_17
          CFI FunCall _Z14code_has_valuev
        BL       _Z14code_has_valuev
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_17
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        MOV      R9,R0
        B.N      ??gcode_G29_18
??gcode_G29_17:
        LDR.W    R9,??gcode_G29_0+0x1C  ;; 0x47c34f80
??gcode_G29_18:
        MOVS     R0,#+89
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_19
          CFI FunCall _Z14code_has_valuev
        BL       _Z14code_has_valuev
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_19
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        MOV      R6,R0
        B.N      ??gcode_G29_20
??gcode_G29_19:
        LDR.W    R6,??gcode_G29_0+0x1C  ;; 0x47c34f80
??gcode_G29_20:
        MOVS     R0,#+73
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_21
          CFI FunCall _Z14code_has_valuev
        BL       _Z14code_has_valuev
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_21
          CFI FunCall _Z15code_value_bytev
        BL       _Z15code_value_bytev
        MOV      R7,R0
        B.N      ??gcode_G29_22
??gcode_G29_21:
        MOV      R7,#-1
??gcode_G29_22:
        MOVS     R0,#+74
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_23
          CFI FunCall _Z14code_has_valuev
        BL       _Z14code_has_valuev
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_23
          CFI FunCall _Z15code_value_bytev
        BL       _Z15code_value_bytev
        MOV      R2,R0
        B.N      ??gcode_G29_24
??gcode_G29_23:
        MOV      R2,#-1
??gcode_G29_24:
        LDR.W    R1,??gcode_G29_1  ;; 0x47c34f00
        MOV      R0,R9
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_G29_25
        MOV      R0,R6
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_G29_25
        LDR.W    R8,??gcode_G29_1+0x4
        LDR      R0,[R4, #+16]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R8, #+68]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        MOV      R3,R2
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOVS     R2,#+0
        MOV      R3,R2
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
        MOV      R7,R0
        LDR      R0,[R4, #+20]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R8, #+72]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R6
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        MOV      R3,R2
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOVS     R2,#+0
        MOV      R3,R2
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
        MOV      R2,R0
        MOV      R0,R7
        SXTB     R0,R0
        CMP      R0,#+0
        BPL.N    ??gcode_G29_26
        MOVS     R7,#+0
        B.N      ??gcode_G29_27
??gcode_G29_26:
        LDR      R1,[SP, #+36]
        LDRB     R1,[R1, #+0]
        MOV      R3,R1
        SUBS     R3,R3,#+1
        CMP      R3,R0
        BGE.N    ??gcode_G29_27
        SUBS     R7,R1,#+1
??gcode_G29_27:
        MOV      R0,R2
        SXTB     R0,R0
        CMP      R0,#+0
        BPL.N    ??gcode_G29_28
        MOVS     R2,#+0
        B.N      ??gcode_G29_25
??gcode_G29_28:
        LDR      R1,[SP, #+36]
        LDRB     R1,[R1, #+1]
        MOV      R3,R1
        SUBS     R3,R3,#+1
        CMP      R3,R0
        BGE.N    ??gcode_G29_25
        SUBS     R2,R1,#+1
??gcode_G29_25:
        SXTB     R7,R7
        CMP      R7,#+0
        BMI.W    ??gcode_G29_3
        LDR      R0,[SP, #+36]
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
        CMP      R0,R7
        BLT.W    ??gcode_G29_3
        MOV      R4,R2
        SXTB     R4,R4
        CMP      R4,#+0
        BMI.W    ??gcode_G29_3
        LDR      R0,[SP, #+36]
        LDRB     R0,[R0, #+1]
        SXTB     R2,R2
        CMP      R0,R2
        BLT.W    ??gcode_G29_3
        MOVS     R0,#+0
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
        LDR.W    R0,??gcode_G29_2
        ADD      R0,R0,R7, LSL #+6
        STR      R5,[R0, R4, LSL #+2]
        LDRB     R0,[SP, #+32]
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
        B.W      ??gcode_G29_3
??gcode_G29_11:
        LDR      R0,[SP, #+52]
        LDRB     R0,[R0, #+0]
        TST      R0,#0x3E
        BEQ.N    ??gcode_G29_29
        MOVS     R0,#+74
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_29
          CFI FunCall _Z15reset_bed_levelv
        BL       _Z15reset_bed_levelv
        B.W      ??gcode_G29_3
??gcode_G29_29:
        MOVS     R0,#+86
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_30
          CFI FunCall _Z14code_has_valuev
        BL       _Z14code_has_valuev
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_30
          CFI FunCall _Z14code_value_intv
        BL       _Z14code_value_intv
        STR      R0,[SP, #+48]
??gcode_G29_30:
        LDR      R0,[SP, #+48]
        CMP      R0,#+5
        BCC.N    ??gcode_G29_31
        LDR.W    R0,??gcode_G29_2+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.W      ??gcode_G29_3
??gcode_G29_31:
        MOVS     R0,#+68
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_32
          CFI FunCall _Z15code_value_boolv
        BL       _Z15code_value_boolv
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
        STR      R0,[SP, #+56]
        B.N      ??gcode_G29_33
??gcode_G29_32:
        MOVS     R0,#+0
        STR      R0,[SP, #+56]
??gcode_G29_33:
        LDR      R0,[SP, #+52]
        LDRB     R0,[R0, #+0]
        LSLS     R1,R0,#+29
        BPL.N    ??gcode_G29_34
        LDR      R0,[SP, #+48]
        CMP      R0,#+3
        BGE.N    ??gcode_G29_35
        MOVS     R0,#+84
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_36
??gcode_G29_35:
        MOVS     R0,#+1
        STRB     R0,[SP, #+12]
??gcode_G29_36:
        MOVS     R0,#+88
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_37
          CFI FunCall _Z14code_value_intv
        BL       _Z14code_value_intv
        UXTB     R0,R0
        STR      R0,[SP, #+44]
        B.N      ??gcode_G29_38
??gcode_G29_37:
        LDR      R0,[SP, #+36]
        LDRB     R0,[R0, #+0]
        STR      R0,[SP, #+44]
??gcode_G29_38:
        MOVS     R0,#+89
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_39
          CFI FunCall _Z14code_value_intv
        BL       _Z14code_value_intv
        UXTB     R0,R0
        STR      R0,[SP, #+16]
        B.N      ??gcode_G29_40
??gcode_G29_39:
        LDR      R0,[SP, #+36]
        LDRB     R0,[R0, #+1]
        STR      R0,[SP, #+16]
??gcode_G29_40:
        MOVS     R0,#+80
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_41
          CFI FunCall _Z14code_value_intv
        BL       _Z14code_value_intv
        UXTB     R0,R0
        STR      R0,[SP, #+16]
        ADD      R0,SP,#+16
        LDRB     R0,[R0, #+0]
        STR      R0,[SP, #+44]
??gcode_G29_41:
        LDR      R0,[SP, #+44]
        CMP      R0,#+1
        BLE.N    ??gcode_G29_42
        LDR      R0,[SP, #+16]
        CMP      R0,#+1
        BGT.N    ??gcode_G29_43
??gcode_G29_42:
        LDR.W    R0,??gcode_G29_2+0x8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.W      ??gcode_G29_3
??gcode_G29_43:
        LDR      R1,[SP, #+44]
        MULS     R1,R0,R1
        STR      R1,[SP, #+40]
        B.N      ??gcode_G29_44
??gcode_G29_34:
        LSLS     R0,R0,#+28
        BPL.N    ??gcode_G29_44
        MOVS     R0,#+90
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_45
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        STR      R0,[SP, #+28]
        B.N      ??gcode_G29_44
??gcode_G29_45:
        MOVS     R0,#+0
        STR      R0,[SP, #+28]
??gcode_G29_44:
        LDR      R0,[SP, #+52]
        LDRB     R0,[R0, #+0]
        TST      R0,#0xC
        BEQ.W    ??gcode_G29_46
        MOVS     R0,#+83
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_47
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        B.N      ??gcode_G29_48
??gcode_G29_47:
        LDR      R0,[SP, #+36]
        LDR      R0,[R0, #+20]
??gcode_G29_48:
        LDR.W    R6,??gcode_G29_1+0x4
        LDR.W    R1,??gcode_G29_2+0xC  ;; 0x42700000
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[R6, #+124]
        MOVS     R0,#+76
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_49
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        STR      R0,[SP, #+8]
        B.N      ??gcode_G29_50
??gcode_G29_49:
        LDR      R0,[SP, #+36]
        LDR      R0,[R0, #+40]
        LDR      R1,[R6, #+68]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        STR      R0,[SP, #+8]
??gcode_G29_50:
        MOVS     R0,#+82
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_51
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R4,R0
        B.N      ??gcode_G29_52
??gcode_G29_51:
        LDR      R0,[SP, #+36]
        LDR      R0,[R0, #+44]
        LDR      R1,[R6, #+68]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R4,R0
??gcode_G29_52:
        MOVS     R0,#+70
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_53
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        STR      R0,[SP, #+4]
        B.N      ??gcode_G29_54
??gcode_G29_53:
        LDR      R0,[SP, #+36]
        LDR      R0,[R0, #+48]
        LDR      R1,[R6, #+72]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        STR      R0,[SP, #+4]
??gcode_G29_54:
        MOVS     R0,#+66
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_55
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R6,R0
        B.N      ??gcode_G29_56
??gcode_G29_55:
        LDR      R0,[SP, #+36]
        LDR      R0,[R0, #+52]
        LDR      R1,[R6, #+72]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R6,R0
??gcode_G29_56:
        LDR.W    R0,??gcode_G29_1+0x4
        LDR      R10,[R0, #+68]
        LDR.W    R7,??gcode_G29_2+0x10
        LDR      R1,[R7, #+0]
        MOV      R0,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R9,R1
        LDR      R0,[SP, #+8]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R9
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_G29_57
        SUB      R0,R4,#+10
        LDR      R1,[SP, #+8]
        CMP      R0,R1
        BGE.N    ??gcode_G29_58
??gcode_G29_57:
        MOV      R9,#+1
        B.N      ??gcode_G29_59
??gcode_G29_58:
        MOV      R9,#+0
??gcode_G29_59:
        MOV      R0,R4
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R11,R1
        LDR      R1,[R7, #+4]
        MOV      R0,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R11
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_G29_60
        LDR      R0,[SP, #+8]
        ADDS     R0,R0,#+10
        CMP      R4,R0
        BGE.N    ??gcode_G29_61
??gcode_G29_60:
        MOV      R10,#+1
        B.N      ??gcode_G29_62
??gcode_G29_61:
        MOV      R10,#+0
??gcode_G29_62:
        LDR      R0,[R7, #+8]
        LDR.W    R1,??gcode_G29_1+0x4
        LDR      R1,[R1, #+72]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R11,R1
        LDR      R0,[SP, #+4]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R11
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_G29_63
        SUB      R0,R6,#+10
        LDR      R1,[SP, #+4]
        CMP      R0,R1
        BGE.N    ??gcode_G29_64
??gcode_G29_63:
        MOV      R11,#+1
        B.N      ??gcode_G29_65
??gcode_G29_64:
        MOV      R11,#+0
??gcode_G29_65:
        MOV      R0,R6
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        STR      R1,[SP, #+0]
        LDR      R0,[R7, #+12]
        LDR.W    R1,??gcode_G29_1+0x4
        LDR      R1,[R1, #+72]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR      R1,[SP, #+0]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_G29_66
        LDR      R0,[SP, #+4]
        ADDS     R0,R0,#+10
        CMP      R6,R0
        BGE.N    ??gcode_G29_67
??gcode_G29_66:
        MOVS     R7,#+1
        B.N      ??gcode_G29_68
??gcode_G29_67:
        MOVS     R7,#+0
??gcode_G29_68:
        ORR      R0,R10,R9
        ORR      R0,R11,R0
        ORRS     R0,R7,R0
        BEQ.N    ??gcode_G29_69
        CMP      R9,#+0
        BEQ.N    ??gcode_G29_70
        LDR.W    R0,??gcode_G29_2+0x14
          CFI FunCall _Z18out_of_range_errorPKc
        BL       _Z18out_of_range_errorPKc
??gcode_G29_70:
        CMP      R10,#+0
        BEQ.N    ??gcode_G29_71
        LDR.W    R0,??gcode_G29_2+0x18
          CFI FunCall _Z18out_of_range_errorPKc
        BL       _Z18out_of_range_errorPKc
??gcode_G29_71:
        CMP      R11,#+0
        BEQ.N    ??gcode_G29_72
        LDR.W    R0,??gcode_G29_2+0x1C
          CFI FunCall _Z18out_of_range_errorPKc
        BL       _Z18out_of_range_errorPKc
??gcode_G29_72:
        CMP      R7,#+0
        BEQ.W    ??gcode_G29_3
        LDR.W    R0,??gcode_G29_2+0x20
          CFI FunCall _Z18out_of_range_errorPKc
        BL       _Z18out_of_range_errorPKc
        B.W      ??gcode_G29_3
??gcode_G29_69:
        LDR      R0,[SP, #+8]
        SUBS     R4,R4,R0
        LDR      R0,[SP, #+44]
        SUBS     R0,R0,#+1
        SDIV     R0,R4,R0
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        STR      R0,[SP, #+24]
        LDR      R0,[SP, #+4]
        SUBS     R6,R6,R0
        LDR      R0,[SP, #+16]
        SUBS     R0,R0,#+1
        SDIV     R0,R6,R0
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        STR      R0,[SP, #+20]
??gcode_G29_46:
        LDR      R0,[SP, #+48]
        CMP      R0,#+0
        BLE.N    ??gcode_G29_73
        LDR.W    R0,??gcode_G29_2+0x24
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR      R0,[SP, #+56]
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_73
        LDR.W    R0,??gcode_G29_2+0x28
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_G29_73:
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        MOVS     R0,#+0
        LDR.W    R1,??gcode_G29_0+0x10
        STRB     R0,[R1, #+0]
        LDR      R0,[SP, #+56]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_74
        MOVS     R0,#+100
          CFI FunCall _Z34set_current_from_steppers_for_axis8AxisEnum
        BL       _Z34set_current_from_steppers_for_axis8AxisEnum
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
??gcode_G29_74:
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531931setup_for_endstop_or_probe_moveEv
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531931setup_for_endstop_or_probe_moveEv
        MOVS     R0,#+1
          CFI FunCall _Z18set_probe_deployedb
        BL       _Z18set_probe_deployedb
        CMP      R0,#+0
        BNE.W    ??gcode_G29_75
        LDR      R0,[SP, #+52]
        LDRB     R0,[R0, #+0]
        CMP      R0,#+8
        BNE.N    ??gcode_G29_76
        LDR.W    R4,??gcode_G29_0+0x4
        LDR      R0,[R4, #+8]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        LDR      R0,[SP, #+24]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??gcode_G29_77
        LDR      R0,[R4, #+12]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        LDR      R0,[SP, #+20]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??gcode_G29_77
        LDR.W    R6,??gcode_G29_1+0x4
        LDR      R0,[SP, #+8]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R7,R0
        LDR      R0,[R4, #+16]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R6, #+68]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??gcode_G29_77
        LDR      R0,[SP, #+4]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R7,R0
        LDR      R0,[R4, #+20]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R6, #+72]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??gcode_G29_78
??gcode_G29_77:
        LDR      R0,[SP, #+56]
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_79
        LDRB     R0,[SP, #+32]
        LDR.W    R1,??gcode_G29_0+0x10
        STRB     R0,[R1, #+0]
??gcode_G29_79:
          CFI FunCall _Z15reset_bed_levelv
        BL       _Z15reset_bed_levelv
        LDR      R0,[SP, #+24]
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        STR      R0,[R4, #+8]
        LDR      R0,[SP, #+20]
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        STR      R0,[R4, #+12]
        LDR.W    R6,??gcode_G29_1+0x4
        LDR      R0,[SP, #+8]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R6, #+68]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        STR      R0,[R4, #+16]
        LDR      R0,[SP, #+4]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R6, #+72]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        STR      R0,[R4, #+20]
        MOVS     R0,#+0
        STRB     R0,[SP, #+32]
        B.N      ??gcode_G29_78
??gcode_G29_76:
        CMP      R0,#+4
        BNE.N    ??gcode_G29_78
        MOVS     R0,#+0
        STR      R0,[SP, #+76]
??gcode_G29_78:
        LDR      R0,[SP, #+52]
        LDRB     R0,[R0, #+0]
        CMP      R0,#+2
        BNE.N    ??gcode_G29_80
        ADD      R0,SP,#+100
        MOVS     R1,#+0
        STR      R1,[R0, #+32]
        STR      R1,[R0, #+20]
        STR      R1,[R0, #+8]
??gcode_G29_80:
        MOVS     R0,#+69
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        MOV      R1,R0
        LDR      R0,[SP, #+52]
        LDRB     R0,[R0, #+0]
        TST      R0,#0xC
        BEQ.W    ??gcode_G29_81
        LDR      R0,[SP, #+16]
        AND      R0,R0,#0x1
        STRB     R0,[SP, #+1]
        MOVS     R2,#+0
        B.N      ??gcode_G29_82
??gcode_G29_83:
        STR      R11,[SP, #+68]
        STR      R6,[SP, #+64]
        STR      R10,[SP, #+60]
        STR      R9,[SP, #+88]
        STR      R4,[SP, #+76]
        LDR      R5,[SP, #+80]
        LDR      R8,[SP, #+84]
        LDRB     R1,[SP, #+0]
        LDR      R2,[SP, #+72]
        ADDS     R2,R2,#+1
        UXTB     R2,R2
??gcode_G29_82:
        LDR      R0,[SP, #+16]
        CMP      R2,R0
        BGE.W    ??gcode_G29_84
        LDRB     R0,[SP, #+1]
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_85
        MOVS     R0,#+0
        ADD      R3,SP,#+44
        LDRSB    R3,[R3, #+0]
        MOVS     R7,#+1
        B.N      ??gcode_G29_86
??gcode_G29_85:
        LDR      R0,[SP, #+44]
        SUBS     R0,R0,#+1
        MOV      R3,#-1
        MOV      R7,R3
??gcode_G29_86:
        LDRB     R4,[SP, #+1]
        EOR      R4,R4,#0x1
        SUBS     R4,R4,#+1
        SBCS     R4,R4,R4
        MVNS     R4,R4
        LSRS     R4,R4,#+31
        STRB     R4,[SP, #+1]
        SXTB     R0,R0
        LDR      R11,[SP, #+68]
        LDR      R6,[SP, #+64]
        LDR      R10,[SP, #+60]
        LDR      R9,[SP, #+88]
        LDR      R4,[SP, #+76]
        STR      R5,[SP, #+80]
        STR      R8,[SP, #+84]
        STRB     R1,[SP, #+0]
        STR      R2,[SP, #+72]
        STR      R3,[SP, #+68]
        STR      R7,[SP, #+64]
        MOV      R5,R0
        B.N      ??gcode_G29_87
??gcode_G29_88:
        CMP      R0,#+8
        BNE.N    ??gcode_G29_89
        LDR.W    R0,??gcode_G29_2
        ADDS     R7,R0,R5, LSL #+6
        LDR      R8,[SP, #+72]
        LDR      R1,[SP, #+28]
        MOV      R0,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R7, R8, LSL #+2]
        B.N      ??gcode_G29_89
??gcode_G29_90:
        LDR.W    R7,??gcode_G29_2+0x2C  ;; 0x3fe00000
??gcode_G29_91:
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R6
        MOV      R1,R7
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall floor
        BL       floor
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R6,R0
        LDR      R0,[SP, #+52]
        LDRB     R0,[R0, #+0]
        CMP      R0,#+4
        BNE.N    ??gcode_G29_92
        ADD      R9,R9,#+1
        ADD      R0,SP,#+184
        ADD      R0,R0,R5, LSL #+6
        LDR      R1,[SP, #+72]
        STR      R9,[R0, R1, LSL #+2]
??gcode_G29_92:
        ADD      R0,SP,#+88
        MOVS     R1,#+0
        MOV      R2,R1
        MOV      R3,R1
        STM      R0,{R1-R3}
        STR      R11,[SP, #+88]
        STR      R6,[SP, #+92]
        LDR      R0,[SP, #+52]
        LDRH     R0,[R0, #+24]
        MOVW     R1,#+770
        TST      R0,R1
        BEQ.N    ??gcode_G29_93
        MOVS     R1,#+1
        ADD      R0,SP,#+88
          CFI FunCall _Z21position_is_reachablePKfb
        BL       _Z21position_is_reachablePKfb
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_94
??gcode_G29_93:
          CFI FunCall rand
        BL       rand
        LDR      R3,[SP, #+48]
        LDRB     R2,[SP, #+0]
        MOV      R1,R6
        MOV      R0,R11
          CFI FunCall _Z8probe_ptffbi
        BL       _Z8probe_ptffbi
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R10,R0
          CFI FunCall _Z5isnanf
        BL       _Z5isnanf
        CMP      R0,#+0
        BNE.W    ??gcode_G29_75
        LDR      R0,[SP, #+52]
        LDRB     R0,[R0, #+0]
        CMP      R0,#+4
        BNE.N    ??gcode_G29_88
        MOV      R0,R4
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R4,R0
        LDR      R0,[SP, #+84]
        STR      R10,[R0, R9, LSL #+2]
        LDR      R0,[SP, #+80]
        STR      R11,[R0, R9, LSL #+2]
        LDR      R0,[SP, #+80]
        ADD      R0,R0,R9, LSL #+2
        LDR      R1,[SP, #+40]
        STR      R6,[R0, R1, LSL #+2]
        MOV      R1,#+1065353216
        LDR      R2,[SP, #+40]
        STR      R1,[R0, R2, LSL #+3]
??gcode_G29_89:
        MOVS     R0,#+0
        STRB     R0,[SP, #+32]
          CFI FunCall _Z4idleb
        BL       _Z4idleb
??gcode_G29_94:
        LDR      R0,[SP, #+64]
        ADDS     R5,R0,R5
        SXTB     R5,R5
??gcode_G29_87:
        LDR      R0,[SP, #+68]
        CMP      R5,R0
        BEQ.W    ??gcode_G29_83
        LDR      R0,[SP, #+8]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R6,R0
        MOV      R0,R5
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        LDR      R0,[SP, #+24]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R6
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R8,R0
        LDR      R0,[SP, #+4]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R6,R0
        ADD      R0,SP,#+72
        LDRB     R0,[R0, #+0]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R1,R0
        LDR      R0,[SP, #+20]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R6
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[SP, #+60]
        MOV      R0,R8
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        MOV      R6,R1
        BCS.N    ??gcode_G29_95
        MOV      R7,R1
        B.N      ??gcode_G29_96
??gcode_G29_95:
        LDR.W    R7,??gcode_G29_2+0x2C  ;; 0x3fe00000
??gcode_G29_96:
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R6
        MOV      R3,R7
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall floor
        BL       floor
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R11,R0
        LDR      R0,[SP, #+60]
        MOV      R1,R6
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.W    ??gcode_G29_90
        MOV      R7,R1
        B.N      ??gcode_G29_91
??gcode_G29_81:
        LSLS     R0,R0,#+30
        BPL.W    ??gcode_G29_84
        MOVS     R4,#+0
        LDR      R11,[SP, #+48]
        LDR      R6,[SP, #+68]
        LDR      R7,[SP, #+64]
        LDR      R0,[SP, #+60]
        STRB     R1,[SP, #+0]
        ADD      R9,SP,#+108
        B.N      ??gcode_G29_97
??gcode_G29_98:
        ADD      R0,R4,R4, LSL #+1
        LSL      R10,R0,#+2
        LDR.W    R7,??gcode_G29_1+0x4
        ADD      R0,SP,#+100
        LDR      R1,[R0, R10]
        LDR      R0,[R7, #+68]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R6,R0
        ADD      R0,SP,#+104
        LDR      R1,[R0, R10]
        LDR      R0,[R7, #+72]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R7,R0
          CFI FunCall rand
        BL       rand
        MOV      R3,R11
        LDRB     R2,[SP, #+0]
        MOV      R1,R7
        MOV      R0,R6
          CFI FunCall _Z8probe_ptffbi
        BL       _Z8probe_ptffbi
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R9, R10]
        ADDS     R4,R4,#+1
??gcode_G29_97:
        CMP      R4,#+3
        BLT.N    ??gcode_G29_98
        STR      R11,[SP, #+48]
        STR      R6,[SP, #+68]
        STR      R7,[SP, #+64]
        STR      R0,[SP, #+60]
          CFI FunCall _Z5isnanf
        BL       _Z5isnanf
        CMP      R0,#+0
        BNE.N    ??gcode_G29_75
        LDR      R0,[SP, #+56]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_84
        ADD      R4,SP,#+100
        ADD      R0,R4,#+12
        SUB      SP,SP,#+8
          CFI CFA R13+1256
        MOV      R1,SP
        LDM      R0!,{R2,R3}
        STM      R1!,{R2,R3}
        LDR      R2,[R0, #+0]
        STR      R2,[R1, #+0]
        POP      {R2,R3}
          CFI CFA R13+1248
        ADD      R1,SP,#+124
        ADD      R0,SP,#+80
          CFI FunCall _ZN8vector_3miES_
        BL       _ZN8vector_3miES_
        ADD      R0,R4,#+12
        SUB      SP,SP,#+8
          CFI CFA R13+1256
        MOV      R1,SP
        LDM      R0!,{R2,R3}
        STM      R1!,{R2,R3}
        LDR      R2,[R0, #+0]
        STR      R2,[R1, #+0]
        POP      {R2,R3}
          CFI CFA R13+1248
        ADD      R1,SP,#+100
        ADD      R0,SP,#+20
          CFI FunCall _ZN8vector_3miES_
        BL       _ZN8vector_3miES_
        ADD      R0,SP,#+80
        MOV      R2,SP
        LDM      R0!,{R1,R3}
        STM      R2!,{R1,R3}
        LDR      R3,[R0, #+0]
        STR      R3,[R2, #+0]
        ADD      R0,SP,#+20
        LDM      R0,{R1-R3}
          CFI FunCall _ZN8vector_35crossES_S_
        BL       _ZN8vector_35crossES_S_
        ADD      R0,SP,#+136
        ADD      R1,SP,#+20
        LDM      R1,{R2-R4}
        STM      R0,{R2-R4}
        ADD      R1,SP,#+136
        ADD      R0,SP,#+20
          CFI FunCall _ZN8vector_310get_normalEv
        BL       _ZN8vector_310get_normalEv
        MOV      R0,SP
        ADD      R1,SP,#+20
        LDM      R1,{R2-R4}
        STM      R0,{R2-R4}
        MOV      R0,R4
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_G29_99
        LDR.W    R6,??gcode_G29_2+0x30  ;; 0xbf800000
        MOV      R1,R2
        MOV      R0,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[SP, #+0]
        LDR      R1,[SP, #+4]
        MOV      R0,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[SP, #+4]
        MOV      R0,R4
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[SP, #+8]
??gcode_G29_99:
        MOV      R0,SP
        LDM      R0,{R1-R3}
        ADD      R0,SP,#+148
          CFI FunCall _ZN10matrix_3x314create_look_atE8vector_3
        BL       _ZN10matrix_3x314create_look_atE8vector_3
        LDR.W    R0,??gcode_G29_2+0x34
        ADD      R1,SP,#+148
        MOVS     R2,#+36
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        MOVS     R0,#+0
        STRB     R0,[SP, #+32]
??gcode_G29_84:
        MOVS     R0,#+0
          CFI FunCall _Z18set_probe_deployedb
        BL       _Z18set_probe_deployedb
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_100
??gcode_G29_75:
        LDRB     R0,[SP, #+32]
        LDR.N    R1,??gcode_G29_0+0x10
        STRB     R0,[R1, #+0]
        B.N      ??gcode_G29_3
??gcode_G29_100:
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531936clean_up_after_endstop_or_probe_moveEv
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531936clean_up_after_endstop_or_probe_moveEv
        LDR      R0,[SP, #+52]
        LDRB     R0,[R0, #+0]
        CMP      R0,#+8
        BNE.N    ??gcode_G29_101
        LDR      R0,[SP, #+56]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_102
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531930extrapolate_unprobed_bed_levelEv
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531930extrapolate_unprobed_bed_levelEv
??gcode_G29_102:
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531928print_bilinear_leveling_gridEv
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531928print_bilinear_leveling_gridEv
          CFI FunCall _Z17refresh_bed_levelv
        BL       _Z17refresh_bed_levelv
        B.N      ??gcode_G29_103
??gcode_G29_101:
        CMP      R0,#+4
        BNE.W    ??gcode_G29_103
        STR      R8,[SP, #+0]
        MOV      R3,R5
        MOVS     R2,#+3
        LDR      R1,[SP, #+40]
        ADD      R0,SP,#+80
          CFI FunCall _Z8qr_solvePfiiS_S_
        BL       _Z8qr_solvePfiiS_S_
        LDR      R0,[SP, #+40]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        LDR      R0,[SP, #+76]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R11,R0
        ADD      R4,SP,#+80
        LDR      R0,[SP, #+48]
        CMP      R0,#+0
        BEQ.W    ??gcode_G29_104
        LDR.W    R0,??gcode_G29_2+0x38
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR      R0,[SP, #+80]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        LDR.W    R6,??gcode_G29_1+0x4
        LDRB     R0,[R6, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_105
        MOVS     R0,#+8
        STR      R0,[SP, #+0]
        LDR.W    R0,??gcode_G29_2+0x3C
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
        B.N      ??gcode_G29_106
??gcode_G29_105:
        MOVS     R0,#+8
        STR      R0,[SP, #+0]
        LDR.W    R0,??gcode_G29_2+0x40
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
??gcode_G29_106:
        LDR.W    R0,??gcode_G29_2+0x44
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR      R0,[R4, #+4]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        LDRB     R0,[R6, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_107
        MOVS     R0,#+8
        STR      R0,[SP, #+0]
        LDR.W    R0,??gcode_G29_2+0x3C
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
        B.N      ??gcode_G29_108
??gcode_G29_107:
        MOVS     R0,#+8
        STR      R0,[SP, #+0]
        LDR.W    R0,??gcode_G29_2+0x40
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
??gcode_G29_108:
        LDR.W    R0,??gcode_G29_2+0x48
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR      R0,[R4, #+8]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        LDRB     R0,[R6, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_109
        MOVS     R0,#+8
        STR      R0,[SP, #+0]
        LDR.W    R0,??gcode_G29_2+0x3C
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
        B.N      ??gcode_G29_110
??gcode_G29_109:
        MOVS     R0,#+8
        STR      R0,[SP, #+0]
        LDR.W    R0,??gcode_G29_2+0x40
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
??gcode_G29_110:
        LDRB     R0,[R6, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_111
        MOVS     R1,#+10
        LDR.W    R0,??gcode_G29_2+0x3C
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??gcode_G29_112
??gcode_G29_111:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.W    R0,??gcode_G29_2+0x40
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
??gcode_G29_112:
        LDR      R0,[SP, #+48]
        CMP      R0,#+3
        BLT.N    ??gcode_G29_104
        LDR.W    R0,??gcode_G29_2+0x4C
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOV      R0,R11
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        LDRB     R0,[R6, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_113
        MOVS     R0,#+8
        STR      R0,[SP, #+0]
        LDR.W    R0,??gcode_G29_2+0x3C
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
        B.N      ??gcode_G29_114
??gcode_G29_113:
        MOVS     R0,#+8
        STR      R0,[SP, #+0]
        LDR.W    R0,??gcode_G29_2+0x40
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
??gcode_G29_114:
        LDRB     R0,[R6, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_115
        MOVS     R1,#+10
        LDR.W    R0,??gcode_G29_2+0x3C
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??gcode_G29_104
??gcode_G29_115:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.W    R0,??gcode_G29_2+0x40
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
??gcode_G29_104:
        LDR      R0,[SP, #+56]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_116
        MOV      R3,#+1065353216
        LDR      R2,[R4, #+4]
        EOR      R2,R2,#0x80000000
        LDR      R1,[SP, #+80]
        EOR      R1,R1,#0x80000000
        MOV      R0,SP
          CFI FunCall _ZN8vector_3C1Efff
        BL       _ZN8vector_3C1Efff
        MOV      R0,SP
        LDM      R0,{R1-R3}
        ADD      R0,SP,#+136
          CFI FunCall _ZN10matrix_3x314create_look_atE8vector_3
        BL       _ZN10matrix_3x314create_look_atE8vector_3
        LDR.W    R0,??gcode_G29_2+0x34
        ADD      R1,SP,#+136
        MOVS     R2,#+36
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
??gcode_G29_116:
        LDRB     R0,[SP, #+12]
        CMP      R0,#+0
        BEQ.W    ??gcode_G29_103
        LDR.W    R0,??gcode_G29_2+0x50
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R4,??gcode_G29_2+0x54  ;; 0x4479c000
        LDR      R0,[SP, #+16]
        SUBS     R0,R0,#+1
        SXTB     R0,R0
        STR      R0,[SP, #+96]
        LDR      R10,[SP, #+96]
        B.N      ??gcode_G29_117
??gcode_G29_118:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.W    R0,??gcode_G29_2+0x40
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
        B.N      ??gcode_G29_119
??gcode_G29_120:
        MOV      R5,R9
        LDR.N    R0,??gcode_G29_1+0x4
        LDRB     R0,[R0, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_118
        MOVS     R1,#+10
        LDR.W    R0,??gcode_G29_2+0x3C
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
??gcode_G29_119:
        SUB      R10,R10,#+1
        SXTB     R10,R10
??gcode_G29_117:
        CMP      R10,#+0
        BMI.N    ??gcode_G29_121
        MOVS     R0,#+0
        MOV      R9,R5
        MOV      R5,R0
        B.N      ??gcode_G29_122
??gcode_G29_123:
        MOVS     R0,#+5
        STR      R0,[SP, #+0]
        LDR.W    R0,??gcode_G29_2+0x40
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
        B.N      ??gcode_G29_124
??gcode_G29_125:
        MOV      R2,R1
        MOVS     R1,#+32
        LDR.W    R0,??gcode_G29_2+0x40
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
??gcode_G29_126:
        MOV      R0,R6
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        LDR.N    R0,??gcode_G29_1+0x4
        LDRB     R0,[R0, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_123
        MOVS     R0,#+5
        STR      R0,[SP, #+0]
        LDR.W    R0,??gcode_G29_2+0x3C
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
??gcode_G29_124:
        ADDS     R5,R5,#+1
??gcode_G29_122:
        MOV      R0,R5
        UXTB     R0,R0
        LDR      R1,[SP, #+44]
        CMP      R0,R1
        BGE.N    ??gcode_G29_120
        ADD      R1,SP,#+184
        ADD      R0,R1,R0, LSL #+6
        LDR      R7,[R0, R10, LSL #+2]
        LDR      R0,[R8, R7, LSL #+2]
        MOV      R1,R11
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R6,R0
        LDR      R0,[R9, R7, LSL #+2]
        STR      R0,[SP, #+92]
        ADD      R0,R9,R7, LSL #+2
        LDR      R1,[SP, #+40]
        LDR      R0,[R0, R1, LSL #+2]
        STR      R0,[SP, #+76]
        MOVS     R0,#+0
        STR      R0,[SP, #+72]
        ADD      R0,SP,#+72
        STR      R0,[SP, #+28]
        ADD      R0,SP,#+76
        STR      R0,[SP, #+24]
        ADD      R0,SP,#+92
        STR      R0,[SP, #+20]
        LDR.N    R1,??gcode_G29_2+0x34
        SUB      SP,SP,#+16
          CFI CFA R13+1264
        MOV      R0,SP
        MOVS     R2,#+36
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        POP      {R0-R3}
          CFI CFA R13+1248
          CFI FunCall _Z18apply_rotation_xyz10matrix_3x3RfS0_S0_
        BL       _Z18apply_rotation_xyz10matrix_3x3RfS0_S0_
        LDR      R0,[R8, R7, LSL #+2]
        LDR      R1,[SP, #+72]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R4
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_G29_127
        MOV      R4,R0
??gcode_G29_127:
        MOV      R0,R6
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_G29_128
        LDR.N    R0,??gcode_G29_2+0x58
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.N      ??gcode_G29_126
??gcode_G29_128:
        LDR.N    R0,??gcode_G29_1+0x4
        LDRB     R0,[R0, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_125
        MOVS     R1,#+32
        LDR.N    R0,??gcode_G29_2+0x3C
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??gcode_G29_126
??gcode_G29_121:
        LDR.N    R0,??gcode_G29_1+0x4
        LDRB     R0,[R0, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_129
        MOVS     R1,#+10
        LDR.N    R0,??gcode_G29_2+0x3C
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??gcode_G29_130
??gcode_G29_129:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.N    R0,??gcode_G29_2+0x40
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
??gcode_G29_130:
        LDR      R0,[SP, #+48]
        CMP      R0,#+4
        BLT.W    ??gcode_G29_103
        LDR.N    R0,??gcode_G29_2+0x5C
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR      R7,[SP, #+96]
        B.N      ??gcode_G29_131
??gcode_G29_132:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.N    R0,??gcode_G29_2+0x40
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
        B.N      ??gcode_G29_133
??gcode_G29_134:
        MOVS     R2,#+5
        STR      R2,[SP, #+0]
        MOV      R2,R0
        MOV      R3,R1
        LDR.N    R0,??gcode_G29_2+0x40
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
        B.N      ??gcode_G29_135
        DATA
??gcode_G29_0:
        DC32     mksCfg
        DC32     Running
        DC32     _ZZ9gcode_G29vEs
        DC32     _ZZ9gcode_G29vEs_0
        DC32     _ZN7Planner11abl_enabledE
        DC32     errormagic
        DC32     _ZZ9gcode_G29vEs_1
        DC32     0x47c34f80
        DC32     0xc1200000
        DC32     0x41200001
        DC32     _ZZ9gcode_G29vEs_2
        THUMB
??gcode_G29_136:
        MOV      R2,R1
        MOVS     R1,#+32
        LDR.N    R0,??gcode_G29_2+0x40
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
??gcode_G29_137:
        MOV      R0,R6
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??gcode_G29_1+0x4
        LDRB     R2,[R2, #+7]
        CMP      R2,#+0
        BNE.N    ??gcode_G29_134
        MOVS     R2,#+5
        STR      R2,[SP, #+0]
        MOV      R2,R0
        MOV      R3,R1
        LDR.N    R0,??gcode_G29_2+0x3C
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
??gcode_G29_135:
        ADDS     R4,R4,#+1
??gcode_G29_138:
        MOV      R0,R4
        UXTB     R0,R0
        CMP      R0,R11
        BGE.W    ??gcode_G29_139
        ADD      R1,SP,#+184
        ADD      R0,R1,R0, LSL #+6
        LDR      R6,[R0, R7, LSL #+2]
        LDR      R0,[R5, R6, LSL #+2]
        STR      R0,[SP, #+72]
        ADD      R0,R5,R6, LSL #+2
        LDR      R0,[R0, R10, LSL #+2]
        STR      R0,[SP, #+44]
        MOVS     R0,#+0
        STR      R0,[SP, #+40]
        ADD      R0,SP,#+40
        STR      R0,[SP, #+28]
        ADD      R0,SP,#+44
        STR      R0,[SP, #+24]
        ADD      R0,SP,#+72
        STR      R0,[SP, #+20]
        LDR.N    R1,??gcode_G29_2+0x34
        SUB      SP,SP,#+16
          CFI CFA R13+1264
        MOV      R0,SP
        MOVS     R2,#+36
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        POP      {R0-R3}
          CFI CFA R13+1248
          CFI FunCall _Z18apply_rotation_xyz10matrix_3x3RfS0_S0_
        BL       _Z18apply_rotation_xyz10matrix_3x3RfS0_S0_
        LDR      R0,[R8, R6, LSL #+2]
        LDR      R1,[SP, #+40]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R6,R0
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_G29_140
        LDR.N    R0,??gcode_G29_2+0x58
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.N      ??gcode_G29_137
??gcode_G29_140:
        LDR.N    R0,??gcode_G29_1+0x4
        LDRB     R0,[R0, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_136
        MOVS     R1,#+32
        LDR.N    R0,??gcode_G29_2+0x3C
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??gcode_G29_137
??gcode_G29_141:
        LDR.N    R0,??gcode_G29_1+0x4
        LDRB     R0,[R0, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_142
        MOVS     R1,#+10
        LDR.N    R0,??gcode_G29_2+0x3C
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??gcode_G29_103
??gcode_G29_142:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.N    R0,??gcode_G29_2+0x40
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
??gcode_G29_103:
        LDR      R0,[SP, #+52]
        LDRB     R0,[R0, #+0]
        TST      R0,#0x6
        BEQ.N    ??gcode_G29_143
        LDR      R0,[SP, #+48]
        CMP      R0,#+0
        BLE.N    ??gcode_G29_144
        LDR.N    R1,??gcode_G29_2+0x60
        LDR.N    R0,??gcode_G29_2+0x34
          CFI FunCall _ZN10matrix_3x35debugEPKc
        BL       _ZN10matrix_3x35debugEPKc
??gcode_G29_144:
        LDR      R0,[SP, #+56]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_145
        MOVS     R2,#+12
        LDR.N    R1,??gcode_G29_2+0x64
        MOV      R0,SP
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R0,#+1
        LDR.N    R1,??gcode_G29_2+0x68
        STRB     R0,[R1, #+0]
        MOV      R0,SP
          CFI FunCall _ZN7Planner16unapply_levelingEPf
        BL       _ZN7Planner16unapply_levelingEPf
        MOVS     R0,#+0
        LDR.N    R1,??gcode_G29_2+0x68
        STRB     R0,[R1, #+0]
        LDR      R0,[SP, #+36]
        LDR      R0,[R0, #+12]
        LDR      R1,[SP, #+68]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR.N    R1,??gcode_G29_1+0x4
        LDR      R1,[R1, #+8]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR.N    R4,??gcode_G29_2+0x6C  ;; 0xb58637bd
        MOV      R1,R4
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_G29_146
        LDR.N    R6,??gcode_G29_2+0x70  ;; 0x358637be
        MOV      R1,R6
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_G29_146
        LDR      R0,[SP, #+36]
        LDR      R0,[R0, #+16]
        LDR      R1,[SP, #+64]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR.N    R1,??gcode_G29_1+0x4
        LDR      R1,[R1, #+12]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R4
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_G29_146
        MOV      R1,R6
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_G29_146
        LDR.N    R0,??gcode_G29_1+0x4
        LDR      R0,[R0, #+16]
        LDR      R1,[SP, #+60]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+8]
??gcode_G29_146:
        MOVS     R2,#+12
        MOV      R1,SP
        LDR.N    R0,??gcode_G29_2+0x64
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        B.N      ??gcode_G29_145
        DATA
??gcode_G29_1:
        DC32     0x47c34f00
        DC32     mks_heating_busy
        THUMB
??gcode_G29_143:
        CMP      R0,#+8
        BNE.N    ??gcode_G29_145
        LDR      R0,[SP, #+56]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_145
        LDR.N    R4,??gcode_G29_2+0x74
        ADD      R0,R4,#+8
          CFI FunCall _Z17bilinear_z_offsetPKf
        BL       _Z17bilinear_z_offsetPKf
        MOV      R1,R0
        LDR      R0,[R4, #+16]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+16]
??gcode_G29_145:
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531923report_current_positionEv
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531923report_current_positionEv
        MOVS     R0,#+1
        LDR.N    R1,??gcode_G29_2+0x74
        STRB     R0,[R1, #+6]
        LDR      R0,[SP, #+56]
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_147
        LDRB     R0,[SP, #+32]
        LDR.N    R1,??gcode_G29_2+0x68
        STRB     R0,[R1, #+0]
        B.N      ??gcode_G29_148
??gcode_G29_147:
        MOVS     R0,#+1
        LDR.N    R1,??gcode_G29_2+0x68
        STRB     R0,[R1, #+0]
??gcode_G29_148:
        MOV      R0,R1
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_149
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
??gcode_G29_149:
        MOV      R0,R8
          CFI FunCall free
        BL       free
        MOV      R0,R5
          CFI FunCall free
        BL       free
??gcode_G29_3:
        ADD      SP,SP,#+1024
          CFI CFA R13+224
        ADD      SP,SP,#+188
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
          CFI CFA R13+1248
??gcode_G29_139:
        STR      R11,[SP, #+44]
        STR      R10,[SP, #+40]
        MOV      R4,R9
        LDR.N    R0,??gcode_G29_2+0x74
        LDRB     R0,[R0, #+7]
        CMP      R0,#+0
        BNE.W    ??gcode_G29_132
        MOVS     R1,#+10
        LDR.N    R0,??gcode_G29_2+0x3C
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
??gcode_G29_133:
        SUBS     R7,R7,#+1
        SXTB     R7,R7
??gcode_G29_131:
        CMP      R7,#+0
        BMI.W    ??gcode_G29_141
        MOVS     R0,#+0
        LDR      R11,[SP, #+44]
        LDR      R10,[SP, #+40]
        MOV      R9,R4
        MOV      R4,R0
        B.N      ??gcode_G29_138
        Nop      
        DATA
??gcode_G29_2:
        DC32     z_values
        DC32     _ZZ9gcode_G29vEs_3
        DC32     _ZZ9gcode_G29vEs_4
        DC32     0x42700000
        DC32     mksTmp
        DC32     _ZZ9gcode_G29vEs_5
        DC32     _ZZ9gcode_G29vEs_6
        DC32     _ZZ9gcode_G29vEs_7
        DC32     _ZZ9gcode_G29vEs_8
        DC32     _ZZ9gcode_G29vEs_9
        DC32     _ZZ9gcode_G29vEs__10_
        DC32     0x3fe00000
        DC32     0xbf800000
        DC32     _ZN7Planner16bed_level_matrixE
        DC32     _ZZ9gcode_G29vEs__11_
        DC32     customizedSerial
        DC32     serial2
        DC32     _ZZ9gcode_G29vEs__12_
        DC32     _ZZ9gcode_G29vEs__13_
        DC32     _ZZ9gcode_G29vEs__14_
        DC32     _ZZ9gcode_G29vEs__15_
        DC32     0x4479c000
        DC32     _ZZ9gcode_G29vEs__16_
        DC32     _ZZ9gcode_G29vEs__17_
        DC32     _ZZ9gcode_G29vEs__18_
        DC32     mks_heating_busy+0x8
        DC32     _ZN7Planner11abl_enabledE
        DC32     0xb58637bd
        DC32     0x358637be
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock237

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_G30v
          CFI Block cfiBlock238 Using cfiCommon0
          CFI Function _Z9gcode_G30v
        THUMB
_Z9gcode_G30v:
        PUSH     {R1-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+40
        LDR.N    R6,??gcode_G30_0
        MOVS     R0,#+88
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_G30_1
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        MOV      R9,R0
        B.N      ??gcode_G30_2
??gcode_G30_1:
        LDR      R1,[R6, #+8]
        LDR.N    R0,??gcode_G30_0+0x4
        LDR      R0,[R0, #+44]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R9,R0
??gcode_G30_2:
        MOVS     R0,#+89
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_G30_3
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        MOV      R7,R0
        B.N      ??gcode_G30_4
??gcode_G30_3:
        LDR      R1,[R6, #+12]
        LDR.N    R0,??gcode_G30_0+0x4
        LDR      R0,[R0, #+48]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R7,R0
??gcode_G30_4:
        STR      R9,[SP, #+0]
        STR      R7,[SP, #+4]
        LDR      R0,[R6, #+76]
        STR      R0,[SP, #+8]
        MOVS     R1,#+1
        MOV      R0,SP
          CFI FunCall _Z21position_is_reachablePKfb
        BL       _Z21position_is_reachablePKfb
        CMP      R0,#+0
        BEQ.N    ??gcode_G30_5
        LDR.N    R0,??gcode_G30_0+0x8
        LDRB     R0,[R0, #+64]
        TST      R0,#0x3E
        BEQ.N    ??gcode_G30_6
        MOVS     R0,#+0
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
??gcode_G30_6:
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531931setup_for_endstop_or_probe_moveEv
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531931setup_for_endstop_or_probe_moveEv
        MOVS     R0,#+83
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_G30_7
          CFI FunCall _Z15code_value_boolv
        BL       _Z15code_value_boolv
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        MVNS     R2,R2
        LSRS     R2,R2,#+31
        B.N      ??gcode_G30_8
??gcode_G30_7:
        MOVS     R2,#+1
??gcode_G30_8:
        MOVS     R3,#+1
        MOV      R1,R7
        MOV      R0,R9
          CFI FunCall _Z8probe_ptffbi
        BL       _Z8probe_ptffbi
        MOV      R8,R0
        LDR.N    R4,??gcode_G30_0+0xC  ;; 0x88e368f1
        LDR.N    R5,??gcode_G30_0+0x10  ;; 0x3ee4f8b5
        MOV      R0,R9
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R0
        MOV      R3,R1
        LDR.N    R0,??gcode_G30_0+0x14
          CFI FunCall _Z17serial_echopair_PPKcd
        BL       _Z17serial_echopair_PPKcd
        MOV      R0,R7
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R0
        MOV      R3,R1
        LDR.N    R0,??gcode_G30_0+0x18
          CFI FunCall _Z17serial_echopair_PPKcd
        BL       _Z17serial_echopair_PPKcd
        MOV      R0,R8
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R0
        MOV      R3,R1
        LDR.N    R0,??gcode_G30_0+0x1C
          CFI FunCall _Z17serial_echopair_PPKcd
        BL       _Z17serial_echopair_PPKcd
        LDRB     R0,[R6, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_G30_9
        MOVS     R1,#+10
        LDR.N    R0,??gcode_G30_0+0x20
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??gcode_G30_10
??gcode_G30_9:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.N    R0,??gcode_G30_0+0x24
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
??gcode_G30_10:
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531936clean_up_after_endstop_or_probe_moveEv
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531936clean_up_after_endstop_or_probe_moveEv
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531923report_current_positionEv
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531923report_current_positionEv
??gcode_G30_5:
        POP      {R0-R2,R4-R9,PC}  ;; return
        Nop      
        DATA
??gcode_G30_0:
        DC32     mks_heating_busy
        DC32     mksCfg+0x40
        DC32     mksCfg
        DC32     0x88e368f1
        DC32     0x3ee4f8b5
        DC32     _ZZ9gcode_G30vEs
        DC32     _ZZ9gcode_G30vEs_0
        DC32     _ZZ9gcode_G30vEs_1
        DC32     customizedSerial
        DC32     serial2
          CFI EndBlock cfiBlock238

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_G92v
          CFI Block cfiBlock239 Using cfiCommon0
          CFI Function _Z9gcode_G92v
        THUMB
_Z9gcode_G92v:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        MOVS     R5,#+0
        MOVS     R0,#+69
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        MOVS     R4,R0
        BNE.N    ??gcode_G92_1
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
??gcode_G92_1:
        MOV      R6,R5
??gcode_G92_2:
        CMP      R6,#+3
        BGT.N    ??gcode_G92_3
        LDR.N    R0,??gcode_G92_0
        LDRSB    R0,[R0, R6]
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_G92_4
        LDR.N    R0,??gcode_G92_0+0x4
        ADD      R7,R0,R6, LSL #+2
        LDR.N    R0,??gcode_G92_0+0x8
        LDRH     R0,[R0, #+88]
        TST      R0,#0x300
        BNE.N    ??gcode_G92_5
        LDR      R8,[R7, #+8]
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        STR      R0,[R7, #+8]
        CMP      R6,#+3
        BEQ.N    ??gcode_G92_4
        MOVS     R5,#+1
        LDR.N    R1,??gcode_G92_0+0xC
        ADD      R7,R1,R6, LSL #+2
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[R7, #+60]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R7, #+60]
        MOV      R0,R6
        SXTB     R0,R0
          CFI FunCall _Z24update_software_endstops8AxisEnum
        BL       _Z24update_software_endstops8AxisEnum
        B.N      ??gcode_G92_4
??gcode_G92_5:
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        STR      R0,[R7, #+8]
        CMP      R6,#+3
        BEQ.N    ??gcode_G92_4
        MOVS     R5,#+1
??gcode_G92_4:
        ADDS     R6,R6,#+1
        B.N      ??gcode_G92_2
??gcode_G92_6:
        CMP      R4,#+0
        BEQ.N    ??gcode_G92_7
          CFI FunCall _Z20sync_plan_position_ev
        BL       _Z20sync_plan_position_ev
??gcode_G92_7:
        POP      {R4-R8,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531923report_current_positionEv
        B.W      _ZN37_INTERNAL_15_Marlin_main_cpp_3178531923report_current_positionEv
          CFI R4 Frame(CFA, -24)
          CFI R5 Frame(CFA, -20)
          CFI R6 Frame(CFA, -16)
          CFI R7 Frame(CFA, -12)
          CFI R8 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+24
??gcode_G92_3:
        CMP      R5,#+0
        BEQ.N    ??gcode_G92_6
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
        B.N      ??gcode_G92_7
        DATA
??gcode_G92_0:
        DC32     axis_codes
        DC32     mks_heating_busy
        DC32     mksCfg
        DC32     axis_homed
          CFI EndBlock cfiBlock239

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z11gcode_M0_M1v
          CFI Block cfiBlock240 Using cfiCommon0
          CFI Function _Z11gcode_M0_M1v
        THUMB
_Z11gcode_M0_M1v:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        LDR.N    R5,??gcode_M0_M1_0
        LDR      R6,[R5, #+40]
        MOVS     R4,#+0
        MOV      R7,R4
        MOV      R8,R4
        MOVS     R0,#+80
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M0_M1_1
          CFI FunCall _Z17code_value_millisv
        BL       _Z17code_value_millisv
        MOVS     R4,R0
        BEQ.N    ??gcode_M0_M1_1
        MOVS     R7,#+1
??gcode_M0_M1_1:
        MOVS     R0,#+83
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M0_M1_2
          CFI FunCall _Z30code_value_millis_from_secondsv
        BL       _Z30code_value_millis_from_secondsv
        MOVS     R4,R0
        BEQ.N    ??gcode_M0_M1_2
        MOV      R8,#+1
??gcode_M0_M1_2:
        ORRS     R7,R8,R7
        BNE.N    ??gcode_M0_M1_3
        LDRSB    R0,[R6, #+0]
        CMP      R0,#+0
        BEQ.N    ??gcode_M0_M1_3
        MOVS     R1,#+1
        MOV      R0,R6
          CFI FunCall _Z13lcd_setstatusPKcb
        BL       _Z13lcd_setstatusPKcb
        B.N      ??gcode_M0_M1_4
??gcode_M0_M1_3:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M0_M1_0+0x4
          CFI FunCall _Z16lcd_setstatuspgmPKch
        BL       _Z16lcd_setstatuspgmPKch
??gcode_M0_M1_4:
        LDR.N    R6,??gcode_M0_M1_0+0x8
        MOVS     R0,#+3
        STRB     R0,[R6, #+6]
        MOVS     R0,#+1
        STRB     R0,[R6, #+4]
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
          CFI FunCall _Z19refresh_cmd_timeoutv
        BL       _Z19refresh_cmd_timeoutv
        CMP      R4,#+0
        BEQ.N    ??gcode_M0_M1_5
        LDR      R0,[R5, #+56]
        ADDS     R4,R0,R4
??gcode_M0_M1_6:
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        SUBS     R0,R0,R4
        BPL.N    ??gcode_M0_M1_7
        LDRB     R0,[R6, #+4]
        CMP      R0,#+0
        BEQ.N    ??gcode_M0_M1_7
        MOVS     R0,#+0
          CFI FunCall _Z4idleb
        BL       _Z4idleb
        B.N      ??gcode_M0_M1_6
??gcode_M0_M1_5:
          CFI FunCall _Z12lcd_detectedv
        BL       _Z12lcd_detectedv
        CMP      R0,#+0
        BNE.N    ??gcode_M0_M1_8
        B.N      ??gcode_M0_M1_7
??gcode_M0_M1_9:
        MOVS     R0,#+0
          CFI FunCall _Z4idleb
        BL       _Z4idleb
??gcode_M0_M1_8:
        LDRB     R0,[R6, #+4]
        CMP      R0,#+0
        BNE.N    ??gcode_M0_M1_9
        LDR.N    R0,??gcode_M0_M1_0+0xC
        LDRB     R0,[R0, #+2]
        CMP      R0,#+0
        BEQ.N    ??gcode_M0_M1_10
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M0_M1_0+0x10
          CFI FunCall _Z16lcd_setstatuspgmPKch
        BL       _Z16lcd_setstatuspgmPKch
        B.N      ??gcode_M0_M1_7
??gcode_M0_M1_10:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M0_M1_0+0x14
          CFI FunCall _Z16lcd_setstatuspgmPKch
        BL       _Z16lcd_setstatuspgmPKch
??gcode_M0_M1_7:
        MOVS     R0,#+0
        STRB     R0,[R6, #+4]
        MOVS     R0,#+1
        STRB     R0,[R6, #+6]
        POP      {R4-R8,PC}       ;; return
        DATA
??gcode_M0_M1_0:
        DC32     axis_relative_modes
        DC32     MSG_USERWAIT
        DC32     mks_heating_busy
        DC32     card
        DC32     _ZZ11gcode_M0_M1vEs
        DC32     WELCOME_MSG
          CFI EndBlock cfiBlock240

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M17v
          CFI Block cfiBlock241 Using cfiCommon0
          CFI Function _Z9gcode_M17v
        THUMB
_Z9gcode_M17v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M17_0
          CFI FunCall _Z16lcd_setstatuspgmPKch
        BL       _Z16lcd_setstatuspgmPKch
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z19enable_all_steppersv
        B.W      _Z19enable_all_steppersv
        Nop      
        DATA
??gcode_M17_0:
        DC32     _ZZ9gcode_M17vEs
          CFI EndBlock cfiBlock241

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M20v
          CFI Block cfiBlock242 Using cfiCommon0
          CFI Function _Z9gcode_M20v
        THUMB
_Z9gcode_M20v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M20_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M20_0+0x4
          CFI FunCall _ZN10CardReader2lsEv
        BL       _ZN10CardReader2lsEv
        LDR.N    R0,??gcode_M20_0+0x8
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
        DATA
??gcode_M20_0:
        DC32     _ZZ9gcode_M20vEs
        DC32     card
        DC32     _ZZ9gcode_M20vEs_0
          CFI EndBlock cfiBlock242

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M21v
          CFI Block cfiBlock243 Using cfiCommon0
          CFI Function _Z9gcode_M21v
        THUMB
_Z9gcode_M21v:
        LDR.N    R0,??gcode_M21_0
          CFI FunCall _ZN10CardReader6initsdEv
        B.W      _ZN10CardReader6initsdEv
        Nop      
        DATA
??gcode_M21_0:
        DC32     card
          CFI EndBlock cfiBlock243

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M22v
          CFI Block cfiBlock244 Using cfiCommon0
          CFI Function _Z9gcode_M22v
        THUMB
_Z9gcode_M22v:
        LDR.N    R0,??gcode_M22_0
          CFI FunCall _ZN10CardReader7releaseEv
        B.W      _ZN10CardReader7releaseEv
        Nop      
        DATA
??gcode_M22_0:
        DC32     card
          CFI EndBlock cfiBlock244

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M23v
          CFI Block cfiBlock245 Using cfiCommon0
          CFI Function _Z9gcode_M23v
        THUMB
_Z9gcode_M23v:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.N    R4,??gcode_M23_0
        LDR.N    R5,??gcode_M23_0+0x4
        MOVS     R3,#+0
        MOVS     R2,#+1
        LDR      R1,[R5, #+40]
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8openFileEPcbb
        BL       _ZN10CardReader8openFileEPcbb
        CMP      R0,#+0
        BPL.N    ??gcode_M23_1
        LDR      R5,[R5, #+40]
        LDR.N    R1,??gcode_M23_0+0x8
        MOV      R0,R5
          CFI FunCall __iar_Strstr
        BL       __iar_Strstr
        CMP      R0,#+0
        BNE.N    ??gcode_M23_2
        LDR.N    R1,??gcode_M23_0+0xC
        MOV      R0,R5
          CFI FunCall __iar_Strstr
        BL       __iar_Strstr
??gcode_M23_2:
        CMP      R0,#+0
        BEQ.N    ??gcode_M23_1
        MOVS     R1,#+0
        STRB     R1,[R0, #+2]
        SUBS     R0,R0,R5
        CMP      R0,#+9
        BCC.N    ??gcode_M23_3
        MOVS     R0,#+126
        STRB     R0,[R5, #+7]
        MOVS     R0,#+46
        STRB     R0,[R5, #+8]
        MOVS     R0,#+103
        STRB     R0,[R5, #+9]
        MOV      R0,R1
        STRB     R0,[R5, #+10]
??gcode_M23_3:
        MOV      R3,R1
        MOVS     R2,#+1
        MOV      R1,R5
        MOV      R0,R4
        ADD      SP,SP,#+4
          CFI CFA R13+12
        POP      {R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10CardReader8openFileEPcbb
        B.W      _ZN10CardReader8openFileEPcbb
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??gcode_M23_1:
        POP      {R0,R4,R5,PC}    ;; return
        Nop      
        DATA
??gcode_M23_0:
        DC32     card
        DC32     axis_relative_modes
        DC32     _ZZ9gcode_M23vEs
        DC32     _ZZ9gcode_M23vEs_0
          CFI EndBlock cfiBlock245

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M24v
          CFI Block cfiBlock246 Using cfiCommon0
          CFI Function _Z9gcode_M24v
        THUMB
_Z9gcode_M24v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
          CFI FunCall mks_resumePrint
        BL       mks_resumePrint
        LDR.N    R4,??gcode_M24_0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader10lastOpenOkEv
        BL       _ZN10CardReader10lastOpenOkEv
        CMP      R0,#+0
        BEQ.N    ??gcode_M24_1
        MOV      R0,R4
          CFI FunCall _ZN10CardReader14startFileprintEv
        BL       _ZN10CardReader14startFileprintEv
        LDR.N    R0,??gcode_M24_0+0x4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN9Stopwatch5startEv
        B.W      _ZN9Stopwatch5startEv
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M24_1:
        POP      {R4,PC}          ;; return
        DATA
??gcode_M24_0:
        DC32     card
        DC32     mks_heating_busy+0x388
          CFI EndBlock cfiBlock246

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M25v
          CFI Block cfiBlock247 Using cfiCommon0
          CFI Function _Z9gcode_M25v
        THUMB
_Z9gcode_M25v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M25_0
          CFI FunCall _ZN10CardReader12pauseSDPrintEv
        BL       _ZN10CardReader12pauseSDPrintEv
        LDR.N    R0,??gcode_M25_0+0x4
          CFI FunCall _ZN9Stopwatch5pauseEv
        BL       _ZN9Stopwatch5pauseEv
        MOVS     R0,#+168
        LDR.N    R1,??gcode_M25_0+0x8
        STRB     R0,[R1, #+104]
        POP      {R0,PC}          ;; return
        DATA
??gcode_M25_0:
        DC32     card
        DC32     mks_heating_busy+0x388
        DC32     mksReprint
          CFI EndBlock cfiBlock247

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M26v
          CFI Block cfiBlock248 Using cfiCommon0
          CFI Function _Z9gcode_M26v
        THUMB
_Z9gcode_M26v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R4,??gcode_M26_0
        LDRB     R0,[R4, #+3]
        CMP      R0,#+0
        BEQ.N    ??gcode_M26_1
        MOVS     R0,#+83
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M26_1
          CFI FunCall _Z15code_value_longv
        BL       _Z15code_value_longv
        MOV      R1,R0
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10CardReader8setIndexEl
        B.W      _ZN10CardReader8setIndexEl
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M26_1:
        POP      {R4,PC}          ;; return
        Nop      
        DATA
??gcode_M26_0:
        DC32     card
          CFI EndBlock cfiBlock248

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M27v
          CFI Block cfiBlock249 Using cfiCommon0
          CFI Function _Z9gcode_M27v
        THUMB
_Z9gcode_M27v:
        LDR.N    R0,??gcode_M27_0
          CFI FunCall _ZN10CardReader9getStatusEv
        B.W      _ZN10CardReader9getStatusEv
        Nop      
        DATA
??gcode_M27_0:
        DC32     card
          CFI EndBlock cfiBlock249

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M28v
          CFI Block cfiBlock250 Using cfiCommon0
          CFI Function _Z9gcode_M28v
        THUMB
_Z9gcode_M28v:
        MOVS     R3,#+0
        MOV      R2,R3
        LDR.N    R0,??gcode_M28_0
        LDR      R1,[R0, #+40]
        LDR.N    R0,??gcode_M28_0+0x4
          CFI FunCall _ZN10CardReader8openFileEPcbb
        B.W      _ZN10CardReader8openFileEPcbb
        Nop      
        DATA
??gcode_M28_0:
        DC32     axis_relative_modes
        DC32     card
          CFI EndBlock cfiBlock250

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z9gcode_M29v
          CFI Block cfiBlock251 Using cfiCommon0
          CFI Function _Z9gcode_M29v
          CFI NoCalls
        THUMB
_Z9gcode_M29v:
        BX       LR               ;; return
          CFI EndBlock cfiBlock251

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M30v
          CFI Block cfiBlock252 Using cfiCommon0
          CFI Function _Z9gcode_M30v
        THUMB
_Z9gcode_M30v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R4,??gcode_M30_0
        LDRB     R0,[R4, #+3]
        CMP      R0,#+0
        BEQ.N    ??gcode_M30_1
        MOVS     R1,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader9closefileEb
        BL       _ZN10CardReader9closefileEb
        LDR.N    R0,??gcode_M30_0+0x4
        LDR      R1,[R0, #+40]
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10CardReader10removeFileEPc
        B.W      _ZN10CardReader10removeFileEPc
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M30_1:
        POP      {R4,PC}          ;; return
        Nop      
        DATA
??gcode_M30_0:
        DC32     card
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock252

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M31v
          CFI Block cfiBlock253 Using cfiCommon0
          CFI Function _Z9gcode_M31v
        THUMB
_Z9gcode_M31v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        SUB      SP,SP,#+32
          CFI CFA R13+40
        LDR.N    R4,??gcode_M31_0
        ADD      R0,R4,#+904
          CFI FunCall _ZN9Stopwatch8durationEv
        BL       _ZN9Stopwatch8durationEv
        STR      R0,[SP, #+0]
        MOV      R1,SP
        ADD      R0,SP,#+4
          CFI FunCall _ZN10duration_tC1ERKj
        BL       _ZN10duration_tC1ERKj
        ADD      R1,SP,#+8
          CFI FunCall _ZNK10duration_t8toStringEPc
        BL       _ZNK10duration_t8toStringEPc
        MOVS     R1,#+0
        ADD      R0,SP,#+8
          CFI FunCall _Z13lcd_setstatusPKcb
        BL       _Z13lcd_setstatusPKcb
        LDR.N    R0,??gcode_M31_0+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        ADD      R1,SP,#+8
        LDR.N    R0,??gcode_M31_0+0x8
          CFI FunCall _Z17serial_echopair_PPKcS0_
        BL       _Z17serial_echopair_PPKcS0_
        LDRB     R0,[R4, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_M31_1
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M31_0+0xC
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??gcode_M31_2
??gcode_M31_1:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M31_0+0x10
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
??gcode_M31_2:
        ADD      SP,SP,#+32
          CFI CFA R13+8
        POP      {R4,PC}          ;; return
        Nop      
        DATA
??gcode_M31_0:
        DC32     mks_heating_busy
        DC32     echomagic
        DC32     _ZZ9gcode_M31vEs
        DC32     customizedSerial
        DC32     serial2
          CFI EndBlock cfiBlock253

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M32v
          CFI Block cfiBlock254 Using cfiCommon0
          CFI Function _Z9gcode_M32v
        THUMB
_Z9gcode_M32v:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        LDR.N    R4,??gcode_M32_0
        LDRB     R0,[R4, #+2]
        CMP      R0,#+0
        BEQ.N    ??gcode_M32_1
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
??gcode_M32_1:
        LDR.N    R5,??gcode_M32_0+0x4
        LDR      R6,[R5, #+40]
        MOVS     R1,#+33
        MOV      R0,R6
          CFI FunCall __iar_Strchr
        BL       __iar_Strchr
        CMP      R0,#+0
        BEQ.N    ??gcode_M32_2
        ADDS     R6,R0,#+1
??gcode_M32_2:
        MOVS     R0,#+80
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M32_3
        LDR      R0,[R5, #+44]
        CMP      R0,R6
        SBCS     R7,R7,R7
        LSRS     R7,R7,#+31
        B.N      ??gcode_M32_4
??gcode_M32_3:
        MOVS     R7,#+0
??gcode_M32_4:
        LDRB     R0,[R4, #+3]
        CMP      R0,#+0
        BEQ.N    ??gcode_M32_5
        MOV      R3,R7
        MOVS     R2,#+1
        MOV      R1,R6
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8openFileEPcbb
        BL       _ZN10CardReader8openFileEPcbb
        MOVS     R0,#+83
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M32_6
        LDR      R0,[R5, #+44]
        CMP      R0,R6
        BCS.N    ??gcode_M32_6
          CFI FunCall _Z15code_value_longv
        BL       _Z15code_value_longv
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8setIndexEl
        BL       _ZN10CardReader8setIndexEl
??gcode_M32_6:
        MOV      R0,R4
          CFI FunCall _ZN10CardReader14startFileprintEv
        BL       _ZN10CardReader14startFileprintEv
        CMP      R7,#+0
        BNE.N    ??gcode_M32_5
        LDR.N    R0,??gcode_M32_0+0x8
        POP      {R1,R4-R7,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN9Stopwatch5startEv
        B.W      _ZN9Stopwatch5startEv
          CFI R4 Frame(CFA, -20)
          CFI R5 Frame(CFA, -16)
          CFI R6 Frame(CFA, -12)
          CFI R7 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+24
??gcode_M32_5:
        POP      {R0,R4-R7,PC}    ;; return
        Nop      
        DATA
??gcode_M32_0:
        DC32     card
        DC32     axis_relative_modes
        DC32     mks_heating_busy+0x388
          CFI EndBlock cfiBlock254

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M928v
          CFI Block cfiBlock255 Using cfiCommon0
          CFI Function _Z10gcode_M928v
        THUMB
_Z10gcode_M928v:
        LDR.N    R0,??gcode_M928_0
        LDR      R1,[R0, #+40]
        LDR.N    R0,??gcode_M928_0+0x4
          CFI FunCall _ZN10CardReader11openLogFileEPc
        B.W      _ZN10CardReader11openLogFileEPc
        Nop      
        DATA
??gcode_M928_0:
        DC32     axis_relative_modes
        DC32     card
          CFI EndBlock cfiBlock255

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M42v
          CFI Block cfiBlock256 Using cfiCommon0
          CFI Function _Z9gcode_M42v
        THUMB
_Z9gcode_M42v:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R0,#+83
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M42_1
          CFI FunCall _Z14code_value_intv
        BL       _Z14code_value_intv
        MOV      R4,R0
        CMP      R4,#+256
        BCS.N    ??gcode_M42_1
        MOVS     R0,#+80
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M42_2
          CFI FunCall _Z14code_value_intv
        BL       _Z14code_value_intv
        MOV      R5,R0
        B.N      ??gcode_M42_3
??gcode_M42_2:
        MOV      R5,#-1
??gcode_M42_3:
        CMP      R5,#+0
        BMI.N    ??gcode_M42_1
        MOV      R0,R5
        UXTB     R0,R0
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531916pin_is_protectedEh
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531916pin_is_protectedEh
        CMP      R0,#+0
        BEQ.N    ??gcode_M42_4
        LDR.N    R0,??gcode_M42_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M42_0+0x4
        POP      {R1,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??gcode_M42_4:
        CMP      R5,#+0
        MOV      R2,R4
        SXTB     R2,R2
        BMI.N    ??gcode_M42_5
        LDR.N    R0,??gcode_M42_0+0x8
        LDRH     R1,[R0, R5, LSL #+1]
        LDR.N    R0,??gcode_M42_0+0xC
        LDR      R0,[R0, R5, LSL #+2]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        B.N      ??gcode_M42_6
??gcode_M42_5:
        MOVS     R1,#+0
        MOV      R0,R1
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
??gcode_M42_6:
        CMP      R5,#+17
        BNE.N    ??gcode_M42_1
        LDR.N    R0,??gcode_M42_0+0x10
        STR      R4,[R0, #+0]
??gcode_M42_1:
        POP      {R0,R4,R5,PC}    ;; return
        Nop      
        DATA
??gcode_M42_0:
        DC32     errormagic
        DC32     _ZZ9gcode_M42vEs
        DC32     gArrayGpioPin
        DC32     gArrayGpioPort
        DC32     fanSpeeds
          CFI EndBlock cfiBlock256

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M49v
          CFI Block cfiBlock257 Using cfiCommon0
          CFI Function _Z9gcode_M49v
        THUMB
_Z9gcode_M49v:
        LDR.N    R0,??gcode_M49_0
        LDRB     R0,[R0, #+64]
        CMP      R0,#+16
        BEQ.N    ??gcode_M49_1
        BX       LR
??gcode_M49_1:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R4,??gcode_M49_0+0x4
        LDRB     R0,[R4, #+0]
        EOR      R0,R0,#0x1
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
        STRB     R0,[R4, #+0]
        LDR.N    R0,??gcode_M49_0+0x8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDRB     R0,[R4, #+0]
        CMP      R0,#+0
        BEQ.N    ??gcode_M49_2
        LDR.N    R0,??gcode_M49_0+0xC
        B.N      ??gcode_M49_3
??gcode_M49_2:
        LDR.N    R0,??gcode_M49_0+0x10
??gcode_M49_3:
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
        Nop      
        DATA
??gcode_M49_0:
        DC32     mksCfg
        DC32     _ZN20unified_bed_leveling14g26_debug_flagE
        DC32     _ZZ9gcode_M49vEs
        DC32     _ZZ9gcode_M49vEs_0
        DC32     _ZZ9gcode_M49vEs_1
          CFI EndBlock cfiBlock257

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M75v
          CFI Block cfiBlock258 Using cfiCommon0
          CFI Function _Z9gcode_M75v
        THUMB
_Z9gcode_M75v:
        LDR.N    R0,??gcode_M75_0
          CFI FunCall _ZN9Stopwatch5startEv
        B.W      _ZN9Stopwatch5startEv
        Nop      
        DATA
??gcode_M75_0:
        DC32     mks_heating_busy+0x388
          CFI EndBlock cfiBlock258

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M76v
          CFI Block cfiBlock259 Using cfiCommon0
          CFI Function _Z9gcode_M76v
        THUMB
_Z9gcode_M76v:
        LDR.N    R0,??gcode_M76_0
          CFI FunCall _ZN9Stopwatch5pauseEv
        B.W      _ZN9Stopwatch5pauseEv
        Nop      
        DATA
??gcode_M76_0:
        DC32     mks_heating_busy+0x388
          CFI EndBlock cfiBlock259

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M77v
          CFI Block cfiBlock260 Using cfiCommon0
          CFI Function _Z9gcode_M77v
        THUMB
_Z9gcode_M77v:
        LDR.N    R0,??gcode_M77_0
          CFI FunCall _ZN9Stopwatch4stopEv
        B.W      _ZN9Stopwatch4stopEv
        Nop      
        DATA
??gcode_M77_0:
        DC32     mks_heating_busy+0x388
          CFI EndBlock cfiBlock260

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M104v
          CFI Block cfiBlock261 Using cfiCommon0
          CFI Function _Z10gcode_M104v
        THUMB
_Z10gcode_M104v:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOVS     R0,#+104
          CFI FunCall _Z32get_target_extruder_from_commandi
        BL       _Z32get_target_extruder_from_commandi
        CMP      R0,#+0
        BNE.N    ??gcode_M104_2
        LDR.N    R4,??gcode_M104_1
        LDRB     R0,[R4, #+1]
        LSLS     R0,R0,#+28
        BMI.N    ??gcode_M104_2
        MOVS     R0,#+83
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M104_3
          CFI FunCall _Z19code_value_temp_absv
        BL       _Z19code_value_temp_absv
        LDRB     R1,[R4, #+5]
        MOV      R5,R1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R5
          CFI FunCall _ZN11Temperature15setTargetHotendEfh
        BL       _ZN11Temperature15setTargetHotendEfh
          CFI FunCall _Z19code_value_temp_absv
        BL       _Z19code_value_temp_absv
        LDR.N    R5,??gcode_M104_1+0x4
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R6,R1
        LDR      R1,[R5, #+0]
        MOV      R0,#+1056964608
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R6
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_M104_4
        ADD      R0,R4,#+904
          CFI FunCall _ZN9Stopwatch4stopEv
        BL       _ZN9Stopwatch4stopEv
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M104_1+0x8
          CFI FunCall _Z16lcd_setstatuspgmPKch
        BL       _Z16lcd_setstatuspgmPKch
??gcode_M104_4:
        LDRB     R0,[R4, #+5]
          CFI FunCall _ZN11Temperature9degHotendEh
        BL       _ZN11Temperature9degHotendEh
        MOV      R6,R0
          CFI FunCall _Z19code_value_temp_absv
        BL       _Z19code_value_temp_absv
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R6
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_M104_3
        LDRB     R0,[R4, #+5]
        CMP      R0,#+4
        BHI.N    ??gcode_M104_3
        TBB      [PC, R0]
        DATA
??gcode_M104_0:
        DC8      0x3,0x10,0x15,0x1A
        DC8      0x1F,0x0
        THUMB
??gcode_M104_5:
        LDRB     R0,[R5, #+18]
        CMP      R0,#+1
        BNE.N    ??gcode_M104_6
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M104_1+0xC
          CFI FunCall _Z16lcd_setstatuspgmPKch
        BL       _Z16lcd_setstatuspgmPKch
        B.N      ??gcode_M104_3
??gcode_M104_6:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M104_1+0x10
          CFI FunCall _Z16lcd_setstatuspgmPKch
        BL       _Z16lcd_setstatuspgmPKch
        B.N      ??gcode_M104_3
??gcode_M104_7:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M104_1+0x14
          CFI FunCall _Z16lcd_setstatuspgmPKch
        BL       _Z16lcd_setstatuspgmPKch
        B.N      ??gcode_M104_3
??gcode_M104_8:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M104_1+0x18
          CFI FunCall _Z16lcd_setstatuspgmPKch
        BL       _Z16lcd_setstatuspgmPKch
        B.N      ??gcode_M104_3
??gcode_M104_9:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M104_1+0x1C
          CFI FunCall _Z16lcd_setstatuspgmPKch
        BL       _Z16lcd_setstatuspgmPKch
        B.N      ??gcode_M104_3
??gcode_M104_10:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M104_1+0x20
          CFI FunCall _Z16lcd_setstatuspgmPKch
        BL       _Z16lcd_setstatuspgmPKch
??gcode_M104_3:
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Planner18autotemp_M104_M109Ev
        B.W      _ZN7Planner18autotemp_M104_M109Ev
          CFI R4 Frame(CFA, -16)
          CFI R5 Frame(CFA, -12)
          CFI R6 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??gcode_M104_2:
        POP      {R4-R6,PC}       ;; return
        DATA
??gcode_M104_1:
        DC32     mks_heating_busy
        DC32     mksCfg+0x2C
        DC32     WELCOME_MSG
        DC32     _ZZ10gcode_M104vEs
        DC32     _ZZ10gcode_M104vEs_0
        DC32     _ZZ10gcode_M104vEs_1
        DC32     _ZZ10gcode_M104vEs_2
        DC32     _ZZ10gcode_M104vEs_3
        DC32     _ZZ10gcode_M104vEs_4
          CFI EndBlock cfiBlock261

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M105v
          CFI Block cfiBlock262 Using cfiCommon0
          CFI Function _Z10gcode_M105v
        THUMB
_Z10gcode_M105v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+105
          CFI FunCall _Z32get_target_extruder_from_commandi
        BL       _Z32get_target_extruder_from_commandi
        CMP      R0,#+0
        BNE.N    ??gcode_M105_1
        LDR.N    R0,??gcode_M105_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
          CFI FunCall _Z18print_heaterstatesv
        BL       _Z18print_heaterstatesv
        LDR.N    R0,??gcode_M105_0+0x4
        LDRB     R0,[R0, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_M105_2
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M105_0+0x8
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN12MarlinSerial5writeEh
        B.W      _ZN12MarlinSerial5writeEh
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M105_2:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M105_0+0xC
        POP      {R3,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN12MarlinSerial5printEci
        B.W      _ZN12MarlinSerial5printEci
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M105_1:
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??gcode_M105_0:
        DC32     _ZZ10gcode_M105vEs
        DC32     mks_heating_busy
        DC32     customizedSerial
        DC32     serial2
          CFI EndBlock cfiBlock262

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M106v
          CFI Block cfiBlock263 Using cfiCommon0
          CFI Function _Z10gcode_M106v
        THUMB
_Z10gcode_M106v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M106_1
          CFI FunCall _Z17code_value_ushortv
        BL       _Z17code_value_ushortv
        MOV      R4,R0
        B.N      ??gcode_M106_2
??gcode_M106_1:
        MOVS     R4,#+255
??gcode_M106_2:
        MOVS     R0,#+80
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M106_3
          CFI FunCall _Z17code_value_ushortv
        BL       _Z17code_value_ushortv
        B.N      ??gcode_M106_4
??gcode_M106_3:
        MOVS     R0,#+0
??gcode_M106_4:
        CMP      R4,#+255
        BLE.N    ??gcode_M106_5
        MOVS     R4,#+255
??gcode_M106_5:
        CMP      R0,#+0
        BNE.N    ??gcode_M106_6
        LDR.N    R0,??gcode_M106_0
        STR      R4,[R0, #+0]
        MOVW     R0,#+10000
        MULS     R4,R0,R4
        MOVS     R0,#+255
        SDIV     R0,R4,R0
        LDR.N    R1,??gcode_M106_0+0x4  ;; 0x40012c34
        STR      R0,[R1, #+0]
??gcode_M106_6:
        POP      {R4,PC}          ;; return
        DATA
??gcode_M106_0:
        DC32     fanSpeeds
        DC32     0x40012c34
          CFI EndBlock cfiBlock263

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M107v
          CFI Block cfiBlock264 Using cfiCommon0
          CFI Function _Z10gcode_M107v
        THUMB
_Z10gcode_M107v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+80
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M107_1
          CFI FunCall _Z17code_value_ushortv
        BL       _Z17code_value_ushortv
        B.N      ??gcode_M107_2
??gcode_M107_1:
        MOVS     R0,#+0
??gcode_M107_2:
        CMP      R0,#+0
        BNE.N    ??gcode_M107_3
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M107_0
        STR      R0,[R1, #+0]
        LDR.N    R1,??gcode_M107_0+0x4  ;; 0x40012c34
        STR      R0,[R1, #+0]
??gcode_M107_3:
        POP      {R0,PC}          ;; return
        DATA
??gcode_M107_0:
        DC32     fanSpeeds
        DC32     0x40012c34
          CFI EndBlock cfiBlock264

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M108v
          CFI Block cfiBlock265 Using cfiCommon0
          CFI Function _Z10gcode_M108v
          CFI NoCalls
        THUMB
_Z10gcode_M108v:
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M108_0
        STRB     R0,[R1, #+3]
        BX       LR               ;; return
        DATA
??gcode_M108_0:
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock265

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M112v
          CFI Block cfiBlock266 Using cfiCommon0
          CFI Function _Z10gcode_M112v
        THUMB
_Z10gcode_M112v:
        LDR.N    R0,??gcode_M112_0
          CFI FunCall _Z4killPKc
        B.W      _Z4killPKc
        Nop      
        DATA
??gcode_M112_0:
        DC32     _ZZ10gcode_M112vEs
          CFI EndBlock cfiBlock266

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M410v
          CFI Block cfiBlock267 Using cfiCommon0
          CFI Function _Z10gcode_M410v
          CFI FunCall _Z17quickstop_stepperv
        THUMB
_Z10gcode_M410v:
        B.W      _Z17quickstop_stepperv
          CFI EndBlock cfiBlock267

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M109v
          CFI Block cfiBlock268 Using cfiCommon0
          CFI Function _Z10gcode_M109v
        THUMB
_Z10gcode_M109v:
        PUSH     {R1-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+48
        MOVS     R0,#+109
          CFI FunCall _Z32get_target_extruder_from_commandi
        BL       _Z32get_target_extruder_from_commandi
        CMP      R0,#+0
        BNE.W    ??gcode_M109_2
        LDR.N    R0,??gcode_M109_1
        LDRB     R0,[R0, #+1]
        LSLS     R0,R0,#+28
        BMI.W    ??gcode_M109_2
        MOVS     R0,#+83
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        MOVS     R4,R0
        BNE.N    ??gcode_M109_3
        MOVS     R0,#+82
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.W    ??gcode_M109_2
??gcode_M109_3:
          CFI FunCall _Z19code_value_temp_absv
        BL       _Z19code_value_temp_absv
        LDR.N    R5,??gcode_M109_1
        LDRB     R1,[R5, #+5]
        MOV      R6,R1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R6
          CFI FunCall _ZN11Temperature15setTargetHotendEfh
        BL       _ZN11Temperature15setTargetHotendEfh
          CFI FunCall _Z19code_value_temp_absv
        BL       _Z19code_value_temp_absv
        ADD      R6,R5,#+904
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R7,R1
        LDR.N    R0,??gcode_M109_1+0x4
        LDR      R1,[R0, #+44]
        MOV      R0,#+1056964608
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R7
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        MOV      R0,R6
        BHI.N    ??gcode_M109_4
          CFI FunCall _ZN9Stopwatch4stopEv
        BL       _ZN9Stopwatch4stopEv
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M109_1+0x8
          CFI FunCall _Z16lcd_setstatuspgmPKch
        BL       _Z16lcd_setstatuspgmPKch
        B.N      ??gcode_M109_5
??gcode_M109_4:
          CFI FunCall _ZN9Stopwatch5startEv
        BL       _ZN9Stopwatch5startEv
??gcode_M109_5:
        LDRB     R0,[R5, #+5]
          CFI FunCall _ZN11Temperature9degHotendEh
        BL       _ZN11Temperature9degHotendEh
        MOV      R6,R0
          CFI FunCall _Z19code_value_temp_absv
        BL       _Z19code_value_temp_absv
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R6
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_M109_6
        LDRB     R0,[R5, #+5]
        CMP      R0,#+4
        BHI.N    ??gcode_M109_6
        TBB      [PC, R0]
        DATA
??gcode_M109_0:
        DC8      0x3,0x8,0xD,0x12
        DC8      0x17,0x0
        THUMB
??gcode_M109_7:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M109_1+0xC
          CFI FunCall _Z16lcd_setstatuspgmPKch
        BL       _Z16lcd_setstatuspgmPKch
        B.N      ??gcode_M109_6
??gcode_M109_8:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M109_1+0x10
          CFI FunCall _Z16lcd_setstatuspgmPKch
        BL       _Z16lcd_setstatuspgmPKch
        B.N      ??gcode_M109_6
??gcode_M109_9:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M109_1+0x14
          CFI FunCall _Z16lcd_setstatuspgmPKch
        BL       _Z16lcd_setstatuspgmPKch
        B.N      ??gcode_M109_6
??gcode_M109_10:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M109_1+0x18
          CFI FunCall _Z16lcd_setstatuspgmPKch
        BL       _Z16lcd_setstatuspgmPKch
        B.N      ??gcode_M109_6
??gcode_M109_11:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M109_1+0x1C
          CFI FunCall _Z16lcd_setstatuspgmPKch
        BL       _Z16lcd_setstatuspgmPKch
??gcode_M109_6:
          CFI FunCall _ZN7Planner18autotemp_M104_M109Ev
        BL       _ZN7Planner18autotemp_M104_M109Ev
        MOVS     R0,#+0
        LDR.N    R7,??gcode_M109_1+0x20  ;; 0xbf800000
        LDR.W    R10,??gcode_M109_1+0x24  ;; 0x461c3c00
        MOV      R5,R0
        LDR.W    R9,??gcode_M109_1
        MOVS     R1,#+1
        STRB     R1,[R9, #+3]
        MOV      R1,R0
        MOV      R6,R0
        MOV      R2,R0
        STRB     R2,[R9, #+6]
        MOVS     R2,#+1
        STRB     R2,[R9, #+0]
        STR      R4,[SP, #+4]
        MOV      R4,R0
        STR      R1,[SP, #+0]
??gcode_M109_12:
        LDRB     R8,[R9, #+5]
        MOV      R0,R8
          CFI FunCall _ZN11Temperature15degTargetHotendEh
        BL       _ZN11Temperature15degTargetHotendEh
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??gcode_M109_13
        MOV      R0,R8
          CFI FunCall _ZN11Temperature15isCoolingHotendEh
        BL       _ZN11Temperature15isCoolingHotendEh
        MOV      R5,R0
        MOV      R0,R8
          CFI FunCall _ZN11Temperature15degTargetHotendEh
        BL       _ZN11Temperature15degTargetHotendEh
        MOV      R7,R0
        LDR      R0,[SP, #+4]
        CMP      R0,#+0
        BEQ.N    ??gcode_M109_13
        CMP      R5,#+0
        BNE.N    ??gcode_M109_14
??gcode_M109_13:
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        MOV      R8,R0
        LDR      R0,[SP, #+0]
        SUBS     R0,R8,R0
        BMI.N    ??gcode_M109_15
        ADD      R0,R8,#+1000
        STR      R0,[SP, #+0]
          CFI FunCall _Z18print_heaterstatesv
        BL       _Z18print_heaterstatesv
        LDR.N    R0,??gcode_M109_1+0x28
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        CMP      R4,#+0
        BEQ.N    ??gcode_M109_16
        MOVW     R0,#+10000
        SUB      R0,R0,R8
        ADDS     R0,R4,R0
        MOV      R1,#+1000
        UDIV     R1,R0,R1
        LDRB     R0,[R9, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_M109_17
        MOVS     R2,#+10
        LDR.N    R0,??gcode_M109_1+0x2C
          CFI FunCall _ZN12MarlinSerial5printEli
        BL       _ZN12MarlinSerial5printEli
        B.N      ??gcode_M109_18
??gcode_M109_17:
        MOVS     R2,#+10
        LDR.N    R0,??gcode_M109_1+0x30
          CFI FunCall _ZN12MarlinSerial5printEli
        BL       _ZN12MarlinSerial5printEli
??gcode_M109_18:
        LDRB     R0,[R9, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_M109_19
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M109_1+0x2C
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??gcode_M109_15
??gcode_M109_19:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M109_1+0x30
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
        B.N      ??gcode_M109_15
??gcode_M109_16:
        LDR.N    R0,??gcode_M109_1+0x34
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_M109_15:
        MOVS     R0,#+0
          CFI FunCall _Z4idleb
        BL       _Z4idleb
          CFI FunCall _Z19refresh_cmd_timeoutv
        BL       _Z19refresh_cmd_timeoutv
        LDRB     R0,[R9, #+5]
          CFI FunCall _ZN11Temperature9degHotendEh
        BL       _ZN11Temperature9degHotendEh
        MOV      R11,R0
        MOV      R0,R7
        MOV      R1,R11
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        BIC      R0,R0,#0x80000000
        CMP      R4,#+0
        BNE.N    ??gcode_M109_20
        MOV      R1,#+1065353216
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_M109_21
        MOV      R4,R8
        B.N      ??gcode_M109_21
??gcode_M109_20:
        LDR.N    R1,??gcode_M109_1+0x38  ;; 0x40000001
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_M109_21
        MOV      R4,R8
??gcode_M109_21:
        CMP      R5,#+0
        BEQ.N    ??gcode_M109_22
        CMP      R6,#+0
        BEQ.N    ??gcode_M109_23
        SUBS     R0,R8,R6
        BMI.N    ??gcode_M109_22
??gcode_M109_23:
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,#+1069547520
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_M109_14
        ADD      R6,R8,#+59904
        ADDS     R6,R6,#+96
        MOV      R10,R11
??gcode_M109_22:
        LDRB     R0,[R9, #+3]
        CMP      R0,#+0
        BEQ.N    ??gcode_M109_14
        CMP      R4,#+0
        BEQ.W    ??gcode_M109_12
        SUB      R8,R8,R4
        LDR.N    R0,??gcode_M109_1+0x3C  ;; 0xffffd8f0
        ADDS     R8,R0,R8
        BMI.W    ??gcode_M109_12
??gcode_M109_14:
        MOV      R4,R9
        MOVS     R0,#+0
        STRB     R0,[R4, #+0]
        LDRB     R0,[R4, #+3]
        CMP      R0,#+0
        BEQ.N    ??gcode_M109_24
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M109_1+0x40
          CFI FunCall _Z16lcd_setstatuspgmPKch
        BL       _Z16lcd_setstatuspgmPKch
??gcode_M109_24:
        MOVS     R0,#+1
        STRB     R0,[R4, #+6]
??gcode_M109_2:
        POP      {R0-R2,R4-R11,PC}  ;; return
        DATA
??gcode_M109_1:
        DC32     mks_heating_busy
        DC32     mksCfg
        DC32     WELCOME_MSG
        DC32     MSG_HEATING
        DC32     _ZZ10gcode_M109vEs
        DC32     _ZZ10gcode_M109vEs_0
        DC32     _ZZ10gcode_M109vEs_1
        DC32     _ZZ10gcode_M109vEs_2
        DC32     0xbf800000
        DC32     0x461c3c00
        DC32     _ZZ10gcode_M109vEs_3
        DC32     customizedSerial
        DC32     serial2
        DC32     _ZZ10gcode_M109vEs_4
        DC32     0x40000001
        DC32     0xffffd8f0
        DC32     MSG_HEATING_COMPLETE
          CFI EndBlock cfiBlock268

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M190v
          CFI Block cfiBlock269 Using cfiCommon0
          CFI Function _Z10gcode_M190v
        THUMB
_Z10gcode_M190v:
        PUSH     {R1-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+48
        LDR.N    R5,??gcode_M190_0
        LDRB     R0,[R5, #+1]
        LSLS     R0,R0,#+28
        BMI.W    ??gcode_M190_1
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M190_0+0x4
          CFI FunCall _Z16lcd_setstatuspgmPKch
        BL       _Z16lcd_setstatuspgmPKch
        MOVS     R0,#+83
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        MOVS     R4,R0
        BNE.N    ??gcode_M190_2
        MOVS     R0,#+82
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.W    ??gcode_M190_1
??gcode_M190_2:
          CFI FunCall _Z19code_value_temp_absv
        BL       _Z19code_value_temp_absv
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
          CFI FunCall _ZN11Temperature12setTargetBedEf
        BL       _ZN11Temperature12setTargetBedEf
          CFI FunCall _Z19code_value_temp_absv
        BL       _Z19code_value_temp_absv
        CMN      R0,#+4
        BLT.N    ??gcode_M190_3
        ADD      R0,R5,#+904
          CFI FunCall _ZN9Stopwatch5startEv
        BL       _ZN9Stopwatch5startEv
??gcode_M190_3:
        MOVS     R0,#+0
        LDR.N    R7,??gcode_M190_0+0x8  ;; 0xbf800000
        LDR.W    R10,??gcode_M190_0+0xC  ;; 0x461c3c00
        MOV      R5,R0
        LDR.W    R9,??gcode_M190_0
        MOVS     R1,#+1
        STRB     R1,[R9, #+3]
        MOV      R1,R0
        MOV      R6,R0
        MOV      R2,R0
        STRB     R2,[R9, #+6]
        LDRB     R2,[R9, #+2]
        STRB     R2,[R9, #+5]
        MOVS     R2,#+1
        STRB     R2,[R9, #+0]
        STR      R4,[SP, #+4]
        MOV      R4,R0
        STR      R1,[SP, #+0]
??gcode_M190_4:
          CFI FunCall _ZN11Temperature12degTargetBedEv
        BL       _ZN11Temperature12degTargetBedEv
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??gcode_M190_5
          CFI FunCall _ZN11Temperature12isCoolingBedEv
        BL       _ZN11Temperature12isCoolingBedEv
        MOV      R5,R0
          CFI FunCall _ZN11Temperature12degTargetBedEv
        BL       _ZN11Temperature12degTargetBedEv
        MOV      R7,R0
        LDR      R0,[SP, #+4]
        CMP      R0,#+0
        BEQ.N    ??gcode_M190_5
        CMP      R5,#+0
        BNE.N    ??gcode_M190_6
??gcode_M190_5:
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        MOV      R8,R0
        LDR      R0,[SP, #+0]
        SUBS     R0,R8,R0
        BMI.N    ??gcode_M190_7
        ADD      R0,R8,#+1000
        STR      R0,[SP, #+0]
          CFI FunCall _Z18print_heaterstatesv
        BL       _Z18print_heaterstatesv
        LDR.N    R0,??gcode_M190_0+0x10
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        CMP      R4,#+0
        BEQ.N    ??gcode_M190_8
        MOVW     R0,#+10000
        SUB      R0,R0,R8
        ADDS     R0,R4,R0
        MOV      R1,#+1000
        UDIV     R1,R0,R1
        LDRB     R0,[R9, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_M190_9
        MOVS     R2,#+10
        LDR.N    R0,??gcode_M190_0+0x14
          CFI FunCall _ZN12MarlinSerial5printEli
        BL       _ZN12MarlinSerial5printEli
        B.N      ??gcode_M190_10
??gcode_M190_9:
        MOVS     R2,#+10
        LDR.N    R0,??gcode_M190_0+0x18
          CFI FunCall _ZN12MarlinSerial5printEli
        BL       _ZN12MarlinSerial5printEli
??gcode_M190_10:
        LDRB     R0,[R9, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_M190_11
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M190_0+0x14
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??gcode_M190_7
??gcode_M190_11:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M190_0+0x18
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
        B.N      ??gcode_M190_7
??gcode_M190_8:
        LDR.N    R0,??gcode_M190_0+0x1C
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_M190_7:
        MOVS     R0,#+0
          CFI FunCall _Z4idleb
        BL       _Z4idleb
          CFI FunCall _Z19refresh_cmd_timeoutv
        BL       _Z19refresh_cmd_timeoutv
          CFI FunCall _ZN11Temperature6degBedEv
        BL       _ZN11Temperature6degBedEv
        MOV      R11,R0
        MOV      R0,R7
        MOV      R1,R11
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        BIC      R0,R0,#0x80000000
        CMP      R4,#+0
        BNE.N    ??gcode_M190_12
        MOV      R1,#+1065353216
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_M190_13
        MOV      R4,R8
        B.N      ??gcode_M190_13
??gcode_M190_12:
        LDR.N    R1,??gcode_M190_0+0x20  ;; 0x40000001
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_M190_13
        MOV      R4,R8
??gcode_M190_13:
        CMP      R5,#+0
        BEQ.N    ??gcode_M190_14
        CMP      R6,#+0
        BEQ.N    ??gcode_M190_15
        SUBS     R0,R8,R6
        BMI.N    ??gcode_M190_14
??gcode_M190_15:
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,#+1069547520
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_M190_6
        ADD      R6,R8,#+59904
        ADDS     R6,R6,#+96
        MOV      R10,R11
??gcode_M190_14:
        LDRB     R0,[R9, #+3]
        CMP      R0,#+0
        BEQ.N    ??gcode_M190_6
        CMP      R4,#+0
        BEQ.W    ??gcode_M190_4
        SUB      R8,R8,R4
        LDR.N    R0,??gcode_M190_0+0x24  ;; 0xffffd8f0
        ADDS     R8,R0,R8
        BMI.W    ??gcode_M190_4
??gcode_M190_6:
        MOV      R4,R9
        MOVS     R0,#+0
        STRB     R0,[R4, #+0]
        LDRB     R0,[R4, #+3]
        CMP      R0,#+0
        BEQ.N    ??gcode_M190_16
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M190_0+0x28
          CFI FunCall _Z16lcd_setstatuspgmPKch
        BL       _Z16lcd_setstatuspgmPKch
??gcode_M190_16:
        MOVS     R0,#+1
        STRB     R0,[R4, #+6]
??gcode_M190_1:
        POP      {R0-R2,R4-R11,PC}  ;; return
        Nop      
        DATA
??gcode_M190_0:
        DC32     mks_heating_busy
        DC32     MSG_BED_HEATING
        DC32     0xbf800000
        DC32     0x461c3c00
        DC32     _ZZ10gcode_M190vEs
        DC32     customizedSerial
        DC32     serial2
        DC32     _ZZ10gcode_M190vEs_0
        DC32     0x40000001
        DC32     0xffffd8f0
        DC32     MSG_BED_DONE
          CFI EndBlock cfiBlock269

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M110v
          CFI Block cfiBlock270 Using cfiCommon0
          CFI Function _Z10gcode_M110v
        THUMB
_Z10gcode_M110v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+78
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M110_1
          CFI FunCall _Z15code_value_longv
        BL       _Z15code_value_longv
        LDR.N    R1,??gcode_M110_0
        STR      R0,[R1, #+32]
??gcode_M110_1:
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??gcode_M110_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock270

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M111v
          CFI Block cfiBlock271 Using cfiCommon0
          CFI Function _Z10gcode_M111v
        THUMB
_Z10gcode_M111v:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        LDR.N    R4,??gcode_M111_0
        MOVS     R0,#+83
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M111_1
          CFI FunCall _Z15code_value_bytev
        BL       _Z15code_value_bytev
        STRB     R0,[R4, #+1]
        B.N      ??gcode_M111_2
??gcode_M111_1:
        MOVS     R0,#+0
        STRB     R0,[R4, #+1]
??gcode_M111_2:
        LDR.N    R0,??gcode_M111_0+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M111_0+0x8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDRB     R0,[R4, #+1]
        CMP      R0,#+0
        BEQ.N    ??gcode_M111_3
        MOVS     R5,#+0
        MOV      R6,R5
??gcode_M111_4:
        CMP      R6,#+5
        BCS.N    ??gcode_M111_5
        LDRB     R0,[R4, #+1]
        MOVS     R1,#+1
        LSLS     R1,R1,R6
        TST      R0,R1
        BEQ.N    ??gcode_M111_6
        MOV      R0,R5
        ADDS     R5,R0,#+1
        UXTB     R0,R0
        CMP      R0,#+0
        BEQ.N    ??gcode_M111_7
        LDRB     R0,[R4, #+7]
        CMP      R0,#+0
        BEQ.N    ??gcode_M111_8
        MOVS     R2,#+0
        MOVS     R1,#+44
        LDR.N    R0,??gcode_M111_0+0xC
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
        B.N      ??gcode_M111_7
??gcode_M111_8:
        MOVS     R1,#+44
        LDR.N    R0,??gcode_M111_0+0x10
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
??gcode_M111_7:
        LDR.N    R0,??gcode_M111_0+0x14
        ADD      R0,R0,R6, LSL #+2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_M111_6:
        ADDS     R6,R6,#+1
        B.N      ??gcode_M111_4
??gcode_M111_3:
        LDR.N    R0,??gcode_M111_0+0x18
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_M111_5:
        LDRB     R0,[R4, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_M111_9
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M111_0+0x10
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN12MarlinSerial5writeEh
        B.W      _ZN12MarlinSerial5writeEh
          CFI R4 Frame(CFA, -16)
          CFI R5 Frame(CFA, -12)
          CFI R6 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??gcode_M111_9:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M111_0+0xC
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN12MarlinSerial5printEci
        B.W      _ZN12MarlinSerial5printEci
        Nop      
        DATA
??gcode_M111_0:
        DC32     mks_heating_busy
        DC32     echomagic
        DC32     _ZZ10gcode_M111vEs_4
        DC32     serial2
        DC32     customizedSerial
        DC32     _ZZ10gcode_M111vE13debug_strings
        DC32     _ZZ10gcode_M111vEs_5
          CFI EndBlock cfiBlock271

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M113v
          CFI Block cfiBlock272 Using cfiCommon0
          CFI Function _Z10gcode_M113v
        THUMB
_Z10gcode_M113v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R4,??gcode_M113_0
        MOVS     R0,#+83
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M113_1
          CFI FunCall _Z15code_value_bytev
        BL       _Z15code_value_bytev
        STRB     R0,[R4, #+0]
        CMP      R0,#+61
        BLT.N    ??gcode_M113_2
        MOVS     R0,#+60
        STRB     R0,[R4, #+0]
        POP      {R4,PC}
??gcode_M113_1:
        LDR.N    R0,??gcode_M113_0+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDRB     R1,[R4, #+0]
        LDR.N    R0,??gcode_M113_0+0x8
          CFI FunCall _Z17serial_echopair_PPKcm
        BL       _Z17serial_echopair_PPKcm
        LDR.N    R0,??gcode_M113_0+0xC
        LDRB     R0,[R0, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_M113_3
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M113_0+0x10
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN12MarlinSerial5writeEh
        B.W      _ZN12MarlinSerial5writeEh
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M113_3:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M113_0+0x14
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN12MarlinSerial5printEci
        B.W      _ZN12MarlinSerial5printEci
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M113_2:
        POP      {R4,PC}          ;; return
        DATA
??gcode_M113_0:
        DC32     host_keepalive_interval
        DC32     echomagic
        DC32     _ZZ10gcode_M113vEs
        DC32     mks_heating_busy
        DC32     customizedSerial
        DC32     serial2
          CFI EndBlock cfiBlock272

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M140v
          CFI Block cfiBlock273 Using cfiCommon0
          CFI Function _Z10gcode_M140v
        THUMB
_Z10gcode_M140v:
        LDR.N    R0,??gcode_M140_0
        LDRB     R0,[R0, #+1]
        LSLS     R0,R0,#+28
        BPL.N    ??gcode_M140_1
        BX       LR
??gcode_M140_1:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M140_2
          CFI FunCall _Z19code_value_temp_absv
        BL       _Z19code_value_temp_absv
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN11Temperature12setTargetBedEf
        B.W      _ZN11Temperature12setTargetBedEf
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M140_2:
        POP      {R0,PC}          ;; return
        DATA
??gcode_M140_0:
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock273

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M145v
          CFI Block cfiBlock274 Using cfiCommon0
          CFI Function _Z10gcode_M145v
        THUMB
_Z10gcode_M145v:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOVS     R0,#+83
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M145_1
          CFI FunCall _Z14code_value_intv
        BL       _Z14code_value_intv
        MOV      R4,R0
        UXTB     R4,R4
        B.N      ??gcode_M145_2
??gcode_M145_1:
        MOVS     R4,#+0
??gcode_M145_2:
        CMP      R4,#+2
        BCC.N    ??gcode_M145_3
        LDR.N    R0,??gcode_M145_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M145_0+0x4
        POP      {R1,R4-R7,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI R4 Frame(CFA, -20)
          CFI R5 Frame(CFA, -16)
          CFI R6 Frame(CFA, -12)
          CFI R7 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+24
??gcode_M145_3:
        MOVS     R0,#+72
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M145_4
          CFI FunCall _Z14code_value_intv
        BL       _Z14code_value_intv
        MOV      R5,R0
        LDR.N    R6,??gcode_M145_0+0x8
        LDR      R7,[R6, #+44]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R7
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_M145_5
        MOV      R0,R7
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        B.N      ??gcode_M145_6
??gcode_M145_5:
        MOV      R0,R6
        LDRSH    R0,[R0, #+48]
        SUBS     R0,R0,#+15
        CMP      R0,R5
        BLE.N    ??gcode_M145_6
        MOV      R0,R5
??gcode_M145_6:
        LDR.N    R1,??gcode_M145_0+0xC
        STR      R0,[R1, R4, LSL #+2]
??gcode_M145_4:
        MOVS     R0,#+70
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M145_7
          CFI FunCall _Z14code_value_intv
        BL       _Z14code_value_intv
        USAT     R0,#+8,R0
        LDR.N    R1,??gcode_M145_0+0x10
        STR      R0,[R1, R4, LSL #+2]
??gcode_M145_7:
        MOVS     R0,#+66
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M145_8
          CFI FunCall _Z14code_value_intv
        BL       _Z14code_value_intv
        MVN      R1,#+4
        CMP      R0,R1
        BLT.N    ??gcode_M145_9
        LDR.N    R1,??gcode_M145_0+0x8
        LDRSH    R1,[R1, #+50]
        SUBS     R1,R1,#+15
        CMP      R1,R0
        BLE.N    ??gcode_M145_9
        MOV      R1,R0
??gcode_M145_9:
        LDR.N    R0,??gcode_M145_0+0x14
        STR      R1,[R0, R4, LSL #+2]
??gcode_M145_8:
        POP      {R0,R4-R7,PC}    ;; return
        DATA
??gcode_M145_0:
        DC32     errormagic
        DC32     _ZZ10gcode_M145vEs
        DC32     mksCfg
        DC32     lcd_preheat_hotend_temp
        DC32     lcd_preheat_fan_speed
        DC32     lcd_preheat_bed_temp
          CFI EndBlock cfiBlock274

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M81v
          CFI Block cfiBlock275 Using cfiCommon0
          CFI Function _Z9gcode_M81v
        THUMB
_Z9gcode_M81v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
          CFI FunCall _ZN7Stepper18finish_and_disableEv
        BL       _ZN7Stepper18finish_and_disableEv
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M81_0
        B.N      ??gcode_M81_1
??gcode_M81_2:
        MOVS     R0,#+0
        STR      R0,[R1, #+0]
        MOVS     R0,#+1
??gcode_M81_1:
        CMP      R0,#+0
        BEQ.N    ??gcode_M81_2
        MOV      R0,#+1000
          CFI FunCall _Z10safe_delaym
        BL       _Z10safe_delaym
        LDR.N    R0,??gcode_M81_0+0x4
        LDRB     R0,[R0, #+62]
        CMP      R0,#+0
        BEQ.N    ??gcode_M81_3
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M81_0+0x8
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z16lcd_setstatuspgmPKch
        B.W      _Z16lcd_setstatuspgmPKch
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M81_3:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M81_0+0xC
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z16lcd_setstatuspgmPKch
        B.W      _Z16lcd_setstatuspgmPKch
        DATA
??gcode_M81_0:
        DC32     fanSpeeds
        DC32     mksCfg
        DC32     _ZZ9gcode_M81vEs
        DC32     _ZZ9gcode_M81vEs_0
          CFI EndBlock cfiBlock275

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M82v
          CFI Block cfiBlock276 Using cfiCommon0
          CFI Function _Z9gcode_M82v
          CFI NoCalls
        THUMB
_Z9gcode_M82v:
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M82_0
        STRB     R0,[R1, #+3]
        BX       LR               ;; return
        DATA
??gcode_M82_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock276

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M83v
          CFI Block cfiBlock277 Using cfiCommon0
          CFI Function _Z9gcode_M83v
          CFI NoCalls
        THUMB
_Z9gcode_M83v:
        MOVS     R0,#+1
        LDR.N    R1,??gcode_M83_0
        STRB     R0,[R1, #+3]
        BX       LR               ;; return
        DATA
??gcode_M83_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock277

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z13gcode_M18_M84v
          CFI Block cfiBlock278 Using cfiCommon0
          CFI Function _Z13gcode_M18_M84v
        THUMB
_Z13gcode_M18_M84v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M18_M84_1
          CFI FunCall _Z30code_value_millis_from_secondsv
        BL       _Z30code_value_millis_from_secondsv
        LDR.N    R1,??gcode_M18_M84_0
        STR      R0,[R1, #+64]
        POP      {R0,PC}
??gcode_M18_M84_1:
        MOVS     R0,#+88
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BNE.N    ??gcode_M18_M84_2
        MOVS     R0,#+89
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BNE.N    ??gcode_M18_M84_2
        MOVS     R0,#+90
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BNE.N    ??gcode_M18_M84_2
        MOVS     R0,#+69
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        LSRS     R0,R0,#+31
        B.N      ??gcode_M18_M84_3
??gcode_M18_M84_2:
        MOVS     R0,#+0
??gcode_M18_M84_3:
        CMP      R0,#+0
        BEQ.N    ??gcode_M18_M84_4
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Stepper18finish_and_disableEv
        B.W      _ZN7Stepper18finish_and_disableEv
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M18_M84_4:
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        MOVS     R0,#+88
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M18_M84_5
        MOVS     R2,#+1
        LDR.N    R0,??gcode_M18_M84_0+0x4
        LDRH     R1,[R0, #+28]
        LDR.N    R0,??gcode_M18_M84_0+0x8
        LDR      R0,[R0, #+56]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M18_M84_0
        STRB     R0,[R1, #+4]
??gcode_M18_M84_5:
        MOVS     R0,#+89
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M18_M84_6
        MOVS     R2,#+1
        LDR.N    R0,??gcode_M18_M84_0+0x4
        LDRH     R1,[R0, #+28]
        LDR.N    R0,??gcode_M18_M84_0+0x8
        LDR      R0,[R0, #+56]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M18_M84_0
        STRB     R0,[R1, #+5]
??gcode_M18_M84_6:
        MOVS     R0,#+90
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M18_M84_7
        MOVS     R2,#+1
        LDR.N    R0,??gcode_M18_M84_0+0x4
        LDRH     R1,[R0, #+28]
        LDR.N    R0,??gcode_M18_M84_0+0x8
        LDR      R0,[R0, #+56]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M18_M84_0
        STRB     R0,[R1, #+6]
??gcode_M18_M84_7:
        MOVS     R0,#+69
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M18_M84_8
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z18disable_e_steppersv
        B.W      _Z18disable_e_steppersv
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M18_M84_8:
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??gcode_M18_M84_0:
        DC32     axis_relative_modes
        DC32     gArrayGpioPin
        DC32     gArrayGpioPort
          CFI EndBlock cfiBlock278

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M85v
          CFI Block cfiBlock279 Using cfiCommon0
          CFI Function _Z9gcode_M85v
        THUMB
_Z9gcode_M85v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M85_1
          CFI FunCall _Z30code_value_millis_from_secondsv
        BL       _Z30code_value_millis_from_secondsv
        LDR.N    R1,??gcode_M85_0
        STR      R0,[R1, #+60]
??gcode_M85_1:
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??gcode_M85_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock279

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M92v
          CFI Block cfiBlock280 Using cfiCommon0
          CFI Function _Z9gcode_M92v
        THUMB
_Z9gcode_M92v:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        MOVS     R4,#+0
        LDR.N    R5,??gcode_M92_0
??gcode_M92_1:
        CMP      R4,#+3
        BGT.N    ??gcode_M92_2
        LDR.N    R0,??gcode_M92_0+0x4
        LDRSB    R0,[R0, R4]
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M92_3
        CMP      R4,#+3
        BEQ.N    ??gcode_M92_4
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        STR      R0,[R5, R4, LSL #+2]
        B.N      ??gcode_M92_3
??gcode_M92_4:
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        MOV      R6,R0
        LDR.N    R1,??gcode_M92_0+0x8  ;; 0x41a00000
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_M92_5
        LDR      R0,[R5, #+12]
        MOV      R1,R6
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R7,R0
        LDR.W    R8,??gcode_M92_0+0xC
        LDR      R0,[R8, #+12]
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[R8, #+12]
        LDR.W    R8,??gcode_M92_0+0x10
        LDR      R0,[R8, #+12]
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[R8, #+12]
        LDR.W    R8,??gcode_M92_0+0x14
        LDR      R0,[R8, #+12]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2uiz
        BL       __aeabi_f2uiz
        STR      R0,[R8, #+12]
??gcode_M92_5:
        STR      R6,[R5, #+12]
??gcode_M92_3:
        ADDS     R4,R4,#+1
        B.N      ??gcode_M92_1
??gcode_M92_2:
        POP      {R4-R8,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Planner19refresh_positioningEv
        B.W      _ZN7Planner19refresh_positioningEv
        Nop      
        DATA
??gcode_M92_0:
        DC32     _ZN7Planner17axis_steps_per_mmE
        DC32     axis_codes
        DC32     0x41a00000
        DC32     _ZN7Planner8max_jerkE
        DC32     _ZN7Planner17max_feedrate_mm_sE
        DC32     _ZN7Planner29max_acceleration_steps_per_s2E
          CFI EndBlock cfiBlock280

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M114v
          CFI Block cfiBlock281 Using cfiCommon0
          CFI Function _Z10gcode_M114v
        THUMB
_Z10gcode_M114v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531923report_current_positionEv
        B.W      _ZN37_INTERNAL_15_Marlin_main_cpp_3178531923report_current_positionEv
          CFI EndBlock cfiBlock281

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M115v
          CFI Block cfiBlock282 Using cfiCommon0
          CFI Function _Z10gcode_M115v
        THUMB
_Z10gcode_M115v:
        LDR.N    R0,??gcode_M115_0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
        Nop      
        DATA
??gcode_M115_0:
        DC32     _ZZ10gcode_M115vEs
          CFI EndBlock cfiBlock282

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M117v
          CFI Block cfiBlock283 Using cfiCommon0
          CFI Function _Z10gcode_M117v
        THUMB
_Z10gcode_M117v:
        LDR.N    R0,??gcode_M117_0
        LDRB     R0,[R0, #+2]
        CMP      R0,#+0
        BEQ.N    ??gcode_M117_1
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M117_0+0x4
          CFI FunCall _Z13lcd_setstatusPKcb
        B.W      _Z13lcd_setstatusPKcb
??gcode_M117_1:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M117_0+0x8
        LDR      R0,[R0, #+40]
          CFI FunCall _Z13lcd_setstatusPKcb
        B.W      _Z13lcd_setstatusPKcb
        Nop      
        DATA
??gcode_M117_0:
        DC32     card
        DC32     MSG_MKSPRINTINTING
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock283

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M119v
          CFI Block cfiBlock284 Using cfiCommon0
          CFI Function _Z10gcode_M119v
          CFI FunCall _ZN8Endstops4M119Ev
        THUMB
_Z10gcode_M119v:
        B.W      _ZN8Endstops4M119Ev
          CFI EndBlock cfiBlock284

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M120v
          CFI Block cfiBlock285 Using cfiCommon0
          CFI Function _Z10gcode_M120v
        THUMB
_Z10gcode_M120v:
        MOVS     R0,#+1
          CFI FunCall _ZN8Endstops15enable_globallyEb
        B.W      _ZN8Endstops15enable_globallyEb
          CFI EndBlock cfiBlock285

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M121v
          CFI Block cfiBlock286 Using cfiCommon0
          CFI Function _Z10gcode_M121v
        THUMB
_Z10gcode_M121v:
        MOVS     R0,#+0
          CFI FunCall _ZN8Endstops15enable_globallyEb
        B.W      _ZN8Endstops15enable_globallyEb
          CFI EndBlock cfiBlock286

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M200v
          CFI Block cfiBlock287 Using cfiCommon0
          CFI Function _Z10gcode_M200v
        THUMB
_Z10gcode_M200v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R0,#+200
          CFI FunCall _Z32get_target_extruder_from_commandi
        BL       _Z32get_target_extruder_from_commandi
        CMP      R0,#+0
        BNE.N    ??gcode_M200_1
        MOVS     R0,#+68
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M200_2
        LDR.N    R4,??gcode_M200_0
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??gcode_M200_3
        MOVS     R0,#+1
        STRB     R0,[R4, #+0]
        B.N      ??gcode_M200_4
??gcode_M200_3:
        MOV      R0,R1
        STRB     R0,[R4, #+0]
??gcode_M200_4:
        LDRB     R0,[R4, #+0]
        CMP      R0,#+0
        BEQ.N    ??gcode_M200_2
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        ADDS     R1,R4,#+4
        LDR.N    R2,??gcode_M200_0+0x4
        LDRB     R2,[R2, #+5]
        STR      R0,[R1, R2, LSL #+2]
        MOVS     R0,#+0
        MOV      R1,R0
        B.N      ??gcode_M200_5
??gcode_M200_6:
        LDR      R0,[R4, #+4]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??gcode_M200_7
        LDR.N    R0,??gcode_M200_0+0x8  ;; 0x40400000
        STR      R0,[R4, #+4]
??gcode_M200_7:
        MOVS     R0,#+1
??gcode_M200_5:
        CMP      R0,#+0
        BEQ.N    ??gcode_M200_6
??gcode_M200_2:
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z32calculate_volumetric_multipliersv
        B.W      _Z32calculate_volumetric_multipliersv
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M200_1:
        POP      {R4,PC}          ;; return
        DATA
??gcode_M200_0:
        DC32     volumetric_enabled
        DC32     mks_heating_busy
        DC32     0x40400000
          CFI EndBlock cfiBlock287

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M201v
          CFI Block cfiBlock288 Using cfiCommon0
          CFI Function _Z10gcode_M201v
        THUMB
_Z10gcode_M201v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R4,#+0
        B.N      ??gcode_M201_1
??gcode_M201_2:
        LDR.N    R0,??gcode_M201_0
        LDRSB    R0,[R0, R4]
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M201_3
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
          CFI FunCall __aeabi_f2uiz
        BL       __aeabi_f2uiz
        LDR.N    R1,??gcode_M201_0+0x4
        MOV      R2,R4
        STR      R0,[R1, R2, LSL #+2]
??gcode_M201_3:
        ADDS     R4,R4,#+1
??gcode_M201_1:
        CMP      R4,#+4
        BLT.N    ??gcode_M201_2
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Planner24reset_acceleration_ratesEv
        B.W      _ZN7Planner24reset_acceleration_ratesEv
        DATA
??gcode_M201_0:
        DC32     axis_codes
        DC32     _ZN7Planner26max_acceleration_mm_per_s2E
          CFI EndBlock cfiBlock288

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M203v
          CFI Block cfiBlock289 Using cfiCommon0
          CFI Function _Z10gcode_M203v
        THUMB
_Z10gcode_M203v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R4,#+0
        B.N      ??gcode_M203_1
??gcode_M203_2:
        LDR.N    R0,??gcode_M203_0
        LDRSB    R0,[R0, R4]
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M203_3
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        LDR.N    R1,??gcode_M203_0+0x4
        MOV      R2,R4
        STR      R0,[R1, R2, LSL #+2]
??gcode_M203_3:
        ADDS     R4,R4,#+1
??gcode_M203_1:
        CMP      R4,#+4
        BLT.N    ??gcode_M203_2
        POP      {R4,PC}          ;; return
        Nop      
        DATA
??gcode_M203_0:
        DC32     axis_codes
        DC32     _ZN7Planner17max_feedrate_mm_sE
          CFI EndBlock cfiBlock289

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M204v
          CFI Block cfiBlock290 Using cfiCommon0
          CFI Function _Z10gcode_M204v
        THUMB
_Z10gcode_M204v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M204_1
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        LDR.N    R1,??gcode_M204_0
        STR      R0,[R1, #+0]
        LDR.N    R1,??gcode_M204_0+0x4
        STR      R0,[R1, #+0]
        MOV      R1,R0
        LDR.N    R0,??gcode_M204_0+0x8
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR.N    R0,??gcode_M204_0+0xC
        LDRB     R0,[R0, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_M204_2
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M204_0+0x10
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??gcode_M204_1
??gcode_M204_2:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M204_0+0x14
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
??gcode_M204_1:
        MOVS     R0,#+80
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M204_3
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        LDR.N    R1,??gcode_M204_0
        STR      R0,[R1, #+0]
        MOV      R1,R0
        LDR.N    R0,??gcode_M204_0+0x18
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR.N    R0,??gcode_M204_0+0xC
        LDRB     R0,[R0, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_M204_4
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M204_0+0x10
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??gcode_M204_3
??gcode_M204_4:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M204_0+0x14
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
??gcode_M204_3:
        MOVS     R0,#+82
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M204_5
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        LDR.N    R1,??gcode_M204_0+0x1C
        STR      R0,[R1, #+0]
        MOV      R1,R0
        LDR.N    R0,??gcode_M204_0+0x20
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR.N    R0,??gcode_M204_0+0xC
        LDRB     R0,[R0, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_M204_6
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M204_0+0x10
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??gcode_M204_5
??gcode_M204_6:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M204_0+0x14
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
??gcode_M204_5:
        MOVS     R0,#+84
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M204_7
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        LDR.N    R1,??gcode_M204_0+0x4
        STR      R0,[R1, #+0]
        MOV      R1,R0
        LDR.N    R0,??gcode_M204_0+0x24
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR.N    R0,??gcode_M204_0+0xC
        LDRB     R0,[R0, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_M204_8
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M204_0+0x10
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN12MarlinSerial5writeEh
        B.W      _ZN12MarlinSerial5writeEh
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M204_8:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M204_0+0x14
        POP      {R3,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN12MarlinSerial5printEci
        B.W      _ZN12MarlinSerial5printEci
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M204_7:
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??gcode_M204_0:
        DC32     _ZN7Planner12accelerationE
        DC32     _ZN7Planner19travel_accelerationE
        DC32     _ZZ10gcode_M204vEs
        DC32     mks_heating_busy
        DC32     customizedSerial
        DC32     serial2
        DC32     _ZZ10gcode_M204vEs_0
        DC32     _ZN7Planner20retract_accelerationE
        DC32     _ZZ10gcode_M204vEs_1
        DC32     _ZZ10gcode_M204vEs_2
          CFI EndBlock cfiBlock290

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M205v
          CFI Block cfiBlock291 Using cfiCommon0
          CFI Function _Z10gcode_M205v
        THUMB
_Z10gcode_M205v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M205_1
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        LDR.N    R1,??gcode_M205_0
        STR      R0,[R1, #+0]
??gcode_M205_1:
        MOVS     R0,#+84
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M205_2
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        LDR.N    R1,??gcode_M205_0+0x4
        STR      R0,[R1, #+0]
??gcode_M205_2:
        MOVS     R0,#+66
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M205_3
          CFI FunCall _Z17code_value_millisv
        BL       _Z17code_value_millisv
        LDR.N    R1,??gcode_M205_0+0x8
        STR      R0,[R1, #+0]
??gcode_M205_3:
        MOVS     R0,#+88
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M205_4
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        LDR.N    R1,??gcode_M205_0+0xC
        STR      R0,[R1, #+0]
??gcode_M205_4:
        MOVS     R0,#+89
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M205_5
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        LDR.N    R1,??gcode_M205_0+0xC
        STR      R0,[R1, #+4]
??gcode_M205_5:
        MOVS     R0,#+90
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M205_6
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        LDR.N    R1,??gcode_M205_0+0xC
        STR      R0,[R1, #+8]
??gcode_M205_6:
        MOVS     R0,#+69
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M205_7
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        LDR.N    R1,??gcode_M205_0+0xC
        STR      R0,[R1, #+12]
??gcode_M205_7:
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??gcode_M205_0:
        DC32     _ZN7Planner17min_feedrate_mm_sE
        DC32     _ZN7Planner24min_travel_feedrate_mm_sE
        DC32     _ZN7Planner16min_segment_timeE
        DC32     _ZN7Planner8max_jerkE
          CFI EndBlock cfiBlock291

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M206v
          CFI Block cfiBlock292 Using cfiCommon0
          CFI Function _Z10gcode_M206v
        THUMB
_Z10gcode_M206v:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.N    R4,??gcode_M206_0
        LDRSH    R0,[R4, #+88]
        CMP      R0,#+2
        BEQ.N    ??gcode_M206_1
        MOVS     R5,#+0
        B.N      ??gcode_M206_2
??gcode_M206_3:
        LDR.N    R0,??gcode_M206_0+0x4
        LDRSB    R0,[R0, R5]
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M206_4
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        MOV      R1,R0
        MOV      R0,R5
        SXTB     R0,R0
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531915set_home_offsetE8AxisEnumf
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531915set_home_offsetE8AxisEnumf
??gcode_M206_4:
        ADDS     R5,R5,#+1
??gcode_M206_2:
        CMP      R5,#+3
        BLT.N    ??gcode_M206_3
        LDRSH    R0,[R4, #+88]
        CMP      R0,#+256
        BNE.N    ??gcode_M206_5
        MOVS     R0,#+84
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M206_6
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        MOV      R1,R0
        MOVS     R0,#+0
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531915set_home_offsetE8AxisEnumf
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531915set_home_offsetE8AxisEnumf
??gcode_M206_6:
        MOVS     R0,#+80
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M206_5
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        MOV      R1,R0
        MOVS     R0,#+1
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531915set_home_offsetE8AxisEnumf
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531915set_home_offsetE8AxisEnumf
??gcode_M206_5:
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531923report_current_positionEv
        B.W      _ZN37_INTERNAL_15_Marlin_main_cpp_3178531923report_current_positionEv
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??gcode_M206_1:
        POP      {R0,R4,R5,PC}    ;; return
        DATA
??gcode_M206_0:
        DC32     mksCfg
        DC32     axis_codes
          CFI EndBlock cfiBlock292

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M665v
          CFI Block cfiBlock293 Using cfiCommon0
          CFI Function _Z10gcode_M665v
        THUMB
_Z10gcode_M665v:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R0,#+72
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M665_1
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        LDR.N    R4,??gcode_M665_0
        LDR.N    R5,??gcode_M665_0+0x4
        LDR      R1,[R5, #+80]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+64]
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        LDR      R1,[R5, #+80]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[R4, #+64]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[R4, #+16]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+16]
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        LDR      R1,[R5, #+80]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+64]
        MOVS     R0,#+2
          CFI FunCall _Z24update_software_endstops8AxisEnum
        BL       _Z24update_software_endstops8AxisEnum
??gcode_M665_1:
        LDR.N    R4,??gcode_M665_0+0x8
        MOVS     R0,#+76
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M665_2
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        STR      R0,[R4, #+80]
??gcode_M665_2:
        MOVS     R0,#+82
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M665_3
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        STR      R0,[R4, #+76]
??gcode_M665_3:
        MOVS     R0,#+83
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M665_4
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        STR      R0,[R4, #+88]
??gcode_M665_4:
        MOVS     R0,#+66
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M665_5
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        STR      R0,[R4, #+84]
??gcode_M665_5:
        MOVS     R0,#+88
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M665_6
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        STR      R0,[R4, #+52]
??gcode_M665_6:
        MOVS     R0,#+89
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M665_7
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        STR      R0,[R4, #+56]
??gcode_M665_7:
        MOVS     R0,#+90
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M665_8
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        MOV      R1,R0
        LDR      R0,[R4, #+52]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+52]
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        MOV      R1,R0
        LDR      R0,[R4, #+56]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+56]
??gcode_M665_8:
        LDR      R1,[R4, #+80]
        LDR      R0,[R4, #+76]
        POP      {R2,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z21recalc_delta_settingsff
        B.W      _Z21recalc_delta_settingsff
        Nop      
        DATA
??gcode_M665_0:
        DC32     mks_heating_busy
        DC32     mksCfg
        DC32     axis_homed
          CFI EndBlock cfiBlock293

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M666v
          CFI Block cfiBlock294 Using cfiCommon0
          CFI Function _Z10gcode_M666v
        THUMB
_Z10gcode_M666v:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOVS     R4,#+0
        LDR.N    R5,??gcode_M666_0
        B.N      ??gcode_M666_1
??gcode_M666_2:
        LDR.N    R0,??gcode_M666_0+0x4
        LDRSB    R0,[R0, R4]
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M666_3
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        STR      R0,[R5, R4, LSL #+2]
??gcode_M666_3:
        ADDS     R4,R4,#+1
??gcode_M666_1:
        CMP      R4,#+3
        BLT.N    ??gcode_M666_2
        LDR      R4,[R5, #+4]
        LDR      R2,[R5, #+0]
        MOV      R0,R4
        MOV      R1,R2
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_M666_4
        MOV      R1,R4
??gcode_M666_4:
        LDR      R0,[R5, #+8]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_M666_5
        MOV      R0,R4
        MOV      R1,R2
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_M666_6
        MOV      R4,R2
        B.N      ??gcode_M666_6
??gcode_M666_5:
        MOV      R4,R0
??gcode_M666_6:
        LDR.N    R6,??gcode_M666_0+0x8
        LDR      R0,[R6, #+64]
        MOV      R1,R4
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R6, #+64]
        MOVS     R6,#+0
        B.N      ??gcode_M666_7
??gcode_M666_8:
        LDR      R0,[R5, R6, LSL #+2]
        MOV      R1,R4
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R5, R6, LSL #+2]
        ADDS     R6,R6,#+1
??gcode_M666_7:
        CMP      R6,#+3
        BLT.N    ??gcode_M666_8
        POP      {R4-R6,PC}       ;; return
        DATA
??gcode_M666_0:
        DC32     endstop_adj
        DC32     axis_codes
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock294

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M211v
          CFI Block cfiBlock295 Using cfiCommon0
          CFI Function _Z10gcode_M211v
        THUMB
_Z10gcode_M211v:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        LDR.N    R0,??gcode_M211_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R4,??gcode_M211_0+0x4
        MOVS     R0,#+83
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M211_1
          CFI FunCall _Z15code_value_boolv
        BL       _Z15code_value_boolv
        STRB     R0,[R4, #+0]
??gcode_M211_1:
        LDR.N    R0,??gcode_M211_0+0x8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDRB     R0,[R4, #+0]
        CMP      R0,#+0
        BEQ.N    ??gcode_M211_2
        LDR.N    R0,??gcode_M211_0+0xC
        B.N      ??gcode_M211_3
??gcode_M211_2:
        LDR.N    R0,??gcode_M211_0+0x10
??gcode_M211_3:
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M211_0+0x14
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R4,??gcode_M211_0+0x18
        LDR.N    R5,??gcode_M211_0+0x1C
        LDR      R1,[R5, #+80]
        MOV      R0,R4
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR.N    R6,??gcode_M211_0+0x20
        LDR      R1,[R5, #+84]
        MOV      R0,R6
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR.N    R7,??gcode_M211_0+0x24
        LDR      R1,[R5, #+88]
        MOV      R0,R7
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR.N    R0,??gcode_M211_0+0x28
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR      R1,[R5, #+92]
        MOV      R0,R4
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR      R1,[R5, #+96]
        MOV      R0,R6
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR      R1,[R5, #+100]
        MOV      R0,R7
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDRB     R0,[R5, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_M211_4
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M211_0+0x2C
        POP      {R2,R4-R7,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN12MarlinSerial5writeEh
        B.W      _ZN12MarlinSerial5writeEh
          CFI R4 Frame(CFA, -20)
          CFI R5 Frame(CFA, -16)
          CFI R6 Frame(CFA, -12)
          CFI R7 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+24
??gcode_M211_4:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M211_0+0x30
        POP      {R3-R7,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN12MarlinSerial5printEci
        B.W      _ZN12MarlinSerial5printEci
        DATA
??gcode_M211_0:
        DC32     echomagic
        DC32     soft_endstops_enabled
        DC32     _ZZ10gcode_M211vEs
        DC32     MSG_ON
        DC32     MSG_OFF
        DC32     _ZZ10gcode_M211vEs_0
        DC32     _ZZ10gcode_M211vEs_1
        DC32     mks_heating_busy
        DC32     _ZZ10gcode_M211vEs_2
        DC32     _ZZ10gcode_M211vEs_3
        DC32     _ZZ10gcode_M211vEs_4
        DC32     customizedSerial
        DC32     serial2
          CFI EndBlock cfiBlock295

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M220v
          CFI Block cfiBlock296 Using cfiCommon0
          CFI Function _Z10gcode_M220v
        THUMB
_Z10gcode_M220v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M220_1
          CFI FunCall _Z14code_value_intv
        BL       _Z14code_value_intv
        LDR.N    R1,??gcode_M220_0
        STR      R0,[R1, #+120]
??gcode_M220_1:
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??gcode_M220_0:
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock296

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M221v
          CFI Block cfiBlock297 Using cfiCommon0
          CFI Function _Z10gcode_M221v
        THUMB
_Z10gcode_M221v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+221
          CFI FunCall _Z32get_target_extruder_from_commandi
        BL       _Z32get_target_extruder_from_commandi
        CMP      R0,#+0
        BNE.N    ??gcode_M221_1
        MOVS     R0,#+83
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M221_1
          CFI FunCall _Z14code_value_intv
        BL       _Z14code_value_intv
        LDR.N    R1,??gcode_M221_0
        LDR.N    R2,??gcode_M221_0+0x4
        LDRB     R2,[R2, #+5]
        STR      R0,[R1, R2, LSL #+2]
??gcode_M221_1:
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??gcode_M221_0:
        DC32     flow_percentage
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock297

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M226v
          CFI Block cfiBlock298 Using cfiCommon0
          CFI Function _Z10gcode_M226v
        THUMB
_Z10gcode_M226v:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOVS     R0,#+80
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M226_1
          CFI FunCall _Z14code_value_intv
        BL       _Z14code_value_intv
        MOV      R4,R0
        MOVS     R0,#+83
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M226_2
          CFI FunCall _Z14code_value_intv
        BL       _Z14code_value_intv
        MOV      R5,R0
        B.N      ??gcode_M226_3
??gcode_M226_2:
        MOV      R5,#-1
??gcode_M226_3:
        ADDS     R0,R5,#+1
        CMP      R0,#+3
        BCS.N    ??gcode_M226_1
        CMP      R4,#+0
        BMI.N    ??gcode_M226_1
        MOV      R0,R4
        UXTB     R0,R0
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531916pin_is_protectedEh
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531916pin_is_protectedEh
        CMP      R0,#+0
        BNE.N    ??gcode_M226_1
        MOVS     R6,#+0
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        CMP      R5,#+1
        BEQ.N    ??gcode_M226_4
        CMP      R5,#-1
        BEQ.N    ??gcode_M226_5
        B.N      ??gcode_M226_6
??gcode_M226_4:
        MOVS     R6,#+1
        B.N      ??gcode_M226_6
??gcode_M226_5:
        CMP      R4,#+0
        BPL.N    ??gcode_M226_6
        LDR.N    R0,??gcode_M226_0
        LDRH     R1,[R0, R4, LSL #+1]
        LDR.N    R0,??gcode_M226_0+0x4
        LDR      R0,[R0, R4, LSL #+2]
          CFI FunCall HAL_GPIO_ReadPin
        BL       HAL_GPIO_ReadPin
        MOV      R6,R0
        B.N      ??gcode_M226_6
??gcode_M226_7:
        MOVS     R0,#+0
          CFI FunCall _Z4idleb
        BL       _Z4idleb
??gcode_M226_6:
        CMP      R4,#+0
        BMI.N    ??gcode_M226_8
        LDR.N    R0,??gcode_M226_0
        LDRH     R1,[R0, R4, LSL #+1]
        LDR.N    R0,??gcode_M226_0+0x4
        LDR      R0,[R0, R4, LSL #+2]
          CFI FunCall HAL_GPIO_ReadPin
        BL       HAL_GPIO_ReadPin
        B.N      ??gcode_M226_9
??gcode_M226_8:
        MOV      R0,R6
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
??gcode_M226_9:
        CMP      R0,#+0
        BNE.N    ??gcode_M226_7
??gcode_M226_1:
        POP      {R4-R6,PC}       ;; return
        DATA
??gcode_M226_0:
        DC32     gArrayGpioPin
        DC32     gArrayGpioPort
          CFI EndBlock cfiBlock298

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M300v
          CFI Block cfiBlock299 Using cfiCommon0
          CFI Function _Z10gcode_M300v
        THUMB
_Z10gcode_M300v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M300_1
          CFI FunCall _Z17code_value_ushortv
        BL       _Z17code_value_ushortv
        B.N      ??gcode_M300_2
??gcode_M300_1:
        MOV      R0,#+260
??gcode_M300_2:
        STRH     R0,[SP, #+2]
        MOVS     R0,#+80
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M300_3
          CFI FunCall _Z17code_value_ushortv
        BL       _Z17code_value_ushortv
        B.N      ??gcode_M300_4
??gcode_M300_3:
        MOV      R0,#+1000
??gcode_M300_4:
        STRH     R0,[SP, #+0]
        LDRH     R0,[SP, #+0]
        MOVW     R1,#+5001
        CMP      R0,R1
        BLT.N    ??gcode_M300_5
        MOVW     R0,#+5000
        STRH     R0,[SP, #+0]
??gcode_M300_5:
        ADD      R2,SP,#+2
        MOV      R1,SP
        LDR.N    R0,??gcode_M300_0
          CFI FunCall _ZN6Buzzer4toneERKtS1_
        BL       _ZN6Buzzer4toneERKtS1_
        POP      {R0,PC}          ;; return
        DATA
??gcode_M300_0:
        DC32     mks_heating_busy+0x398
          CFI EndBlock cfiBlock299

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M301v
          CFI Block cfiBlock300 Using cfiCommon0
          CFI Function _Z10gcode_M301v
        THUMB
_Z10gcode_M301v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R0,#+69
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M301_1
          CFI FunCall _Z14code_value_intv
        BL       _Z14code_value_intv
        B.N      ??gcode_M301_2
??gcode_M301_1:
        MOVS     R0,#+0
??gcode_M301_2:
        CMP      R0,#+0
        BGT.N    ??gcode_M301_3
        MOVS     R0,#+80
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M301_4
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        LDR.N    R1,??gcode_M301_0
        STR      R0,[R1, #+0]
??gcode_M301_4:
        MOVS     R0,#+73
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M301_5
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??gcode_M301_0+0x4  ;; 0x88e368f1
        LDR.N    R3,??gcode_M301_0+0x8  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        LDR.N    R1,??gcode_M301_0+0xC
        STR      R0,[R1, #+0]
??gcode_M301_5:
        LDR.N    R4,??gcode_M301_0+0x10
        MOVS     R0,#+68
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M301_6
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??gcode_M301_0+0x4  ;; 0x88e368f1
        LDR.N    R3,??gcode_M301_0+0x8  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R4, #+0]
??gcode_M301_6:
          CFI FunCall _ZN11Temperature9updatePIDEv
        BL       _ZN11Temperature9updatePIDEv
        LDR.N    R0,??gcode_M301_0+0x14
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M301_0
        LDR      R1,[R0, #+0]
        LDR.N    R0,??gcode_M301_0+0x18
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR.N    R0,??gcode_M301_0+0xC
        LDR      R0,[R0, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??gcode_M301_0+0x4  ;; 0x88e368f1
        LDR.N    R3,??gcode_M301_0+0x8  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R0
        MOV      R3,R1
        LDR.N    R0,??gcode_M301_0+0x1C
          CFI FunCall _Z17serial_echopair_PPKcd
        BL       _Z17serial_echopair_PPKcd
        LDR      R0,[R4, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??gcode_M301_0+0x4  ;; 0x88e368f1
        LDR.N    R3,??gcode_M301_0+0x8  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R0
        MOV      R3,R1
        LDR.N    R0,??gcode_M301_0+0x20
          CFI FunCall _Z17serial_echopair_PPKcd
        BL       _Z17serial_echopair_PPKcd
        LDR.N    R0,??gcode_M301_0+0x24
        LDRB     R0,[R0, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_M301_7
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M301_0+0x28
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN12MarlinSerial5writeEh
        B.W      _ZN12MarlinSerial5writeEh
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M301_7:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M301_0+0x2C
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN12MarlinSerial5printEci
        B.W      _ZN12MarlinSerial5printEci
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M301_3:
        LDR.N    R0,??gcode_M301_0+0x30
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R1,??gcode_M301_0+0x34
        LDR.N    R4,??gcode_M301_0+0x24
        LDRB     R0,[R4, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_M301_8
        LDR.N    R0,??gcode_M301_0+0x28
          CFI FunCall _ZN12MarlinSerial5printEPKc
        BL       _ZN12MarlinSerial5printEPKc
        B.N      ??gcode_M301_9
??gcode_M301_8:
        LDR.N    R0,??gcode_M301_0+0x2C
          CFI FunCall _ZN12MarlinSerial5printEPKc
        BL       _ZN12MarlinSerial5printEPKc
??gcode_M301_9:
        LDRB     R0,[R4, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_M301_10
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M301_0+0x28
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN12MarlinSerial5writeEh
        B.W      _ZN12MarlinSerial5writeEh
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M301_10:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M301_0+0x2C
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN12MarlinSerial5printEci
        B.W      _ZN12MarlinSerial5printEci
        DATA
??gcode_M301_0:
        DC32     _ZN11Temperature2KpE
        DC32     0x88e368f1
        DC32     0x3fc4f8b5
        DC32     _ZN11Temperature2KiE
        DC32     _ZN11Temperature2KdE
        DC32     echomagic
        DC32     _ZZ10gcode_M301vEs
        DC32     _ZZ10gcode_M301vEs_0
        DC32     _ZZ10gcode_M301vEs_1
        DC32     mks_heating_busy
        DC32     customizedSerial
        DC32     serial2
        DC32     errormagic
        DC32     _ZZ10gcode_M301vEs_2
          CFI EndBlock cfiBlock300

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M304v
          CFI Block cfiBlock301 Using cfiCommon0
          CFI Function _Z10gcode_M304v
        THUMB
_Z10gcode_M304v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R0,#+80
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M304_1
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        LDR.N    R1,??gcode_M304_0
        STR      R0,[R1, #+0]
??gcode_M304_1:
        MOVS     R0,#+73
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M304_2
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??gcode_M304_0+0x4  ;; 0x88e368f1
        LDR.N    R3,??gcode_M304_0+0x8  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        LDR.N    R1,??gcode_M304_0+0xC
        STR      R0,[R1, #+0]
??gcode_M304_2:
        LDR.N    R4,??gcode_M304_0+0x10
        MOVS     R0,#+68
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M304_3
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??gcode_M304_0+0x4  ;; 0x88e368f1
        LDR.N    R3,??gcode_M304_0+0x8  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R4, #+0]
??gcode_M304_3:
          CFI FunCall _ZN11Temperature9updatePIDEv
        BL       _ZN11Temperature9updatePIDEv
        LDR.N    R0,??gcode_M304_0+0x14
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M304_0
        LDR      R1,[R0, #+0]
        LDR.N    R0,??gcode_M304_0+0x18
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR.N    R0,??gcode_M304_0+0xC
        LDR      R0,[R0, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??gcode_M304_0+0x4  ;; 0x88e368f1
        LDR.N    R3,??gcode_M304_0+0x8  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R0
        MOV      R3,R1
        LDR.N    R0,??gcode_M304_0+0x1C
          CFI FunCall _Z17serial_echopair_PPKcd
        BL       _Z17serial_echopair_PPKcd
        LDR      R0,[R4, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??gcode_M304_0+0x4  ;; 0x88e368f1
        LDR.N    R3,??gcode_M304_0+0x8  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R0
        MOV      R3,R1
        LDR.N    R0,??gcode_M304_0+0x20
          CFI FunCall _Z17serial_echopair_PPKcd
        BL       _Z17serial_echopair_PPKcd
        LDR.N    R0,??gcode_M304_0+0x24
        LDRB     R0,[R0, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_M304_4
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M304_0+0x28
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN12MarlinSerial5writeEh
        B.W      _ZN12MarlinSerial5writeEh
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M304_4:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M304_0+0x2C
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN12MarlinSerial5printEci
        B.W      _ZN12MarlinSerial5printEci
        DATA
??gcode_M304_0:
        DC32     _ZN11Temperature5bedKpE
        DC32     0x88e368f1
        DC32     0x3fc4f8b5
        DC32     _ZN11Temperature5bedKiE
        DC32     _ZN11Temperature5bedKdE
        DC32     echomagic
        DC32     _ZZ10gcode_M304vEs
        DC32     _ZZ10gcode_M304vEs_0
        DC32     _ZZ10gcode_M304vEs_1
        DC32     mks_heating_busy
        DC32     customizedSerial
        DC32     serial2
          CFI EndBlock cfiBlock301

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M302v
          CFI Block cfiBlock302 Using cfiCommon0
          CFI Function _Z10gcode_M302v
        THUMB
_Z10gcode_M302v:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOVS     R0,#+83
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        MOVS     R4,R0
        LDR.N    R5,??gcode_M302_0
        BEQ.N    ??gcode_M302_1
        LDR.N    R6,??gcode_M302_0+0x4
          CFI FunCall _Z19code_value_temp_absv
        BL       _Z19code_value_temp_absv
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        STR      R0,[R6, #+0]
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??gcode_M302_2
        MOVS     R0,#+1
        STRB     R0,[R5, #+0]
        B.N      ??gcode_M302_1
??gcode_M302_2:
        MOV      R0,R1
        STRB     R0,[R5, #+0]
??gcode_M302_1:
        MOVS     R0,#+80
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M302_3
        LDR.N    R0,??gcode_M302_0+0x4
        LDR      R0,[R0, #+0]
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??gcode_M302_4
          CFI FunCall _Z15code_value_boolv
        BL       _Z15code_value_boolv
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
        STRB     R0,[R5, #+0]
        POP      {R4-R6,PC}
??gcode_M302_4:
        MOVS     R0,#+1
        STRB     R0,[R5, #+0]
        POP      {R4-R6,PC}
??gcode_M302_3:
        CMP      R4,#+0
        BNE.N    ??gcode_M302_5
        LDR.N    R0,??gcode_M302_0+0x8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDRB     R0,[R5, #+0]
        CMP      R0,#+0
        BEQ.N    ??gcode_M302_6
        LDR.N    R1,??gcode_M302_0+0xC
        B.N      ??gcode_M302_7
??gcode_M302_6:
        LDR.N    R1,??gcode_M302_0+0x10
??gcode_M302_7:
        LDR.N    R0,??gcode_M302_0+0x14
          CFI FunCall _Z17serial_echopair_PPKcS0_
        BL       _Z17serial_echopair_PPKcS0_
        LDR.N    R0,??gcode_M302_0+0x4
        LDR      R0,[R0, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        LDR.N    R3,??gcode_M302_0+0x18  ;; 0x3fe00000
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
        MOV      R1,R0
        LDR.N    R0,??gcode_M302_0+0x1C
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        LDR.N    R0,??gcode_M302_0+0x20
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI R4 Frame(CFA, -16)
          CFI R5 Frame(CFA, -12)
          CFI R6 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??gcode_M302_5:
        POP      {R4-R6,PC}       ;; return
        DATA
??gcode_M302_0:
        DC32     _ZN11Temperature18allow_cold_extrudeE
        DC32     _ZN11Temperature16extrude_min_tempE
        DC32     echomagic
        DC32     _ZZ10gcode_M302vEs_0
        DC32     _ZZ10gcode_M302vEs_1
        DC32     _ZZ10gcode_M302vEs
        DC32     0x3fe00000
        DC32     _ZZ10gcode_M302vEs_2
        DC32     _ZZ10gcode_M302vEs_3
          CFI EndBlock cfiBlock302

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M303v
          CFI Block cfiBlock303 Using cfiCommon0
          CFI Function _Z10gcode_M303v
        THUMB
_Z10gcode_M303v:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        LDR.N    R1,??gcode_M303_0
        LDRB     R0,[R1, #+0]
        CMP      R0,#+0
        BNE.N    ??gcode_M303_1
        LDRB     R0,[R1, #+1]
        CMP      R0,#+0
        BEQ.N    ??gcode_M303_2
??gcode_M303_1:
        MOVS     R0,#+69
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M303_3
          CFI FunCall _Z14code_value_intv
        BL       _Z14code_value_intv
        MOV      R4,R0
        B.N      ??gcode_M303_4
??gcode_M303_3:
        MOVS     R4,#+0
??gcode_M303_4:
        MOVS     R0,#+67
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M303_5
          CFI FunCall _Z14code_value_intv
        BL       _Z14code_value_intv
        MOV      R6,R0
        B.N      ??gcode_M303_6
??gcode_M303_5:
        MOVS     R6,#+5
??gcode_M303_6:
        MOVS     R0,#+85
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M303_7
          CFI FunCall _Z15code_value_boolv
        BL       _Z15code_value_boolv
        SUBS     R7,R0,#+1
        SBCS     R7,R7,R7
        MVNS     R7,R7
        LSRS     R7,R7,#+31
        B.N      ??gcode_M303_8
??gcode_M303_7:
        MOVS     R7,#+0
??gcode_M303_8:
        MOVS     R0,#+83
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M303_9
          CFI FunCall _Z19code_value_temp_absv
        BL       _Z19code_value_temp_absv
        B.N      ??gcode_M303_10
??gcode_M303_9:
        CMP      R4,#+0
        BPL.N    ??gcode_M303_11
        MOVS     R0,#+70
        B.N      ??gcode_M303_10
??gcode_M303_11:
        MOVS     R0,#+150
??gcode_M303_10:
        LDR.N    R5,??gcode_M303_0+0x4
        CMP      R4,#+0
        BNE.N    ??gcode_M303_12
        MOVS     R1,#+0
        STRB     R1,[R5, #+5]
??gcode_M303_12:
        MOVS     R1,#+0
        STRB     R1,[R5, #+6]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R3,R7
        MOV      R2,R6
        MOV      R1,R4
          CFI FunCall _ZN11Temperature12PID_autotuneEfiib
        BL       _ZN11Temperature12PID_autotuneEfiib
        MOVS     R0,#+1
        STRB     R0,[R5, #+6]
        POP      {R0,R4-R7,PC}
??gcode_M303_2:
        LDR.N    R0,??gcode_M303_0+0x8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M303_0+0xC
        POP      {R1,R4-R7,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
        Nop      
        DATA
??gcode_M303_0:
        DC32     mksCfg+0x34
        DC32     mks_heating_busy
        DC32     errormagic
        DC32     _ZZ10gcode_M303vEs
          CFI EndBlock cfiBlock303

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M360v
          CFI Block cfiBlock304 Using cfiCommon0
          CFI Function _Z10gcode_M360v
        THUMB
_Z10gcode_M360v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M360_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R1,#+120
        MOVS     R0,#+0
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z17SCARA_move_to_calhh
        B.W      _Z17SCARA_move_to_calhh
        DATA
??gcode_M360_0:
        DC32     _ZZ10gcode_M360vEs
          CFI EndBlock cfiBlock304

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M361v
          CFI Block cfiBlock305 Using cfiCommon0
          CFI Function _Z10gcode_M361v
        THUMB
_Z10gcode_M361v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M361_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R1,#+130
        MOVS     R0,#+90
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z17SCARA_move_to_calhh
        B.W      _Z17SCARA_move_to_calhh
        DATA
??gcode_M361_0:
        DC32     _ZZ10gcode_M361vEs
          CFI EndBlock cfiBlock305

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M362v
          CFI Block cfiBlock306 Using cfiCommon0
          CFI Function _Z10gcode_M362v
        THUMB
_Z10gcode_M362v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M362_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R1,#+180
        MOVS     R0,#+60
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z17SCARA_move_to_calhh
        B.W      _Z17SCARA_move_to_calhh
        DATA
??gcode_M362_0:
        DC32     _ZZ10gcode_M362vEs
          CFI EndBlock cfiBlock306

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M363v
          CFI Block cfiBlock307 Using cfiCommon0
          CFI Function _Z10gcode_M363v
        THUMB
_Z10gcode_M363v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M363_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R1,#+90
        MOVS     R0,#+50
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z17SCARA_move_to_calhh
        B.W      _Z17SCARA_move_to_calhh
        DATA
??gcode_M363_0:
        DC32     _ZZ10gcode_M363vEs
          CFI EndBlock cfiBlock307

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M364v
          CFI Block cfiBlock308 Using cfiCommon0
          CFI Function _Z10gcode_M364v
        THUMB
_Z10gcode_M364v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M364_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R1,#+135
        MOVS     R0,#+45
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z17SCARA_move_to_calhh
        B.W      _Z17SCARA_move_to_calhh
        DATA
??gcode_M364_0:
        DC32     _ZZ10gcode_M364vEs
          CFI EndBlock cfiBlock308

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M400v
          CFI Block cfiBlock309 Using cfiCommon0
          CFI Function _Z10gcode_M400v
          CFI FunCall _ZN7Stepper11synchronizeEv
        THUMB
_Z10gcode_M400v:
        B.W      _ZN7Stepper11synchronizeEv
          CFI EndBlock cfiBlock309

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M401v
          CFI Block cfiBlock310 Using cfiCommon0
          CFI Function _Z10gcode_M401v
        THUMB
_Z10gcode_M401v:
        MOVS     R0,#+1
          CFI FunCall _Z18set_probe_deployedb
        B.W      _Z18set_probe_deployedb
          CFI EndBlock cfiBlock310

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M402v
          CFI Block cfiBlock311 Using cfiCommon0
          CFI Function _Z10gcode_M402v
        THUMB
_Z10gcode_M402v:
        MOVS     R0,#+0
          CFI FunCall _Z18set_probe_deployedb
        B.W      _Z18set_probe_deployedb
          CFI EndBlock cfiBlock311

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M420v
          CFI Block cfiBlock312 Using cfiCommon0
          CFI Function _Z10gcode_M420v
        THUMB
_Z10gcode_M420v:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        LDR.N    R5,??gcode_M420_0
        LDR.N    R4,??gcode_M420_0+0x4
        LDRB     R0,[R5, #+0]
        CMP      R0,#+16
        BNE.N    ??gcode_M420_1
        MOVS     R0,#+76
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M420_1
          CFI FunCall _Z14code_has_valuev
        BL       _Z14code_has_valuev
        CMP      R0,#+0
        BEQ.N    ??gcode_M420_2
          CFI FunCall _Z14code_value_intv
        BL       _Z14code_value_intv
        MOV      R6,R0
        SXTB     R6,R6
        B.N      ??gcode_M420_3
??gcode_M420_2:
        LDR.N    R0,??gcode_M420_0+0x8
        LDRSB    R6,[R0, #+8]
??gcode_M420_3:
        CMP      R6,#+0
        BMI.N    ??gcode_M420_4
        LDR.N    R0,??gcode_M420_0+0xC
        LDRSH    R0,[R0, #+0]
        MOVW     R1,#+1535
        SUBS     R1,R1,R0
        LSRS     R1,R1,#+10
        SXTH     R1,R1
        SUBS     R1,R1,#+1
        CMP      R1,R6
        BLT.N    ??gcode_M420_4
        CMP      R0,#+0
        BGT.N    ??gcode_M420_5
??gcode_M420_4:
        LDR.N    R0,??gcode_M420_0+0x10
        POP      {R4-R8,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI R4 Frame(CFA, -24)
          CFI R5 Frame(CFA, -20)
          CFI R6 Frame(CFA, -16)
          CFI R7 Frame(CFA, -12)
          CFI R8 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+24
??gcode_M420_5:
        MOV      R1,R6
        ADD      R0,R4,#+132
          CFI FunCall _ZN20unified_bed_leveling9load_meshEs
        BL       _ZN20unified_bed_leveling9load_meshEs
        LDR.N    R0,??gcode_M420_0+0x8
        STRB     R6,[R0, #+8]
??gcode_M420_1:
        MOVS     R0,#+86
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M420_6
        LDRB     R0,[R5, #+0]
        TST      R0,#0x6
        BEQ.N    ??gcode_M420_7
        LDR.N    R1,??gcode_M420_0+0x14
        LDR.N    R0,??gcode_M420_0+0x18
          CFI FunCall _ZN10matrix_3x35debugEPKc
        BL       _ZN10matrix_3x35debugEPKc
        B.N      ??gcode_M420_6
??gcode_M420_7:
        CMP      R0,#+8
        BNE.N    ??gcode_M420_8
        LDR.N    R0,??gcode_M420_0+0x1C
        LDR      R0,[R0, #+8]
        CMP      R0,#+0
        BEQ.N    ??gcode_M420_6
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531928print_bilinear_leveling_gridEv
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531928print_bilinear_leveling_gridEv
        B.N      ??gcode_M420_6
??gcode_M420_8:
        CMP      R0,#+32
        BNE.N    ??gcode_M420_6
          CFI FunCall _ZN17mesh_bed_leveling8has_meshEv
        BL       _ZN17mesh_bed_leveling8has_meshEv
        CMP      R0,#+0
        BEQ.N    ??gcode_M420_6
        LDR.N    R0,??gcode_M420_0+0x20
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
          CFI FunCall _Z15mbl_mesh_reportv
        BL       _Z15mbl_mesh_reportv
??gcode_M420_6:
        LDRB     R0,[R5, #+0]
        CMP      R0,#+16
        BNE.N    ??gcode_M420_9
        MOVS     R0,#+76
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BNE.N    ??gcode_M420_10
        MOVS     R0,#+86
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M420_9
??gcode_M420_10:
        MOVS     R1,#+0
        ADD      R0,R4,#+132
          CFI FunCall _ZN20unified_bed_leveling11display_mapEi
        BL       _ZN20unified_bed_leveling11display_mapEi
        LDR.N    R2,??gcode_M420_0+0x24
        LDR      R3,[R2, #+4]
        LDR      R6,[R2, #+0]
        MOV      R0,R6
        MOV      R1,R3
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??gcode_M420_11
        MOV      R0,R3
        LDR      R1,[R2, #+8]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??gcode_M420_11
        LDR      R3,[R2, #+68]
        LDR      R7,[R2, #+64]
        MOV      R0,R7
        MOV      R1,R3
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??gcode_M420_11
        MOV      R0,R3
        LDR      R1,[R2, #+72]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??gcode_M420_11
        ADD      R3,R2,#+132
        LDR      R8,[R3, #+0]
        LDR      R2,[R2, #+128]
        MOV      R0,R2
        MOV      R1,R8
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??gcode_M420_11
        MOV      R0,R8
        LDR      R1,[R3, #+4]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??gcode_M420_11
        MOV      R0,R6
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??gcode_M420_11
        MOV      R0,R7
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??gcode_M420_11
        MOV      R0,R2
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??gcode_M420_12
??gcode_M420_11:
        MOV      R0,R6
          CFI FunCall _Z5isnanf
        BL       _Z5isnanf
        SUBS     R1,R0,#+1
        SBCS     R1,R1,R1
        LSRS     R1,R1,#+31
??gcode_M420_12:
        LDR.N    R0,??gcode_M420_0+0x28
          CFI FunCall _Z17serial_echopair_PPKcb
        BL       _Z17serial_echopair_PPKcb
        LDRB     R0,[R4, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_M420_13
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M420_0+0x2C
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??gcode_M420_14
??gcode_M420_13:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M420_0+0x30
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
??gcode_M420_14:
        LDR.N    R0,??gcode_M420_0+0x8
        LDRSB    R1,[R0, #+8]
        LDR.N    R0,??gcode_M420_0+0x34
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        LDRB     R0,[R4, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_M420_15
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M420_0+0x2C
          CFI FunCall _ZN12MarlinSerial5writeEh
        BL       _ZN12MarlinSerial5writeEh
        B.N      ??gcode_M420_9
??gcode_M420_15:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M420_0+0x30
          CFI FunCall _ZN12MarlinSerial5printEci
        BL       _ZN12MarlinSerial5printEci
??gcode_M420_9:
        MOVS     R6,#+0
        MOVS     R0,#+83
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M420_16
          CFI FunCall _Z15code_value_boolv
        BL       _Z15code_value_boolv
        MOV      R6,R0
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
??gcode_M420_16:
        LDRSH    R0,[R5, #+24]
        CMP      R0,#+2
        BEQ.N    ??gcode_M420_17
        LDRB     R0,[R5, #+0]
        LSLS     R0,R0,#+27
        BPL.N    ??gcode_M420_17
        MOVS     R0,#+90
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M420_17
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
          CFI FunCall _Z17set_z_fade_heightf
        BL       _Z17set_z_fade_heightf
??gcode_M420_17:
        LDRB     R0,[R5, #+0]
        CMP      R0,#+32
        BNE.N    ??gcode_M420_18
          CFI FunCall _ZN17mesh_bed_leveling6activeEv
        BL       _ZN17mesh_bed_leveling6activeEv
        MOV      R5,R0
        B.N      ??gcode_M420_19
??gcode_M420_18:
        CMP      R0,#+16
        BNE.N    ??gcode_M420_20
        LDR.N    R0,??gcode_M420_0+0x8
        LDRB     R5,[R0, #+0]
        B.N      ??gcode_M420_19
??gcode_M420_20:
        LDR.N    R0,??gcode_M420_0+0x38
        LDRB     R5,[R0, #+0]
??gcode_M420_19:
        CMP      R6,#+0
        BEQ.N    ??gcode_M420_21
        MOVS     R0,R5
        BNE.N    ??gcode_M420_21
        LDR.N    R0,??gcode_M420_0+0x3C
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M420_0+0x40
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_M420_21:
        LDR.N    R0,??gcode_M420_0+0x44
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        CMP      R5,#+0
        BEQ.N    ??gcode_M420_22
        LDR.N    R1,??gcode_M420_0+0x48
        B.N      ??gcode_M420_23
??gcode_M420_22:
        LDR.N    R1,??gcode_M420_0+0x4C
??gcode_M420_23:
        LDR.N    R0,??gcode_M420_0+0x50
          CFI FunCall _Z17serial_echopair_PPKcS0_
        BL       _Z17serial_echopair_PPKcS0_
        LDRB     R0,[R4, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_M420_24
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M420_0+0x2C
        POP      {R4-R8,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN12MarlinSerial5writeEh
        B.W      _ZN12MarlinSerial5writeEh
          CFI R4 Frame(CFA, -24)
          CFI R5 Frame(CFA, -20)
          CFI R6 Frame(CFA, -16)
          CFI R7 Frame(CFA, -12)
          CFI R8 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+24
??gcode_M420_24:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M420_0+0x30
        POP      {R4-R8,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN12MarlinSerial5printEci
        B.W      _ZN12MarlinSerial5printEci
        DATA
??gcode_M420_0:
        DC32     mksCfg+0x40
        DC32     mks_heating_busy
        DC32     _ZN20unified_bed_leveling5stateE
        DC32     _ZN20unified_bed_leveling12eeprom_startE
        DC32     _ZZ10gcode_M420vEs
        DC32     _ZZ10gcode_M420vEs_0
        DC32     _ZN7Planner16bed_level_matrixE
        DC32     Running
        DC32     _ZZ10gcode_M420vEs_1
        DC32     _ZN20unified_bed_leveling8z_valuesE
        DC32     _ZZ10gcode_M420vEs_2
        DC32     customizedSerial
        DC32     serial2
        DC32     _ZZ10gcode_M420vEs_3
        DC32     _ZN7Planner11abl_enabledE
        DC32     errormagic
        DC32     _ZZ10gcode_M420vEs_4
        DC32     echomagic
        DC32     MSG_ON
        DC32     MSG_OFF
        DC32     _ZZ10gcode_M420vEs_5
          CFI EndBlock cfiBlock312

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z28gcode_M421_MESH_BED_LEVELINGv
          CFI Block cfiBlock313 Using cfiCommon0
          CFI Function _Z28gcode_M421_MESH_BED_LEVELINGv
        THUMB
_Z28gcode_M421_MESH_BED_LEVELINGv:
        PUSH     {R2-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+40
        MOVS     R6,#+0
        MOV      R7,R6
        MOV      R0,R6
        STR      R0,[SP, #+4]
        MOVS     R0,#+88
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        MOVS     R5,R0
        BEQ.N    ??gcode_M421_MESH_BED_LEVELING_1
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        STR      R0,[SP, #+0]
        MOV      R0,SP
          CFI FunCall _ZN17mesh_bed_leveling13probe_index_xERKf
        BL       _ZN17mesh_bed_leveling13probe_index_xERKf
        MOV      R6,R0
??gcode_M421_MESH_BED_LEVELING_1:
        MOVS     R0,#+89
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        MOV      R8,R0
        CMP      R0,#+0
        BEQ.N    ??gcode_M421_MESH_BED_LEVELING_2
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        STR      R0,[SP, #+0]
        MOV      R0,SP
          CFI FunCall _ZN17mesh_bed_leveling13probe_index_yERKf
        BL       _ZN17mesh_bed_leveling13probe_index_yERKf
        MOV      R7,R0
??gcode_M421_MESH_BED_LEVELING_2:
        MOVS     R0,#+73
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        MOV      R9,R0
        CMP      R0,#+0
        BEQ.N    ??gcode_M421_MESH_BED_LEVELING_3
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R6,R0
??gcode_M421_MESH_BED_LEVELING_3:
        MOVS     R0,#+74
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        MOV      R10,R0
        CMP      R0,#+0
        BEQ.N    ??gcode_M421_MESH_BED_LEVELING_4
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R7,R0
??gcode_M421_MESH_BED_LEVELING_4:
        MOVS     R0,#+90
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        MOVS     R4,R0
        BEQ.N    ??gcode_M421_MESH_BED_LEVELING_5
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        STR      R0,[SP, #+4]
??gcode_M421_MESH_BED_LEVELING_5:
        CMP      R5,#+0
        BEQ.N    ??gcode_M421_MESH_BED_LEVELING_6
        CMP      R8,#+0
        BEQ.N    ??gcode_M421_MESH_BED_LEVELING_6
        CMP      R4,#+0
        BEQ.N    ??gcode_M421_MESH_BED_LEVELING_6
        MOV      R0,R6
        SXTB     R0,R0
        CMP      R0,#+0
        BMI.N    ??gcode_M421_MESH_BED_LEVELING_7
        MOV      R0,R7
        SXTB     R0,R0
        CMP      R0,#+0
        BPL.N    ??gcode_M421_MESH_BED_LEVELING_8
??gcode_M421_MESH_BED_LEVELING_7:
        LDR.N    R0,??gcode_M421_MESH_BED_LEVELING_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M421_MESH_BED_LEVELING_0+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.N      ??gcode_M421_MESH_BED_LEVELING_9
??gcode_M421_MESH_BED_LEVELING_6:
        CMP      R9,#+0
        BEQ.N    ??gcode_M421_MESH_BED_LEVELING_10
        CMP      R10,#+0
        BEQ.N    ??gcode_M421_MESH_BED_LEVELING_10
        CMP      R4,#+0
        BEQ.N    ??gcode_M421_MESH_BED_LEVELING_10
        MOV      R0,R6
        SXTB     R0,R0
        CMP      R0,#+0
        BMI.N    ??gcode_M421_MESH_BED_LEVELING_7
        LDR.N    R1,??gcode_M421_MESH_BED_LEVELING_0+0x8
        LDRB     R2,[R1, #+0]
        SUBS     R2,R2,#+1
        CMP      R2,R0
        BLT.N    ??gcode_M421_MESH_BED_LEVELING_7
        MOV      R0,R7
        SXTB     R0,R0
        CMP      R0,#+0
        BMI.N    ??gcode_M421_MESH_BED_LEVELING_7
        LDRB     R1,[R1, #+1]
        SUBS     R1,R1,#+1
        CMP      R1,R0
        BLT.N    ??gcode_M421_MESH_BED_LEVELING_7
??gcode_M421_MESH_BED_LEVELING_8:
        ADD      R2,SP,#+4
        MOV      R1,R7
        SXTB     R1,R1
        MOV      R0,R6
        SXTB     R0,R0
          CFI FunCall _ZN17mesh_bed_leveling5set_zEaaRKf
        BL       _ZN17mesh_bed_leveling5set_zEaaRKf
        B.N      ??gcode_M421_MESH_BED_LEVELING_9
??gcode_M421_MESH_BED_LEVELING_10:
        LDR.N    R0,??gcode_M421_MESH_BED_LEVELING_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M421_MESH_BED_LEVELING_0+0xC
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_M421_MESH_BED_LEVELING_9:
        POP      {R0,R1,R4-R10,PC}  ;; return
        DATA
??gcode_M421_MESH_BED_LEVELING_0:
        DC32     errormagic
        DC32     _ZZ28gcode_M421_MESH_BED_LEVELINGvEs
        DC32     mksCfg+0x60
        DC32     _ZZ28gcode_M421_MESH_BED_LEVELINGvEs_0
          CFI EndBlock cfiBlock313

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M421v
          CFI Block cfiBlock314 Using cfiCommon0
          CFI Function _Z10gcode_M421v
        THUMB
_Z10gcode_M421v:
        PUSH     {R3-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+32
        MOVS     R4,#+0
        MOV      R5,R4
        MOV      R6,R4
        MOVS     R0,#+73
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        MOVS     R7,R0
        BEQ.N    ??gcode_M421_1
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R4,R0
        SXTB     R4,R4
??gcode_M421_1:
        MOVS     R0,#+74
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        MOV      R8,R0
        CMP      R0,#+0
        BEQ.N    ??gcode_M421_2
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R5,R0
        SXTB     R5,R5
??gcode_M421_2:
        MOVS     R0,#+90
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        MOV      R9,R0
        CMP      R0,#+0
        BEQ.N    ??gcode_M421_3
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        MOV      R6,R0
??gcode_M421_3:
        CMP      R7,#+0
        BEQ.N    ??gcode_M421_4
        CMP      R8,#+0
        BEQ.N    ??gcode_M421_4
        CMP      R9,#+0
        BEQ.N    ??gcode_M421_4
        CMP      R4,#+0
        BMI.N    ??gcode_M421_5
        LDR.N    R0,??gcode_M421_0
        LDRB     R1,[R0, #+96]
        SUBS     R1,R1,#+1
        CMP      R1,R4
        BLT.N    ??gcode_M421_5
        CMP      R5,#+0
        BMI.N    ??gcode_M421_5
        CMP      R1,R5
        BLT.N    ??gcode_M421_5
        LDRB     R0,[R0, #+64]
        CMP      R0,#+16
        BNE.N    ??gcode_M421_6
        LDR.N    R0,??gcode_M421_0+0x4
        ADD      R0,R0,R4, LSL #+6
        STR      R6,[R0, R5, LSL #+2]
        B.N      ??gcode_M421_7
??gcode_M421_6:
        LDR.N    R0,??gcode_M421_0+0x8
        ADD      R0,R0,R4, LSL #+6
        STR      R6,[R0, R5, LSL #+2]
        B.N      ??gcode_M421_7
??gcode_M421_5:
        LDR.N    R0,??gcode_M421_0+0xC
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M421_0+0x10
        POP      {R1,R4-R9,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI R4 Frame(CFA, -28)
          CFI R5 Frame(CFA, -24)
          CFI R6 Frame(CFA, -20)
          CFI R7 Frame(CFA, -16)
          CFI R8 Frame(CFA, -12)
          CFI R9 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
??gcode_M421_4:
        LDR.N    R0,??gcode_M421_0+0xC
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M421_0+0x14
        POP      {R1,R4-R9,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI R4 Frame(CFA, -28)
          CFI R5 Frame(CFA, -24)
          CFI R6 Frame(CFA, -20)
          CFI R7 Frame(CFA, -16)
          CFI R8 Frame(CFA, -12)
          CFI R9 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
??gcode_M421_7:
        POP      {R0,R4-R9,PC}    ;; return
        Nop      
        DATA
??gcode_M421_0:
        DC32     mksCfg
        DC32     _ZN20unified_bed_leveling8z_valuesE
        DC32     z_values
        DC32     errormagic
        DC32     _ZZ10gcode_M421vEs
        DC32     _ZZ10gcode_M421vEs_0
          CFI EndBlock cfiBlock314

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M428v
          CFI Block cfiBlock315 Using cfiCommon0
          CFI Function _Z10gcode_M428v
        THUMB
_Z10gcode_M428v:
        LDR.N    R0,??gcode_M428_0
        LDRSH    R0,[R0, #+88]
        CMP      R0,#+2
        BNE.N    ??gcode_M428_1
        BX       LR
??gcode_M428_1:
        PUSH     {R2-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+40
        MOV      R10,#+0
        MOV      R4,R10
        LDR.N    R7,??gcode_M428_0+0x4
??gcode_M428_2:
        CMP      R4,#+3
        BGE.N    ??gcode_M428_3
        LDR.N    R0,??gcode_M428_0+0x8
        LDRB     R0,[R0, R4]
        CMP      R0,#+0
        BEQ.N    ??gcode_M428_4
        ADD      R5,R7,R4, LSL #+2
        LDR      R6,[R5, #+8]
        MOV      R0,R6
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R8,R2
        MOV      R9,R3
        LDR      R0,[R5, #+80]
        LDR      R1,[R5, #+92]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R10
        LDR.N    R3,??gcode_M428_0+0xC  ;; 0x3fe00000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_cdcmple
        BL       __aeabi_cdcmple
        BCC.N    ??gcode_M428_5
        MOV      R0,R10
        B.N      ??gcode_M428_6
??gcode_M428_5:
        MOV      R0,R4
        SXTB     R0,R0
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531913base_home_posE8AxisEnum
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531913base_home_posE8AxisEnum
??gcode_M428_6:
        LDR      R1,[R5, #+68]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R6
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R2,R0
        LDR.N    R1,??gcode_M428_0+0x10  ;; 0xc1a00000
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_M428_7
        LDR.N    R1,??gcode_M428_0+0x14  ;; 0x41a00001
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_M428_7
        LDR      R0,[R5, #+56]
        MOV      R1,R2
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R0
        MOV      R0,R4
        SXTB     R0,R0
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531915set_home_offsetE8AxisEnumf
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531915set_home_offsetE8AxisEnumf
??gcode_M428_4:
        ADDS     R4,R4,#+1
        UXTB     R4,R4
        B.N      ??gcode_M428_2
??gcode_M428_7:
        LDR.N    R0,??gcode_M428_0+0x18
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M428_0+0x1C
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M428_0+0x20
          CFI FunCall _Z21lcd_setalertstatuspgmPKc
        BL       _Z21lcd_setalertstatuspgmPKc
        MOVS     R0,#+200
        STRH     R0,[SP, #+2]
        MOVS     R0,#+40
        STRH     R0,[SP, #+0]
        MOV      R2,SP
        ADD      R1,SP,#+2
        ADD      R0,R7,#+920
          CFI FunCall _ZN6Buzzer4toneERKtS1_
        BL       _ZN6Buzzer4toneERKtS1_
        MOV      R10,#+1
??gcode_M428_3:
        CMP      R10,#+0
        BNE.N    ??gcode_M428_8
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
          CFI FunCall _ZN37_INTERNAL_15_Marlin_main_cpp_3178531923report_current_positionEv
        BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531923report_current_positionEv
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M428_0+0x24
          CFI FunCall _Z16lcd_setstatuspgmPKch
        BL       _Z16lcd_setstatuspgmPKch
        MOVS     R0,#+100
        STRH     R0,[SP, #+2]
        MOVW     R0,#+659
        STRH     R0,[SP, #+0]
        LDR.N    R4,??gcode_M428_0+0x28
        MOV      R2,SP
        ADD      R1,SP,#+2
        MOV      R0,R4
          CFI FunCall _ZN6Buzzer4toneERKtS1_
        BL       _ZN6Buzzer4toneERKtS1_
        MOVS     R0,#+100
        STRH     R0,[SP, #+2]
        MOVW     R0,#+698
        STRH     R0,[SP, #+0]
        MOV      R2,SP
        ADD      R1,SP,#+2
        MOV      R0,R4
          CFI FunCall _ZN6Buzzer4toneERKtS1_
        BL       _ZN6Buzzer4toneERKtS1_
??gcode_M428_8:
        POP      {R0,R1,R4-R10,PC}  ;; return
        Nop      
        DATA
??gcode_M428_0:
        DC32     mksCfg
        DC32     mks_heating_busy
        DC32     axis_homed
        DC32     0x3fe00000
        DC32     0xc1a00000
        DC32     0x41a00001
        DC32     errormagic
        DC32     _ZZ10gcode_M428vEs
        DC32     _ZZ10gcode_M428vEs_0
        DC32     MSG_HOME_OFFSETS_APPLIED
        DC32     mks_heating_busy+0x398
          CFI EndBlock cfiBlock315

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M500v
          CFI Block cfiBlock316 Using cfiCommon0
          CFI Function _Z10gcode_M500v
          CFI FunCall _ZN14MarlinSettings4saveEv
        THUMB
_Z10gcode_M500v:
        B.W      _ZN14MarlinSettings4saveEv
          CFI EndBlock cfiBlock316

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M501v
          CFI Block cfiBlock317 Using cfiCommon0
          CFI Function _Z10gcode_M501v
          CFI FunCall _ZN14MarlinSettings4loadEv
        THUMB
_Z10gcode_M501v:
        B.W      _ZN14MarlinSettings4loadEv
          CFI EndBlock cfiBlock317

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M502v
          CFI Block cfiBlock318 Using cfiCommon0
          CFI Function _Z10gcode_M502v
          CFI FunCall _ZN14MarlinSettings5resetEv
        THUMB
_Z10gcode_M502v:
        B.W      _ZN14MarlinSettings5resetEv
          CFI EndBlock cfiBlock318

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M503v
          CFI Block cfiBlock319 Using cfiCommon0
          CFI Function _Z10gcode_M503v
        THUMB
_Z10gcode_M503v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M503_0
          CFI FunCall _Z15code_value_boolv
        BL       _Z15code_value_boolv
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        LSRS     R0,R0,#+31
        B.N      ??gcode_M503_1
??gcode_M503_0:
        MOVS     R0,#+0
??gcode_M503_1:
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN14MarlinSettings6reportEb
        B.W      _ZN14MarlinSettings6reportEb
          CFI EndBlock cfiBlock319

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M851v
          CFI Block cfiBlock320 Using cfiCommon0
          CFI Function _Z10gcode_M851v
        THUMB
_Z10gcode_M851v:
        PUSH     {R2-R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+16
        LDR.N    R0,??gcode_M851_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M851_0+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R0,#+90
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M851_1
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        LDR.N    R1,??gcode_M851_0+0x8  ;; 0xc1a00000
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_M851_2
        LDR.N    R1,??gcode_M851_0+0xC  ;; 0x41a00001
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_M851_2
        LDR.N    R4,??gcode_M851_0+0x10
        STR      R0,[R4, #+72]
        MOVS     R0,#+0
          CFI FunCall _Z22refresh_zprobe_zoffsetb
        BL       _Z22refresh_zprobe_zoffsetb
        LDR      R0,[R4, #+72]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??gcode_M851_0+0x14
        LDRB     R2,[R2, #+7]
        CMP      R2,#+0
        BNE.N    ??gcode_M851_3
        MOVS     R2,#+2
        STR      R2,[SP, #+0]
        MOV      R2,R0
        MOV      R3,R1
        LDR.N    R0,??gcode_M851_0+0x18
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
        B.N      ??gcode_M851_4
??gcode_M851_3:
        MOVS     R2,#+2
        STR      R2,[SP, #+0]
        MOV      R2,R0
        MOV      R3,R1
        LDR.N    R0,??gcode_M851_0+0x1C
          CFI FunCall _ZN12MarlinSerial5printEdi
        BL       _ZN12MarlinSerial5printEdi
        B.N      ??gcode_M851_4
??gcode_M851_2:
        LDR.N    R0,??gcode_M851_0+0x20
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.N      ??gcode_M851_4
??gcode_M851_1:
        LDR.N    R0,??gcode_M851_0+0x10
        LDR      R1,[R0, #+72]
        LDR.N    R0,??gcode_M851_0+0x24
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
??gcode_M851_4:
        LDR.N    R0,??gcode_M851_0+0x14
        LDRB     R0,[R0, #+7]
        CMP      R0,#+0
        BNE.N    ??gcode_M851_5
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M851_0+0x18
        POP      {R2-R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN12MarlinSerial5writeEh
        B.W      _ZN12MarlinSerial5writeEh
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??gcode_M851_5:
        MOVS     R2,#+0
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M851_0+0x1C
        ADD      SP,SP,#+8
          CFI CFA R13+8
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN12MarlinSerial5printEci
        B.W      _ZN12MarlinSerial5printEci
        Nop      
        DATA
??gcode_M851_0:
        DC32     echomagic
        DC32     _ZZ10gcode_M851vEs
        DC32     0xc1a00000
        DC32     0x41a00001
        DC32     axis_homed
        DC32     mks_heating_busy
        DC32     customizedSerial
        DC32     serial2
        DC32     _ZZ10gcode_M851vEs_0
        DC32     _ZZ10gcode_M851vEs_1
          CFI EndBlock cfiBlock320

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M600v
          CFI Block cfiBlock321 Using cfiCommon0
          CFI Function _Z10gcode_M600v
        THUMB
_Z10gcode_M600v:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        SUB      SP,SP,#+24
          CFI CFA R13+64
        LDR.W    R5,??gcode_M600_0
        LDRB     R0,[R5, #+1]
        LSLS     R0,R0,#+28
        BMI.N    ??gcode_M600_1
        LDRB     R0,[R5, #+2]
          CFI FunCall _ZN11Temperature16tooColdToExtrudeEh
        BL       _ZN11Temperature16tooColdToExtrudeEh
        CMP      R0,#+0
        BEQ.N    ??gcode_M600_1
        LDR.W    R0,??gcode_M600_0+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R0,??gcode_M600_0+0x8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.N      ??gcode_M600_2
??gcode_M600_1:
        LDR.W    R6,??gcode_M600_0+0xC
        MOVS     R0,#+1
        STRB     R0,[R6, #+15]
        ADD      R7,R5,#+904
        MOV      R0,R7
          CFI FunCall _ZN9Stopwatch9isRunningEv
        BL       _ZN9Stopwatch9isRunningEv
        MOV      R8,R0
        MOV      R0,R7
          CFI FunCall _ZN9Stopwatch5pauseEv
        BL       _ZN9Stopwatch5pauseEv
        MOVS     R0,#+0
          CFI FunCall _Z32lcd_filament_change_show_message21FilamentChangeMessage
        BL       _Z32lcd_filament_change_show_message21FilamentChangeMessage
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        MOVS     R2,#+16
        ADD      R1,R5,#+8
        ADD      R0,SP,#+4
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
          CFI FunCall _Z26set_destination_to_currentv
        BL       _Z26set_destination_to_currentv
        MOVS     R0,#+69
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M600_3
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        MOV      R1,R0
        B.N      ??gcode_M600_4
??gcode_M600_3:
        MOV      R1,#-1073741824
??gcode_M600_4:
        LDR      R0,[R5, #+36]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+36]
        LDR.N    R0,??gcode_M600_0+0x10  ;; 0x42700000
          CFI FunCall _Z7RUNPLANf
        BL       _Z7RUNPLANf
        LDR.W    R9,??gcode_M600_0+0x14
        MOVS     R0,#+90
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M600_5
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        MOV      R4,R0
        B.N      ??gcode_M600_6
??gcode_M600_5:
        ADD      R0,R9,#+212
        LDR      R4,[R0, #+8]
??gcode_M600_6:
        MOV      R0,R4
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BCS.N    ??gcode_M600_7
        LDR      R0,[R5, #+32]
        MOV      R1,R4
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        STR      R1,[R5, #+32]
        LDR      R0,[R9, #+28]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_M600_8
        STR      R0,[R5, #+32]
??gcode_M600_8:
        LDR      R0,[R9, #+40]
        LDR.N    R1,??gcode_M600_0+0x10  ;; 0x42700000
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
          CFI FunCall _Z7RUNPLANf
        BL       _Z7RUNPLANf
??gcode_M600_7:
        MOVS     R0,#+88
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M600_9
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        STR      R0,[R5, #+24]
        B.N      ??gcode_M600_10
??gcode_M600_9:
        LDR      R0,[R9, #+212]
        STR      R0,[R5, #+24]
??gcode_M600_10:
        MOVS     R0,#+89
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M600_11
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        STR      R0,[R5, #+28]
        B.N      ??gcode_M600_12
??gcode_M600_11:
        ADD      R0,R9,#+212
        LDR      R0,[R0, #+4]
        STR      R0,[R5, #+28]
??gcode_M600_12:
        LDR      R0,[R9, #+36]
        LDR.N    R1,??gcode_M600_0+0x10  ;; 0x42700000
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
          CFI FunCall _Z7RUNPLANf
        BL       _Z7RUNPLANf
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        MOVS     R0,#+1
          CFI FunCall _Z32lcd_filament_change_show_message21FilamentChangeMessage
        BL       _Z32lcd_filament_change_show_message21FilamentChangeMessage
        MOVS     R0,#+0
          CFI FunCall _Z4idleb
        BL       _Z4idleb
        MOVS     R0,#+76
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M600_13
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        MOV      R1,R0
        B.N      ??gcode_M600_14
??gcode_M600_13:
        LDR.N    R1,??gcode_M600_0+0x18  ;; 0xc2c80000
??gcode_M600_14:
        LDR      R0,[R5, #+36]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+36]
        LDR.N    R0,??gcode_M600_0+0x1C  ;; 0x41200000
          CFI FunCall _Z7RUNPLANf
        BL       _Z7RUNPLANf
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
          CFI FunCall _Z18disable_e_steppersv
        BL       _Z18disable_e_steppersv
        MOVS     R0,#+100
          CFI FunCall _Z10safe_delaym
        BL       _Z10safe_delaym
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        MOV      R10,R0
        ADD      R10,R10,#+44800
        ADD      R10,R10,#+200
        MOVS     R4,#+0
        MOVS     R0,#+2
          CFI FunCall _Z32lcd_filament_change_show_message21FilamentChangeMessage
        BL       _Z32lcd_filament_change_show_message21FilamentChangeMessage
        MOVS     R0,#+1
          CFI FunCall _Z20filament_change_beepb
        BL       _Z20filament_change_beepb
        MOV      R0,R4
          CFI FunCall _Z4idleb
        BL       _Z4idleb
        MOV      R0,R4
        MOV      R2,SP
        B.N      ??gcode_M600_15
??gcode_M600_16:
        LDR.N    R1,??gcode_M600_0+0x20
        LDR      R1,[R1, R0, LSL #+2]
        STRH     R1,[R2, R0, LSL #+1]
        ADDS     R0,R0,#+1
        SXTB     R0,R0
??gcode_M600_15:
        CMP      R0,#+0
        BLE.N    ??gcode_M600_16
        MOVS     R0,#+3
        STRB     R0,[R5, #+6]
        MOVS     R0,#+1
        STRB     R0,[R5, #+4]
        B.N      ??gcode_M600_17
??gcode_M600_18:
        MOV      R1,R11
        UXTB     R1,R1
        MOVS     R0,#+0
          CFI FunCall _ZN11Temperature15setTargetHotendEfh
        BL       _ZN11Temperature15setTargetHotendEfh
        ADD      R11,R11,#+1
??gcode_M600_19:
        MOV      R0,R11
        SXTB     R0,R0
        CMP      R0,#+0
        BLE.N    ??gcode_M600_18
        MOVS     R0,#+8
          CFI FunCall _Z32lcd_filament_change_show_message21FilamentChangeMessage
        BL       _Z32lcd_filament_change_show_message21FilamentChangeMessage
??gcode_M600_20:
        MOVS     R0,#+1
          CFI FunCall _Z4idleb
        BL       _Z4idleb
??gcode_M600_17:
        LDRB     R0,[R5, #+4]
        CMP      R0,#+0
        BEQ.N    ??gcode_M600_21
        CMP      R4,#+0
        BEQ.N    ??gcode_M600_22
        MOVS     R0,#+8
          CFI FunCall _Z32lcd_filament_change_show_message21FilamentChangeMessage
        BL       _Z32lcd_filament_change_show_message21FilamentChangeMessage
??gcode_M600_22:
        MOVS     R0,#+0
          CFI FunCall _Z20filament_change_beepb
        BL       _Z20filament_change_beepb
        CMP      R4,#+0
        BNE.N    ??gcode_M600_20
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        SUBS     R0,R0,R10
        BMI.N    ??gcode_M600_20
        MOVS     R4,#+1
        MOV      R11,#+0
        B.N      ??gcode_M600_19
??gcode_M600_21:
        MOVS     R0,#+1
        STRB     R0,[R5, #+6]
        CMP      R4,#+0
        BEQ.N    ??gcode_M600_23
        MOV      R11,#+0
        B.N      ??gcode_M600_24
??gcode_M600_25:
        MOV      R0,R11
        MOV      R1,R0
        UXTB     R1,R1
        MOV      R10,R1
        MOV      R0,SP
        LDRSH    R0,[R0, R11, LSL #+1]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R10
          CFI FunCall _ZN11Temperature15setTargetHotendEfh
        BL       _ZN11Temperature15setTargetHotendEfh
        ADD      R11,R11,#+1
        SXTB     R11,R11
??gcode_M600_24:
        CMP      R11,#+0
        BLE.N    ??gcode_M600_25
??gcode_M600_23:
        MOVS     R0,#+9
          CFI FunCall _Z32lcd_filament_change_show_message21FilamentChangeMessage
        BL       _Z32lcd_filament_change_show_message21FilamentChangeMessage
        MOVS     R0,#+1
        STRB     R0,[R5, #+3]
        B.N      ??gcode_M600_26
??gcode_M600_27:
        ADD      R11,R11,#+1
        SXTB     R11,R11
??gcode_M600_28:
        CMP      R11,#+0
        BGT.N    ??gcode_M600_26
        MOV      R0,R11
        UXTB     R0,R0
          CFI FunCall _ZN11Temperature9degHotendEh
        BL       _ZN11Temperature9degHotendEh
        MOV      R10,R0
        MOV      R0,SP
        LDRSH    R0,[R0, R11, LSL #+1]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R10
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        BIC      R0,R0,#0x80000000
        LDR.N    R1,??gcode_M600_0+0x24  ;; 0x40400001
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_M600_27
        MOVS     R0,#+1
        STRB     R0,[R5, #+3]
??gcode_M600_26:
        LDRB     R0,[R5, #+3]
        CMP      R0,#+0
        BEQ.N    ??gcode_M600_29
        MOVS     R0,#+0
          CFI FunCall _Z4idleb
        BL       _Z4idleb
        MOVS     R0,#+0
        STRB     R0,[R5, #+3]
        MOV      R11,R0
        B.N      ??gcode_M600_28
??gcode_M600_29:
        CMP      R4,#+0
        BEQ.N    ??gcode_M600_30
        MOVS     R0,#+2
          CFI FunCall _Z32lcd_filament_change_show_message21FilamentChangeMessage
        BL       _Z32lcd_filament_change_show_message21FilamentChangeMessage
??gcode_M600_30:
        MOVS     R0,#+1
          CFI FunCall _Z20filament_change_beepb
        BL       _Z20filament_change_beepb
        MOVS     R0,#+3
        STRB     R0,[R5, #+6]
        MOVS     R0,#+1
        STRB     R0,[R5, #+4]
??gcode_M600_31:
        LDRB     R0,[R5, #+4]
        CMP      R0,#+0
        BEQ.N    ??gcode_M600_32
        CMP      R4,#+0
        BEQ.N    ??gcode_M600_32
        MOVS     R0,#+0
          CFI FunCall _Z20filament_change_beepb
        BL       _Z20filament_change_beepb
        MOVS     R0,#+1
          CFI FunCall _Z4idleb
        BL       _Z4idleb
        B.N      ??gcode_M600_31
??gcode_M600_33:
        MOVS     R1,#+0
??gcode_M600_34:
        LDR      R0,[R5, #+36]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+36]
        LDR.N    R0,??gcode_M600_0+0x28  ;; 0x40c00000
          CFI FunCall _Z7RUNPLANf
        BL       _Z7RUNPLANf
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
??gcode_M600_35:
        MOVS     R0,#+4
          CFI FunCall _Z32lcd_filament_change_show_message21FilamentChangeMessage
        BL       _Z32lcd_filament_change_show_message21FilamentChangeMessage
        LDR      R0,[R5, #+36]
        LDR.N    R1,??gcode_M600_0+0x2C  ;; 0x42480000
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+36]
        LDR.N    R0,??gcode_M600_0+0x30  ;; 0x40400000
          CFI FunCall _Z7RUNPLANf
        BL       _Z7RUNPLANf
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        MOVS     R0,#+3
        STRB     R0,[R5, #+6]
        MOVS     R0,#+0
        STRB     R0,[R5, #+4]
        MOVS     R0,#+5
          CFI FunCall _Z32lcd_filament_change_show_message21FilamentChangeMessage
        BL       _Z32lcd_filament_change_show_message21FilamentChangeMessage
        B.N      ??gcode_M600_36
??gcode_M600_37:
        MOVS     R0,#+1
          CFI FunCall _Z4idleb
        BL       _Z4idleb
??gcode_M600_36:
        LDRSB    R0,[R6, #+26]
        CMP      R0,#+0
        BEQ.N    ??gcode_M600_37
        MOVS     R1,#+1
        STRB     R1,[R5, #+6]
        CMP      R0,#+1
        BEQ.N    ??gcode_M600_35
        MOVS     R0,#+6
          CFI FunCall _Z32lcd_filament_change_show_message21FilamentChangeMessage
        BL       _Z32lcd_filament_change_show_message21FilamentChangeMessage
        LDR      R0,[SP, #+16]
        STR      R0,[R5, #+20]
        STR      R0,[R5, #+36]
        ADD      R0,R5,#+20
          CFI FunCall _ZN7Planner17set_e_position_mmERKf
        BL       _ZN7Planner17set_e_position_mmERKf
        LDR      R0,[R9, #+36]
        LDR.N    R1,??gcode_M600_0+0x10  ;; 0x42700000
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        LDRH     R1,[R9, #+88]
        MOVW     R2,#+770
        TST      R1,R2
        BEQ.N    ??gcode_M600_38
        STR      R0,[SP, #+20]
        LDRB     R2,[R5, #+2]
        ADD      R1,SP,#+20
        ADD      R0,SP,#+4
          CFI FunCall _ZN7Planner21buffer_line_kinematicEPKfRS0_h
        BL       _ZN7Planner21buffer_line_kinematicEPKfRS0_h
        B.N      ??gcode_M600_39
??gcode_M600_38:
        LDR      R1,[SP, #+4]
        STR      R1,[R5, #+24]
        ADD      R4,SP,#+4
        LDR      R1,[R4, #+4]
        STR      R1,[R5, #+28]
          CFI FunCall _Z7RUNPLANf
        BL       _Z7RUNPLANf
        LDR      R0,[R4, #+8]
        STR      R0,[R5, #+32]
        LDR      R0,[R9, #+40]
        LDR.N    R1,??gcode_M600_0+0x10  ;; 0x42700000
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
          CFI FunCall _Z7RUNPLANf
        BL       _Z7RUNPLANf
??gcode_M600_39:
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        MOVS     R0,#+0
        STRB     R0,[R6, #+13]
        MOVS     R0,#+7
          CFI FunCall _Z32lcd_filament_change_show_message21FilamentChangeMessage
        BL       _Z32lcd_filament_change_show_message21FilamentChangeMessage
        CMP      R8,#+0
        BEQ.N    ??gcode_M600_40
        MOV      R0,R7
          CFI FunCall _ZN9Stopwatch5startEv
        BL       _ZN9Stopwatch5startEv
??gcode_M600_40:
        MOVS     R0,#+0
        STRB     R0,[R6, #+15]
??gcode_M600_2:
        ADD      SP,SP,#+28
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
          CFI CFA R13+64
??gcode_M600_32:
        MOVS     R0,#+1
        STRB     R0,[R5, #+6]
        MOVS     R0,#+3
          CFI FunCall _Z32lcd_filament_change_show_message21FilamentChangeMessage
        BL       _Z32lcd_filament_change_show_message21FilamentChangeMessage
        MOVS     R0,#+76
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M600_33
          CFI FunCall _Z16code_value_floatv
        BL       _Z16code_value_floatv
        MOV      R1,R0
        EOR      R1,R1,#0x80000000
        B.N      ??gcode_M600_34
        DATA
??gcode_M600_0:
        DC32     mks_heating_busy
        DC32     errormagic
        DC32     _ZZ10gcode_M600vEs
        DC32     axis_relative_modes
        DC32     0x42700000
        DC32     mksCfg
        DC32     0xc2c80000
        DC32     0x41200000
        DC32     _ZN11Temperature18target_temperatureE
        DC32     0x40400001
        DC32     0x40c00000
        DC32     0x42480000
        DC32     0x40400000
          CFI EndBlock cfiBlock321

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M907v
          CFI Block cfiBlock322 Using cfiCommon0
          CFI Function _Z10gcode_M907v
          CFI NoCalls
        THUMB
_Z10gcode_M907v:
        BX       LR               ;; return
          CFI EndBlock cfiBlock322

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M355v
          CFI Block cfiBlock323 Using cfiCommon0
          CFI Function _Z10gcode_M355v
        THUMB
_Z10gcode_M355v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M355_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M355_0+0x4
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
        Nop      
        DATA
??gcode_M355_0:
        DC32     errormagic
        DC32     _ZZ10gcode_M355vEs
          CFI EndBlock cfiBlock323

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M999v
          CFI Block cfiBlock324 Using cfiCommon0
          CFI Function _Z10gcode_M999v
        THUMB
_Z10gcode_M999v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+1
        LDR.N    R1,??gcode_M999_0
        STRB     R0,[R1, #+0]
          CFI FunCall _Z21lcd_reset_alert_levelv
        BL       _Z21lcd_reset_alert_levelv
        MOVS     R0,#+83
          CFI FunCall _Z9code_seenc
        BL       _Z9code_seenc
        CMP      R0,#+0
        BEQ.N    ??gcode_M999_1
          CFI FunCall _Z15code_value_boolv
        BL       _Z15code_value_boolv
        CMP      R0,#+0
        BNE.N    ??gcode_M999_2
??gcode_M999_1:
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z24FlushSerialRequestResendv
        B.W      _Z24FlushSerialRequestResendv
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M999_2:
        POP      {R0,PC}          ;; return
        DATA
??gcode_M999_0:
        DC32     Running
          CFI EndBlock cfiBlock324

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z7gcode_Th
          CFI Block cfiBlock325 Using cfiCommon0
          CFI Function _Z7gcode_Th
        THUMB
_Z7gcode_Th:
        MOVS     R2,#+0
        MOV      R1,R2
          CFI FunCall _Z11tool_changehfb
        B.W      _Z11tool_changehfb
          CFI EndBlock cfiBlock325

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z25prepare_kinematic_move_toPf
          CFI Block cfiBlock326 Using cfiCommon0
          CFI Function _Z25prepare_kinematic_move_toPf
        THUMB
_Z25prepare_kinematic_move_toPf:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        SUB      SP,SP,#+84
          CFI CFA R13+120
        MOV      R4,R0
        LDR.W    R5,??prepare_kinematic_move_to_0
        LDR      R0,[R5, #+120]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R5, #+116]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??prepare_kinematic_move_to_0+0x4  ;; 0x47ae147b
        LDR.W    R3,??prepare_kinematic_move_to_0+0x8  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+8]
        LDR      R0,[R4, #+0]
        LDR      R1,[R5, #+8]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??prepare_kinematic_move_to_1
        LDR      R0,[R4, #+4]
        LDR      R1,[R5, #+12]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??prepare_kinematic_move_to_1
        LDRB     R2,[R5, #+2]
        ADD      R1,SP,#+8
        MOV      R0,R4
          CFI FunCall _ZN7Planner21buffer_line_kinematicEPKfRS0_h
        BL       _ZN7Planner21buffer_line_kinematicEPKfRS0_h
        MOVS     R0,#+0
        B.N      ??prepare_kinematic_move_to_2
??prepare_kinematic_move_to_1:
        MOVS     R6,#+0
        B.N      ??prepare_kinematic_move_to_3
??prepare_kinematic_move_to_4:
        LDR      R0,[R4, R6, LSL #+2]
        ADD      R1,R5,#+8
        LDR      R1,[R1, R6, LSL #+2]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        ADD      R1,SP,#+68
        STR      R0,[R1, R6, LSL #+2]
        ADDS     R6,R6,#+1
??prepare_kinematic_move_to_3:
        CMP      R6,#+4
        BLT.N    ??prepare_kinematic_move_to_4
        STR      R4,[SP, #+44]
        LDR      R7,[SP, #+68]
        MOVS     R6,#+2
        MOV      R4,#+1065353216
        B.N      ??prepare_kinematic_move_to_5
??prepare_kinematic_move_to_6:
        MOV      R0,R7
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??prepare_kinematic_move_to_5:
        LSLS     R0,R6,#+31
        BPL.N    ??prepare_kinematic_move_to_7
        MOV      R0,R4
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
??prepare_kinematic_move_to_7:
        LSRS     R6,R6,#+1
        BNE.N    ??prepare_kinematic_move_to_6
        LDR      R8,[SP, #+72]
        MOVS     R7,#+2
        MOV      R6,#+1065353216
        B.N      ??prepare_kinematic_move_to_8
??prepare_kinematic_move_to_9:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??prepare_kinematic_move_to_8:
        LSLS     R0,R7,#+31
        BPL.N    ??prepare_kinematic_move_to_10
        MOV      R0,R6
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
??prepare_kinematic_move_to_10:
        LSRS     R7,R7,#+1
        BNE.N    ??prepare_kinematic_move_to_9
        ADD      R8,SP,#+68
        LDR      R9,[R8, #+8]
        MOV      R10,R9
        MOVS     R7,#+2
        MOV      R11,#+1065353216
        B.N      ??prepare_kinematic_move_to_11
??prepare_kinematic_move_to_12:
        MOV      R0,R10
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??prepare_kinematic_move_to_11:
        LSLS     R0,R7,#+31
        BPL.N    ??prepare_kinematic_move_to_13
        MOV      R0,R11
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??prepare_kinematic_move_to_13:
        LSRS     R7,R7,#+1
        BNE.N    ??prepare_kinematic_move_to_12
        MOV      R0,R4
        MOV      R1,R6
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R4,R0
        LDR.W    R1,??prepare_kinematic_move_to_0+0xC  ;; 0x358637be
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??prepare_kinematic_move_to_14
        LDR      R0,[R8, #+12]
        BIC      R4,R0,#0x80000000
??prepare_kinematic_move_to_14:
        MOV      R0,R4
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??prepare_kinematic_move_to_15
        MOVS     R0,#+1
        B.N      ??prepare_kinematic_move_to_2
??prepare_kinematic_move_to_15:
        LDR.W    R6,??prepare_kinematic_move_to_0+0x10
        LDR      R1,[SP, #+8]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        LDR      R1,[R6, #+88]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R7,R0
        UXTH     R7,R7
        LDR.W    R0,??prepare_kinematic_move_to_0+0x14
        LDRH     R0,[R0, #+88]
        TST      R0,#0x300
        BEQ.N    ??prepare_kinematic_move_to_16
        MOV      R0,#+1082130432
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
        MOV      R0,R7
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R1,R0
        MOV      R0,R10
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??prepare_kinematic_move_to_16
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R7,R0
        UXTH     R7,R7
??prepare_kinematic_move_to_16:
        CMP      R7,#+0
        BNE.N    ??prepare_kinematic_move_to_17
        MOVS     R7,#+1
??prepare_kinematic_move_to_17:
        MOV      R0,R7
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R10,R0
        MOV      R0,#+1065353216
        MOV      R1,R10
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R11,R0
        LDR      R0,[SP, #+68]
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[SP, #+52]
        LDR      R0,[R8, #+4]
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[SP, #+56]
        MOV      R0,R9
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[SP, #+60]
        LDR      R0,[R8, #+12]
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[SP, #+64]
        MOV      R0,R10
        MOV      R1,R4
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R4,R0
        LDR.N    R1,??prepare_kinematic_move_to_0+0x18  ;; 0x41200001
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??prepare_kinematic_move_to_18
        LDR.N    R4,??prepare_kinematic_move_to_0+0x1C  ;; 0x41200000
??prepare_kinematic_move_to_18:
        LDR      R0,[SP, #+8]
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[SP, #+48]
        MOVS     R0,#+0
          CFI FunCall _ZN7Stepper25get_axis_position_degreesE8AxisEnum
        BL       _ZN7Stepper25get_axis_position_degreesE8AxisEnum
        STR      R0,[SP, #+40]
        MOVS     R0,#+1
          CFI FunCall _ZN7Stepper25get_axis_position_degreesE8AxisEnum
        BL       _ZN7Stepper25get_axis_position_degreesE8AxisEnum
        STR      R0,[SP, #+36]
        MOVS     R2,#+16
        ADD      R1,R5,#+8
        ADD      R0,SP,#+20
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        STRH     R7,[SP, #+12]
        B.N      ??prepare_kinematic_move_to_19
??prepare_kinematic_move_to_20:
        MOV      R7,R0
??prepare_kinematic_move_to_21:
        LDR      R0,[SP, #+48]
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[SP, #+16]
        LDRB     R0,[R5, #+2]
        STR      R0,[SP, #+4]
        ADD      R0,SP,#+16
        STR      R0,[SP, #+0]
        ADD      R3,SP,#+32
        LDR      R2,[R5, #+112]
        MOV      R1,R4
        MOV      R0,R8
          CFI FunCall _ZN7Planner11buffer_lineEfffRKfS1_h
        BL       _ZN7Planner11buffer_lineEfffRKfS1_h
        LDR      R0,[R5, #+104]
        STR      R0,[SP, #+40]
        LDR      R0,[R5, #+108]
        STR      R0,[SP, #+36]
??prepare_kinematic_move_to_19:
        LDRH     R0,[SP, #+12]
        SUBS     R0,R0,#+1
        STRH     R0,[SP, #+12]
        LDRH     R0,[SP, #+12]
        CMP      R0,#+0
        BEQ.W    ??prepare_kinematic_move_to_22
        MOVS     R4,#+0
        ADD      R7,SP,#+20
        B.N      ??prepare_kinematic_move_to_23
??prepare_kinematic_move_to_24:
        LDR      R0,[R7, R4, LSL #+2]
        ADD      R1,SP,#+52
        LDR      R1,[R1, R4, LSL #+2]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R7, R4, LSL #+2]
        ADDS     R4,R4,#+1
??prepare_kinematic_move_to_23:
        CMP      R4,#+4
        BLT.N    ??prepare_kinematic_move_to_24
        LDR.N    R7,??prepare_kinematic_move_to_0+0x14
        LDRSH    R0,[R7, #+88]
        CMP      R0,#+2
        BNE.W    ??prepare_kinematic_move_to_25
        LDR      R0,[SP, #+20]
        LDR      R1,[R5, #+68]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+16]
        ADD      R4,SP,#+20
        LDR      R0,[R4, #+4]
        LDR      R1,[R5, #+72]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+4]
        LDR      R0,[R4, #+8]
        LDR      R1,[R5, #+76]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+0]
        LDR      R0,[R6, #+4]
        LDR      R1,[SP, #+16]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R10,R0
        MOVS     R4,#+2
        MOV      R8,#+1065353216
        MOV      R9,R8
        B.N      ??prepare_kinematic_move_to_26
??prepare_kinematic_move_to_27:
        MOV      R0,R10
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??prepare_kinematic_move_to_26:
        LSLS     R0,R4,#+31
        BPL.N    ??prepare_kinematic_move_to_28
        MOV      R0,R9
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??prepare_kinematic_move_to_28:
        LSRS     R4,R4,#+1
        BNE.N    ??prepare_kinematic_move_to_27
        LDR      R0,[R6, #+8]
        LDR      R1,[SP, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R10,R0
        MOVS     R4,#+2
        MOV      R11,R8
        B.N      ??prepare_kinematic_move_to_29
??prepare_kinematic_move_to_30:
        MOV      R0,R10
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??prepare_kinematic_move_to_29:
        LSLS     R0,R4,#+31
        BPL.N    ??prepare_kinematic_move_to_31
        MOV      R0,R11
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??prepare_kinematic_move_to_31:
        LSRS     R4,R4,#+1
        BNE.N    ??prepare_kinematic_move_to_30
        MOV      R0,R9
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        LDR      R0,[R6, #+28]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R1,R0
        LDR      R0,[SP, #+0]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+104]
        LDR      R0,[R6, #+12]
        LDR      R1,[SP, #+16]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R10,R0
        MOVS     R4,#+2
        MOV      R9,R8
        B.N      ??prepare_kinematic_move_to_32
??prepare_kinematic_move_to_33:
        MOV      R0,R10
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??prepare_kinematic_move_to_32:
        LSLS     R0,R4,#+31
        BPL.N    ??prepare_kinematic_move_to_34
        MOV      R0,R9
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??prepare_kinematic_move_to_34:
        LSRS     R4,R4,#+1
        BNE.N    ??prepare_kinematic_move_to_33
        LDR      R0,[R6, #+16]
        LDR      R1,[SP, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R10,R0
        MOVS     R4,#+2
        MOV      R11,R8
        B.N      ??prepare_kinematic_move_to_35
??prepare_kinematic_move_to_36:
        MOV      R0,R10
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??prepare_kinematic_move_to_35:
        LSLS     R0,R4,#+31
        BPL.N    ??prepare_kinematic_move_to_37
        MOV      R0,R11
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??prepare_kinematic_move_to_37:
        LSRS     R4,R4,#+1
        BNE.N    ??prepare_kinematic_move_to_36
        MOV      R0,R9
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        LDR      R0,[R6, #+32]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R1,R0
        LDR      R0,[SP, #+0]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+108]
        LDR      R0,[R6, #+20]
        LDR      R1,[SP, #+16]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R10,R0
        MOVS     R4,#+2
        MOV      R9,R8
        B.N      ??prepare_kinematic_move_to_38
??prepare_kinematic_move_to_39:
        MOV      R0,R10
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??prepare_kinematic_move_to_38:
        LSLS     R0,R4,#+31
        BPL.N    ??prepare_kinematic_move_to_40
        MOV      R0,R9
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??prepare_kinematic_move_to_40:
        LSRS     R4,R4,#+1
        BNE.N    ??prepare_kinematic_move_to_39
        LDR      R0,[R6, #+24]
        LDR      R1,[SP, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R10,R0
        MOVS     R4,#+2
        B.N      ??prepare_kinematic_move_to_41
??prepare_kinematic_move_to_42:
        MOV      R0,R10
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??prepare_kinematic_move_to_41:
        LSLS     R0,R4,#+31
        BPL.N    ??prepare_kinematic_move_to_43
        MOV      R0,R8
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??prepare_kinematic_move_to_43:
        LSRS     R4,R4,#+1
        BNE.N    ??prepare_kinematic_move_to_42
        MOV      R0,R9
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        LDR      R0,[R6, #+36]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R1,R0
        LDR      R0,[SP, #+0]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+112]
        B.N      ??prepare_kinematic_move_to_44
??prepare_kinematic_move_to_25:
        CMP      R0,#+256
        ADD      R0,SP,#+20
        BNE.N    ??prepare_kinematic_move_to_45
          CFI FunCall _Z31inverse_kinematics_MORGAN_SCARAPKf
        BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
        B.N      ??prepare_kinematic_move_to_44
??prepare_kinematic_move_to_45:
          CFI FunCall _Z18inverse_kinematicsPKf
        BL       _Z18inverse_kinematicsPKf
??prepare_kinematic_move_to_44:
        ADD      R0,SP,#+20
          CFI FunCall _Z12ADJUST_DELTAPKf
        BL       _Z12ADJUST_DELTAPKf
        LDR      R4,[R5, #+108]
        LDR      R8,[R5, #+104]
        LDRH     R0,[R7, #+88]
        TST      R0,#0x300
        BEQ.N    ??prepare_kinematic_move_to_46
        MOV      R0,R8
        LDR      R1,[SP, #+40]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        BIC      R7,R0,#0x80000000
        MOV      R0,R4
        LDR      R1,[SP, #+36]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        BIC      R0,R0,#0x80000000
        MOV      R1,R7
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.W    ??prepare_kinematic_move_to_20
        B.N      ??prepare_kinematic_move_to_21
??prepare_kinematic_move_to_46:
        LDRB     R0,[R5, #+2]
        STR      R0,[SP, #+4]
        ADD      R0,SP,#+8
        STR      R0,[SP, #+0]
        ADD      R3,SP,#+32
        LDR      R2,[R5, #+112]
        MOV      R1,R4
        MOV      R0,R8
          CFI FunCall _ZN7Planner11buffer_lineEfffRKfS1_h
        BL       _ZN7Planner11buffer_lineEfffRKfS1_h
        B.N      ??prepare_kinematic_move_to_19
??prepare_kinematic_move_to_22:
        LDR.N    R0,??prepare_kinematic_move_to_0+0x14
        LDRSH    R0,[R0, #+88]
        TST      R0,#0x300
        BEQ.N    ??prepare_kinematic_move_to_47
        CMP      R0,#+256
        LDR      R0,[SP, #+44]
        BNE.N    ??prepare_kinematic_move_to_48
          CFI FunCall _Z31inverse_kinematics_MORGAN_SCARAPKf
        BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
        B.N      ??prepare_kinematic_move_to_49
??prepare_kinematic_move_to_48:
          CFI FunCall _Z18inverse_kinematicsPKf
        BL       _Z18inverse_kinematicsPKf
??prepare_kinematic_move_to_49:
        ADD      R0,SP,#+20
          CFI FunCall _Z12ADJUST_DELTAPKf
        BL       _Z12ADJUST_DELTAPKf
        LDR      R4,[R5, #+104]
        MOV      R0,R4
        LDR      R1,[SP, #+40]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        BIC      R6,R0,#0x80000000
        LDR      R7,[R5, #+108]
        MOV      R0,R7
        LDR      R1,[SP, #+36]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        BIC      R0,R0,#0x80000000
        MOV      R1,R6
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??prepare_kinematic_move_to_50
        MOV      R6,R0
??prepare_kinematic_move_to_50:
        LDR      R0,[SP, #+48]
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[SP, #+12]
        LDRB     R0,[R5, #+2]
        STR      R0,[SP, #+4]
        ADD      R0,SP,#+12
        STR      R0,[SP, #+0]
        ADD      R3,SP,#+32
        LDR      R2,[R5, #+112]
        MOV      R1,R7
        MOV      R0,R4
          CFI FunCall _ZN7Planner11buffer_lineEfffRKfS1_h
        BL       _ZN7Planner11buffer_lineEfffRKfS1_h
        B.N      ??prepare_kinematic_move_to_51
??prepare_kinematic_move_to_47:
        LDRB     R2,[R5, #+2]
        ADD      R1,SP,#+8
        LDR      R0,[SP, #+44]
          CFI FunCall _ZN7Planner21buffer_line_kinematicEPKfRS0_h
        BL       _ZN7Planner21buffer_line_kinematicEPKfRS0_h
??prepare_kinematic_move_to_51:
        MOVS     R0,#+0
??prepare_kinematic_move_to_2:
        ADD      SP,SP,#+84
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
        Nop      
        DATA
??prepare_kinematic_move_to_0:
        DC32     mks_heating_busy
        DC32     0x47ae147b
        DC32     0x3f847ae1
        DC32     0x358637be
        DC32     axis_homed
        DC32     mksCfg
        DC32     0x41200001
        DC32     0x41200000
          CFI EndBlock cfiBlock326

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z37prepare_move_to_destination_cartesianv
          CFI Block cfiBlock327 Using cfiCommon0
          CFI Function _Z37prepare_move_to_destination_cartesianv
        THUMB
_Z37prepare_move_to_destination_cartesianv:
        PUSH     {R2-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+24
        LDR.N    R4,??prepare_move_to_destination_cartesian_0
        LDR      R0,[R4, #+8]
        LDR      R1,[R4, #+24]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??prepare_move_to_destination_cartesian_1
        LDR      R0,[R4, #+12]
        LDR      R1,[R4, #+28]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??prepare_move_to_destination_cartesian_1
          CFI FunCall _Z19line_to_destinationv
        BL       _Z19line_to_destinationv
        B.N      ??prepare_move_to_destination_cartesian_2
??prepare_move_to_destination_cartesian_1:
        LDR.N    R0,??prepare_move_to_destination_cartesian_0+0x4
        LDRB     R0,[R0, #+64]
        CMP      R0,#+32
        BNE.N    ??prepare_move_to_destination_cartesian_3
          CFI FunCall _ZN17mesh_bed_leveling6activeEv
        BL       _ZN17mesh_bed_leveling6activeEv
        CMP      R0,#+0
        BEQ.N    ??prepare_move_to_destination_cartesian_4
        MOVS     R2,#+255
        MOV      R1,R2
        MOV      R5,R1
        MOV      R6,R2
        LDR      R0,[R4, #+120]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R4, #+116]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??prepare_move_to_destination_cartesian_0+0x8  ;; 0x47ae147b
        LDR.N    R3,??prepare_move_to_destination_cartesian_0+0xC  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R2,R6
        MOV      R1,R5
          CFI FunCall _Z24mesh_line_to_destinationfhh
        BL       _Z24mesh_line_to_destinationfhh
        MOVS     R0,#+1
        POP      {R1,R2,R4-R6,PC}
??prepare_move_to_destination_cartesian_3:
        CMP      R0,#+16
        BNE.N    ??prepare_move_to_destination_cartesian_5
        LDR.N    R0,??prepare_move_to_destination_cartesian_0+0x10
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??prepare_move_to_destination_cartesian_4
        LDR      R0,[R4, #+120]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R4, #+116]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??prepare_move_to_destination_cartesian_0+0x8  ;; 0x47ae147b
        LDR.N    R3,??prepare_move_to_destination_cartesian_0+0xC  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+0]
        LDRB     R1,[R4, #+2]
        MOV      R0,SP
          CFI FunCall _Z23ubl_line_to_destinationRKfh
        BL       _Z23ubl_line_to_destinationRKfh
        MOVS     R0,#+1
        POP      {R1,R2,R4-R6,PC}
??prepare_move_to_destination_cartesian_5:
        CMP      R0,#+8
        BNE.N    ??prepare_move_to_destination_cartesian_4
        LDR.N    R0,??prepare_move_to_destination_cartesian_0+0x14
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??prepare_move_to_destination_cartesian_4
        MOVW     R1,#+65535
        MOV      R2,R1
        MOV      R5,R2
        LDR      R0,[R4, #+120]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R4, #+116]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??prepare_move_to_destination_cartesian_0+0x8  ;; 0x47ae147b
        LDR.N    R3,??prepare_move_to_destination_cartesian_0+0xC  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R2,R5
        MOV      R1,R5
          CFI FunCall _Z28bilinear_line_to_destinationftt
        BL       _Z28bilinear_line_to_destinationftt
        MOVS     R0,#+1
        POP      {R1,R2,R4-R6,PC}
??prepare_move_to_destination_cartesian_4:
        LDR      R0,[R4, #+120]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R4, #+116]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??prepare_move_to_destination_cartesian_0+0x8  ;; 0x47ae147b
        LDR.N    R3,??prepare_move_to_destination_cartesian_0+0xC  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
          CFI FunCall _Z19line_to_destinationf
        BL       _Z19line_to_destinationf
??prepare_move_to_destination_cartesian_2:
        MOVS     R0,#+0
        POP      {R1,R2,R4-R6,PC}  ;; return
        Nop      
        DATA
??prepare_move_to_destination_cartesian_0:
        DC32     mks_heating_busy
        DC32     mksCfg
        DC32     0x47ae147b
        DC32     0x3f847ae1
        DC32     _ZN20unified_bed_leveling5stateE
        DC32     _ZN7Planner11abl_enabledE
          CFI EndBlock cfiBlock327

        SECTION `.iar_vfe_vtableinfo_ZTV6Buzzer`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        SECTION_GROUP _ZTV6Buzzer
        DATA
        DC32    _ZTV6Buzzer
        DC32    3
        DC32    1
        DC32    _ZTI6Buzzer
        DC32    1
        DC32    2
        DC32    0

        SECTION `.init_array`:CODE:ROOT(2)
        SECTION_TYPE SHT_INIT_ARRAY, 0
        DATA
        DC32    RELOC_ARM_TARGET1 __sti__routine

        SECTION `.iar_vfe_vcallinfo_ZN6Buzzer4toneERKtS1_`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        SECTION_GROUP _ZN6Buzzer4toneERKtS1_
        DATA
        DC32    _ZN6Buzzer4toneERKtS1_
        DC32    0
        DC32    0
        DC32    1
        DC32    _ZTI6Buzzer
        DC32    1
        DC32    1
        DC32    0
        DC32    0

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        END
// 13904 
// 13905 /**
// 13906  * The main Marlin program loop
// 13907  *
// 13908  *  - Save or log commands to SD
// 13909  *  - Process available commands (if not saving)
// 13910  *  - Call heater manager
// 13911  *  - Call inactivity manager
// 13912  *  - Call endstop manager
// 13913  *  - Call LCD update
// 13914  */
// 13915 void loop() {
// 13916   if (commands_in_queue < BUFSIZE) 
// 13917     get_available_commands();
// 13918 
// 13919   #if ENABLED(SDSUPPORT)
// 13920     card.checkautostart(false);
// 13921   #endif
// 13922 
// 13923   if (commands_in_queue) {
// 13924 
// 13925     #if ENABLED(SDSUPPORT)
// 13926 	
// 13927       if (card.saving) {
// 13928         char* command = command_queue[cmd_queue_index_r];
// 13929         if (strstr_P(command, PSTR("M29"))) {
// 13930           // M29 closes the file
// 13931           card.closefile();
// 13932           SERIAL_PROTOCOLLNPGM(MSG_FILE_SAVED);
// 13933           ok_to_send();
// 13934           BLINK_LED(LED_ON);
// 13935         }
// 13936         else {
// 13937           // Write the string from the read buffer to SD
// 13938           card.write_command(command);
// 13939           if (card.logging)
// 13940             process_next_command(); // The card is saving because it's logging
// 13941           else
// 13942             ok_to_send();
// 13943         }
// 13944       }
// 13945       else
// 13946         process_next_command();
// 13947 
// 13948     #else
// 13949 
// 13950       process_next_command();
// 13951 
// 13952     #endif // SDSUPPORT
// 13953 
// 13954     // The queue may be reset by a command handler or by code invoked by idle() within a handler
// 13955     if (commands_in_queue) {
// 13956       --commands_in_queue;
// 13957       if (++cmd_queue_index_r >= BUFSIZE) cmd_queue_index_r = 0;
// 13958     }
// 13959   }
// 13960   endstops.report_state();
// 13961   idle();
// 13962 //#if MASK_FOR_SPACE
// 13963   mks_PrintStatePolling();
// 13964 //#endif
// 13965 }
// 13966 
// 13967 
// 13968 #include "mks_reprint.cpp"
// 
//  3 581 bytes in section .bss
//  1 333 bytes in section .data
//      4 bytes in section .init_array
//  3 043 bytes in section .rodata
// 45 272 bytes in section .text
// 
// 23 214 bytes of CODE  memory (+ 22 062 bytes shared)
//    125 bytes of CONST memory (+  2 918 bytes shared)
//  4 709 bytes of DATA  memory (+    205 bytes shared)
//
//Errors: none
//Warnings: 72
