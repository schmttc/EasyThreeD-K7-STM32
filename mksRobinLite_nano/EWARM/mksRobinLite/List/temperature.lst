###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.1.114/W32 for ARM         07/May/2021  14:21:35
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\temperature.cpp
#    Command line =  
#        -f C:\Users\PLT\AppData\Local\Temp\EWFD42.tmp
#        (C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\temperature.cpp
#        -D USE_HAL_DRIVER -D STM32F103xE -D MKS_ROBIN -D MARLIN -D __arm__ -D
#        USE_MKS_WIFI --preprocess=s
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List -lC
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List -lA
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List
#        --diag_suppress Pa050 -o
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.1\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Inc\ -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Src\ -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/Inc\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/CMSIS/Include\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/STM32MKS-3dPrinter\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/Common\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/l6474\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/MotorControl\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/u8glib_arm_v1.17/src\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/arduino\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/arduino/avr\
#        -I C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Inc/Logo\ -Om --c++
#        --no_exceptions --no_rtti -I "D:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.1\arm\CMSIS\Core\Include\" -I "D:\Program
#        Files (x86)\IAR Systems\Embedded Workbench
#        8.1\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List\temperature.lst
#    Object file  =  
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\Obj\temperature.o
#
###############################################################################

C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\temperature.cpp
      1          /**
      2           * Marlin 3D Printer Firmware
      3           * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
      4           *
      5           * Based on Sprinter and grbl.
      6           * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
      7           *
      8           * This program is free software: you can redistribute it and/or modify
      9           * it under the terms of the GNU General Public License as published by
     10           * the Free Software Foundation, either version 3 of the License, or
     11           * (at your option) any later version.
     12           *
     13           * This program is distributed in the hope that it will be useful,
     14           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     15           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     16           * GNU General Public License for more details.
     17           *
     18           * You should have received a copy of the GNU General Public License
     19           * along with this program.  If not, see <http://www.gnu.org/licenses/>.
     20           *
     21           */
     22          
     23          /**
     24           * temperature.cpp - temperature control
     25           */
     26          
     27          #include "Marlin.h"

    #define SDSS   18
            ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\pins_MKS_ROBIN_LITE.h",161  Warning[Pa181]: 
          incompatible redefinition of macro "SDSS" (declared at line 62)

  #define UNUSED(x) ((void)(x))
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_def.h",87  Warning[Pa181]: 
          incompatible redefinition of macro "UNUSED" (declared at line 88 of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marl
          in\macros.h")

   \                                 In section .text, align 2
   \   __interwork __softfp void MarlinSerial::write(uint8_t)
   \                     _ZN12MarlinSerial5writeEh: (+1)
   \        0x0   0xB502             PUSH     {R1,LR}
   \        0x2   0x2201             MOVS     R2,#+1
   \        0x4   0x4669             MOV      R1,SP
   \        0x6   0x.... 0x....      BL       BSP_UartIfQueueTxData
   \        0xA   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void MarlinSerial::write(char const *)
   \                     _ZN12MarlinSerial5writeEPKc: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4628             MOV      R0,R5
   \        0x8   0x.... 0x....      BL       strlen
   \        0xC   0x4602             MOV      R2,R0
   \        0xE   0xB2D2             UXTB     R2,R2
   \       0x10   0x4629             MOV      R1,R5
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0xE8BD 0x4038      POP      {R3-R5,LR}
   \       0x18   0x.... 0x....      B.W      BSP_UartIfQueueTxData

   \                                 In section .text, align 4
   \   __interwork __softfp void MarlinSerial::print(char const *)
   \                     _ZN12MarlinSerial5printEPKc: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4628             MOV      R0,R5
   \        0x8   0x.... 0x....      BL       strlen
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD013             BEQ.N    ??print_1
   \       0x10   0x480A             LDR.N    R0,??print_0
   \       0x12   0x7800             LDRB     R0,[R0, #+0]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD105             BNE.N    ??print_2
   \       0x18   0x4629             MOV      R1,R5
   \       0x1A   0x4620             MOV      R0,R4
   \       0x1C   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \       0x20   0x.... 0x....      B.W      _ZN12MarlinSerial5writeEPKc
   \                     ??print_2: (+1)
   \       0x24   0x4628             MOV      R0,R5
   \       0x26   0x.... 0x....      BL       strlen
   \       0x2A   0x4602             MOV      R2,R0
   \       0x2C   0x4629             MOV      R1,R5
   \       0x2E   0x2002             MOVS     R0,#+2
   \       0x30   0xE8BD 0x4038      POP      {R3-R5,LR}
   \       0x34   0x.... 0x....      B.W      package_to_wifi
   \                     ??print_1: (+1)
   \       0x38   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \       0x3A   0xBF00             Nop      
   \                     ??print_0:
   \       0x3C   0x....'....        DC32     from_wifi_flag

   \                                 In section .text, align 4
   \   __interwork __softfp void serialprintPGM(char const *)
   \                     _Z14serialprintPGMPKc: (+1)
   \        0x0   0x4601             MOV      R1,R0
   \        0x2   0x4805             LDR.N    R0,??serialprintPGM_0
   \        0x4   0x7800             LDRB     R0,[R0, #+0]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD102             BNE.N    ??serialprintPGM_1
   \        0xA   0x4804             LDR.N    R0,??serialprintPGM_0+0x4
   \        0xC   0x.... 0x....      B.W      _ZN12MarlinSerial5writeEPKc
   \                     ??serialprintPGM_1: (+1)
   \       0x10   0x4803             LDR.N    R0,??serialprintPGM_0+0x8
   \       0x12   0x.... 0x....      B.W      _ZN12MarlinSerial5printEPKc
   \       0x16   0xBF00             Nop      
   \                     ??serialprintPGM_0:
   \       0x18   0x....'....        DC32     from_wifi_flag
   \       0x1C   0x....'....        DC32     customizedSerial
   \       0x20   0x....'....        DC32     serial2

  #define PRINT_LED_PIN         PDout(2)
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\BSP\STM32MKS-3dPrinter\mks_fastio.h",14  Warning[Pa181]: 
          incompatible redefinition of macro "PRINT_LED_PIN" (declared at line
          146 of "C:\Users\PLT\Desktop\mksRobinLite_nano\Inc\main.h")

   \                                 In section .text, align 4
   \   __interwork __softfp bool IsRunning()
   \                     _Z9IsRunningv: (+1)
   \        0x0   0x4801             LDR.N    R0,??IsRunning_0
   \        0x2   0x7800             LDRB     R0,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return
   \        0x6   0xBF00             Nop      
   \                     ??IsRunning_0:
   \        0x8   0x....'....        DC32     Running
     28          #include "temperature.h"

   \                                 In section .text, align 4, keep-with-next
   \   static __absolute short const temptable_1[64][2]
   \                     temptable_1:
   \        0x0   0x0170 0x0122      DC16 368, 290, 400, 285, 432, 280, 448, 275, 496, 270, 528, 265, 560
   \               0x0190 0x011
   \              D 0x01B0 0x01
   \              18 0x01C0 0x0
   \              113 0x01F0 0x
   \              010E 0x0210 0
   \              x0109 0x0230 
   \       0x1A   0x0104 0x0260      DC16 260, 608, 255, 656, 250, 704, 245, 768, 240, 832, 235, 896, 230
   \               0x00FF 0x029
   \              0 0x00FA 0x02
   \              C0 0x00F5 0x0
   \              300 0x00F0 0x
   \              0340 0x00EB 0
   \              x0380 0x00E6 
   \       0x34   0x03D0 0x00E1      DC16 976, 225, 1056, 220, 1136, 215, 1248, 210, 1344, 205, 1472, 200
   \               0x0420 0x00D
   \              C 0x0470 0x00
   \              D7 0x04E0 0x0
   \              0D2 0x0540 0x
   \              00CD 0x05C0 0
   \              x00C8        
   \       0x4C   0x0640 0x00C3      DC16 1600, 195, 1744, 190, 1920, 185, 2096, 180, 2288, 175, 2496, 170
   \               0x06D0 0x00B
   \              E 0x0780 0x00
   \              B9 0x0830 0x0
   \              0B4 0x08F0 0x
   \              00AF 0x09C0 0
   \              x00AA        
   \       0x64   0x0AB0 0x00A5      DC16 2736, 165, 2992, 160, 3280, 155, 3584, 150, 3920, 145, 4288, 140
   \               0x0BB0 0x00A
   \              0 0x0CD0 0x00
   \              9B 0x0E00 0x0
   \              096 0x0F50 0x
   \              0091 0x10C0 0
   \              x008C        
   \       0x7C   0x1250 0x0087      DC16 4688, 135, 5120, 130, 5568, 125, 6064, 120, 6576, 115, 7120, 110
   \               0x1400 0x008
   \              2 0x15C0 0x00
   \              7D 0x17B0 0x0
   \              078 0x19B0 0x
   \              0073 0x1BD0 0
   \              x006E        
   \       0x94   0x1E00 0x0069      DC16 7680, 105, 8256, 100, 8848, 95, 9456, 90, 10048, 85, 10640, 80
   \               0x2040 0x006
   \              4 0x2290 0x00
   \              5F 0x24F0 0x0
   \              05A 0x2740 0x
   \              0055 0x2990 0
   \              x0050        
   \       0xAC   0x2BE0 0x004B      DC16 11232, 75, 11792, 70, 12320, 65, 12816, 60, 13280, 55, 13712, 50
   \               0x2E10 0x004
   \              6 0x3020 0x00
   \              41 0x3210 0x0
   \              03C 0x33E0 0x
   \              0037 0x3590 0
   \              x0032        
   \       0xC4   0x3710 0x002D      DC16 14096, 45, 14448, 40, 14752, 35, 15024, 30, 15264, 25, 15456, 20
   \               0x3870 0x002
   \              8 0x39A0 0x00
   \              23 0x3AB0 0x0
   \              01E 0x3BA0 0x
   \              0019 0x3C60 0
   \              x0014        
   \       0xDC   0x3D10 0x000F      DC16 15632, 15, 15760, 10, 15888, 5, 15984, 0, 16064, -5, 16128, -10
   \               0x3D90 0x000
   \              A 0x3E10 0x00
   \              05 0x3E70 0x0
   \              000 0x3EC0 0x
   \              FFFB 0x3F00 0
   \              xFFF6        
   \       0xF4   0x3F40 0xFFF1      DC16 16192, -15, 16256, -20, 16320, -25
   \               0x3F80 0xFFE
   \              C 0x3FC0 0xFF
   \              E7           

   \                                 In section .text, align 4
   \   __interwork __softfp float Temperature::degHotend(uint8_t)
   \                     _ZN11Temperature9degHotendEh: (+1)
   \        0x0   0x4801             LDR.N    R0,??degHotend_0
   \        0x2   0x69C0             LDR      R0,[R0, #+28]
   \        0x4   0x4770             BX       LR               ;; return
   \        0x6   0xBF00             Nop      
   \                     ??degHotend_0:
   \        0x8   0x....'....        DC32     _ZN11Temperature12soft_pwm_bedE

   \                                 In section .text, align 4
   \   __interwork __softfp float Temperature::degBed()
   \                     _ZN11Temperature6degBedEv: (+1)
   \        0x0   0x4801             LDR.N    R0,??degBed_0
   \        0x2   0x6A00             LDR      R0,[R0, #+32]
   \        0x4   0x4770             BX       LR               ;; return
   \        0x6   0xBF00             Nop      
   \                     ??degBed_0:
   \        0x8   0x....'....        DC32     _ZN11Temperature12soft_pwm_bedE

   \                                 In section .text, align 4
   \   __interwork __softfp float Temperature::degTargetHotend(uint8_t)
   \                     _ZN11Temperature15degTargetHotendEh: (+1)
   \        0x0   0x4801             LDR.N    R0,??degTargetHotend_0
   \        0x2   0x6A80             LDR      R0,[R0, #+40]
   \        0x4   0x.... 0x....      B.W      __aeabi_i2f
   \                     ??degTargetHotend_0:
   \        0x8   0x....'....        DC32     _ZN11Temperature12soft_pwm_bedE

   \                                 In section .text, align 4
   \   __interwork __softfp float Temperature::degTargetBed()
   \                     _ZN11Temperature12degTargetBedEv: (+1)
   \        0x0   0x4801             LDR.N    R0,??degTargetBed_0
   \        0x2   0x6B00             LDR      R0,[R0, #+48]
   \        0x4   0x.... 0x....      B.W      __aeabi_i2f
   \                     ??degTargetBed_0:
   \        0x8   0x....'....        DC32     _ZN11Temperature12soft_pwm_bedE

   \                                 In section .text, align 4
   \   __interwork __softfp void Temperature::setTargetHotend(float, uint8_t)
   \                     _ZN11Temperature15setTargetHotendEfh: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}

        target_temperature[HOTEND_INDEX] = celsius;
                                         ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\temperature.h",401  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \        0x2   0x.... 0x....      BL       __aeabi_f2iz
   \        0x6   0x4903             LDR.N    R1,??setTargetHotend_0
   \        0x8   0x6288             STR      R0,[R1, #+40]
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xE8BD 0x4002      POP      {R1,LR}
   \       0x10   0x.... 0x....      B.W      _ZN11Temperature21start_watching_heaterEh
   \                     ??setTargetHotend_0:
   \       0x14   0x....'....        DC32     _ZN11Temperature12soft_pwm_bedE

   \                                 In section .text, align 4
   \   __interwork __softfp void Temperature::setTargetBed(float)
   \                     _ZN11Temperature12setTargetBedEf: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}

        target_temperature_bed = celsius;
                               ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\temperature.h",408  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \        0x2   0x.... 0x....      BL       __aeabi_f2iz
   \        0x6   0x4903             LDR.N    R1,??setTargetBed_0
   \        0x8   0x6308             STR      R0,[R1, #+48]
   \        0xA   0xE8BD 0x4001      POP      {R0,LR}
   \        0xE   0x.... 0x....      B.W      _ZN11Temperature18start_watching_bedEv
   \       0x12   0xBF00             Nop      
   \                     ??setTargetBed_0:
   \       0x14   0x....'....        DC32     _ZN11Temperature12soft_pwm_bedE
     29          #include "thermistortables.h"
     30          #include "ultralcd.h"
     31          #include "planner.h"
     32          #include "language.h"
     33          #include "adc.h"
     34          #include "tim.h"
     35          
     36          #if ENABLED(HEATER_0_USES_MAX6675)
     37            #include "spi.h"
     38          #endif
     39          
     40          #if ENABLED(BABYSTEPPING)
     41            #include "stepper.h"
     42          #endif
     43          
     44          #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
     45            #include "endstops.h"
     46          #endif
     47          
     48          #if ENABLED(USE_WATCHDOG)
     49            #include "watchdog.h"
     50          #endif
     51          
     52          #ifdef K1 // Defined in Configuration.h in the PID settings
     53            #define K2 (1.0-K1)
     54          #endif
     55          
     56          #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     57            static void* heater_ttbl_map[2] = {(void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE };
     58            static uint8_t heater_ttbllen_map[2] = { HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN };
     59          #else

   \                                 In section .data, align 4
     60            static void* heater_ttbl_map[HOTENDS] = ARRAY_BY_HOTENDS((void*)HEATER_0_TEMPTABLE, (void*)HEATER_1_TEMPTABLE, (void*)HEATER_2_TEMPTABLE, (void*)HEATER_3_TEMPTABLE, (void*)HEATER_4_TEMPTABLE);
     61            static uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN, HEATER_3_TEMPTABLE_LEN, HEATER_4_TEMPTABLE_LEN);
   \                     heater_ttbllen_map:
   \        0x0   0x40               DC8 64
   \        0x1   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   \        0x4   0x....'....        DC32 temptable_1
     62          #endif
     63          

   \                                 In section .bss, align 1
     64          Temperature thermalManager;
   \                     thermalManager:
   \        0x0                      DS8 1
     65          
     66          // public:
     67          
     68          float Temperature::current_temperature[HOTENDS] = { 0.0 },
     69                Temperature::current_temperature_bed = 0.0;
     70          //int16_t Temperature::current_temperature_raw[HOTENDS] = { 0 },     /*--mks--*/   
     71          int Temperature::current_temperature_raw[HOTENDS] = { 0 },
     72                  Temperature::target_temperature[HOTENDS] = { 0 },
     73                  Temperature::current_temperature_bed_raw = 0,
     74                  Temperature::target_temperature_bed = 0;
     75          
     76          #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
     77            float Temperature::redundant_temperature = 0.0;
     78          #endif
     79          
     80          uint8_t Temperature::soft_pwm_bed;
     81          
     82          #if ENABLED(FAN_SOFT_PWM)
     83            uint8_t Temperature::fanSpeedSoftPwm[FAN_COUNT];
     84          #endif
     85          
     86          //#if ENABLED(PIDTEMP)	/*--mks cfg--*/
     87          #if 1
     88            #if ENABLED(PID_PARAMS_PER_HOTEND) && HOTENDS > 1
     89              float Temperature::Kp[HOTENDS] = ARRAY_BY_HOTENDS1(DEFAULT_Kp),
     90                    Temperature::Ki[HOTENDS] = ARRAY_BY_HOTENDS1((DEFAULT_Ki) * (PID_dT)),
     91                    Temperature::Kd[HOTENDS] = ARRAY_BY_HOTENDS1((DEFAULT_Kd) / (PID_dT));
     92              #if ENABLED(PID_EXTRUSION_SCALING)
     93                float Temperature::Kc[HOTENDS] = ARRAY_BY_HOTENDS1(DEFAULT_Kc);
     94              #endif
     95            #else
     96              float Temperature::Kp = DEFAULT_Kp,
     97                    Temperature::Ki = (DEFAULT_Ki) * (PID_dT),
     98                    Temperature::Kd = (DEFAULT_Kd) / (PID_dT);
     99              #if ENABLED(PID_EXTRUSION_SCALING)
    100                float Temperature::Kc = DEFAULT_Kc;
    101              #endif
    102            #endif
    103          #endif
    104          
    105          //#if ENABLED(PIDTEMPBED)  /*--mks cfg--*/
    106          #if 1
    107            float Temperature::bedKp = DEFAULT_bedKp,
    108                  Temperature::bedKi = ((DEFAULT_bedKi) * PID_dT),
    109                  Temperature::bedKd = ((DEFAULT_bedKd) / PID_dT);
    110          #endif
    111          
    112          #if ENABLED(BABYSTEPPING)
    113            volatile int Temperature::babystepsTodo[XYZ] = { 0 };
    114          #endif
    115          
    116          #if WATCH_HOTENDS
    117            int Temperature::watch_target_temp[HOTENDS] = { 0 };
    118            millis_t Temperature::watch_heater_next_ms[HOTENDS] = { 0 };
    119          #endif
    120          
    121          #if WATCH_THE_BED
    122            int Temperature::watch_target_bed_temp = 0;
    123            millis_t Temperature::watch_bed_next_ms = 0;
    124          #endif
    125          
    126          #if ENABLED(PREVENT_COLD_EXTRUSION)

   \                                 In section .bss, align 1
    127            bool Temperature::allow_cold_extrude = false;
   \                     _ZN11Temperature18allow_cold_extrudeE:
   \        0x0                      DS8 1

   \                                 In section .bss, align 4
    128            float Temperature::extrude_min_temp = EXTRUDE_MINTEMP;
   \                     _ZN11Temperature16extrude_min_tempE:
   \        0x0                      DS8 4
    129          #endif
    130          
    131          // private:
    132          
    133          #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
    134            int Temperature::redundant_temperature_raw = 0;
    135            float Temperature::redundant_temperature = 0.0;
    136          #endif
    137          
    138          volatile bool Temperature::temp_meas_ready = false;
    139          
    140          //#if ENABLED(PIDTEMP)	/*--mks cfg--*/
    141          #if 1
    142            float Temperature::temp_iState[HOTENDS] = { 0 },
    143                  Temperature::temp_dState[HOTENDS] = { 0 },
    144                  Temperature::pTerm[HOTENDS],
    145                  Temperature::iTerm[HOTENDS],
    146                  Temperature::dTerm[HOTENDS];
    147          
    148            #if ENABLED(PID_EXTRUSION_SCALING)
    149              float Temperature::cTerm[HOTENDS];
    150              long Temperature::last_e_position;
    151              long Temperature::lpq[LPQ_MAX_LEN];
    152              int Temperature::lpq_ptr = 0;
    153            #endif
    154          
    155            float Temperature::pid_error[HOTENDS];
    156            bool Temperature::pid_reset[HOTENDS];
    157          #endif
    158          
    159          #if 0 /*--mks cfg begin--*/
    160          #if ENABLED(PIDTEMPBED)
    161            float Temperature::temp_iState_bed = { 0 },
    162                  Temperature::temp_dState_bed = { 0 },
    163                  Temperature::pTerm_bed,
    164                  Temperature::iTerm_bed,
    165                  Temperature::dTerm_bed,
    166                  Temperature::pid_error_bed;
    167          #else
    168            millis_t Temperature::next_bed_check_ms;
    169          #endif
    170          #endif

   \                                 In section .bss, align 4
    171          	float Temperature::temp_iState_bed = { 0 },
   \                     _ZN11Temperature15temp_iState_bedE:
   \        0x0                      DS8 4
    172          		  Temperature::temp_dState_bed = { 0 },
   \                     _ZN11Temperature15temp_dState_bedE:
   \        0x4                      DS8 4
    173          		  Temperature::pTerm_bed,
   \                     _ZN11Temperature9pTerm_bedE:
   \        0x8                      DS8 4
    174          		  Temperature::iTerm_bed,
   \                     _ZN11Temperature9iTerm_bedE:
   \        0xC                      DS8 4
    175          		  Temperature::dTerm_bed,
   \                     _ZN11Temperature9dTerm_bedE:
   \       0x10                      DS8 4
    176          		  Temperature::pid_error_bed;
   \                     _ZN11Temperature13pid_error_bedE:
   \       0x14                      DS8 4
    177          	millis_t Temperature::next_bed_check_ms;
    178          
    179          	/*--mks cfg end--*/
    180          
    181          uint16_t Temperature::raw_temp_value[MAX_EXTRUDERS] = { 0 },
    182                   Temperature::raw_temp_bed_value = 0;
    183          
    184          // Init min and max temp with extreme values to prevent false errors during startup
    185          int16_t Temperature::minttemp_raw[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_RAW_LO_TEMP , HEATER_1_RAW_LO_TEMP , HEATER_2_RAW_LO_TEMP, HEATER_3_RAW_LO_TEMP, HEATER_4_RAW_LO_TEMP),
    186                  Temperature::maxttemp_raw[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_RAW_HI_TEMP , HEATER_1_RAW_HI_TEMP , HEATER_2_RAW_HI_TEMP, HEATER_3_RAW_HI_TEMP, HEATER_4_RAW_HI_TEMP),
    187                  Temperature::minttemp[HOTENDS] = { 0 },
    188                  Temperature::maxttemp[HOTENDS] = ARRAY_BY_HOTENDS1(16383);
    189          
    190          #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
    191            uint8_t Temperature::consecutive_low_temperature_error[HOTENDS] = { 0 };
    192          #endif
    193          
    194          #ifdef MILLISECONDS_PREHEAT_TIME
    195            millis_t Temperature::preheat_end_time[HOTENDS] = { 0 };
    196          #endif
    197          
    198          #ifdef BED_MINTEMP
    199            int16_t Temperature::bed_minttemp_raw = HEATER_BED_RAW_LO_TEMP;
    200          #endif
    201          
    202          #ifdef BED_MAXTEMP
    203            int16_t Temperature::bed_maxttemp_raw = HEATER_BED_RAW_HI_TEMP;
    204          #endif
    205          
    206          #if ENABLED(FILAMENT_WIDTH_SENSOR)
    207            int16_t Temperature::meas_shift_index;  // Index of a delayed sample in buffer
    208          #endif
    209          
    210          #if HAS_AUTO_FAN
    211            millis_t Temperature::next_auto_fan_check_ms = 0;
    212          #endif
    213          
    214          uint8_t Temperature::soft_pwm[HOTENDS];
    215          
    216          #if ENABLED(FAN_SOFT_PWM)
    217            uint8_t Temperature::soft_pwm_fan[FAN_COUNT];
    218          #endif
    219          
    220          #if ENABLED(FILAMENT_WIDTH_SENSOR)
    221            int Temperature::current_raw_filwidth = 0;  //Holds measured filament diameter - one extruder only
    222          #endif
    223          #if ENABLED(PROBING_HEATERS_OFF)
    224            bool Temperature::paused;
    225            int16_t Temperature::paused_hotend_temps[HOTENDS];
    226            //#if HAS_TEMP_BED	/*--mks cfg-- HAS_TEMP_BED --*/
    227              int16_t Temperature::paused_bed_temp;
    228            //#endif
    229          #endif
    230          
    231          //#if HAS_PID_HEATING	/*--mks cfg--*/
    232          #if 1

   \                                 In section .text, align 2, keep-with-next
    233            void Temperature::PID_autotune(float temp, int hotend, int ncycles, bool set_result/*=false*/) {
   \                     _ZN11Temperature12PID_autotuneEfiib: (+1)
   \        0x0   0xE92D 0x4FFC      PUSH     {R2-R11,LR}
   \        0x4   0xB08F             SUB      SP,SP,#+60
   \        0x6   0x4682             MOV      R10,R0
   \        0x8   0x460E             MOV      R6,R1
   \        0xA   0x4693             MOV      R11,R2
    234              float input = 0.0;
   \        0xC   0xF04F 0x0800      MOV      R8,#+0
    235              int cycles = 0;
   \       0x10   0x4640             MOV      R0,R8
   \       0x12   0x9006             STR      R0,[SP, #+24]
    236              bool heating = true;
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0xF88D 0x0000      STRB     R0,[SP, #+0]
    237          
    238              millis_t temp_ms = millis(), t1 = temp_ms, t2 = temp_ms;
   \       0x1A   0x.... 0x....      BL       HAL_GetTick
   \       0x1E   0x4681             MOV      R9,R0
   \       0x20   0xF8CD 0x9024      STR      R9,[SP, #+36]
   \       0x24   0xF8CD 0x9020      STR      R9,[SP, #+32]
    239              long t_high = 0, t_low = 0;
   \       0x28   0x4640             MOV      R0,R8
   \       0x2A   0x9007             STR      R0,[SP, #+28]
    240          
    241              long bias, d;
    242              float Ku, Tu;
    243              float workKp = 0, workKi = 0, workKd = 0;
   \       0x2C   0x900D             STR      R0,[SP, #+52]
   \       0x2E   0x900B             STR      R0,[SP, #+44]
   \       0x30   0x9002             STR      R0,[SP, #+8]
    244              float max = 0, min = 10000;
   \       0x32   0x9005             STR      R0,[SP, #+20]
   \       0x34   0x.... 0x....      LDR.W    R0,??DataTable47_1  ;; 0x461c4000
   \       0x38   0x9004             STR      R0,[SP, #+16]
    245          
    246              #if HAS_AUTO_FAN
    247                next_auto_fan_check_ms = temp_ms + 2500UL;
    248              #endif
    249          #if 0	/*--mks cfg--*/
    250              if (hotend >=	
    251                  #if ENABLED(PIDTEMP)
    252                    HOTENDS
    253                  #else
    254                    0
    255                  #endif
    256                || hotend <
    257                  #if ENABLED(PIDTEMPBED)
    258                    -1
    259                  #else
    260                    0
    261                  #endif
    262              ) {
    263                SERIAL_ECHOLN(MSG_PID_BAD_EXTRUDER_NUM);
    264                return;
    265              }
    266          #endif
    267          	if(PIDTEMP == 0 && PIDTEMPBED == 0) if(hotend >= 0 || hotend < 0) {SERIAL_ECHOLN(MSG_PID_BAD_EXTRUDER_NUM);return;}
   \       0x3A   0x.... 0x....      LDR.W    R0,??DataTable47_2
   \       0x3E   0x9001             STR      R0,[SP, #+4]
   \       0x40   0x7800             LDRB     R0,[R0, #+0]
   \       0x42   0x.... 0x....      LDR.W    R4,??DataTable47_3
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD128             BNE.N    ??PID_autotune_0
   \       0x4A   0x9901             LDR      R1,[SP, #+4]
   \       0x4C   0x7849             LDRB     R1,[R1, #+1]
   \       0x4E   0x2900             CMP      R1,#+0
   \       0x50   0xD124             BNE.N    ??PID_autotune_0
   \       0x52   0x2E00             CMP      R6,#+0
   \       0x54   0xD500             BPL.N    ??PID_autotune_1
   \       0x56   0xD521             BPL.N    ??PID_autotune_0
   \                     ??PID_autotune_1: (+1)
   \       0x58   0x.... 0x....      ADR.W    R1,?_3
   \       0x5C   0x7820             LDRB     R0,[R4, #+0]
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD104             BNE.N    ??PID_autotune_2
   \       0x62   0x.... 0x....      LDR.W    R0,??DataTable47_4
   \       0x66   0x.... 0x....      BL       _ZN12MarlinSerial5printEPKc
   \       0x6A   0xE003             B.N      ??PID_autotune_3
   \                     ??PID_autotune_2: (+1)
   \       0x6C   0x.... 0x....      LDR.W    R0,??DataTable47_5
   \       0x70   0x.... 0x....      BL       _ZN12MarlinSerial5printEPKc
   \                     ??PID_autotune_3: (+1)
   \       0x74   0x7820             LDRB     R0,[R4, #+0]
   \       0x76   0x2800             CMP      R0,#+0
   \       0x78   0xD107             BNE.N    ??PID_autotune_4
   \       0x7A   0x210A             MOVS     R1,#+10
   \       0x7C   0x.... 0x....      LDR.W    R0,??DataTable47_4
   \       0x80   0xB011             ADD      SP,SP,#+68
   \       0x82   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \       0x86   0x.... 0x....      B.W      _ZN12MarlinSerial5writeEh
   \                     ??PID_autotune_4: (+1)
   \       0x8A   0x4642             MOV      R2,R8
   \       0x8C   0x210A             MOVS     R1,#+10
   \       0x8E   0x.... 0x....      LDR.W    R0,??DataTable47_5
   \       0x92   0xB011             ADD      SP,SP,#+68
   \       0x94   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \       0x98   0x.... 0x....      B.W      _ZN12MarlinSerial5printEci
    268          	if(PIDTEMP == 0 && PIDTEMPBED == 1) if(hotend >= 0 || hotend < -1) {SERIAL_ECHOLN(MSG_PID_BAD_EXTRUDER_NUM);return;}
   \                     ??PID_autotune_0: (+1)
   \       0x9C   0x2800             CMP      R0,#+0
   \       0x9E   0xD127             BNE.N    ??PID_autotune_5
   \       0xA0   0x9901             LDR      R1,[SP, #+4]
   \       0xA2   0x7849             LDRB     R1,[R1, #+1]
   \       0xA4   0x2901             CMP      R1,#+1
   \       0xA6   0xD123             BNE.N    ??PID_autotune_5
   \       0xA8   0x1C71             ADDS     R1,R6,#+1
   \       0xAA   0xD021             BEQ.N    ??PID_autotune_5
   \       0xAC   0x.... 0x....      ADR.W    R1,?_3
   \       0xB0   0x7820             LDRB     R0,[R4, #+0]
   \       0xB2   0x2800             CMP      R0,#+0
   \       0xB4   0xD104             BNE.N    ??PID_autotune_6
   \       0xB6   0x.... 0x....      LDR.W    R0,??DataTable47_4
   \       0xBA   0x.... 0x....      BL       _ZN12MarlinSerial5printEPKc
   \       0xBE   0xE003             B.N      ??PID_autotune_7
   \                     ??PID_autotune_6: (+1)
   \       0xC0   0x.... 0x....      LDR.W    R0,??DataTable47_5
   \       0xC4   0x.... 0x....      BL       _ZN12MarlinSerial5printEPKc
   \                     ??PID_autotune_7: (+1)
   \       0xC8   0x7820             LDRB     R0,[R4, #+0]
   \       0xCA   0x2800             CMP      R0,#+0
   \       0xCC   0xD107             BNE.N    ??PID_autotune_8
   \       0xCE   0x210A             MOVS     R1,#+10
   \       0xD0   0x.... 0x....      LDR.W    R0,??DataTable47_4
   \       0xD4   0xB011             ADD      SP,SP,#+68
   \       0xD6   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \       0xDA   0x.... 0x....      B.W      _ZN12MarlinSerial5writeEh
   \                     ??PID_autotune_8: (+1)
   \       0xDE   0x4642             MOV      R2,R8
   \       0xE0   0x210A             MOVS     R1,#+10
   \       0xE2   0x.... 0x....      LDR.W    R0,??DataTable47_5
   \       0xE6   0xB011             ADD      SP,SP,#+68
   \       0xE8   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \       0xEC   0x.... 0x....      B.W      _ZN12MarlinSerial5printEci
    269          	if(PIDTEMP == 1 && PIDTEMPBED == 0) if(hotend >= HOTENDS|| hotend < 0) {SERIAL_ECHOLN(MSG_PID_BAD_EXTRUDER_NUM);return;}
   \                     ??PID_autotune_5: (+1)
   \       0xF0   0x2801             CMP      R0,#+1
   \       0xF2   0xD127             BNE.N    ??PID_autotune_9
   \       0xF4   0x9901             LDR      R1,[SP, #+4]
   \       0xF6   0x7849             LDRB     R1,[R1, #+1]
   \       0xF8   0x2900             CMP      R1,#+0
   \       0xFA   0xD123             BNE.N    ??PID_autotune_9
   \       0xFC   0x2E00             CMP      R6,#+0
   \       0xFE   0xD021             BEQ.N    ??PID_autotune_9
   \      0x100   0x.... 0x....      ADR.W    R1,?_3
   \      0x104   0x7820             LDRB     R0,[R4, #+0]
   \      0x106   0x2800             CMP      R0,#+0
   \      0x108   0xD104             BNE.N    ??PID_autotune_10
   \      0x10A   0x.... 0x....      LDR.W    R0,??DataTable47_4
   \      0x10E   0x.... 0x....      BL       _ZN12MarlinSerial5printEPKc
   \      0x112   0xE003             B.N      ??PID_autotune_11
   \                     ??PID_autotune_10: (+1)
   \      0x114   0x.... 0x....      LDR.W    R0,??DataTable47_5
   \      0x118   0x.... 0x....      BL       _ZN12MarlinSerial5printEPKc
   \                     ??PID_autotune_11: (+1)
   \      0x11C   0x7820             LDRB     R0,[R4, #+0]
   \      0x11E   0x2800             CMP      R0,#+0
   \      0x120   0xD107             BNE.N    ??PID_autotune_12
   \      0x122   0x210A             MOVS     R1,#+10
   \      0x124   0x.... 0x....      LDR.W    R0,??DataTable47_4
   \      0x128   0xB011             ADD      SP,SP,#+68
   \      0x12A   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \      0x12E   0x.... 0x....      B.W      _ZN12MarlinSerial5writeEh
   \                     ??PID_autotune_12: (+1)
   \      0x132   0x4642             MOV      R2,R8
   \      0x134   0x210A             MOVS     R1,#+10
   \      0x136   0x.... 0x....      LDR.W    R0,??DataTable47_5
   \      0x13A   0xB011             ADD      SP,SP,#+68
   \      0x13C   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \      0x140   0x.... 0x....      B.W      _ZN12MarlinSerial5printEci
    270          	if(PIDTEMP == 1 && PIDTEMPBED == 1) if(hotend >= HOTENDS|| hotend < -1) {SERIAL_ECHOLN(MSG_PID_BAD_EXTRUDER_NUM);return;}
   \                     ??PID_autotune_9: (+1)
   \      0x144   0x2801             CMP      R0,#+1
   \      0x146   0xD128             BNE.N    ??PID_autotune_13
   \      0x148   0x9801             LDR      R0,[SP, #+4]
   \      0x14A   0x7840             LDRB     R0,[R0, #+1]
   \      0x14C   0x2801             CMP      R0,#+1
   \      0x14E   0xD124             BNE.N    ??PID_autotune_13
   \      0x150   0x1C70             ADDS     R0,R6,#+1
   \      0x152   0x2801             CMP      R0,#+1
   \      0x154   0xD921             BLS.N    ??PID_autotune_13
   \      0x156   0x.... 0x....      ADR.W    R1,?_3
   \      0x15A   0x7820             LDRB     R0,[R4, #+0]
   \      0x15C   0x2800             CMP      R0,#+0
   \      0x15E   0xD104             BNE.N    ??PID_autotune_14
   \      0x160   0x.... 0x....      LDR.W    R0,??DataTable47_4
   \      0x164   0x.... 0x....      BL       _ZN12MarlinSerial5printEPKc
   \      0x168   0xE003             B.N      ??PID_autotune_15
   \                     ??PID_autotune_14: (+1)
   \      0x16A   0x.... 0x....      LDR.W    R0,??DataTable47_5
   \      0x16E   0x.... 0x....      BL       _ZN12MarlinSerial5printEPKc
   \                     ??PID_autotune_15: (+1)
   \      0x172   0x7820             LDRB     R0,[R4, #+0]
   \      0x174   0x2800             CMP      R0,#+0
   \      0x176   0xD107             BNE.N    ??PID_autotune_16
   \      0x178   0x210A             MOVS     R1,#+10
   \      0x17A   0x.... 0x....      LDR.W    R0,??DataTable47_4
   \      0x17E   0xB011             ADD      SP,SP,#+68
   \      0x180   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \      0x184   0x.... 0x....      B.W      _ZN12MarlinSerial5writeEh
   \                     ??PID_autotune_16: (+1)
   \      0x188   0x4642             MOV      R2,R8
   \      0x18A   0x210A             MOVS     R1,#+10
   \      0x18C   0x.... 0x....      LDR.W    R0,??DataTable47_5
   \      0x190   0xB011             ADD      SP,SP,#+68
   \      0x192   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \      0x196   0x.... 0x....      B.W      _ZN12MarlinSerial5printEci
    271          
    272              SERIAL_ECHOLN(MSG_PID_AUTOTUNE_START);
   \                     ??PID_autotune_13: (+1)
   \      0x19A   0x.... 0x....      ADR.W    R1,?_4
   \      0x19E   0x7820             LDRB     R0,[R4, #+0]
   \      0x1A0   0x2800             CMP      R0,#+0
   \      0x1A2   0xD104             BNE.N    ??PID_autotune_17
   \      0x1A4   0x.... 0x....      LDR.W    R0,??DataTable47_4
   \      0x1A8   0x.... 0x....      BL       _ZN12MarlinSerial5printEPKc
   \      0x1AC   0xE003             B.N      ??PID_autotune_18
   \                     ??PID_autotune_17: (+1)
   \      0x1AE   0x.... 0x....      LDR.W    R0,??DataTable47_5
   \      0x1B2   0x.... 0x....      BL       _ZN12MarlinSerial5printEPKc
   \                     ??PID_autotune_18: (+1)
   \      0x1B6   0x7820             LDRB     R0,[R4, #+0]
   \      0x1B8   0x2800             CMP      R0,#+0
   \      0x1BA   0xD105             BNE.N    ??PID_autotune_19
   \      0x1BC   0x210A             MOVS     R1,#+10
   \      0x1BE   0x.... 0x....      LDR.W    R0,??DataTable47_4
   \      0x1C2   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \      0x1C6   0xE005             B.N      ??PID_autotune_20
   \                     ??PID_autotune_19: (+1)
   \      0x1C8   0x4642             MOV      R2,R8
   \      0x1CA   0x210A             MOVS     R1,#+10
   \      0x1CC   0x.... 0x....      LDR.W    R0,??DataTable47_5
   \      0x1D0   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
    273          
    274              disable_all_heaters(); // switch off all heaters.
   \                     ??PID_autotune_20: (+1)
   \      0x1D4   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
    275          #if 0	/*--mks cfg begin--*/
    276              #if HAS_PID_FOR_BOTH
    277                if (hotend < 0)
    278                  soft_pwm_bed = bias = d = (MAX_BED_POWER) >> 1;
    279                else
    280                  soft_pwm[hotend] = bias = d = (PID_MAX) >> 1;
    281              #elif ENABLED(PIDTEMP)
    282                soft_pwm[hotend] = bias = d = (PID_MAX) >> 1;
    283              #else
    284                soft_pwm_bed = bias = d = (MAX_BED_POWER) >> 1;
    285              #endif
    286          #endif
    287          	if (HAS_PID_FOR_BOTH) {
   \      0x1D8   0x9801             LDR      R0,[SP, #+4]
   \      0x1DA   0x7800             LDRB     R0,[R0, #+0]
   \      0x1DC   0x.... 0x....      LDR.W    R5,??DataTable48
   \      0x1E0   0x2800             CMP      R0,#+0
   \      0x1E2   0xD010             BEQ.N    ??PID_autotune_21
   \      0x1E4   0x9901             LDR      R1,[SP, #+4]
   \      0x1E6   0x7849             LDRB     R1,[R1, #+1]
   \      0x1E8   0x2900             CMP      R1,#+0
   \      0x1EA   0xD00C             BEQ.N    ??PID_autotune_21
    288                if (hotend < 0)
   \      0x1EC   0x2E00             CMP      R6,#+0
   \      0x1EE   0xD504             BPL.N    ??PID_autotune_22
    289                  soft_pwm_bed = bias = d = (MAX_BED_POWER) >> 1;
   \      0x1F0   0x207F             MOVS     R0,#+127
   \      0x1F2   0x4607             MOV      R7,R0
   \      0x1F4   0x4601             MOV      R1,R0
   \      0x1F6   0x7029             STRB     R1,[R5, #+0]
   \      0x1F8   0xE011             B.N      ??PID_autotune_23
    290                else
    291                  soft_pwm[hotend] = bias = d = (PID_MAX) >> 1;}
   \                     ??PID_autotune_22: (+1)
   \      0x1FA   0x207F             MOVS     R0,#+127
   \      0x1FC   0x4607             MOV      R7,R0
   \      0x1FE   0x4601             MOV      R1,R0
   \      0x200   0x19AA             ADDS     R2,R5,R6
   \      0x202   0x70D1             STRB     R1,[R2, #+3]
   \      0x204   0xE00B             B.N      ??PID_autotune_23
    292          	else if(PIDTEMP)	soft_pwm[hotend] = bias = d = (PID_MAX) >> 1;
   \                     ??PID_autotune_21: (+1)
   \      0x206   0x2800             CMP      R0,#+0
   \      0x208   0xD005             BEQ.N    ??PID_autotune_24
   \      0x20A   0x207F             MOVS     R0,#+127
   \      0x20C   0x4607             MOV      R7,R0
   \      0x20E   0x4601             MOV      R1,R0
   \      0x210   0x19AA             ADDS     R2,R5,R6
   \      0x212   0x70D1             STRB     R1,[R2, #+3]
   \      0x214   0xE003             B.N      ??PID_autotune_23
    293          	else soft_pwm_bed = bias = d = (MAX_BED_POWER) >> 1;
   \                     ??PID_autotune_24: (+1)
   \      0x216   0x207F             MOVS     R0,#+127
   \      0x218   0x4607             MOV      R7,R0
   \      0x21A   0x4601             MOV      R1,R0
   \      0x21C   0x7029             STRB     R1,[R5, #+0]
    294          
    295          
    296          	/*--mks cfg end--*/
    297          
    298              wait_for_heatup = true;
   \                     ??PID_autotune_23: (+1)
   \      0x21E   0x2101             MOVS     R1,#+1
   \      0x220   0x.... 0x....      LDR.W    R2,??DataTable48_1
   \      0x224   0x7011             STRB     R1,[R2, #+0]
   \      0x226   0xF8CD 0xA028      STR      R10,[SP, #+40]
   \      0x22A   0x9603             STR      R6,[SP, #+12]
   \      0x22C   0xF8CD 0xB038      STR      R11,[SP, #+56]
   \      0x230   0xF8CD 0x9030      STR      R9,[SP, #+48]
   \      0x234   0xF8DD 0xB034      LDR      R11,[SP, #+52]
   \      0x238   0xF8DD 0x902C      LDR      R9,[SP, #+44]
   \      0x23C   0xF8DD 0xA008      LDR      R10,[SP, #+8]
   \      0x240   0x9002             STR      R0,[SP, #+8]
   \      0x242   0xE021             B.N      ??PID_autotune_25
    299          
    300              // PID Tuning loop
    301              while (wait_for_heatup) {
    302          
    303                millis_t ms = millis();
    304          
    305                if (temp_meas_ready) { // temp sample ready
    306                  updateTemperaturesFromRawValues();
    307          
    308          #if 0	/*--mks cfg begin--*/
    309                  input =
    310                    #if HAS_PID_FOR_BOTH
    311                      hotend < 0 ? current_temperature_bed : current_temperature[hotend]
    312                    #elif ENABLED(PIDTEMP)
    313                      current_temperature[hotend]
    314                    #else
    315                      current_temperature_bed
    316                    #endif
    317                  ;
    318          #endif
    319          		if(HAS_PID_FOR_BOTH) 	input = hotend < 0 ? current_temperature_bed : current_temperature[hotend];
    320          		else if(PIDTEMP) 		input = current_temperature[hotend];
    321          		else					input = current_temperature_bed;
    322          		/*--mks cfg end--*/
    323          
    324                  NOLESS(max, input);
    325                  NOMORE(min, input);
    326          
    327                  #if HAS_AUTO_FAN
    328                    if (ELAPSED(ms, next_auto_fan_check_ms)) {
    329                      checkExtruderAutoFans();
    330                      next_auto_fan_check_ms = ms + 2500UL;
    331                    }
    332                  #endif
    333          
    334                  if (heating && input > temp) {
    335                    if (ELAPSED(ms, t2 + 5000UL)) {
    336                      heating = false;
    337          #if 0 		/*--mks cfg begin--*/	
    338                      #if HAS_PID_FOR_BOTH
    339                        if (hotend < 0)
    340                          soft_pwm_bed = (bias - d) >> 1;
    341                        else
    342                          soft_pwm[hotend] = (bias - d) >> 1;
    343                      #elif ENABLED(PIDTEMP)
    344                        soft_pwm[hotend] = (bias - d) >> 1;
    345                      #elif ENABLED(PIDTEMPBED)
    346                        soft_pwm_bed = (bias - d) >> 1;
    347                      #endif
    348          #endif
    349          			if(HAS_PID_FOR_BOTH)	{if (hotend < 0) soft_pwm_bed = (bias - d) >> 1; else soft_pwm[hotend] = (bias - d) >> 1;}
    350          			else if(PIDTEMP)		soft_pwm[hotend] = (bias - d) >> 1;
    351          			else					soft_pwm_bed = (bias - d) >> 1;
    352          			/*--mks cfg begin--*/
    353          
    354                      t1 = ms;
    355                      t_high = t1 - t2;
    356                      max = temp;
    357                    }
    358                  }
    359          
    360                  if (!heating && input < temp) {
    361                    if (ELAPSED(ms, t1 + 5000UL)) {
    362                      heating = true;
    363                      t2 = ms;
    364                      t_low = t2 - t1;
    365                      if (cycles > 0) {
    366          #if 0 /*--mks cfg begin--*/				
    367                        long max_pow =
    368                          #if HAS_PID_FOR_BOTH
    369                            hotend < 0 ? MAX_BED_POWER : PID_MAX
    370                          #elif ENABLED(PIDTEMP)
    371                            PID_MAX
    372                          #else
    373                            MAX_BED_POWER
    374                          #endif
    375                        ;
    376          #endif
    377                        long max_pow;
    378                        if(HAS_PID_FOR_BOTH)	 max_pow = hotend < 0 ? MAX_BED_POWER : PID_MAX;
    379                        else if(PIDTEMP)	 max_pow = PID_MAX;
    380                        else 			 max_pow = MAX_BED_POWER;
    381          	/*--mks cfg begin--*/
    382          
    383                        bias += (d * (t_high - t_low)) / (t_low + t_high);
    384                        bias = constrain(bias, 20, max_pow - 20);
    385                        d = (bias > max_pow / 2) ? max_pow - 1 - bias : bias;
    386          
    387                        SERIAL_PROTOCOLPAIR(MSG_BIAS, bias);
    388                        SERIAL_PROTOCOLPAIR(MSG_D, d);
    389                        SERIAL_PROTOCOLPAIR(MSG_T_MIN, min);
    390                        SERIAL_PROTOCOLPAIR(MSG_T_MAX, max);
    391                        if (cycles > 2) {
    392                          Ku = (4.0 * d) / (M_PI * (max - min) * 0.5);
    393                          Tu = ((float)(t_low + t_high) * 0.001);
    394                          SERIAL_PROTOCOLPAIR(MSG_KU, Ku);
    395                          SERIAL_PROTOCOLPAIR(MSG_TU, Tu);
    396                          workKp = 0.6 * Ku;
    397                          workKi = 2 * workKp / Tu;
    398                          workKd = workKp * Tu * 0.125;
    399                          SERIAL_PROTOCOLLNPGM("\n" MSG_CLASSIC_PID);
    400                          SERIAL_PROTOCOLPAIR(MSG_KP, workKp);
    401                          SERIAL_PROTOCOLPAIR(MSG_KI, workKi);
    402                          SERIAL_PROTOCOLLNPAIR(MSG_KD, workKd);
    403                          /**
    404                          workKp = 0.33*Ku;
    405                          workKi = workKp/Tu;
    406                          workKd = workKp*Tu/3;
    407                          SERIAL_PROTOCOLLNPGM(" Some overshoot");
    408                          SERIAL_PROTOCOLPAIR(" Kp: ", workKp);
    409                          SERIAL_PROTOCOLPAIR(" Ki: ", workKi);
    410                          SERIAL_PROTOCOLPAIR(" Kd: ", workKd);
    411                          workKp = 0.2*Ku;
    412                          workKi = 2*workKp/Tu;
    413                          workKd = workKp*Tu/3;
    414                          SERIAL_PROTOCOLLNPGM(" No overshoot");
    415                          SERIAL_PROTOCOLPAIR(" Kp: ", workKp);
    416                          SERIAL_PROTOCOLPAIR(" Ki: ", workKi);
    417                          SERIAL_PROTOCOLPAIR(" Kd: ", workKd);
    418                          */
    419                        }
    420                      }
    421          #if 0 /*--mks cfg begin--*/			
    422                      #if HAS_PID_FOR_BOTH
    423                        if (hotend < 0)
    424                          soft_pwm_bed = (bias + d) >> 1;
    425                        else
    426                          soft_pwm[hotend] = (bias + d) >> 1;
    427                      #elif ENABLED(PIDTEMP)
    428                        soft_pwm[hotend] = (bias + d) >> 1;
    429                      #else
    430                        soft_pwm_bed = (bias + d) >> 1;
    431                      #endif
    432          #endif
    433          		if(HAS_PID_FOR_BOTH)	{if (hotend < 0) soft_pwm_bed = (bias + d) >> 1; else soft_pwm[hotend] = (bias + d) >> 1;}
    434          		else if(PIDTEMP)		soft_pwm[hotend] = (bias + d) >> 1;
    435          		else					soft_pwm_bed = (bias + d) >> 1;
    436          		/*--mks cfg end--*/
    437                      cycles++;
    438                      min = temp;
    439                    }
    440                  }
    441                }
    442                #define MAX_OVERSHOOT_PID_AUTOTUNE 20
    443                if (input > temp + MAX_OVERSHOOT_PID_AUTOTUNE) {
    444                  SERIAL_PROTOCOLLNPGM(MSG_PID_TEMP_TOO_HIGH);
    445                  return;
    446                }
    447                // Every 2 seconds...
    448                if (ELAPSED(ms, temp_ms + 2000UL)) {
   \                     ??PID_autotune_26: (+1)
   \      0x244   0x980C             LDR      R0,[SP, #+48]
   \      0x246   0x1A30             SUBS     R0,R6,R0
   \      0x248   0xF5B0 0x60FA      SUBS     R0,R0,#+2000
   \      0x24C   0xD40B             BMI.N    ??PID_autotune_27
    449                  //#if HAS_TEMP_HOTEND || HAS_TEMP_BED	/*--mks cfg-- HAS_TEMP_BED --*/
    450          		#if HAS_TEMP_HOTEND
    451                    print_heaterstates();
   \      0x24E   0x.... 0x....      BL       _Z18print_heaterstatesv
    452                    SERIAL_EOL;
   \      0x252   0x7820             LDRB     R0,[R4, #+0]
   \      0x254   0x2800             CMP      R0,#+0
   \      0x256   0xF040 0x8170      BNE.W    ??PID_autotune_28
   \      0x25A   0x210A             MOVS     R1,#+10
   \      0x25C   0x.... 0x....      LDR.W    R0,??DataTable47_4
   \      0x260   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
    453                  #endif
    454          
    455                  temp_ms = ms;
   \                     ??PID_autotune_29: (+1)
   \      0x264   0x960C             STR      R6,[SP, #+48]
    456                } // every 2 seconds
    457                // Over 2 minutes?
    458                if (((ms - t1) + (ms - t2)) > (10L * 60L * 1000L * 2L)) {
   \                     ??PID_autotune_27: (+1)
   \      0x266   0x9809             LDR      R0,[SP, #+36]
   \      0x268   0xEBC0 0x0046      RSB      R0,R0,R6, LSL #+1
   \      0x26C   0x9908             LDR      R1,[SP, #+32]
   \      0x26E   0x1A40             SUBS     R0,R0,R1
   \      0x270   0x.... 0x....      LDR.W    R1,??DataTable48_2  ;; 0x124f81
   \      0x274   0x4288             CMP      R0,R1
   \      0x276   0xF080 0x8167      BCS.W    ??PID_autotune_30
    459                  SERIAL_PROTOCOLLNPGM(MSG_PID_TIMEOUT);
    460                  return;
    461                }
    462                if (cycles > ncycles) {
   \      0x27A   0x980E             LDR      R0,[SP, #+56]
   \      0x27C   0x9906             LDR      R1,[SP, #+24]
   \      0x27E   0x4288             CMP      R0,R1
   \      0x280   0xF2C0 0x8169      BLT.W    ??PID_autotune_31
    463                  SERIAL_PROTOCOLLNPGM(MSG_PID_AUTOTUNE_FINISHED);
    464          		
    465          #if 0 /*--mks cfg begin--*/
    466                  #if HAS_PID_FOR_BOTH
    467                    const char* estring = hotend < 0 ? "bed" : "";
    468                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Kp ", workKp); SERIAL_EOL;
    469                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Ki ", workKi); SERIAL_EOL;
    470                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Kd ", workKd); SERIAL_EOL;
    471                  #elif ENABLED(PIDTEMP)
    472                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_Kp ", workKp); SERIAL_EOL;
    473                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_Ki ", workKi); SERIAL_EOL;
    474                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_Kd ", workKd); SERIAL_EOL;
    475                  #else
    476                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_bedKp ", workKp); SERIAL_EOL;
    477                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_bedKi ", workKi); SERIAL_EOL;
    478                    SERIAL_PROTOCOLPAIR("#define  DEFAULT_bedKd ", workKd); SERIAL_EOL;
    479                  #endif
    480          #endif
    481          		if(HAS_PID_FOR_BOTH)
    482          			{
    483          			const char* estring = hotend < 0 ? "bed" : "";
    484          			SERIAL_PROTOCOLPAIR("#define  DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Kp ", workKp); SERIAL_EOL;
    485          			SERIAL_PROTOCOLPAIR("#define  DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Ki ", workKi); SERIAL_EOL;
    486          			SERIAL_PROTOCOLPAIR("#define  DEFAULT_", estring); SERIAL_PROTOCOLPAIR("Kd ", workKd); SERIAL_EOL;
    487          			}
    488          		else if(PIDTEMP)
    489          			{
    490          			SERIAL_PROTOCOLPAIR("#define  DEFAULT_Kp ", workKp); SERIAL_EOL;
    491          			SERIAL_PROTOCOLPAIR("#define  DEFAULT_Ki ", workKi); SERIAL_EOL;
    492          			SERIAL_PROTOCOLPAIR("#define  DEFAULT_Kd ", workKd); SERIAL_EOL;
    493          			}
    494          		else
    495          			{
    496          			SERIAL_PROTOCOLPAIR("#define  DEFAULT_bedKp ", workKp); SERIAL_EOL;
    497          			SERIAL_PROTOCOLPAIR("#define  DEFAULT_bedKi ", workKi); SERIAL_EOL;
    498          			SERIAL_PROTOCOLPAIR("#define  DEFAULT_bedKd ", workKd); SERIAL_EOL;
    499          			}
    500          		/*--mks cfg end--*/
    501          
    502                  #define _SET_BED_PID() do { \
    503                    bedKp = workKp; \
    504                    bedKi = scalePID_i(workKi); \
    505                    bedKd = scalePID_d(workKd); \
    506                    updatePID(); } while(0)
    507          
    508                  #define _SET_EXTRUDER_PID() do { \
    509                    PID_PARAM(Kp, hotend) = workKp; \
    510                    PID_PARAM(Ki, hotend) = scalePID_i(workKi); \
    511                    PID_PARAM(Kd, hotend) = scalePID_d(workKd); \
    512                    updatePID(); } while(0)
    513          
    514                  // Use the result? (As with "M303 U1")
    515          #if 0 /*--mks cfg begin--*/        
    516                  if (set_result) {
    517                    #if HAS_PID_FOR_BOTH
    518                      if (hotend < 0)
    519                        _SET_BED_PID();
    520                      else
    521                        _SET_EXTRUDER_PID();
    522                    #elif ENABLED(PIDTEMP)
    523                      _SET_EXTRUDER_PID();
    524                    #else
    525                      _SET_BED_PID();
    526                    #endif
    527          	  
    528                  }
    529          #endif	
    530          	if(HAS_PID_FOR_BOTH)	if (set_result) {if (hotend < 0) _SET_BED_PID(); else _SET_EXTRUDER_PID();}
    531          	else if(PIDTEMP)		if (set_result)  _SET_EXTRUDER_PID();
    532          	else 					if (set_result)  _SET_BED_PID();
    533           
    534          		/*--mks cfg end--*/
    535          
    536                  return;
    537                }
    538                lcd_update();
   \      0x284   0x.... 0x....      BL       _Z10lcd_updatev
   \                     ??PID_autotune_25: (+1)
   \      0x288   0x.... 0x....      LDR.W    R1,??DataTable48_1
   \      0x28C   0x7808             LDRB     R0,[R1, #+0]
   \      0x28E   0x2800             CMP      R0,#+0
   \      0x290   0xF000 0x826B      BEQ.W    ??PID_autotune_32
   \      0x294   0x.... 0x....      BL       HAL_GetTick
   \      0x298   0x4606             MOV      R6,R0
   \      0x29A   0x7868             LDRB     R0,[R5, #+1]
   \      0x29C   0x2800             CMP      R0,#+0
   \      0x29E   0xF000 0x8132      BEQ.W    ??PID_autotune_33
   \      0x2A2   0x.... 0x....      BL       _ZN11Temperature31updateTemperaturesFromRawValuesEv
   \      0x2A6   0x9801             LDR      R0,[SP, #+4]
   \      0x2A8   0x7802             LDRB     R2,[R0, #+0]
   \      0x2AA   0x2A00             CMP      R2,#+0
   \      0x2AC   0xD00D             BEQ.N    ??PID_autotune_34
   \      0x2AE   0x7840             LDRB     R0,[R0, #+1]
   \      0x2B0   0x2800             CMP      R0,#+0
   \      0x2B2   0xD00A             BEQ.N    ??PID_autotune_34
   \      0x2B4   0x9803             LDR      R0,[SP, #+12]
   \      0x2B6   0x2800             CMP      R0,#+0
   \      0x2B8   0xD502             BPL.N    ??PID_autotune_35
   \      0x2BA   0xF8D5 0x8020      LDR      R8,[R5, #+32]
   \      0x2BE   0xE00E             B.N      ??PID_autotune_36
   \                     ??PID_autotune_35: (+1)
   \      0x2C0   0xEB05 0x0080      ADD      R0,R5,R0, LSL #+2
   \      0x2C4   0xF8D0 0x801C      LDR      R8,[R0, #+28]
   \      0x2C8   0xE009             B.N      ??PID_autotune_36
   \                     ??PID_autotune_34: (+1)
   \      0x2CA   0x2A00             CMP      R2,#+0
   \      0x2CC   0xD005             BEQ.N    ??PID_autotune_37
   \      0x2CE   0x9803             LDR      R0,[SP, #+12]
   \      0x2D0   0xEB05 0x0080      ADD      R0,R5,R0, LSL #+2
   \      0x2D4   0xF8D0 0x801C      LDR      R8,[R0, #+28]
   \      0x2D8   0xE001             B.N      ??PID_autotune_36
   \                     ??PID_autotune_37: (+1)
   \      0x2DA   0xF8D5 0x8020      LDR      R8,[R5, #+32]
   \                     ??PID_autotune_36: (+1)
   \      0x2DE   0x9805             LDR      R0,[SP, #+20]
   \      0x2E0   0x4641             MOV      R1,R8
   \      0x2E2   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x2E6   0xD201             BCS.N    ??PID_autotune_38
   \      0x2E8   0xF8CD 0x8014      STR      R8,[SP, #+20]
   \                     ??PID_autotune_38: (+1)
   \      0x2EC   0x4640             MOV      R0,R8
   \      0x2EE   0x9904             LDR      R1,[SP, #+16]
   \      0x2F0   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x2F4   0xD201             BCS.N    ??PID_autotune_39
   \      0x2F6   0xF8CD 0x8010      STR      R8,[SP, #+16]
   \                     ??PID_autotune_39: (+1)
   \      0x2FA   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \      0x2FE   0x2800             CMP      R0,#+0
   \      0x300   0xD01E             BEQ.N    ??PID_autotune_40
   \      0x302   0x980A             LDR      R0,[SP, #+40]
   \      0x304   0x4641             MOV      R1,R8
   \      0x306   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x30A   0xD219             BCS.N    ??PID_autotune_40
   \      0x30C   0x9908             LDR      R1,[SP, #+32]
   \      0x30E   0x1A71             SUBS     R1,R6,R1
   \      0x310   0x.... 0x....      LDR.W    R0,??DataTable49  ;; 0xffffec78
   \      0x314   0x1840             ADDS     R0,R0,R1
   \      0x316   0xD413             BMI.N    ??PID_autotune_40
   \      0x318   0x2000             MOVS     R0,#+0
   \      0x31A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \      0x31E   0x2A00             CMP      R2,#+0
   \      0x320   0xD037             BEQ.N    ??PID_autotune_41
   \      0x322   0x9801             LDR      R0,[SP, #+4]
   \      0x324   0x7840             LDRB     R0,[R0, #+1]
   \      0x326   0x2800             CMP      R0,#+0
   \      0x328   0xD033             BEQ.N    ??PID_autotune_41
   \      0x32A   0x9803             LDR      R0,[SP, #+12]
   \      0x32C   0x2800             CMP      R0,#+0
   \      0x32E   0xD532             BPL.N    ??PID_autotune_42
   \                     ??PID_autotune_43: (+1)
   \      0x330   0x9802             LDR      R0,[SP, #+8]
   \      0x332   0x1A38             SUBS     R0,R7,R0
   \      0x334   0x1040             ASRS     R0,R0,#+1
   \      0x336   0x7028             STRB     R0,[R5, #+0]
   \                     ??PID_autotune_44: (+1)
   \      0x338   0x9609             STR      R6,[SP, #+36]
   \      0x33A   0x9107             STR      R1,[SP, #+28]
   \      0x33C   0x980A             LDR      R0,[SP, #+40]
   \      0x33E   0x9005             STR      R0,[SP, #+20]
   \                     ??PID_autotune_40: (+1)
   \      0x340   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \      0x344   0x2800             CMP      R0,#+0
   \      0x346   0xF040 0x80DE      BNE.W    ??PID_autotune_33
   \      0x34A   0x4640             MOV      R0,R8
   \      0x34C   0x990A             LDR      R1,[SP, #+40]
   \      0x34E   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x352   0xF080 0x80D8      BCS.W    ??PID_autotune_33
   \      0x356   0x9809             LDR      R0,[SP, #+36]
   \      0x358   0x1A30             SUBS     R0,R6,R0
   \      0x35A   0x.... 0x....      LDR.W    R1,??DataTable49  ;; 0xffffec78
   \      0x35E   0x1809             ADDS     R1,R1,R0
   \      0x360   0xF100 0x80D1      BMI.W    ??PID_autotune_33
   \      0x364   0x2101             MOVS     R1,#+1
   \      0x366   0xF88D 0x1000      STRB     R1,[SP, #+0]
   \      0x36A   0x9608             STR      R6,[SP, #+32]
   \      0x36C   0x9906             LDR      R1,[SP, #+24]
   \      0x36E   0x2900             CMP      R1,#+0
   \      0x370   0xF340 0x80B5      BLE.W    ??PID_autotune_45
   \      0x374   0x9907             LDR      R1,[SP, #+28]
   \      0x376   0x1809             ADDS     R1,R1,R0
   \      0x378   0x910B             STR      R1,[SP, #+44]
   \      0x37A   0x9902             LDR      R1,[SP, #+8]
   \      0x37C   0x9A07             LDR      R2,[SP, #+28]
   \      0x37E   0x1A10             SUBS     R0,R2,R0
   \      0x380   0x4348             MULS     R0,R0,R1
   \      0x382   0x990B             LDR      R1,[SP, #+44]
   \      0x384   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \      0x388   0x19C7             ADDS     R7,R0,R7
   \      0x38A   0x2F14             CMP      R7,#+20
   \      0x38C   0xDA0A             BGE.N    ??PID_autotune_46
   \      0x38E   0x2714             MOVS     R7,#+20
   \      0x390   0xE00B             B.N      ??PID_autotune_47
   \                     ??PID_autotune_41: (+1)
   \      0x392   0x2A00             CMP      R2,#+0
   \      0x394   0xD0CC             BEQ.N    ??PID_autotune_43
   \                     ??PID_autotune_42: (+1)
   \      0x396   0x9802             LDR      R0,[SP, #+8]
   \      0x398   0x1A38             SUBS     R0,R7,R0
   \      0x39A   0x1040             ASRS     R0,R0,#+1
   \      0x39C   0x9A03             LDR      R2,[SP, #+12]
   \      0x39E   0x442A             ADD      R2,R5,R2
   \      0x3A0   0x70D0             STRB     R0,[R2, #+3]
   \      0x3A2   0xE7C9             B.N      ??PID_autotune_44
   \                     ??PID_autotune_46: (+1)
   \      0x3A4   0x2FEB             CMP      R7,#+235
   \      0x3A6   0xDD00             BLE.N    ??PID_autotune_47
   \      0x3A8   0x27EB             MOVS     R7,#+235
   \                     ??PID_autotune_47: (+1)
   \      0x3AA   0x2F7F             CMP      R7,#+127
   \      0x3AC   0xDD03             BLE.N    ??PID_autotune_48
   \      0x3AE   0xF1C7 0x00FE      RSB      R0,R7,#+254
   \      0x3B2   0x9002             STR      R0,[SP, #+8]
   \      0x3B4   0xE000             B.N      ??PID_autotune_49
   \                     ??PID_autotune_48: (+1)
   \      0x3B6   0x9702             STR      R7,[SP, #+8]
   \                     ??PID_autotune_49: (+1)
   \      0x3B8   0x4639             MOV      R1,R7
   \      0x3BA   0x.... 0x....      ADR.W    R0,?_5
   \      0x3BE   0x.... 0x....      BL       _Z17serial_echopair_PPKcl
   \      0x3C2   0x9902             LDR      R1,[SP, #+8]
   \      0x3C4   0x.... 0x....      ADR.W    R0,?_6
   \      0x3C8   0x.... 0x....      BL       _Z17serial_echopair_PPKcl
   \      0x3CC   0x9904             LDR      R1,[SP, #+16]
   \      0x3CE   0x.... 0x....      ADR.W    R0,?_7
   \      0x3D2   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \      0x3D6   0x9905             LDR      R1,[SP, #+20]
   \      0x3D8   0x.... 0x....      ADR.W    R0,?_8
   \      0x3DC   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \      0x3E0   0x9806             LDR      R0,[SP, #+24]
   \      0x3E2   0x2803             CMP      R0,#+3
   \      0x3E4   0xDB7B             BLT.N    ??PID_autotune_45
   \      0x3E6   0x9802             LDR      R0,[SP, #+8]
   \      0x3E8   0x.... 0x....      BL       __aeabi_i2d
   \      0x3EC   0x2200             MOVS     R2,#+0
   \      0x3EE   0x.... 0x....      LDR.W    R3,??DataTable49_1  ;; 0x40100000
   \      0x3F2   0x.... 0x....      BL       __aeabi_dmul
   \      0x3F6   0x4682             MOV      R10,R0
   \      0x3F8   0x468B             MOV      R11,R1
   \      0x3FA   0x9805             LDR      R0,[SP, #+20]
   \      0x3FC   0x9904             LDR      R1,[SP, #+16]
   \      0x3FE   0x.... 0x....      BL       __aeabi_fsub
   \      0x402   0x.... 0x....      BL       __aeabi_f2d
   \      0x406   0x.... 0x....      LDR.W    R2,??DataTable50  ;; 0x54442d18
   \      0x40A   0x.... 0x....      LDR.W    R3,??DataTable50_1  ;; 0x400921fb
   \      0x40E   0x.... 0x....      BL       __aeabi_dmul
   \      0x412   0x2200             MOVS     R2,#+0
   \      0x414   0x.... 0x....      LDR.W    R3,??DataTable50_2  ;; 0x3fe00000
   \      0x418   0x.... 0x....      BL       __aeabi_dmul
   \      0x41C   0x4602             MOV      R2,R0
   \      0x41E   0x460B             MOV      R3,R1
   \      0x420   0x4650             MOV      R0,R10
   \      0x422   0x4659             MOV      R1,R11
   \      0x424   0x.... 0x....      BL       __aeabi_ddiv
   \      0x428   0x.... 0x....      BL       __aeabi_d2f
   \      0x42C   0x4681             MOV      R9,R0
   \      0x42E   0x980B             LDR      R0,[SP, #+44]
   \      0x430   0x.... 0x....      BL       __aeabi_i2f
   \      0x434   0x.... 0x....      BL       __aeabi_f2d
   \      0x438   0x.... 0x....      LDR.W    R2,??DataTable50_3  ;; 0xd2f1a9fc
   \      0x43C   0x.... 0x....      LDR.W    R3,??DataTable50_4  ;; 0x3f50624d
   \      0x440   0x.... 0x....      BL       __aeabi_dmul
   \      0x444   0x.... 0x....      BL       __aeabi_d2f
   \      0x448   0x4682             MOV      R10,R0
   \      0x44A   0x4649             MOV      R1,R9
   \      0x44C   0x.... 0x....      ADR.W    R0,?_9
   \      0x450   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \      0x454   0x4651             MOV      R1,R10
   \      0x456   0x.... 0x....      ADR.W    R0,?_10
   \      0x45A   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \      0x45E   0x4648             MOV      R0,R9
   \      0x460   0x.... 0x....      BL       __aeabi_f2d
   \      0x464   0xF04F 0x3233      MOV      R2,#+858993459
   \      0x468   0x.... 0x....      LDR.W    R3,??DataTable50_5  ;; 0x3fe33333
   \      0x46C   0x.... 0x....      BL       __aeabi_dmul
   \      0x470   0x.... 0x....      BL       __aeabi_d2f
   \      0x474   0x4683             MOV      R11,R0
   \      0x476   0xF04F 0x4080      MOV      R0,#+1073741824
   \      0x47A   0x4659             MOV      R1,R11
   \      0x47C   0x.... 0x....      BL       __aeabi_fmul
   \      0x480   0x4651             MOV      R1,R10
   \      0x482   0x.... 0x....      BL       __aeabi_fdiv
   \      0x486   0x4681             MOV      R9,R0
   \      0x488   0x4658             MOV      R0,R11
   \      0x48A   0x4651             MOV      R1,R10
   \      0x48C   0x.... 0x....      BL       __aeabi_fmul
   \      0x490   0xF04F 0x5178      MOV      R1,#+1040187392
   \      0x494   0x.... 0x....      BL       __aeabi_fmul
   \      0x498   0x4682             MOV      R10,R0
   \      0x49A   0x.... 0x....      ADR.W    R0,?_11
   \      0x49E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \      0x4A2   0x4659             MOV      R1,R11
   \      0x4A4   0x.... 0x....      ADR.W    R0,?_12
   \      0x4A8   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \      0x4AC   0x4649             MOV      R1,R9
   \      0x4AE   0x.... 0x....      ADR.W    R0,?_13
   \      0x4B2   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \      0x4B6   0x4651             MOV      R1,R10
   \      0x4B8   0x.... 0x....      ADR.W    R0,?_14
   \      0x4BC   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \      0x4C0   0x7820             LDRB     R0,[R4, #+0]
   \      0x4C2   0x2800             CMP      R0,#+0
   \      0x4C4   0xD105             BNE.N    ??PID_autotune_50
   \      0x4C6   0x210A             MOVS     R1,#+10
   \      0x4C8   0x.... 0x....      LDR.W    R0,??DataTable47_4
   \      0x4CC   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \      0x4D0   0xE005             B.N      ??PID_autotune_45
   \                     ??PID_autotune_50: (+1)
   \      0x4D2   0x2200             MOVS     R2,#+0
   \      0x4D4   0x210A             MOVS     R1,#+10
   \      0x4D6   0x.... 0x....      LDR.W    R0,??DataTable47_5
   \      0x4DA   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   \                     ??PID_autotune_45: (+1)
   \      0x4DE   0x9801             LDR      R0,[SP, #+4]
   \      0x4E0   0x7800             LDRB     R0,[R0, #+0]
   \      0x4E2   0x2800             CMP      R0,#+0
   \      0x4E4   0xD020             BEQ.N    ??PID_autotune_51
   \      0x4E6   0x9901             LDR      R1,[SP, #+4]
   \      0x4E8   0x7849             LDRB     R1,[R1, #+1]
   \      0x4EA   0x2900             CMP      R1,#+0
   \      0x4EC   0xD01C             BEQ.N    ??PID_autotune_51
   \      0x4EE   0x9803             LDR      R0,[SP, #+12]
   \      0x4F0   0x2800             CMP      R0,#+0
   \      0x4F2   0xD51B             BPL.N    ??PID_autotune_52
   \                     ??PID_autotune_53: (+1)
   \      0x4F4   0x9802             LDR      R0,[SP, #+8]
   \      0x4F6   0x19C0             ADDS     R0,R0,R7
   \      0x4F8   0x1040             ASRS     R0,R0,#+1
   \      0x4FA   0x7028             STRB     R0,[R5, #+0]
   \                     ??PID_autotune_54: (+1)
   \      0x4FC   0x9806             LDR      R0,[SP, #+24]
   \      0x4FE   0x1C40             ADDS     R0,R0,#+1
   \      0x500   0x9006             STR      R0,[SP, #+24]
   \      0x502   0x980A             LDR      R0,[SP, #+40]
   \      0x504   0x9004             STR      R0,[SP, #+16]
   \                     ??PID_autotune_33: (+1)
   \      0x506   0x980A             LDR      R0,[SP, #+40]
   \      0x508   0x.... 0x....      LDR.W    R1,??DataTable52  ;; 0x41a00000
   \      0x50C   0x.... 0x....      BL       __aeabi_fadd
   \      0x510   0x4641             MOV      R1,R8
   \      0x512   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x516   0xF4BF 0xAE95      BCS.W    ??PID_autotune_26
   \      0x51A   0x.... 0x....      ADR.W    R0,?_15
   \      0x51E   0xB011             ADD      SP,SP,#+68
   \      0x520   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \      0x524   0x.... 0x....      B.W      _Z14serialprintPGMPKc
   \                     ??PID_autotune_51: (+1)
   \      0x528   0x2800             CMP      R0,#+0
   \      0x52A   0xD0E3             BEQ.N    ??PID_autotune_53
   \                     ??PID_autotune_52: (+1)
   \      0x52C   0x9802             LDR      R0,[SP, #+8]
   \      0x52E   0x19C0             ADDS     R0,R0,R7
   \      0x530   0x1040             ASRS     R0,R0,#+1
   \      0x532   0x9903             LDR      R1,[SP, #+12]
   \      0x534   0x4429             ADD      R1,R5,R1
   \      0x536   0x70C8             STRB     R0,[R1, #+3]
   \      0x538   0xE7E0             B.N      ??PID_autotune_54
   \                     ??PID_autotune_28: (+1)
   \      0x53A   0x2200             MOVS     R2,#+0
   \      0x53C   0x210A             MOVS     R1,#+10
   \      0x53E   0x.... 0x....      LDR.W    R0,??DataTable47_5
   \      0x542   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   \      0x546   0xE68D             B.N      ??PID_autotune_29
   \                     ??PID_autotune_30: (+1)
   \      0x548   0x.... 0x....      ADR.W    R0,?_16
   \      0x54C   0xB011             ADD      SP,SP,#+68
   \      0x54E   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \      0x552   0x.... 0x....      B.W      _Z14serialprintPGMPKc
   \                     ??PID_autotune_31: (+1)
   \      0x556   0x9F03             LDR      R7,[SP, #+12]
   \      0x558   0x465E             MOV      R6,R11
   \      0x55A   0x.... 0x....      ADR.W    R0,?_17
   \      0x55E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \      0x562   0x9801             LDR      R0,[SP, #+4]
   \      0x564   0x7800             LDRB     R0,[R0, #+0]
   \      0x566   0x2800             CMP      R0,#+0
   \      0x568   0xD052             BEQ.N    ??PID_autotune_55
   \      0x56A   0x9901             LDR      R1,[SP, #+4]
   \      0x56C   0x7849             LDRB     R1,[R1, #+1]
   \      0x56E   0x2900             CMP      R1,#+0
   \      0x570   0xD04E             BEQ.N    ??PID_autotune_55
   \      0x572   0x2F00             CMP      R7,#+0
   \      0x574   0xD502             BPL.N    ??PID_autotune_56
   \      0x576   0x.... 0x....      ADR.W    R8,??DataTable42  ;; "bed"
   \      0x57A   0xE001             B.N      ??PID_autotune_57
   \                     ??PID_autotune_56: (+1)
   \      0x57C   0x.... 0x....      ADR.W    R8,??DataTable42_1  ;; ""
   \                     ??PID_autotune_57: (+1)
   \      0x580   0x.... 0x....      ADR.W    R11,?_20
   \      0x584   0x4641             MOV      R1,R8
   \      0x586   0x4658             MOV      R0,R11
   \      0x588   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
   \      0x58C   0x4631             MOV      R1,R6
   \      0x58E   0x....             ADR.N    R0,??DataTable42_2  ;; "Kp "
   \      0x590   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \      0x594   0x7820             LDRB     R0,[R4, #+0]
   \      0x596   0x2800             CMP      R0,#+0
   \      0x598   0xD105             BNE.N    ??PID_autotune_58
   \      0x59A   0x210A             MOVS     R1,#+10
   \      0x59C   0x.... 0x....      LDR.W    R0,??DataTable47_4
   \      0x5A0   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \      0x5A4   0xE005             B.N      ??PID_autotune_59
   \                     ??PID_autotune_58: (+1)
   \      0x5A6   0x2200             MOVS     R2,#+0
   \      0x5A8   0x210A             MOVS     R1,#+10
   \      0x5AA   0x.... 0x....      LDR.W    R0,??DataTable47_5
   \      0x5AE   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   \                     ??PID_autotune_59: (+1)
   \      0x5B2   0x4641             MOV      R1,R8
   \      0x5B4   0x4658             MOV      R0,R11
   \      0x5B6   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
   \      0x5BA   0x4649             MOV      R1,R9
   \      0x5BC   0x....             ADR.N    R0,??DataTable42_3  ;; "Ki "
   \      0x5BE   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \      0x5C2   0x7820             LDRB     R0,[R4, #+0]
   \      0x5C4   0x2800             CMP      R0,#+0
   \      0x5C6   0xD105             BNE.N    ??PID_autotune_60
   \      0x5C8   0x210A             MOVS     R1,#+10
   \      0x5CA   0x.... 0x....      LDR.W    R0,??DataTable47_4
   \      0x5CE   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \      0x5D2   0xE005             B.N      ??PID_autotune_61
   \                     ??PID_autotune_60: (+1)
   \      0x5D4   0x2200             MOVS     R2,#+0
   \      0x5D6   0x210A             MOVS     R1,#+10
   \      0x5D8   0x.... 0x....      LDR.W    R0,??DataTable47_5
   \      0x5DC   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   \                     ??PID_autotune_61: (+1)
   \      0x5E0   0x4641             MOV      R1,R8
   \      0x5E2   0x4658             MOV      R0,R11
   \      0x5E4   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
   \      0x5E8   0x4651             MOV      R1,R10
   \      0x5EA   0x....             ADR.N    R0,??DataTable42_4  ;; "Kd "
   \      0x5EC   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \      0x5F0   0x7820             LDRB     R0,[R4, #+0]
   \      0x5F2   0x2800             CMP      R0,#+0
   \      0x5F4   0xD105             BNE.N    ??PID_autotune_62
   \      0x5F6   0x210A             MOVS     R1,#+10
   \      0x5F8   0x.... 0x....      LDR.W    R0,??DataTable47_4
   \      0x5FC   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \      0x600   0xE080             B.N      ??PID_autotune_63
   \                     ??PID_autotune_62: (+1)
   \      0x602   0x2200             MOVS     R2,#+0
   \      0x604   0x210A             MOVS     R1,#+10
   \      0x606   0x.... 0x....      LDR.W    R0,??DataTable47_5
   \      0x60A   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   \      0x60E   0xE079             B.N      ??PID_autotune_63
   \                     ??PID_autotune_55: (+1)
   \      0x610   0x2800             CMP      R0,#+0
   \      0x612   0x4631             MOV      R1,R6
   \      0x614   0xD03B             BEQ.N    ??PID_autotune_64
   \      0x616   0x.... 0x....      ADR.W    R0,?_24
   \      0x61A   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \      0x61E   0x7820             LDRB     R0,[R4, #+0]
   \      0x620   0x2800             CMP      R0,#+0
   \      0x622   0xD105             BNE.N    ??PID_autotune_65
   \      0x624   0x210A             MOVS     R1,#+10
   \      0x626   0x.... 0x....      LDR.W    R0,??DataTable47_4
   \      0x62A   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \      0x62E   0xE005             B.N      ??PID_autotune_66
   \                     ??PID_autotune_65: (+1)
   \      0x630   0x2200             MOVS     R2,#+0
   \      0x632   0x210A             MOVS     R1,#+10
   \      0x634   0x.... 0x....      LDR.W    R0,??DataTable47_5
   \      0x638   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   \                     ??PID_autotune_66: (+1)
   \      0x63C   0x4649             MOV      R1,R9
   \      0x63E   0x.... 0x....      ADR.W    R0,?_25
   \      0x642   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \      0x646   0x7820             LDRB     R0,[R4, #+0]
   \      0x648   0x2800             CMP      R0,#+0
   \      0x64A   0xD105             BNE.N    ??PID_autotune_67
   \      0x64C   0x210A             MOVS     R1,#+10
   \      0x64E   0x.... 0x....      LDR.W    R0,??DataTable47_4
   \      0x652   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \      0x656   0xE005             B.N      ??PID_autotune_68
   \                     ??PID_autotune_67: (+1)
   \      0x658   0x2200             MOVS     R2,#+0
   \      0x65A   0x210A             MOVS     R1,#+10
   \      0x65C   0x.... 0x....      LDR.W    R0,??DataTable47_5
   \      0x660   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   \                     ??PID_autotune_68: (+1)
   \      0x664   0x4651             MOV      R1,R10
   \      0x666   0x.... 0x....      ADR.W    R0,?_26
   \      0x66A   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \      0x66E   0x7820             LDRB     R0,[R4, #+0]
   \      0x670   0x2800             CMP      R0,#+0
   \      0x672   0xD105             BNE.N    ??PID_autotune_69
   \      0x674   0x210A             MOVS     R1,#+10
   \      0x676   0x.... 0x....      LDR.W    R0,??DataTable47_4
   \      0x67A   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \      0x67E   0xE041             B.N      ??PID_autotune_63
   \                     ??PID_autotune_69: (+1)
   \      0x680   0x2200             MOVS     R2,#+0
   \      0x682   0x210A             MOVS     R1,#+10
   \      0x684   0x.... 0x....      LDR.W    R0,??DataTable47_5
   \      0x688   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   \      0x68C   0xE03A             B.N      ??PID_autotune_63
   \                     ??PID_autotune_64: (+1)
   \      0x68E   0x.... 0x....      ADR.W    R0,?_27
   \      0x692   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \      0x696   0x7820             LDRB     R0,[R4, #+0]
   \      0x698   0x2800             CMP      R0,#+0
   \      0x69A   0xD105             BNE.N    ??PID_autotune_70
   \      0x69C   0x210A             MOVS     R1,#+10
   \      0x69E   0x.... 0x....      LDR.W    R0,??DataTable47_4
   \      0x6A2   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \      0x6A6   0xE005             B.N      ??PID_autotune_71
   \                     ??PID_autotune_70: (+1)
   \      0x6A8   0x2200             MOVS     R2,#+0
   \      0x6AA   0x210A             MOVS     R1,#+10
   \      0x6AC   0x.... 0x....      LDR.W    R0,??DataTable47_5
   \      0x6B0   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   \                     ??PID_autotune_71: (+1)
   \      0x6B4   0x4649             MOV      R1,R9
   \      0x6B6   0x.... 0x....      ADR.W    R0,?_28
   \      0x6BA   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \      0x6BE   0x7820             LDRB     R0,[R4, #+0]
   \      0x6C0   0x2800             CMP      R0,#+0
   \      0x6C2   0xD105             BNE.N    ??PID_autotune_72
   \      0x6C4   0x210A             MOVS     R1,#+10
   \      0x6C6   0x.... 0x....      LDR.W    R0,??DataTable47_4
   \      0x6CA   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \      0x6CE   0xE005             B.N      ??PID_autotune_73
   \                     ??PID_autotune_72: (+1)
   \      0x6D0   0x2200             MOVS     R2,#+0
   \      0x6D2   0x210A             MOVS     R1,#+10
   \      0x6D4   0x.... 0x....      LDR.W    R0,??DataTable47_5
   \      0x6D8   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   \                     ??PID_autotune_73: (+1)
   \      0x6DC   0x4651             MOV      R1,R10
   \      0x6DE   0x.... 0x....      ADR.W    R0,?_29
   \      0x6E2   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \      0x6E6   0x7820             LDRB     R0,[R4, #+0]
   \      0x6E8   0x2800             CMP      R0,#+0
   \      0x6EA   0xD105             BNE.N    ??PID_autotune_74
   \      0x6EC   0x210A             MOVS     R1,#+10
   \      0x6EE   0x.... 0x....      LDR.W    R0,??DataTable47_4
   \      0x6F2   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \      0x6F6   0xE005             B.N      ??PID_autotune_63
   \                     ??PID_autotune_74: (+1)
   \      0x6F8   0x2200             MOVS     R2,#+0
   \      0x6FA   0x210A             MOVS     R1,#+10
   \      0x6FC   0x.... 0x....      LDR.W    R0,??DataTable47_5
   \      0x700   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   \                     ??PID_autotune_63: (+1)
   \      0x704   0x9801             LDR      R0,[SP, #+4]
   \      0x706   0x7800             LDRB     R0,[R0, #+0]
   \      0x708   0x2800             CMP      R0,#+0
   \      0x70A   0xD036             BEQ.N    ??PID_autotune_75
   \      0x70C   0x9801             LDR      R0,[SP, #+4]
   \      0x70E   0x7840             LDRB     R0,[R0, #+1]
   \      0x710   0x2800             CMP      R0,#+0
   \      0x712   0xD032             BEQ.N    ??PID_autotune_75
   \      0x714   0xF89D 0x0040      LDRB     R0,[SP, #+64]
   \      0x718   0x2800             CMP      R0,#+0
   \      0x71A   0xD02E             BEQ.N    ??PID_autotune_75
   \      0x71C   0x4650             MOV      R0,R10
   \      0x71E   0x.... 0x....      BL       __aeabi_f2d
   \      0x722   0x.... 0x....      LDR.W    R2,??DataTable56  ;; 0x88e368f1
   \      0x726   0x.... 0x....      LDR.W    R3,??DataTable58  ;; 0x3fc4f8b5
   \      0x72A   0x.... 0x....      BL       __aeabi_ddiv
   \      0x72E   0x.... 0x....      BL       __aeabi_d2f
   \      0x732   0x4604             MOV      R4,R0
   \      0x734   0x4648             MOV      R0,R9
   \      0x736   0x.... 0x....      BL       __aeabi_f2d
   \      0x73A   0x.... 0x....      LDR.W    R2,??DataTable56  ;; 0x88e368f1
   \      0x73E   0x.... 0x....      LDR.W    R3,??DataTable58  ;; 0x3fc4f8b5
   \      0x742   0x.... 0x....      BL       __aeabi_dmul
   \      0x746   0x.... 0x....      BL       __aeabi_d2f
   \      0x74A   0x2F00             CMP      R7,#+0
   \      0x74C   0xD406             BMI.N    ??PID_autotune_76
   \      0x74E   0x636E             STR      R6,[R5, #+52]
   \      0x750   0x63A8             STR      R0,[R5, #+56]
   \      0x752   0x63EC             STR      R4,[R5, #+60]
   \      0x754   0xB011             ADD      SP,SP,#+68
   \      0x756   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \      0x75A   0x....             B.N      _ZN11Temperature9updatePIDEv
   \                     ??PID_autotune_76: (+1)
   \      0x75C   0x642E             STR      R6,[R5, #+64]
   \      0x75E   0x6468             STR      R0,[R5, #+68]
   \      0x760   0x64AC             STR      R4,[R5, #+72]
   \      0x762   0xB011             ADD      SP,SP,#+68
   \      0x764   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \      0x768   0x....             B.N      _ZN11Temperature9updatePIDEv
    539              }
    540              if (!wait_for_heatup) disable_all_heaters();
   \                     ??PID_autotune_32: (+1)
   \      0x76A   0x7808             LDRB     R0,[R1, #+0]
   \      0x76C   0x2800             CMP      R0,#+0
   \      0x76E   0xD104             BNE.N    ??PID_autotune_75
   \      0x770   0xB011             ADD      SP,SP,#+68
   \      0x772   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \      0x776   0x.... 0x....      B.W      _ZN11Temperature19disable_all_heatersEv
    541            }
   \                     ??PID_autotune_75: (+1)
   \      0x77A   0xB011             ADD      SP,SP,#+68
   \      0x77C   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    542          
    543          #endif // HAS_PID_HEATING
    544          
    545          /**
    546           * Class and Instance Methods
    547           */
    548          

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp Temperature::subobject Temperature()
   \                     _ZN11TemperatureC2Ev: (+1)
   \        0x0   0x.... 0x....      B.W      _ZN11TemperatureC1Ev

   \                                 In section .text, align 2, keep-with-next
    549          Temperature::Temperature() { }
   \                     _ZN11TemperatureC1Ev: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    550          

   \                                 In section .text, align 2, keep-with-next
    551          void Temperature::updatePID() {
    552            //#if ENABLED(PIDTEMP)	/*--mks cfg--*/
    553            #if 1
    554              #if ENABLED(PID_EXTRUSION_SCALING)
    555                last_e_position = 0;
    556              #endif
    557            #endif
    558          }
   \                     _ZN11Temperature9updatePIDEv: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    559          

   \                                 In section .text, align 2, keep-with-next
    560          int Temperature::getHeaterPower(int heater) {
    561            return heater < 0 ? soft_pwm_bed : soft_pwm[heater];
   \                     _ZN11Temperature14getHeaterPowerEi: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable59
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD501             BPL.N    ??getHeaterPower_0
   \        0x8   0x7808             LDRB     R0,[R1, #+0]
   \        0xA   0x4770             BX       LR
   \                     ??getHeaterPower_0: (+1)
   \        0xC   0x4408             ADD      R0,R1,R0
   \        0xE   0x78C0             LDRB     R0,[R0, #+3]
   \       0x10   0x4770             BX       LR               ;; return
    562          }
    563          
    564          #if HAS_AUTO_FAN
    565          
    566            void Temperature::checkExtruderAutoFans() {
    567              constexpr int8_t fanPin[] = { E0_AUTO_FAN_PIN, E1_AUTO_FAN_PIN, E2_AUTO_FAN_PIN, E3_AUTO_FAN_PIN, E4_AUTO_FAN_PIN };
    568              constexpr int fanBit[] = {
    569                              0,
    570                AUTO_1_IS_0 ? 0 :               1,
    571                AUTO_2_IS_0 ? 0 : AUTO_2_IS_1 ? 1 :               2,
    572                AUTO_3_IS_0 ? 0 : AUTO_3_IS_1 ? 1 : AUTO_3_IS_2 ? 2 :               3,
    573                AUTO_4_IS_0 ? 0 : AUTO_4_IS_1 ? 1 : AUTO_4_IS_2 ? 2 : AUTO_4_IS_3 ? 3 : 4
    574              };
    575              uint8_t fanState = 0;
    576          
    577              HOTEND_LOOP() {
    578                if (current_temperature[e] > EXTRUDER_AUTO_FAN_TEMPERATURE)
    579                  SBI(fanState, fanBit[e]);
    580              }
    581          
    582              uint8_t fanDone = 0;
    583              for (uint8_t f = 0; f < COUNT(fanPin); f++) {
    584                int8_t pin = fanPin[f];
    585                if (pin >= 0 && !TEST(fanDone, fanBit[f])) {
    586                  uint8_t newFanSpeed = TEST(fanState, fanBit[f]) ? EXTRUDER_AUTO_FAN_SPEED : 0;
    587                  // this idiom allows both digital and PWM fan outputs (see M42 handling).
    588                  digitalWrite(pin, newFanSpeed);
    589                  analogWrite(pin, newFanSpeed);
    590                  SBI(fanDone, fanBit[f]);
    591                }
    592              }
    593            }
    594          
    595          #endif // HAS_AUTO_FAN
    596          
    597          //
    598          // Temperature Error Handlers
    599          //

   \                                 In section .text, align 4, keep-with-next
    600          void Temperature::_temp_error(int e, const char* serial_msg, const char* lcd_msg) {
   \                     _ZN11Temperature11_temp_errorEiPKcS1_: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460E             MOV      R6,R1
   \        0x6   0x4614             MOV      R4,R2
    601            static bool killed = false;
    602            if (IsRunning()) {
   \        0x8   0x.... 0x....      BL       _Z9IsRunningv
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD02C             BEQ.N    ??_temp_error_0
    603              SERIAL_ERROR_START;
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable58_1
   \       0x14   0x.... 0x....      BL       _Z14serialprintPGMPKc
    604              serialprintPGM(serial_msg);
   \       0x18   0x4630             MOV      R0,R6
   \       0x1A   0x.... 0x....      BL       _Z14serialprintPGMPKc
    605              SERIAL_ERRORPGM(MSG_STOPPED_HEATER);
   \       0x1E   0xBF00             Nop      
   \       0x20   0x....             ADR.N    R0,?_30
   \       0x22   0x.... 0x....      BL       _Z14serialprintPGMPKc
    606              if (e >= 0) {SERIAL_ERRORLN((int)e);} else {SERIAL_ERRORLNPGM(MSG_HEATER_BED);}
   \       0x26   0x2D00             CMP      R5,#+0
   \       0x28   0xD41C             BMI.N    ??_temp_error_1
   \       0x2A   0x....             LDR.N    R6,??DataTable47_3
   \       0x2C   0x7830             LDRB     R0,[R6, #+0]
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD105             BNE.N    ??_temp_error_2
   \       0x32   0x220A             MOVS     R2,#+10
   \       0x34   0x4629             MOV      R1,R5
   \       0x36   0x....             LDR.N    R0,??DataTable47_4
   \       0x38   0x.... 0x....      BL       _ZN12MarlinSerial5printEii
   \       0x3C   0xE004             B.N      ??_temp_error_3
   \                     ??_temp_error_2: (+1)
   \       0x3E   0x220A             MOVS     R2,#+10
   \       0x40   0x4629             MOV      R1,R5
   \       0x42   0x....             LDR.N    R0,??DataTable47_5
   \       0x44   0x.... 0x....      BL       _ZN12MarlinSerial5printEii
   \                     ??_temp_error_3: (+1)
   \       0x48   0x7830             LDRB     R0,[R6, #+0]
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD104             BNE.N    ??_temp_error_4
   \       0x4E   0x210A             MOVS     R1,#+10
   \       0x50   0x....             LDR.N    R0,??DataTable47_4
   \       0x52   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \       0x56   0xE008             B.N      ??_temp_error_0
   \                     ??_temp_error_4: (+1)
   \       0x58   0x2200             MOVS     R2,#+0
   \       0x5A   0x210A             MOVS     R1,#+10
   \       0x5C   0x....             LDR.N    R0,??DataTable47_5
   \       0x5E   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   \       0x62   0xE002             B.N      ??_temp_error_0
   \                     ??_temp_error_1: (+1)
   \       0x64   0x....             ADR.N    R0,?_31
   \       0x66   0x.... 0x....      BL       _Z14serialprintPGMPKc
    607            }
    608            #if DISABLED(BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE)
    609              if (!killed) {
   \                     ??_temp_error_0: (+1)
   \       0x6A   0x.... 0x....      LDR.W    R1,??DataTable58_2
   \       0x6E   0x7808             LDRB     R0,[R1, #+0]
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xD10A             BNE.N    ??_temp_error_5
    610                Running = false;
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0x.... 0x....      LDR.W    R2,??DataTable59_1
   \       0x7A   0x7010             STRB     R0,[R2, #+0]
    611                killed = true;
   \       0x7C   0x2001             MOVS     R0,#+1
   \       0x7E   0x7008             STRB     R0,[R1, #+0]
    612                kill(lcd_msg);
   \       0x80   0x4620             MOV      R0,R4
   \       0x82   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x86   0x.... 0x....      B.W      _Z4killPKc
    613              }
    614              else
    615                disable_all_heaters(); // paranoia
   \                     ??_temp_error_5: (+1)
   \       0x8A   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x8E   0x.... 0x....      B.W      _ZN11Temperature19disable_all_heatersEv
    616            #endif
    617          }

   \                                 In section .bss, align 1
   \                     `Temperature::_temp_error(int, char const *, char const *)::killed`:
   \        0x0                      DS8 1
    618          

   \                                 In section .text, align 4, keep-with-next
    619          void Temperature::max_temp_error(int8_t e) {
    620          /*--mks cfg begin-- HAS_TEMP_BED */	
    621          /*
    622            #if HAS_TEMP_BED
    623              _temp_error(e, PSTR(MSG_T_MAXTEMP), e >= 0 ? PSTR(MSG_ERR_MAXTEMP) : PSTR(MSG_ERR_MAXTEMP_BED));
    624            #else
    625              _temp_error(HOTEND_INDEX, PSTR(MSG_T_MAXTEMP), PSTR(MSG_ERR_MAXTEMP));
    626              #if HOTENDS == 1
    627                UNUSED(e);
    628              #endif
    629            #endif
    630          */
    631          if(HAS_TEMP_BED)
   \                     _ZN11Temperature14max_temp_errorEa: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable59_2
   \        0x4   0xF891 0x1036      LDRB     R1,[R1, #+54]
   \        0x8   0x2900             CMP      R1,#+0
   \        0xA   0xD007             BEQ.N    ??max_temp_error_0
    632          	  _temp_error(e, PSTR(MSG_T_MAXTEMP), e >= 0 ? PSTR(MSG_ERR_MAXTEMP) : PSTR(MSG_ERR_MAXTEMP_BED));
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD401             BMI.N    ??max_temp_error_1
   \       0x10   0x....             ADR.N    R2,?_36
   \       0x12   0xE000             B.N      ??max_temp_error_2
   \                     ??max_temp_error_1: (+1)
   \       0x14   0x....             ADR.N    R2,?_37
   \                     ??max_temp_error_2: (+1)
   \       0x16   0xBF00             Nop      
   \       0x18   0x....             ADR.N    R1,?_35
   \       0x1A   0x....             B.N      _ZN11Temperature11_temp_errorEiPKcS1_
    633          else
    634          {
    635          	_temp_error(HOTEND_INDEX, PSTR(MSG_T_MAXTEMP), PSTR(MSG_ERR_MAXTEMP));
   \                     ??max_temp_error_0: (+1)
   \       0x1C   0x.... 0x....      ADR.W    R2,?_36
   \       0x20   0x....             ADR.N    R1,?_35
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x....             B.N      _ZN11Temperature11_temp_errorEiPKcS1_
    636            #if HOTENDS == 1
    637          		UNUSED(e);
    638            #endif
    639          }
    640          /*--mks cfg end-- HAS_TEMP_BED */  
    641          }

   \                                 In section .text, align 4, keep-with-next
    642          void Temperature::min_temp_error(int8_t e) {
    643          	/*--mks cfg begin-- HAS_TEMP_BED */ 
    644          /*
    645            #if HAS_TEMP_BED
    646              _temp_error(e, PSTR(MSG_T_MINTEMP), e >= 0 ? PSTR(MSG_ERR_MINTEMP) : PSTR(MSG_ERR_MINTEMP_BED));
    647            #else
    648              _temp_error(HOTEND_INDEX, PSTR(MSG_T_MINTEMP), PSTR(MSG_ERR_MINTEMP));
    649              #if HOTENDS == 1
    650                UNUSED(e);
    651              #endif
    652            #endif
    653          */
    654          if(HAS_TEMP_BED)
   \                     _ZN11Temperature14min_temp_errorEa: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable59_2
   \        0x4   0xF891 0x1036      LDRB     R1,[R1, #+54]
   \        0x8   0x2900             CMP      R1,#+0
   \        0xA   0xD007             BEQ.N    ??min_temp_error_0
    655          		  _temp_error(e, PSTR(MSG_T_MINTEMP), e >= 0 ? PSTR(MSG_ERR_MINTEMP) : PSTR(MSG_ERR_MINTEMP_BED));
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD401             BMI.N    ??min_temp_error_1
   \       0x10   0x....             ADR.N    R2,?_33
   \       0x12   0xE000             B.N      ??min_temp_error_2
   \                     ??min_temp_error_1: (+1)
   \       0x14   0x....             ADR.N    R2,?_34
   \                     ??min_temp_error_2: (+1)
   \       0x16   0xBF00             Nop      
   \       0x18   0x....             ADR.N    R1,?_32
   \       0x1A   0x....             B.N      _ZN11Temperature11_temp_errorEiPKcS1_
    656          else
    657          {
    658          		  _temp_error(HOTEND_INDEX, PSTR(MSG_T_MINTEMP), PSTR(MSG_ERR_MINTEMP));
   \                     ??min_temp_error_0: (+1)
   \       0x1C   0x.... 0x....      ADR.W    R2,?_33
   \       0x20   0x....             ADR.N    R1,?_32
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x....             B.N      _ZN11Temperature11_temp_errorEiPKcS1_
    659            #if HOTENDS == 1
    660          			UNUSED(e);
    661            #endif
    662          }
    663            /*--mks cfg end-- HAS_TEMP_BED */  
    664          }
    665          

   \                                 In section .text, align 2, keep-with-next
    666          float Temperature::get_pid_output(int e) {
   \                     _ZN11Temperature14get_pid_outputEi: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
    667            #if HOTENDS == 1
    668              UNUSED(e);
    669              #define _HOTEND_TEST     true
    670            #else
    671              #define _HOTEND_TEST     e == active_extruder
    672            #endif
    673            float pid_output;
    674            //#if ENABLED(PIDTEMP)	/*--mks cfg--*/
    675            if(PIDTEMP) {
   \        0x4   0x....             LDR.N    R5,??DataTable48
   \        0x6   0x6AAC             LDR      R4,[R5, #+40]
   \        0x8   0x4620             MOV      R0,R4
   \        0xA   0x.... 0x....      BL       __aeabi_i2f
   \        0xE   0x4601             MOV      R1,R0
   \       0x10   0x69EE             LDR      R6,[R5, #+28]
   \       0x12   0x.... 0x....      LDR.W    R0,??DataTable59_2
   \       0x16   0xF890 0x0034      LDRB     R0,[R0, #+52]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xF000 0x8085      BEQ.W    ??get_pid_output_0
    676              #if DISABLED(PID_OPENLOOP)
    677                pid_error[HOTEND_INDEX] = target_temperature[HOTEND_INDEX] - current_temperature[HOTEND_INDEX];
   \       0x20   0x4608             MOV      R0,R1
   \       0x22   0x4631             MOV      R1,R6
   \       0x24   0x.... 0x....      BL       __aeabi_fsub
   \       0x28   0x4607             MOV      R7,R0
   \       0x2A   0x672F             STR      R7,[R5, #+112]
    678                dTerm[HOTEND_INDEX] = K2 * PID_PARAM(Kd, HOTEND_INDEX) * (current_temperature[HOTEND_INDEX] - temp_dState[HOTEND_INDEX]) + K1 * dTerm[HOTEND_INDEX];
   \       0x2C   0x6BE8             LDR      R0,[R5, #+60]
   \       0x2E   0x.... 0x....      BL       __aeabi_f2d
   \       0x32   0x.... 0x....      LDR.W    R2,??DataTable59_3  ;; 0x999999a0
   \       0x36   0x.... 0x....      LDR.W    R3,??DataTable59_4  ;; 0x3fa99999
   \       0x3A   0x.... 0x....      BL       __aeabi_dmul
   \       0x3E   0x4680             MOV      R8,R0
   \       0x40   0x4689             MOV      R9,R1
   \       0x42   0x4630             MOV      R0,R6
   \       0x44   0x6E29             LDR      R1,[R5, #+96]
   \       0x46   0x.... 0x....      BL       __aeabi_fsub
   \       0x4A   0x.... 0x....      BL       __aeabi_f2d
   \       0x4E   0x4642             MOV      R2,R8
   \       0x50   0x464B             MOV      R3,R9
   \       0x52   0x.... 0x....      BL       __aeabi_dmul
   \       0x56   0x4680             MOV      R8,R0
   \       0x58   0x4689             MOV      R9,R1
   \       0x5A   0x6EE8             LDR      R0,[R5, #+108]
   \       0x5C   0x.... 0x....      BL       __aeabi_f2d
   \       0x60   0xF04F 0x3266      MOV      R2,#+1717986918
   \       0x64   0x.... 0x....      LDR.W    R3,??DataTable59_5  ;; 0x3fee6666
   \       0x68   0x.... 0x....      BL       __aeabi_dmul
   \       0x6C   0x4642             MOV      R2,R8
   \       0x6E   0x464B             MOV      R3,R9
   \       0x70   0x.... 0x....      BL       __aeabi_dadd
   \       0x74   0x.... 0x....      BL       __aeabi_d2f
   \       0x78   0x4680             MOV      R8,R0
   \       0x7A   0xF8C5 0x806C      STR      R8,[R5, #+108]
    679                temp_dState[HOTEND_INDEX] = current_temperature[HOTEND_INDEX];
   \       0x7E   0x662E             STR      R6,[R5, #+96]
    680                if (pid_error[HOTEND_INDEX] > PID_FUNCTIONAL_RANGE) {
   \       0x80   0x4638             MOV      R0,R7
   \       0x82   0x.... 0x....      LDR.W    R1,??DataTable59_6  ;; 0x41200001
   \       0x86   0x.... 0x....      BL       __aeabi_cfrcmple
   \       0x8A   0xD804             BHI.N    ??get_pid_output_1
    681                  pid_output = BANG_MAX;
   \       0x8C   0x.... 0x....      LDR.W    R0,??DataTable59_7  ;; 0x437f0000
    682                  pid_reset[HOTEND_INDEX] = true;
   \       0x90   0x2101             MOVS     R1,#+1
   \       0x92   0x70A9             STRB     R1,[R5, #+2]
   \       0x94   0xE051             B.N      ??get_pid_output_2
    683                }
    684                else if (pid_error[HOTEND_INDEX] < -(PID_FUNCTIONAL_RANGE) || target_temperature[HOTEND_INDEX] == 0) {
   \                     ??get_pid_output_1: (+1)
   \       0x96   0x.... 0x....      LDR.W    R1,??DataTable59_8  ;; 0xc1200000
   \       0x9A   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x9E   0xD301             BCC.N    ??get_pid_output_3
   \       0xA0   0x2C00             CMP      R4,#+0
   \       0xA2   0xD103             BNE.N    ??get_pid_output_4
    685                  pid_output = 0;
   \                     ??get_pid_output_3: (+1)
   \       0xA4   0x2000             MOVS     R0,#+0
    686                  pid_reset[HOTEND_INDEX] = true;
   \       0xA6   0x2101             MOVS     R1,#+1
   \       0xA8   0x70A9             STRB     R1,[R5, #+2]
   \       0xAA   0xE046             B.N      ??get_pid_output_2
    687                }
    688                else {
    689                  if (pid_reset[HOTEND_INDEX]) {
   \                     ??get_pid_output_4: (+1)
   \       0xAC   0x78A8             LDRB     R0,[R5, #+2]
   \       0xAE   0x2800             CMP      R0,#+0
   \       0xB0   0xD002             BEQ.N    ??get_pid_output_5
    690                    temp_iState[HOTEND_INDEX] = 0.0;
   \       0xB2   0x2000             MOVS     R0,#+0
   \       0xB4   0x65E8             STR      R0,[R5, #+92]
    691                    pid_reset[HOTEND_INDEX] = false;
   \       0xB6   0x70A8             STRB     R0,[R5, #+2]
    692                  }
    693                  pTerm[HOTEND_INDEX] = PID_PARAM(Kp, HOTEND_INDEX) * pid_error[HOTEND_INDEX];
   \                     ??get_pid_output_5: (+1)
   \       0xB8   0x6B68             LDR      R0,[R5, #+52]
   \       0xBA   0x4639             MOV      R1,R7
   \       0xBC   0x.... 0x....      BL       __aeabi_fmul
   \       0xC0   0x4606             MOV      R6,R0
   \       0xC2   0x666E             STR      R6,[R5, #+100]
    694                  temp_iState[HOTEND_INDEX] += pid_error[HOTEND_INDEX];
   \       0xC4   0x6DE8             LDR      R0,[R5, #+92]
   \       0xC6   0x4639             MOV      R1,R7
   \       0xC8   0x.... 0x....      BL       __aeabi_fadd
   \       0xCC   0x4604             MOV      R4,R0
   \       0xCE   0x65EC             STR      R4,[R5, #+92]
    695                  iTerm[HOTEND_INDEX] = PID_PARAM(Ki, HOTEND_INDEX) * temp_iState[HOTEND_INDEX];
   \       0xD0   0x6BA8             LDR      R0,[R5, #+56]
   \       0xD2   0x4621             MOV      R1,R4
   \       0xD4   0x.... 0x....      BL       __aeabi_fmul
   \       0xD8   0x4601             MOV      R1,R0
   \       0xDA   0x66A9             STR      R1,[R5, #+104]
    696          
    697                  pid_output = pTerm[HOTEND_INDEX] + iTerm[HOTEND_INDEX] - dTerm[HOTEND_INDEX];
   \       0xDC   0x4630             MOV      R0,R6
   \       0xDE   0x.... 0x....      BL       __aeabi_fadd
   \       0xE2   0x4641             MOV      R1,R8
   \       0xE4   0x.... 0x....      BL       __aeabi_fsub
    698          
    699                  #if ENABLED(PID_EXTRUSION_SCALING)
    700                    cTerm[HOTEND_INDEX] = 0;
    701                    if (_HOTEND_TEST) {
    702                      long e_position = stepper.position(E_AXIS);
    703                      if (e_position > last_e_position) {
    704                        lpq[lpq_ptr] = e_position - last_e_position;
    705                        last_e_position = e_position;
    706                      }
    707                      else {
    708                        lpq[lpq_ptr] = 0;
    709                      }
    710                      if (++lpq_ptr >= lpq_len) lpq_ptr = 0;
    711                      cTerm[HOTEND_INDEX] = (lpq[lpq_ptr] * planner.steps_to_mm[E_AXIS]) * PID_PARAM(Kc, HOTEND_INDEX);
    712                      pid_output += cTerm[HOTEND_INDEX];
    713                    }
    714                  #endif // PID_EXTRUSION_SCALING
    715          
    716                  if (pid_output > PID_MAX) {
   \       0xE8   0x.... 0x....      LDR.W    R1,??DataTable59_9  ;; 0x437f0001
   \       0xEC   0x.... 0x....      BL       __aeabi_cfrcmple
   \       0xF0   0xD80C             BHI.N    ??get_pid_output_6
    717                    if (pid_error[HOTEND_INDEX] > 0) temp_iState[HOTEND_INDEX] -= pid_error[HOTEND_INDEX]; // conditional un-integration
   \       0xF2   0x4638             MOV      R0,R7
   \       0xF4   0x2100             MOVS     R1,#+0
   \       0xF6   0x.... 0x....      BL       __aeabi_cfrcmple
   \       0xFA   0xD204             BCS.N    ??get_pid_output_7
   \       0xFC   0x4620             MOV      R0,R4
   \       0xFE   0x4639             MOV      R1,R7
   \      0x100   0x.... 0x....      BL       __aeabi_fsub
   \      0x104   0x65E8             STR      R0,[R5, #+92]
    718                    pid_output = PID_MAX;
   \                     ??get_pid_output_7: (+1)
   \      0x106   0x.... 0x....      LDR.W    R0,??DataTable59_7  ;; 0x437f0000
   \      0x10A   0xE016             B.N      ??get_pid_output_2
    719                  }
    720                  else if (pid_output < 0) {
   \                     ??get_pid_output_6: (+1)
   \      0x10C   0x2100             MOVS     R1,#+0
   \      0x10E   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x112   0xD212             BCS.N    ??get_pid_output_2
    721                    if (pid_error[HOTEND_INDEX] < 0) temp_iState[HOTEND_INDEX] -= pid_error[HOTEND_INDEX]; // conditional un-integration
   \      0x114   0x4638             MOV      R0,R7
   \      0x116   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x11A   0xD204             BCS.N    ??get_pid_output_8
   \      0x11C   0x4620             MOV      R0,R4
   \      0x11E   0x4639             MOV      R1,R7
   \      0x120   0x.... 0x....      BL       __aeabi_fsub
   \      0x124   0x65E8             STR      R0,[R5, #+92]
    722                    pid_output = 0;
   \                     ??get_pid_output_8: (+1)
   \      0x126   0x2000             MOVS     R0,#+0
   \      0x128   0xE007             B.N      ??get_pid_output_2
    723                  }
    724                }
    725              #else
    726                pid_output = constrain(target_temperature[HOTEND_INDEX], 0, PID_MAX);
    727              #endif //PID_OPENLOOP
    728          
    729              #if ENABLED(PID_DEBUG)
    730                SERIAL_ECHO_START;
    731                SERIAL_ECHOPAIR(MSG_PID_DEBUG, HOTEND_INDEX);
    732                SERIAL_ECHOPAIR(MSG_PID_DEBUG_INPUT, current_temperature[HOTEND_INDEX]);
    733                SERIAL_ECHOPAIR(MSG_PID_DEBUG_OUTPUT, pid_output);
    734                SERIAL_ECHOPAIR(MSG_PID_DEBUG_PTERM, pTerm[HOTEND_INDEX]);
    735                SERIAL_ECHOPAIR(MSG_PID_DEBUG_ITERM, iTerm[HOTEND_INDEX]);
    736                SERIAL_ECHOPAIR(MSG_PID_DEBUG_DTERM, dTerm[HOTEND_INDEX]);
    737                #if ENABLED(PID_EXTRUSION_SCALING)
    738                  SERIAL_ECHOPAIR(MSG_PID_DEBUG_CTERM, cTerm[HOTEND_INDEX]);
    739                #endif
    740                SERIAL_EOL;
    741              #endif //PID_DEBUG
    742          
    743            }else{//#else /* PID off */
    744              pid_output = (current_temperature[HOTEND_INDEX] < target_temperature[HOTEND_INDEX]) ? PID_MAX : 0;
   \                     ??get_pid_output_0: (+1)
   \      0x12A   0x4630             MOV      R0,R6
   \      0x12C   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x130   0xD202             BCS.N    ??get_pid_output_9
   \      0x132   0x.... 0x....      LDR.W    R0,??DataTable59_7  ;; 0x437f0000
   \      0x136   0xE000             B.N      ??get_pid_output_2
   \                     ??get_pid_output_9: (+1)
   \      0x138   0x2000             MOVS     R0,#+0
    745            }//#endif
    746          
    747            return pid_output;
   \                     ??get_pid_output_2: (+1)
   \      0x13A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    748          }
    749          
    750          //#if ENABLED(PIDTEMPBED)	/*--mks cfg--*/
    751          #if 1

   \                                 In section .text, align 2, keep-with-next
    752            float Temperature::get_pid_output_bed() {
   \                     _ZN11Temperature18get_pid_output_bedEv: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
    753              float pid_output;
    754              #if DISABLED(PID_OPENLOOP)
    755                pid_error_bed = target_temperature_bed - current_temperature_bed;
   \        0x4   0x.... 0x....      LDR.W    R10,??DataTable48
   \        0x8   0xF8DA 0x8020      LDR      R8,[R10, #+32]
   \        0xC   0xF8DA 0x0030      LDR      R0,[R10, #+48]
   \       0x10   0x.... 0x....      BL       __aeabi_i2f
   \       0x14   0x4641             MOV      R1,R8
   \       0x16   0x.... 0x....      BL       __aeabi_fsub
   \       0x1A   0x4604             MOV      R4,R0
   \       0x1C   0x.... 0x....      LDR.W    R5,??DataTable59_10
   \       0x20   0x616C             STR      R4,[R5, #+20]
    756                pTerm_bed = bedKp * pid_error_bed;
   \       0x22   0xF8DA 0x0040      LDR      R0,[R10, #+64]
   \       0x26   0x4621             MOV      R1,R4
   \       0x28   0x.... 0x....      BL       __aeabi_fmul
   \       0x2C   0x4606             MOV      R6,R0
   \       0x2E   0x60AE             STR      R6,[R5, #+8]
    757                temp_iState_bed += pid_error_bed;
   \       0x30   0x6828             LDR      R0,[R5, #+0]
   \       0x32   0x4621             MOV      R1,R4
   \       0x34   0x.... 0x....      BL       __aeabi_fadd
   \       0x38   0x4607             MOV      R7,R0
   \       0x3A   0x602F             STR      R7,[R5, #+0]
    758                iTerm_bed = bedKi * temp_iState_bed;
   \       0x3C   0xF8DA 0x0044      LDR      R0,[R10, #+68]
   \       0x40   0x4639             MOV      R1,R7
   \       0x42   0x.... 0x....      BL       __aeabi_fmul
   \       0x46   0x4681             MOV      R9,R0
   \       0x48   0xF8C5 0x900C      STR      R9,[R5, #+12]
    759          
    760                dTerm_bed = K2 * bedKd * (current_temperature_bed - temp_dState_bed) + K1 * dTerm_bed;
   \       0x4C   0xF8DA 0x0048      LDR      R0,[R10, #+72]
   \       0x50   0x.... 0x....      BL       __aeabi_f2d
   \       0x54   0x.... 0x....      LDR.W    R2,??DataTable59_3  ;; 0x999999a0
   \       0x58   0x.... 0x....      LDR.W    R3,??DataTable59_4  ;; 0x3fa99999
   \       0x5C   0x.... 0x....      BL       __aeabi_dmul
   \       0x60   0x4682             MOV      R10,R0
   \       0x62   0x468B             MOV      R11,R1
   \       0x64   0x4640             MOV      R0,R8
   \       0x66   0x6869             LDR      R1,[R5, #+4]
   \       0x68   0x.... 0x....      BL       __aeabi_fsub
   \       0x6C   0x.... 0x....      BL       __aeabi_f2d
   \       0x70   0x4652             MOV      R2,R10
   \       0x72   0x465B             MOV      R3,R11
   \       0x74   0x.... 0x....      BL       __aeabi_dmul
   \       0x78   0x4682             MOV      R10,R0
   \       0x7A   0x468B             MOV      R11,R1
   \       0x7C   0x6928             LDR      R0,[R5, #+16]
   \       0x7E   0x.... 0x....      BL       __aeabi_f2d
   \       0x82   0xF04F 0x3266      MOV      R2,#+1717986918
   \       0x86   0x.... 0x....      LDR.W    R3,??DataTable59_5  ;; 0x3fee6666
   \       0x8A   0x.... 0x....      BL       __aeabi_dmul
   \       0x8E   0x4652             MOV      R2,R10
   \       0x90   0x465B             MOV      R3,R11
   \       0x92   0x.... 0x....      BL       __aeabi_dadd
   \       0x96   0x.... 0x....      BL       __aeabi_d2f
   \       0x9A   0x4682             MOV      R10,R0
   \       0x9C   0xF8C5 0xA010      STR      R10,[R5, #+16]
    761                temp_dState_bed = current_temperature_bed;
   \       0xA0   0xF8C5 0x8004      STR      R8,[R5, #+4]
    762          
    763                pid_output = pTerm_bed + iTerm_bed - dTerm_bed;
   \       0xA4   0x4630             MOV      R0,R6
   \       0xA6   0x4649             MOV      R1,R9
   \       0xA8   0x.... 0x....      BL       __aeabi_fadd
   \       0xAC   0x4651             MOV      R1,R10
   \       0xAE   0x.... 0x....      BL       __aeabi_fsub
    764                if (pid_output > MAX_BED_POWER) {
   \       0xB2   0x.... 0x....      LDR.W    R1,??DataTable59_9  ;; 0x437f0001
   \       0xB6   0x.... 0x....      BL       __aeabi_cfrcmple
   \       0xBA   0xD80C             BHI.N    ??get_pid_output_bed_0
    765                  if (pid_error_bed > 0) temp_iState_bed -= pid_error_bed; // conditional un-integration
   \       0xBC   0x4620             MOV      R0,R4
   \       0xBE   0x2100             MOVS     R1,#+0
   \       0xC0   0x.... 0x....      BL       __aeabi_cfrcmple
   \       0xC4   0xD204             BCS.N    ??get_pid_output_bed_1
   \       0xC6   0x4638             MOV      R0,R7
   \       0xC8   0x4621             MOV      R1,R4
   \       0xCA   0x.... 0x....      BL       __aeabi_fsub
   \       0xCE   0x6028             STR      R0,[R5, #+0]
    766                  pid_output = MAX_BED_POWER;
   \                     ??get_pid_output_bed_1: (+1)
   \       0xD0   0x.... 0x....      LDR.W    R0,??DataTable59_7  ;; 0x437f0000
   \       0xD4   0xE00D             B.N      ??get_pid_output_bed_2
    767                }
    768                else if (pid_output < 0) {
   \                     ??get_pid_output_bed_0: (+1)
   \       0xD6   0x2100             MOVS     R1,#+0
   \       0xD8   0x.... 0x....      BL       __aeabi_cfcmple
   \       0xDC   0xD209             BCS.N    ??get_pid_output_bed_2
    769                  if (pid_error_bed < 0) temp_iState_bed -= pid_error_bed; // conditional un-integration
   \       0xDE   0x4620             MOV      R0,R4
   \       0xE0   0x.... 0x....      BL       __aeabi_cfcmple
   \       0xE4   0xD204             BCS.N    ??get_pid_output_bed_3
   \       0xE6   0x4638             MOV      R0,R7
   \       0xE8   0x4621             MOV      R1,R4
   \       0xEA   0x.... 0x....      BL       __aeabi_fsub
   \       0xEE   0x6028             STR      R0,[R5, #+0]
    770                  pid_output = 0;
   \                     ??get_pid_output_bed_3: (+1)
   \       0xF0   0x2000             MOVS     R0,#+0
    771                }
    772              #else
    773                pid_output = constrain(target_temperature_bed, 0, MAX_BED_POWER);
    774              #endif // PID_OPENLOOP
    775          
    776              #if ENABLED(PID_BED_DEBUG)
    777                SERIAL_ECHO_START;
    778                SERIAL_ECHOPGM(" PID_BED_DEBUG ");
    779                SERIAL_ECHOPGM(": Input ");
    780                SERIAL_ECHO(current_temperature_bed);
    781                SERIAL_ECHOPGM(" Output ");
    782                SERIAL_ECHO(pid_output);
    783                SERIAL_ECHOPGM(" pTerm ");
    784                SERIAL_ECHO(pTerm_bed);
    785                SERIAL_ECHOPGM(" iTerm ");
    786                SERIAL_ECHO(iTerm_bed);
    787                SERIAL_ECHOPGM(" dTerm ");
    788                SERIAL_ECHOLN(dTerm_bed);
    789              #endif //PID_BED_DEBUG
    790          
    791              return pid_output;
   \                     ??get_pid_output_bed_2: (+1)
   \       0xF2   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    792            }
    793          #endif //PIDTEMPBED
    794          
    795          /**
    796           * Manage heating activities for extruder hot-ends and a heated bed
    797           *  - Acquire updated temperature readings
    798           *    - Also resets the watchdog timer
    799           *  - Invoke thermal runaway protection
    800           *  - Manage extruder auto-fan
    801           *  - Apply filament width to the extrusion rate (may move)
    802           *  - Update the heated bed PID output value
    803           */
    804          
    805          /**
    806           * The following line SOMETIMES results in the dreaded "unable to find a register to spill in class 'POINTER_REGS'"
    807           * compile error.
    808           *    thermal_runaway_protection(&thermal_runaway_state_machine[e], &thermal_runaway_timer[e], current_temperature[e], target_temperature[e], e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
    809           *
    810           * This is due to a bug in the C++ compiler used by the Arduino IDE from 1.6.10 to at least 1.8.1.
    811           *
    812           * The work around is to add the compiler flag "__attribute__((__optimize__("O2")))" to the declaration for manage_heater()
    813           */
    814          //void Temperature::manage_heater()  __attribute__((__optimize__("O2")));

   \                                 In section .text, align 2, keep-with-next
    815          void Temperature::manage_heater() {
   \                     _ZN11Temperature13manage_heaterEv: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
    816          
    817            if (!temp_meas_ready) return;
   \        0x4   0x.... 0x....      LDR.W    R5,??DataTable59
   \        0x8   0x7868             LDRB     R0,[R5, #+1]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xF000 0x80F2      BEQ.W    ??manage_heater_0
    818          
    819            updateTemperaturesFromRawValues(); // also resets the watchdog
   \       0x10   0x.... 0x....      BL       _ZN11Temperature31updateTemperaturesFromRawValuesEv
    820          
    821            #if ENABLED(HEATER_0_USES_MAX6675)
    822              if (current_temperature[0] > min(HEATER_0_MAXTEMP, MAX6675_TMAX - 1)) max_temp_error(0);
    823              if (current_temperature[0] < max(HEATER_0_MINTEMP, MAX6675_TMIN + 0.01)) min_temp_error(0);
    824            #endif
    825          
    826          #if 0 /*--mks cfg begin--*/
    827            #if WATCH_HOTENDS || WATCH_THE_BED || DISABLED(PIDTEMPBED) || HAS_AUTO_FAN
    828              millis_t ms = millis();
    829            #endif
    830          #endif
    831            millis_t ms = millis();
   \       0x14   0x.... 0x....      BL       HAL_GetTick
   \       0x18   0x4606             MOV      R6,R0
    832          	/*--mks cfg end--*/
    833            // Loop through all hotends
    834            HOTEND_LOOP() {
   \       0x1A   0xF04F 0x0800      MOV      R8,#+0
   \       0x1E   0x.... 0x....      LDR.W    R7,??DataTable59_2
   \       0x22   0xE027             B.N      ??manage_heater_1
    835          
    836              #if ENABLED(THERMAL_PROTECTION_HOTENDS)
    837                thermal_runaway_protection(&thermal_runaway_state_machine[e], &thermal_runaway_timer[e], current_temperature[e], target_temperature[e], e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);
    838              #endif
    839          
    840              float pid_output = get_pid_output(e);
    841          
    842              // Check if temperature is within the correct range
    843              soft_pwm[e] = (current_temperature[e] > minttemp[e] || is_preheating(e)) && current_temperature[e] < maxttemp[e] ? (int)pid_output >> 1 : 0;
    844          
    845              // Check if the temperature is failing to increase
    846              #if WATCH_HOTENDS
    847          
    848                // Is it time to check this extruder's heater?
    849                if (watch_heater_next_ms[e] && ELAPSED(ms, watch_heater_next_ms[e])) {
    850                  // Has it failed to increase enough?
    851                  if (degHotend(e) < watch_target_temp[e]) {
    852                    // Stop!
    853                    _temp_error(e, PSTR(MSG_T_HEATING_FAILED), PSTR(MSG_HEATING_FAILED_LCD));
    854                  }
    855                  else {
    856                    // Start again if the target is still far off
    857                    start_watching_heater(e);
    858                  }
    859                }
    860          
    861              #endif // THERMAL_PROTECTION_HOTENDS
    862          
    863              // Check if the temperature is failing to increase
    864              #if WATCH_THE_BED
    865          	if(HAS_TEMP_BED) {	/*--mks cfg-- HAS_TEMP_BED --*/
    866                // Is it time to check the bed?
    867                if (watch_bed_next_ms && ELAPSED(ms, watch_bed_next_ms)) {
    868                  // Has it failed to increase enough?
    869                  if (degBed() < watch_target_bed_temp) {
    870                    // Stop!
    871                    _temp_error(-1, PSTR(MSG_T_HEATING_FAILED), PSTR(MSG_HEATING_FAILED_LCD));
    872                  }
    873                  else {
    874                    // Start again if the target is still far off
    875                    start_watching_bed();
   \                     ??manage_heater_2: (+1)
   \       0x24   0x.... 0x....      BL       _ZN11Temperature18start_watching_bedEv
   \       0x28   0xE020             B.N      ??manage_heater_3
    876                  }
   \                     ??manage_heater_4: (+1)
   \       0x2A   0x4640             MOV      R0,R8
   \       0x2C   0xB2C0             UXTB     R0,R0
   \       0x2E   0x.... 0x....      BL       _ZN11Temperature21start_watching_heaterEh
   \                     ??manage_heater_5: (+1)
   \       0x32   0xF107 0x0032      ADD      R0,R7,#+50
   \       0x36   0x7900             LDRB     R0,[R0, #+4]
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD017             BEQ.N    ??manage_heater_3
   \       0x3C   0x6DA8             LDR      R0,[R5, #+88]
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD014             BEQ.N    ??manage_heater_3
   \       0x42   0x1A30             SUBS     R0,R6,R0
   \       0x44   0xD412             BMI.N    ??manage_heater_3
   \       0x46   0x6D68             LDR      R0,[R5, #+84]
   \       0x48   0x.... 0x....      BL       __aeabi_i2f
   \       0x4C   0x4601             MOV      R1,R0
   \       0x4E   0x460C             MOV      R4,R1
   \       0x50   0x.... 0x....      BL       _ZN11Temperature6degBedEv
   \       0x54   0x4621             MOV      R1,R4
   \       0x56   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x5A   0xD2E3             BCS.N    ??manage_heater_2
   \       0x5C   0x.... 0x....      LDR.W    R2,??DataTable59_11
   \       0x60   0x.... 0x....      ADR.W    R1,?_2
   \       0x64   0xF04F 0x30FF      MOV      R0,#-1
   \       0x68   0x.... 0x....      BL       _ZN11Temperature11_temp_errorEiPKcS1_
   \                     ??manage_heater_3: (+1)
   \       0x6C   0xF108 0x0801      ADD      R8,R8,#+1
   \       0x70   0xFA4F 0xF888      SXTB     R8,R8
   \                     ??manage_heater_1: (+1)
   \       0x74   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x78   0xF300 0x80BE      BGT.W    ??manage_heater_6
   \       0x7C   0xEB05 0x0488      ADD      R4,R5,R8, LSL #+2
   \       0x80   0xF107 0x00E0      ADD      R0,R7,#+224
   \       0x84   0x7881             LDRB     R1,[R0, #+2]
   \       0x86   0x9102             STR      R1,[SP, #+8]
   \       0x88   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \       0x8C   0x9001             STR      R0,[SP, #+4]
   \       0x8E   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x92   0x6AA0             LDR      R0,[R4, #+40]
   \       0x94   0x.... 0x....      BL       __aeabi_i2f
   \       0x98   0x4603             MOV      R3,R0
   \       0x9A   0x69E2             LDR      R2,[R4, #+28]
   \       0x9C   0xF104 0x017C      ADD      R1,R4,#+124
   \       0xA0   0xEB05 0x0008      ADD      R0,R5,R8
   \       0xA4   0x3078             ADDS     R0,R0,#+120
   \       0xA6   0x.... 0x....      BL       _ZN11Temperature26thermal_runaway_protectionEPNS_7TRStateEPmffiii
   \       0xAA   0x4640             MOV      R0,R8
   \       0xAC   0x.... 0x....      BL       _ZN11Temperature14get_pid_outputEi
   \       0xB0   0x4681             MOV      R9,R0
   \       0xB2   0xF8D4 0xA01C      LDR      R10,[R4, #+28]
   \       0xB6   0xEB05 0x0B48      ADD      R11,R5,R8, LSL #+1
   \       0xBA   0xF9BB 0x0014      LDRSH    R0,[R11, #+20]
   \       0xBE   0x.... 0x....      BL       __aeabi_i2f
   \       0xC2   0x4651             MOV      R1,R10
   \       0xC4   0x.... 0x....      BL       __aeabi_cfcmple
   \       0xC8   0xD20D             BCS.N    ??manage_heater_7
   \       0xCA   0xF9BB 0x0016      LDRSH    R0,[R11, #+22]
   \       0xCE   0x.... 0x....      BL       __aeabi_i2f
   \       0xD2   0x4601             MOV      R1,R0
   \       0xD4   0x4650             MOV      R0,R10
   \       0xD6   0x.... 0x....      BL       __aeabi_cfcmple
   \       0xDA   0xD204             BCS.N    ??manage_heater_7
   \       0xDC   0x4648             MOV      R0,R9
   \       0xDE   0x.... 0x....      BL       __aeabi_f2iz
   \       0xE2   0x1040             ASRS     R0,R0,#+1
   \       0xE4   0xE000             B.N      ??manage_heater_8
   \                     ??manage_heater_7: (+1)
   \       0xE6   0x2000             MOVS     R0,#+0
   \                     ??manage_heater_8: (+1)
   \       0xE8   0xEB05 0x0108      ADD      R1,R5,R8
   \       0xEC   0x70C8             STRB     R0,[R1, #+3]
   \       0xEE   0x6D20             LDR      R0,[R4, #+80]
   \       0xF0   0x2800             CMP      R0,#+0
   \       0xF2   0xD09E             BEQ.N    ??manage_heater_5
   \       0xF4   0x1A30             SUBS     R0,R6,R0
   \       0xF6   0xD49C             BMI.N    ??manage_heater_5
   \       0xF8   0x6CE0             LDR      R0,[R4, #+76]
   \       0xFA   0x.... 0x....      BL       __aeabi_i2f
   \       0xFE   0x4601             MOV      R1,R0
   \      0x100   0x460C             MOV      R4,R1
   \      0x102   0x4640             MOV      R0,R8
   \      0x104   0xB2C0             UXTB     R0,R0
   \      0x106   0x.... 0x....      BL       _ZN11Temperature9degHotendEh
   \      0x10A   0x4621             MOV      R1,R4
   \      0x10C   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x110   0xD28B             BCS.N    ??manage_heater_4
   \      0x112   0x.... 0x....      LDR.W    R2,??DataTable59_11
   \      0x116   0x.... 0x....      ADR.W    R1,?_2
   \      0x11A   0x4640             MOV      R0,R8
   \      0x11C   0x.... 0x....      BL       _ZN11Temperature11_temp_errorEiPKcS1_
   \      0x120   0xE787             B.N      ??manage_heater_5
    877                }
    878          		}
    879              #endif // THERMAL_PROTECTION_HOTENDS
    880          
    881              #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
    882                if (fabs(current_temperature[0] - redundant_temperature) > MAX_REDUNDANT_TEMP_SENSOR_DIFF) {
    883                  _temp_error(0, PSTR(MSG_REDUNDANCY), PSTR(MSG_ERR_REDUNDANT_TEMP));
    884                }
    885              #endif
    886          
    887            } // HOTEND_LOOP
    888          
    889            #if HAS_AUTO_FAN
    890              if (ELAPSED(ms, next_auto_fan_check_ms)) { // only need to check fan state very infrequently
    891                checkExtruderAutoFans();
    892                next_auto_fan_check_ms = ms + 2500UL;
    893              }
    894            #endif
    895          
    896            // Control the extruder rate based on the width sensor
    897            #if ENABLED(FILAMENT_WIDTH_SENSOR)
    898              if (filament_sensor) {
    899                meas_shift_index = filwidth_delay_index[0] - meas_delay_cm;
    900                if (meas_shift_index < 0) meas_shift_index += MAX_MEASUREMENT_DELAY + 1;  //loop around buffer if needed
    901                meas_shift_index = constrain(meas_shift_index, 0, MAX_MEASUREMENT_DELAY);
    902          
    903                // Get the delayed info and add 100 to reconstitute to a percent of
    904                // the nominal filament diameter then square it to get an area
    905                const float vmroot = measurement_delay[meas_shift_index] * 0.01 + 1.0;
    906                volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM] = vmroot <= 0.1 ? 0.01 : sq(vmroot);
    907              }
    908            #endif // FILAMENT_WIDTH_SENSOR
    909          
    910            //#if DISABLED(PIDTEMPBED)	/*--mks cfg--*/
    911            if(PIDTEMPBED == 0) {
    912              if (PENDING(ms, next_bed_check_ms)) return;
    913              next_bed_check_ms = ms + BED_CHECK_INTERVAL;
   \                     ??manage_heater_9: (+1)
   \      0x122   0xF506 0x5698      ADD      R6,R6,#+4864
   \      0x126   0x3688             ADDS     R6,R6,#+136
   \      0x128   0x676E             STR      R6,[R5, #+116]
    914            }//#endif
    915          
    916            #if TEMP_SENSOR_BED != 0
    917          
    918              #if HAS_THERMALLY_PROTECTED_BED
    919          	if(HAS_TEMP_BED) /*--mks cfg-- HAS_TEMP_BED --*/
   \                     ??manage_heater_10: (+1)
   \      0x12A   0x7920             LDRB     R0,[R4, #+4]
   \      0x12C   0x2800             CMP      R0,#+0
   \      0x12E   0xD014             BEQ.N    ??manage_heater_11
    920                thermal_runaway_protection(&thermal_runaway_bed_state_machine, &thermal_runaway_bed_timer, current_temperature_bed, target_temperature_bed, -1, THERMAL_PROTECTION_BED_PERIOD, THERMAL_PROTECTION_BED_HYSTERESIS);
   \      0x130   0xF107 0x00E0      ADD      R0,R7,#+224
   \      0x134   0x7A81             LDRB     R1,[R0, #+10]
   \      0x136   0x9102             STR      R1,[SP, #+8]
   \      0x138   0xF9B0 0x0008      LDRSH    R0,[R0, #+8]
   \      0x13C   0x9001             STR      R0,[SP, #+4]
   \      0x13E   0xF04F 0x30FF      MOV      R0,#-1
   \      0x142   0x9000             STR      R0,[SP, #+0]
   \      0x144   0x6B28             LDR      R0,[R5, #+48]
   \      0x146   0x.... 0x....      BL       __aeabi_i2f
   \      0x14A   0x4603             MOV      R3,R0
   \      0x14C   0x6A2A             LDR      R2,[R5, #+32]
   \      0x14E   0xF105 0x0180      ADD      R1,R5,#+128
   \      0x152   0xF105 0x0079      ADD      R0,R5,#+121
   \      0x156   0x.... 0x....      BL       _ZN11Temperature26thermal_runaway_protectionEPNS_7TRStateEPmffiii
    921              #endif
    922          	
    923          #if 0 /*--mks cfg begin--*/
    924              #if ENABLED(PIDTEMPBED)
    925                float pid_output = get_pid_output_bed();
    926          
    927                soft_pwm_bed = WITHIN(current_temperature_bed, BED_MINTEMP, BED_MAXTEMP) ? (int)pid_output >> 1 : 0;
    928          
    929              #elif ENABLED(BED_LIMIT_SWITCHING)
    930                // Check if temperature is within the correct band
    931                if (WITHIN(current_temperature_bed, BED_MINTEMP, BED_MAXTEMP)) {
    932                  if (current_temperature_bed >= target_temperature_bed + BED_HYSTERESIS)
    933                    soft_pwm_bed = 0;
    934                  else if (current_temperature_bed <= target_temperature_bed - (BED_HYSTERESIS))
    935                    soft_pwm_bed = MAX_BED_POWER >> 1;
    936                }
    937                else {
    938                  soft_pwm_bed = 0;
    939                  WRITE_HEATER_BED(LOW);
    940                }
    941              #else // !PIDTEMPBED && !BED_LIMIT_SWITCHING
    942                // Check if temperature is within the correct range
    943                if (WITHIN(current_temperature_bed, BED_MINTEMP, BED_MAXTEMP)) {
    944                  soft_pwm_bed = current_temperature_bed < target_temperature_bed ? MAX_BED_POWER >> 1 : 0;
    945                }
    946                else {
    947                  soft_pwm_bed = 0;
    948                  WRITE_HEATER_BED(LOW);
    949                }
    950              #endif
    951          #endif 	
    952          	if(PIDTEMPBED)
   \                     ??manage_heater_11: (+1)
   \      0x15A   0x6A2E             LDR      R6,[R5, #+32]
   \      0x15C   0x.... 0x....      LDR.W    R7,??DataTable59_12  ;; 0xc0a00000
   \      0x160   0x78E0             LDRB     R0,[R4, #+3]
   \      0x162   0x2800             CMP      R0,#+0
   \      0x164   0xD018             BEQ.N    ??manage_heater_12
    953          		{
    954          		float pid_output = get_pid_output_bed();
   \      0x166   0x.... 0x....      BL       _ZN11Temperature18get_pid_output_bedEv
   \      0x16A   0x4680             MOV      R8,R0
    955          		soft_pwm_bed = WITHIN(current_temperature_bed, BED_MINTEMP, BED_MAXTEMP) ? (int)pid_output >> 1 : 0;
   \      0x16C   0x4630             MOV      R0,R6
   \      0x16E   0x4639             MOV      R1,R7
   \      0x170   0x.... 0x....      BL       __aeabi_cfrcmple
   \      0x174   0xD80D             BHI.N    ??manage_heater_13
   \      0x176   0xF9B4 0x0000      LDRSH    R0,[R4, #+0]
   \      0x17A   0x.... 0x....      BL       __aeabi_i2f
   \      0x17E   0x4631             MOV      R1,R6
   \      0x180   0x.... 0x....      BL       __aeabi_cfrcmple
   \      0x184   0xD805             BHI.N    ??manage_heater_13
   \      0x186   0x4640             MOV      R0,R8
   \      0x188   0x.... 0x....      BL       __aeabi_f2iz
   \      0x18C   0x1040             ASRS     R0,R0,#+1
   \      0x18E   0x7028             STRB     R0,[R5, #+0]
   \      0x190   0xE030             B.N      ??manage_heater_0
   \                     ??manage_heater_13: (+1)
   \      0x192   0x2000             MOVS     R0,#+0
   \      0x194   0x7028             STRB     R0,[R5, #+0]
   \      0x196   0xE02D             B.N      ??manage_heater_0
    956          		}
    957          	else
    958          		{
    959          		// Check if temperature is within the correct range
    960          		if (WITHIN(current_temperature_bed, BED_MINTEMP, BED_MAXTEMP)) {
   \                     ??manage_heater_12: (+1)
   \      0x198   0x4630             MOV      R0,R6
   \      0x19A   0x4639             MOV      R1,R7
   \      0x19C   0x.... 0x....      BL       __aeabi_cfrcmple
   \      0x1A0   0xD815             BHI.N    ??manage_heater_14
   \      0x1A2   0xF9B4 0x0000      LDRSH    R0,[R4, #+0]
   \      0x1A6   0x.... 0x....      BL       __aeabi_i2f
   \      0x1AA   0x4631             MOV      R1,R6
   \      0x1AC   0x.... 0x....      BL       __aeabi_cfrcmple
   \      0x1B0   0xD80D             BHI.N    ??manage_heater_14
    961          		  soft_pwm_bed = current_temperature_bed < target_temperature_bed ? MAX_BED_POWER >> 1 : 0;
   \      0x1B2   0x6B28             LDR      R0,[R5, #+48]
   \      0x1B4   0x.... 0x....      BL       __aeabi_i2f
   \      0x1B8   0x4601             MOV      R1,R0
   \      0x1BA   0x4630             MOV      R0,R6
   \      0x1BC   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x1C0   0xD202             BCS.N    ??manage_heater_15
   \      0x1C2   0x207F             MOVS     R0,#+127
   \      0x1C4   0x7028             STRB     R0,[R5, #+0]
   \      0x1C6   0xE015             B.N      ??manage_heater_0
   \                     ??manage_heater_15: (+1)
   \      0x1C8   0x2000             MOVS     R0,#+0
   \      0x1CA   0x7028             STRB     R0,[R5, #+0]
   \      0x1CC   0xE012             B.N      ??manage_heater_0
    962          		}
    963          		else {
    964          		  soft_pwm_bed = 0;
   \                     ??manage_heater_14: (+1)
   \      0x1CE   0x2000             MOVS     R0,#+0
   \      0x1D0   0x7028             STRB     R0,[R5, #+0]
    965          		  WRITE_HEATER_BED(LOW);
   \      0x1D2   0x.... 0x....      LDR.W    R0,??DataTable59_13
   \      0x1D6   0x7CC0             LDRB     R0,[R0, #+19]
   \      0x1D8   0x2800             CMP      R0,#+0
   \      0x1DA   0xD10B             BNE.N    ??manage_heater_0
   \      0x1DC   0x2200             MOVS     R2,#+0
   \      0x1DE   0x.... 0x....      LDR.W    R0,??DataTable59_14
   \      0x1E2   0x8BC1             LDRH     R1,[R0, #+30]
   \      0x1E4   0x.... 0x....      LDR.W    R0,??DataTable59_15
   \      0x1E8   0x6BC0             LDR      R0,[R0, #+60]
   \      0x1EA   0xB003             ADD      SP,SP,#+12
   \      0x1EC   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \      0x1F0   0x.... 0x....      B.W      HAL_GPIO_WritePin
    966          		}
    967          		}
    968          	/*--mks cfg end--*/
    969            #endif //TEMP_SENSOR_BED != 0
    970           
    971          }
   \                     ??manage_heater_0: (+1)
   \      0x1F4   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
   \                     ??manage_heater_6: (+1)
   \      0x1F8   0xF107 0x0432      ADD      R4,R7,#+50
   \      0x1FC   0x78E0             LDRB     R0,[R4, #+3]
   \      0x1FE   0x2800             CMP      R0,#+0
   \      0x200   0xD193             BNE.N    ??manage_heater_10
   \      0x202   0x6F68             LDR      R0,[R5, #+116]
   \      0x204   0x1A30             SUBS     R0,R6,R0
   \      0x206   0xD58C             BPL.N    ??manage_heater_9
   \      0x208   0xE7F4             B.N      ??manage_heater_0
    972          
    973          /*--mks--*/
    974          //#define PGM_RD_W(x)   (short)pgm_read_word(&x)
    975          #define PGM_RD_W(x)   (short)(x)
    976          
    977          // Derived from RepRap FiveD extruder::getTemperature()
    978          // For hot end temperature measurement.

   \                                 In section .text, align 2, keep-with-next
    979          float Temperature::analog2temp(int raw, uint8_t e) {
   \                     _ZN11Temperature11analog2tempEih: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x000C             MOVS     R4,R1
    980            #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
    981              if (e > HOTENDS)
    982            #else
    983              if (e >= HOTENDS)
   \        0x6   0xD01F             BEQ.N    ??analog2temp_0
    984            #endif
    985              {
    986                SERIAL_ERROR_START;
   \        0x8   0x.... 0x....      LDR.W    R0,??DataTable58_1
   \        0xC   0x.... 0x....      BL       _Z14serialprintPGMPKc
    987                SERIAL_ERROR((int)e);
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable59_16
   \       0x14   0x7800             LDRB     R0,[R0, #+0]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD106             BNE.N    ??analog2temp_1
   \       0x1A   0x220A             MOVS     R2,#+10
   \       0x1C   0x4621             MOV      R1,R4
   \       0x1E   0x.... 0x....      LDR.W    R0,??DataTable59_17
   \       0x22   0x.... 0x....      BL       _ZN12MarlinSerial5printEii
   \       0x26   0xE005             B.N      ??analog2temp_2
   \                     ??analog2temp_1: (+1)
   \       0x28   0x220A             MOVS     R2,#+10
   \       0x2A   0x4621             MOV      R1,R4
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable59_18
   \       0x30   0x.... 0x....      BL       _ZN12MarlinSerial5printEii
    988                SERIAL_ERRORLNPGM(MSG_INVALID_EXTRUDER_NUM);
   \                     ??analog2temp_2: (+1)
   \       0x34   0x.... 0x....      ADR.W    R0,?_0
   \       0x38   0x.... 0x....      BL       _Z14serialprintPGMPKc
    989                kill(PSTR(MSG_KILLED));
   \       0x3C   0x.... 0x....      ADR.W    R0,?_1
   \       0x40   0x.... 0x....      BL       _Z4killPKc
    990                return 0.0;
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0xE052             B.N      ??analog2temp_3
    991              }
    992          
    993            #if ENABLED(HEATER_0_USES_MAX6675)
    994              if (e == 0) return 0.25 * raw;
    995            #endif
    996          
    997            if (heater_ttbl_map[e] != NULL) {
   \                     ??analog2temp_0: (+1)
   \       0x48   0x.... 0x....      LDR.W    R2,??DataTable59_19
   \       0x4C   0x6854             LDR      R4,[R2, #+4]
   \       0x4E   0x2C00             CMP      R4,#+0
   \       0x50   0xD042             BEQ.N    ??analog2temp_4
    998              float celsius = 0;
   \       0x52   0x2100             MOVS     R1,#+0
    999              uint8_t i;
   1000              short(*tt)[][2] = (short(*)[][2])(heater_ttbl_map[e]);
   1001          
   1002              for (i = 1; i < heater_ttbllen_map[e]; i++) {
   \       0x54   0x2501             MOVS     R5,#+1
   \       0x56   0x4606             MOV      R6,R0
   \       0x58   0x7817             LDRB     R7,[R2, #+0]
   \       0x5A   0xE001             B.N      ??analog2temp_5
   \                     ??analog2temp_6: (+1)
   \       0x5C   0x1C6D             ADDS     R5,R5,#+1
   \       0x5E   0xB2ED             UXTB     R5,R5
   \                     ??analog2temp_5: (+1)
   \       0x60   0x42BD             CMP      R5,R7
   \       0x62   0xDA2D             BGE.N    ??analog2temp_7
   1003                if (PGM_RD_W((*tt)[i][0]) > raw) {
   \       0x64   0xF934 0x8025      LDRSH    R8,[R4, R5, LSL #+2]
   \       0x68   0x4546             CMP      R6,R8
   \       0x6A   0xDAF7             BGE.N    ??analog2temp_6
   1004                  celsius = PGM_RD_W((*tt)[i - 1][1]) +
   1005                            (raw - PGM_RD_W((*tt)[i - 1][0])) *
   1006                            (float)(PGM_RD_W((*tt)[i][1]) - PGM_RD_W((*tt)[i - 1][1])) /
   1007                            (float)(PGM_RD_W((*tt)[i][0]) - PGM_RD_W((*tt)[i - 1][0]));
   \       0x6C   0xEB04 0x0B85      ADD      R11,R4,R5, LSL #+2
   \       0x70   0xF1AB 0x0004      SUB      R0,R11,#+4
   \       0x74   0xF9B0 0xA000      LDRSH    R10,[R0, #+0]
   \       0x78   0xF9B0 0x9002      LDRSH    R9,[R0, #+2]
   \       0x7C   0x4648             MOV      R0,R9
   \       0x7E   0x.... 0x....      BL       __aeabi_i2f
   \       0x82   0x9000             STR      R0,[SP, #+0]
   \       0x84   0xEBA6 0x060A      SUB      R6,R6,R10
   \       0x88   0x4630             MOV      R0,R6
   \       0x8A   0x.... 0x....      BL       __aeabi_i2f
   \       0x8E   0x4606             MOV      R6,R0
   \       0x90   0xF9BB 0x0002      LDRSH    R0,[R11, #+2]
   \       0x94   0xEBA0 0x0909      SUB      R9,R0,R9
   \       0x98   0x4648             MOV      R0,R9
   \       0x9A   0x.... 0x....      BL       __aeabi_i2f
   \       0x9E   0x4631             MOV      R1,R6
   \       0xA0   0x.... 0x....      BL       __aeabi_fmul
   \       0xA4   0x4606             MOV      R6,R0
   \       0xA6   0xEBA8 0x080A      SUB      R8,R8,R10
   \       0xAA   0x4640             MOV      R0,R8
   \       0xAC   0x.... 0x....      BL       __aeabi_i2f
   \       0xB0   0x4601             MOV      R1,R0
   \       0xB2   0x4630             MOV      R0,R6
   \       0xB4   0x.... 0x....      BL       __aeabi_fdiv
   \       0xB8   0x9900             LDR      R1,[SP, #+0]
   \       0xBA   0x.... 0x....      BL       __aeabi_fadd
   \       0xBE   0x4601             MOV      R1,R0
   1008                  break;
   1009                }
   1010              }
   1011          
   1012              // Overflow: Set to last value in the table
   1013              if (i == heater_ttbllen_map[e]) celsius = PGM_RD_W((*tt)[i - 1][1]);
   \                     ??analog2temp_7: (+1)
   \       0xC0   0x42BD             CMP      R5,R7
   \       0xC2   0xD107             BNE.N    ??analog2temp_8
   \       0xC4   0xEB04 0x0085      ADD      R0,R4,R5, LSL #+2
   \       0xC8   0x1F00             SUBS     R0,R0,#+4
   \       0xCA   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
   \       0xCE   0x.... 0x....      BL       __aeabi_i2f
   \       0xD2   0x4601             MOV      R1,R0
   1014          
   1015              return celsius;
   \                     ??analog2temp_8: (+1)
   \       0xD4   0x4608             MOV      R0,R1
   \       0xD6   0xE00A             B.N      ??analog2temp_3
   1016            }
   1017            return ((raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN)) + TEMP_SENSOR_AD595_OFFSET;
   \                     ??analog2temp_4: (+1)
   \       0xD8   0x.... 0x....      BL       __aeabi_i2d
   \       0xDC   0x2200             MOVS     R2,#+0
   \       0xDE   0x.... 0x....      LDR.W    R3,??DataTable59_20  ;; 0x3f9f4000
   \       0xE2   0x.... 0x....      BL       __aeabi_dmul
   \       0xE6   0xE8BD 0x4FF4      POP      {R2,R4-R11,LR}
   \       0xEA   0x.... 0x....      B.W      __aeabi_d2f
   \                     ??analog2temp_3: (+1)
   \       0xEE   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1018          }
   1019          
   1020          // Derived from RepRap FiveD extruder::getTemperature()
   1021          // For bed temperature measurement.

   \                                 In section .text, align 2, keep-with-next
   1022          float Temperature::analog2tempBed(int raw) {
   \                     _ZN11Temperature14analog2tempBedEi: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4607             MOV      R7,R0
   1023            #if ENABLED(BED_USES_THERMISTOR)
   1024              float celsius = 0;
   \        0x6   0x2000             MOVS     R0,#+0
   1025              byte i;
   1026          
   1027              for (i = 1; i < BEDTEMPTABLE_LEN; i++) {
   \        0x8   0x2401             MOVS     R4,#+1
   \        0xA   0x.... 0x....      ADR.W    R5,temptable_1
   \        0xE   0xE001             B.N      ??analog2tempBed_0
   \                     ??analog2tempBed_1: (+1)
   \       0x10   0x1C64             ADDS     R4,R4,#+1
   \       0x12   0xB2E4             UXTB     R4,R4
   \                     ??analog2tempBed_0: (+1)
   \       0x14   0x2C40             CMP      R4,#+64
   \       0x16   0xD22C             BCS.N    ??analog2tempBed_2
   1028                if (PGM_RD_W(BEDTEMPTABLE[i][0]) > raw) {
   \       0x18   0xF935 0x1024      LDRSH    R1,[R5, R4, LSL #+2]
   \       0x1C   0x428F             CMP      R7,R1
   \       0x1E   0xDAF7             BGE.N    ??analog2tempBed_1
   1029                  celsius  = PGM_RD_W(BEDTEMPTABLE[i - 1][1]) +
   1030                             (raw - PGM_RD_W(BEDTEMPTABLE[i - 1][0])) *
   1031                             (float)(PGM_RD_W(BEDTEMPTABLE[i][1]) - PGM_RD_W(BEDTEMPTABLE[i - 1][1])) /
   1032                             (float)(PGM_RD_W(BEDTEMPTABLE[i][0]) - PGM_RD_W(BEDTEMPTABLE[i - 1][0]));
   \       0x20   0xEB05 0x0984      ADD      R9,R5,R4, LSL #+2
   \       0x24   0xF1A9 0x0804      SUB      R8,R9,#+4
   \       0x28   0xF9B8 0x0002      LDRSH    R0,[R8, #+2]
   \       0x2C   0x.... 0x....      BL       __aeabi_i2f
   \       0x30   0x4606             MOV      R6,R0
   \       0x32   0xF9B8 0x0000      LDRSH    R0,[R8, #+0]
   \       0x36   0x1A3F             SUBS     R7,R7,R0
   \       0x38   0x4638             MOV      R0,R7
   \       0x3A   0x.... 0x....      BL       __aeabi_i2f
   \       0x3E   0x4607             MOV      R7,R0
   \       0x40   0xF9B9 0x0002      LDRSH    R0,[R9, #+2]
   \       0x44   0xF9B8 0x1002      LDRSH    R1,[R8, #+2]
   \       0x48   0x1A40             SUBS     R0,R0,R1
   \       0x4A   0x.... 0x....      BL       __aeabi_i2f
   \       0x4E   0x4639             MOV      R1,R7
   \       0x50   0x.... 0x....      BL       __aeabi_fmul
   \       0x54   0x4607             MOV      R7,R0
   \       0x56   0xF935 0x0024      LDRSH    R0,[R5, R4, LSL #+2]
   \       0x5A   0xF9B8 0x1000      LDRSH    R1,[R8, #+0]
   \       0x5E   0x1A40             SUBS     R0,R0,R1
   \       0x60   0x.... 0x....      BL       __aeabi_i2f
   \       0x64   0x4601             MOV      R1,R0
   \       0x66   0x4638             MOV      R0,R7
   \       0x68   0x.... 0x....      BL       __aeabi_fdiv
   \       0x6C   0x4631             MOV      R1,R6
   \       0x6E   0x.... 0x....      BL       __aeabi_fadd
   1033                  break;
   1034                }
   1035              }
   1036          
   1037              // Overflow: Set to last value in the table
   1038              if (i == BEDTEMPTABLE_LEN) celsius = PGM_RD_W(BEDTEMPTABLE[i - 1][1]);
   \                     ??analog2tempBed_2: (+1)
   \       0x72   0x2C40             CMP      R4,#+64
   \       0x74   0xD101             BNE.N    ??analog2tempBed_3
   \       0x76   0x.... 0x....      LDR.W    R0,??DataTable59_21  ;; 0xc1c80000
   1039          
   1040              return celsius;
   \                     ??analog2tempBed_3: (+1)
   \       0x7A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1041          
   1042            #elif defined(BED_USES_AD595)
   1043          
   1044              return ((raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN)) + TEMP_SENSOR_AD595_OFFSET;
   1045          
   1046            #else
   1047          
   1048              UNUSED(raw);
   1049              return 0;
   1050          
   1051            #endif
   1052          }
   1053          
   1054          /**
   1055           * Get the raw values into the actual temperatures.
   1056           * The raw values are created in interrupt context,
   1057           * and this function is called from normal context
   1058           * as it would block the stepper routine.
   1059           */

   \                                 In section .text, align 4, keep-with-next
   1060          void Temperature::updateTemperaturesFromRawValues() {
   \                     _ZN11Temperature31updateTemperaturesFromRawValuesEv: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   1061            #if ENABLED(HEATER_0_USES_MAX6675)
   1062              current_temperature_raw[0] = read_max6675();
   1063            #endif
   1064            HOTEND_LOOP()
   \        0x2   0x2400             MOVS     R4,#+0
   \        0x4   0xE00A             B.N      ??updateTemperaturesFromRawValues_0
   1065              current_temperature[e] = Temperature::analog2temp(current_temperature_raw[e], e);
   \                     ??updateTemperaturesFromRawValues_1: (+1)
   \        0x6   0xEB05 0x0584      ADD      R5,R5,R4, LSL #+2
   \        0xA   0x4620             MOV      R0,R4
   \        0xC   0x4601             MOV      R1,R0
   \        0xE   0xB2C9             UXTB     R1,R1
   \       0x10   0x6A68             LDR      R0,[R5, #+36]
   \       0x12   0x.... 0x....      BL       _ZN11Temperature11analog2tempEih
   \       0x16   0x61E8             STR      R0,[R5, #+28]
   \       0x18   0x1C64             ADDS     R4,R4,#+1
   \       0x1A   0xB264             SXTB     R4,R4
   \                     ??updateTemperaturesFromRawValues_0: (+1)
   \       0x1C   0x.... 0x....      LDR.W    R5,??DataTable59
   \       0x20   0x2C00             CMP      R4,#+0
   \       0x22   0xDDF0             BLE.N    ??updateTemperaturesFromRawValues_1
   1066            current_temperature_bed = Temperature::analog2tempBed(current_temperature_bed_raw);
   \       0x24   0x6AE8             LDR      R0,[R5, #+44]
   \       0x26   0x.... 0x....      BL       _ZN11Temperature14analog2tempBedEi
   \       0x2A   0x6228             STR      R0,[R5, #+32]
   1067            #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
   1068              redundant_temperature = Temperature::analog2temp(redundant_temperature_raw, 1);
   1069            #endif
   1070            #if ENABLED(FILAMENT_WIDTH_SENSOR)
   1071              filament_width_meas = analog2widthFil();
   1072            #endif
   1073          
   1074            #if ENABLED(USE_WATCHDOG)
   1075              // Reset the watchdog after we know we have a temperature measurement.
   1076              watchdog_reset();
   1077            #endif
   1078          
   1079            CRITICAL_SECTION_START;
   \       0x2C   0xB672             cpsid i
   1080            temp_meas_ready = false;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x7068             STRB     R0,[R5, #+1]
   1081            CRITICAL_SECTION_END;
   \       0x32   0xB662             cpsie i
   1082          }
   \       0x34   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1083          
   1084          
   1085          #if ENABLED(FILAMENT_WIDTH_SENSOR)
   1086          
   1087            // Convert raw Filament Width to millimeters
   1088            float Temperature::analog2widthFil() {
   1089              return current_raw_filwidth / 16383.0 * 5.0;
   1090              //return current_raw_filwidth;
   1091            }
   1092          
   1093            // Convert raw Filament Width to a ratio
   1094            int Temperature::widthFil_to_size_ratio() {
   1095              float temp = filament_width_meas;
   1096              if (temp < MEASURED_LOWER_LIMIT) temp = filament_width_nominal;  //assume sensor cut out
   1097              else NOMORE(temp, MEASURED_UPPER_LIMIT);
   1098              return filament_width_nominal / temp * 100;
   1099            }
   1100          
   1101          #endif
   1102          
   1103          #if ENABLED(HEATER_0_USES_MAX6675)
   1104            #ifndef MAX6675_SCK_PIN
   1105              #define MAX6675_SCK_PIN SCK_PIN
   1106            #endif
   1107            #ifndef MAX6675_DO_PIN
   1108              #define MAX6675_DO_PIN MISO_PIN
   1109            #endif
   1110            Spi<MAX6675_DO_PIN, MOSI_PIN, MAX6675_SCK_PIN> max6675_spi;
   1111          #endif
   1112          
   1113          /**
   1114           * Initialize the temperature manager
   1115           * The manager is implemented by periodic calls to manage_heater()
   1116           */

   \                                 In section .text, align 2, keep-with-next
   1117          void Temperature::init() {
   \                     _ZN11Temperature4initEv: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   1118          #if 0	/*--mks--*/
   1119            #if MB(RUMBA) && (TEMP_SENSOR_0 == -1 || TEMP_SENSOR_1 == -1 || TEMP_SENSOR_2 == -1 || TEMP_SENSOR_BED == -1)
   1120              // Disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector
   1121              MCUCR = _BV(JTD);
   1122              MCUCR = _BV(JTD);
   1123            #endif
   1124          #endif
   1125            // Finish init of mult hotend arrays
   1126            HOTEND_LOOP() maxttemp[e] = maxttemp[0];
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x.... 0x....      LDR.W    R4,??DataTable59
   \        0x8   0xF104 0x0316      ADD      R3,R4,#+22
   \        0xC   0xE003             B.N      ??init_0
   \                     ??init_1: (+1)
   \        0xE   0x8AE2             LDRH     R2,[R4, #+22]
   \       0x10   0xF823 0x2011      STRH     R2,[R3, R1, LSL #+1]
   \       0x14   0x1C40             ADDS     R0,R0,#+1
   \                     ??init_0: (+1)
   \       0x16   0x4601             MOV      R1,R0
   \       0x18   0xB249             SXTB     R1,R1
   \       0x1A   0x2901             CMP      R1,#+1
   \       0x1C   0xDBF7             BLT.N    ??init_1
   1127          
   1128          
   1129          //  #if ENABLED(PIDTEMP) && ENABLED(PID_EXTRUSION_SCALING)	/*--mks cfg end--*/
   1130          #if 0
   1131              last_e_position = 0;
   1132            #endif
   1133          
   1134            #if HAS_HEATER_0
   1135              SET_OUTPUT(HEATER_0_PIN);
   1136            #endif
   1137            #if HAS_HEATER_1
   1138              SET_OUTPUT(HEATER_1_PIN);
   1139            #endif
   1140            #if HAS_HEATER_2
   1141              SET_OUTPUT(HEATER_2_PIN);
   1142            #endif
   1143            #if HAS_HEATER_3
   1144              SET_OUTPUT(HEATER_3_PIN);
   1145            #endif
   1146            #if HAS_HEATER_4
   1147              SET_OUTPUT(HEATER_3_PIN);
   1148            #endif
   1149            #if HAS_HEATER_BED
   1150              SET_OUTPUT(HEATER_BED_PIN);
   1151            #endif
   1152          
   1153            #if HAS_FAN0
   1154              SET_OUTPUT(FAN_PIN);
   1155              #if ENABLED(FAST_PWM_FAN)
   1156                setPwmFrequency(FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1157              #endif
   1158            #endif
   1159          
   1160            #if HAS_FAN1
   1161              SET_OUTPUT(FAN1_PIN);
   1162              #if ENABLED(FAST_PWM_FAN)
   1163                setPwmFrequency(FAN1_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1164              #endif
   1165            #endif
   1166          
   1167            #if HAS_FAN2
   1168              SET_OUTPUT(FAN2_PIN);
   1169              #if ENABLED(FAST_PWM_FAN)
   1170                setPwmFrequency(FAN2_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1171              #endif
   1172            #endif
   1173          
   1174            #if ENABLED(HEATER_0_USES_MAX6675)
   1175          
   1176              OUT_WRITE(SCK_PIN, LOW);
   1177              OUT_WRITE(MOSI_PIN, HIGH);
   1178              SET_INPUT_PULLUP(MISO_PIN);
   1179          
   1180              max6675_spi.init();
   1181          
   1182              OUT_WRITE(SS_PIN, HIGH);
   1183              OUT_WRITE(MAX6675_SS, HIGH);
   1184          
   1185            #endif // HEATER_0_USES_MAX6675
   1186          
   1187            #ifdef DIDR2
   1188              #define ANALOG_SELECT(pin) do{ if (pin < 8) SBI(DIDR0, pin); else SBI(DIDR2, pin - 8); }while(0)
   1189            #else
   1190              #define ANALOG_SELECT(pin) do{ SBI(DIDR0, pin); }while(0)
   1191            #endif
   1192          
   1193          #if 0	/*--mks--*/
   1194            // Set analog inputs
   1195            ADCSRA = _BV(ADEN) | _BV(ADSC) | _BV(ADIF) | 0x07;
   1196            DIDR0 = 0;
   1197            #ifdef DIDR2
   1198              DIDR2 = 0;
   1199            #endif
   1200            #if HAS_TEMP_0
   1201              ANALOG_SELECT(TEMP_0_PIN);
   1202            #endif
   1203            #if HAS_TEMP_1
   1204              ANALOG_SELECT(TEMP_1_PIN);
   1205            #endif
   1206            #if HAS_TEMP_2
   1207              ANALOG_SELECT(TEMP_2_PIN);
   1208            #endif
   1209            #if HAS_TEMP_3
   1210              ANALOG_SELECT(TEMP_3_PIN);
   1211            #endif
   1212            #if HAS_TEMP_4
   1213              ANALOG_SELECT(TEMP_4_PIN);
   1214            #endif
   1215            #if HAS_TEMP_BED
   1216              ANALOG_SELECT(TEMP_BED_PIN);
   1217            #endif
   1218            #if ENABLED(FILAMENT_WIDTH_SENSOR)
   1219              ANALOG_SELECT(FILWIDTH_PIN);
   1220            #endif
   1221          
   1222            #if HAS_AUTO_FAN_0
   1223              #if E0_AUTO_FAN_PIN == FAN1_PIN
   1224                SET_OUTPUT(E0_AUTO_FAN_PIN);
   1225                #if ENABLED(FAST_PWM_FAN)
   1226                  setPwmFrequency(E0_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1227                #endif
   1228              #else
   1229                SET_OUTPUT(E0_AUTO_FAN_PIN);
   1230              #endif
   1231            #endif
   1232            #if HAS_AUTO_FAN_1 && !AUTO_1_IS_0
   1233              #if E1_AUTO_FAN_PIN == FAN1_PIN
   1234                SET_OUTPUT(E1_AUTO_FAN_PIN);
   1235                #if ENABLED(FAST_PWM_FAN)
   1236                  setPwmFrequency(E1_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1237                #endif
   1238              #else
   1239                SET_OUTPUT(E1_AUTO_FAN_PIN);
   1240              #endif
   1241            #endif
   1242            #if HAS_AUTO_FAN_2 && !AUTO_2_IS_0 && !AUTO_2_IS_1
   1243              #if E2_AUTO_FAN_PIN == FAN1_PIN
   1244                SET_OUTPUT(E2_AUTO_FAN_PIN);
   1245                #if ENABLED(FAST_PWM_FAN)
   1246                  setPwmFrequency(E2_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1247                #endif
   1248              #else
   1249                SET_OUTPUT(E2_AUTO_FAN_PIN);
   1250              #endif
   1251            #endif
   1252            #if HAS_AUTO_FAN_3 && !AUTO_3_IS_0 && !AUTO_3_IS_1 && !AUTO_3_IS_2
   1253              #if E3_AUTO_FAN_PIN == FAN1_PIN
   1254                SET_OUTPUT(E3_AUTO_FAN_PIN);
   1255                #if ENABLED(FAST_PWM_FAN)
   1256                  setPwmFrequency(E3_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1257                #endif
   1258              #else
   1259                SET_OUTPUT(E3_AUTO_FAN_PIN);
   1260              #endif
   1261            #endif
   1262            #if HAS_AUTO_FAN_4 && !AUTO_4_IS_0 && !AUTO_4_IS_1 && !AUTO_4_IS_2 && !AUTO_4_IS_3
   1263              #if E4_AUTO_FAN_PIN == FAN1_PIN
   1264                SET_OUTPUT(E4_AUTO_FAN_PIN);
   1265                #if ENABLED(FAST_PWM_FAN)
   1266                  setPwmFrequency(E4_AUTO_FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
   1267                #endif
   1268              #else
   1269                SET_OUTPUT(E4_AUTO_FAN_PIN);
   1270              #endif
   1271            #endif
   1272          
   1273            // Use timer0 for temperature measurement
   1274            // Interleave temperature interrupt with millies interrupt
   1275            OCR0B = 128;
   1276            SBI(TIMSK0, OCIE0B);
   1277          
   1278            // Wait for temperature measurement to settle
   1279            delay(250);
   1280          #endif
   1281          
   1282            #define TEMP_MIN_ROUTINE(NR) \
   1283              minttemp[NR] = HEATER_ ##NR## _MINTEMP; \
   1284              while(analog2temp(minttemp_raw[NR], NR) < HEATER_ ##NR## _MINTEMP) { \
   1285                if (HEATER_ ##NR## _RAW_LO_TEMP < HEATER_ ##NR## _RAW_HI_TEMP) \
   1286                  minttemp_raw[NR] += OVERSAMPLENR; \
   1287                else \
   1288                  minttemp_raw[NR] -= OVERSAMPLENR; \
   1289              }
   1290            #define TEMP_MAX_ROUTINE(NR) \
   1291              maxttemp[NR] = HEATER_ ##NR## _MAXTEMP; \
   1292              while(analog2temp(maxttemp_raw[NR], NR) > HEATER_ ##NR## _MAXTEMP) { \
   1293                if (HEATER_ ##NR## _RAW_LO_TEMP < HEATER_ ##NR## _RAW_HI_TEMP) \
   1294                  maxttemp_raw[NR] -= OVERSAMPLENR; \
   1295                else \
   1296                  maxttemp_raw[NR] += OVERSAMPLENR; \
   1297              }
   1298          
   1299            #ifdef HEATER_0_MINTEMP
   1300              TEMP_MIN_ROUTINE(0);
   \       0x1E   0xF06F 0x0004      MVN      R0,#+4
   \       0x22   0x82A0             STRH     R0,[R4, #+20]
   \       0x24   0x.... 0x....      LDR.W    R6,??DataTable59_12  ;; 0xc0a00000
   \       0x28   0xE002             B.N      ??init_2
   \                     ??init_3: (+1)
   \       0x2A   0x8A20             LDRH     R0,[R4, #+16]
   \       0x2C   0x3810             SUBS     R0,R0,#+16
   \       0x2E   0x8220             STRH     R0,[R4, #+16]
   \                     ??init_2: (+1)
   \       0x30   0x2100             MOVS     R1,#+0
   \       0x32   0xF9B4 0x0010      LDRSH    R0,[R4, #+16]
   \       0x36   0x.... 0x....      BL       _ZN11Temperature11analog2tempEih
   \       0x3A   0x4631             MOV      R1,R6
   \       0x3C   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x40   0xD3F3             BCC.N    ??init_3
   1301            #endif
   1302            #ifdef HEATER_0_MAXTEMP
   1303              TEMP_MAX_ROUTINE(0);
   \       0x42   0x.... 0x....      LDR.W    R5,??DataTable59_2
   \       0x46   0x8E28             LDRH     R0,[R5, #+48]
   \       0x48   0x82E0             STRH     R0,[R4, #+22]
   \       0x4A   0xE002             B.N      ??init_4
   \                     ??init_5: (+1)
   \       0x4C   0x8A60             LDRH     R0,[R4, #+18]
   \       0x4E   0x3010             ADDS     R0,R0,#+16
   \       0x50   0x8260             STRH     R0,[R4, #+18]
   \                     ??init_4: (+1)
   \       0x52   0x2100             MOVS     R1,#+0
   \       0x54   0xF9B4 0x0012      LDRSH    R0,[R4, #+18]
   \       0x58   0x.... 0x....      BL       _ZN11Temperature11analog2tempEih
   \       0x5C   0x4607             MOV      R7,R0
   \       0x5E   0xF9B5 0x0030      LDRSH    R0,[R5, #+48]
   \       0x62   0x.... 0x....      BL       __aeabi_i2f
   \       0x66   0x4639             MOV      R1,R7
   \       0x68   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x6C   0xD3EE             BCC.N    ??init_5
   1304            #endif
   1305            #if HOTENDS > 1
   1306              #ifdef HEATER_1_MINTEMP
   1307                TEMP_MIN_ROUTINE(1);
   1308              #endif
   1309              #ifdef HEATER_1_MAXTEMP
   1310                TEMP_MAX_ROUTINE(1);
   1311              #endif
   1312              #if HOTENDS > 2
   1313                #ifdef HEATER_2_MINTEMP
   1314                  TEMP_MIN_ROUTINE(2);
   1315                #endif
   1316                #ifdef HEATER_2_MAXTEMP
   1317                  TEMP_MAX_ROUTINE(2);
   1318                #endif
   1319                #if HOTENDS > 3
   1320                  #ifdef HEATER_3_MINTEMP
   1321                    TEMP_MIN_ROUTINE(3);
   1322                  #endif
   1323                  #ifdef HEATER_3_MAXTEMP
   1324                    TEMP_MAX_ROUTINE(3);
   1325                  #endif
   1326                  #if HOTENDS > 4
   1327                    #ifdef HEATER_4_MINTEMP
   1328                      TEMP_MIN_ROUTINE(4);
   1329                    #endif
   1330                    #ifdef HEATER_4_MAXTEMP
   1331                      TEMP_MAX_ROUTINE(4);
   1332                    #endif
   1333                  #endif // HOTENDS > 4
   1334                #endif // HOTENDS > 3
   1335              #endif // HOTENDS > 2
   1336            #endif // HOTENDS > 1
   1337          
   1338            #ifdef BED_MINTEMP
   1339              while(analog2tempBed(bed_minttemp_raw) < BED_MINTEMP) {
   \                     ??init_6: (+1)
   \       0x6E   0xF9B4 0x7018      LDRSH    R7,[R4, #+24]
   \       0x72   0x4638             MOV      R0,R7
   \       0x74   0x.... 0x....      BL       _ZN11Temperature14analog2tempBedEi
   \       0x78   0x4631             MOV      R1,R6
   \       0x7A   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x7E   0xD205             BCS.N    ??init_7
   1340                #if HEATER_BED_RAW_LO_TEMP < HEATER_BED_RAW_HI_TEMP
   1341                  bed_minttemp_raw += OVERSAMPLENR;
   1342                #else
   1343                  bed_minttemp_raw -= OVERSAMPLENR;
   \       0x80   0xF1A7 0x0010      SUB      R0,R7,#+16
   \       0x84   0x8320             STRH     R0,[R4, #+24]
   \       0x86   0xE7F2             B.N      ??init_6
   1344                #endif
   1345              }
   1346            #endif //BED_MINTEMP
   1347            #ifdef BED_MAXTEMP
   1348              while (analog2tempBed(bed_maxttemp_raw) > BED_MAXTEMP) {
   1349                #if HEATER_BED_RAW_LO_TEMP < HEATER_BED_RAW_HI_TEMP
   1350                  bed_maxttemp_raw -= OVERSAMPLENR;
   1351                #else
   1352                  bed_maxttemp_raw += OVERSAMPLENR;
   \                     ??init_8: (+1)
   \       0x88   0x3610             ADDS     R6,R6,#+16
   \       0x8A   0x8366             STRH     R6,[R4, #+26]
   1353                #endif
   1354              }
   \                     ??init_7: (+1)
   \       0x8C   0xF9B4 0x601A      LDRSH    R6,[R4, #+26]
   \       0x90   0x4630             MOV      R0,R6
   \       0x92   0x.... 0x....      BL       _ZN11Temperature14analog2tempBedEi
   \       0x96   0x4601             MOV      R1,R0
   \       0x98   0x460F             MOV      R7,R1
   \       0x9A   0xF9B5 0x0032      LDRSH    R0,[R5, #+50]
   \       0x9E   0x.... 0x....      BL       __aeabi_i2f
   \       0xA2   0x4639             MOV      R1,R7
   \       0xA4   0x.... 0x....      BL       __aeabi_cfcmple
   \       0xA8   0xD3EE             BCC.N    ??init_8
   1355            #endif //BED_MAXTEMP
   1356          #if ENABLED(PROBING_HEATERS_OFF)
   1357              paused = false;
   1358              ZERO(paused_hotend_temps);
   1359            //#if HAS_TEMP_BED		/*--mks cfg-- HAS_TEMP_BED --*/
   1360          	if(HAS_TEMP_BED)
   1361            	paused_bed_temp = 0;
   1362            //#endif
   1363          #endif
   1364            
   1365          }
   \       0xAA   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1366          
   1367          #if WATCH_HOTENDS
   1368            /**
   1369             * Start Heating Sanity Check for hotends that are below
   1370             * their target temperature by a configurable margin.
   1371             * This is called when the temperature is set. (M104, M109)
   1372             */

   \                                 In section .text, align 2, keep-with-next
   1373            void Temperature::start_watching_heater(uint8_t e) {
   \                     _ZN11Temperature21start_watching_heaterEh: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   1374              #if HOTENDS == 1
   1375                UNUSED(e);
   1376              #endif
   1377              if (degHotend(HOTEND_INDEX) < degTargetHotend(HOTEND_INDEX) - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1)) {
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x.... 0x....      BL       _ZN11Temperature9degHotendEh
   \        0xA   0x4607             MOV      R7,R0
   \        0xC   0x.... 0x....      LDR.W    R5,??DataTable59_22
   \       0x10   0x78AE             LDRB     R6,[R5, #+2]
   \       0x12   0x.... 0x....      LDR.W    R4,??DataTable59
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x.... 0x....      BL       _ZN11Temperature15degTargetHotendEh
   \       0x1C   0x4680             MOV      R8,R0
   \       0x1E   0x4630             MOV      R0,R6
   \       0x20   0x1CC0             ADDS     R0,R0,#+3
   \       0x22   0x.... 0x....      BL       __aeabi_i2f
   \       0x26   0x4601             MOV      R1,R0
   \       0x28   0x4640             MOV      R0,R8
   \       0x2A   0x.... 0x....      BL       __aeabi_fsub
   \       0x2E   0x4601             MOV      R1,R0
   \       0x30   0x4638             MOV      R0,R7
   \       0x32   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x36   0xD216             BCS.N    ??start_watching_heater_0
   1378          		//int mks_temp = WATCH_TEMP_INCREASE;
   1379              	//watch_target_temp[HOTEND_INDEX] = degHotend(HOTEND_INDEX) + mks_temp;	
   1380                watch_target_temp[HOTEND_INDEX] = degHotend(HOTEND_INDEX) + WATCH_TEMP_INCREASE;
                                                       ^
Warning[Pa093]: implicit conversion from floating point to integer
   \       0x38   0x4630             MOV      R0,R6
   \       0x3A   0x.... 0x....      BL       __aeabi_ui2f
   \       0x3E   0x4606             MOV      R6,R0
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0x.... 0x....      BL       _ZN11Temperature9degHotendEh
   \       0x46   0x4631             MOV      R1,R6
   \       0x48   0x.... 0x....      BL       __aeabi_fadd
   \       0x4C   0x.... 0x....      BL       __aeabi_f2iz
   \       0x50   0x64E0             STR      R0,[R4, #+76]
   1381                watch_heater_next_ms[HOTEND_INDEX] = millis() + (WATCH_TEMP_PERIOD) * 1000UL;
   \       0x52   0x.... 0x....      BL       HAL_GetTick
   \       0x56   0xF9B5 0x2000      LDRSH    R2,[R5, #+0]
   \       0x5A   0xF44F 0x717A      MOV      R1,#+1000
   \       0x5E   0xFB01 0x0002      MLA      R0,R1,R2,R0
   \       0x62   0x6520             STR      R0,[R4, #+80]
   \       0x64   0xE001             B.N      ??start_watching_heater_1
   1382              }
   1383              else
   1384                watch_heater_next_ms[HOTEND_INDEX] = 0;
   \                     ??start_watching_heater_0: (+1)
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0x6520             STR      R0,[R4, #+80]
   1385            }
   \                     ??start_watching_heater_1: (+1)
   \       0x6A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1386          #endif
   1387          
   1388          #if WATCH_THE_BED
   1389            /**
   1390             * Start Heating Sanity Check for hotends that are below
   1391             * their target temperature by a configurable margin.
   1392             * This is called when the temperature is set. (M140, M190)
   1393             */

   \                                 In section .text, align 2, keep-with-next
   1394            void Temperature::start_watching_bed() {
   \                     _ZN11Temperature18start_watching_bedEv: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   1395              if (degBed() < degTargetBed() - (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1)) {
   \        0x4   0x.... 0x....      BL       _ZN11Temperature6degBedEv
   \        0x8   0x4607             MOV      R7,R0
   \        0xA   0x.... 0x....      LDR.W    R5,??DataTable59_23
   \        0xE   0x78AE             LDRB     R6,[R5, #+2]
   \       0x10   0x.... 0x....      LDR.W    R4,??DataTable59
   \       0x14   0x.... 0x....      BL       _ZN11Temperature12degTargetBedEv
   \       0x18   0x4680             MOV      R8,R0
   \       0x1A   0x4630             MOV      R0,R6
   \       0x1C   0x1CC0             ADDS     R0,R0,#+3
   \       0x1E   0x.... 0x....      BL       __aeabi_i2f
   \       0x22   0x4601             MOV      R1,R0
   \       0x24   0x4640             MOV      R0,R8
   \       0x26   0x.... 0x....      BL       __aeabi_fsub
   \       0x2A   0x4601             MOV      R1,R0
   \       0x2C   0x4638             MOV      R0,R7
   \       0x2E   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x32   0xD215             BCS.N    ??start_watching_bed_0
   1396                watch_target_bed_temp = degBed() + WATCH_BED_TEMP_INCREASE;
                                             ^
Warning[Pa093]: implicit conversion from floating point to integer
   \       0x34   0x4630             MOV      R0,R6
   \       0x36   0x.... 0x....      BL       __aeabi_ui2f
   \       0x3A   0x4606             MOV      R6,R0
   \       0x3C   0x.... 0x....      BL       _ZN11Temperature6degBedEv
   \       0x40   0x4631             MOV      R1,R6
   \       0x42   0x.... 0x....      BL       __aeabi_fadd
   \       0x46   0x.... 0x....      BL       __aeabi_f2iz
   \       0x4A   0x6560             STR      R0,[R4, #+84]
   1397                watch_bed_next_ms = millis() + (WATCH_BED_TEMP_PERIOD) * 1000UL;
   \       0x4C   0x.... 0x....      BL       HAL_GetTick
   \       0x50   0xF9B5 0x2000      LDRSH    R2,[R5, #+0]
   \       0x54   0xF44F 0x717A      MOV      R1,#+1000
   \       0x58   0xFB01 0x0002      MLA      R0,R1,R2,R0
   \       0x5C   0x65A0             STR      R0,[R4, #+88]
   \       0x5E   0xE001             B.N      ??start_watching_bed_1
   1398              }
   1399              else
   1400                watch_bed_next_ms = 0;
   \                     ??start_watching_bed_0: (+1)
   \       0x60   0x2000             MOVS     R0,#+0
   \       0x62   0x65A0             STR      R0,[R4, #+88]
   1401            }
   \                     ??start_watching_bed_1: (+1)
   \       0x64   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1402          #endif
   1403          
   1404          #if ENABLED(THERMAL_PROTECTION_HOTENDS) || HAS_THERMALLY_PROTECTED_BED
   1405          
   1406            #if ENABLED(THERMAL_PROTECTION_HOTENDS)
   1407              Temperature::TRState Temperature::thermal_runaway_state_machine[HOTENDS] = { TRInactive };
   1408              millis_t Temperature::thermal_runaway_timer[HOTENDS] = { 0 };
   1409            #endif
   1410          
   1411            #if HAS_THERMALLY_PROTECTED_BED
   1412           // if(HAS_TEMP_BED) /*--mks cfg-- HAS_TEMP_BED --*/
   1413              Temperature::TRState Temperature::thermal_runaway_bed_state_machine = TRInactive;
   1414              millis_t Temperature::thermal_runaway_bed_timer;
   1415          #endif
   1416          

   \                                 In section .text, align 2, keep-with-next
   1417            void Temperature::thermal_runaway_protection(Temperature::TRState* state, millis_t* timer, float current, float target, int heater_id, int period_seconds, int hysteresis_degc) {
   \                     _ZN11Temperature26thermal_runaway_protectionEPNS_7TRStateEPmffiii: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4691             MOV      R9,R2
   \        0x8   0x9E08             LDR      R6,[SP, #+32]
   1418          
   1419              static float tr_target_temperature[HOTENDS + 1] = { 0.0 };
   1420          
   1421              /**
   1422                  SERIAL_ECHO_START;
   1423                  SERIAL_ECHOPGM("Thermal Thermal Runaway Running. Heater ID: ");
   1424                  if (heater_id < 0) SERIAL_ECHOPGM("bed"); else SERIAL_ECHO(heater_id);
   1425                  SERIAL_ECHOPAIR(" ;  State:", *state);
   1426                  SERIAL_ECHOPAIR(" ;  Timer:", *timer);
   1427                  SERIAL_ECHOPAIR(" ;  Temperature:", current);
   1428                  SERIAL_ECHOPAIR(" ;  Target Temp:", target);
   1429                  SERIAL_EOL;
   1430              */
   1431          
   1432              int heater_index = heater_id >= 0 ? heater_id : HOTENDS;
   \        0xA   0x2E00             CMP      R6,#+0
   \        0xC   0xD401             BMI.N    ??thermal_runaway_protection_0
   \        0xE   0x4637             MOV      R7,R6
   \       0x10   0xE000             B.N      ??thermal_runaway_protection_1
   \                     ??thermal_runaway_protection_0: (+1)
   \       0x12   0x2701             MOVS     R7,#+1
   1433          
   1434              // If the target temperature changes, restart
   1435              if (tr_target_temperature[heater_index] != target) {
   \                     ??thermal_runaway_protection_1: (+1)
   \       0x14   0x.... 0x....      LDR.W    R8,??DataTable59_24
   \       0x18   0x4604             MOV      R4,R0
   \       0x1A   0xF858 0x0027      LDR      R0,[R8, R7, LSL #+2]
   \       0x1E   0x4619             MOV      R1,R3
   \       0x20   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0x24   0xD00A             BEQ.N    ??thermal_runaway_protection_2
   1436                tr_target_temperature[heater_index] = target;
   \       0x26   0xF848 0x3027      STR      R3,[R8, R7, LSL #+2]
   1437                *state = target > 0 ? TRFirstHeating : TRInactive;
   \       0x2A   0x4618             MOV      R0,R3
   \       0x2C   0x2100             MOVS     R1,#+0
   \       0x2E   0x.... 0x....      BL       __aeabi_cfrcmple
   \       0x32   0xD201             BCS.N    ??thermal_runaway_protection_3
   \       0x34   0x2001             MOVS     R0,#+1
   \       0x36   0xE000             B.N      ??thermal_runaway_protection_4
   \                     ??thermal_runaway_protection_3: (+1)
   \       0x38   0x4608             MOV      R0,R1
   \                     ??thermal_runaway_protection_4: (+1)
   \       0x3A   0x7020             STRB     R0,[R4, #+0]
   1438              }
   1439          
   1440              switch (*state) {
   \                     ??thermal_runaway_protection_2: (+1)
   \       0x3C   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \       0x40   0x2801             CMP      R0,#+1
   \       0x42   0xD004             BEQ.N    ??thermal_runaway_protection_5
   \       0x44   0xD330             BCC.N    ??thermal_runaway_protection_6
   \       0x46   0x2803             CMP      R0,#+3
   \       0x48   0xD026             BEQ.N    ??thermal_runaway_protection_7
   \       0x4A   0xD308             BCC.N    ??thermal_runaway_protection_8
   \       0x4C   0xE02C             B.N      ??thermal_runaway_protection_6
   1441                // Inactive state waits for a target temperature to be set
   1442                case TRInactive: break;
   1443                // When first heating, wait for the temperature to be reached then go to Stable state
   1444                case TRFirstHeating:
   1445                  if (current < tr_target_temperature[heater_index]) break;
   \                     ??thermal_runaway_protection_5: (+1)
   \       0x4E   0x4648             MOV      R0,R9
   \       0x50   0xF858 0x1027      LDR      R1,[R8, R7, LSL #+2]
   \       0x54   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x58   0xD326             BCC.N    ??thermal_runaway_protection_6
   1446                  *state = TRStable;
   \       0x5A   0x2002             MOVS     R0,#+2
   \       0x5C   0x7020             STRB     R0,[R4, #+0]
   \                     ??thermal_runaway_protection_8: (+1)
   \       0x5E   0x980A             LDR      R0,[SP, #+40]
   1447                // While the temperature is stable watch for a bad temperature
   1448                case TRStable:
   1449                  if (current >= tr_target_temperature[heater_index] - hysteresis_degc) {
   \       0x60   0x.... 0x....      BL       __aeabi_i2f
   \       0x64   0x4601             MOV      R1,R0
   \       0x66   0xF858 0x0027      LDR      R0,[R8, R7, LSL #+2]
   \       0x6A   0x.... 0x....      BL       __aeabi_fsub
   \       0x6E   0x4601             MOV      R1,R0
   \       0x70   0x4648             MOV      R0,R9
   \       0x72   0x.... 0x....      BL       __aeabi_cfrcmple
   \       0x76   0xD808             BHI.N    ??thermal_runaway_protection_9
   \       0x78   0x9C09             LDR      R4,[SP, #+36]
   1450                    *timer = millis() + period_seconds * 1000UL;
   \       0x7A   0x.... 0x....      BL       HAL_GetTick
   \       0x7E   0xF44F 0x717A      MOV      R1,#+1000
   \       0x82   0xFB01 0x0404      MLA      R4,R1,R4,R0
   \       0x86   0x602C             STR      R4,[R5, #+0]
   1451                    break;
   \       0x88   0xE00E             B.N      ??thermal_runaway_protection_6
   1452                  }
   1453                  else if (PENDING(millis(), *timer)) break;
   \                     ??thermal_runaway_protection_9: (+1)
   \       0x8A   0x.... 0x....      BL       HAL_GetTick
   \       0x8E   0x6829             LDR      R1,[R5, #+0]
   \       0x90   0x1A40             SUBS     R0,R0,R1
   \       0x92   0xD409             BMI.N    ??thermal_runaway_protection_6
   1454                  *state = TRRunaway;
   \       0x94   0x2003             MOVS     R0,#+3
   \       0x96   0x7020             STRB     R0,[R4, #+0]
   1455                case TRRunaway:
   1456                  _temp_error(heater_id, PSTR(MSG_T_THERMAL_RUNAWAY), PSTR(MSG_THERMAL_RUNAWAY));
   \                     ??thermal_runaway_protection_7: (+1)
   \       0x98   0x....             LDR.N    R2,??DataTable59_25
   \       0x9A   0x.... 0x....      ADR.W    R1,?_38
   \       0x9E   0x4630             MOV      R0,R6
   \       0xA0   0xE8BD 0x43F8      POP      {R3-R9,LR}
   \       0xA4   0x.... 0x....      B.W      _ZN11Temperature11_temp_errorEiPKcS1_
   1457              }
   1458            }
   \                     ??thermal_runaway_protection_6: (+1)
   \       0xA8   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return

   \                                 In section .bss, align 4
   \                     `Temperature::thermal_runaway_protection(Temperature::TRState *, millis_t *, float, float, int, int, int)::tr_target_temperature`:
   \        0x0                      DS8 8
   1459          
   1460          #endif // THERMAL_PROTECTION_HOTENDS || THERMAL_PROTECTION_BED
   1461          

   \                                 In section .text, align 2, keep-with-next
   1462          void Temperature::disable_all_heaters() {
   \                     _ZN11Temperature19disable_all_heatersEv: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   1463          
   1464            #if ENABLED(AUTOTEMP)
   1465              planner.autotemp_enabled = false;
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x....             LDR.N    R1,??DataTable59_26
   \        0x6   0x7008             STRB     R0,[R1, #+0]
   1466            #endif
   1467          
   1468            HOTEND_LOOP() setTargetHotend(0, e);
   \        0x8   0x4604             MOV      R4,R0
   \        0xA   0xE005             B.N      ??disable_all_heaters_0
   \                     ??disable_all_heaters_1: (+1)
   \        0xC   0x4621             MOV      R1,R4
   \        0xE   0xB2C9             UXTB     R1,R1
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x.... 0x....      BL       _ZN11Temperature15setTargetHotendEfh
   \       0x16   0x1C64             ADDS     R4,R4,#+1
   \                     ??disable_all_heaters_0: (+1)
   \       0x18   0x4620             MOV      R0,R4
   \       0x1A   0xB240             SXTB     R0,R0
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xDDF5             BLE.N    ??disable_all_heaters_1
   1469            setTargetBed(0);
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x.... 0x....      BL       _ZN11Temperature12setTargetBedEf
   1470            // Unpause and reset everything
   1471          #if ENABLED(PROBING_HEATERS_OFF)
   1472              paused = false;
   1473              ZERO(paused_hotend_temps);
   1474            //#if HAS_TEMP_BED	/*--mks cfg-- HAS_TEMP_BED --*/
   1475          	if(HAS_TEMP_BED)
   1476            	paused_bed_temp = 0;
   1477            //#endif
   1478          #endif
   1479          
   1480            // If all heaters go down then for sure our print job has stopped
   1481            print_job_timer.stop();
   \       0x26   0x....             LDR.N    R0,??DataTable59_27
   \       0x28   0x.... 0x....      BL       _ZN9Stopwatch4stopEv
   1482          
   1483            #define DISABLE_HEATER(NR) { \
   1484              setTargetHotend(0, NR); \
   1485              soft_pwm[NR] = 0; \
   1486              WRITE_HEATER_ ##NR (LOW); \
   1487            }
   1488          
   1489            #if HAS_TEMP_HOTEND
   1490              DISABLE_HEATER(0);
   \       0x2C   0x2100             MOVS     R1,#+0
   \       0x2E   0x4608             MOV      R0,R1
   \       0x30   0x.... 0x....      BL       _ZN11Temperature15setTargetHotendEfh
   \       0x34   0x....             LDR.N    R4,??DataTable59
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0x70E0             STRB     R0,[R4, #+3]
   \       0x3A   0x....             LDR.N    R5,??DataTable59_13
   \       0x3C   0x7CE8             LDRB     R0,[R5, #+19]
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD106             BNE.N    ??disable_all_heaters_2
   \       0x42   0x2200             MOVS     R2,#+0
   \       0x44   0x....             LDR.N    R0,??DataTable59_14
   \       0x46   0x8C01             LDRH     R1,[R0, #+32]
   \       0x48   0x....             LDR.N    R0,??DataTable59_15
   \       0x4A   0x6C00             LDR      R0,[R0, #+64]
   \       0x4C   0x.... 0x....      BL       HAL_GPIO_WritePin
   1491              #if HOTENDS > 1
   1492                DISABLE_HEATER(1);
   1493                #if HOTENDS > 2
   1494                  DISABLE_HEATER(2);
   1495                  #if HOTENDS > 3
   1496                    DISABLE_HEATER(3);
   1497                    #if HOTENDS > 4
   1498                      DISABLE_HEATER(4);
   1499                    #endif // HOTENDS > 4
   1500                  #endif // HOTENDS > 3
   1501                #endif // HOTENDS > 2
   1502              #endif // HOTENDS > 1
   1503            #endif
   1504          	
   1505           // #if HAS_TEMP_BED	/*--mks cfg-- HAS_TEMP_BED --*/
   1506            if(HAS_TEMP_BED) {
   \                     ??disable_all_heaters_2: (+1)
   \       0x50   0x....             LDR.N    R0,??DataTable59_2
   \       0x52   0xF890 0x0036      LDRB     R0,[R0, #+54]
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD00E             BEQ.N    ??disable_all_heaters_3
   1507              target_temperature_bed = 0;
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0x6320             STR      R0,[R4, #+48]
   1508              soft_pwm_bed = 0;
   \       0x5E   0x7020             STRB     R0,[R4, #+0]
   1509              #if HAS_HEATER_BED
   1510                WRITE_HEATER_BED(LOW);
   \       0x60   0x7CE8             LDRB     R0,[R5, #+19]
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xD108             BNE.N    ??disable_all_heaters_3
   \       0x66   0x2200             MOVS     R2,#+0
   \       0x68   0x....             LDR.N    R0,??DataTable59_14
   \       0x6A   0x8BC1             LDRH     R1,[R0, #+30]
   \       0x6C   0x....             LDR.N    R0,??DataTable59_15
   \       0x6E   0x6BC0             LDR      R0,[R0, #+60]
   \       0x70   0xE8BD 0x4038      POP      {R3-R5,LR}
   \       0x74   0x.... 0x....      B.W      HAL_GPIO_WritePin
   1511              #endif
   1512            }//#endif
   1513          }
   \                     ??disable_all_heaters_3: (+1)
   \       0x78   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1514          #if ENABLED(PROBING_HEATERS_OFF)
   1515            void Temperature::pause(bool p) {
   1516              if (p && paused) { // If called out of order something is wrong
   1517                SERIAL_ERROR_START;
   1518                SERIAL_ERRORLNPGM("Heaters already paused!");
   1519                return;
   1520              }
   1521          
   1522              if (!p && !paused) {
   1523                SERIAL_ERROR_START;
   1524                SERIAL_ERRORLNPGM("Heaters already unpaused!");
   1525                return;
   1526              }
   1527          
   1528              if (p) {
   1529                HOTEND_LOOP() {
   1530                  paused_hotend_temps[e] = degTargetHotend(e);
   1531                  setTargetHotend(0, e);
   1532                }
   1533               // #if HAS_TEMP_BED	/*--mks cfg-- HAS_TEMP_BED --*/
   1534          		if(HAS_TEMP_BED) {
   1535          	 	paused_bed_temp = degTargetBed();
   1536                  setTargetBed(0);
   1537                }//#endif
   1538              }
   1539              else {
   1540                HOTEND_LOOP() setTargetHotend(paused_hotend_temps[e], e);
   1541               // #if HAS_TEMP_BED	/*--mks cfg-- HAS_TEMP_BED --*/
   1542               if(HAS_TEMP_BED)
   1543                  setTargetBed(paused_bed_temp);
   1544               // #endif
   1545              }
   1546          
   1547              paused = p;
   1548            }
   1549          
   1550            bool Temperature::ispaused() {
   1551              return paused;
   1552            }
   1553          #endif
   1554          
   1555          
   1556          #if ENABLED(HEATER_0_USES_MAX6675)
   1557          
   1558            #define MAX6675_HEAT_INTERVAL 250u
   1559          
   1560            #if ENABLED(MAX6675_IS_MAX31855)
   1561              uint32_t max6675_temp = 2000;
   1562              #define MAX6675_ERROR_MASK 7
   1563              #define MAX6675_DISCARD_BITS 18
   1564              #define MAX6675_SPEED_BITS (_BV(SPR1)) // clock  64
   1565            #else
   1566              uint16_t max6675_temp = 2000;
   1567              #define MAX6675_ERROR_MASK 4
   1568              #define MAX6675_DISCARD_BITS 3
   1569              #define MAX6675_SPEED_BITS (_BV(SPR0)) // clock  16
   1570            #endif
   1571          
   1572            int Temperature::read_max6675() {
   1573          
   1574              static millis_t next_max6675_ms = 0;
   1575          
   1576              millis_t ms = millis();
   1577          
   1578              if (PENDING(ms, next_max6675_ms)) return (int)max6675_temp;
   1579          
   1580              next_max6675_ms = ms + MAX6675_HEAT_INTERVAL;
   1581          
   1582              CBI(
   1583                #ifdef PRR
   1584                  PRR
   1585                #elif defined(PRR0)
   1586                  PRR0
   1587                #endif
   1588                  , PRSPI);
   1589              SPCR = _BV(MSTR) | _BV(SPE) | MAX6675_SPEED_BITS;
   1590          
   1591              WRITE(MAX6675_SS, 0); // enable TT_MAX6675
   1592          
   1593              // ensure 100ns delay - a bit extra is fine
   1594              asm("nop");//50ns on 20Mhz, 62.5ns on 16Mhz
   1595              asm("nop");//50ns on 20Mhz, 62.5ns on 16Mhz
   1596          
   1597              // Read a big-endian temperature value
   1598              max6675_temp = 0;
   1599              for (uint8_t i = sizeof(max6675_temp); i--;) {
   1600                max6675_temp |= max6675_spi.receive();
   1601                if (i > 0) max6675_temp <<= 8; // shift left if not the last byte
   1602              }
   1603          
   1604              WRITE(MAX6675_SS, 1); // disable TT_MAX6675
   1605          
   1606              if (max6675_temp & MAX6675_ERROR_MASK) {
   1607                SERIAL_ERROR_START;
   1608                SERIAL_ERRORPGM("Temp measurement error! ");
   1609                #if MAX6675_ERROR_MASK == 7
   1610                  SERIAL_ERRORPGM("MAX31855 ");
   1611                  if (max6675_temp & 1)
   1612                    SERIAL_ERRORLNPGM("Open Circuit");
   1613                  else if (max6675_temp & 2)
   1614                    SERIAL_ERRORLNPGM("Short to GND");
   1615                  else if (max6675_temp & 4)
   1616                    SERIAL_ERRORLNPGM("Short to VCC");
   1617                #else
   1618                  SERIAL_ERRORLNPGM("MAX6675");
   1619                #endif
   1620                max6675_temp = MAX6675_TMAX * 4; // thermocouple open
   1621              }
   1622              else
   1623                max6675_temp >>= MAX6675_DISCARD_BITS;
   1624                #if ENABLED(MAX6675_IS_MAX31855)
   1625                  // Support negative temperature
   1626                  if (max6675_temp & 0x00002000) max6675_temp |= 0xFFFFC000;
   1627                #endif
   1628          
   1629              return (int)max6675_temp;
   1630            }
   1631          
   1632          #endif //HEATER_0_USES_MAX6675
   1633          
   1634          /**
   1635           * Get raw temperatures
   1636           */

   \                                 In section .text, align 2, keep-with-next
   1637          void Temperature::set_current_temp_raw() {
   1638            #if HAS_TEMP_0 && DISABLED(HEATER_0_USES_MAX6675)
   1639              current_temperature_raw[0] = raw_temp_value[0];
   \                     _ZN11Temperature20set_current_temp_rawEv: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable59
   \        0x2   0x8981             LDRH     R1,[R0, #+12]
   \        0x4   0x6241             STR      R1,[R0, #+36]
   1640            #endif
   1641            #if HAS_TEMP_1
   1642              #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
   1643                redundant_temperature_raw = raw_temp_value[1];
   1644              #else
   1645                current_temperature_raw[1] = raw_temp_value[1];
   1646              #endif
   1647              #if HAS_TEMP_2
   1648                current_temperature_raw[2] = raw_temp_value[2];
   1649                #if HAS_TEMP_3
   1650                  current_temperature_raw[3] = raw_temp_value[3];
   1651                  #if HAS_TEMP_4
   1652                    current_temperature_raw[4] = raw_temp_value[4];
   1653                  #endif
   1654                #endif
   1655              #endif
   1656            #endif
   1657            current_temperature_bed_raw = raw_temp_bed_value;
   \        0x6   0x89C1             LDRH     R1,[R0, #+14]
   \        0x8   0x62C1             STR      R1,[R0, #+44]
   1658            temp_meas_ready = true;
   \        0xA   0x2101             MOVS     R1,#+1
   \        0xC   0x7041             STRB     R1,[R0, #+1]
   1659          }
   \        0xE   0x4770             BX       LR               ;; return
   1660          
   1661          #if ENABLED(PINS_DEBUGGING)
   1662            /**
   1663             * monitors endstops & Z probe for changes
   1664             *
   1665             * If a change is detected then the LED is toggled and
   1666             * a message is sent out the serial port
   1667             *
   1668             * Yes, we could miss a rapid back & forth change but
   1669             * that won't matter because this is all manual.
   1670             *
   1671             */
   1672            void endstop_monitor() {
   1673              static uint16_t old_endstop_bits_local = 0;
   1674              static uint8_t local_LED_status = 0;
   1675              uint16_t current_endstop_bits_local = 0;
   1676              #if HAS_X_MIN	if(mksCfg.use_xmin_plug)
   1677                if (READ(X_MIN_PIN)) SBI(current_endstop_bits_local, X_MIN);
   1678              #endif
   1679              #if HAS_X_MAX	if(mksCfg.use_xmax_plug)
   1680                if (READ(X_MAX_PIN)) SBI(current_endstop_bits_local, X_MAX);
   1681              #endif
   1682              #if HAS_Y_MIN	if(mksCfg.use_ymin_plug)
   1683                if (READ(Y_MIN_PIN)) SBI(current_endstop_bits_local, Y_MIN);
   1684              #endif
   1685              #if HAS_Y_MAX	if(mksCfg.use_ymax_plug)
   1686                if (READ(Y_MAX_PIN)) SBI(current_endstop_bits_local, Y_MAX);
   1687              #endif
   1688              #if HAS_Z_MIN	if(mksCfg.use_zmin_plug)
   1689                if (READ(Z_MIN_PIN)) SBI(current_endstop_bits_local, Z_MIN);
   1690              #endif
   1691              #if HAS_Z_MAX	
   1692          	if(Z_MIN_PROBE_PIN_MODE != Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)
   1693          		{
   1694          		if(mksCfg.use_zmax_plug)
   1695                		{if (READ(Z_MAX_PIN)) SBI(current_endstop_bits_local, Z_MAX);}
   1696          		}
   1697              #endif
   1698              #if HAS_Z_MIN_PROBE_PIN
   1699                if (READ(Z_MIN_PROBE_PIN)) SBI(current_endstop_bits_local, Z_MIN_PROBE);
   1700              #endif
   1701              #if HAS_Z2_MIN
   1702                if (READ(Z2_MIN_PIN)) SBI(current_endstop_bits_local, Z2_MIN);
   1703              #endif
   1704              #if HAS_Z2_MAX
   1705                if (READ(Z2_MAX_PIN)) SBI(current_endstop_bits_local, Z2_MAX);
   1706              #endif
   1707          
   1708              uint16_t endstop_change = current_endstop_bits_local ^ old_endstop_bits_local;
   1709          
   1710              if (endstop_change) {
   1711                #if HAS_X_MIN		if(mksCfg.use_xmin_plug)
   1712                  if (TEST(endstop_change, X_MIN)) SERIAL_PROTOCOLPAIR("X_MIN:", !!TEST(current_endstop_bits_local, X_MIN));
   1713                #endif
   1714                #if HAS_X_MAX		if(mksCfg.use_xmax_plug)
   1715                  if (TEST(endstop_change, X_MAX)) SERIAL_PROTOCOLPAIR("  X_MAX:", !!TEST(current_endstop_bits_local, X_MAX));
   1716                #endif
   1717                #if HAS_Y_MIN		if(mksCfg.use_ymin_plug)
   1718                  if (TEST(endstop_change, Y_MIN)) SERIAL_PROTOCOLPAIR("  Y_MIN:", !!TEST(current_endstop_bits_local, Y_MIN));
   1719                #endif
   1720                #if HAS_Y_MAX		if(mksCfg.use_ymax_plug)
   1721                  if (TEST(endstop_change, Y_MAX)) SERIAL_PROTOCOLPAIR("  Y_MAX:", !!TEST(current_endstop_bits_local, Y_MAX));
   1722                #endif
   1723                #if HAS_Z_MIN		if(mksCfg.use_zmin_plug)
   1724                  if (TEST(endstop_change, Z_MIN)) SERIAL_PROTOCOLPAIR("  Z_MIN:", !!TEST(current_endstop_bits_local, Z_MIN));
   1725                #endif
   1726                #if HAS_Z_MAX		
   1727          	  if(Z_MIN_PROBE_PIN_MODE != Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)
   1728          	  	{
   1729          	 	 if(mksCfg.use_zmax_plug)
   1730                 		{ if (TEST(endstop_change, Z_MAX)) SERIAL_PROTOCOLPAIR("  Z_MAX:", !!TEST(current_endstop_bits_local, Z_MAX));}
   1731          	  	}
   1732                #endif
   1733                #if HAS_Z_MIN_PROBE_PIN
   1734                  if (TEST(endstop_change, Z_MIN_PROBE)) SERIAL_PROTOCOLPAIR("  PROBE:", !!TEST(current_endstop_bits_local, Z_MIN_PROBE));
   1735                #endif
   1736                #if HAS_Z2_MIN
   1737                  if (TEST(endstop_change, Z2_MIN)) SERIAL_PROTOCOLPAIR("  Z2_MIN:", !!TEST(current_endstop_bits_local, Z2_MIN));
   1738                #endif
   1739                #if HAS_Z2_MAX
   1740                  if (TEST(endstop_change, Z2_MAX)) SERIAL_PROTOCOLPAIR("  Z2_MAX:", !!TEST(current_endstop_bits_local, Z2_MAX));
   1741                #endif
   1742                SERIAL_PROTOCOLPGM("\n\n");
   1743                analogWrite(LED_PIN, local_LED_status);
   1744                local_LED_status ^= 255;
   1745                old_endstop_bits_local = current_endstop_bits_local;
   1746              }
   1747            }
   1748          #endif // PINS_DEBUGGING
   1749          
   1750          /**
   1751           * Timer 0 is shared with millies so don't change the prescaler.
   1752           *
   1753           * This ISR uses the compare method so it runs at the base
   1754           * frequency (16 MHz / 64 / 256 = 976.5625 Hz), but at the TCNT0 set
   1755           * in OCR0B above (128 or halfway between OVFs).
   1756           *
   1757           *  - Manage PWM to all the heaters and fan
   1758           *  - Prepare or Measure one of the raw ADC sensor values
   1759           *  - Check new temperature values for MIN/MAX errors (kill on error)
   1760           *  - Step the babysteps value for each axis towards 0
   1761           *  - For PINS_DEBUGGING, monitor and report endstop pins
   1762           *  - For ENDSTOP_INTERRUPTS_FEATURE check endstops if flagged
   1763           */
   1764          //ISR(TIMER0_COMPB_vect) { Temperature::isr(); }
   1765          
   1766          volatile bool Temperature::in_temp_isr = false;
   1767          
   1768          //void Temperature::isr() {

   \                                 In section .text, align 4, keep-with-next
   1769            void IsrTemperatureHandler() { Temperature::TemperatureHandler(); }
   \                     IsrTemperatureHandler: (+1)
   \        0x0   0xBF00             Nop      
   \        0x2                      REQUIRE _ZN11Temperature18TemperatureHandlerEv
   \        0x2                      ;; // Fall through to label Temperature::TemperatureHandler()

   \                                 In section .text, align 2, keep-with-next
   1770            void Temperature::TemperatureHandler(void)  {
   \                     _ZN11Temperature18TemperatureHandlerEv: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   1771          
   1772            // The stepper ISR can interrupt this ISR. When it does it re-enables this ISR
   1773            // at the end of its run, potentially causing re-entry. This flag prevents it.
   1774            if (in_temp_isr) return;
   \        0x2   0x....             LDR.N    R4,??DataTable59
   \        0x4   0x7920             LDRB     R0,[R4, #+4]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xF040 0x80D5      BNE.W    ??TemperatureHandler_0
   1775            in_temp_isr = true;
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0x7120             STRB     R0,[R4, #+4]
   1776          
   1777            // Allow UART and stepper ISRs
   1778           // CBI(TIMSK0, OCIE0B); //Disable Temperature ISR
   1779           // sei();  /*--mks--*/
   1780            HAL_TIM_Base_Stop_IT(&htim4);
   \       0x10   0x....             LDR.N    R5,??DataTable59_28
   \       0x12   0x4628             MOV      R0,R5
   \       0x14   0x.... 0x....      BL       HAL_TIM_Base_Stop_IT
   1781          
   1782            static int8_t temp_count = -1;
   1783            static ADCSensorState adc_sensor_state = StartupDelay;
   1784            static uint8_t pwm_count = _BV(SOFT_PWM_SCALE);
   1785            // avoid multiple loads of pwm_count
   1786            uint8_t pwm_count_tmp = pwm_count;
   \       0x18   0x79E6             LDRB     R6,[R4, #+7]
   1787          
   1788            // Static members for each heater
   1789            #if ENABLED(SLOW_PWM_HEATERS)
   1790              static uint8_t slow_pwm_count = 0;
   1791              #define ISR_STATICS(n) \
   1792                static uint8_t soft_pwm_ ## n; \
   1793                static uint8_t state_heater_ ## n = 0; \
   1794                static uint8_t state_timer_heater_ ## n = 0
   1795            #else
   1796              #define ISR_STATICS(n) static uint8_t soft_pwm_ ## n = 0
   1797            #endif
   1798          
   1799            // Statics per heater
   1800            ISR_STATICS(0);
   1801            #if HOTENDS > 1
   1802              ISR_STATICS(1);
   1803              #if HOTENDS > 2
   1804                ISR_STATICS(2);
   1805                #if HOTENDS > 3
   1806                  ISR_STATICS(3);
   1807                  #if HOTENDS > 4
   1808                    ISR_STATICS(4);
   1809                  #endif // HOTENDS > 4
   1810                #endif // HOTENDS > 3
   1811              #endif // HOTENDS > 2
   1812            #endif // HOTENDS > 1
   1813            #if HAS_HEATER_BED
   1814              ISR_STATICS(BED);
   1815            #endif
   1816          
   1817            #if ENABLED(FILAMENT_WIDTH_SENSOR)
   1818              static unsigned long raw_filwidth_value = 0;
   1819            #endif
   1820          
   1821            #if DISABLED(SLOW_PWM_HEATERS)
   1822              constexpr uint8_t pwm_mask =
   1823                #if ENABLED(SOFT_PWM_DITHER)
   1824                  _BV(SOFT_PWM_SCALE) - 1
   1825                #else
   1826                  0
   1827                #endif
   1828              ;
   1829          
   1830              /**
   1831               * Standard PWM modulation
   1832               */
   1833              if (pwm_count_tmp >= 127) {
   \       0x1A   0x2E7F             CMP      R6,#+127
   \       0x1C   0xDB1F             BLT.N    ??TemperatureHandler_1
   1834                pwm_count_tmp -= 127;
   \       0x1E   0x3E7F             SUBS     R6,R6,#+127
   1835                soft_pwm_0 = (soft_pwm_0 & pwm_mask) + soft_pwm[0];
   \       0x20   0x78E0             LDRB     R0,[R4, #+3]
   \       0x22   0x7220             STRB     R0,[R4, #+8]
   1836                //WRITE_HEATER_0(soft_pwm_0 > pwm_mask ? HIGH : LOW);	/*--mks--*/
   1837          	  if(soft_pwm_0 > pwm_mask) WRITE_HEATER_0(HIGH);
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD00A             BEQ.N    ??TemperatureHandler_2
   \       0x28   0x....             LDR.N    R0,??DataTable59_13
   \       0x2A   0x7CC0             LDRB     R0,[R0, #+19]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD106             BNE.N    ??TemperatureHandler_2
   \       0x30   0x2201             MOVS     R2,#+1
   \       0x32   0x....             LDR.N    R0,??DataTable59_14
   \       0x34   0x8C01             LDRH     R1,[R0, #+32]
   \       0x36   0x....             LDR.N    R0,??DataTable59_15
   \       0x38   0x6C00             LDR      R0,[R0, #+64]
   \       0x3A   0x.... 0x....      BL       HAL_GPIO_WritePin
   1838          	  else WRITE_HEATER_0(LOW);
   1839                #if HOTENDS > 1
   1840                  soft_pwm_1 = (soft_pwm_1 & pwm_mask) + soft_pwm[1];
   1841                  WRITE_HEATER_1(soft_pwm_1 > pwm_mask ? HIGH : LOW);
   1842                  #if HOTENDS > 2
   1843                    soft_pwm_2 = (soft_pwm_2 & pwm_mask) + soft_pwm[2];
   1844                    WRITE_HEATER_2(soft_pwm_2 > pwm_mask ? HIGH : LOW);
   1845                    #if HOTENDS > 3
   1846                      soft_pwm_3 = (soft_pwm_3 & pwm_mask) + soft_pwm[3];
   1847                      WRITE_HEATER_3(soft_pwm_3 > pwm_mask ? HIGH : LOW);
   1848                      #if HOTENDS > 4
   1849                        soft_pwm_4 = (soft_pwm_4 & pwm_mask) + soft_pwm[4];
   1850                        WRITE_HEATER_4(soft_pwm_4 > pwm_mask ? HIGH : LOW);
   1851                      #endif // HOTENDS > 4
   1852                    #endif // HOTENDS > 3
   1853                  #endif // HOTENDS > 2
   1854                #endif // HOTENDS > 1
   1855          
   1856                #if HAS_HEATER_BED
   1857                  soft_pwm_BED = (soft_pwm_BED & pwm_mask) + soft_pwm_bed;
   \                     ??TemperatureHandler_2: (+1)
   \       0x3E   0x7820             LDRB     R0,[R4, #+0]
   \       0x40   0x7260             STRB     R0,[R4, #+9]
   1858                  //WRITE_HEATER_BED(soft_pwm_BED > pwm_mask ? HIGH : LOW);	/*--mks--*/
   1859          		if(soft_pwm_BED > pwm_mask) WRITE_HEATER_BED(HIGH);
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD027             BEQ.N    ??TemperatureHandler_3
   \       0x46   0x....             LDR.N    R0,??DataTable59_13
   \       0x48   0x7CC0             LDRB     R0,[R0, #+19]
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD118             BNE.N    ??TemperatureHandler_4
   \       0x4E   0x2201             MOVS     R2,#+1
   \       0x50   0x....             LDR.N    R0,??DataTable59_14
   \       0x52   0x8BC1             LDRH     R1,[R0, #+30]
   \       0x54   0x....             LDR.N    R0,??DataTable59_15
   \       0x56   0x6BC0             LDR      R0,[R0, #+60]
   \       0x58   0x.... 0x....      BL       HAL_GPIO_WritePin
   \       0x5C   0xE01B             B.N      ??TemperatureHandler_3
   1860          		else WRITE_HEATER_BED(LOW);
   1861                #endif
   1862          
   1863                #if ENABLED(FAN_SOFT_PWM)
   1864                  #if HAS_FAN0
   1865                    soft_pwm_fan[0] = (soft_pwm_fan[0] & pwm_mask) + fanSpeedSoftPwm[0] >> 1;
   1866                    WRITE_FAN(soft_pwm_fan[0] > pwm_mask ? HIGH : LOW);
   1867                  #endif
   1868                  #if HAS_FAN1
   1869                    soft_pwm_fan[1] = (soft_pwm_fan[1] & pwm_mask) + fanSpeedSoftPwm[1] >> 1;
   1870                    WRITE_FAN1(soft_pwm_fan[1] > pwm_mask ? HIGH : LOW);
   1871                  #endif
   1872                  #if HAS_FAN2
   1873                    soft_pwm_fan[2] = (soft_pwm_fan[2] & pwm_mask) + fanSpeedSoftPwm[2] >> 1;
   1874                    WRITE_FAN2(soft_pwm_fan[2] > pwm_mask ? HIGH : LOW);
   1875                  #endif
   1876                #endif
   1877              }
   1878              else {
   1879                if (soft_pwm_0 <= pwm_count_tmp) WRITE_HEATER_0(0);
   \                     ??TemperatureHandler_1: (+1)
   \       0x5E   0x7A20             LDRB     R0,[R4, #+8]
   \       0x60   0x4286             CMP      R6,R0
   \       0x62   0xDB0A             BLT.N    ??TemperatureHandler_5
   \       0x64   0x....             LDR.N    R0,??DataTable59_13
   \       0x66   0x7CC0             LDRB     R0,[R0, #+19]
   \       0x68   0x2800             CMP      R0,#+0
   \       0x6A   0xD106             BNE.N    ??TemperatureHandler_5
   \       0x6C   0x2200             MOVS     R2,#+0
   \       0x6E   0x....             LDR.N    R0,??DataTable59_14
   \       0x70   0x8C01             LDRH     R1,[R0, #+32]
   \       0x72   0x....             LDR.N    R0,??DataTable59_15
   \       0x74   0x6C00             LDR      R0,[R0, #+64]
   \       0x76   0x.... 0x....      BL       HAL_GPIO_WritePin
   1880                #if HOTENDS > 1
   1881                  if (soft_pwm_1 <= pwm_count_tmp) WRITE_HEATER_1(0);
   1882                  #if HOTENDS > 2
   1883                    if (soft_pwm_2 <= pwm_count_tmp) WRITE_HEATER_2(0);
   1884                    #if HOTENDS > 3
   1885                      if (soft_pwm_3 <= pwm_count_tmp) WRITE_HEATER_3(0);
   1886                      #if HOTENDS > 4
   1887                        if (soft_pwm_4 <= pwm_count_tmp) WRITE_HEATER_4(0);
   1888                      #endif // HOTENDS > 4
   1889                    #endif // HOTENDS > 3
   1890                  #endif // HOTENDS > 2
   1891                #endif // HOTENDS > 1
   1892          
   1893                #if HAS_HEATER_BED
   1894                  if (soft_pwm_BED <= pwm_count_tmp) WRITE_HEATER_BED(0);
   \                     ??TemperatureHandler_5: (+1)
   \       0x7A   0x7A60             LDRB     R0,[R4, #+9]
   \       0x7C   0x4286             CMP      R6,R0
   \       0x7E   0xDB0A             BLT.N    ??TemperatureHandler_3
   \                     ??TemperatureHandler_4: (+1)
   \       0x80   0x....             LDR.N    R0,??DataTable59_13
   \       0x82   0x7CC0             LDRB     R0,[R0, #+19]
   \       0x84   0x2800             CMP      R0,#+0
   \       0x86   0xD106             BNE.N    ??TemperatureHandler_3
   \       0x88   0x2200             MOVS     R2,#+0
   \       0x8A   0x....             LDR.N    R0,??DataTable59_14
   \       0x8C   0x8BC1             LDRH     R1,[R0, #+30]
   \       0x8E   0x....             LDR.N    R0,??DataTable59_15
   \       0x90   0x6BC0             LDR      R0,[R0, #+60]
   \       0x92   0x.... 0x....      BL       HAL_GPIO_WritePin
   1895                #endif
   1896          
   1897                #if ENABLED(FAN_SOFT_PWM)
   1898                  #if HAS_FAN0
   1899                    if (soft_pwm_fan[0] <= pwm_count_tmp) WRITE_FAN(0);
   1900                  #endif
   1901                  #if HAS_FAN1
   1902                    if (soft_pwm_fan[1] <= pwm_count_tmp) WRITE_FAN1(0);
   1903                  #endif
   1904                  #if HAS_FAN2
   1905                    if (soft_pwm_fan[2] <= pwm_count_tmp) WRITE_FAN2(0);
   1906                  #endif
   1907                #endif
   1908              }
   1909          
   1910              // SOFT_PWM_SCALE to frequency:
   1911              //
   1912              // 0: 16000000/64/256/128 =   7.6294 Hz
   1913              // 1:                / 64 =  15.2588 Hz
   1914              // 2:                / 32 =  30.5176 Hz
   1915              // 3:                / 16 =  61.0352 Hz
   1916              // 4:                /  8 = 122.0703 Hz
   1917              // 5:                /  4 = 244.1406 Hz
   1918              pwm_count = pwm_count_tmp + _BV(SOFT_PWM_SCALE);
   \                     ??TemperatureHandler_3: (+1)
   \       0x96   0x1C76             ADDS     R6,R6,#+1
   \       0x98   0x71E6             STRB     R6,[R4, #+7]
   1919          
   1920            #else // SLOW_PWM_HEATERS
   1921          
   1922              /**
   1923               * SLOW PWM HEATERS
   1924               *
   1925               * For relay-driven heaters
   1926               */
   1927              #ifndef MIN_STATE_TIME
   1928                #define MIN_STATE_TIME 16 // MIN_STATE_TIME * 65.5 = time in milliseconds
   1929              #endif
   1930          
   1931              // Macros for Slow PWM timer logic
   1932              #define _SLOW_PWM_ROUTINE(NR, src) \
   1933                soft_pwm_ ##NR = src; \
   1934                if (soft_pwm_ ##NR > 0) { \
   1935                  if (state_timer_heater_ ##NR == 0) { \
   1936                    if (state_heater_ ##NR == 0) state_timer_heater_ ##NR = MIN_STATE_TIME; \
   1937                    state_heater_ ##NR = 1; \
   1938                    WRITE_HEATER_ ##NR(1); \
   1939                  } \
   1940                } \
   1941                else { \
   1942                  if (state_timer_heater_ ##NR == 0) { \
   1943                    if (state_heater_ ##NR == 1) state_timer_heater_ ##NR = MIN_STATE_TIME; \
   1944                    state_heater_ ##NR = 0; \
   1945                    WRITE_HEATER_ ##NR(0); \
   1946                  } \
   1947                }
   1948              #define SLOW_PWM_ROUTINE(n) _SLOW_PWM_ROUTINE(n, soft_pwm[n])
   1949          
   1950              #define PWM_OFF_ROUTINE(NR) \
   1951                if (soft_pwm_ ##NR < slow_pwm_count) { \
   1952                  if (state_timer_heater_ ##NR == 0) { \
   1953                    if (state_heater_ ##NR == 1) state_timer_heater_ ##NR = MIN_STATE_TIME; \
   1954                    state_heater_ ##NR = 0; \
   1955                    WRITE_HEATER_ ##NR (0); \
   1956                  } \
   1957                }
   1958          
   1959              if (slow_pwm_count == 0) {
   1960          
   1961                SLOW_PWM_ROUTINE(0);
   1962                #if HOTENDS > 1
   1963                  SLOW_PWM_ROUTINE(1);
   1964                  #if HOTENDS > 2
   1965                    SLOW_PWM_ROUTINE(2);
   1966                    #if HOTENDS > 3
   1967                      SLOW_PWM_ROUTINE(3);
   1968                      #if HOTENDS > 4
   1969                        SLOW_PWM_ROUTINE(4);
   1970                      #endif // HOTENDS > 4
   1971                    #endif // HOTENDS > 3
   1972                  #endif // HOTENDS > 2
   1973                #endif // HOTENDS > 1
   1974                #if HAS_HEATER_BED
   1975                  _SLOW_PWM_ROUTINE(BED, soft_pwm_bed); // BED
   1976                #endif
   1977          
   1978              } // slow_pwm_count == 0
   1979          
   1980              PWM_OFF_ROUTINE(0);
   1981              #if HOTENDS > 1
   1982                PWM_OFF_ROUTINE(1);
   1983                #if HOTENDS > 2
   1984                  PWM_OFF_ROUTINE(2);
   1985                  #if HOTENDS > 3
   1986                    PWM_OFF_ROUTINE(3);
   1987                    #if HOTENDS > 4
   1988                      PWM_OFF_ROUTINE(4);
   1989                    #endif // HOTENDS > 4
   1990                  #endif // HOTENDS > 3
   1991                #endif // HOTENDS > 2
   1992              #endif // HOTENDS > 1
   1993              #if HAS_HEATER_BED
   1994                PWM_OFF_ROUTINE(BED); // BED
   1995              #endif
   1996          
   1997              #if ENABLED(FAN_SOFT_PWM)
   1998                if (pwm_count_tmp >= 127) {
   1999                  pwm_count_tmp = 0;
   2000                  #if HAS_FAN0
   2001                    soft_pwm_fan[0] = fanSpeedSoftPwm[0] >> 1;
   2002                    WRITE_FAN(soft_pwm_fan[0] > 0 ? HIGH : LOW);
   2003                  #endif
   2004                  #if HAS_FAN1
   2005                    soft_pwm_fan[1] = fanSpeedSoftPwm[1] >> 1;
   2006                    WRITE_FAN1(soft_pwm_fan[1] > 0 ? HIGH : LOW);
   2007                  #endif
   2008                  #if HAS_FAN2
   2009                    soft_pwm_fan[2] = fanSpeedSoftPwm[2] >> 1;
   2010                    WRITE_FAN2(soft_pwm_fan[2] > 0 ? HIGH : LOW);
   2011                  #endif
   2012                }
   2013                #if HAS_FAN0
   2014                  if (soft_pwm_fan[0] <= pwm_count_tmp) WRITE_FAN(0);
   2015                #endif
   2016                #if HAS_FAN1
   2017                  if (soft_pwm_fan[1] <= pwm_count_tmp) WRITE_FAN1(0);
   2018                #endif
   2019                #if HAS_FAN2
   2020                  if (soft_pwm_fan[2] <= pwm_count_tmp) WRITE_FAN2(0);
   2021                #endif
   2022              #endif // FAN_SOFT_PWM
   2023          
   2024              // SOFT_PWM_SCALE to frequency:
   2025              //
   2026              // 0: 16000000/64/256/128 =   7.6294 Hz
   2027              // 1:                / 64 =  15.2588 Hz
   2028              // 2:                / 32 =  30.5176 Hz
   2029              // 3:                / 16 =  61.0352 Hz
   2030              // 4:                /  8 = 122.0703 Hz
   2031              // 5:                /  4 = 244.1406 Hz
   2032              pwm_count = pwm_count_tmp + _BV(SOFT_PWM_SCALE);
   2033          
   2034              // increment slow_pwm_count only every 64th pwm_count,
   2035              // i.e. yielding a PWM frequency of 16/128 Hz (8s).
   2036              if (((pwm_count >> SOFT_PWM_SCALE) & 0x3F) == 0) {
   2037                slow_pwm_count++;
   2038                slow_pwm_count &= 0x7F;
   2039          
   2040                if (state_timer_heater_0 > 0) state_timer_heater_0--;
   2041                #if HOTENDS > 1
   2042                  if (state_timer_heater_1 > 0) state_timer_heater_1--;
   2043                  #if HOTENDS > 2
   2044                    if (state_timer_heater_2 > 0) state_timer_heater_2--;
   2045                    #if HOTENDS > 3
   2046                      if (state_timer_heater_3 > 0) state_timer_heater_3--;
   2047                      #if HOTENDS > 4
   2048                        if (state_timer_heater_4 > 0) state_timer_heater_4--;
   2049                      #endif // HOTENDS > 4
   2050                    #endif // HOTENDS > 3
   2051                  #endif // HOTENDS > 2
   2052                #endif // HOTENDS > 1
   2053                #if HAS_HEATER_BED
   2054                  if (state_timer_heater_BED > 0) state_timer_heater_BED--;
   2055                #endif
   2056              } // ((pwm_count >> SOFT_PWM_SCALE) & 0x3F) == 0
   2057          
   2058            #endif // SLOW_PWM_HEATERS
   2059          
   2060            //
   2061            // Update lcd buttons 488 times per second
   2062            //
   2063            static bool do_buttons;
   2064            if ((do_buttons ^= true)) lcd_buttons_update();
   \       0x9A   0x7AA0             LDRB     R0,[R4, #+10]
   \       0x9C   0xF080 0x0001      EOR      R0,R0,#0x1
   \       0xA0   0x1E40             SUBS     R0,R0,#+1
   \       0xA2   0x4180             SBCS     R0,R0,R0
   \       0xA4   0x43C0             MVNS     R0,R0
   \       0xA6   0x0FC0             LSRS     R0,R0,#+31
   \       0xA8   0x72A0             STRB     R0,[R4, #+10]
   \       0xAA   0x7AA0             LDRB     R0,[R4, #+10]
   \       0xAC   0x2800             CMP      R0,#+0
   \       0xAE   0xD001             BEQ.N    ??TemperatureHandler_6
   \       0xB0   0x.... 0x....      BL       _Z18lcd_buttons_updatev
   2065          
   2066            /**
   2067             * One sensor is sampled on every other call of the ISR.
   2068             * Each sensor is read 16 (OVERSAMPLENR) times, taking the average.
   2069             *
   2070             * On each Prepare pass, ADC is started for a sensor pin.
   2071             * On the next pass, the ADC value is read and accumulated.
   2072             *
   2073             * This gives each ADC 0.9765ms to charge up.
   2074             */
   2075          #if 0 /*--mks--*/
   2076            #define SET_ADMUX_ADCSRA(pin) ADMUX = _BV(REFS0) | (pin & 0x07); SBI(ADCSRA, ADSC)
   2077            #ifdef MUX5
   2078              #define START_ADC(pin) if (pin > 7) ADCSRB = _BV(MUX5); else ADCSRB = 0; SET_ADMUX_ADCSRA(pin)
   2079            #else
   2080              #define START_ADC(pin) ADCSRB = 0; SET_ADMUX_ADCSRA(pin)
   2081            #endif
   2082          #endif
   2083            switch (adc_sensor_state) {
   \                     ??TemperatureHandler_6: (+1)
   \       0xB4   0xF994 0x0006      LDRSB    R0,[R4, #+6]
   \       0xB8   0x2801             CMP      R0,#+1
   \       0xBA   0xD011             BEQ.N    ??TemperatureHandler_7
   \       0xBC   0x2803             CMP      R0,#+3
   \       0xBE   0xD016             BEQ.N    ??TemperatureHandler_8
   \       0xC0   0x2804             CMP      R0,#+4
   \       0xC2   0xD11A             BNE.N    ??TemperatureHandler_9
   2084          
   2085              case SensorsReady: {
   2086                // All sensors have been read. Stay in this state for a few
   2087                // ISRs to save on calls to temp update/checking code below.
   2088                constexpr int extra_loops = MIN_ADC_ISR_LOOPS - (int)SensorsReady;
   2089                static uint8_t delay_count = 0;
   2090                if (extra_loops > 0) {
   2091                  if (delay_count == 0) delay_count = extra_loops;   // Init this delay
   \       0xC4   0x7AE0             LDRB     R0,[R4, #+11]
   \       0xC6   0x2800             CMP      R0,#+0
   \       0xC8   0xD101             BNE.N    ??TemperatureHandler_10
   \       0xCA   0x2006             MOVS     R0,#+6
   \       0xCC   0x72E0             STRB     R0,[R4, #+11]
   2092                  if (--delay_count)                                 // While delaying...
   \                     ??TemperatureHandler_10: (+1)
   \       0xCE   0x7AE0             LDRB     R0,[R4, #+11]
   \       0xD0   0x1E40             SUBS     R0,R0,#+1
   \       0xD2   0x72E0             STRB     R0,[R4, #+11]
   \       0xD4   0xB2C0             UXTB     R0,R0
   \       0xD6   0x2800             CMP      R0,#+0
   \       0xD8   0xD00F             BEQ.N    ??TemperatureHandler_9
   2093                    adc_sensor_state = (ADCSensorState)(int(SensorsReady) - 1); // retain this state (else, next state will be 0)
   \       0xDA   0x2003             MOVS     R0,#+3
   \       0xDC   0x71A0             STRB     R0,[R4, #+6]
   \       0xDE   0xE00C             B.N      ??TemperatureHandler_9
   2094                  break;
   2095                }
   2096                else
   2097                  adc_sensor_state = (ADCSensorState)0; // Fall-through to start first sensor now
   2098              }
   2099          
   2100              #if HAS_TEMP_0
   2101                case PrepareTemp_0:
   2102                  //START_ADC(TEMP_0_PIN);	/*--mks--*/
   2103                  break;
   2104                case MeasureTemp_0:
   2105                  //raw_temp_value[0] += ADC;
   2106          		raw_temp_value[0] += uhADCxConvertedValue[0]>>2;
   \                     ??TemperatureHandler_7: (+1)
   \       0xE0   0x89A0             LDRH     R0,[R4, #+12]
   \       0xE2   0x....             LDR.N    R1,??DataTable59_29
   \       0xE4   0x8809             LDRH     R1,[R1, #+0]
   \       0xE6   0xEB00 0x0091      ADD      R0,R0,R1, LSR #+2
   \       0xEA   0x81A0             STRH     R0,[R4, #+12]
   2107                  break;
   \       0xEC   0xE005             B.N      ??TemperatureHandler_9
   2108              #endif
   2109          
   2110              //#if HAS_TEMP_BED	/*--mks cfg-- HAS_TEMP_BED --*/
   2111            #if 1
   2112                case PrepareTemp_BED:
   2113                  //START_ADC(TEMP_BED_PIN);	/*--mks--*/
   2114                  break;
   2115                case MeasureTemp_BED:
   2116                  //raw_temp_bed_value += ADC;
   2117          		raw_temp_bed_value += uhADCxConvertedValue[1]>>2;
   \                     ??TemperatureHandler_8: (+1)
   \       0xEE   0x89E0             LDRH     R0,[R4, #+14]
   \       0xF0   0x....             LDR.N    R1,??DataTable59_29
   \       0xF2   0x8849             LDRH     R1,[R1, #+2]
   \       0xF4   0xEB00 0x0091      ADD      R0,R0,R1, LSR #+2
   \       0xF8   0x81E0             STRH     R0,[R4, #+14]
   2118                  break;
   2119              #endif
   2120          
   2121              #if HAS_TEMP_1
   2122                case PrepareTemp_1:
   2123                  START_ADC(TEMP_1_PIN);
   2124                  break;
   2125                case MeasureTemp_1:
   2126                  raw_temp_value[1] += ADC;
   2127                  break;
   2128              #endif
   2129          
   2130              #if HAS_TEMP_2
   2131                case PrepareTemp_2:
   2132                  START_ADC(TEMP_2_PIN);
   2133                  break;
   2134                case MeasureTemp_2:
   2135                  raw_temp_value[2] += ADC;
   2136                  break;
   2137              #endif
   2138          
   2139              #if HAS_TEMP_3
   2140                case PrepareTemp_3:
   2141                  START_ADC(TEMP_3_PIN);
   2142                  break;
   2143                case MeasureTemp_3:
   2144                  raw_temp_value[3] += ADC;
   2145                  break;
   2146              #endif
   2147          
   2148              #if HAS_TEMP_4
   2149                case PrepareTemp_4:
   2150                  START_ADC(TEMP_4_PIN);
   2151                  break;
   2152                case MeasureTemp_4:
   2153                  raw_temp_value[4] += ADC;
   2154                  break;
   2155              #endif
   2156          
   2157              #if ENABLED(FILAMENT_WIDTH_SENSOR)
   2158                case Prepare_FILWIDTH:
   2159                  START_ADC(FILWIDTH_PIN);
   2160                break;
   2161                case Measure_FILWIDTH:
   2162                  if (ADC > 102) { // Make sure ADC is reading > 0.5 volts, otherwise don't read.
   2163                    raw_filwidth_value -= (raw_filwidth_value >> 7); // Subtract 1/128th of the raw_filwidth_value
   2164                    raw_filwidth_value += ((unsigned long)ADC << 7); // Add new ADC reading, scaled by 128
   2165                  }
   2166                  break;
   2167              #endif
   2168          
   2169              case StartupDelay: break;
   2170          
   2171            } // switch(adc_sensor_state)
   2172          
   2173            if (!adc_sensor_state && ++temp_count >= OVERSAMPLENR) { // 10 * 16 * 1/(16000000/64/256)  = 164ms.
   \                     ??TemperatureHandler_9: (+1)
   \       0xFA   0xF994 0x0006      LDRSB    R0,[R4, #+6]
   \       0xFE   0x2800             CMP      R0,#+0
   \      0x100   0xD148             BNE.N    ??TemperatureHandler_11
   \      0x102   0x7960             LDRB     R0,[R4, #+5]
   \      0x104   0x1C40             ADDS     R0,R0,#+1
   \      0x106   0x7160             STRB     R0,[R4, #+5]
   \      0x108   0xB240             SXTB     R0,R0
   \      0x10A   0x2810             CMP      R0,#+16
   \      0x10C   0xDB42             BLT.N    ??TemperatureHandler_11
   2174          
   2175              temp_count = 0;
   \      0x10E   0x2000             MOVS     R0,#+0
   \      0x110   0x7160             STRB     R0,[R4, #+5]
   2176          
   2177              // Update the raw values if they've been read. Else we could be updating them during reading.
   2178              if (!temp_meas_ready) set_current_temp_raw();
   \      0x112   0x7860             LDRB     R0,[R4, #+1]
   \      0x114   0x2800             CMP      R0,#+0
   \      0x116   0xD101             BNE.N    ??TemperatureHandler_12
   \      0x118   0x.... 0x....      BL       _ZN11Temperature20set_current_temp_rawEv
   2179          
   2180              // Filament Sensor - can be read any time since IIR filtering is used
   2181              #if ENABLED(FILAMENT_WIDTH_SENSOR)
   2182                current_raw_filwidth = raw_filwidth_value >> 10;  // Divide to get to 0-16384 range since we used 1/128 IIR filter approach
   2183              #endif
   2184          
   2185              ZERO(raw_temp_value);
   \                     ??TemperatureHandler_12: (+1)
   \      0x11C   0x2200             MOVS     R2,#+0
   \      0x11E   0x2102             MOVS     R1,#+2
   \      0x120   0xF104 0x000C      ADD      R0,R4,#+12
   \      0x124   0x.... 0x....      BL       __aeabi_memset4
   2186              raw_temp_bed_value = 0;
   \      0x128   0x2000             MOVS     R0,#+0
   \      0x12A   0x81E0             STRH     R0,[R4, #+14]
   2187          
   2188              #define TEMPDIR(N) ((HEATER_##N##_RAW_LO_TEMP) > (HEATER_##N##_RAW_HI_TEMP) ? -1 : 1)
   2189          
   2190              int constexpr temp_dir[] = {
   2191                #if ENABLED(HEATER_0_USES_MAX6675)
   2192                   0
   2193                #else
   2194                  TEMPDIR(0)
   2195                #endif
   2196                #if HOTENDS > 1
   2197                  , TEMPDIR(1)
   2198                  #if HOTENDS > 2
   2199                    , TEMPDIR(2)
   2200                    #if HOTENDS > 3
   2201                      , TEMPDIR(3)
   2202                      #if HOTENDS > 4
   2203                        , TEMPDIR(4)
   2204                      #endif // HOTENDS > 4
   2205                    #endif // HOTENDS > 3
   2206                  #endif // HOTENDS > 2
   2207                #endif // HOTENDS > 1
   2208              };
   2209          
   2210              for (uint8_t e = 0; e < COUNT(temp_dir); e++) {
   \      0x12C   0xE018             B.N      ??TemperatureHandler_13
   2211                const int16_t tdir = temp_dir[e], rawtemp = current_temperature_raw[e] * tdir;
   \                     ??TemperatureHandler_14: (+1)
   \      0x12E   0x6A66             LDR      R6,[R4, #+36]
   \      0x130   0x4276             RSBS     R6,R6,#+0
   \      0x132   0xB236             SXTH     R6,R6
   2212                if (rawtemp > maxttemp_raw[e] * tdir && target_temperature[e] > 0) max_temp_error(e);
   \      0x134   0xF9B4 0x0012      LDRSH    R0,[R4, #+18]
   \      0x138   0x4240             RSBS     R0,R0,#+0
   \      0x13A   0x42B0             CMP      R0,R6
   \      0x13C   0xDA05             BGE.N    ??TemperatureHandler_15
   \      0x13E   0x6AA0             LDR      R0,[R4, #+40]
   \      0x140   0x2800             CMP      R0,#+0
   \      0x142   0xDD02             BLE.N    ??TemperatureHandler_15
   \      0x144   0x2000             MOVS     R0,#+0
   \      0x146   0x.... 0x....      BL       _ZN11Temperature14max_temp_errorEa
   2213                if (rawtemp < minttemp_raw[e] * tdir && !is_preheating(e) && target_temperature[e] > 0) {
   \                     ??TemperatureHandler_15: (+1)
   \      0x14A   0xF9B4 0x0010      LDRSH    R0,[R4, #+16]
   \      0x14E   0x42C6             CMN      R6,R0
   \      0x150   0xDA05             BGE.N    ??TemperatureHandler_16
   \      0x152   0x6AA0             LDR      R0,[R4, #+40]
   \      0x154   0x2800             CMP      R0,#+0
   \      0x156   0xDD02             BLE.N    ??TemperatureHandler_16
   2214                  #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
   2215                    if (++consecutive_low_temperature_error[e] >= MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED)
   2216                  #endif
   2217                      min_temp_error(e);
   \      0x158   0x2000             MOVS     R0,#+0
   \      0x15A   0x.... 0x....      BL       _ZN11Temperature14min_temp_errorEa
   2218                }
   2219                #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
   2220                  else
   2221                    consecutive_low_temperature_error[e] = 0;
   2222                #endif
   2223              }
   \                     ??TemperatureHandler_16: (+1)
   \      0x15E   0x2001             MOVS     R0,#+1
   \                     ??TemperatureHandler_13: (+1)
   \      0x160   0x2800             CMP      R0,#+0
   \      0x162   0xD0E4             BEQ.N    ??TemperatureHandler_14
   2224          
   2225          	/*--mks cfg begin-- HAS_TEMP_BED */
   2226          /*	
   2227              #if HAS_TEMP_BED
   2228                #if HEATER_BED_RAW_LO_TEMP > HEATER_BED_RAW_HI_TEMP
   2229                  #define GEBED <=
   2230                #else
   2231                  #define GEBED >=
   2232                #endif
   2233                if (current_temperature_bed_raw GEBED bed_maxttemp_raw && target_temperature_bed > 0) max_temp_error(-1);
   2234                if (bed_minttemp_raw GEBED current_temperature_bed_raw && target_temperature_bed > 0) min_temp_error(-1);
   2235              #endif
   2236          */
   2237          	#if HEATER_BED_RAW_LO_TEMP > HEATER_BED_RAW_HI_TEMP
   2238            		#define GEBED <=
   2239          	#else
   2240          	  #define GEBED >=
   2241          	#endif
   2242          	if (current_temperature_bed_raw GEBED bed_maxttemp_raw && target_temperature_bed > 0) max_temp_error(-1);
   \      0x164   0xF9B4 0x001A      LDRSH    R0,[R4, #+26]
   \      0x168   0x6AE1             LDR      R1,[R4, #+44]
   \      0x16A   0x4288             CMP      R0,R1
   \      0x16C   0xDB06             BLT.N    ??TemperatureHandler_17
   \      0x16E   0x6B20             LDR      R0,[R4, #+48]
   \      0x170   0x2800             CMP      R0,#+0
   \      0x172   0xDD03             BLE.N    ??TemperatureHandler_17
   \      0x174   0xF04F 0x30FF      MOV      R0,#-1
   \      0x178   0x.... 0x....      BL       _ZN11Temperature14max_temp_errorEa
   2243          	if (bed_minttemp_raw GEBED current_temperature_bed_raw && target_temperature_bed > 0) min_temp_error(-1);
   \                     ??TemperatureHandler_17: (+1)
   \      0x17C   0x6AE0             LDR      R0,[R4, #+44]
   \      0x17E   0xF9B4 0x1018      LDRSH    R1,[R4, #+24]
   \      0x182   0x4288             CMP      R0,R1
   \      0x184   0xDB06             BLT.N    ??TemperatureHandler_11
   \      0x186   0x6B20             LDR      R0,[R4, #+48]
   \      0x188   0x2800             CMP      R0,#+0
   \      0x18A   0xDD03             BLE.N    ??TemperatureHandler_11
   \      0x18C   0xF04F 0x30FF      MOV      R0,#-1
   \      0x190   0x.... 0x....      BL       _ZN11Temperature14min_temp_errorEa
   2244          
   2245          	
   2246          	/*--mks cfg end-- HAS_TEMP_BED */
   2247          
   2248            } // temp_count >= OVERSAMPLENR
   2249          
   2250            // Go to the next state, up to SensorsReady
   2251            adc_sensor_state = (ADCSensorState)((int(adc_sensor_state) + 1) % int(StartupDelay));
   \                     ??TemperatureHandler_11: (+1)
   \      0x194   0xF994 0x0006      LDRSB    R0,[R4, #+6]
   \      0x198   0x1C40             ADDS     R0,R0,#+1
   \      0x19A   0x2105             MOVS     R1,#+5
   \      0x19C   0xFB90 0xF1F1      SDIV     R1,R0,R1
   \      0x1A0   0xEB01 0x0181      ADD      R1,R1,R1, LSL #+2
   \      0x1A4   0x1A40             SUBS     R0,R0,R1
   \      0x1A6   0x71A0             STRB     R0,[R4, #+6]
   2252          
   2253            #if ENABLED(BABYSTEPPING)
   2254              LOOP_XYZ(axis) {
   2255                int curTodo = babystepsTodo[axis]; //get rid of volatile for performance
   2256          
   2257                if (curTodo > 0) {
   2258                  stepper.babystep((AxisEnum)axis,/*fwd*/true);
   2259                  babystepsTodo[axis]--; //fewer to do next time
   2260                }
   2261                else if (curTodo < 0) {
   2262                  stepper.babystep((AxisEnum)axis,/*fwd*/false);
   2263                  babystepsTodo[axis]++; //fewer to do next time
   2264                }
   2265              }
   2266            #endif //BABYSTEPPING
   2267          
   2268            #if ENABLED(PINS_DEBUGGING)
   2269              extern bool endstop_monitor_flag;
   2270              // run the endstop monitor at 15Hz
   2271              static uint8_t endstop_monitor_count = 16;  // offset this check from the others
   2272              if (endstop_monitor_flag) {
   2273                endstop_monitor_count += _BV(1);  //  15 Hz
   2274                endstop_monitor_count &= 0x7F;
   2275                if (!endstop_monitor_count) endstop_monitor();  // report changes in endstop status
   2276              }
   2277            #endif
   2278          
   2279            #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
   2280          
   2281              extern volatile uint8_t e_hit;
   2282          
   2283              if (e_hit && ENDSTOPS_ENABLED) {
   2284                endstops.update();  // call endstop update routine
   2285                e_hit--;
   2286              }
   2287            #endif
   2288          
   2289            //cli();				/*--mks--*/
   2290            in_temp_isr = false;
   \      0x1A8   0x2000             MOVS     R0,#+0
   \      0x1AA   0x7120             STRB     R0,[R4, #+4]
   2291            //SBI(TIMSK0, OCIE0B); //re-enable Temperature ISR
   2292            HAL_TIM_Base_Start_IT(&htim4);
   \      0x1AC   0x4628             MOV      R0,R5
   \      0x1AE   0xE8BD 0x4070      POP      {R4-R6,LR}
   \      0x1B2   0x.... 0x....      B.W      HAL_TIM_Base_Start_IT
   \                     ??TemperatureHandler_0: (+1)
   \      0x1B6   0xBD70             POP      {R4-R6,PC}       ;; return
   2293          }

   \                                 In section .data, align 4
   \                     _ZN11Temperature12soft_pwm_bedE:
   \        0x0   0x00               DC8 0
   \                     _ZN11Temperature15temp_meas_readyE:
   \        0x1   0x00               DC8 0
   \                     _ZN11Temperature9pid_resetE:
   \        0x2   0x00               DC8 0
   \                     _ZN11Temperature8soft_pwmE:
   \        0x3   0x00               DC8 0
   \                     _ZN11Temperature11in_temp_isrE:
   \        0x4   0x00               DC8 0
   \        0x5   0xFF               DC8 -1
   \        0x6   0x05               DC8 5
   \        0x7   0x01               DC8 1
   \        0x8   0x00               DC8 0
   \        0x9   0x00               DC8 0
   \        0xA   0x00               DC8 0
   \        0xB   0x00               DC8 0
   \                     _ZN11Temperature14raw_temp_valueE:
   \        0xC   0x0000             DC16 0
   \                     _ZN11Temperature18raw_temp_bed_valueE:
   \        0xE   0x0000             DC16 0
   \                     _ZN11Temperature12minttemp_rawE:
   \       0x10   0x3FFF             DC16 16383
   \                     _ZN11Temperature12maxttemp_rawE:
   \       0x12   0x0000             DC16 0
   \                     _ZN11Temperature8minttempE:
   \       0x14   0x0000             DC16 0
   \                     _ZN11Temperature8maxttempE:
   \       0x16   0x3FFF             DC16 16383
   \                     _ZN11Temperature16bed_minttemp_rawE:
   \       0x18   0x3FFF             DC16 16383
   \                     _ZN11Temperature16bed_maxttemp_rawE:
   \       0x1A   0x0000             DC16 0
   \                     _ZN11Temperature19current_temperatureE:
   \       0x1C   0x0000'0000        DC32 0H
   \                     _ZN11Temperature23current_temperature_bedE:
   \       0x20   0x0000'0000        DC32 0H
   \                     _ZN11Temperature23current_temperature_rawE:
   \       0x24   0x0000'0000        DC32 0
   \                     _ZN11Temperature18target_temperatureE:
   \       0x28   0x0000'0000        DC32 0
   \                     _ZN11Temperature27current_temperature_bed_rawE:
   \       0x2C   0x0000'0000        DC32 0
   \                     _ZN11Temperature22target_temperature_bedE:
   \       0x30   0x0000'0000        DC32 0
   \                     _ZN11Temperature2KpE:
   \       0x34   0x41B1'999A        DC32 41B1999AH
   \                     _ZN11Temperature2KiE:
   \       0x38   0x3E35'31A6        DC32 3E3531A6H
   \                     _ZN11Temperature2KdE:
   \       0x3C   0x442D'F340        DC32 442DF340H
   \                     _ZN11Temperature5bedKpE:
   \       0x40   0x4120'0000        DC32 41200000H
   \                     _ZN11Temperature5bedKiE:
   \       0x44   0x3B76'F5EB        DC32 3B76F5EBH
   \                     _ZN11Temperature5bedKdE:
   \       0x48   0x44E9'0070        DC32 44E90070H
   \                     _ZN11Temperature17watch_target_tempE:
   \       0x4C   0x0000'0000        DC32 0
   \                     _ZN11Temperature20watch_heater_next_msE:
   \       0x50   0x0000'0000        DC32 0
   \                     _ZN11Temperature21watch_target_bed_tempE:
   \       0x54   0x0000'0000        DC32 0
   \                     _ZN11Temperature17watch_bed_next_msE:
   \       0x58   0x0000'0000        DC32 0
   \                     _ZN11Temperature11temp_iStateE:
   \       0x5C   0x0000'0000        DC32 0H
   \                     _ZN11Temperature11temp_dStateE:
   \       0x60   0x0000'0000        DC32 0H
   \                     _ZN11Temperature5pTermE:
   \       0x64   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN11Temperature5iTermE:
   \       0x68   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN11Temperature5dTermE:
   \       0x6C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN11Temperature9pid_errorE:
   \       0x70   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN11Temperature17next_bed_check_msE:
   \       0x74   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN11Temperature29thermal_runaway_state_machineE:
   \       0x78   0x00               DC8 0
   \                     _ZN11Temperature33thermal_runaway_bed_state_machineE:
   \       0x79   0x00               DC8 0
   \       0x7A   0x00 0x00          DC8 0, 0
   \                     _ZN11Temperature21thermal_runaway_timerE:
   \       0x7C   0x0000'0000        DC32 0
   \                     _ZN11Temperature25thermal_runaway_bed_timerE:
   \       0x80   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_18:
   \        0x0   0x62 0x65          DC8 "bed"
   \              0x64 0x00    

   \                                 In section .rodata, align 1, keep-with-next
   \                     ?_19:
   \        0x0   0x00               DC8 ""

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_21:
   \        0x0   0x4B 0x70          DC8 "Kp "
   \              0x20 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_22:
   \        0x0   0x4B 0x69          DC8 "Ki "
   \              0x20 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_23:
   \        0x0   0x4B 0x64          DC8 "Kd "
   \              0x20 0x00    

   \                                 In section .text, align 2, keep-with-next
   \   static __intrinsic __interwork __softfp void __sti__routine()
   \                     __sti__routine: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable46
   \        0x4   0x6AC0             LDR      R0,[R0, #+44]
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable47
   \        0xA   0x6008             STR      R0,[R1, #+0]
   \        0xC   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42:
   \        0x0   0x62 0x65          DC8      "bed"
   \              0x64 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_1:
   \        0x0   0x00 0x00          DC8      "",0x0,0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_2:
   \        0x0   0x4B 0x70          DC8      "Kp "
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_3:
   \        0x0   0x4B 0x69          DC8      "Ki "
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_4:
   \        0x0   0x4B 0x64          DC8      "Kd "
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \        0x0   0x50 0x49          DC8 "PID Autotune failed! Bad extruder number"
   \              0x44 0x20    
   \              0x41 0x75    
   \              0x74 0x6F    
   \              0x74 0x75    
   \              0x6E 0x65    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x21    
   \              0x20 0x42    
   \              0x61 0x64    
   \              0x20 0x65    
   \              0x78 0x74    
   \              0x72 0x75    
   \              0x64 0x65    
   \              0x72 0x20    
   \              0x6E 0x75    
   \              0x6D 0x62    
   \              0x65 0x72    
   \              0x00         
   \       0x29   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \        0x0   0x50 0x49          DC8 "PID Autotune start"
   \              0x44 0x20    
   \              0x41 0x75    
   \              0x74 0x6F    
   \              0x74 0x75    
   \              0x6E 0x65    
   \              0x20 0x73    
   \              0x74 0x61    
   \              0x72 0x74    
   \              0x00         
   \       0x13   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \        0x0   0x20 0x62          DC8 " bias: "
   \              0x69 0x61    
   \              0x73 0x3A    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_6:
   \        0x0   0x20 0x64          DC8 " d: "
   \              0x3A 0x20    
   \              0x00         
   \        0x5   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_7:
   \        0x0   0x20 0x6D          DC8 " min: "
   \              0x69 0x6E    
   \              0x3A 0x20    
   \              0x00         
   \        0x7   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_8:
   \        0x0   0x20 0x6D          DC8 " max: "
   \              0x61 0x78    
   \              0x3A 0x20    
   \              0x00         
   \        0x7   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_9:
   \        0x0   0x20 0x4B          DC8 " Ku: "
   \              0x75 0x3A    
   \              0x20 0x00    
   \        0x6   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_10:
   \        0x0   0x20 0x54          DC8 " Tu: "
   \              0x75 0x3A    
   \              0x20 0x00    
   \        0x6   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_11:
   \        0x0   0x0A 0x20          DC8 "\012 Classic PID \012"
   \              0x43 0x6C    
   \              0x61 0x73    
   \              0x73 0x69    
   \              0x63 0x20    
   \              0x50 0x49    
   \              0x44 0x20    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_12:
   \        0x0   0x20 0x4B          DC8 " Kp: "
   \              0x70 0x3A    
   \              0x20 0x00    
   \        0x6   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_13:
   \        0x0   0x20 0x4B          DC8 " Ki: "
   \              0x69 0x3A    
   \              0x20 0x00    
   \        0x6   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_14:
   \        0x0   0x20 0x4B          DC8 " Kd: "
   \              0x64 0x3A    
   \              0x20 0x00    
   \        0x6   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_15:
   \        0x0   0x50 0x49          DC8 "PID Autotune failed! Temperature too high\012"
   \              0x44 0x20    
   \              0x41 0x75    
   \              0x74 0x6F    
   \              0x74 0x75    
   \              0x6E 0x65    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x21    
   \              0x20 0x54    
   \              0x65 0x6D    
   \              0x70 0x65    
   \              0x72 0x61    
   \              0x74 0x75    
   \              0x72 0x65    
   \              0x20 0x74    
   \              0x6F 0x6F    
   \              0x20 0x68    
   \              0x69 0x67    
   \              0x68 0x0A    
   \              0x00         
   \       0x2B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_16:
   \        0x0   0x50 0x49          DC8 "PID Autotune failed! timeout\012"
   \              0x44 0x20    
   \              0x41 0x75    
   \              0x74 0x6F    
   \              0x74 0x75    
   \              0x6E 0x65    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x21    
   \              0x20 0x74    
   \              0x69 0x6D    
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x0A 0x00    
   \       0x1E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_17:
   \        0x0   0x50 0x49          DC8 50H, 49H, 44H, 20H, 41H, 75H, 74H, 6FH
   \              0x44 0x20    
   \              0x41 0x75    
   \              0x74 0x6F    
   \        0x8   0x74 0x75          DC8 74H, 75H, 6EH, 65H, 20H, 66H, 69H, 6EH
   \              0x6E 0x65    
   \              0x20 0x66    
   \              0x69 0x6E    
   \       0x10   0x69 0x73          DC8 69H, 73H, 68H, 65H, 64H, 21H, 20H, 50H
   \              0x68 0x65    
   \              0x64 0x21    
   \              0x20 0x50    
   \       0x18   0x75 0x74          DC8 75H, 74H, 20H, 74H, 68H, 65H, 20H, 6CH
   \              0x20 0x74    
   \              0x68 0x65    
   \              0x20 0x6C    
   \       0x20   0x61 0x73          DC8 61H, 73H, 74H, 20H, 4BH, 70H, 2CH, 20H
   \              0x74 0x20    
   \              0x4B 0x70    
   \              0x2C 0x20    
   \       0x28   0x4B 0x69          DC8 4BH, 69H, 20H, 61H, 6EH, 64H, 20H, 4BH
   \              0x20 0x61    
   \              0x6E 0x64    
   \              0x20 0x4B    
   \       0x30   0x64 0x20          DC8 64H, 20H, 63H, 6FH, 6EH, 73H, 74H, 61H
   \              0x63 0x6F    
   \              0x6E 0x73    
   \              0x74 0x61    
   \       0x38   0x6E 0x74          DC8 6EH, 74H, 73H, 20H, 66H, 72H, 6FH, 6DH
   \              0x73 0x20    
   \              0x66 0x72    
   \              0x6F 0x6D    
   \       0x40   0x20 0x62          DC8 20H, 62H, 65H, 6CH, 6FH, 77H, 20H, 69H
   \              0x65 0x6C    
   \              0x6F 0x77    
   \              0x20 0x69    
   \       0x48   0x6E 0x74          DC8 6EH, 74H, 6FH, 20H, 43H, 6FH, 6EH, 66H
   \              0x6F 0x20    
   \              0x43 0x6F    
   \              0x6E 0x66    
   \       0x50   0x69 0x67          DC8 69H, 67H, 75H, 72H, 61H, 74H, 69H, 6FH
   \              0x75 0x72    
   \              0x61 0x74    
   \              0x69 0x6F    
   \       0x58   0x6E 0x2E          DC8 6EH, 2EH, 68H, 0AH, 0
   \              0x68 0x0A    
   \              0x00         
   \       0x5D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_20:
   \        0x0   0x23 0x64          DC8 "#define  DEFAULT_"
   \              0x65 0x66    
   \              0x69 0x6E    
   \              0x65 0x20    
   \              0x20 0x44    
   \              0x45 0x46    
   \              0x41 0x55    
   \              0x4C 0x54    
   \              0x5F 0x00    
   \       0x12   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_24:
   \        0x0   0x23 0x64          DC8 "#define  DEFAULT_Kp "
   \              0x65 0x66    
   \              0x69 0x6E    
   \              0x65 0x20    
   \              0x20 0x44    
   \              0x45 0x46    
   \              0x41 0x55    
   \              0x4C 0x54    
   \              0x5F 0x4B    
   \              0x70 0x20    
   \              0x00         
   \       0x15   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_25:
   \        0x0   0x23 0x64          DC8 "#define  DEFAULT_Ki "
   \              0x65 0x66    
   \              0x69 0x6E    
   \              0x65 0x20    
   \              0x20 0x44    
   \              0x45 0x46    
   \              0x41 0x55    
   \              0x4C 0x54    
   \              0x5F 0x4B    
   \              0x69 0x20    
   \              0x00         
   \       0x15   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_26:
   \        0x0   0x23 0x64          DC8 "#define  DEFAULT_Kd "
   \              0x65 0x66    
   \              0x69 0x6E    
   \              0x65 0x20    
   \              0x20 0x44    
   \              0x45 0x46    
   \              0x41 0x55    
   \              0x4C 0x54    
   \              0x5F 0x4B    
   \              0x64 0x20    
   \              0x00         
   \       0x15   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_27:
   \        0x0   0x23 0x64          DC8 "#define  DEFAULT_bedKp "
   \              0x65 0x66    
   \              0x69 0x6E    
   \              0x65 0x20    
   \              0x20 0x44    
   \              0x45 0x46    
   \              0x41 0x55    
   \              0x4C 0x54    
   \              0x5F 0x62    
   \              0x65 0x64    
   \              0x4B 0x70    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_28:
   \        0x0   0x23 0x64          DC8 "#define  DEFAULT_bedKi "
   \              0x65 0x66    
   \              0x69 0x6E    
   \              0x65 0x20    
   \              0x20 0x44    
   \              0x45 0x46    
   \              0x41 0x55    
   \              0x4C 0x54    
   \              0x5F 0x62    
   \              0x65 0x64    
   \              0x4B 0x69    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_29:
   \        0x0   0x23 0x64          DC8 "#define  DEFAULT_bedKd "
   \              0x65 0x66    
   \              0x69 0x6E    
   \              0x65 0x20    
   \              0x20 0x44    
   \              0x45 0x46    
   \              0x41 0x55    
   \              0x4C 0x54    
   \              0x5F 0x62    
   \              0x65 0x64    
   \              0x4B 0x64    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_30:
   \        0x0   0x2C 0x20          DC8 ", system stopped! Heater_ID: "
   \              0x73 0x79    
   \              0x73 0x74    
   \              0x65 0x6D    
   \              0x20 0x73    
   \              0x74 0x6F    
   \              0x70 0x70    
   \              0x65 0x64    
   \              0x21 0x20    
   \              0x48 0x65    
   \              0x61 0x74    
   \              0x65 0x72    
   \              0x5F 0x49    
   \              0x44 0x3A    
   \              0x20 0x00    
   \       0x1E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_31:
   \        0x0   0x62 0x65          DC8 "bed\012"
   \              0x64 0x0A    
   \              0x00         
   \        0x5   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_37:
   \        0x0   0x45 0x72          DC8 "Err: MAXTEMP BED"
   \              0x72 0x3A    
   \              0x20 0x4D    
   \              0x41 0x58    
   \              0x54 0x45    
   \              0x4D 0x50    
   \              0x20 0x42    
   \              0x45 0x44    
   \              0x00         
   \       0x11   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_36:
   \        0x0   0x45 0x72          DC8 "Err: MAXTEMP"
   \              0x72 0x3A    
   \              0x20 0x4D    
   \              0x41 0x58    
   \              0x54 0x45    
   \              0x4D 0x50    
   \              0x00         
   \        0xD   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_35:
   \        0x0   0x4D 0x41          DC8 "MAXTEMP triggered"
   \              0x58 0x54    
   \              0x45 0x4D    
   \              0x50 0x20    
   \              0x74 0x72    
   \              0x69 0x67    
   \              0x67 0x65    
   \              0x72 0x65    
   \              0x64 0x00    
   \       0x12   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46:
   \        0x0   0x....'....        DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ?_34:
   \        0x0   0x45 0x72          DC8 "Err: MINTEMP BED"
   \              0x72 0x3A    
   \              0x20 0x4D    
   \              0x49 0x4E    
   \              0x54 0x45    
   \              0x4D 0x50    
   \              0x20 0x42    
   \              0x45 0x44    
   \              0x00         
   \       0x11   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_33:
   \        0x0   0x45 0x72          DC8 "Err: MINTEMP"
   \              0x72 0x3A    
   \              0x20 0x4D    
   \              0x49 0x4E    
   \              0x54 0x45    
   \              0x4D 0x50    
   \              0x00         
   \        0xD   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_32:
   \        0x0   0x4D 0x49          DC8 "MINTEMP triggered"
   \              0x4E 0x54    
   \              0x45 0x4D    
   \              0x50 0x20    
   \              0x74 0x72    
   \              0x69 0x67    
   \              0x67 0x65    
   \              0x72 0x65    
   \              0x64 0x00    
   \       0x12   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable47:
   \        0x0   0x....'....        DC32     _ZN11Temperature16extrude_min_tempE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable47_1:
   \        0x0   0x461C'4000        DC32     0x461c4000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable47_2:
   \        0x0   0x....'....        DC32     mksCfg+0x34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable47_3:
   \        0x0   0x....'....        DC32     from_wifi_flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable47_4:
   \        0x0   0x....'....        DC32     customizedSerial

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable47_5:
   \        0x0   0x....'....        DC32     serial2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48:
   \        0x0   0x....'....        DC32     _ZN11Temperature12soft_pwm_bedE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_1:
   \        0x0   0x....'....        DC32     wait_for_heatup

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_2:
   \        0x0   0x0012'4F81        DC32     0x124f81

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable49:
   \        0x0   0xFFFF'EC78        DC32     0xffffec78

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable49_1:
   \        0x0   0x4010'0000        DC32     0x40100000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50:
   \        0x0   0x5444'2D18        DC32     0x54442d18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_1:
   \        0x0   0x4009'21FB        DC32     0x400921fb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_2:
   \        0x0   0x3FE0'0000        DC32     0x3fe00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_3:
   \        0x0   0xD2F1'A9FC        DC32     0xd2f1a9fc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_4:
   \        0x0   0x3F50'624D        DC32     0x3f50624d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_5:
   \        0x0   0x3FE3'3333        DC32     0x3fe33333

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable52:
   \        0x0   0x41A0'0000        DC32     0x41a00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable56:
   \        0x0   0x88E3'68F1        DC32     0x88e368f1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable58:
   \        0x0   0x3FC4'F8B5        DC32     0x3fc4f8b5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable58_1:
   \        0x0   0x....'....        DC32     errormagic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable58_2:
   \        0x0   0x....'....        DC32     `Temperature::_temp_error(int, char const *, char const *)::killed`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59:
   \        0x0   0x....'....        DC32     _ZN11Temperature12soft_pwm_bedE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_1:
   \        0x0   0x....'....        DC32     Running

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_2:
   \        0x0   0x....'....        DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_3:
   \        0x0   0x9999'99A0        DC32     0x999999a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_4:
   \        0x0   0x3FA9'9999        DC32     0x3fa99999

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_5:
   \        0x0   0x3FEE'6666        DC32     0x3fee6666

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_6:
   \        0x0   0x4120'0001        DC32     0x41200001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_7:
   \        0x0   0x437F'0000        DC32     0x437f0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_8:
   \        0x0   0xC120'0000        DC32     0xc1200000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_9:
   \        0x0   0x437F'0001        DC32     0x437f0001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_10:
   \        0x0   0x....'....        DC32     _ZN11Temperature15temp_iState_bedE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_11:
   \        0x0   0x....'....        DC32     MSG_HEATING_FAILED_LCD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_12:
   \        0x0   0xC0A0'0000        DC32     0xc0a00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_13:
   \        0x0   0x....'....        DC32     mksTmp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_14:
   \        0x0   0x....'....        DC32     gArrayGpioPin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_15:
   \        0x0   0x....'....        DC32     gArrayGpioPort

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_16:
   \        0x0   0x....'....        DC32     from_wifi_flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_17:
   \        0x0   0x....'....        DC32     customizedSerial

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_18:
   \        0x0   0x....'....        DC32     serial2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_19:
   \        0x0   0x....'....        DC32     heater_ttbllen_map

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_20:
   \        0x0   0x3F9F'4000        DC32     0x3f9f4000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_21:
   \        0x0   0xC1C8'0000        DC32     0xc1c80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_22:
   \        0x0   0x....'....        DC32     mksCfg+0xE4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_23:
   \        0x0   0x....'....        DC32     mksCfg+0xEC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_24:
   \        0x0   0x....'....        DC32     `Temperature::thermal_runaway_protection(Temperature::TRState *, millis_t *, float, float, int, int, int)::tr_target_temperature`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_25:
   \        0x0   0x....'....        DC32     MSG_THERMAL_RUNAWAY

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_26:
   \        0x0   0x....'....        DC32     _ZN7Planner16autotemp_enabledE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_27:
   \        0x0   0x....'....        DC32     print_job_timer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_28:
   \        0x0   0x....'....        DC32     htim4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_29:
   \        0x0   0x....'....        DC32     uhADCxConvertedValue

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \        0x0   0x20 0x2D          DC8 " - Invalid extruder number !\012"
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x65    
   \              0x78 0x74    
   \              0x72 0x75    
   \              0x64 0x65    
   \              0x72 0x20    
   \              0x6E 0x75    
   \              0x6D 0x62    
   \              0x65 0x72    
   \              0x20 0x21    
   \              0x0A 0x00    
   \       0x1E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \        0x0   0x4B 0x49          DC8 "KILLED. "
   \              0x4C 0x4C    
   \              0x45 0x44    
   \              0x2E 0x20    
   \              0x00         
   \        0x9   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \        0x0   0x48 0x65          DC8 "Heating failed"
   \              0x61 0x74    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x66 0x61    
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x00         
   \        0xF   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_38:
   \        0x0   0x54 0x68          DC8 "Thermal Runaway"
   \              0x65 0x72    
   \              0x6D 0x61    
   \              0x6C 0x20    
   \              0x52 0x75    
   \              0x6E 0x61    
   \              0x77 0x61    
   \              0x79 0x00    

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   IsRunning()
       0   IsrTemperatureHandler
         0   -> Temperature::TemperatureHandler()
      16   MarlinSerial::print(char const *)
         0   -> MarlinSerial::write(char const *)
         0   -> package_to_wifi
        16   -> strlen
      16   MarlinSerial::write(char const *)
         0   -> BSP_UartIfQueueTxData
        16   -> strlen
       8   MarlinSerial::write(uint8_t)
         8   -> BSP_UartIfQueueTxData
     104   Temperature::PID_autotune(float, int, int, bool)
       104   -> HAL_GetTick
       104   -> MarlinSerial::print(char const *)
         0   -> MarlinSerial::print(char, int)
       104   -> MarlinSerial::print(char, int)
         0   -> MarlinSerial::write(uint8_t)
       104   -> MarlinSerial::write(uint8_t)
         0   -> Temperature::disable_all_heaters()
       104   -> Temperature::disable_all_heaters()
         0   -> Temperature::updatePID()
       104   -> Temperature::updateTemperaturesFromRawValues()
       104   -> __aeabi_d2f
       104   -> __aeabi_ddiv
       104   -> __aeabi_dmul
       104   -> __aeabi_f2d
       104   -> __aeabi_fadd
       104   -> __aeabi_fdiv
       104   -> __aeabi_fmul
       104   -> __aeabi_fsub
       104   -> __aeabi_i2d
       104   -> __aeabi_i2f
       104   -> lcd_update()
       104   -> print_heaterstates()
       104   -> serial_echopair_P(char const *, char const *)
       104   -> serial_echopair_P(char const *, float)
       104   -> serial_echopair_P(char const *, long)
         0   -> serialprintPGM(char const *)
       104   -> serialprintPGM(char const *)
       104 __aeabi_cfcmple
       0   Temperature::Temperature()
      16   Temperature::TemperatureHandler()
        16   -> HAL_GPIO_WritePin
         0   -> HAL_TIM_Base_Start_IT
        16   -> HAL_TIM_Base_Stop_IT
        16   -> Temperature::max_temp_error(int8_t)
        16   -> Temperature::min_temp_error(int8_t)
        16   -> Temperature::set_current_temp_raw()
        16   -> __aeabi_memset4
        16   -> lcd_buttons_update()
      16   Temperature::_temp_error(int, char const *, char const *)
        16   -> IsRunning()
        16   -> MarlinSerial::print(char, int)
        16   -> MarlinSerial::print(int, int)
        16   -> MarlinSerial::write(uint8_t)
         0   -> Temperature::disable_all_heaters()
         0   -> kill(char const *)
        16   -> serialprintPGM(char const *)
      40   Temperature::analog2temp(int, uint8_t)
        40   -> MarlinSerial::print(int, int)
         0   -> __aeabi_d2f
        40   -> __aeabi_dmul
        40   -> __aeabi_fadd
        40   -> __aeabi_fdiv
        40   -> __aeabi_fmul
        40   -> __aeabi_i2d
        40   -> __aeabi_i2f
        40   -> kill(char const *)
        40   -> serialprintPGM(char const *)
      32   Temperature::analog2tempBed(int)
        32   -> __aeabi_fadd
        32   -> __aeabi_fdiv
        32   -> __aeabi_fmul
        32   -> __aeabi_i2f
       0   Temperature::degBed()
       0   Temperature::degHotend(uint8_t)
       0   Temperature::degTargetBed()
         0   -> __aeabi_i2f
       0   Temperature::degTargetHotend(uint8_t)
         0   -> __aeabi_i2f
      16   Temperature::disable_all_heaters()
         0   -> HAL_GPIO_WritePin
        16   -> HAL_GPIO_WritePin
        16   -> Stopwatch::stop()
        16   -> Temperature::setTargetBed(float)
        16   -> Temperature::setTargetHotend(float, uint8_t)
       0   Temperature::getHeaterPower(int)
      32   Temperature::get_pid_output(int)
        32   -> __aeabi_d2f
        32   -> __aeabi_dadd
        32   -> __aeabi_dmul
        32   -> __aeabi_f2d
        32   -> __aeabi_fadd
        32   -> __aeabi_fmul
        32   -> __aeabi_fsub
        32   -> __aeabi_i2f
        32 __aeabi_cfcmple
        32 __aeabi_cfrcmple
      40   Temperature::get_pid_output_bed()
        40   -> __aeabi_d2f
        40   -> __aeabi_dadd
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_fadd
        40   -> __aeabi_fmul
        40   -> __aeabi_fsub
        40   -> __aeabi_i2f
        40 __aeabi_cfcmple
        40 __aeabi_cfrcmple
      24   Temperature::init()
        24   -> Temperature::analog2temp(int, uint8_t)
        24   -> Temperature::analog2tempBed(int)
        24   -> __aeabi_i2f
        24 __aeabi_cfcmple
      48   Temperature::manage_heater()
         0   -> HAL_GPIO_WritePin
        48   -> HAL_GetTick
        48   -> Temperature::_temp_error(int, char const *, char const *)
        48   -> Temperature::degBed()
        48   -> Temperature::degHotend(uint8_t)
        48   -> Temperature::get_pid_output(int)
        48   -> Temperature::get_pid_output_bed()
        48   -> Temperature::start_watching_bed()
        48   -> Temperature::start_watching_heater(uint8_t)
        48   -> Temperature::thermal_runaway_protection(Temperature::TRState *, millis_t *, float, float, int, int, int)
        48   -> Temperature::updateTemperaturesFromRawValues()
        48   -> __aeabi_f2iz
        48   -> __aeabi_i2f
        48 __aeabi_cfcmple
        48 __aeabi_cfrcmple
       0   Temperature::max_temp_error(int8_t)
         0   -> Temperature::_temp_error(int, char const *, char const *)
       0   Temperature::min_temp_error(int8_t)
         0   -> Temperature::_temp_error(int, char const *, char const *)
       8   Temperature::setTargetBed(float)
         0   -> Temperature::start_watching_bed()
         8   -> __aeabi_f2iz
       8   Temperature::setTargetHotend(float, uint8_t)
         0   -> Temperature::start_watching_heater(uint8_t)
         8   -> __aeabi_f2iz
       0   Temperature::set_current_temp_raw()
      24   Temperature::start_watching_bed()
        24   -> HAL_GetTick
        24   -> Temperature::degBed()
        24   -> Temperature::degTargetBed()
        24   -> __aeabi_f2iz
        24   -> __aeabi_fadd
        24   -> __aeabi_fsub
        24   -> __aeabi_i2f
        24   -> __aeabi_ui2f
        24 __aeabi_cfcmple
      24   Temperature::start_watching_heater(uint8_t)
        24   -> HAL_GetTick
        24   -> Temperature::degHotend(uint8_t)
        24   -> Temperature::degTargetHotend(uint8_t)
        24   -> __aeabi_f2iz
        24   -> __aeabi_fadd
        24   -> __aeabi_fsub
        24   -> __aeabi_i2f
        24   -> __aeabi_ui2f
        24 __aeabi_cfcmple
       0   Temperature::subobject Temperature()
         0   -> Temperature::Temperature()
      32   Temperature::thermal_runaway_protection(Temperature::TRState *, millis_t *, float, float, int, int, int)
        32   -> HAL_GetTick
         0   -> Temperature::_temp_error(int, char const *, char const *)
        32   -> __aeabi_fsub
        32   -> __aeabi_i2f
        32 __aeabi_cfcmpeq
        32 __aeabi_cfcmple
        32 __aeabi_cfrcmple
       0   Temperature::updatePID()
      16   Temperature::updateTemperaturesFromRawValues()
        16   -> Temperature::analog2temp(int, uint8_t)
        16   -> Temperature::analog2tempBed(int)
       0   __sti__routine()
       0   serialprintPGM(char const *)
         0   -> MarlinSerial::print(char const *)
         0   -> MarlinSerial::write(char const *)


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable42
       4  ??DataTable42_1
       4  ??DataTable42_2
       4  ??DataTable42_3
       4  ??DataTable42_4
       4  ??DataTable46
       4  ??DataTable47
       4  ??DataTable47_1
       4  ??DataTable47_2
       4  ??DataTable47_3
       4  ??DataTable47_4
       4  ??DataTable47_5
       4  ??DataTable48
       4  ??DataTable48_1
       4  ??DataTable48_2
       4  ??DataTable49
       4  ??DataTable49_1
       4  ??DataTable50
       4  ??DataTable50_1
       4  ??DataTable50_2
       4  ??DataTable50_3
       4  ??DataTable50_4
       4  ??DataTable50_5
       4  ??DataTable52
       4  ??DataTable56
       4  ??DataTable58
       4  ??DataTable58_1
       4  ??DataTable58_2
       4  ??DataTable59
       4  ??DataTable59_1
       4  ??DataTable59_10
       4  ??DataTable59_11
       4  ??DataTable59_12
       4  ??DataTable59_13
       4  ??DataTable59_14
       4  ??DataTable59_15
       4  ??DataTable59_16
       4  ??DataTable59_17
       4  ??DataTable59_18
       4  ??DataTable59_19
       4  ??DataTable59_2
       4  ??DataTable59_20
       4  ??DataTable59_21
       4  ??DataTable59_22
       4  ??DataTable59_23
       4  ??DataTable59_24
       4  ??DataTable59_25
       4  ??DataTable59_26
       4  ??DataTable59_27
       4  ??DataTable59_28
       4  ??DataTable59_29
       4  ??DataTable59_3
       4  ??DataTable59_4
       4  ??DataTable59_5
       4  ??DataTable59_6
       4  ??DataTable59_7
       4  ??DataTable59_8
       4  ??DataTable59_9
      32  ?_0
      12  ?_1
       8  ?_10
      16  ?_11
       8  ?_12
       8  ?_13
       8  ?_14
      44  ?_15
      32  ?_16
      96  ?_17
       4  ?_18
       1  ?_19
      16  ?_2
      20  ?_20
       4  ?_21
       4  ?_22
       4  ?_23
      24  ?_24
      24  ?_25
      24  ?_26
      24  ?_27
      24  ?_28
      24  ?_29
      44  ?_3
      32  ?_30
       8  ?_31
      20  ?_32
      16  ?_33
      20  ?_34
      20  ?_35
      16  ?_36
      20  ?_37
      16  ?_38
      20  ?_4
       8  ?_5
       8  ?_6
       8  ?_7
       8  ?_8
       8  ?_9
      12  IsRunning()
       2  IsrTemperatureHandler
      64  MarlinSerial::print(char const *)
      28  MarlinSerial::write(char const *)
      12  MarlinSerial::write(uint8_t)
    1920  Temperature::PID_autotune(float, int, int, bool)
       2  Temperature::Temperature()
     440  Temperature::TemperatureHandler()
     146  Temperature::_temp_error(int, char const *, char const *)
       1  Temperature::allow_cold_extrude
     242  Temperature::analog2temp(int, uint8_t)
     126  Temperature::analog2tempBed(int)
      12  Temperature::degBed()
      12  Temperature::degHotend(uint8_t)
      12  Temperature::degTargetBed()
      12  Temperature::degTargetHotend(uint8_t)
     122  Temperature::disable_all_heaters()
       4  Temperature::extrude_min_temp
      18  Temperature::getHeaterPower(int)
     318  Temperature::get_pid_output(int)
     246  Temperature::get_pid_output_bed()
     172  Temperature::init()
     522  Temperature::manage_heater()
      38  Temperature::max_temp_error(int8_t)
      38  Temperature::min_temp_error(int8_t)
      24  Temperature::setTargetBed(float)
      24  Temperature::setTargetHotend(float, uint8_t)
      16  Temperature::set_current_temp_raw()
     132  Temperature::soft_pwm_bed
          Temperature::temp_meas_ready
          Temperature::pid_reset
          Temperature::soft_pwm
          Temperature::in_temp_isr
          temp_count
          adc_sensor_state
          pwm_count
          soft_pwm_0
          soft_pwm_BED
          do_buttons
          delay_count
          Temperature::raw_temp_value
          Temperature::raw_temp_bed_value
          Temperature::minttemp_raw
          Temperature::maxttemp_raw
          Temperature::minttemp
          Temperature::maxttemp
          Temperature::bed_minttemp_raw
          Temperature::bed_maxttemp_raw
          Temperature::current_temperature
          Temperature::current_temperature_bed
          Temperature::current_temperature_raw
          Temperature::target_temperature
          Temperature::current_temperature_bed_raw
          Temperature::target_temperature_bed
          Temperature::Kp
          Temperature::Ki
          Temperature::Kd
          Temperature::bedKp
          Temperature::bedKi
          Temperature::bedKd
          Temperature::watch_target_temp
          Temperature::watch_heater_next_ms
          Temperature::watch_target_bed_temp
          Temperature::watch_bed_next_ms
          Temperature::temp_iState
          Temperature::temp_dState
          Temperature::pTerm
          Temperature::iTerm
          Temperature::dTerm
          Temperature::pid_error
          Temperature::next_bed_check_ms
          Temperature::thermal_runaway_state_machine
          Temperature::thermal_runaway_bed_state_machine
          Temperature::thermal_runaway_timer
          Temperature::thermal_runaway_bed_timer
     104  Temperature::start_watching_bed()
     110  Temperature::start_watching_heater(uint8_t)
       4  Temperature::subobject Temperature()
      24  Temperature::temp_iState_bed
          Temperature::temp_dState_bed
          Temperature::pTerm_bed
          Temperature::iTerm_bed
          Temperature::dTerm_bed
          Temperature::pid_error_bed
     172  Temperature::thermal_runaway_protection(Temperature::TRState *, millis_t *, float, float, int, int, int)
       2  Temperature::updatePID()
      54  Temperature::updateTemperaturesFromRawValues()
      14  __sti__routine()
       8  heater_ttbllen_map
          heater_ttbl_map
       1  killed
      36  serialprintPGM(char const *)
     256  temptable_1
       1  thermalManager
       8  tr_target_temperature
       4  -- Other

 
    39 bytes in section .bss
   140 bytes in section .data
     4 bytes in section .init_array
    17 bytes in section .rodata
 6 280 bytes in section .text
 
 6 036 bytes of CODE  memory (+ 248 bytes shared)
    17 bytes of CONST memory
   179 bytes of DATA  memory

Errors: none
Warnings: 7
