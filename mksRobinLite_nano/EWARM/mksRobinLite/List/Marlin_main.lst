###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.1.114/W32 for ARM         07/May/2021  14:21:34
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\Marlin_main.cpp
#    Command line =  
#        -f C:\Users\PLT\AppData\Local\Temp\EWEADF.tmp
#        (C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\Marlin_main.cpp
#        -D USE_HAL_DRIVER -D STM32F103xE -D MKS_ROBIN -D MARLIN -D __arm__ -D
#        USE_MKS_WIFI --preprocess=s
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List -lC
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List -lA
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List
#        --diag_suppress Pa050 -o
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.1\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Inc\ -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Src\ -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/Inc\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/CMSIS/Include\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/STM32MKS-3dPrinter\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/Common\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/l6474\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/MotorControl\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/u8glib_arm_v1.17/src\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/arduino\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/arduino/avr\
#        -I C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Inc/Logo\ -Om --c++
#        --no_exceptions --no_rtti -I "D:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.1\arm\CMSIS\Core\Include\" -I "D:\Program
#        Files (x86)\IAR Systems\Embedded Workbench
#        8.1\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List\Marlin_main.lst
#    Object file  =  
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\Obj\Marlin_main.o
#
###############################################################################

C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\Marlin_main.cpp
      1          /**
      2           * Marlin 3D Printer Firmware
      3           * Copyright (C) 2016, 2017 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
      4           *
      5           * Based on Sprinter and grbl.
      6           * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
      7           *
      8           * This program is free software: you can redistribute it and/or modify
      9           * it under the terms of the GNU General Public License as published by
     10           * the Free Software Foundation, either version 3 of the License, or
     11           * (at your option) any later version.
     12           *
     13           * This program is distributed in the hope that it will be useful,
     14           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     15           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     16           * GNU General Public License for more details.
     17           *
     18           * You should have received a copy of the GNU General Public License
     19           * along with this program.  If not, see <http://www.gnu.org/licenses/>.
     20           *
     21           */
     22          
     23          /**
     24           * About Marlin
     25           *
     26           * This firmware is a mashup between Sprinter and grbl.
     27           *  - https://github.com/kliment/Sprinter
     28           *  - https://github.com/simen/grbl/tree
     29           */
     30          
     31          /**
     32           * -----------------
     33           * G-Codes in Marlin
     34           * -----------------
     35           *
     36           * Helpful G-code references:
     37           *  - http://linuxcnc.org/handbook/gcode/g-code.html
     38           *  - http://objects.reprap.org/wiki/Mendel_User_Manual:_RepRapGCodes
     39           *
     40           * Help to document Marlin's G-codes online:
     41           *  - http://reprap.org/wiki/G-code
     42           *  - https://github.com/MarlinFirmware/MarlinDocumentation
     43           *
     44           * -----------------
     45           *
     46           * "G" Codes
     47           *
     48           * G0  -> G1
     49           * G1  - Coordinated Movement X Y Z E
     50           * G2  - CW ARC
     51           * G3  - CCW ARC
     52           * G4  - Dwell S<seconds> or P<milliseconds>
     53           * G5  - Cubic B-spline with XYZE destination and IJPQ offsets
     54           * G10 - Retract filament according to settings of M207
     55           * G11 - Retract recover filament according to settings of M208
     56           * G12 - Clean tool
     57           * G20 - Set input units to inches
     58           * G21 - Set input units to millimeters
     59           * G28 - Home one or more axes
     60           * G29 - Detailed Z probe, probes the bed at 3 or more points.  Will fail if you haven't homed yet.
     61           * G30 - Single Z probe, probes bed at X Y location (defaults to current XY location)
     62           * G31 - Dock sled (Z_PROBE_SLED only)
     63           * G32 - Undock sled (Z_PROBE_SLED only)
     64           * G33 - Delta Auto-Calibration (Requires DELTA_AUTO_CALIBRATION)
     65           * G38 - Probe target - similar to G28 except it uses the Z_MIN_PROBE for all three axes
     66           * G90 - Use Absolute Coordinates
     67           * G91 - Use Relative Coordinates
     68           * G92 - Set current position to coordinates given
     69           *
     70           * "M" Codes
     71           *
     72           * M0   - Unconditional stop - Wait for user to press a button on the LCD (Only if ULTRA_LCD is enabled)
     73           * M1   - Same as M0
     74           * M17  - Enable/Power all stepper motors
     75           * M18  - Disable all stepper motors; same as M84
     76           * M20  - List SD card. (Requires SDSUPPORT)
     77           * M21  - Init SD card. (Requires SDSUPPORT)
     78           * M22  - Release SD card. (Requires SDSUPPORT)
     79           * M23  - Select SD file: "M23 /path/file.gco". (Requires SDSUPPORT)
     80           * M24  - Start/resume SD print. (Requires SDSUPPORT)
     81           * M25  - Pause SD print. (Requires SDSUPPORT)
     82           * M26  - Set SD position in bytes: "M26 S12345". (Requires SDSUPPORT)
     83           * M27  - Report SD print status. (Requires SDSUPPORT)
     84           * M28  - Start SD write: "M28 /path/file.gco". (Requires SDSUPPORT)
     85           * M29  - Stop SD write. (Requires SDSUPPORT)
     86           * M30  - Delete file from SD: "M30 /path/file.gco"
     87           * M31  - Report time since last M109 or SD card start to serial.
     88           * M32  - Select file and start SD print: "M32 [S<bytepos>] !/path/file.gco#". (Requires SDSUPPORT)
     89           *        Use P to run other files as sub-programs: "M32 P !filename#"
     90           *        The '#' is necessary when calling from within sd files, as it stops buffer prereading
     91           * M33  - Get the longname version of a path. (Requires LONG_FILENAME_HOST_SUPPORT)
     92           * M34  - Set SD Card sorting options. (Requires SDCARD_SORT_ALPHA)
     93           * M42  - Change pin status via gcode: M42 P<pin> S<value>. LED pin assumed if P is omitted.
     94           * M43  - Display pin status, watch pins for changes, watch endstops & toggle LED, Z servo probe test, toggle pins
     95           * M48  - Measure Z Probe repeatability: M48 P<points> X<pos> Y<pos> V<level> E<engage> L<legs>. (Requires Z_MIN_PROBE_REPEATABILITY_TEST)
     96           * M75  - Start the print job timer.
     97           * M76  - Pause the print job timer.
     98           * M77  - Stop the print job timer.
     99           * M78  - Show statistical information about the print jobs. (Requires PRINTCOUNTER)
    100           * M80  - Turn on Power Supply. (Requires POWER_SUPPLY)
    101           * M81  - Turn off Power Supply. (Requires POWER_SUPPLY)
    102           * M82  - Set E codes absolute (default).
    103           * M83  - Set E codes relative while in Absolute (G90) mode.
    104           * M84  - Disable steppers until next move, or use S<seconds> to specify an idle
    105           *        duration after which steppers should turn off. S0 disables the timeout.
    106           * M85  - Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
    107           * M92  - Set planner.axis_steps_per_mm for one or more axes.
    108           * M104 - Set extruder target temp.
    109           * M105 - Report current temperatures.
    110           * M106 - Fan on.
    111           * M107 - Fan off.
    112           * M108 - Break out of heating loops (M109, M190, M303). With no controller, breaks out of M0/M1. (Requires EMERGENCY_PARSER)
    113           * M109 - Sxxx Wait for extruder current temp to reach target temp. Waits only when heating
    114           *        Rxxx Wait for extruder current temp to reach target temp. Waits when heating and cooling
    115           *        If AUTOTEMP is enabled, S<mintemp> B<maxtemp> F<factor>. Exit autotemp by any M109 without F
    116           * M110 - Set the current line number. (Used by host printing)
    117           * M111 - Set debug flags: "M111 S<flagbits>". See flag bits defined in enum.h.
    118           * M112 - Emergency stop.
    119           * M113 - Get or set the timeout interval for Host Keepalive "busy" messages. (Requires HOST_KEEPALIVE_FEATURE)
    120           * M114 - Report current position.
    121           * M115 - Report capabilities. (Extended capabilities requires EXTENDED_CAPABILITIES_REPORT)
    122           * M117 - Display a message on the controller screen. (Requires an LCD)
    123           * M119 - Report endstops status.
    124           * M120 - Enable endstops detection.
    125           * M121 - Disable endstops detection.
    126           * M125 - Save current position and move to filament change position. (Requires PARK_HEAD_ON_PAUSE)
    127           * M126 - Solenoid Air Valve Open. (Requires BARICUDA)
    128           * M127 - Solenoid Air Valve Closed. (Requires BARICUDA)
    129           * M128 - EtoP Open. (Requires BARICUDA)
    130           * M129 - EtoP Closed. (Requires BARICUDA)
    131           * M140 - Set bed target temp. S<temp>
    132           * M145 - Set heatup values for materials on the LCD. H<hotend> B<bed> F<fan speed> for S<material> (0=PLA, 1=ABS)
    133           * M149 - Set temperature units. (Requires TEMPERATURE_UNITS_SUPPORT)
    134           * M150 - Set Status LED Color as R<red> U<green> B<blue>. Values 0-255. (Requires BLINKM or RGB_LED)
    135           * M155 - Auto-report temperatures with interval of S<seconds>. (Requires AUTO_REPORT_TEMPERATURES)
    136           * M163 - Set a single proportion for a mixing extruder. (Requires MIXING_EXTRUDER)
    137           * M164 - Save the mix as a virtual extruder. (Requires MIXING_EXTRUDER and MIXING_VIRTUAL_TOOLS)
    138           * M165 - Set the proportions for a mixing extruder. Use parameters ABCDHI to set the mixing factors. (Requires MIXING_EXTRUDER)
    139           * M190 - Sxxx Wait for bed current temp to reach target temp. ** Waits only when heating! **
    140           *        Rxxx Wait for bed current temp to reach target temp. ** Waits for heating or cooling. **
    141           * M200 - Set filament diameter, D<diameter>, setting E axis units to cubic. (Use S0 to revert to linear units.)
    142           * M201 - Set max acceleration in units/s^2 for print moves: "M201 X<accel> Y<accel> Z<accel> E<accel>"
    143           * M202 - Set max acceleration in units/s^2 for travel moves: "M202 X<accel> Y<accel> Z<accel> E<accel>" ** UNUSED IN MARLIN! **
    144           * M203 - Set maximum feedrate: "M203 X<fr> Y<fr> Z<fr> E<fr>" in units/sec.
    145           * M204 - Set default acceleration in units/sec^2: P<printing> R<extruder_only> T<travel>
    146           * M205 - Set advanced settings. Current units apply:
    147                      S<print> T<travel> minimum speeds
    148                      B<minimum segment time>
    149                      X<max X jerk>, Y<max Y jerk>, Z<max Z jerk>, E<max E jerk>
    150           * M206 - Set additional homing offset. (Disabled by NO_WORKSPACE_OFFSETS or DELTA)
    151           * M207 - Set Retract Length: S<length>, Feedrate: F<units/min>, and Z lift: Z<distance>. (Requires FWRETRACT)
    152           * M208 - Set Recover (unretract) Additional (!) Length: S<length> and Feedrate: F<units/min>. (Requires FWRETRACT)
    153           * M209 - Turn Automatic Retract Detection on/off: S<0|1> (For slicers that don't support G10/11). (Requires FWRETRACT)
    154                    Every normal extrude-only move will be classified as retract depending on the direction.
    155           * M211 - Enable, Disable, and/or Report software endstops: S<0|1> (Requires MIN_SOFTWARE_ENDSTOPS or MAX_SOFTWARE_ENDSTOPS)
    156           * M218 - Set a tool offset: "M218 T<index> X<offset> Y<offset>". (Requires 2 or more extruders)
    157           * M220 - Set Feedrate Percentage: "M220 S<percent>" (i.e., "FR" on the LCD)
    158           * M221 - Set Flow Percentage: "M221 S<percent>"
    159           * M226 - Wait until a pin is in a given state: "M226 P<pin> S<state>"
    160           * M240 - Trigger a camera to take a photograph. (Requires CHDK or PHOTOGRAPH_PIN)
    161           * M250 - Set LCD contrast: "M250 C<contrast>" (0-63). (Requires LCD support)
    162           * M260 - i2c Send Data (Requires EXPERIMENTAL_I2CBUS)
    163           * M261 - i2c Request Data (Requires EXPERIMENTAL_I2CBUS)
    164           * M280 - Set servo position absolute: "M280 P<index> S<angle|Âµs>". (Requires servos)
    165           * M300 - Play beep sound S<frequency Hz> P<duration ms>
    166           * M301 - Set PID parameters P I and D. (Requires PIDTEMP)
    167           * M302 - Allow cold extrudes, or set the minimum extrude S<temperature>. (Requires PREVENT_COLD_EXTRUSION)
    168           * M303 - PID relay autotune S<temperature> sets the target temperature. Default 150C. (Requires PIDTEMP)
    169           * M304 - Set bed PID parameters P I and D. (Requires PIDTEMPBED)
    170           * M355 - Turn the Case Light on/off and set its brightness. (Requires CASE_LIGHT_PIN)
    171           * M380 - Activate solenoid on active extruder. (Requires EXT_SOLENOID)
    172           * M381 - Disable all solenoids. (Requires EXT_SOLENOID)
    173           * M400 - Finish all moves.
    174           * M401 - Lower Z probe. (Requires a probe)
    175           * M402 - Raise Z probe. (Requires a probe)
    176           * M404 - Display or set the Nominal Filament Width: "W<diameter>". (Requires FILAMENT_WIDTH_SENSOR)
    177           * M405 - Enable Filament Sensor flow control. "M405 D<delay_cm>". (Requires FILAMENT_WIDTH_SENSOR)
    178           * M406 - Disable Filament Sensor flow control. (Requires FILAMENT_WIDTH_SENSOR)
    179           * M407 - Display measured filament diameter in millimeters. (Requires FILAMENT_WIDTH_SENSOR)
    180           * M410 - Quickstop. Abort all planned moves.
    181           * M420 - Enable/Disable Leveling (with current values) S1=enable S0=disable (Requires MESH_BED_LEVELING or ABL)
    182           * M421 - Set a single Z coordinate in the Mesh Leveling grid. X<units> Y<units> Z<units> (Requires MESH_BED_LEVELING or AUTO_BED_LEVELING_UBL)
    183           * M428 - Set the home_offset based on the current_position. Nearest edge applies. (Disabled by NO_WORKSPACE_OFFSETS or DELTA)
    184           * M500 - Store parameters in EEPROM. (Requires EEPROM_SETTINGS)
    185           * M501 - Restore parameters from EEPROM. (Requires EEPROM_SETTINGS)
    186           * M502 - Revert to the default "factory settings". ** Does not write them to EEPROM! **
    187           * M503 - Print the current settings (in memory): "M503 S<verbose>". S0 specifies compact output.
    188           * M540 - Enable/disable SD card abort on endstop hit: "M540 S<state>". (Requires ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
    189           * M600 - Pause for filament change: "M600 X<pos> Y<pos> Z<raise> E<first_retract> L<later_retract>". (Requires FILAMENT_CHANGE_FEATURE)
    190           * M665 - Set delta configurations: "M665 L<diagonal rod> R<delta radius> S<segments/s> A<rod A trim mm> B<rod B trim mm> C<rod C trim mm> I<tower A trim angle> J<tower B trim angle> K<tower C trim angle>" (Requires DELTA)
    191           * M666 - Set delta endstop adjustment. (Requires DELTA)
    192           * M605 - Set dual x-carriage movement mode: "M605 S<mode> [X<x_offset>] [R<temp_offset>]". (Requires DUAL_X_CARRIAGE)
    193           * M851 - Set Z probe's Z offset in current units. (Negative = below the nozzle.)
    194           * M906 - Set or get motor current in milliamps using axis codes X, Y, Z, E. Report values if no axis codes given. (Requires HAVE_TMC2130)
    195           * M907 - Set digital trimpot motor current using axis codes. (Requires a board with digital trimpots)
    196           * M908 - Control digital trimpot directly. (Requires DAC_STEPPER_CURRENT or DIGIPOTSS_PIN)
    197           * M909 - Print digipot/DAC current value. (Requires DAC_STEPPER_CURRENT)
    198           * M910 - Commit digipot/DAC value to external EEPROM via I2C. (Requires DAC_STEPPER_CURRENT)
    199           * M911 - Report stepper driver overtemperature pre-warn condition. (Requires HAVE_TMC2130)
    200           * M912 - Clear stepper driver overtemperature pre-warn condition flag. (Requires HAVE_TMC2130)
    201           * M913 - Set HYBRID_THRESHOLD speed. (Requires HYBRID_THRESHOLD)
    202           * M914 - Set SENSORLESS_HOMING sensitivity. (Requires SENSORLESS_HOMING)
    203           * M350 - Set microstepping mode. (Requires digital microstepping pins.)
    204           * M351 - Toggle MS1 MS2 pins directly. (Requires digital microstepping pins.)
    205           *
    206           * M360 - SCARA calibration: Move to cal-position ThetaA (0 deg calibration)
    207           * M361 - SCARA calibration: Move to cal-position ThetaB (90 deg calibration - steps per degree)
    208           * M362 - SCARA calibration: Move to cal-position PsiA (0 deg calibration)
    209           * M363 - SCARA calibration: Move to cal-position PsiB (90 deg calibration - steps per degree)
    210           * M364 - SCARA calibration: Move to cal-position PSIC (90 deg to Theta calibration position)
    211           *
    212           * ************ Custom codes - This can change to suit future G-code regulations
    213           * M100 - Watch Free Memory (For Debugging). (Requires M100_FREE_MEMORY_WATCHER)
    214           * M928 - Start SD logging: "M928 filename.gco". Stop with M29. (Requires SDSUPPORT)
    215           * M999 - Restart after being stopped by error
    216           *
    217           * "T" Codes
    218           *
    219           * T0-T3 - Select an extruder (tool) by index: "T<n> F<units/min>"
    220           *
    221           */
    222          
    223          #include "Marlin.h"

   \                                 In section .text, align 2
   \   __interwork __softfp bool isnan(float)
   \                     _Z5isnanf: (+1)
   \        0x0   0x0040             LSLS     R0,R0,#+1
   \        0x2   0x4601             MOV      R1,R0
   \        0x4   0x1609             ASRS     R1,R1,#+24
   \        0x6   0x1C49             ADDS     R1,R1,#+1
   \        0x8   0xD001             BEQ.N    ??isnan_0
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xE000             B.N      ??isnan_1
   \                     ??isnan_0: (+1)
   \        0xE   0x0200             LSLS     R0,R0,#+8
   \                     ??isnan_1: (+1)
   \       0x10   0x1E40             SUBS     R0,R0,#+1
   \       0x12   0x4180             SBCS     R0,R0,R0
   \       0x14   0x43C0             MVNS     R0,R0
   \       0x16   0x0FC0             LSRS     R0,R0,#+31
   \       0x18   0x4770             BX       LR               ;; return

    #define SDSS   18
            ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\pins_MKS_ROBIN_LITE.h",161  Warning[Pa181]: 
          incompatible redefinition of macro "SDSS" (declared at line 62)

  #define UNUSED(x) ((void)(x))
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_def.h",87  Warning[Pa181]: 
          incompatible redefinition of macro "UNUSED" (declared at line 88 of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marl
          in\macros.h")

   \                                 In section .text, align 2
   \   __interwork __softfp int MarlinSerial::available()
   \                     _ZN12MarlinSerial9availableEv: (+1)
   \        0x0   0x.... 0x....      B.W      BSP_UartGetNbRxAvalaibleBytes

   \                                 In section .text, align 2
   \   __interwork __softfp void MarlinSerial::write(uint8_t)
   \                     _ZN12MarlinSerial5writeEh: (+1)
   \        0x0   0xB502             PUSH     {R1,LR}
   \        0x2   0x2201             MOVS     R2,#+1
   \        0x4   0x4669             MOV      R1,SP
   \        0x6   0x.... 0x....      BL       BSP_UartIfQueueTxData
   \        0xA   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void MarlinSerial::write(char const *)
   \                     _ZN12MarlinSerial5writeEPKc: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4628             MOV      R0,R5
   \        0x8   0x.... 0x....      BL       strlen
   \        0xC   0x4602             MOV      R2,R0
   \        0xE   0xB2D2             UXTB     R2,R2
   \       0x10   0x4629             MOV      R1,R5
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0xE8BD 0x4038      POP      {R3-R5,LR}
   \       0x18   0x.... 0x....      B.W      BSP_UartIfQueueTxData

   \                                 In section .text, align 4
   \   __interwork __softfp void MarlinSerial::print(char const *)
   \                     _ZN12MarlinSerial5printEPKc: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4628             MOV      R0,R5
   \        0x8   0x.... 0x....      BL       strlen
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD013             BEQ.N    ??print_1
   \       0x10   0x480A             LDR.N    R0,??print_0
   \       0x12   0x79C0             LDRB     R0,[R0, #+7]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD105             BNE.N    ??print_2
   \       0x18   0x4629             MOV      R1,R5
   \       0x1A   0x4620             MOV      R0,R4
   \       0x1C   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \       0x20   0x.... 0x....      B.W      _ZN12MarlinSerial5writeEPKc
   \                     ??print_2: (+1)
   \       0x24   0x4628             MOV      R0,R5
   \       0x26   0x.... 0x....      BL       strlen
   \       0x2A   0x4602             MOV      R2,R0
   \       0x2C   0x4629             MOV      R1,R5
   \       0x2E   0x2002             MOVS     R0,#+2
   \       0x30   0xE8BD 0x4038      POP      {R3-R5,LR}
   \       0x34   0x.... 0x....      B.W      package_to_wifi
   \                     ??print_1: (+1)
   \       0x38   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \       0x3A   0xBF00             Nop      
   \                     ??print_0:
   \       0x3C   0x....'....        DC32     mks_heating_busy

   \                                 In section .text, align 2
   \   __interwork __softfp void serial_echopair_P(char const *, uint8_t)
   \                     _Z17serial_echopair_PPKch: (+1)
   \        0x0   0x.... 0x....      B.W      _Z17serial_echopair_PPKci

   \                                 In section .text, align 2
   \   __interwork __softfp void serial_echopair_P(char const *, bool)
   \                     _Z17serial_echopair_PPKcb: (+1)
   \        0x0   0x.... 0x....      B.W      _Z17serial_echopair_PPKci

   \                                 In section .text, align 4
   \   __interwork __softfp void serialprintPGM(char const *)
   \                     _Z14serialprintPGMPKc: (+1)
   \        0x0   0x4601             MOV      R1,R0
   \        0x2   0x4805             LDR.N    R0,??serialprintPGM_0
   \        0x4   0x79C0             LDRB     R0,[R0, #+7]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD102             BNE.N    ??serialprintPGM_1
   \        0xA   0x4804             LDR.N    R0,??serialprintPGM_0+0x4
   \        0xC   0x.... 0x....      B.W      _ZN12MarlinSerial5writeEPKc
   \                     ??serialprintPGM_1: (+1)
   \       0x10   0x4803             LDR.N    R0,??serialprintPGM_0+0x8
   \       0x12   0x.... 0x....      B.W      _ZN12MarlinSerial5printEPKc
   \       0x16   0xBF00             Nop      
   \                     ??serialprintPGM_0:
   \       0x18   0x....'....        DC32     mks_heating_busy
   \       0x1C   0x....'....        DC32     customizedSerial
   \       0x20   0x....'....        DC32     serial2

  #define PRINT_LED_PIN         PDout(2)
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\BSP\STM32MKS-3dPrinter\mks_fastio.h",14  Warning[Pa181]: 
          incompatible redefinition of macro "PRINT_LED_PIN" (declared at line
          146 of "C:\Users\PLT\Desktop\mksRobinLite_nano\Inc\main.h")

   \                                 In section .text, align 4
   \   __interwork __softfp bool IsRunning()
   \                     _Z9IsRunningv: (+1)
   \        0x0   0x4801             LDR.N    R0,??IsRunning_0
   \        0x2   0x7800             LDRB     R0,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return
   \        0x6   0xBF00             Nop      
   \                     ??IsRunning_0:
   \        0x8   0x....'....        DC32     Running

   \                                 In section .text, align 4
   \   __interwork __softfp bool IsStopped()
   \                     _Z9IsStoppedv: (+1)
   \        0x0   0x4802             LDR.N    R0,??IsStopped_0
   \        0x2   0x7800             LDRB     R0,[R0, #+0]
   \        0x4   0x1E40             SUBS     R0,R0,#+1
   \        0x6   0x4180             SBCS     R0,R0,R0
   \        0x8   0x0FC0             LSRS     R0,R0,#+31
   \        0xA   0x4770             BX       LR               ;; return
   \                     ??IsStopped_0:
   \        0xC   0x....'....        DC32     Running

   \                                 In section .text, align 4
   \   __interwork __softfp void refresh_cmd_timeout()
   \                     _Z19refresh_cmd_timeoutv: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x.... 0x....      BL       HAL_GetTick
   \        0x6   0x4901             LDR.N    R1,??refresh_cmd_timeout_0
   \        0x8   0x6388             STR      R0,[R1, #+56]
   \        0xA   0xBD01             POP      {R0,PC}          ;; return
   \                     ??refresh_cmd_timeout_0:
   \        0xC   0x....'....        DC32     axis_relative_modes
    224          #include "ultralcd.h"
    225          #include "planner.h"

   \                                 In section .text, align 2
   \   __interwork __softfp void Planner::apply_leveling(float *)
   \                     _ZN7Planner14apply_levelingEPf: (+1)
   \        0x0   0xF100 0x0208      ADD      R2,R0,#+8
   \        0x4   0x1D01             ADDS     R1,R0,#+4
   \        0x6   0x.... 0x....      B.W      _ZN7Planner14apply_levelingERfS0_S0_

   \                                 In section .text, align 4
   \   __interwork __softfp void Planner::buffer_line(float, float, float, float const &, float const &, uint8_t)
   \                     _ZN7Planner11buffer_lineEfffRKfS1_h: (+1)
   \        0x0   0xB517             PUSH     {R0-R2,R4,LR}
   \        0x2   0xB083             SUB      SP,SP,#+12
   \        0x4   0x461C             MOV      R4,R3
   \        0x6   0x480D             LDR.N    R0,??buffer_line_0
   \        0x8   0x7801             LDRB     R1,[R0, #+0]
   \        0xA   0xF011 0x0F2E      TST      R1,#0x2E
   \        0xE   0xD008             BEQ.N    ??buffer_line_1
   \       0x10   0xF9B0 0x0018      LDRSH    R0,[R0, #+24]
   \       0x14   0x2801             CMP      R0,#+1
   \       0x16   0xD104             BNE.N    ??buffer_line_1
   \       0x18   0xAA05             ADD      R2,SP,#+20
   \       0x1A   0xA904             ADD      R1,SP,#+16
   \       0x1C   0xA803             ADD      R0,SP,#+12
   \       0x1E   0x.... 0x....      BL       _ZN7Planner14apply_levelingERfS0_S0_
   \                     ??buffer_line_1: (+1)
   \       0x22   0x9809             LDR      R0,[SP, #+36]
   \       0x24   0x9908             LDR      R1,[SP, #+32]
   \       0x26   0x9001             STR      R0,[SP, #+4]
   \       0x28   0x6808             LDR      R0,[R1, #+0]
   \       0x2A   0x9000             STR      R0,[SP, #+0]
   \       0x2C   0x4623             MOV      R3,R4
   \       0x2E   0xAA05             ADD      R2,SP,#+20
   \       0x30   0xA904             ADD      R1,SP,#+16
   \       0x32   0xA803             ADD      R0,SP,#+12
   \       0x34   0x.... 0x....      BL       _ZN7Planner12_buffer_lineERKfS1_S1_S1_fh
   \       0x38   0xB006             ADD      SP,SP,#+24
   \       0x3A   0xBD10             POP      {R4,PC}          ;; return
   \                     ??buffer_line_0:
   \       0x3C   0x....'....        DC32     mksCfg+0x40

   \                                 In section .text, align 4
   \   __interwork __softfp void Planner::buffer_line_kinematic(float const *, float const &, uint8_t)
   \                     _ZN7Planner21buffer_line_kinematicEPKfRS0_h: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB086             SUB      SP,SP,#+24
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x9002             STR      R0,[SP, #+8]
   \        0xE   0xA802             ADD      R0,SP,#+8
   \       0x10   0x6861             LDR      R1,[R4, #+4]
   \       0x12   0x6041             STR      R1,[R0, #+4]
   \       0x14   0x68A1             LDR      R1,[R4, #+8]
   \       0x16   0x6081             STR      R1,[R0, #+8]
   \       0x18   0x68E1             LDR      R1,[R4, #+12]
   \       0x1A   0x60C1             STR      R1,[R0, #+12]
   \       0x1C   0x4F18             LDR.N    R7,??buffer_line_kinematic_0
   \       0x1E   0x7838             LDRB     R0,[R7, #+0]
   \       0x20   0xF010 0x0F2E      TST      R0,#0x2E
   \       0x24   0xD002             BEQ.N    ??buffer_line_kinematic_1
   \       0x26   0xA802             ADD      R0,SP,#+8
   \       0x28   0x.... 0x....      BL       _ZN7Planner14apply_levelingEPf
   \                     ??buffer_line_kinematic_1: (+1)
   \       0x2C   0xF9B7 0x0018      LDRSH    R0,[R7, #+24]
   \       0x30   0xF240 0x3102      MOVW     R1,#+770
   \       0x34   0x4208             TST      R0,R1
   \       0x36   0xD016             BEQ.N    ??buffer_line_kinematic_2
   \       0x38   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x3C   0xA802             ADD      R0,SP,#+8
   \       0x3E   0xD102             BNE.N    ??buffer_line_kinematic_3
   \       0x40   0x.... 0x....      BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
   \       0x44   0xE001             B.N      ??buffer_line_kinematic_4
   \                     ??buffer_line_kinematic_3: (+1)
   \       0x46   0x.... 0x....      BL       _Z18inverse_kinematicsPKf
   \                     ??buffer_line_kinematic_4: (+1)
   \       0x4A   0x480E             LDR.N    R0,??buffer_line_kinematic_0+0x4
   \       0x4C   0x9601             STR      R6,[SP, #+4]
   \       0x4E   0x6829             LDR      R1,[R5, #+0]
   \       0x50   0x9100             STR      R1,[SP, #+0]
   \       0x52   0xF104 0x030C      ADD      R3,R4,#+12
   \       0x56   0xF100 0x0270      ADD      R2,R0,#+112
   \       0x5A   0xF100 0x016C      ADD      R1,R0,#+108
   \       0x5E   0x3068             ADDS     R0,R0,#+104
   \       0x60   0x.... 0x....      BL       _ZN7Planner12_buffer_lineERKfS1_S1_S1_fh
   \       0x64   0xE009             B.N      ??buffer_line_kinematic_5
   \                     ??buffer_line_kinematic_2: (+1)
   \       0x66   0x9601             STR      R6,[SP, #+4]
   \       0x68   0x6828             LDR      R0,[R5, #+0]
   \       0x6A   0x9000             STR      R0,[SP, #+0]
   \       0x6C   0xF104 0x030C      ADD      R3,R4,#+12
   \       0x70   0xAA04             ADD      R2,SP,#+16
   \       0x72   0xA903             ADD      R1,SP,#+12
   \       0x74   0xA802             ADD      R0,SP,#+8
   \       0x76   0x.... 0x....      BL       _ZN7Planner12_buffer_lineERKfS1_S1_S1_fh
   \                     ??buffer_line_kinematic_5: (+1)
   \       0x7A   0xB007             ADD      SP,SP,#+28
   \       0x7C   0xBDF0             POP      {R4-R7,PC}       ;; return
   \       0x7E   0xBF00             Nop      
   \                     ??buffer_line_kinematic_0:
   \       0x80   0x....'....        DC32     mksCfg+0x40
   \       0x84   0x....'....        DC32     mks_heating_busy

   \                                 In section .text, align 4
   \   __interwork __softfp void Planner::set_position_mm(float, float, float, float const &)
   \                     _ZN7Planner15set_position_mmEfffRKf: (+1)
   \        0x0   0xB517             PUSH     {R0-R2,R4,LR}
   \        0x2   0xB081             SUB      SP,SP,#+4
   \        0x4   0x461C             MOV      R4,R3
   \        0x6   0x480A             LDR.N    R0,??set_position_mm_0
   \        0x8   0x7801             LDRB     R1,[R0, #+0]
   \        0xA   0xF011 0x0F2E      TST      R1,#0x2E
   \        0xE   0xD008             BEQ.N    ??set_position_mm_1
   \       0x10   0xF9B0 0x0018      LDRSH    R0,[R0, #+24]
   \       0x14   0x2801             CMP      R0,#+1
   \       0x16   0xD104             BNE.N    ??set_position_mm_1
   \       0x18   0xAA03             ADD      R2,SP,#+12
   \       0x1A   0xA902             ADD      R1,SP,#+8
   \       0x1C   0xA801             ADD      R0,SP,#+4
   \       0x1E   0x.... 0x....      BL       _ZN7Planner14apply_levelingERfS0_S0_
   \                     ??set_position_mm_1: (+1)
   \       0x22   0x4623             MOV      R3,R4
   \       0x24   0xAA03             ADD      R2,SP,#+12
   \       0x26   0xA902             ADD      R1,SP,#+8
   \       0x28   0xA801             ADD      R0,SP,#+4
   \       0x2A   0x.... 0x....      BL       _ZN7Planner16_set_position_mmERKfS1_S1_S1_
   \       0x2E   0xBD1F             POP      {R0-R4,PC}       ;; return
   \                     ??set_position_mm_0:
   \       0x30   0x....'....        DC32     mksCfg+0x40

   \                                 In section .text, align 2
   \   __interwork __softfp void Planner::set_e_position_mm(float const &)
   \                     _ZN7Planner17set_e_position_mmERKf: (+1)
   \        0x0   0x4601             MOV      R1,R0
   \        0x2   0x2003             MOVS     R0,#+3
   \        0x4   0x.... 0x....      B.W      _ZN7Planner15set_position_mmE8AxisEnumRKf

   \                                 In section .text, align 4
   \   __interwork __softfp bool Planner::blocks_queued()
   \                     _ZN7Planner13blocks_queuedEv: (+1)
   \        0x0   0x4804             LDR.N    R0,??blocks_queued_0
   \        0x2   0x7800             LDRB     R0,[R0, #+0]
   \        0x4   0x4904             LDR.N    R1,??blocks_queued_0+0x4
   \        0x6   0x7809             LDRB     R1,[R1, #+0]
   \        0x8   0x4288             CMP      R0,R1
   \        0xA   0xD001             BEQ.N    ??blocks_queued_1
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0x4770             BX       LR
   \                     ??blocks_queued_1: (+1)
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x4770             BX       LR               ;; return
   \                     ??blocks_queued_0:
   \       0x14   0x....'....        DC32     _ZN7Planner17block_buffer_headE
   \       0x18   0x....'....        DC32     _ZN7Planner17block_buffer_tailE

   \                                 In section .text, align 4
   \   __interwork __softfp void Planner::discard_current_block()
   \                     _ZN7Planner21discard_current_blockEv: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x.... 0x....      BL       _ZN7Planner13blocks_queuedEv
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD005             BEQ.N    ??discard_current_block_1
   \        0xA   0x4803             LDR.N    R0,??discard_current_block_0
   \        0xC   0x7801             LDRB     R1,[R0, #+0]
   \        0xE   0x1C49             ADDS     R1,R1,#+1
   \       0x10   0xF001 0x010F      AND      R1,R1,#0xF
   \       0x14   0x7001             STRB     R1,[R0, #+0]
   \                     ??discard_current_block_1: (+1)
   \       0x16   0xBD01             POP      {R0,PC}          ;; return
   \                     ??discard_current_block_0:
   \       0x18   0x....'....        DC32     _ZN7Planner17block_buffer_tailE
    226          #include "stepper.h"

   \                                 In section .text, align 2
   \   __interwork __softfp float Stepper::get_axis_position_degrees(AxisEnum)
   \                     _ZN7Stepper25get_axis_position_degreesE8AxisEnum: (+1)
   \        0x0   0x.... 0x....      B.W      _ZN7Stepper20get_axis_position_mmE8AxisEnum
    227          #include "endstops.h"

   \                                 In section .text, align 4
   \   __interwork __softfp void Endstops::enable_globally(bool)
   \                     _ZN8Endstops15enable_globallyEb: (+1)
   \        0x0   0x4902             LDR.N    R1,??enable_globally_0
   \        0x2   0x7008             STRB     R0,[R1, #+0]
   \        0x4   0x4902             LDR.N    R1,??enable_globally_0+0x4
   \        0x6   0x7008             STRB     R0,[R1, #+0]
   \        0x8   0x4770             BX       LR               ;; return
   \        0xA   0xBF00             Nop      
   \                     ??enable_globally_0:
   \        0xC   0x....'....        DC32     _ZN8Endstops7enabledE
   \       0x10   0x....'....        DC32     _ZN8Endstops16enabled_globallyE

   \                                 In section .text, align 4
   \   __interwork __softfp void Endstops::enable(bool)
   \                     _ZN8Endstops6enableEb: (+1)
   \        0x0   0x4901             LDR.N    R1,??enable_0
   \        0x2   0x7008             STRB     R0,[R1, #+0]
   \        0x4   0x4770             BX       LR               ;; return
   \        0x6   0xBF00             Nop      
   \                     ??enable_0:
   \        0x8   0x....'....        DC32     _ZN8Endstops7enabledE

   \                                 In section .text, align 4
   \   __interwork __softfp void Endstops::not_homing()
   \                     _ZN8Endstops10not_homingEv: (+1)
   \        0x0   0x4802             LDR.N    R0,??not_homing_0
   \        0x2   0x7800             LDRB     R0,[R0, #+0]
   \        0x4   0x4902             LDR.N    R1,??not_homing_0+0x4
   \        0x6   0x7008             STRB     R0,[R1, #+0]
   \        0x8   0x4770             BX       LR               ;; return
   \        0xA   0xBF00             Nop      
   \                     ??not_homing_0:
   \        0xC   0x....'....        DC32     _ZN8Endstops16enabled_globallyE
   \       0x10   0x....'....        DC32     _ZN8Endstops7enabledE

   \                                 In section .text, align 4
   \   __interwork __softfp void Endstops::hit_on_purpose()
   \                     _ZN8Endstops14hit_on_purposeEv: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x4901             LDR.N    R1,??hit_on_purpose_0
   \        0x4   0x7008             STRB     R0,[R1, #+0]
   \        0x6   0x4770             BX       LR               ;; return
   \                     ??hit_on_purpose_0:
   \        0x8   0x....'....        DC32     _ZN8Endstops16endstop_hit_bitsE

   \                                 In section .text, align 4
   \   __interwork __softfp void Endstops::enable_z_probe(bool)
   \                     _ZN8Endstops14enable_z_probeEb: (+1)
   \        0x0   0x4901             LDR.N    R1,??enable_z_probe_0
   \        0x2   0x7008             STRB     R0,[R1, #+0]
   \        0x4   0x4770             BX       LR               ;; return
   \        0x6   0xBF00             Nop      
   \                     ??enable_z_probe_0:
   \        0x8   0x....'....        DC32     _ZN8Endstops15z_probe_enabledE
    228          #include "temperature.h"

   \                                 In section .text, align 4
   \   __interwork __softfp bool Temperature::tooColdToExtrude(uint8_t)
   \                     _ZN11Temperature16tooColdToExtrudeEh: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x4809             LDR.N    R0,??tooColdToExtrude_0
   \        0x4   0x7800             LDRB     R0,[R0, #+0]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD001             BEQ.N    ??tooColdToExtrude_1
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xBD02             POP      {R1,PC}
   \                     ??tooColdToExtrude_1: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x.... 0x....      BL       _ZN11Temperature9degHotendEh
   \       0x14   0x4905             LDR.N    R1,??tooColdToExtrude_0+0x4
   \       0x16   0x6809             LDR      R1,[R1, #+0]
   \       0x18   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x1C   0xD201             BCS.N    ??tooColdToExtrude_2
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0xBD02             POP      {R1,PC}
   \                     ??tooColdToExtrude_2: (+1)
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0xBD02             POP      {R1,PC}          ;; return
   \       0x26   0xBF00             Nop      
   \                     ??tooColdToExtrude_0:
   \       0x28   0x....'....        DC32     _ZN11Temperature18allow_cold_extrudeE
   \       0x2C   0x....'....        DC32     _ZN11Temperature16extrude_min_tempE

   \                                 In section .text, align 4
   \   __interwork __softfp float Temperature::degHotend(uint8_t)
   \                     _ZN11Temperature9degHotendEh: (+1)
   \        0x0   0x4801             LDR.N    R0,??degHotend_0
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return
   \        0x6   0xBF00             Nop      
   \                     ??degHotend_0:
   \        0x8   0x....'....        DC32     _ZN11Temperature19current_temperatureE

   \                                 In section .text, align 4
   \   __interwork __softfp float Temperature::degBed()
   \                     _ZN11Temperature6degBedEv: (+1)
   \        0x0   0x4801             LDR.N    R0,??degBed_0
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return
   \        0x6   0xBF00             Nop      
   \                     ??degBed_0:
   \        0x8   0x....'....        DC32     _ZN11Temperature23current_temperature_bedE

   \                                 In section .text, align 4
   \   __interwork __softfp float Temperature::degTargetHotend(uint8_t)
   \                     _ZN11Temperature15degTargetHotendEh: (+1)
   \        0x0   0x4801             LDR.N    R0,??degTargetHotend_0
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x.... 0x....      B.W      __aeabi_i2f
   \                     ??degTargetHotend_0:
   \        0x8   0x....'....        DC32     _ZN11Temperature18target_temperatureE

   \                                 In section .text, align 4
   \   __interwork __softfp float Temperature::degTargetBed()
   \                     _ZN11Temperature12degTargetBedEv: (+1)
   \        0x0   0x4801             LDR.N    R0,??degTargetBed_0
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x.... 0x....      B.W      __aeabi_i2f
   \                     ??degTargetBed_0:
   \        0x8   0x....'....        DC32     _ZN11Temperature22target_temperature_bedE

   \                                 In section .text, align 4
   \   __interwork __softfp void Temperature::setTargetHotend(float, uint8_t)
   \                     _ZN11Temperature15setTargetHotendEfh: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}

        target_temperature[HOTEND_INDEX] = celsius;
                                         ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\temperature.h",401  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \        0x2   0x.... 0x....      BL       __aeabi_f2iz
   \        0x6   0x4903             LDR.N    R1,??setTargetHotend_0
   \        0x8   0x6008             STR      R0,[R1, #+0]
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xE8BD 0x4002      POP      {R1,LR}
   \       0x10   0x.... 0x....      B.W      _ZN11Temperature21start_watching_heaterEh
   \                     ??setTargetHotend_0:
   \       0x14   0x....'....        DC32     _ZN11Temperature18target_temperatureE

   \                                 In section .text, align 4
   \   __interwork __softfp void Temperature::setTargetBed(float)
   \                     _ZN11Temperature12setTargetBedEf: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}

        target_temperature_bed = celsius;
                               ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\temperature.h",408  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \        0x2   0x.... 0x....      BL       __aeabi_f2iz
   \        0x6   0x4903             LDR.N    R1,??setTargetBed_0
   \        0x8   0x6008             STR      R0,[R1, #+0]
   \        0xA   0xE8BD 0x4001      POP      {R0,LR}
   \        0xE   0x.... 0x....      B.W      _ZN11Temperature18start_watching_bedEv
   \       0x12   0xBF00             Nop      
   \                     ??setTargetBed_0:
   \       0x14   0x....'....        DC32     _ZN11Temperature22target_temperature_bedE

   \                                 In section .text, align 4
   \   __interwork __softfp bool Temperature::isCoolingHotend(uint8_t)
   \                     _ZN11Temperature15isCoolingHotendEh: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x4806             LDR.N    R0,??isCoolingHotend_0
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x.... 0x....      BL       __aeabi_i2f
   \        0xA   0x4905             LDR.N    R1,??isCoolingHotend_0+0x4
   \        0xC   0x6809             LDR      R1,[R1, #+0]
   \        0xE   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x12   0xD201             BCS.N    ??isCoolingHotend_1
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0xBD02             POP      {R1,PC}
   \                     ??isCoolingHotend_1: (+1)
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xBD02             POP      {R1,PC}          ;; return
   \                     ??isCoolingHotend_0:
   \       0x1C   0x....'....        DC32     _ZN11Temperature18target_temperatureE
   \       0x20   0x....'....        DC32     _ZN11Temperature19current_temperatureE

   \                                 In section .text, align 4
   \   __interwork __softfp bool Temperature::isCoolingBed()
   \                     _ZN11Temperature12isCoolingBedEv: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x4806             LDR.N    R0,??isCoolingBed_0
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x.... 0x....      BL       __aeabi_i2f
   \        0xA   0x4905             LDR.N    R1,??isCoolingBed_0+0x4
   \        0xC   0x6809             LDR      R1,[R1, #+0]
   \        0xE   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x12   0xD201             BCS.N    ??isCoolingBed_1
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0xBD02             POP      {R1,PC}
   \                     ??isCoolingBed_1: (+1)
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xBD02             POP      {R1,PC}          ;; return
   \                     ??isCoolingBed_0:
   \       0x1C   0x....'....        DC32     _ZN11Temperature22target_temperature_bedE
   \       0x20   0x....'....        DC32     _ZN11Temperature23current_temperature_bedE
    229          #include "cardreader.h"

   \                                 In section .text, align 2
   \   __code __interwork __softfp SdBaseFile::subobject ~SdBaseFile()
   \                     _ZN10SdBaseFileD2Ev: (+1)
   \        0x0   0x.... 0x....      B.W      _ZN10SdBaseFileD1Ev

   \                                 In section .text, align 2
   \   __code __interwork __softfp SdBaseFile::~SdBaseFile()
   \                     _ZN10SdBaseFileD1Ev: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x.... 0x....      BL       _ZNK10SdBaseFile6isOpenEv
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD002             BEQ.N    `?~SdBaseFile_0`
   \        0xC   0x4620             MOV      R0,R4
   \        0xE   0x.... 0x....      BL       _ZN10SdBaseFile5closeEv
   \                     `?~SdBaseFile_0`: (+1)
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint32_t SdBaseFile::curPosition() const
   \                     _ZNK10SdBaseFile11curPositionEv: (+1)
   \        0x0   0x6880             LDR      R0,[R0, #+8]
   \        0x2   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp bool SdBaseFile::isOpen() const
   \                     _ZNK10SdBaseFile6isOpenEv: (+1)
   \        0x0   0x78C0             LDRB     R0,[R0, #+3]
   \        0x2   0x1E40             SUBS     R0,R0,#+1
   \        0x4   0x4180             SBCS     R0,R0,R0
   \        0x6   0x43C0             MVNS     R0,R0
   \        0x8   0x0FC0             LSRS     R0,R0,#+31
   \        0xA   0x4770             BX       LR               ;; return

  #define PSTR(str) (str)
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\arduino\avr\pgmspace.h",8  Warning[Pa181]: 
          incompatible redefinition of macro "PSTR" (declared at line 59 of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marl
          in\Marlin.h")

  #define strcpy_P(dest, src) strcpy((dest), (src))
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\arduino\avr\pgmspace.h",23  Warning[Pa181]: 
          incompatible redefinition of macro "strcpy_P" (declared at line 93 of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marl
          in\Marlin_export.h")

  #define strstr_P(a, b) strstr((a), (b))
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\arduino\avr\pgmspace.h",26  Warning[Pa181]: 
          incompatible redefinition of macro "strstr_P" (declared at line 94 of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marl
          in\Marlin_export.h")

  #define sprintf_P(s, f, ...) sprintf((s), (f), __VA_ARGS__)
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\arduino\avr\pgmspace.h",28  Warning[Pa181]: 
          incompatible redefinition of macro "sprintf_P" (declared at line 95
          of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marl
          in\Marlin_export.h")

  #define pgm_read_word_near(addr) pgm_read_word(addr)
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\arduino\avr\pgmspace.h",36  Warning[Pa181]: 
          incompatible redefinition of macro "pgm_read_word_near" (declared at
          line 65 of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marl
          in\Marlin_export.h")

   \                                 In section .text, align 2

  class SdFile : public SdBaseFile, public Print {
        ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\SdFile.h",45  Warning[Pe611]: 
          overloaded virtual function "Print::write" is only partially
          overridden in class "SdFile"
   \   __code __interwork __softfp SdFile::~SdFile()
   \                     _ZN6SdFileD1Ev: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0xF104 0x0008      ADD      R0,R4,#+8
   \        0x8   0x.... 0x....      BL       _ZN10SdBaseFileD2Ev
   \        0xC   0x4620             MOV      R0,R4
   \        0xE   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4
   \   __code __interwork __softfp CardReader::~CardReader()
   \                     _ZN10CardReaderD1Ev: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0xF504 0x7013      ADD      R0,R4,#+588
   \        0x8   0x.... 0x....      BL       _ZN6SdFileD1Ev
   \        0xC   0x230A             MOVS     R3,#+10
   \        0xE   0x2228             MOVS     R2,#+40
   \       0x10   0x4907             LDR.N    R1,`?~CardReader_0`
   \       0x12   0xF104 0x008C      ADD      R0,R4,#+140
   \       0x16   0x.... 0x....      BL       __aeabi_vec_dtor
   \       0x1A   0xF104 0x0064      ADD      R0,R4,#+100
   \       0x1E   0x.... 0x....      BL       _ZN6SdFileD1Ev
   \       0x22   0xF104 0x0038      ADD      R0,R4,#+56
   \       0x26   0x.... 0x....      BL       _ZN6SdFileD1Ev
   \       0x2A   0x4620             MOV      R0,R4
   \       0x2C   0xBD10             POP      {R4,PC}          ;; return
   \       0x2E   0xBF00             Nop      
   \                     `?~CardReader_0`:
   \       0x30   0x....'....        DC32     _ZN6SdFileD1Ev

   \                                 In section .text, align 2
   \   __interwork __softfp void CardReader::pauseSDPrint()
   \                     _ZN10CardReader12pauseSDPrintEv: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x7081             STRB     R1,[R0, #+2]
   \        0x4   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp bool CardReader::isFileOpen()
   \                     _ZN10CardReader10isFileOpenEv: (+1)
   \        0x0   0xF500 0x7015      ADD      R0,R0,#+596
   \        0x4   0x.... 0x....      B.W      _ZNK10SdBaseFile6isOpenEv

   \                                 In section .text, align 2
   \   __interwork __softfp bool CardReader::eof()
   \                     _ZN10CardReader3eofEv: (+1)
   \        0x0   0x6B41             LDR      R1,[R0, #+52]
   \        0x2   0xF8D0 0x030C      LDR      R0,[R0, #+780]
   \        0x6   0x4281             CMP      R1,R0
   \        0x8   0x4180             SBCS     R0,R0,R0
   \        0xA   0x43C0             MVNS     R0,R0
   \        0xC   0x0FC0             LSRS     R0,R0,#+31
   \        0xE   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp int16_t CardReader::get()
   \                     _ZN10CardReader3getEv: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0xF504 0x7515      ADD      R5,R4,#+596
   \        0x8   0x4628             MOV      R0,R5
   \        0xA   0x.... 0x....      BL       _ZNK10SdBaseFile11curPositionEv
   \        0xE   0x6360             STR      R0,[R4, #+52]
   \       0x10   0x4628             MOV      R0,R5
   \       0x12   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \       0x16   0x.... 0x....      B.W      _ZN10SdBaseFile4readEv

   \                                 In section .text, align 2
   \   __interwork __softfp void CardReader::setIndex(long)
   \                     _ZN10CardReader8setIndexEl: (+1)
   \        0x0   0x6341             STR      R1,[R0, #+52]
   \        0x2   0xF500 0x7015      ADD      R0,R0,#+596
   \        0x6   0x.... 0x....      B.W      _ZN10SdBaseFile7seekSetEj

    FORCE_INLINE bool renameFile(const char * newPath){ file.rename(curDir, newPath);}
                                                                                     ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\cardreader.h",99  Warning[Pe940]: 
          missing return statement at end of non-void function
          "CardReader::renameFile"

   \                                 In section .text, align 2
   \   __interwork __softfp bool CardReader::lastOpenOk()
   \                     _ZN10CardReader10lastOpenOkEv: (+1)
   \        0x0   0xF890 0x031C      LDRB     R0,[R0, #+796]
   \        0x4   0x4770             BX       LR               ;; return
    230          #include "configuration_store.h"
    231          #include "language.h"
    232          //#include "pins_arduino.h"
    233          #include "math.h"
    234          #include "nozzle.h"
    235          #include "duration_t.h"

   \                                 In section .text, align 2
   \   __code __interwork __softfp duration_t::duration_t(uint32_t const &)
   \                     _ZN10duration_tC1ERKj: (+1)
   \        0x0   0x6809             LDR      R1,[R1, #+0]
   \        0x2   0x6001             STR      R1,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint8_t duration_t::year() const
   \                     _ZNK10duration_t4yearEv: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x.... 0x....      BL       _ZNK10duration_t3dayEv
   \        0x6   0xF240 0x116D      MOVW     R1,#+365
   \        0xA   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \        0xE   0xB2C0             UXTB     R0,R0
   \       0x10   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint16_t duration_t::day() const
   \                     _ZNK10duration_t3dayEv: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x.... 0x....      BL       _ZNK10duration_t4hourEv
   \        0x6   0x2118             MOVS     R1,#+24
   \        0x8   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \        0xC   0xB280             UXTH     R0,R0
   \        0xE   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint32_t duration_t::hour() const
   \                     _ZNK10duration_t4hourEv: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x.... 0x....      BL       _ZNK10duration_t6minuteEv
   \        0x6   0x213C             MOVS     R1,#+60
   \        0x8   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \        0xC   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint32_t duration_t::minute() const
   \                     _ZNK10duration_t6minuteEv: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x.... 0x....      BL       _ZNK10duration_t6secondEv
   \        0x6   0x213C             MOVS     R1,#+60
   \        0x8   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \        0xC   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint32_t duration_t::second() const
   \                     _ZNK10duration_t6secondEv: (+1)
   \        0x0   0x6800             LDR      R0,[R0, #+0]
   \        0x2   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4
   \   __interwork __softfp void duration_t::toString(char *) const
   \                     _ZNK10duration_t8toStringEPc: (+1)
   \        0x0   0xE92D 0x47FF      PUSH     {R0-R10,LR}
   \        0x4   0x4682             MOV      R10,R0
   \        0x6   0x4688             MOV      R8,R1
   \        0x8   0x.... 0x....      BL       _ZNK10duration_t4yearEv
   \        0xC   0x4604             MOV      R4,R0
   \        0xE   0x4650             MOV      R0,R10
   \       0x10   0x.... 0x....      BL       _ZNK10duration_t3dayEv
   \       0x14   0xF240 0x116D      MOVW     R1,#+365
   \       0x18   0xFB90 0xF7F1      SDIV     R7,R0,R1
   \       0x1C   0xFB01 0x0717      MLS      R7,R1,R7,R0
   \       0x20   0x4650             MOV      R0,R10
   \       0x22   0x.... 0x....      BL       _ZNK10duration_t4hourEv
   \       0x26   0x4605             MOV      R5,R0
   \       0x28   0x2018             MOVS     R0,#+24
   \       0x2A   0xFBB5 0xF0F0      UDIV     R0,R5,R0
   \       0x2E   0xEB00 0x0140      ADD      R1,R0,R0, LSL #+1
   \       0x32   0xEBA5 0x05C1      SUB      R5,R5,R1, LSL #+3
   \       0x36   0x4650             MOV      R0,R10
   \       0x38   0x.... 0x....      BL       _ZNK10duration_t6minuteEv
   \       0x3C   0xF04F 0x093C      MOV      R9,#+60
   \       0x40   0x4649             MOV      R1,R9
   \       0x42   0xFBB0 0xF6F1      UDIV     R6,R0,R1
   \       0x46   0xFB09 0x0616      MLS      R6,R9,R6,R0
   \       0x4A   0x4650             MOV      R0,R10
   \       0x4C   0x.... 0x....      BL       _ZNK10duration_t6secondEv
   \       0x50   0x4649             MOV      R1,R9
   \       0x52   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \       0x56   0xFB09 0x0212      MLS      R2,R9,R2,R0
   \       0x5A   0x2C00             CMP      R4,#+0
   \       0x5C   0xD009             BEQ.N    ??toString_1
   \       0x5E   0x9202             STR      R2,[SP, #+8]
   \       0x60   0x9601             STR      R6,[SP, #+4]
   \       0x62   0x9500             STR      R5,[SP, #+0]
   \       0x64   0x463B             MOV      R3,R7
   \       0x66   0x4622             MOV      R2,R4
   \       0x68   0x4916             LDR.N    R1,??toString_0
   \       0x6A   0x4640             MOV      R0,R8
   \       0x6C   0x.... 0x....      BL       sprintf
   \       0x70   0xE026             B.N      ??toString_2
   \                     ??toString_1: (+1)
   \       0x72   0x2F00             CMP      R7,#+0
   \       0x74   0xD008             BEQ.N    ??toString_3
   \       0x76   0x9201             STR      R2,[SP, #+4]
   \       0x78   0x9600             STR      R6,[SP, #+0]
   \       0x7A   0x462B             MOV      R3,R5
   \       0x7C   0x463A             MOV      R2,R7
   \       0x7E   0x4912             LDR.N    R1,??toString_0+0x4
   \       0x80   0x4640             MOV      R0,R8
   \       0x82   0x.... 0x....      BL       sprintf
   \       0x86   0xE01B             B.N      ??toString_2
   \                     ??toString_3: (+1)
   \       0x88   0x2D00             CMP      R5,#+0
   \       0x8A   0xD007             BEQ.N    ??toString_4
   \       0x8C   0x9200             STR      R2,[SP, #+0]
   \       0x8E   0x4633             MOV      R3,R6
   \       0x90   0x462A             MOV      R2,R5
   \       0x92   0x490E             LDR.N    R1,??toString_0+0x8
   \       0x94   0x4640             MOV      R0,R8
   \       0x96   0x.... 0x....      BL       sprintf
   \       0x9A   0xE011             B.N      ??toString_2
   \                     ??toString_4: (+1)
   \       0x9C   0x2E00             CMP      R6,#+0
   \       0x9E   0xD008             BEQ.N    ??toString_5
   \       0xA0   0x4613             MOV      R3,R2
   \       0xA2   0x4632             MOV      R2,R6
   \       0xA4   0x490A             LDR.N    R1,??toString_0+0xC
   \       0xA6   0x4640             MOV      R0,R8
   \       0xA8   0xB004             ADD      SP,SP,#+16
   \       0xAA   0xE8BD 0x47F0      POP      {R4-R10,LR}
   \       0xAE   0x.... 0x....      B.W      sprintf
   \                     ??toString_5: (+1)
   \       0xB2   0x4908             LDR.N    R1,??toString_0+0x10
   \       0xB4   0x4640             MOV      R0,R8
   \       0xB6   0xB004             ADD      SP,SP,#+16
   \       0xB8   0xE8BD 0x47F0      POP      {R4-R10,LR}
   \       0xBC   0x.... 0x....      B.W      sprintf
   \                     ??toString_2: (+1)
   \       0xC0   0xE8BD 0x87FF      POP      {R0-R10,PC}      ;; return
   \                     ??toString_0:
   \       0xC4   0x....'....        DC32     _ZZNK10duration_t8toStringEPcEs
   \       0xC8   0x....'....        DC32     _ZZNK10duration_t8toStringEPcEs_0
   \       0xCC   0x....'....        DC32     _ZZNK10duration_t8toStringEPcEs_1
   \       0xD0   0x....'....        DC32     _ZZNK10duration_t8toStringEPcEs_2
   \       0xD4   0x....'....        DC32     _ZZNK10duration_t8toStringEPcEs_3
    236          //#include "types.h"
    237          #include "tim.h"
    238          //#include <stdlib.h>
    239          #include "mks_reprint.h"

   \                                 In section .text, align 2
   \   __code __interwork __softfp DATA_REPRINT_ITMES::<_ZN18DATA_REPRINT_ITMESC1Ev>()
   \                     _ZN18DATA_REPRINT_ITMESC1Ev: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0xF104 0x00F4      ADD      R0,R4,#+244
   \        0x8   0x.... 0x....      BL       _ZN10CardReaderC1Ev
   \        0xC   0x4620             MOV      R0,R4
   \        0xE   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2
   \   __code __interwork __softfp DATA_REPRINT_ITMES::~<unnamed>()
   \                     _ZN18DATA_REPRINT_ITMESD1Ev: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0xF104 0x00F4      ADD      R0,R4,#+244
   \        0x8   0x.... 0x....      BL       _ZN10CardReaderD1Ev
   \        0xC   0x4620             MOV      R0,R4
   \        0xE   0xBD10             POP      {R4,PC}          ;; return
    240          #ifdef USE_MKS_WIFI
    241          #include "wifi_module.h"
    242          #endif
    243          #include "nano.h"
    244          
    245          volatile uint8_t mks_heating_busy = 0;
    246          
    247          
    248          /*--mks cfg--begin MESH_BED_LEVELING */
    249          /*
    250          #if HAS_ABL
    251            #include "vector_3.h"
    252            #if ENABLED(AUTO_BED_LEVELING_LINEAR)
    253              #include "qr_solve.h"
    254            #endif
    255          #elif ENABLED(MESH_BED_LEVELING)
    256            #include "mesh_bed_leveling.h"
    257          #endif
    258          */
    259          	#include "vector_3.h"
    260          	#include "qr_solve.h"
    261          	#include "mesh_bed_leveling.h"

   \                                 In section .text, align 4
   \   __interwork __softfp void mesh_bed_leveling::set_z(int8_t, int8_t, float const &)
   \                     _ZN17mesh_bed_leveling5set_zEaaRKf: (+1)
   \        0x0   0x4B03             LDR.N    R3,??set_z_0
   \        0x2   0xEB03 0x1080      ADD      R0,R3,R0, LSL #+6
   \        0x6   0x6812             LDR      R2,[R2, #+0]
   \        0x8   0xF840 0x2021      STR      R2,[R0, R1, LSL #+2]
   \        0xC   0x4770             BX       LR               ;; return
   \        0xE   0xBF00             Nop      
   \                     ??set_z_0:
   \       0x10   0x....'....        DC32     _ZN17mesh_bed_leveling8z_valuesE

   \                                 In section .text, align 4
   \   __interwork __softfp bool mesh_bed_leveling::active()
   \                     _ZN17mesh_bed_leveling6activeEv: (+1)
   \        0x0   0x4802             LDR.N    R0,??active_0
   \        0x2   0x7800             LDRB     R0,[R0, #+0]
   \        0x4   0x0840             LSRS     R0,R0,#+1
   \        0x6   0xF000 0x0001      AND      R0,R0,#0x1
   \        0xA   0x4770             BX       LR               ;; return
   \                     ??active_0:
   \        0xC   0x....'....        DC32     _ZN17mesh_bed_leveling6statusE

   \                                 In section .text, align 4
   \   __interwork __softfp void mesh_bed_leveling::set_active(bool)
   \                     _ZN17mesh_bed_leveling10set_activeEb: (+1)
   \        0x0   0x4905             LDR.N    R1,??set_active_0
   \        0x2   0x780A             LDRB     R2,[R1, #+0]
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD003             BEQ.N    ??set_active_1
   \        0x8   0xF042 0x0202      ORR      R2,R2,#0x2
   \        0xC   0x700A             STRB     R2,[R1, #+0]
   \        0xE   0x4770             BX       LR
   \                     ??set_active_1: (+1)
   \       0x10   0xF002 0x02FD      AND      R2,R2,#0xFD
   \       0x14   0x700A             STRB     R2,[R1, #+0]
   \       0x16   0x4770             BX       LR               ;; return
   \                     ??set_active_0:
   \       0x18   0x....'....        DC32     _ZN17mesh_bed_leveling6statusE

   \                                 In section .text, align 4
   \   __interwork __softfp bool mesh_bed_leveling::has_mesh()
   \                     _ZN17mesh_bed_leveling8has_meshEv: (+1)
   \        0x0   0x4802             LDR.N    R0,??has_mesh_0
   \        0x2   0x7800             LDRB     R0,[R0, #+0]
   \        0x4   0xF000 0x0001      AND      R0,R0,#0x1
   \        0x8   0x4770             BX       LR               ;; return
   \        0xA   0xBF00             Nop      
   \                     ??has_mesh_0:
   \        0xC   0x....'....        DC32     _ZN17mesh_bed_leveling6statusE

   \                                 In section .text, align 4
   \   __interwork __softfp void mesh_bed_leveling::set_has_mesh(bool)
   \                     _ZN17mesh_bed_leveling12set_has_meshEb: (+1)
   \        0x0   0x4905             LDR.N    R1,??set_has_mesh_0
   \        0x2   0x780A             LDRB     R2,[R1, #+0]
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD003             BEQ.N    ??set_has_mesh_1
   \        0x8   0xF042 0x0201      ORR      R2,R2,#0x1
   \        0xC   0x700A             STRB     R2,[R1, #+0]
   \        0xE   0x4770             BX       LR
   \                     ??set_has_mesh_1: (+1)
   \       0x10   0xF002 0x02FE      AND      R2,R2,#0xFE
   \       0x14   0x700A             STRB     R2,[R1, #+0]
   \       0x16   0x4770             BX       LR               ;; return
   \                     ??set_has_mesh_0:
   \       0x18   0x....'....        DC32     _ZN17mesh_bed_leveling6statusE

   \                                 In section .text, align 4
   \   __interwork __softfp void mesh_bed_leveling::zigzag(int8_t, int8_t &, int8_t &)
   \                     _ZN17mesh_bed_leveling6zigzagEaRaS0_: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
   \        0x2   0x4B0C             LDR.N    R3,??zigzag_0
   \        0x4   0xF893 0x4060      LDRB     R4,[R3, #+96]
   \        0x8   0xFB90 0xF5F4      SDIV     R5,R0,R4
   \        0xC   0xFB04 0x0415      MLS      R4,R4,R5,R0
   \       0x10   0x700C             STRB     R4,[R1, #+0]
   \       0x12   0xF893 0x4060      LDRB     R4,[R3, #+96]
   \       0x16   0xFB90 0xF0F4      SDIV     R0,R0,R4
   \       0x1A   0x7010             STRB     R0,[R2, #+0]
   \       0x1C   0x7810             LDRB     R0,[R2, #+0]
   \       0x1E   0x07C0             LSLS     R0,R0,#+31
   \       0x20   0xD505             BPL.N    ??zigzag_1
   \       0x22   0xF993 0x0060      LDRSB    R0,[R3, #+96]
   \       0x26   0x1E42             SUBS     R2,R0,#+1
   \       0x28   0x7808             LDRB     R0,[R1, #+0]
   \       0x2A   0x1A12             SUBS     R2,R2,R0
   \       0x2C   0x700A             STRB     R2,[R1, #+0]
   \                     ??zigzag_1: (+1)
   \       0x2E   0xBC30             POP      {R4,R5}
   \       0x30   0x4770             BX       LR               ;; return
   \       0x32   0xBF00             Nop      
   \                     ??zigzag_0:
   \       0x34   0x....'....        DC32     mksCfg

   \                                 In section .text, align 2
   \   __interwork __softfp void mesh_bed_leveling::set_zigzag_z(int8_t, float const &)
   \                     _ZN17mesh_bed_leveling12set_zigzag_zEaRKf: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x460C             MOV      R4,R1
   \        0x4   0x466A             MOV      R2,SP
   \        0x6   0xF10D 0x0101      ADD      R1,SP,#+1
   \        0xA   0x.... 0x....      BL       _ZN17mesh_bed_leveling6zigzagEaRaS0_
   \        0xE   0x4622             MOV      R2,R4
   \       0x10   0xF99D 0x1000      LDRSB    R1,[SP, #+0]
   \       0x14   0xF99D 0x0001      LDRSB    R0,[SP, #+1]
   \       0x18   0x.... 0x....      BL       _ZN17mesh_bed_leveling5set_zEaaRKf
   \       0x1C   0xBD13             POP      {R0,R1,R4,PC}    ;; return

   \                                 In section .text, align 4
   \   __interwork __softfp int8_t mesh_bed_leveling::cell_index_x(float const &)
   \                     _ZN17mesh_bed_leveling12cell_index_xERKf: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4681             MOV      R9,R0

        int8_t cx = (x - (MESH_MIN_X)) * (1.0 / (MESH_X_DIST));
                    ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",85  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \        0x6   0x4E20             LDR.N    R6,??cell_index_x_0
   \        0x8   0xF896 0x0098      LDRB     R0,[R6, #+152]
   \        0xC   0x.... 0x....      BL       __aeabi_ui2f
   \       0x10   0x4607             MOV      R7,R0
   \       0x12   0x68B0             LDR      R0,[R6, #+8]
   \       0x14   0x4639             MOV      R1,R7
   \       0x16   0x.... 0x....      BL       __aeabi_fadd
   \       0x1A   0x4680             MOV      R8,R0
   \       0x1C   0xF896 0x4060      LDRB     R4,[R6, #+96]
   \       0x20   0x4625             MOV      R5,R4
   \       0x22   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x26   0x4641             MOV      R1,R8
   \       0x28   0x.... 0x....      BL       __aeabi_fsub
   \       0x2C   0x.... 0x....      BL       __aeabi_f2d
   \       0x30   0x4682             MOV      R10,R0
   \       0x32   0x468B             MOV      R11,R1
   \       0x34   0x6970             LDR      R0,[R6, #+20]
   \       0x36   0x4639             MOV      R1,R7
   \       0x38   0x.... 0x....      BL       __aeabi_fsub
   \       0x3C   0x4641             MOV      R1,R8
   \       0x3E   0x.... 0x....      BL       __aeabi_fsub
   \       0x42   0x4606             MOV      R6,R0
   \       0x44   0x1E68             SUBS     R0,R5,#+1
   \       0x46   0x.... 0x....      BL       __aeabi_i2f
   \       0x4A   0x4601             MOV      R1,R0
   \       0x4C   0x4630             MOV      R0,R6
   \       0x4E   0x.... 0x....      BL       __aeabi_fdiv
   \       0x52   0x.... 0x....      BL       __aeabi_f2d
   \       0x56   0x4602             MOV      R2,R0
   \       0x58   0x460B             MOV      R3,R1
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0x490B             LDR.N    R1,??cell_index_x_0+0x4  ;; 0x3ff00000
   \       0x5E   0x.... 0x....      BL       __aeabi_ddiv
   \       0x62   0x4652             MOV      R2,R10
   \       0x64   0x465B             MOV      R3,R11
   \       0x66   0x.... 0x....      BL       __aeabi_dmul
   \       0x6A   0x.... 0x....      BL       __aeabi_d2iz
   \       0x6E   0x4601             MOV      R1,R0
   \       0x70   0xB249             SXTB     R1,R1
   \       0x72   0x2900             CMP      R1,#+0
   \       0x74   0xD501             BPL.N    ??cell_index_x_1
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0xE003             B.N      ??cell_index_x_2
   \                     ??cell_index_x_1: (+1)
   \       0x7A   0x1EAD             SUBS     R5,R5,#+2
   \       0x7C   0x428D             CMP      R5,R1
   \       0x7E   0xDA00             BGE.N    ??cell_index_x_2
   \       0x80   0x1EA0             SUBS     R0,R4,#+2
   \                     ??cell_index_x_2: (+1)
   \       0x82   0xB240             SXTB     R0,R0
   \       0x84   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \                     ??cell_index_x_0:
   \       0x88   0x....'....        DC32     mksCfg
   \       0x8C   0x3FF0'0000        DC32     0x3ff00000

   \                                 In section .text, align 4
   \   __interwork __softfp int8_t mesh_bed_leveling::cell_index_y(float const &)
   \                     _ZN17mesh_bed_leveling12cell_index_yERKf: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4681             MOV      R9,R0

        int8_t cy = (y - (MESH_MIN_Y)) * (1.0 / (MESH_Y_DIST));
                    ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",90  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \        0x6   0x4E20             LDR.N    R6,??cell_index_y_0
   \        0x8   0xF896 0x0098      LDRB     R0,[R6, #+152]
   \        0xC   0x.... 0x....      BL       __aeabi_ui2f
   \       0x10   0x4607             MOV      R7,R0
   \       0x12   0x68F0             LDR      R0,[R6, #+12]
   \       0x14   0x4639             MOV      R1,R7
   \       0x16   0x.... 0x....      BL       __aeabi_fadd
   \       0x1A   0x4680             MOV      R8,R0
   \       0x1C   0xF896 0x4061      LDRB     R4,[R6, #+97]
   \       0x20   0x4625             MOV      R5,R4
   \       0x22   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x26   0x4641             MOV      R1,R8
   \       0x28   0x.... 0x....      BL       __aeabi_fsub
   \       0x2C   0x.... 0x....      BL       __aeabi_f2d
   \       0x30   0x4682             MOV      R10,R0
   \       0x32   0x468B             MOV      R11,R1
   \       0x34   0x69B0             LDR      R0,[R6, #+24]
   \       0x36   0x4639             MOV      R1,R7
   \       0x38   0x.... 0x....      BL       __aeabi_fsub
   \       0x3C   0x4641             MOV      R1,R8
   \       0x3E   0x.... 0x....      BL       __aeabi_fsub
   \       0x42   0x4606             MOV      R6,R0
   \       0x44   0x1E68             SUBS     R0,R5,#+1
   \       0x46   0x.... 0x....      BL       __aeabi_i2f
   \       0x4A   0x4601             MOV      R1,R0
   \       0x4C   0x4630             MOV      R0,R6
   \       0x4E   0x.... 0x....      BL       __aeabi_fdiv
   \       0x52   0x.... 0x....      BL       __aeabi_f2d
   \       0x56   0x4602             MOV      R2,R0
   \       0x58   0x460B             MOV      R3,R1
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0x490B             LDR.N    R1,??cell_index_y_0+0x4  ;; 0x3ff00000
   \       0x5E   0x.... 0x....      BL       __aeabi_ddiv
   \       0x62   0x4652             MOV      R2,R10
   \       0x64   0x465B             MOV      R3,R11
   \       0x66   0x.... 0x....      BL       __aeabi_dmul
   \       0x6A   0x.... 0x....      BL       __aeabi_d2iz
   \       0x6E   0x4601             MOV      R1,R0
   \       0x70   0xB249             SXTB     R1,R1
   \       0x72   0x2900             CMP      R1,#+0
   \       0x74   0xD501             BPL.N    ??cell_index_y_1
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0xE003             B.N      ??cell_index_y_2
   \                     ??cell_index_y_1: (+1)
   \       0x7A   0x1EAD             SUBS     R5,R5,#+2
   \       0x7C   0x428D             CMP      R5,R1
   \       0x7E   0xDA00             BGE.N    ??cell_index_y_2
   \       0x80   0x1EA0             SUBS     R0,R4,#+2
   \                     ??cell_index_y_2: (+1)
   \       0x82   0xB240             SXTB     R0,R0
   \       0x84   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \                     ??cell_index_y_0:
   \       0x88   0x....'....        DC32     mksCfg
   \       0x8C   0x3FF0'0000        DC32     0x3ff00000

   \                                 In section .text, align 4
   \   __interwork __softfp int8_t mesh_bed_leveling::probe_index_x(float const &)
   \                     _ZN17mesh_bed_leveling13probe_index_xERKf: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4604             MOV      R4,R0

        int8_t px = (x - (MESH_MIN_X) + 0.5 * (MESH_X_DIST)) * (1.0 / (MESH_X_DIST));
                    ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",95  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \        0x6   0x4D26             LDR.N    R5,??probe_index_x_0
   \        0x8   0xF895 0x6060      LDRB     R6,[R5, #+96]
   \        0xC   0x1E76             SUBS     R6,R6,#+1
   \        0xE   0xF895 0x0098      LDRB     R0,[R5, #+152]
   \       0x12   0x.... 0x....      BL       __aeabi_ui2f
   \       0x16   0x4607             MOV      R7,R0
   \       0x18   0x68A8             LDR      R0,[R5, #+8]
   \       0x1A   0x4639             MOV      R1,R7
   \       0x1C   0x.... 0x....      BL       __aeabi_fadd
   \       0x20   0x4680             MOV      R8,R0
   \       0x22   0x6968             LDR      R0,[R5, #+20]
   \       0x24   0x4639             MOV      R1,R7
   \       0x26   0x.... 0x....      BL       __aeabi_fsub
   \       0x2A   0x4641             MOV      R1,R8
   \       0x2C   0x.... 0x....      BL       __aeabi_fsub
   \       0x30   0x4605             MOV      R5,R0
   \       0x32   0x4630             MOV      R0,R6
   \       0x34   0x.... 0x....      BL       __aeabi_i2f
   \       0x38   0x4601             MOV      R1,R0
   \       0x3A   0x4628             MOV      R0,R5
   \       0x3C   0x.... 0x....      BL       __aeabi_fdiv
   \       0x40   0x4607             MOV      R7,R0
   \       0x42   0x6820             LDR      R0,[R4, #+0]
   \       0x44   0x4641             MOV      R1,R8
   \       0x46   0x.... 0x....      BL       __aeabi_fsub
   \       0x4A   0x.... 0x....      BL       __aeabi_f2d
   \       0x4E   0x4604             MOV      R4,R0
   \       0x50   0x460D             MOV      R5,R1
   \       0x52   0x4638             MOV      R0,R7
   \       0x54   0x.... 0x....      BL       __aeabi_f2d
   \       0x58   0x2200             MOVS     R2,#+0
   \       0x5A   0x4B12             LDR.N    R3,??probe_index_x_0+0x4  ;; 0x3fe00000
   \       0x5C   0x.... 0x....      BL       __aeabi_dmul
   \       0x60   0x4622             MOV      R2,R4
   \       0x62   0x462B             MOV      R3,R5
   \       0x64   0x.... 0x....      BL       __aeabi_dadd
   \       0x68   0x4604             MOV      R4,R0
   \       0x6A   0x460D             MOV      R5,R1
   \       0x6C   0x4638             MOV      R0,R7
   \       0x6E   0x.... 0x....      BL       __aeabi_f2d
   \       0x72   0x4602             MOV      R2,R0
   \       0x74   0x460B             MOV      R3,R1
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0x490B             LDR.N    R1,??probe_index_x_0+0x8  ;; 0x3ff00000
   \       0x7A   0x.... 0x....      BL       __aeabi_ddiv
   \       0x7E   0x4622             MOV      R2,R4
   \       0x80   0x462B             MOV      R3,R5
   \       0x82   0x.... 0x....      BL       __aeabi_dmul
   \       0x86   0x.... 0x....      BL       __aeabi_d2iz
   \       0x8A   0x4601             MOV      R1,R0
   \       0x8C   0xB249             SXTB     R1,R1
   \       0x8E   0x2900             CMP      R1,#+0
   \       0x90   0xD401             BMI.N    ??probe_index_x_1
   \       0x92   0x428E             CMP      R6,R1
   \       0x94   0xDA01             BGE.N    ??probe_index_x_2
   \                     ??probe_index_x_1: (+1)
   \       0x96   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??probe_index_x_2: (+1)
   \       0x9A   0xB240             SXTB     R0,R0
   \       0x9C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   \                     ??probe_index_x_0:
   \       0xA0   0x....'....        DC32     mksCfg
   \       0xA4   0x3FE0'0000        DC32     0x3fe00000
   \       0xA8   0x3FF0'0000        DC32     0x3ff00000

   \                                 In section .text, align 4
   \   __interwork __softfp int8_t mesh_bed_leveling::probe_index_y(float const &)
   \                     _ZN17mesh_bed_leveling13probe_index_yERKf: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4604             MOV      R4,R0

        int8_t py = (y - (MESH_MIN_Y) + 0.5 * (MESH_Y_DIST)) * (1.0 / (MESH_Y_DIST));
                    ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",100  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \        0x6   0x4D26             LDR.N    R5,??probe_index_y_0
   \        0x8   0xF895 0x6061      LDRB     R6,[R5, #+97]
   \        0xC   0x1E76             SUBS     R6,R6,#+1
   \        0xE   0xF895 0x0098      LDRB     R0,[R5, #+152]
   \       0x12   0x.... 0x....      BL       __aeabi_ui2f
   \       0x16   0x4607             MOV      R7,R0
   \       0x18   0x68E8             LDR      R0,[R5, #+12]
   \       0x1A   0x4639             MOV      R1,R7
   \       0x1C   0x.... 0x....      BL       __aeabi_fadd
   \       0x20   0x4680             MOV      R8,R0
   \       0x22   0x69A8             LDR      R0,[R5, #+24]
   \       0x24   0x4639             MOV      R1,R7
   \       0x26   0x.... 0x....      BL       __aeabi_fsub
   \       0x2A   0x4641             MOV      R1,R8
   \       0x2C   0x.... 0x....      BL       __aeabi_fsub
   \       0x30   0x4605             MOV      R5,R0
   \       0x32   0x4630             MOV      R0,R6
   \       0x34   0x.... 0x....      BL       __aeabi_i2f
   \       0x38   0x4601             MOV      R1,R0
   \       0x3A   0x4628             MOV      R0,R5
   \       0x3C   0x.... 0x....      BL       __aeabi_fdiv
   \       0x40   0x4607             MOV      R7,R0
   \       0x42   0x6820             LDR      R0,[R4, #+0]
   \       0x44   0x4641             MOV      R1,R8
   \       0x46   0x.... 0x....      BL       __aeabi_fsub
   \       0x4A   0x.... 0x....      BL       __aeabi_f2d
   \       0x4E   0x4604             MOV      R4,R0
   \       0x50   0x460D             MOV      R5,R1
   \       0x52   0x4638             MOV      R0,R7
   \       0x54   0x.... 0x....      BL       __aeabi_f2d
   \       0x58   0x2200             MOVS     R2,#+0
   \       0x5A   0x4B12             LDR.N    R3,??probe_index_y_0+0x4  ;; 0x3fe00000
   \       0x5C   0x.... 0x....      BL       __aeabi_dmul
   \       0x60   0x4622             MOV      R2,R4
   \       0x62   0x462B             MOV      R3,R5
   \       0x64   0x.... 0x....      BL       __aeabi_dadd
   \       0x68   0x4604             MOV      R4,R0
   \       0x6A   0x460D             MOV      R5,R1
   \       0x6C   0x4638             MOV      R0,R7
   \       0x6E   0x.... 0x....      BL       __aeabi_f2d
   \       0x72   0x4602             MOV      R2,R0
   \       0x74   0x460B             MOV      R3,R1
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0x490B             LDR.N    R1,??probe_index_y_0+0x8  ;; 0x3ff00000
   \       0x7A   0x.... 0x....      BL       __aeabi_ddiv
   \       0x7E   0x4622             MOV      R2,R4
   \       0x80   0x462B             MOV      R3,R5
   \       0x82   0x.... 0x....      BL       __aeabi_dmul
   \       0x86   0x.... 0x....      BL       __aeabi_d2iz
   \       0x8A   0x4601             MOV      R1,R0
   \       0x8C   0xB249             SXTB     R1,R1
   \       0x8E   0x2900             CMP      R1,#+0
   \       0x90   0xD401             BMI.N    ??probe_index_y_1
   \       0x92   0x428E             CMP      R6,R1
   \       0x94   0xDA01             BGE.N    ??probe_index_y_2
   \                     ??probe_index_y_1: (+1)
   \       0x96   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??probe_index_y_2: (+1)
   \       0x9A   0xB240             SXTB     R0,R0
   \       0x9C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   \                     ??probe_index_y_0:
   \       0xA0   0x....'....        DC32     mksCfg
   \       0xA4   0x3FE0'0000        DC32     0x3fe00000
   \       0xA8   0x3FF0'0000        DC32     0x3ff00000
    262          
    263          /*--mks cfg--end MESH_BED_LEVELING */
    264          
    265          #if ENABLED(BEZIER_CURVE_SUPPORT)
    266            #include "planner_bezier.h"
    267          #endif
    268          
    269          #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
    270            #include "buzzer.h"

   \                                 In section .text, align 2
   \   __code __interwork __softfp CircularQueue<tone_t, (uint8_t)'\004'>::CircularQueue()
   \                     _ZN13CircularQueueI6tone_tLh4EEC1Ev: (+1)
   \        0x0   0x2104             MOVS     R1,#+4
   \        0x2   0x70C1             STRB     R1,[R0, #+3]
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x7041             STRB     R1,[R0, #+1]
   \        0x8   0x7001             STRB     R1,[R0, #+0]
   \        0xA   0x7081             STRB     R1,[R0, #+2]
   \        0xC   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp tone_t CircularQueue<tone_t, (uint8_t)'\004'>::dequeue()
   \                     _ZN13CircularQueueI6tone_tLh4EE7dequeueEv: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x.... 0x....      BL       _ZN13CircularQueueI6tone_tLh4EE7isEmptyEv
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD006             BEQ.N    ??dequeue_0
   \        0xC   0x2200             MOVS     R2,#+0
   \        0xE   0x2104             MOVS     R1,#+4
   \       0x10   0x4668             MOV      R0,SP
   \       0x12   0x.... 0x....      BL       __aeabi_memset4
   \       0x16   0x9800             LDR      R0,[SP, #+0]
   \       0x18   0xBD16             POP      {R1,R2,R4,PC}
   \                     ??dequeue_0: (+1)
   \       0x1A   0x7820             LDRB     R0,[R4, #+0]
   \       0x1C   0x78A1             LDRB     R1,[R4, #+2]
   \       0x1E   0x1E49             SUBS     R1,R1,#+1
   \       0x20   0x70A1             STRB     R1,[R4, #+2]
   \       0x22   0x7821             LDRB     R1,[R4, #+0]
   \       0x24   0x1C49             ADDS     R1,R1,#+1
   \       0x26   0x7021             STRB     R1,[R4, #+0]
   \       0x28   0x78E2             LDRB     R2,[R4, #+3]
   \       0x2A   0xB2C9             UXTB     R1,R1
   \       0x2C   0x4291             CMP      R1,R2
   \       0x2E   0xD101             BNE.N    ??dequeue_1
   \       0x30   0x2100             MOVS     R1,#+0
   \       0x32   0x7021             STRB     R1,[R4, #+0]
   \                     ??dequeue_1: (+1)
   \       0x34   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \       0x38   0x6840             LDR      R0,[R0, #+4]
   \       0x3A   0x9000             STR      R0,[SP, #+0]
   \       0x3C   0xBD16             POP      {R1,R2,R4,PC}    ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp bool CircularQueue<tone_t, (uint8_t)'\004'>::enqueue(tone_t const &)
   \                     _ZN13CircularQueueI6tone_tLh4EE7enqueueERKS0_: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x.... 0x....      BL       _ZN13CircularQueueI6tone_tLh4EE6isFullEv
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD001             BEQ.N    ??enqueue_0
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??enqueue_0: (+1)
   \       0x12   0x7860             LDRB     R0,[R4, #+1]
   \       0x14   0xEB04 0x0080      ADD      R0,R4,R0, LSL #+2
   \       0x18   0x6829             LDR      R1,[R5, #+0]
   \       0x1A   0x6041             STR      R1,[R0, #+4]
   \       0x1C   0x78A0             LDRB     R0,[R4, #+2]
   \       0x1E   0x1C40             ADDS     R0,R0,#+1
   \       0x20   0x70A0             STRB     R0,[R4, #+2]
   \       0x22   0x7860             LDRB     R0,[R4, #+1]
   \       0x24   0x1C40             ADDS     R0,R0,#+1
   \       0x26   0x7060             STRB     R0,[R4, #+1]
   \       0x28   0x78E1             LDRB     R1,[R4, #+3]
   \       0x2A   0xB2C0             UXTB     R0,R0
   \       0x2C   0x4288             CMP      R0,R1
   \       0x2E   0xD101             BNE.N    ??enqueue_1
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x7060             STRB     R0,[R4, #+1]
   \                     ??enqueue_1: (+1)
   \       0x34   0x2001             MOVS     R0,#+1
   \       0x36   0xBD32             POP      {R1,R4,R5,PC}    ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp bool CircularQueue<tone_t, (uint8_t)'\004'>::isEmpty()
   \                     _ZN13CircularQueueI6tone_tLh4EE7isEmptyEv: (+1)
   \        0x0   0x7880             LDRB     R0,[R0, #+2]
   \        0x2   0x1E40             SUBS     R0,R0,#+1
   \        0x4   0x4180             SBCS     R0,R0,R0
   \        0x6   0x0FC0             LSRS     R0,R0,#+31
   \        0x8   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp bool CircularQueue<tone_t, (uint8_t)'\004'>::isFull()
   \                     _ZN13CircularQueueI6tone_tLh4EE6isFullEv: (+1)
   \        0x0   0x7881             LDRB     R1,[R0, #+2]
   \        0x2   0x78C0             LDRB     R0,[R0, #+3]
   \        0x4   0x4281             CMP      R1,R0
   \        0x6   0xD101             BNE.N    ??isFull_0
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0x4770             BX       LR
   \                     ??isFull_0: (+1)
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4
   \   __interwork __softfp void Buzzer::off()
   \                     _ZN6Buzzer3offEv: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   \        0x2   0x4804             LDR.N    R0,??off_0
   \        0x4   0xF8B0 0x1046      LDRH     R1,[R0, #+70]
   \        0x8   0x4803             LDR.N    R0,??off_0+0x4
   \        0xA   0xF8D0 0x008C      LDR      R0,[R0, #+140]
   \        0xE   0x.... 0x....      B.W      HAL_GPIO_WritePin
   \       0x12   0xBF00             Nop      
   \                     ??off_0:
   \       0x14   0x....'....        DC32     gArrayGpioPin
   \       0x18   0x....'....        DC32     gArrayGpioPort

   \                                 In section .text, align 4
   \   __interwork __softfp void Buzzer::on()
   \                     _ZN6Buzzer2onEv: (+1)
   \        0x0   0x2201             MOVS     R2,#+1
   \        0x2   0x4804             LDR.N    R0,??on_0
   \        0x4   0xF8B0 0x1046      LDRH     R1,[R0, #+70]
   \        0x8   0x4803             LDR.N    R0,??on_0+0x4
   \        0xA   0xF8D0 0x008C      LDR      R0,[R0, #+140]
   \        0xE   0x.... 0x....      B.W      HAL_GPIO_WritePin
   \       0x12   0xBF00             Nop      
   \                     ??on_0:
   \       0x14   0x....'....        DC32     gArrayGpioPin
   \       0x18   0x....'....        DC32     gArrayGpioPort

   \                                 In section .text, align 2
   \   __interwork __softfp void Buzzer::reset()
   \                     _ZN6Buzzer5resetEv: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x.... 0x....      BL       _ZN6Buzzer3offEv
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x60A0             STR      R0,[R4, #+8]
   \        0xC   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4
   \   __code __interwork __softfp Buzzer::Buzzer()
   \                     _ZN6BuzzerC1Ev: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x4805             LDR.N    R0,??Buzzer_0
   \        0x6   0x6020             STR      R0,[R4, #+0]
   \        0x8   0xF104 0x000C      ADD      R0,R4,#+12
   \        0xC   0x.... 0x....      BL       _ZN13CircularQueueI6tone_tLh4EEC1Ev
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0x.... 0x....      BL       _ZN6Buzzer5resetEv
   \       0x16   0x4620             MOV      R0,R4
   \       0x18   0xBD10             POP      {R4,PC}          ;; return
   \       0x1A   0xBF00             Nop      
   \                     ??Buzzer_0:
   \       0x1C   0x....'....        DC32     _ZTV6Buzzer+0x8

   \                                 In section .text, align 2
   \   __interwork __softfp void Buzzer::tone(uint16_t const &, uint16_t const &)
   \                     _ZN6Buzzer4toneERKtS1_: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
   \        0x8   0xE005             B.N      ??tone_0
   \                     ??tone_1: (+1)
   \        0xA   0x4620             MOV      R0,R4
   \        0xC   0x6821             LDR      R1,[R4, #+0]
   \        0xE   0x6809             LDR      R1,[R1, #+0]
   \       0x10   0x4788             BLX      R1
   \       0x12   0x.... 0x....      BL       _ZN11Temperature13manage_heaterEv
   \                     ??tone_0: (+1)
   \       0x16   0xF104 0x000C      ADD      R0,R4,#+12
   \       0x1A   0x.... 0x....      BL       _ZN13CircularQueueI6tone_tLh4EE6isFullEv
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD1F3             BNE.N    ??tone_1
   \       0x22   0x8828             LDRH     R0,[R5, #+0]
   \       0x24   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \       0x28   0x8830             LDRH     R0,[R6, #+0]
   \       0x2A   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   \       0x2E   0x4669             MOV      R1,SP
   \       0x30   0xF104 0x000C      ADD      R0,R4,#+12
   \       0x34   0x.... 0x....      BL       _ZN13CircularQueueI6tone_tLh4EE7enqueueERKS0_
   \       0x38   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void Buzzer::tick()
   \                     _ZN6Buzzer4tickEv: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x.... 0x....      BL       HAL_GetTick
   \        0x8   0x4605             MOV      R5,R0
   \        0xA   0x68A0             LDR      R0,[R4, #+8]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD115             BNE.N    ??tick_0
   \       0x10   0xF104 0x000C      ADD      R0,R4,#+12
   \       0x14   0x.... 0x....      BL       _ZN13CircularQueueI6tone_tLh4EE7isEmptyEv
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD116             BNE.N    ??tick_1
   \       0x1C   0xF104 0x000C      ADD      R0,R4,#+12
   \       0x20   0x.... 0x....      BL       _ZN13CircularQueueI6tone_tLh4EE7dequeueEv
   \       0x24   0x6060             STR      R0,[R4, #+4]
   \       0x26   0x88A0             LDRH     R0,[R4, #+4]
   \       0x28   0x1945             ADDS     R5,R0,R5
   \       0x2A   0x60A5             STR      R5,[R4, #+8]
   \       0x2C   0x88E0             LDRH     R0,[R4, #+6]
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD00B             BEQ.N    ??tick_1
   \       0x32   0x4620             MOV      R0,R4
   \       0x34   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \       0x38   0x.... 0x....      B.W      _ZN6Buzzer2onEv
   \                     ??tick_0: (+1)
   \       0x3C   0x1A2D             SUBS     R5,R5,R0
   \       0x3E   0xD404             BMI.N    ??tick_1
   \       0x40   0x4620             MOV      R0,R4
   \       0x42   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \       0x46   0x.... 0x....      B.W      _ZN6Buzzer5resetEv
   \                     ??tick_1: (+1)
   \       0x4A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    271          #endif
    272          
    273          #if ENABLED(USE_WATCHDOG)
    274            #include "watchdog.h"
    275          #endif
    276          
    277          #if ENABLED(BLINKM)
    278            #include "blinkm.h"
    279            #include "Wire.h"
    280          #endif
    281          
    282          #if HAS_SERVOS
    283            #include "servo.h"
    284          #endif
    285          
    286          #if HAS_DIGIPOTSS
    287            #include <SPI.h>
    288          #endif
    289          
    290          #if ENABLED(DAC_STEPPER_CURRENT)
    291            #include "stepper_dac.h"
    292          #endif
    293          
    294          #if ENABLED(EXPERIMENTAL_I2CBUS)
    295            #include "twibus.h"
    296          #endif
    297          
    298          #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
    299            #include "endstop_interrupts.h"
    300          #endif
    301          
    302          #if ENABLED(M100_FREE_MEMORY_WATCHER)
    303            void gcode_M100();
    304            void M100_dump_routine(const char * const title, const char *start, const char *end);
    305          #endif
    306          
    307          #if ENABLED(SDSUPPORT)

   \                                 In section .text, align 2, keep-with-next
   \   static __intrinsic __interwork __softfp void __sti__routine()
   \                     __sti__routine: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
    308            CardReader card;
   \        0x4   0x.... 0x....      LDR.W    R0,??DataTable112
   \        0x8   0x.... 0x....      BL       _ZN10CardReaderC1Ev
   \        0xC   0x.... 0x....      LDR.W    R5,??DataTable112_1
   \       0x10   0x462A             MOV      R2,R5
   \       0x12   0x.... 0x....      LDR.W    R1,??DataTable112_2
   \       0x16   0x.... 0x....      BL       __aeabi_atexit
    309          
    310          #endif
    311          
    312          #if ENABLED(EXPERIMENTAL_I2CBUS)
    313            TWIBus i2c;
    314          #endif
    315          
    316          #if ENABLED(G38_PROBE_TARGET)
    317            bool G38_move = false,
    318                 G38_endstop_hit = false;
    319          #endif
    320          
    321          //#if ENABLED(AUTO_BED_LEVELING_UBL)
    322          #if 1
    323            #include "ubl.h"

    #define MESH_X_DIST (float(UBL_MESH_MAX_X - (UBL_MESH_MIN_X)) / float(GRID_MAX_POINTS_X - 1))
            ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\ubl.h",93  Warning[Pa181]: 
          incompatible redefinition of macro "MESH_X_DIST" (declared at line 44
          of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marl
          in\mesh_bed_leveling.h")

    #define MESH_Y_DIST (float(UBL_MESH_MAX_Y - (UBL_MESH_MIN_Y)) / float(GRID_MAX_POINTS_Y - 1))
            ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\ubl.h",94  Warning[Pa181]: 
          incompatible redefinition of macro "MESH_Y_DIST" (declared at line 45
          of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marl
          in\mesh_bed_leveling.h")

          const int8_t cx = (x - (UBL_MESH_MIN_X)) * (1.0 / (MESH_X_DIST));
                            ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\ubl.h",180  Warning[Pa093]: 
          implicit conversion from floating point to integer

          const int8_t cy = (y - (UBL_MESH_MIN_Y)) * (1.0 / (MESH_Y_DIST));
                            ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\ubl.h",187  Warning[Pa093]: 
          implicit conversion from floating point to integer

          const int8_t px = (x - (UBL_MESH_MIN_X) + (MESH_X_DIST) * 0.5) * (1.0 / (MESH_X_DIST));
                            ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\ubl.h",195  Warning[Pa093]: 
          implicit conversion from floating point to integer

          const int8_t py = (y - (UBL_MESH_MIN_Y) + (MESH_Y_DIST) * 0.5) * (1.0 / (MESH_Y_DIST));
                            ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\ubl.h",200  Warning[Pa093]: 
          implicit conversion from floating point to integer
    324            unified_bed_leveling ubl;
   \       0x1A   0x.... 0x....      LDR.W    R4,??DataTable112_3
   \       0x1E   0xF104 0x0084      ADD      R0,R4,#+132
   \       0x22   0x.... 0x....      BL       _ZN20unified_bed_levelingC1Ev
    325            #define UBL_MESH_VALID !( ( ubl.z_values[0][0] == ubl.z_values[0][1] && ubl.z_values[0][1] == ubl.z_values[0][2] \
    326                                     && ubl.z_values[1][0] == ubl.z_values[1][1] && ubl.z_values[1][1] == ubl.z_values[1][2] \
    327                                     && ubl.z_values[2][0] == ubl.z_values[2][1] && ubl.z_values[2][1] == ubl.z_values[2][2] \
    328                                     && ubl.z_values[0][0] == 0 && ubl.z_values[1][0] == 0 && ubl.z_values[2][0] == 0 )  \
    329                                     || isnan(ubl.z_values[0][0]))
    330          #endif
    331          
    332          
    333          bool Running = true;
    334          
    335          uint8_t marlin_debug_flags = DEBUG_NONE;
    336          
    337          /**
    338           * Cartesian Current Position
    339           *   Used to track the logical position as moves are queued.
    340           *   Used by 'line_to_current_position' to do a move after changing it.
    341           *   Used by 'SYNC_PLAN_POSITION_KINEMATIC' to update 'planner.position'.
    342           */
    343          float current_position[XYZE] = { 0.0 };
    344          
    345          /**
    346           * Cartesian Destination
    347           *   A temporary position, usually applied to 'current_position'.
    348           *   Set with 'gcode_get_destination' or 'set_destination_to_current'.
    349           *   'line_to_destination' sets 'current_position' to 'destination'.
    350           */
    351          float destination[XYZE] = { 0.0 };
    352          
    353          /**
    354           * axis_homed
    355           *   Flags that each linear axis was homed.
    356           *   XYZ on cartesian, ABC on delta, ABZ on SCARA.
    357           *
    358           * axis_known_position
    359           *   Flags that the position is known in each linear axis. Set when homed.
    360           *   Cleared whenever a stepper powers off, potentially losing its position.
    361           */
    362          bool axis_homed[XYZ] = { false }, axis_known_position[XYZ] = { false };
    363          
    364          /**
    365           * GCode line number handling. Hosts may opt to include line numbers when
    366           * sending commands to Marlin, and lines will be checked for sequentiality.
    367           * M110 N<int> sets the current line number.
    368           */
    369          static long gcode_N, gcode_LastN, Stopped_gcode_LastN = 0;
    370          
    371          /**
    372           * GCode Command Queue
    373           * A simple ring buffer of BUFSIZE command strings.
    374           *
    375           * Commands are copied into this buffer by the command injectors
    376           * (immediate, serial, sd card) and they are processed sequentially by
    377           * the main loop. The process_next_command function parses the next
    378           * command and hands off execution to individual handler functions.
    379           */
    380          uint8_t commands_in_queue = 0; // Count of commands in the queue
    381          static uint8_t cmd_queue_index_r = 0, // Ring buffer read position
    382                         cmd_queue_index_w = 0; // Ring buffer write position
    383          uint8_t cmd_queue_index_r_bak = 0;               
    384          #if ENABLED(M100_FREE_MEMORY_WATCHER)
    385            char command_queue[BUFSIZE][MAX_CMD_SIZE];  // Necessary so M100 Free Memory Dumper can show us the commands and any corruption
    386          #else                                         // This can be collapsed back to the way it was soon.
    387          static char command_queue[BUFSIZE][MAX_CMD_SIZE];
    388          static char command_queue_bak[8][MAX_CMD_SIZE];
    389          static char command_queue_bak_end[MAX_CMD_SIZE];
    390          
    391          
    392          #endif
    393          
    394          /**
    395           * Current GCode Command
    396           * When a GCode handler is running, these will be set
    397           */
    398          static char *current_command,      // The command currently being executed
    399                      *current_command_args, // The address where arguments begin
    400                      *seen_pointer;         // Set by code_seen(), used by the code_value functions
    401          
    402          /**
    403           * Next Injected Command pointer. NULL if no commands are being injected.
    404           * Used by Marlin internally to ensure that commands initiated from within
    405           * are enqueued ahead of any pending serial or sd card commands.
    406           */
    407          static const char *injected_commands_P = NULL;
    408          
    409          #if ENABLED(INCH_MODE_SUPPORT)
    410            float linear_unit_factor = 1.0, volumetric_unit_factor = 1.0;
    411          #endif
    412          
    413          #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
    414            TempUnit input_temp_units = TEMPUNIT_C;
    415          #endif
    416          
    417          /**
    418           * Feed rates are often configured with mm/m
    419           * but the planner and stepper like mm/s units.
    420           */
    421          	/*--mks cfg--*/
    422          /*
    423          float constexpr homing_feedrate_mm_s[] = {	
    424          
    425            #if ENABLED(DELTA)
    426              MMM_TO_MMS(HOMING_FEEDRATE_Z), MMM_TO_MMS(HOMING_FEEDRATE_Z),
    427            #else
    428              MMM_TO_MMS(HOMING_FEEDRATE_XY), MMM_TO_MMS(HOMING_FEEDRATE_XY),
    429            #endif
    430            MMM_TO_MMS(HOMING_FEEDRATE_Z), 0
    431          };*/
    432          float  homing_feedrate_mm_s[4];
    433          
    434          
    435          static float feedrate_mm_s = MMM_TO_MMS(1500.0), saved_feedrate_mm_s;
    436          int feedrate_percentage = 100, saved_feedrate_percentage,
    437              flow_percentage[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100);
    438          
    439          bool axis_relative_modes[] = AXIS_RELATIVE_MODES,
    440               volumetric_enabled =
    441                  #if ENABLED(VOLUMETRIC_DEFAULT_ON)
    442                    true
    443                  #else
    444                    false
    445                  #endif
    446                ;
    447          float filament_size[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(DEFAULT_NOMINAL_FILAMENT_DIA),
    448                volumetric_multiplier[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(1.0);
    449          
    450          #if HAS_WORKSPACE_OFFSET
    451            #if HAS_POSITION_SHIFT
    452              // The distance that XYZ has been offset by G92. Reset by G28.
    453              float position_shift[XYZ] = { 0 };
    454            #endif
    455            #if HAS_HOME_OFFSET
    456              // This offset is added to the configured home position.
    457              // Set by M206, M428, or menu item. Saved to EEPROM.
    458              float home_offset[XYZ] = { 0 };
    459            #endif
    460            #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
    461              // The above two are combined to save on computes
    462              float workspace_offset[XYZ] = { 0 };
    463            #endif
    464          #endif
    465          
    466          // Software Endstops are based on the configured limits.
    467          #if HAS_SOFTWARE_ENDSTOPS
    468            bool soft_endstops_enabled = true;
    469          #endif
    470          float soft_endstop_min[XYZ] = { X_MIN_POS, Y_MIN_POS, Z_MIN_POS },
   \       0x26   0x.... 0x....      LDR.W    R6,??DataTable113_4
   \       0x2A   0x68B0             LDR      R0,[R6, #+8]
   \       0x2C   0x6520             STR      R0,[R4, #+80]
   \       0x2E   0x68F0             LDR      R0,[R6, #+12]
   \       0x30   0x6560             STR      R0,[R4, #+84]
   \       0x32   0x6930             LDR      R0,[R6, #+16]
   \       0x34   0x65A0             STR      R0,[R4, #+88]
    471                soft_endstop_max[XYZ] = { X_MAX_POS, Y_MAX_POS, Z_MAX_POS };
   \       0x36   0x6970             LDR      R0,[R6, #+20]
   \       0x38   0x65E0             STR      R0,[R4, #+92]
   \       0x3A   0x69B0             LDR      R0,[R6, #+24]
   \       0x3C   0x6620             STR      R0,[R4, #+96]
   \       0x3E   0x69F0             LDR      R0,[R6, #+28]
   \       0x40   0x6660             STR      R0,[R4, #+100]
    472          
    473          #if FAN_COUNT > 0
    474            //int16_t fanSpeeds[FAN_COUNT] = { 0 };  /*--mks--*/     
    475            int fanSpeeds[FAN_COUNT] = { 0 };
    476          #if ENABLED(PROBING_FANS_OFF)
    477            bool fans_paused = false;
    478            int16_t paused_fanSpeeds[FAN_COUNT] = { 0 };
    479          #endif
    480          
    481          #endif
    482          
    483          // The active extruder (tool). Set with T<extruder> command.
    484          uint8_t active_extruder = 0;
    485          
    486          // Relative Mode. Enable with G91, disable with G90.
    487          static bool relative_mode = false;
    488          
    489          // For M109 and M190, this flag may be cleared (by M108) to exit the wait loop
    490          volatile bool wait_for_heatup = true;
    491          
    492          // For M0/M1, this flag may be cleared (by M108) to exit the wait-for-user loop
    493          #if HAS_RESUME_CONTINUE
    494            volatile bool wait_for_user = false;
    495          #endif
    496          
    497          const char axis_codes[XYZE] = {'X', 'Y', 'Z', 'E'};
    498          
    499          // Number of characters read in the current line of serial input
    500          static int serial_count = 0;
    501          static int wifi_read_count = 0;
    502          
    503          // Inactivity shutdown
    504          millis_t previous_cmd_ms = 0;
    505          static millis_t max_inactive_time = 0;
    506          static millis_t stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL;
    507          
    508          // Print Job Timer
    509          #if ENABLED(PRINTCOUNTER)
    510            PrintCounter print_job_timer = PrintCounter();
    511          #else
    512            Stopwatch print_job_timer = Stopwatch();
   \       0x42   0xF504 0x7062      ADD      R0,R4,#+904
   \       0x46   0x.... 0x....      BL       _ZN9StopwatchC1Ev
    513          #endif
    514          
    515          // Buzzer - I2C on the LCD or a BEEPER_PIN
    516          #if ENABLED(LCD_USE_I2C_BUZZER)
    517            #define BUZZ(d,f) lcd_buzz(d, f)
    518          #elif PIN_EXISTS(BEEPER)
    519            Buzzer buzzer;
   \       0x4A   0xF504 0x7066      ADD      R0,R4,#+920
   \       0x4E   0x.... 0x....      BL       _ZN6BuzzerC1Ev
    520            #define BUZZ(d,f) buzzer.tone(d, f)
    521          #else
    522            #define BUZZ(d,f) NOOP
    523          #endif
    524          
    525          uint8_t target_extruder;
    526          
    527          #if HAS_BED_PROBE
    528            float zprobe_zoffset = Z_PROBE_OFFSET_FROM_EXTRUDER;
    529          #endif
    530          
    531          //#if HAS_ABL
    532          #if 1
    533            float xy_probe_feedrate_mm_s = MMM_TO_MMS(XY_PROBE_SPEED);
   \       0x52   0x6F70             LDR      R0,[R6, #+116]
   \       0x54   0x.... 0x....      LDR.W    R1,??DataTable113_5  ;; 0x42700000
   \       0x58   0x.... 0x....      BL       __aeabi_fdiv
   \       0x5C   0x67E0             STR      R0,[R4, #+124]
   \       0x5E   0x69F7             LDR      R7,[R6, #+28]
   \       0x60   0xF8C4 0x7080      STR      R7,[R4, #+128]
   \       0x64   0x.... 0x....      LDR.W    R9,??DataTable113_6  ;; 0x43160000
   \       0x68   0x46CA             MOV      R10,R9
   \       0x6A   0x2402             MOVS     R4,#+2
   \       0x6C   0xF04F 0x587E      MOV      R8,#+1065353216
   \       0x70   0x46C3             MOV      R11,R8
   \       0x72   0xE004             B.N      ??__sti__routine_0
   \                     ??__sti__routine_1: (+1)
   \       0x74   0x4650             MOV      R0,R10
   \       0x76   0x4651             MOV      R1,R10
   \       0x78   0x.... 0x....      BL       __aeabi_fmul
   \       0x7C   0x4682             MOV      R10,R0
   \                     ??__sti__routine_0: (+1)
   \       0x7E   0x07E0             LSLS     R0,R4,#+31
   \       0x80   0xD504             BPL.N    ??__sti__routine_2
   \       0x82   0x4658             MOV      R0,R11
   \       0x84   0x4651             MOV      R1,R10
   \       0x86   0x.... 0x....      BL       __aeabi_fmul
   \       0x8A   0x4683             MOV      R11,R0
   \                     ??__sti__routine_2: (+1)
   \       0x8C   0x0864             LSRS     R4,R4,#+1
   \       0x8E   0xD1F1             BNE.N    ??__sti__routine_1
   \       0x90   0x.... 0x....      LDR.W    R10,??DataTable113_7
   \       0x94   0xF8CA 0xB034      STR      R11,[R10, #+52]
   \       0x98   0x4659             MOV      R1,R11
   \       0x9A   0xF04F 0x4080      MOV      R0,#+1073741824
   \       0x9E   0x.... 0x....      BL       __aeabi_fmul
   \       0xA2   0xF8CA 0x0038      STR      R0,[R10, #+56]
   \       0xA6   0x2402             MOVS     R4,#+2
   \       0xA8   0xE004             B.N      ??__sti__routine_3
   \                     ??__sti__routine_4: (+1)
   \       0xAA   0x4648             MOV      R0,R9
   \       0xAC   0x4649             MOV      R1,R9
   \       0xAE   0x.... 0x....      BL       __aeabi_fmul
   \       0xB2   0x4681             MOV      R9,R0
   \                     ??__sti__routine_3: (+1)
   \       0xB4   0x07E0             LSLS     R0,R4,#+31
   \       0xB6   0xD504             BPL.N    ??__sti__routine_5
   \       0xB8   0x4640             MOV      R0,R8
   \       0xBA   0x4649             MOV      R1,R9
   \       0xBC   0x.... 0x....      BL       __aeabi_fmul
   \       0xC0   0x4680             MOV      R8,R0
   \                     ??__sti__routine_5: (+1)
   \       0xC2   0x0864             LSRS     R4,R4,#+1
   \       0xC4   0xD1F1             BNE.N    ??__sti__routine_4
   \       0xC6   0xF8CA 0x803C      STR      R8,[R10, #+60]
   \       0xCA   0x68B1             LDR      R1,[R6, #+8]
   \       0xCC   0xF8CA 0x1004      STR      R1,[R10, #+4]
   \       0xD0   0x68F4             LDR      R4,[R6, #+12]
   \       0xD2   0xF8CA 0x4008      STR      R4,[R10, #+8]
   \       0xD6   0xF8D6 0x8010      LDR      R8,[R6, #+16]
   \       0xDA   0xF8CA 0x800C      STR      R8,[R10, #+12]
   \       0xDE   0x6970             LDR      R0,[R6, #+20]
   \       0xE0   0xF8CA 0x0010      STR      R0,[R10, #+16]
   \       0xE4   0xF8D6 0x9018      LDR      R9,[R6, #+24]
   \       0xE8   0xF8CA 0x9014      STR      R9,[R10, #+20]
   \       0xEC   0xF8CA 0x7018      STR      R7,[R10, #+24]
   \       0xF0   0x6D32             LDR      R2,[R6, #+80]
   \       0xF2   0xF8CA 0x2024      STR      R2,[R10, #+36]
   \       0xF6   0x.... 0x....      BL       __aeabi_fsub
   \       0xFA   0xF8CA 0x0028      STR      R0,[R10, #+40]
   \       0xFE   0x4648             MOV      R0,R9
   \      0x100   0x4621             MOV      R1,R4
   \      0x102   0x.... 0x....      BL       __aeabi_fsub
   \      0x106   0xF8CA 0x002C      STR      R0,[R10, #+44]
   \      0x10A   0x4638             MOV      R0,R7
   \      0x10C   0x4641             MOV      R1,R8
   \      0x10E   0x.... 0x....      BL       __aeabi_fsub
   \      0x112   0xF8CA 0x0030      STR      R0,[R10, #+48]
   \      0x116   0x7930             LDRB     R0,[R6, #+4]
   \      0x118   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \      0x11C   0x7970             LDRB     R0,[R6, #+5]
   \      0x11E   0xF88A 0x0001      STRB     R0,[R10, #+1]
   \      0x122   0x79B0             LDRB     R0,[R6, #+6]
   \      0x124   0xF88A 0x0002      STRB     R0,[R10, #+2]
   \      0x128   0x.... 0x....      LDR.W    R0,??DataTable113_8
   \      0x12C   0x.... 0x....      BL       _ZN18DATA_REPRINT_ITMESC1Ev
   \      0x130   0x462A             MOV      R2,R5
   \      0x132   0x.... 0x....      LDR.W    R1,??DataTable115
   \      0x136   0xE8BD 0x4FF8      POP      {R3-R11,LR}
   \      0x13A   0x.... 0x....      B.W      __aeabi_atexit

   \                                 In section .bss, align 4
   \                     card:
   \        0x0                      DS8 800

   \                                 In section .bss, align 4
   \                     command_queue:
   \        0x0                      DS8 384

   \                                 In section .bss, align 4
   \                     injected_commands_P:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
   \                     saved_feedrate_mm_s:
   \        0x0                      DS8 4
   \                     saved_feedrate_percentage:
   \        0x4                      DS8 4

   \                                 In section .bss, align 4
   \                     fanSpeeds:
   \        0x0                      DS8 4

   \                                 In section .text, align 4, keep-with-next
   \                     axis_codes:
   \        0x0   0x58 0x59          DC8 88, 89, 90, 69
   \              0x5A 0x45    
    534            #define XY_PROBE_FEEDRATE_MM_S xy_probe_feedrate_mm_s
    535          #elif defined(XY_PROBE_SPEED)
    536            #define XY_PROBE_FEEDRATE_MM_S MMM_TO_MMS(XY_PROBE_SPEED)
    537          #else
    538            #define XY_PROBE_FEEDRATE_MM_S PLANNER_XY_FEEDRATE()
    539          #endif
    540          
    541          /*--mks cfg--begin AUTO_BED_LEVELING_BILINEAR */
    542          
    543          //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
    544          #if 1
    545          	//mks_delta
    546          /*
    547            #if ENABLED(DELTA)
    548              #define ADJUST_DELTA(V) \
    549                if (planner.abl_enabled) { \
    550                  const float zadj = bilinear_z_offset(V); \
    551                  delta[A_AXIS] += zadj; \
    552                  delta[B_AXIS] += zadj; \
    553                  delta[C_AXIS] += zadj; \
    554                }
    555            #else
    556              #define ADJUST_DELTA(V) if (planner.abl_enabled) { delta[Z_AXIS] += bilinear_z_offset(V); }
    557            #endif
    558          */

   \                                 In section .text, align 2, keep-with-next
    559          void  ADJUST_DELTA(const float logical[XYZ])
    560          {
   \                     _Z12ADJUST_DELTAPKf: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    561          	float zadj;
    562          
    563          	if(MACHINETPYE == DELTA)
   \        0x2   0x.... 0x....      LDR.W    R1,??DataTable113_9
   \        0x6   0x7809             LDRB     R1,[R1, #+0]
   \        0x8   0x.... 0x....      LDR.W    R2,??DataTable113_4
   \        0xC   0xF9B2 0x2058      LDRSH    R2,[R2, #+88]
   \       0x10   0x2A02             CMP      R2,#+2
   \       0x12   0xD116             BNE.N    ??ADJUST_DELTA_0
    564          		{
    565                	if (planner.abl_enabled) { 
   \       0x14   0x2900             CMP      R1,#+0
   \       0x16   0xD01E             BEQ.N    ??ADJUST_DELTA_1
    566                 	 	zadj = bilinear_z_offset(logical); 
   \       0x18   0x.... 0x....      BL       _Z17bilinear_z_offsetPKf
   \       0x1C   0x4605             MOV      R5,R0
    567                  	delta[A_AXIS] += zadj; 
   \       0x1E   0x.... 0x....      LDR.W    R4,??DataTable112_3
   \       0x22   0x6EA0             LDR      R0,[R4, #+104]
   \       0x24   0x4629             MOV      R1,R5
   \       0x26   0x.... 0x....      BL       __aeabi_fadd
   \       0x2A   0x66A0             STR      R0,[R4, #+104]
    568                 		delta[B_AXIS] += zadj; 
   \       0x2C   0x6EE0             LDR      R0,[R4, #+108]
   \       0x2E   0x4629             MOV      R1,R5
   \       0x30   0x.... 0x....      BL       __aeabi_fadd
   \       0x34   0x66E0             STR      R0,[R4, #+108]
    569                  	delta[C_AXIS] += zadj; 
   \       0x36   0x6F20             LDR      R0,[R4, #+112]
   \       0x38   0x4629             MOV      R1,R5
   \       0x3A   0x.... 0x....      BL       __aeabi_fadd
   \       0x3E   0x6720             STR      R0,[R4, #+112]
   \       0x40   0xBD31             POP      {R0,R4,R5,PC}
    570                		}
    571          		}
    572          		else
    573          			{
    574          			if (planner.abl_enabled) 
   \                     ??ADJUST_DELTA_0: (+1)
   \       0x42   0x2900             CMP      R1,#+0
   \       0x44   0xD007             BEQ.N    ??ADJUST_DELTA_1
    575          				 delta[Z_AXIS] += bilinear_z_offset(logical); 
   \       0x46   0x.... 0x....      BL       _Z17bilinear_z_offsetPKf
   \       0x4A   0x.... 0x....      LDR.W    R4,??DataTable112_3
   \       0x4E   0x6F21             LDR      R1,[R4, #+112]
   \       0x50   0x.... 0x....      BL       __aeabi_fadd
   \       0x54   0x6720             STR      R0,[R4, #+112]
    576          			}
    577          }
   \                     ??ADJUST_DELTA_1: (+1)
   \       0x56   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    578          
    579          //#elif IS_KINEMATIC	//mks_delta
    580            //#define ADJUST_DELTA(V) NOOP
    581          #endif
    582          /*--mks cfg--end AUTO_BED_LEVELING_BILINEAR */
    583          
    584          #if ENABLED(Z_DUAL_ENDSTOPS)
    585            float z_endstop_adj =
    586              #ifdef Z_DUAL_ENDSTOPS_ADJUSTMENT
    587                Z_DUAL_ENDSTOPS_ADJUSTMENT
    588              #else
    589                0
    590              #endif
    591            ;
    592          #endif
    593          
    594          // Extruder offsets
    595          #if HOTENDS > 1
    596            float hotend_offset[XYZ][HOTENDS];
    597          #endif
    598          
    599          #if HAS_Z_SERVO_ENDSTOP
    600            const int z_servo_angle[2] = Z_SERVO_ANGLES;
    601          #endif
    602          
    603          #if ENABLED(BARICUDA)
    604            int baricuda_valve_pressure = 0;
    605            int baricuda_e_to_p_pressure = 0;
    606          #endif
    607          
    608          #if ENABLED(FWRETRACT)
    609          
    610            bool autoretract_enabled = false;
    611            bool retracted[EXTRUDERS] = { false };
    612            bool retracted_swap[EXTRUDERS] = { false };
    613          
    614            float retract_length = RETRACT_LENGTH;
    615            float retract_length_swap = RETRACT_LENGTH_SWAP;
    616            float retract_feedrate_mm_s = RETRACT_FEEDRATE;
    617            float retract_zlift = RETRACT_ZLIFT;
    618            float retract_recover_length = RETRACT_RECOVER_LENGTH;
    619            float retract_recover_length_swap = RETRACT_RECOVER_LENGTH_SWAP;
    620            float retract_recover_feedrate_mm_s = RETRACT_RECOVER_FEEDRATE;
    621          
    622          #endif // FWRETRACT
    623          
    624          #if ENABLED(ULTIPANEL) && HAS_POWER_SWITCH
    625            bool powersupply =
    626              #if ENABLED(PS_DEFAULT_OFF)
    627                false
    628              #else
    629                true
    630              #endif
    631            ;
    632          #endif
    633          
    634          #if HAS_CASE_LIGHT
    635            bool case_light_on =
    636              #if ENABLED(CASE_LIGHT_DEFAULT_ON)
    637                true
    638              #else
    639                false
    640              #endif
    641            ;
    642          #endif
    643          
    644          //#if ENABLED(DELTA)	//mks_delta
    645          #if 1
    646            float delta[ABC],

   \                                 In section .bss, align 4
    647                  endstop_adj[ABC] = { 0 };
   \                     endstop_adj:
   \        0x0                      DS8 12
    648          
    649            // These values are loaded or reset at boot time when setup() calls
    650            // settings.load(), which calls recalc_delta_settings().
    651            float delta_radius,
    652                  delta_tower_angle_trim[2],
    653                  delta_tower[ABC][2],
    654                  delta_diagonal_rod,
    655                  delta_calibration_radius,
    656                  delta_diagonal_rod_2_tower[ABC],
    657                  delta_segments_per_second,
    658                  delta_clip_start_height = Z_MAX_POS;
    659          
    660            float delta_safe_distance_from_top();
    661          
    662          #endif
    663          
    664          //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
    665          #if 1 /*--mks cfg-- AUTO_BED_LEVELING_BILINEAR */
    666            int bilinear_grid_spacing[2], bilinear_start[2];		/*---mks---*/ //int to int16_t
    667            float bilinear_grid_factor[2],
    668                  //z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];

   \                                 In section .bss, align 4
    669                  z_values[GRID_MAX_POINTS_X_MAX][GRID_MAX_POINTS_Y_MAX];
   \                     z_values:
   \        0x0                      DS8 1024
    670          #endif
    671          
    672          //#if IS_SCARA	//mks_delta
    673          #if 1
    674            // Float constants for SCARA calculations
    675            const float L1 = SCARA_LINKAGE_1, L2 = SCARA_LINKAGE_2,
    676                        L1_2 = sq(float(L1)), L1_2_2 = 2.0 * L1_2,
    677                        L2_2 = sq(float(L2));
    678          
    679          //  float delta_segments_per_second = SCARA_SEGMENTS_PER_SECOND,
    680          //        delta[ABC];
    681          #endif
    682          
    683          float cartes[XYZ] = { 0 };
    684          
    685          #if ENABLED(FILAMENT_WIDTH_SENSOR)
    686            bool filament_sensor = false;                                 // M405 turns on filament sensor control. M406 turns it off.
    687            float filament_width_nominal = DEFAULT_NOMINAL_FILAMENT_DIA,  // Nominal filament width. Change with M404.
    688                  filament_width_meas = DEFAULT_MEASURED_FILAMENT_DIA;    // Measured filament diameter
    689            int8_t measurement_delay[MAX_MEASUREMENT_DELAY + 1];          // Ring buffer to delayed measurement. Store extruder factor after subtracting 100
    690            int filwidth_delay_index[2] = { 0, -1 };                      // Indexes into ring buffer
    691            int meas_delay_cm = MEASUREMENT_DELAY_CM;                     // Distance delay setting
    692          #endif
    693          
    694          #if ENABLED(FILAMENT_RUNOUT_SENSOR)
    695            static bool filament_ran_out = false;
    696          #endif
    697          
    698          #if ENABLED(FILAMENT_CHANGE_FEATURE)
    699            FilamentChangeMenuResponse filament_change_menu_response;
    700          #endif
    701          
    702          #if ENABLED(MIXING_EXTRUDER)
    703            float mixing_factor[MIXING_STEPPERS]; // Reciprocal of mix proportion. 0.0 = off, otherwise >= 1.0.
    704            #if MIXING_VIRTUAL_TOOLS > 1
    705              float mixing_virtual_tool_mix[MIXING_VIRTUAL_TOOLS][MIXING_STEPPERS];
    706            #endif
    707          #endif
    708          
    709          static bool send_ok[BUFSIZE];
    710          
    711          #if HAS_SERVOS
    712            Servo servo[NUM_SERVOS];
    713            #define MOVE_SERVO(I, P) servo[I].move(P)
    714            #if HAS_Z_SERVO_ENDSTOP
    715              #define DEPLOY_Z_SERVO() MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[0])
    716              #define STOW_Z_SERVO() MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[1])
    717            #endif
    718          #endif
    719          
    720          #ifdef CHDK
    721            millis_t chdkHigh = 0;
    722            bool chdkActive = false;
    723          #endif
    724          
    725          #ifdef AUTOMATIC_CURRENT_CONTROL
    726            bool auto_current_control = 0;
    727          #endif
    728          
    729          #if ENABLED(PID_EXTRUSION_SCALING)
    730            int lpq_len = 20;
    731          #endif
    732          
    733          #if ENABLED(HOST_KEEPALIVE_FEATURE)
    734            MarlinBusyState busy_state = NOT_BUSY;
    735            static millis_t next_busy_signal_ms = 0;
    736            uint8_t host_keepalive_interval = DEFAULT_KEEPALIVE_INTERVAL;
    737          #else
    738            #define host_keepalive() NOOP
    739          #endif
    740          
    741          static inline float pgm_read_any(const float *p) { return pgm_read_float_near(p); }
    742          static inline signed char pgm_read_any(const signed char *p) { return pgm_read_byte_near(p); }
    743          
    744          /*--mks--*/
    745          /*
    746          #define XYZ_CONSTS_FROM_CONFIG(type, array, CONFIG) \
    747            static const PROGMEM type array##_P[XYZ] = { X_##CONFIG, Y_##CONFIG, Z_##CONFIG }; \
    748            static inline type array(AxisEnum axis) { return (array##_P[axis]); } 	
    749            //typedef void __void_##CONFIG##__
    750          
    751          XYZ_CONSTS_FROM_CONFIG(float, base_min_pos,   MIN_POS);
    752          XYZ_CONSTS_FROM_CONFIG(float, base_max_pos,   MAX_POS);
    753          XYZ_CONSTS_FROM_CONFIG(float, base_home_pos,  HOME_POS);
    754          XYZ_CONSTS_FROM_CONFIG(float, max_length,     MAX_LENGTH);
    755          XYZ_CONSTS_FROM_CONFIG(float, home_bump_mm,   HOME_BUMP_MM);
    756          XYZ_CONSTS_FROM_CONFIG(signed char, home_dir, HOME_DIR);
    757          */
    758          /*--mks cfg XYZ_CONSTS_FROM_CONFIG BEGIN--*/
    759          #define XYZ_CONSTS_FROM_CONFIG(type, array, CONFIG) \
    760            type array##_P[XYZ] = { X_##CONFIG, Y_##CONFIG, Z_##CONFIG }; \
    761            static inline type array(AxisEnum axis) { return (array##_P[axis]); } 	
    762            //typedef void __void_##CONFIG##__
    763          

   \                                 In section .text, align 2, keep-with-next
    764          XYZ_CONSTS_FROM_CONFIG(float, base_min_pos,   MIN_POS);			/*--mks cfg--*/
   \                     _ZN37_INTERNAL_15_Marlin_main_cpp_3178531912base_min_posE8AxisEnum: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable113_7
   \        0x4   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \        0x8   0x6840             LDR      R0,[R0, #+4]
   \        0xA   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    765          XYZ_CONSTS_FROM_CONFIG(float, base_max_pos,   MAX_POS);			/*--mks cfg--*/
   \                     _ZN37_INTERNAL_15_Marlin_main_cpp_3178531912base_max_posE8AxisEnum: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable113_7
   \        0x4   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \        0x8   0x6900             LDR      R0,[R0, #+16]
   \        0xA   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    766          XYZ_CONSTS_FROM_CONFIG(float, base_home_pos,  HOME_POS);		/*--mks cfg--*/ 
   \                     _ZN37_INTERNAL_15_Marlin_main_cpp_3178531913base_home_posE8AxisEnum: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable113_7
   \        0x4   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \        0x8   0x69C0             LDR      R0,[R0, #+28]
   \        0xA   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    767          XYZ_CONSTS_FROM_CONFIG(float, max_length,     MAX_LENGTH);		/*--mks cfg--*/	
   \                     _ZN37_INTERNAL_15_Marlin_main_cpp_3178531910max_lengthE8AxisEnum: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable113_7
   \        0x4   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \        0x8   0x6A80             LDR      R0,[R0, #+40]
   \        0xA   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    768          XYZ_CONSTS_FROM_CONFIG(float, home_bump_mm,   HOME_BUMP_MM);
   \                     _ZN37_INTERNAL_15_Marlin_main_cpp_3178531912home_bump_mmE8AxisEnum: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable116
   \        0x4   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \        0x8   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    769          XYZ_CONSTS_FROM_CONFIG(signed char, home_dir, HOME_DIR);		/*--mks cfg--*/
   \                     _ZN37_INTERNAL_15_Marlin_main_cpp_317853198home_dirE8AxisEnum: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable113_7
   \        0x4   0x5608             LDRSB    R0,[R1, R0]
   \        0x6   0x4770             BX       LR               ;; return
    770          //signed char home_dir_P[XYZ] = {-1, Y_HOME_DIR, Z_HOME_DIR }; 
    771          //static inline signed char home_dir(AxisEnum axis) { return (home_dir_P[axis]); }	  
    772          
    773          /*--mks cfg XYZ_CONSTS_FROM_CONFIG END--*/
    774          
    775          /**
    776           * ***************************************************************************
    777           * ******************************** FUNCTIONS ********************************
    778           * ***************************************************************************
    779           */
    780          
    781          void stop();
    782          
    783          void get_available_commands();
    784          void process_next_command();
    785          void prepare_move_to_destination();
    786          
    787          void get_cartesian_from_steppers();
    788          void set_current_from_steppers_for_axis(const AxisEnum axis);
    789          
    790          #if ENABLED(ARC_SUPPORT)
    791            void plan_arc(float target[XYZE], float* offset, uint8_t clockwise);
    792          #endif
    793          
    794          #if ENABLED(BEZIER_CURVE_SUPPORT)
    795            void plan_cubic_move(const float offset[4]);
    796          #endif
    797          
    798          void tool_change(const uint8_t tmp_extruder, const float fr_mm_s=0.0, bool no_move=false);
    799          static void report_current_position();
    800          
    801          #if ENABLED(DEBUG_LEVELING_FEATURE)
    802            void print_xyz(const char* prefix, const char* suffix, const float x, const float y, const float z) {
    803              serialprintPGM(prefix);
    804              SERIAL_CHAR('(');
    805              SERIAL_ECHO(x);
    806              SERIAL_ECHOPAIR(", ", y);
    807              SERIAL_ECHOPAIR(", ", z);
    808              SERIAL_CHAR(')');
    809          
    810              suffix ? serialprintPGM(suffix) : SERIAL_EOL;
    811            }
    812          
    813            void print_xyz(const char* prefix, const char* suffix, const float xyz[]) {
    814              print_xyz(prefix, suffix, xyz[X_AXIS], xyz[Y_AXIS], xyz[Z_AXIS]);
    815            }
    816          
    817          //  #if HAS_ABL
    818          #if 1
    819              void print_xyz(const char* prefix, const char* suffix, const vector_3 &xyz) {
    820                print_xyz(prefix, suffix, xyz.x, xyz.y, xyz.z);
    821              }
    822            #endif
    823          
    824            #define DEBUG_POS(SUFFIX,VAR) do { \
    825              print_xyz(PSTR("  " STRINGIFY(VAR) "="), PSTR(" : " SUFFIX "\n"), VAR); } while(0)
    826          #endif
    827          
    828          /**
    829           * sync_plan_position
    830           *
    831           * Set the planner/stepper positions directly from current_position with
    832           * no kinematic translation. Used for homing axes and cartesian/core syncing.
    833           */

   \                                 In section .text, align 4
    834          inline void sync_plan_position() {
    835            #if ENABLED(DEBUG_LEVELING_FEATURE)
    836              if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position", current_position);
    837            #endif
    838            planner.set_position_mm(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
   \                     _Z18sync_plan_positionv: (+1)
   \        0x0   0x4803             LDR.N    R0,??sync_plan_position_0
   \        0x2   0xF100 0x0314      ADD      R3,R0,#+20
   \        0x6   0x6902             LDR      R2,[R0, #+16]
   \        0x8   0x68C1             LDR      R1,[R0, #+12]
   \        0xA   0x6880             LDR      R0,[R0, #+8]
   \        0xC   0x.... 0x....      B.W      _ZN7Planner15set_position_mmEfffRKf
   \                     ??sync_plan_position_0:
   \       0x10   0x....'....        DC32     mks_heating_busy
    839          }

   \                                 In section .text, align 4
    840          inline void sync_plan_position_e() { planner.set_e_position_mm(current_position[E_AXIS]); }
   \                     _Z20sync_plan_position_ev: (+1)
   \        0x0   0x4801             LDR.N    R0,??sync_plan_position_e_0
   \        0x2   0x.... 0x....      B.W      _ZN7Planner17set_e_position_mmERKf
   \        0x6   0xBF00             Nop      
   \                     ??sync_plan_position_e_0:
   \        0x8   0x....'....        DC32     mks_heating_busy+0x14
    841          
    842          //mks_delta
    843          /*	
    844          #if IS_KINEMATIC
    845          
    846            inline void sync_plan_position_kinematic() {
    847              #if ENABLED(DEBUG_LEVELING_FEATURE)
    848                if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position_kinematic", current_position);
    849              #endif
    850              planner.set_position_mm_kinematic(current_position);
    851            }
    852            #define SYNC_PLAN_POSITION_KINEMATIC() sync_plan_position_kinematic()
    853          #else
    854            #define SYNC_PLAN_POSITION_KINEMATIC() sync_plan_position()
    855          #endif
    856          */

   \                                 In section .text, align 4
    857          	inline void sync_plan_position_kinematic() {
    858            #if ENABLED(DEBUG_LEVELING_FEATURE)
    859          		if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position_kinematic", current_position);
    860            #endif
    861          	  planner.set_position_mm_kinematic(current_position);
   \                     _Z28sync_plan_position_kinematicv: (+1)
   \        0x0   0x4801             LDR.N    R0,??sync_plan_position_kinematic_0
   \        0x2   0x.... 0x....      B.W      _ZN7Planner25set_position_mm_kinematicEPKf
   \        0x6   0xBF00             Nop      
   \                     ??sync_plan_position_kinematic_0:
   \        0x8   0x....'....        DC32     mks_heating_busy+0x8
    862          	}
    863          

   \                                 In section .text, align 2, keep-with-next
    864          void SYNC_PLAN_POSITION_KINEMATIC()
    865          {
    866          	if(MACHINETPYE & IS_KINEMATIC)
   \                     _Z28SYNC_PLAN_POSITION_KINEMATICv: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable113_4
   \        0x4   0xF8B0 0x0058      LDRH     R0,[R0, #+88]
   \        0x8   0xF240 0x3102      MOVW     R1,#+770
   \        0xC   0x4208             TST      R0,R1
   \        0xE   0xD001             BEQ.N    ??SYNC_PLAN_POSITION_KINEMATIC_0
    867          		sync_plan_position_kinematic();
   \       0x10   0x.... 0x....      B.W      _Z28sync_plan_position_kinematicv
    868          	else
    869          		sync_plan_position();
   \                     ??SYNC_PLAN_POSITION_KINEMATIC_0: (+1)
   \       0x14   0x.... 0x....      B.W      _Z18sync_plan_positionv
    870          }
    871          	
    872          
    873          
    874          #if 0	/*--mks--*/
    875          //#if ENABLED(SDSUPPORT)
    876            #include "SdFatUtil.h"
    877            int freeMemory() { return SdFatUtil::FreeRam(); }
    878          #else
    879          /*
    880          extern "C" {
    881            extern char __bss_end;
    882            extern char __heap_start;
    883            extern void* __brkval;
    884          
    885            int freeMemory() {
    886              int free_memory;
    887              if ((int)__brkval == 0)
    888                free_memory = ((int)&free_memory) - ((int)&__bss_end);
    889              else
    890                free_memory = ((int)&free_memory) - ((int)__brkval);
    891              return free_memory;
    892            }
    893          }
    894          */

   \                                 In section .text, align 2, keep-with-next
    895          	int freeMemory() { return 4396; }	//No free ram management
   \                     _Z10freeMemoryv: (+1)
   \        0x0   0xF241 0x102C      MOVW     R0,#+4396
   \        0x4   0x4770             BX       LR               ;; return
    896          
    897          #endif //!SDSUPPORT
    898          
    899          #if ENABLED(DIGIPOT_I2C)
    900            extern void digipot_i2c_set_current(int channel, float current);
    901            extern void digipot_i2c_init();
    902          #endif
    903          
    904          /**
    905           * Inject the next "immediate" command, when possible, onto the front of the queue.
    906           * Return true if any immediate commands remain to inject.
    907           */

   \                                 In section .text, align 2, keep-with-next
    908          static bool drain_injected_commands_P() {
   \                     _ZN37_INTERNAL_15_Marlin_main_cpp_3178531925drain_injected_commands_PEv: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
    909            if (injected_commands_P != NULL) {
   \        0x4   0x.... 0x....      LDR.W    R5,??DataTable116_1
   \        0x8   0x6829             LDR      R1,[R5, #+0]
   \        0xA   0x2900             CMP      R1,#+0
   \        0xC   0xD010             BEQ.N    ??drain_injected_commands_P_0
    910              size_t i = 0;
   \        0xE   0x2600             MOVS     R6,#+0
    911              char c, cmd[30];
    912          	//strncpy_P(cmd, injected_commands_P, sizeof(cmd) - 1);
    913              strncpy(cmd, injected_commands_P, sizeof(cmd) - 1);	/*--mks--*/
   \       0x10   0x221D             MOVS     R2,#+29
   \       0x12   0x4668             MOV      R0,SP
   \       0x14   0x.... 0x....      BL       strncpy
    914          
    915          	cmd[sizeof(cmd) - 1] = '\0';
   \       0x18   0x4668             MOV      R0,SP
   \       0x1A   0x4631             MOV      R1,R6
   \       0x1C   0x7741             STRB     R1,[R0, #+29]
    916              while ((c = cmd[i]) && c != '\n') i++; // find the end of this gcode command
   \                     ??drain_injected_commands_P_1: (+1)
   \       0x1E   0x5784             LDRSB    R4,[R0, R6]
   \       0x20   0x2C00             CMP      R4,#+0
   \       0x22   0xD00D             BEQ.N    ??drain_injected_commands_P_2
   \       0x24   0x2C0A             CMP      R4,#+10
   \       0x26   0xD00B             BEQ.N    ??drain_injected_commands_P_2
   \       0x28   0x1C76             ADDS     R6,R6,#+1
   \       0x2A   0xE7F8             B.N      ??drain_injected_commands_P_1
    917              cmd[i] = '\0';
    918              if (enqueue_and_echo_command(cmd))     // success?
    919                injected_commands_P = c ? injected_commands_P + i + 1 : NULL; // next command or done
   \                     ??drain_injected_commands_P_3: (+1)
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x6028             STR      R0,[R5, #+0]
    920            }
    921            return (injected_commands_P != NULL);    // return whether any more remain
   \                     ??drain_injected_commands_P_0: (+1)
   \       0x30   0x6828             LDR      R0,[R5, #+0]
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD001             BEQ.N    ??drain_injected_commands_P_4
   \       0x36   0x2001             MOVS     R0,#+1
   \       0x38   0xE000             B.N      ??drain_injected_commands_P_5
   \                     ??drain_injected_commands_P_4: (+1)
   \       0x3A   0x2000             MOVS     R0,#+0
   \                     ??drain_injected_commands_P_5: (+1)
   \       0x3C   0xB008             ADD      SP,SP,#+32
   \       0x3E   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??drain_injected_commands_P_2: (+1)
   \       0x40   0x5581             STRB     R1,[R0, R6]
   \       0x42   0x.... 0x....      BL       _Z24enqueue_and_echo_commandPKcb
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD0F2             BEQ.N    ??drain_injected_commands_P_0
   \       0x4A   0x2C00             CMP      R4,#+0
   \       0x4C   0xD0EE             BEQ.N    ??drain_injected_commands_P_3
   \       0x4E   0x6828             LDR      R0,[R5, #+0]
   \       0x50   0x4430             ADD      R0,R0,R6
   \       0x52   0x1C40             ADDS     R0,R0,#+1
   \       0x54   0x6028             STR      R0,[R5, #+0]
   \       0x56   0xE7EB             B.N      ??drain_injected_commands_P_0
    922          }
    923          
    924          /**
    925           * Record one or many commands to run from program memory.
    926           * Aborts the current queue, if any.
    927           * Note: drain_injected_commands_P() must be called repeatedly to drain the commands afterwards
    928           */

   \                                 In section .text, align 2, keep-with-next
    929          void enqueue_and_echo_commands_P(const char* pgcode) {
    930            injected_commands_P = pgcode;
   \                     _Z27enqueue_and_echo_commands_PPKc: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable116_1
   \        0x4   0x6008             STR      R0,[R1, #+0]
    931            drain_injected_commands_P(); // first command executed asap (when possible)
   \        0x6   0x....             B.N      _ZN37_INTERNAL_15_Marlin_main_cpp_3178531925drain_injected_commands_PEv
    932          }
    933          
    934          /**
    935           * Clear the Marlin command queue
    936           */

   \                                 In section .text, align 2, keep-with-next
    937          void clear_command_queue() {
    938            cmd_queue_index_r = cmd_queue_index_w;
   \                     _Z19clear_command_queuev: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable116_2
   \        0x4   0x7A81             LDRB     R1,[R0, #+10]
   \        0x6   0x7241             STRB     R1,[R0, #+9]
    939            commands_in_queue = 0;
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x7201             STRB     R1,[R0, #+8]
    940          }
   \        0xC   0x4770             BX       LR               ;; return
    941          
    942          /**
    943           * Once a new command is in the ring buffer, call this to commit it
    944           */

   \                                 In section .text, align 4
    945          inline void _commit_command(bool say_ok) {
    946            send_ok[cmd_queue_index_w] = say_ok;
   \                     _Z15_commit_commandb: (+1)
   \        0x0   0x4907             LDR.N    R1,??_commit_command_0
   \        0x2   0x7A8A             LDRB     R2,[R1, #+10]
   \        0x4   0x4613             MOV      R3,R2
   \        0x6   0x440B             ADD      R3,R1,R3
   \        0x8   0x7518             STRB     R0,[R3, #+20]
    947            if (++cmd_queue_index_w >= BUFSIZE) cmd_queue_index_w = 0;
   \        0xA   0x1C52             ADDS     R2,R2,#+1
   \        0xC   0x728A             STRB     R2,[R1, #+10]
   \        0xE   0xB2D2             UXTB     R2,R2
   \       0x10   0x2A04             CMP      R2,#+4
   \       0x12   0xDB01             BLT.N    ??_commit_command_1
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x7288             STRB     R0,[R1, #+10]
    948            commands_in_queue++;
   \                     ??_commit_command_1: (+1)
   \       0x18   0x7A08             LDRB     R0,[R1, #+8]
   \       0x1A   0x1C40             ADDS     R0,R0,#+1
   \       0x1C   0x7208             STRB     R0,[R1, #+8]
    949          }
   \       0x1E   0x4770             BX       LR               ;; return
   \                     ??_commit_command_0:
   \       0x20   0x....'....        DC32     axis_relative_modes
    950          
    951          /**
    952           * Copy a command from RAM into the main command buffer.
    953           * Return true if the command was successfully added.
    954           * Return false for a full buffer, or if the 'command' is a comment.
    955           */

   \                                 In section .text, align 4
    956          inline bool _enqueuecommand(const char* cmd, bool say_ok=false) {
   \                     _Z15_enqueuecommandPKcb: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x460C             MOV      R4,R1
    957            if (*cmd == ';' || commands_in_queue >= BUFSIZE) return false;
   \        0x4   0xF990 0x1000      LDRSB    R1,[R0, #+0]
   \        0x8   0x293B             CMP      R1,#+59
   \        0xA   0xD003             BEQ.N    ??_enqueuecommand_1
   \        0xC   0x4A09             LDR.N    R2,??_enqueuecommand_0
   \        0xE   0x7A11             LDRB     R1,[R2, #+8]
   \       0x10   0x2904             CMP      R1,#+4
   \       0x12   0xDB01             BLT.N    ??_enqueuecommand_2
   \                     ??_enqueuecommand_1: (+1)
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xBD10             POP      {R4,PC}
    958            strcpy(command_queue[cmd_queue_index_w], cmd);
   \                     ??_enqueuecommand_2: (+1)
   \       0x18   0x4601             MOV      R1,R0
   \       0x1A   0x4807             LDR.N    R0,??_enqueuecommand_0+0x4
   \       0x1C   0x7A92             LDRB     R2,[R2, #+10]
   \       0x1E   0xEB02 0x0342      ADD      R3,R2,R2, LSL #+1
   \       0x22   0xEB00 0x1043      ADD      R0,R0,R3, LSL #+5
   \       0x26   0x.... 0x....      BL       strcpy
    959            _commit_command(say_ok);
   \       0x2A   0x4620             MOV      R0,R4
   \       0x2C   0x.... 0x....      BL       _Z15_commit_commandb
    960            return true;
   \       0x30   0x2001             MOVS     R0,#+1
   \       0x32   0xBD10             POP      {R4,PC}          ;; return
   \                     ??_enqueuecommand_0:
   \       0x34   0x....'....        DC32     axis_relative_modes
   \       0x38   0x....'....        DC32     command_queue
    961          }
    962          
    963          /**
    964           * Enqueue with Serial Echo
    965           */

   \                                 In section .text, align 2, keep-with-next
    966          bool enqueue_and_echo_command(const char* cmd, bool say_ok/*=false*/) {
   \                     _Z24enqueue_and_echo_commandPKcb: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    967            if (_enqueuecommand(cmd, say_ok)) {
   \        0x4   0x.... 0x....      BL       _Z15_enqueuecommandPKcb
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD02A             BEQ.N    ??enqueue_and_echo_command_0
    968              SERIAL_ECHO_START;
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable116_3
   \       0x10   0x.... 0x....      BL       _Z14serialprintPGMPKc
    969              SERIAL_ECHOPAIR(MSG_ENQUEUEING, cmd);
   \       0x14   0x4621             MOV      R1,R4
   \       0x16   0x.... 0x....      ADR.W    R0,?_0
   \       0x1A   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
    970              SERIAL_CHAR('"');
   \       0x1E   0x.... 0x....      LDR.W    R4,??DataTable112_3
   \       0x22   0x79E0             LDRB     R0,[R4, #+7]
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD105             BNE.N    ??enqueue_and_echo_command_1
   \       0x28   0x2122             MOVS     R1,#+34
   \       0x2A   0x.... 0x....      LDR.W    R0,??DataTable116_4
   \       0x2E   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \       0x32   0xE005             B.N      ??enqueue_and_echo_command_2
   \                     ??enqueue_and_echo_command_1: (+1)
   \       0x34   0x2200             MOVS     R2,#+0
   \       0x36   0x2122             MOVS     R1,#+34
   \       0x38   0x.... 0x....      LDR.W    R0,??DataTable116_5
   \       0x3C   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
    971              SERIAL_EOL;
   \                     ??enqueue_and_echo_command_2: (+1)
   \       0x40   0x79E0             LDRB     R0,[R4, #+7]
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD105             BNE.N    ??enqueue_and_echo_command_3
   \       0x46   0x210A             MOVS     R1,#+10
   \       0x48   0x.... 0x....      LDR.W    R0,??DataTable116_4
   \       0x4C   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \       0x50   0xE005             B.N      ??enqueue_and_echo_command_4
   \                     ??enqueue_and_echo_command_3: (+1)
   \       0x52   0x2200             MOVS     R2,#+0
   \       0x54   0x210A             MOVS     R1,#+10
   \       0x56   0x.... 0x....      LDR.W    R0,??DataTable116_5
   \       0x5A   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
    972              return true;
   \                     ??enqueue_and_echo_command_4: (+1)
   \       0x5E   0x2001             MOVS     R0,#+1
   \       0x60   0xBD10             POP      {R4,PC}
    973            }
    974            return false;
   \                     ??enqueue_and_echo_command_0: (+1)
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0xBD10             POP      {R4,PC}          ;; return
    975          }
    976          

   \                                 In section .text, align 2, keep-with-next
    977          void setup_killpin() {
    978            #if HAS_KILL
    979              SET_INPUT_PULLUP(KILL_PIN);
    980            #endif
    981          }
   \                     _Z13setup_killpinv: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    982          
    983          #if ENABLED(FILAMENT_RUNOUT_SENSOR)
    984          

   \                                 In section .text, align 2, keep-with-next
    985            void setup_filrunoutpin() {
    986              #if ENABLED(ENDSTOPPULLUP_FIL_RUNOUT)
    987                SET_INPUT_PULLUP(FIL_RUNOUT_PIN);
    988              #else
    989                SET_INPUT(FIL_RUNOUT_PIN);
    990              #endif
    991            }
   \                     _Z18setup_filrunoutpinv: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    992          
    993          #endif
    994          

   \                                 In section .text, align 2, keep-with-next
    995          void setup_homepin(void) {
    996            #if HAS_HOME
    997              SET_INPUT_PULLUP(HOME_PIN);
    998            #endif
    999          }
   \                     _Z13setup_homepinv: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   1000          

   \                                 In section .text, align 2, keep-with-next
   1001          void setup_powerhold() {
   1002            #if HAS_SUICIDE
   1003              OUT_WRITE(SUICIDE_PIN, HIGH);
   1004            #endif
   1005            #if HAS_POWER_SWITCH
   1006              #if ENABLED(PS_DEFAULT_OFF)
   1007                OUT_WRITE(PS_ON_PIN, PS_ON_ASLEEP);
   1008              #else
   1009                OUT_WRITE(PS_ON_PIN, PS_ON_AWAKE);
   1010              #endif
   1011            #endif
   1012          }
   \                     _Z15setup_powerholdv: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   1013          

   \                                 In section .text, align 2, keep-with-next
   1014          void suicide() {
   1015            #if HAS_SUICIDE
   1016              OUT_WRITE(SUICIDE_PIN, LOW);
   1017            #endif
   1018          }
   \                     _Z7suicidev: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   1019          

   \                                 In section .text, align 2, keep-with-next
   1020          void servo_init() {
   1021            #if NUM_SERVOS >= 1 && HAS_SERVO_0
   1022              servo[0].attach(SERVO0_PIN);
   1023              servo[0].detach(); // Just set up the pin. We don't have a position yet. Don't move to a random position.
   1024            #endif
   1025            #if NUM_SERVOS >= 2 && HAS_SERVO_1
   1026              servo[1].attach(SERVO1_PIN);
   1027              servo[1].detach();
   1028            #endif
   1029            #if NUM_SERVOS >= 3 && HAS_SERVO_2
   1030              servo[2].attach(SERVO2_PIN);
   1031              servo[2].detach();
   1032            #endif
   1033            #if NUM_SERVOS >= 4 && HAS_SERVO_3
   1034              servo[3].attach(SERVO3_PIN);
   1035              servo[3].detach();
   1036            #endif
   1037          
   1038            #if HAS_Z_SERVO_ENDSTOP
   1039              /**
   1040               * Set position of Z Servo Endstop
   1041               *
   1042               * The servo might be deployed and positioned too low to stow
   1043               * when starting up the machine or rebooting the board.
   1044               * There's no way to know where the nozzle is positioned until
   1045               * homing has been done - no homing with z-probe without init!
   1046               *
   1047               */
   1048              STOW_Z_SERVO();
   1049            #endif
   1050          }
   \                     _Z10servo_initv: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   1051          
   1052          /**
   1053           * Stepper Reset (RigidBoard, et.al.)
   1054           */
   1055          #if HAS_STEPPER_RESET
   1056            void disableStepperDrivers() {
   1057              OUT_WRITE(STEPPER_RESET_PIN, LOW);  // drive it down to hold in reset motor driver chips
   1058            }
   1059            void enableStepperDrivers() { SET_INPUT(STEPPER_RESET_PIN); }  // set to input, which allows it to be pulled high by pullups
   1060          #endif
   1061          
   1062          #if ENABLED(EXPERIMENTAL_I2CBUS) && I2C_SLAVE_ADDRESS > 0
   1063          
   1064            void i2c_on_receive(int bytes) { // just echo all bytes received to serial
   1065              i2c.receive(bytes);
   1066            }
   1067          
   1068            void i2c_on_request() {          // just send dummy data for now
   1069              i2c.reply("Hello World!\n");
   1070            }
   1071          
   1072          #endif
   1073          
   1074          #if HAS_COLOR_LEDS
   1075          
   1076            void set_led_color(
   1077              const uint8_t r, const uint8_t g, const uint8_t b
   1078                #if ENABLED(RGBW_LED)
   1079                  , const uint8_t w=0
   1080                #endif
   1081            ) {
   1082          
   1083              #if ENABLED(BLINKM)
   1084          
   1085                // This variant uses i2c to send the RGB components to the device.
   1086                SendColors(r, g, b);
   1087          
   1088              #else
   1089          
   1090                // This variant uses 3 separate pins for the RGB components.
   1091                // If the pins can do PWM then their intensity will be set.
   1092                WRITE(RGB_LED_R_PIN, r ? HIGH : LOW);
   1093                WRITE(RGB_LED_G_PIN, g ? HIGH : LOW);
   1094                WRITE(RGB_LED_B_PIN, b ? HIGH : LOW);
   1095                analogWrite(RGB_LED_R_PIN, r);
   1096                analogWrite(RGB_LED_G_PIN, g);
   1097                analogWrite(RGB_LED_B_PIN, b);
   1098          
   1099                #if ENABLED(RGBW_LED)
   1100                  WRITE(RGB_LED_W_PIN, w ? HIGH : LOW);
   1101                  analogWrite(RGB_LED_W_PIN, w);
   1102                #endif
   1103          
   1104              #endif
   1105            }
   1106          
   1107          #endif // HAS_COLOR_LEDS
   1108          

   \                                 In section .text, align 2, keep-with-next
   1109          void gcode_line_error(const char* err, bool doFlush = true) {
   \                     _Z16gcode_line_errorPKcb: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   1110            SERIAL_ERROR_START;
   \        0x6   0x.... 0x....      LDR.W    R0,??DataTable116_6
   \        0xA   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1111            serialprintPGM(err);
   \        0xE   0x4620             MOV      R0,R4
   \       0x10   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1112            SERIAL_ERRORLN(gcode_LastN);
   \       0x14   0x.... 0x....      LDR.W    R4,??DataTable116_2
   \       0x18   0x6A21             LDR      R1,[R4, #+32]
   \       0x1A   0x.... 0x....      LDR.W    R6,??DataTable112_3
   \       0x1E   0x79F0             LDRB     R0,[R6, #+7]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD105             BNE.N    ??gcode_line_error_0
   \       0x24   0x220A             MOVS     R2,#+10
   \       0x26   0x.... 0x....      LDR.W    R0,??DataTable116_4
   \       0x2A   0x.... 0x....      BL       _ZN12MarlinSerial5printEli
   \       0x2E   0xE004             B.N      ??gcode_line_error_1
   \                     ??gcode_line_error_0: (+1)
   \       0x30   0x220A             MOVS     R2,#+10
   \       0x32   0x.... 0x....      LDR.W    R0,??DataTable116_5
   \       0x36   0x.... 0x....      BL       _ZN12MarlinSerial5printEli
   \                     ??gcode_line_error_1: (+1)
   \       0x3A   0x79F0             LDRB     R0,[R6, #+7]
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD105             BNE.N    ??gcode_line_error_2
   \       0x40   0x210A             MOVS     R1,#+10
   \       0x42   0x.... 0x....      LDR.W    R0,??DataTable116_4
   \       0x46   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \       0x4A   0xE005             B.N      ??gcode_line_error_3
   \                     ??gcode_line_error_2: (+1)
   \       0x4C   0x2200             MOVS     R2,#+0
   \       0x4E   0x210A             MOVS     R1,#+10
   \       0x50   0x.... 0x....      LDR.W    R0,??DataTable116_5
   \       0x54   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   1113            //Serial.println(gcode_N);
   1114            if (doFlush) FlushSerialRequestResend();
   \                     ??gcode_line_error_3: (+1)
   \       0x58   0x2D00             CMP      R5,#+0
   \       0x5A   0xD001             BEQ.N    ??gcode_line_error_4
   \       0x5C   0x.... 0x....      BL       _Z24FlushSerialRequestResendv
   1115            serial_count = 0;
   \                     ??gcode_line_error_4: (+1)
   \       0x60   0x2000             MOVS     R0,#+0
   \       0x62   0x6320             STR      R0,[R4, #+48]
   1116          }
   \       0x64   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .data, align 4
   \                     mks_heating_busy:
   \        0x0   0x00               DC8 0
   \                     marlin_debug_flags:
   \        0x1   0x00               DC8 0
   \                     active_extruder:
   \        0x2   0x00               DC8 0
   \                     wait_for_heatup:
   \        0x3   0x01               DC8 1
   \                     wait_for_user:
   \        0x4   0x00               DC8 0
   \                     target_extruder:
   \        0x5   0x00               DC8 0
   \                     busy_state:
   \        0x6   0x00               DC8 0
   1117          
   1118          /**
   1119           * Get all commands waiting on the serial port and queue them.
   1120           * Exit when the buffer is full or when no more characters are
   1121           * left on the serial port.
   1122           */
   1123           uint8_t serial_wait_tick = 0; //use to calculate the serial wait ticks
   1124          
   1125          uint8_t from_wifi_flag = 0; // whether data comes from wifi model
   \                     from_wifi_flag:
   \        0x7   0x00               DC8 0
   \                     current_position:
   \        0x8   0x0000'0000        DC32 0H
   \        0xC   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     destination:
   \       0x18   0x0000'0000        DC32 0H
   \       0x1C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     homing_feedrate_mm_s:
   \       0x28   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     home_offset:
   \       0x38   0x0000'0000        DC32 0H
   \       0x3C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     workspace_offset:
   \       0x44   0x0000'0000        DC32 0H
   \       0x48   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     soft_endstop_min:
   \       0x50   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     soft_endstop_max:
   \       0x5C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     delta:
   \       0x68   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \       0x74   0x41C8'0000        DC32 41C80000H
   \                     feedrate_percentage:
   \       0x78   0x0000'0064        DC32 100
   \                     xy_probe_feedrate_mm_s:
   \       0x7C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     delta_clip_start_height:
   \       0x80   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     ubl:
   \       0x84   0x00               DC8 0
   \       0x85   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   \       0x88   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \       0x98   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \       0xA8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \       0xB8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \       0xC8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \       0xD8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \       0xE8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \       0xF8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x108   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x118   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x128   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x138   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x148   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x158   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x168   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x178   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x188   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x198   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x1A8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x1B8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x1C8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x1D8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x1E8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x1F8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x208   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x218   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x228   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x238   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x248   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x258   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x268   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x278   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x288   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x298   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x2A8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x2B8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x2C8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x2D8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x2E8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x2F8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x308   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x318   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x328   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x338   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x348   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x358   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x368   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x378   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     print_job_timer:
   \      0x388   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     buzzer:
   \      0x398   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x3A8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   1126          

   \                                 In section .text, align 4
   1127          inline void get_serial_commands() {
   \                     _Z19get_serial_commandsv: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   1128            static char serial_line_buffer[MAX_CMD_SIZE];
   1129            static bool serial_comment_mode = false;
   1130          static millis_t last_wait_time = 0;
   1131              const millis_t wait_ms = millis();
   \        0x4   0x.... 0x....      BL       HAL_GetTick
   \        0x8   0x4604             MOV      R4,R0
   1132          
   1133            // If the command buffer is empty for too long,
   1134            // send "wait" to indicate Marlin is still waiting.
   1135            #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
   1136              static millis_t last_command_time = 0;
   1137              const millis_t ms = millis();
   1138              if (commands_in_queue == 0 && !MYSERIAL.available() && ELAPSED(ms, last_command_time + NO_TIMEOUTS)) {
   1139                SERIAL_ECHOLNPGM(MSG_WAIT);
   1140                last_command_time = ms;
   1141              }
   1142            #endif
   1143          
   1144          #ifdef USE_MKS_WIFI
   1145          
   1146          	/*5s?¨¬2a2?¦Ì?¡ä??¨²¨ºy?Y?¨°¨¨??a??¨®D¨¢a?¨²????¡ê??¨¦¨º1¨®?wifi*/
   1147             if (commands_in_queue == 0 && !MYSERIAL.available() && ELAPSED(wait_ms, last_wait_time + 1000)) {
   \        0xA   0x4E7F             LDR.N    R6,??get_serial_commands_0
   \        0xC   0x7A30             LDRB     R0,[R6, #+8]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xF040 0x8097      BNE.W    ??get_serial_commands_1
   \       0x14   0x487D             LDR.N    R0,??get_serial_commands_0+0x4
   \       0x16   0x.... 0x....      BL       _ZN12MarlinSerial9availableEv
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xF040 0x8091      BNE.W    ??get_serial_commands_1
   \       0x20   0x487B             LDR.N    R0,??get_serial_commands_0+0x8
   \       0x22   0x6801             LDR      R1,[R0, #+0]
   \       0x24   0x1A61             SUBS     R1,R4,R1
   \       0x26   0xF5B1 0x717A      SUBS     R1,R1,#+1000
   \       0x2A   0xF100 0x808A      BMI.W    ??get_serial_commands_1
   1148                if(serial_wait_tick <= 5)
   \       0x2E   0x7BB1             LDRB     R1,[R6, #+14]
   \       0x30   0x460A             MOV      R2,R1
   \       0x32   0x2A06             CMP      R2,#+6
   \       0x34   0xDA01             BGE.N    ??get_serial_commands_2
   1149          	{
   1150          		serial_wait_tick ++;
   \       0x36   0x1C49             ADDS     R1,R1,#+1
   \       0x38   0x73B1             STRB     R1,[R6, #+14]
   1151          	}
   1152                last_wait_time = wait_ms;
   \                     ??get_serial_commands_2: (+1)
   \       0x3A   0x6004             STR      R4,[R0, #+0]
   \       0x3C   0xE081             B.N      ??get_serial_commands_1
   1153              }
   1154          #endif
   1155            /**
   1156             * Loop while serial characters are incoming and the queue is not full
   1157             */
   1158            while (commands_in_queue < BUFSIZE && MYSERIAL.available() > 0) {
   1159          
   1160              char serial_char = MYSERIAL.read();
   1161          
   1162          	serial_wait_tick = 0;
   1163          	from_wifi_flag = 0;
   1164          
   1165              /**
   1166               * If the character ends the line
   1167               */
   1168              if (serial_char == '\n' || serial_char == '\r') {
   1169          
   1170                serial_comment_mode = false; // end of line == end of comment
   1171          
   1172                if (!serial_count) continue; // skip empty lines
   1173          
   1174                serial_line_buffer[serial_count] = 0; // terminate string
   1175                serial_count = 0; //reset buffer
   1176          
   1177                char* command = serial_line_buffer;
   1178          
   1179                while (*command == ' ') command++; // skip any leading spaces
   \                     ??get_serial_commands_3: (+1)
   \       0x3E   0xF109 0x0901      ADD      R9,R9,#+1
   \                     ??get_serial_commands_4: (+1)
   \       0x42   0xF999 0x0000      LDRSB    R0,[R9, #+0]
   \       0x46   0x2820             CMP      R0,#+32
   \       0x48   0xD0F9             BEQ.N    ??get_serial_commands_3
   1180                char* npos = (*command == 'N') ? command : NULL; // Require the N parameter to start the line
   \       0x4A   0x284E             CMP      R0,#+78
   \       0x4C   0xD101             BNE.N    ??get_serial_commands_5
   \       0x4E   0x464D             MOV      R5,R9
   \       0x50   0xE000             B.N      ??get_serial_commands_6
   \                     ??get_serial_commands_5: (+1)
   \       0x52   0x460D             MOV      R5,R1
   1181                char* apos = strchr(command, '*');
   \                     ??get_serial_commands_6: (+1)
   \       0x54   0x212A             MOVS     R1,#+42
   \       0x56   0x4648             MOV      R0,R9
   \       0x58   0x.... 0x....      BL       __iar_Strchr
   \       0x5C   0x4604             MOV      R4,R0
   1182          
   1183                if (npos) {
   \       0x5E   0x2D00             CMP      R5,#+0
   \       0x60   0xF000 0x80A7      BEQ.W    ??get_serial_commands_7
   1184          
   1185                  bool M110 = strstr_P(command, PSTR("M110")) != NULL;
   \       0x64   0x496B             LDR.N    R1,??get_serial_commands_0+0xC
   \       0x66   0x4648             MOV      R0,R9
   \       0x68   0x.... 0x....      BL       __iar_Strstr
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0xD002             BEQ.N    ??get_serial_commands_8
   \       0x70   0xF04F 0x0A01      MOV      R10,#+1
   \       0x74   0xE001             B.N      ??get_serial_commands_9
   \                     ??get_serial_commands_8: (+1)
   \       0x76   0xF04F 0x0A00      MOV      R10,#+0
   1186          
   1187                  if (M110) {
   \                     ??get_serial_commands_9: (+1)
   \       0x7A   0x4650             MOV      R0,R10
   \       0x7C   0x2800             CMP      R0,#+0
   \       0x7E   0xD007             BEQ.N    ??get_serial_commands_10
   1188                    char* n2pos = strchr(command + 4, 'N');
   \       0x80   0x214E             MOVS     R1,#+78
   \       0x82   0xF109 0x0004      ADD      R0,R9,#+4
   \       0x86   0x.... 0x....      BL       __iar_Strchr
   1189                    if (n2pos) npos = n2pos;
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0xD000             BEQ.N    ??get_serial_commands_10
   \       0x8E   0x4605             MOV      R5,R0
   1190                  }
   1191          
   1192                  gcode_N = strtol(npos + 1, NULL, 10);
   \                     ??get_serial_commands_10: (+1)
   \       0x90   0x220A             MOVS     R2,#+10
   \       0x92   0x2100             MOVS     R1,#+0
   \       0x94   0x1C68             ADDS     R0,R5,#+1
   \       0x96   0x.... 0x....      BL       strtol
   \       0x9A   0x61F0             STR      R0,[R6, #+28]
   1193          
   1194                  if (gcode_N != gcode_LastN + 1 && !M110) {
   \       0x9C   0x6A31             LDR      R1,[R6, #+32]
   \       0x9E   0x1C49             ADDS     R1,R1,#+1
   \       0xA0   0x4288             CMP      R0,R1
   \       0xA2   0xD002             BEQ.N    ??get_serial_commands_11
   \       0xA4   0xF1BA 0x0F00      CMP      R10,#+0
   \       0xA8   0xD004             BEQ.N    ??get_serial_commands_12
   1195                    gcode_line_error(PSTR(MSG_ERR_LINE_NO));
   1196                    return;
   1197                  }
   1198          
   1199                  if (apos) {
   \                     ??get_serial_commands_11: (+1)
   \       0xAA   0x2C00             CMP      R4,#+0
   \       0xAC   0xD07B             BEQ.N    ??get_serial_commands_13
   1200                    byte checksum = 0, count = 0;
   \       0xAE   0x2500             MOVS     R5,#+0
   \       0xB0   0x4628             MOV      R0,R5
   \       0xB2   0xE007             B.N      ??get_serial_commands_14
   \                     ??get_serial_commands_12: (+1)
   \       0xB4   0x2101             MOVS     R1,#+1
   \       0xB6   0x4858             LDR.N    R0,??get_serial_commands_0+0x10
   \       0xB8   0xE8BD 0x47F0      POP      {R4-R10,LR}
   \       0xBC   0x.... 0x....      B.W      _Z16gcode_line_errorPKcb
   1201                    while (command[count] != '*') checksum ^= command[count++];
   \                     ??get_serial_commands_15: (+1)
   \       0xC0   0x404D             EORS     R5,R1,R5
   \       0xC2   0x1C40             ADDS     R0,R0,#+1
   \                     ??get_serial_commands_14: (+1)
   \       0xC4   0x4601             MOV      R1,R0
   \       0xC6   0xB2C9             UXTB     R1,R1
   \       0xC8   0xF919 0x1001      LDRSB    R1,[R9, R1]
   \       0xCC   0x292A             CMP      R1,#+42
   \       0xCE   0xD1F7             BNE.N    ??get_serial_commands_15
   1202          
   1203                    if (strtol(apos + 1, NULL, 10) != checksum) {
   \       0xD0   0x220A             MOVS     R2,#+10
   \       0xD2   0x2100             MOVS     R1,#+0
   \       0xD4   0x1C60             ADDS     R0,R4,#+1
   \       0xD6   0x.... 0x....      BL       strtol
   \       0xDA   0xB2ED             UXTB     R5,R5
   \       0xDC   0x42A8             CMP      R0,R5
   \       0xDE   0xD154             BNE.N    ??get_serial_commands_16
   1204                      gcode_line_error(PSTR(MSG_ERR_CHECKSUM_MISMATCH));
   1205                      return;
   1206                    }
   1207                    // if no errors, continue parsing
   1208                  }
   1209                  else {
   1210                    gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM));
   1211                    return;
   1212                  }
   1213          
   1214                  gcode_LastN = gcode_N;
   \       0xE0   0x69F0             LDR      R0,[R6, #+28]
   \       0xE2   0x6230             STR      R0,[R6, #+32]
   1215                  // if no errors, continue parsing
   1216                }
   1217                else if (apos) { // No '*' without 'N'
   1218                  gcode_line_error(PSTR(MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM), false);
   1219                  return;
   1220                }
   1221          
   1222                // Movement commands alert when stopped
   1223                if (IsStopped()) {
   \                     ??get_serial_commands_17: (+1)
   \       0xE4   0x.... 0x....      BL       _Z9IsStoppedv
   \       0xE8   0x2800             CMP      R0,#+0
   \       0xEA   0xD00C             BEQ.N    ??get_serial_commands_18
   1224                  char* gpos = strchr(command, 'G');
   \       0xEC   0x2147             MOVS     R1,#+71
   \       0xEE   0x4648             MOV      R0,R9
   \       0xF0   0x.... 0x....      BL       __iar_Strchr
   1225                  if (gpos) {
   \       0xF4   0x2800             CMP      R0,#+0
   \       0xF6   0xD006             BEQ.N    ??get_serial_commands_18
   1226                    const int codenum = strtol(gpos + 1, NULL, 10);
   1227                    switch (codenum) {
   \       0xF8   0x220A             MOVS     R2,#+10
   \       0xFA   0x2100             MOVS     R1,#+0
   \       0xFC   0x1C40             ADDS     R0,R0,#+1
   \       0xFE   0x.... 0x....      BL       strtol
   \      0x102   0x2803             CMP      R0,#+3
   \      0x104   0xD947             BLS.N    ??get_serial_commands_19
   1228                      case 0:
   1229                      case 1:
   1230                      case 2:
   1231                      case 3:
   1232                        SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
   1233                        LCD_MESSAGEPGM(MSG_STOPPED);
   1234                        break;
   1235                    }
   1236                  }
   1237                }
   1238          
   1239                #if DISABLED(EMERGENCY_PARSER)
   1240                  // If command was e-stop process now
   1241                  if (strcmp(command, "M108") == 0) {
   \                     ??get_serial_commands_18: (+1)
   \      0x106   0x4945             LDR.N    R1,??get_serial_commands_0+0x14
   \      0x108   0x4648             MOV      R0,R9
   \      0x10A   0x.... 0x....      BL       strcmp
   \      0x10E   0x2800             CMP      R0,#+0
   \      0x110   0xD102             BNE.N    ??get_serial_commands_20
   1242                    wait_for_heatup = false;
   \      0x112   0x2000             MOVS     R0,#+0
   \      0x114   0x70F8             STRB     R0,[R7, #+3]
   1243                    #if ENABLED(ULTIPANEL)
   1244                      wait_for_user = false;
   \      0x116   0x7138             STRB     R0,[R7, #+4]
   1245                    #endif
   1246                  }
   1247                  if (strcmp(command, "M112") == 0) kill(PSTR(MSG_KILLED));
   \                     ??get_serial_commands_20: (+1)
   \      0x118   0x4941             LDR.N    R1,??get_serial_commands_0+0x18
   \      0x11A   0x4648             MOV      R0,R9
   \      0x11C   0x.... 0x....      BL       strcmp
   \      0x120   0x2800             CMP      R0,#+0
   \      0x122   0xD102             BNE.N    ??get_serial_commands_21
   \      0x124   0x483F             LDR.N    R0,??get_serial_commands_0+0x1C
   \      0x126   0x.... 0x....      BL       _Z4killPKc
   1248                  if (strcmp(command, "M410") == 0) { quickstop_stepper(); }
   \                     ??get_serial_commands_21: (+1)
   \      0x12A   0x493F             LDR.N    R1,??get_serial_commands_0+0x20
   \      0x12C   0x4648             MOV      R0,R9
   \      0x12E   0x.... 0x....      BL       strcmp
   \      0x132   0x2800             CMP      R0,#+0
   \      0x134   0xD101             BNE.N    ??get_serial_commands_22
   \      0x136   0x.... 0x....      BL       _Z17quickstop_stepperv
   1249                #endif
   1250          
   1251                #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
   1252                  last_command_time = ms;
   1253                #endif
   1254          
   1255                // Add the command to the queue
   1256                _enqueuecommand(serial_line_buffer, true);
   \                     ??get_serial_commands_22: (+1)
   \      0x13A   0x2101             MOVS     R1,#+1
   \      0x13C   0x4640             MOV      R0,R8
   \      0x13E   0x.... 0x....      BL       _Z15_enqueuecommandPKcb
   \                     ??get_serial_commands_1: (+1)
   \      0x142   0x7A30             LDRB     R0,[R6, #+8]
   \      0x144   0x2804             CMP      R0,#+4
   \      0x146   0xDA5C             BGE.N    ??get_serial_commands_23
   \      0x148   0x4C30             LDR.N    R4,??get_serial_commands_0+0x4
   \      0x14A   0x4620             MOV      R0,R4
   \      0x14C   0x.... 0x....      BL       _ZN12MarlinSerial9availableEv
   \      0x150   0x2800             CMP      R0,#+0
   \      0x152   0xDD56             BLE.N    ??get_serial_commands_23
   \      0x154   0x4620             MOV      R0,R4
   \      0x156   0x.... 0x....      BL       _ZN12MarlinSerial4readEv
   \      0x15A   0xB240             SXTB     R0,R0
   \      0x15C   0x2100             MOVS     R1,#+0
   \      0x15E   0x73B1             STRB     R1,[R6, #+14]
   \      0x160   0x4F32             LDR.N    R7,??get_serial_commands_0+0x24
   \      0x162   0x71F9             STRB     R1,[R7, #+7]
   \      0x164   0x280A             CMP      R0,#+10
   \      0x166   0xD001             BEQ.N    ??get_serial_commands_24
   \      0x168   0x280D             CMP      R0,#+13
   \      0x16A   0xD12A             BNE.N    ??get_serial_commands_25
   \                     ??get_serial_commands_24: (+1)
   \      0x16C   0x4608             MOV      R0,R1
   \      0x16E   0x4930             LDR.N    R1,??get_serial_commands_0+0x28
   \      0x170   0x7008             STRB     R0,[R1, #+0]
   \      0x172   0x6B30             LDR      R0,[R6, #+48]
   \      0x174   0x2800             CMP      R0,#+0
   \      0x176   0xD0E4             BEQ.N    ??get_serial_commands_1
   \      0x178   0xF8DF 0x80B8      LDR.W    R8,??get_serial_commands_0+0x2C
   \      0x17C   0x2100             MOVS     R1,#+0
   \      0x17E   0xF808 0x1000      STRB     R1,[R8, R0]
   \      0x182   0x4608             MOV      R0,R1
   \      0x184   0x6330             STR      R0,[R6, #+48]
   \      0x186   0x46C1             MOV      R9,R8
   \      0x188   0xE75B             B.N      ??get_serial_commands_4
   \                     ??get_serial_commands_16: (+1)
   \      0x18A   0x2101             MOVS     R1,#+1
   \      0x18C   0x482A             LDR.N    R0,??get_serial_commands_0+0x30
   \      0x18E   0xE8BD 0x47F0      POP      {R4-R10,LR}
   \      0x192   0x.... 0x....      B.W      _Z16gcode_line_errorPKcb
   \                     ??get_serial_commands_19: (+1)
   \      0x196   0x4829             LDR.N    R0,??get_serial_commands_0+0x34
   \      0x198   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \      0x19C   0x2100             MOVS     R1,#+0
   \      0x19E   0x4828             LDR.N    R0,??get_serial_commands_0+0x38
   \      0x1A0   0x.... 0x....      BL       _Z16lcd_setstatuspgmPKch
   \      0x1A4   0xE7AF             B.N      ??get_serial_commands_18
   \                     ??get_serial_commands_13: (+1)
   \      0x1A6   0x2101             MOVS     R1,#+1
   \      0x1A8   0x4826             LDR.N    R0,??get_serial_commands_0+0x3C
   \      0x1AA   0xE8BD 0x47F0      POP      {R4-R10,LR}
   \      0x1AE   0x.... 0x....      B.W      _Z16gcode_line_errorPKcb
   \                     ??get_serial_commands_7: (+1)
   \      0x1B2   0x2C00             CMP      R4,#+0
   \      0x1B4   0xD096             BEQ.N    ??get_serial_commands_17
   \      0x1B6   0x2100             MOVS     R1,#+0
   \      0x1B8   0x4823             LDR.N    R0,??get_serial_commands_0+0x40
   \      0x1BA   0xE8BD 0x47F0      POP      {R4-R10,LR}
   \      0x1BE   0x.... 0x....      B.W      _Z16gcode_line_errorPKcb
   1257              }
   1258              else if (serial_count >= MAX_CMD_SIZE - 1) {
   \                     ??get_serial_commands_25: (+1)
   \      0x1C2   0x6B31             LDR      R1,[R6, #+48]
   \      0x1C4   0x295F             CMP      R1,#+95
   \      0x1C6   0xDABC             BGE.N    ??get_serial_commands_1
   1259                // Keep fetching, but ignore normal characters beyond the max length
   1260                // The command will be injected when EOL is reached
   1261              }
   1262              else if (serial_char == '\\') {  // Handle escapes
   \      0x1C8   0x285C             CMP      R0,#+92
   \      0x1CA   0xD10C             BNE.N    ??get_serial_commands_26
   1263                if (MYSERIAL.available() > 0) {
   \      0x1CC   0x4620             MOV      R0,R4
   \      0x1CE   0x.... 0x....      BL       _ZN12MarlinSerial9availableEv
   \      0x1D2   0x2800             CMP      R0,#+0
   \      0x1D4   0xDDB5             BLE.N    ??get_serial_commands_1
   1264                  // if we have one more character, copy it over
   1265                  serial_char = MYSERIAL.read();
   \      0x1D6   0x4620             MOV      R0,R4
   \      0x1D8   0x.... 0x....      BL       _ZN12MarlinSerial4readEv
   1266                  if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
   \      0x1DC   0x4914             LDR.N    R1,??get_serial_commands_0+0x28
   \      0x1DE   0x7809             LDRB     R1,[R1, #+0]
   \      0x1E0   0x2900             CMP      R1,#+0
   \      0x1E2   0xD1AE             BNE.N    ??get_serial_commands_1
   \      0x1E4   0xE007             B.N      ??get_serial_commands_27
   1267                }
   1268                // otherwise do nothing
   1269              }
   1270              else { // it's not a newline, carriage return or escape char
   1271                if (serial_char == ';') serial_comment_mode = true;
   \                     ??get_serial_commands_26: (+1)
   \      0x1E6   0x4912             LDR.N    R1,??get_serial_commands_0+0x28
   \      0x1E8   0x283B             CMP      R0,#+59
   \      0x1EA   0xD101             BNE.N    ??get_serial_commands_28
   \      0x1EC   0x2201             MOVS     R2,#+1
   \      0x1EE   0x700A             STRB     R2,[R1, #+0]
   1272                if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
   \                     ??get_serial_commands_28: (+1)
   \      0x1F0   0x7809             LDRB     R1,[R1, #+0]
   \      0x1F2   0x2900             CMP      R1,#+0
   \      0x1F4   0xD1A5             BNE.N    ??get_serial_commands_1
   \                     ??get_serial_commands_27: (+1)
   \      0x1F6   0x6B31             LDR      R1,[R6, #+48]
   \      0x1F8   0x4A0E             LDR.N    R2,??get_serial_commands_0+0x2C
   \      0x1FA   0x5450             STRB     R0,[R2, R1]
   \      0x1FC   0x1C49             ADDS     R1,R1,#+1
   \      0x1FE   0x6331             STR      R1,[R6, #+48]
   \      0x200   0xE79F             B.N      ??get_serial_commands_1
   1273              }
   1274          
   1275            } // queue has space, serial has data
   1276          }
   \                     ??get_serial_commands_23: (+1)
   \      0x202   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   \      0x206   0xBF00             Nop      
   \                     ??get_serial_commands_0:
   \      0x208   0x....'....        DC32     axis_relative_modes
   \      0x20C   0x....'....        DC32     customizedSerial
   \      0x210   0x....'....        DC32     _ZZ19get_serial_commandsvE14last_wait_time
   \      0x214   0x....'....        DC32     _ZZ19get_serial_commandsvEs
   \      0x218   0x....'....        DC32     _ZZ19get_serial_commandsvEs_0
   \      0x21C   0x....'....        DC32     _ZZ19get_serial_commandsvEs_6
   \      0x220   0x....'....        DC32     _ZZ19get_serial_commandsvEs_7
   \      0x224   0x....'....        DC32     _ZZ19get_serial_commandsvEs_8
   \      0x228   0x....'....        DC32     _ZZ19get_serial_commandsvEs_9
   \      0x22C   0x....'....        DC32     mks_heating_busy
   \      0x230   0x....'....        DC32     _ZZ19get_serial_commandsvE19serial_comment_mode
   \      0x234   0x....'....        DC32     _ZZ19get_serial_commandsvE18serial_line_buffer
   \      0x238   0x....'....        DC32     _ZZ19get_serial_commandsvEs_1
   \      0x23C   0x....'....        DC32     _ZZ19get_serial_commandsvEs_4
   \      0x240   0x....'....        DC32     _ZZ19get_serial_commandsvEs_5
   \      0x244   0x....'....        DC32     _ZZ19get_serial_commandsvEs_2
   \      0x248   0x....'....        DC32     _ZZ19get_serial_commandsvEs_3
   1277          
   1278          #if ENABLED(SDSUPPORT)
   1279          
   1280            /**
   1281             * Get commands from the SD Card until the command buffer is full
   1282             * or until the end of the file is reached. The special character '#'
   1283             * can also interrupt buffering.
   1284             */

   \                                 In section .text, align 4
   1285            inline void get_sdcard_commands() {
   \                     _Z19get_sdcard_commandsv: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   1286              static bool stop_buffering = false,
   1287                          sd_comment_mode = false;
   1288          
   1289              if (!card.sdprinting) 
   \        0x4   0x4E47             LDR.N    R6,??get_sdcard_commands_0
   \        0x6   0x78B0             LDRB     R0,[R6, #+2]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xF000 0x8088      BEQ.W    ??get_sdcard_commands_1
   1290                return;
   1291          
   1292              /**
   1293               * '#' stops reading from SD to the buffer prematurely, so procedural
   1294               * macro calls are possible. If it occurs, stop_buffering is triggered
   1295               * and the buffer is run dry; this character _can_ occur in serial com
   1296               * due to checksums, however, no checksums are used in SD printing.
   1297               */
   1298          
   1299              if (commands_in_queue == 0) stop_buffering = false;
   \        0xE   0x4F46             LDR.N    R7,??get_sdcard_commands_0+0x4
   \       0x10   0x7A38             LDRB     R0,[R7, #+8]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD102             BNE.N    ??get_sdcard_commands_2
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x4944             LDR.N    R1,??get_sdcard_commands_0+0x8
   \       0x1A   0x7008             STRB     R0,[R1, #+0]
   1300          
   1301              uint16_t sd_count = 0;
   \                     ??get_sdcard_commands_2: (+1)
   \       0x1C   0x2500             MOVS     R5,#+0
   1302              bool card_eof = card.eof();
   \       0x1E   0x4630             MOV      R0,R6
   \       0x20   0x.... 0x....      BL       _ZN10CardReader3eofEv
   \       0x24   0x4604             MOV      R4,R0
   \       0x26   0xF8DF 0x9104      LDR.W    R9,??get_sdcard_commands_0+0x8
   \       0x2A   0xE01F             B.N      ??get_sdcard_commands_3
   1303              while (commands_in_queue < BUFSIZE && !card_eof && !stop_buffering) {
   1304                const int16_t n = card.get();
   1305                char sd_char = (char)n;
   1306                card_eof = card.eof();
   1307                if (card_eof || n == -1
   1308                    || sd_char == '\n' || sd_char == '\r'
   1309                    || ((sd_char == '#' || sd_char == ':') && !sd_comment_mode)
   1310                ) {
   1311                  if (card_eof) {
   1312                    SERIAL_PROTOCOLLNPGM(MSG_FILE_PRINTED);
   1313                    card.printingHasFinished();
   1314                    #if ENABLED(PRINTER_EVENT_LEDS)
   1315                      LCD_MESSAGEPGM(MSG_INFO_COMPLETED_PRINTS);
   1316                      set_led_color(0, 255, 0); // Green
   1317                      #if HAS_RESUME_CONTINUE
   1318                        enqueue_and_echo_commands_P(PSTR("M0")); // end of the queue!
   1319                      #else
   1320                        safe_delay(1000);
   1321                      #endif
   1322                      set_led_color(0, 0, 0);   // OFF
   1323                    #endif
   1324                    card.checkautostart(true);
   1325                  }
   1326                  else if (n == -1) {
   \                     ??get_sdcard_commands_4: (+1)
   \       0x2C   0xF11A 0x0F01      CMN      R10,#+1
   \       0x30   0xD105             BNE.N    ??get_sdcard_commands_5
   1327                    SERIAL_ERROR_START;
   \       0x32   0x483F             LDR.N    R0,??get_sdcard_commands_0+0xC
   \       0x34   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1328                    SERIAL_ECHOLNPGM(MSG_SD_ERR_READ);
   \       0x38   0x483E             LDR.N    R0,??get_sdcard_commands_0+0x10
   \       0x3A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1329                  }
   1330                  if (sd_char == '#') stop_buffering = true;
   \                     ??get_sdcard_commands_5: (+1)
   \       0x3E   0xF1B8 0x0F23      CMP      R8,#+35
   \       0x42   0xD102             BNE.N    ??get_sdcard_commands_6
   \       0x44   0x2001             MOVS     R0,#+1
   \       0x46   0xF889 0x0000      STRB     R0,[R9, #+0]
   1331          
   1332                  sd_comment_mode = false; // for new command
   \                     ??get_sdcard_commands_6: (+1)
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0x493A             LDR.N    R1,??get_sdcard_commands_0+0x14
   \       0x4E   0x7008             STRB     R0,[R1, #+0]
   1333          
   1334                  if (!sd_count) continue; // skip empty lines (and comment lines)
   \       0x50   0x2D00             CMP      R5,#+0
   \       0x52   0xD00B             BEQ.N    ??get_sdcard_commands_3
   1335          
   1336                  command_queue[cmd_queue_index_w][sd_count] = '\0'; // terminate string
   \       0x54   0x4839             LDR.N    R0,??get_sdcard_commands_0+0x18
   \       0x56   0x7AB9             LDRB     R1,[R7, #+10]
   \       0x58   0xEB01 0x0241      ADD      R2,R1,R1, LSL #+1
   \       0x5C   0xEB00 0x1042      ADD      R0,R0,R2, LSL #+5
   \       0x60   0x2100             MOVS     R1,#+0
   \       0x62   0x5541             STRB     R1,[R0, R5]
   1337                  sd_count = 0; // clear sd line buffer
   \       0x64   0x460D             MOV      R5,R1
   1338          
   1339                  _commit_command(false);
   \       0x66   0x4608             MOV      R0,R1
   \       0x68   0x.... 0x....      BL       _Z15_commit_commandb
   \                     ??get_sdcard_commands_3: (+1)
   \       0x6C   0x7A38             LDRB     R0,[R7, #+8]
   \       0x6E   0x2804             CMP      R0,#+4
   \       0x70   0xDA55             BGE.N    ??get_sdcard_commands_1
   \       0x72   0x2C00             CMP      R4,#+0
   \       0x74   0xD153             BNE.N    ??get_sdcard_commands_1
   \       0x76   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD14F             BNE.N    ??get_sdcard_commands_1
   \       0x7E   0x4630             MOV      R0,R6
   \       0x80   0x.... 0x....      BL       _ZN10CardReader3getEv
   \       0x84   0x4682             MOV      R10,R0
   \       0x86   0x46D0             MOV      R8,R10
   \       0x88   0xFA4F 0xF888      SXTB     R8,R8
   \       0x8C   0x4630             MOV      R0,R6
   \       0x8E   0x.... 0x....      BL       _ZN10CardReader3eofEv
   \       0x92   0x0004             MOVS     R4,R0
   \       0x94   0xD112             BNE.N    ??get_sdcard_commands_7
   \       0x96   0xF11A 0x0F01      CMN      R10,#+1
   \       0x9A   0xD00F             BEQ.N    ??get_sdcard_commands_7
   \       0x9C   0xF1B8 0x0F0A      CMP      R8,#+10
   \       0xA0   0xD00C             BEQ.N    ??get_sdcard_commands_7
   \       0xA2   0xF1B8 0x0F0D      CMP      R8,#+13
   \       0xA6   0xD009             BEQ.N    ??get_sdcard_commands_7
   \       0xA8   0xF1B8 0x0F23      CMP      R8,#+35
   \       0xAC   0xD002             BEQ.N    ??get_sdcard_commands_8
   \       0xAE   0xF1B8 0x0F3A      CMP      R8,#+58
   \       0xB2   0xD110             BNE.N    ??get_sdcard_commands_9
   \                     ??get_sdcard_commands_8: (+1)
   \       0xB4   0x4820             LDR.N    R0,??get_sdcard_commands_0+0x14
   \       0xB6   0x7800             LDRB     R0,[R0, #+0]
   \       0xB8   0x2800             CMP      R0,#+0
   \       0xBA   0xD10C             BNE.N    ??get_sdcard_commands_9
   \                     ??get_sdcard_commands_7: (+1)
   \       0xBC   0x2C00             CMP      R4,#+0
   \       0xBE   0xD0B5             BEQ.N    ??get_sdcard_commands_4
   \       0xC0   0x481F             LDR.N    R0,??get_sdcard_commands_0+0x1C
   \       0xC2   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \       0xC6   0x4630             MOV      R0,R6
   \       0xC8   0x.... 0x....      BL       _ZN10CardReader19printingHasFinishedEv
   \       0xCC   0x2101             MOVS     R1,#+1
   \       0xCE   0x4630             MOV      R0,R6
   \       0xD0   0x.... 0x....      BL       _ZN10CardReader14checkautostartEb
   \       0xD4   0xE7B3             B.N      ??get_sdcard_commands_5
   1340                }
   1341                else if (sd_count >= MAX_CMD_SIZE - 1) {
   \                     ??get_sdcard_commands_9: (+1)
   \       0xD6   0x2D5F             CMP      R5,#+95
   \       0xD8   0xDAC8             BGE.N    ??get_sdcard_commands_3
   1342                  /**
   1343                   * Keep fetching, but ignore normal characters beyond the max length
   1344                   * The command will be injected when EOL is reached
   1345                   */
   1346                }
   1347                else {
   1348                  if (sd_char == ';') sd_comment_mode = true;
   \       0xDA   0x4817             LDR.N    R0,??get_sdcard_commands_0+0x14
   \       0xDC   0xF1B8 0x0F3B      CMP      R8,#+59
   \       0xE0   0xD101             BNE.N    ??get_sdcard_commands_10
   \       0xE2   0x2101             MOVS     R1,#+1
   \       0xE4   0x7001             STRB     R1,[R0, #+0]
   1349                  if (!sd_comment_mode) 
   \                     ??get_sdcard_commands_10: (+1)
   \       0xE6   0x7800             LDRB     R0,[R0, #+0]
   \       0xE8   0x2800             CMP      R0,#+0
   \       0xEA   0xD1BF             BNE.N    ??get_sdcard_commands_3
   1350                  	{
   1351          			command_queue[cmd_queue_index_w][sd_count++] = sd_char;
   \       0xEC   0x4813             LDR.N    R0,??get_sdcard_commands_0+0x18
   \       0xEE   0x7AB9             LDRB     R1,[R7, #+10]
   \       0xF0   0xEB01 0x0241      ADD      R2,R1,R1, LSL #+1
   \       0xF4   0xEB00 0x1042      ADD      R0,R0,R2, LSL #+5
   \       0xF8   0xF800 0x8005      STRB     R8,[R0, R5]
   \       0xFC   0x1C6D             ADDS     R5,R5,#+1
   \       0xFE   0xB2AD             UXTH     R5,R5
   1352          			if(sd_char == 0x5a ) 
   \      0x100   0xF1B8 0x0F5A      CMP      R8,#+90
   \      0x104   0xD1B2             BNE.N    ??get_sdcard_commands_3
   1353          				{
   1354          				mksReprint.sdpos = card.getsdpos()-3;	//"·Ö²ãÎ»ÖÃ"
   \      0x106   0xF8DF 0x803C      LDR.W    R8,??get_sdcard_commands_0+0x20
   \      0x10A   0x4630             MOV      R0,R6
   \      0x10C   0x.... 0x....      BL       _ZN10CardReader8getsdposEv
   \      0x110   0x1EC0             SUBS     R0,R0,#+3
   \      0x112   0xF8C8 0x0000      STR      R0,[R8, #+0]
   1355          				mksReprint.refresh = true;
   \      0x116   0x2001             MOVS     R0,#+1
   \      0x118   0xF888 0x0004      STRB     R0,[R8, #+4]
   \      0x11C   0xE7A6             B.N      ??get_sdcard_commands_3
   1356          				}
   1357                  	}
   1358          		
   1359                }
   1360              }
   1361            }
   \                     ??get_sdcard_commands_1: (+1)
   \      0x11E   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   \      0x122   0xBF00             Nop      
   \                     ??get_sdcard_commands_0:
   \      0x124   0x....'....        DC32     card
   \      0x128   0x....'....        DC32     axis_relative_modes
   \      0x12C   0x....'....        DC32     _ZZ19get_sdcard_commandsvE14stop_buffering
   \      0x130   0x....'....        DC32     errormagic
   \      0x134   0x....'....        DC32     _ZZ19get_sdcard_commandsvEs_0
   \      0x138   0x....'....        DC32     _ZZ19get_sdcard_commandsvE15sd_comment_mode
   \      0x13C   0x....'....        DC32     command_queue
   \      0x140   0x....'....        DC32     _ZZ19get_sdcard_commandsvEs
   \      0x144   0x....'....        DC32     mksReprint+0x6C
   1362          
   1363          #endif // SDSUPPORT
   1364          
   1365          #ifdef USE_MKS_WIFI

   \                                 In section .text, align 4
   1366          inline void get_wifi_commands() {
   \                     _Z17get_wifi_commandsv: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   1367            static char wifi_line_buffer[MAX_CMD_SIZE];
   1368            static bool wifi_comment_mode = false;
   1369          
   1370            if(serial_wait_tick > 5)
   \        0x2   0x4C3C             LDR.N    R4,??get_wifi_commands_0
   \        0x4   0x4D3C             LDR.N    R5,??get_wifi_commands_0+0x4
   \        0x6   0x7BA8             LDRB     R0,[R5, #+14]
   \        0x8   0x2806             CMP      R0,#+6
   \        0xA   0xDB70             BLT.N    ??get_wifi_commands_1
   1371            {
   1372            	from_wifi_flag = 1;
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0x71E0             STRB     R0,[R4, #+7]
   \       0x10   0xE03A             B.N      ??get_wifi_commands_2
   1373          
   1374          /**
   1375          	   * Loop while serial characters are incoming and the queue is not full
   1376          	   */
   1377          	  while ((commands_in_queue < BUFSIZE) && (espGcodeFifo.r != espGcodeFifo.w)) {
   1378          
   1379          	    char wifi_char = espGcodeFifo.Buffer[espGcodeFifo.r];
   1380          
   1381          	    espGcodeFifo.r = (espGcodeFifo.r + 1) % WIFI_GCODE_BUFFER_SIZE;
   1382          
   1383          	    /**
   1384          	     * If the character ends the line
   1385          	     */
   1386          	    if (wifi_char == '\n' || wifi_char == '\r') {
   1387          
   1388          	      wifi_comment_mode = false; // end of line == end of comment
   1389          
   1390          	      if (!wifi_read_count) continue; // skip empty lines
   1391          
   1392          	      wifi_line_buffer[wifi_read_count] = 0; // terminate string
   1393          	      wifi_read_count = 0; //reset buffer
   1394          
   1395          	      char* command = wifi_line_buffer;
   1396          
   1397          	      while (*command == ' ') command++; // skip any leading spaces	    
   \                     ??get_wifi_commands_3: (+1)
   \       0x12   0x1C7F             ADDS     R7,R7,#+1
   \                     ??get_wifi_commands_4: (+1)
   \       0x14   0xF997 0x0000      LDRSB    R0,[R7, #+0]
   \       0x18   0x2820             CMP      R0,#+32
   \       0x1A   0xD0FA             BEQ.N    ??get_wifi_commands_3
   1398          
   1399          	      // Movement commands alert when stopped
   1400          	      if (IsStopped()) {
   \       0x1C   0x.... 0x....      BL       _Z9IsStoppedv
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD013             BEQ.N    ??get_wifi_commands_5
   1401          	        char* gpos = strchr(command, 'G');
   \       0x24   0x2147             MOVS     R1,#+71
   \       0x26   0x4638             MOV      R0,R7
   \       0x28   0x.... 0x....      BL       __iar_Strchr
   1402          	        if (gpos) {
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD00D             BEQ.N    ??get_wifi_commands_5
   1403          	          const int codenum = strtol(gpos + 1, NULL, 10);
   1404          	          switch (codenum) {
   \       0x30   0x220A             MOVS     R2,#+10
   \       0x32   0x2100             MOVS     R1,#+0
   \       0x34   0x1C40             ADDS     R0,R0,#+1
   \       0x36   0x.... 0x....      BL       strtol
   \       0x3A   0x2803             CMP      R0,#+3
   \       0x3C   0xD806             BHI.N    ??get_wifi_commands_5
   1405          	            case 0:
   1406          	            case 1:
   1407          	            case 2:
   1408          	            case 3:
   1409          	              SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
   \       0x3E   0x482F             LDR.N    R0,??get_wifi_commands_0+0x8
   \       0x40   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1410          	              LCD_MESSAGEPGM(MSG_STOPPED);
   \       0x44   0x2100             MOVS     R1,#+0
   \       0x46   0x482E             LDR.N    R0,??get_wifi_commands_0+0xC
   \       0x48   0x.... 0x....      BL       _Z16lcd_setstatuspgmPKch
   1411          	              break;
   1412          	          }
   1413          	        }
   1414          	      }
   1415          
   1416          	      #if DISABLED(EMERGENCY_PARSER)
   1417          	        // If command was e-stop process now
   1418          	        if (strcmp(command, "M108") == 0) {
   \                     ??get_wifi_commands_5: (+1)
   \       0x4C   0x492D             LDR.N    R1,??get_wifi_commands_0+0x10
   \       0x4E   0x4638             MOV      R0,R7
   \       0x50   0x.... 0x....      BL       strcmp
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD102             BNE.N    ??get_wifi_commands_6
   1419          	          wait_for_heatup = false;
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0x70E0             STRB     R0,[R4, #+3]
   1420          	          #if ENABLED(ULTIPANEL)
   1421          	            wait_for_user = false;
   \       0x5C   0x7120             STRB     R0,[R4, #+4]
   1422          	          #endif
   1423          	        }
   1424          	        if (strcmp(command, "M112") == 0) kill(PSTR(MSG_KILLED));
   \                     ??get_wifi_commands_6: (+1)
   \       0x5E   0x492A             LDR.N    R1,??get_wifi_commands_0+0x14
   \       0x60   0x4638             MOV      R0,R7
   \       0x62   0x.... 0x....      BL       strcmp
   \       0x66   0x2800             CMP      R0,#+0
   \       0x68   0xD102             BNE.N    ??get_wifi_commands_7
   \       0x6A   0x4828             LDR.N    R0,??get_wifi_commands_0+0x18
   \       0x6C   0x.... 0x....      BL       _Z4killPKc
   1425          	        if (strcmp(command, "M410") == 0) { quickstop_stepper(); }
   \                     ??get_wifi_commands_7: (+1)
   \       0x70   0x4927             LDR.N    R1,??get_wifi_commands_0+0x1C
   \       0x72   0x4638             MOV      R0,R7
   \       0x74   0x.... 0x....      BL       strcmp
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD101             BNE.N    ??get_wifi_commands_8
   \       0x7C   0x.... 0x....      BL       _Z17quickstop_stepperv
   1426          	      #endif
   1427          
   1428          	      #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
   1429          	        last_command_time = ms;
   1430          	      #endif
   1431          
   1432          	      // Add the command to the queue
   1433          	      _enqueuecommand(wifi_line_buffer, true);
   \                     ??get_wifi_commands_8: (+1)
   \       0x80   0x2101             MOVS     R1,#+1
   \       0x82   0x4630             MOV      R0,R6
   \       0x84   0x.... 0x....      BL       _Z15_enqueuecommandPKcb
   \                     ??get_wifi_commands_2: (+1)
   \       0x88   0x7A28             LDRB     R0,[R5, #+8]
   \       0x8A   0x2803             CMP      R0,#+3
   \       0x8C   0xDC31             BGT.N    ??get_wifi_commands_9
   \       0x8E   0x4821             LDR.N    R0,??get_wifi_commands_0+0x20
   \       0x90   0x6E01             LDR      R1,[R0, #+96]
   \       0x92   0x6E42             LDR      R2,[R0, #+100]
   \       0x94   0x4291             CMP      R1,R2
   \       0x96   0xD02C             BEQ.N    ??get_wifi_commands_9
   \       0x98   0x5642             LDRSB    R2,[R0, R1]
   \       0x9A   0x1C49             ADDS     R1,R1,#+1
   \       0x9C   0x2360             MOVS     R3,#+96
   \       0x9E   0xFBB1 0xF3F3      UDIV     R3,R1,R3
   \       0xA2   0xEB03 0x0643      ADD      R6,R3,R3, LSL #+1
   \       0xA6   0xEBA1 0x1146      SUB      R1,R1,R6, LSL #+5
   \       0xAA   0x6601             STR      R1,[R0, #+96]
   \       0xAC   0x2A0A             CMP      R2,#+10
   \       0xAE   0xD001             BEQ.N    ??get_wifi_commands_10
   \       0xB0   0x2A0D             CMP      R2,#+13
   \       0xB2   0xD10C             BNE.N    ??get_wifi_commands_11
   \                     ??get_wifi_commands_10: (+1)
   \       0xB4   0x2000             MOVS     R0,#+0
   \       0xB6   0x4918             LDR.N    R1,??get_wifi_commands_0+0x24
   \       0xB8   0x7008             STRB     R0,[R1, #+0]
   \       0xBA   0x6B68             LDR      R0,[R5, #+52]
   \       0xBC   0x2800             CMP      R0,#+0
   \       0xBE   0xD0E3             BEQ.N    ??get_wifi_commands_2
   \       0xC0   0x4E16             LDR.N    R6,??get_wifi_commands_0+0x28
   \       0xC2   0x2100             MOVS     R1,#+0
   \       0xC4   0x5431             STRB     R1,[R6, R0]
   \       0xC6   0x4608             MOV      R0,R1
   \       0xC8   0x6368             STR      R0,[R5, #+52]
   \       0xCA   0x4637             MOV      R7,R6
   \       0xCC   0xE7A2             B.N      ??get_wifi_commands_4
   1434          	    }
   1435          	    else if (wifi_read_count >= MAX_CMD_SIZE - 1) {
   \                     ??get_wifi_commands_11: (+1)
   \       0xCE   0x6B69             LDR      R1,[R5, #+52]
   \       0xD0   0x295F             CMP      R1,#+95
   \       0xD2   0xDAD9             BGE.N    ??get_wifi_commands_2
   1436          	      // Keep fetching, but ignore normal characters beyond the max length
   1437          	      // The command will be injected when EOL is reached
   1438          	    }
   1439          		/*
   1440          	    else if (wifi_char == '\\') {  // Handle escapes
   1441          	      if (MYSERIAL.available() > 0) {
   1442          	        // if we have one more character, copy it over
   1443          	        wifi_char = MYSERIAL.read();
   1444          	        if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
   1445          	      }
   1446          	      // otherwise do nothing
   1447          	    }*/
   1448          	    else { // it's not a newline, carriage return or escape char
   1449          	      if (wifi_char == ';') wifi_comment_mode = true;
   \       0xD4   0x4810             LDR.N    R0,??get_wifi_commands_0+0x24
   \       0xD6   0x2A3B             CMP      R2,#+59
   \       0xD8   0xD101             BNE.N    ??get_wifi_commands_12
   \       0xDA   0x2301             MOVS     R3,#+1
   \       0xDC   0x7003             STRB     R3,[R0, #+0]
   1450          	      if (!wifi_comment_mode) wifi_line_buffer[wifi_read_count++] = wifi_char;
   \                     ??get_wifi_commands_12: (+1)
   \       0xDE   0x7800             LDRB     R0,[R0, #+0]
   \       0xE0   0x2800             CMP      R0,#+0
   \       0xE2   0xD1D1             BNE.N    ??get_wifi_commands_2
   \       0xE4   0x480D             LDR.N    R0,??get_wifi_commands_0+0x28
   \       0xE6   0x5442             STRB     R2,[R0, R1]
   \       0xE8   0x1C49             ADDS     R1,R1,#+1
   \       0xEA   0x6369             STR      R1,[R5, #+52]
   \       0xEC   0xE7CC             B.N      ??get_wifi_commands_2
   1451          	    }
   1452          
   1453          	  }
   1454              }// queue has space, serial has data
   1455              else
   1456              {
   1457              	from_wifi_flag = 0;
   \                     ??get_wifi_commands_1: (+1)
   \       0xEE   0x2000             MOVS     R0,#+0
   \       0xF0   0x71E0             STRB     R0,[R4, #+7]
   1458              }
   1459          }
   \                     ??get_wifi_commands_9: (+1)
   \       0xF2   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   \                     ??get_wifi_commands_0:
   \       0xF4   0x....'....        DC32     mks_heating_busy
   \       0xF8   0x....'....        DC32     axis_relative_modes
   \       0xFC   0x....'....        DC32     _ZZ17get_wifi_commandsvEs
   \      0x100   0x....'....        DC32     _ZZ17get_wifi_commandsvEs_0
   \      0x104   0x....'....        DC32     _ZZ17get_wifi_commandsvEs_1
   \      0x108   0x....'....        DC32     _ZZ17get_wifi_commandsvEs_2
   \      0x10C   0x....'....        DC32     _ZZ17get_wifi_commandsvEs_3
   \      0x110   0x....'....        DC32     _ZZ17get_wifi_commandsvEs_4
   \      0x114   0x....'....        DC32     espGcodeFifo
   \      0x118   0x....'....        DC32     _ZZ17get_wifi_commandsvE17wifi_comment_mode
   \      0x11C   0x....'....        DC32     _ZZ17get_wifi_commandsvE16wifi_line_buffer
   1460          #endif
   1461          
   1462          /**
   1463           * Add to the circular command queue the next command from:
   1464           *  - The command-injection queue (injected_commands_P)
   1465           *  - The active serial input (usually USB)
   1466           *  - The SD card file being actively printed
   1467           */

   \                                 In section .text, align 2, keep-with-next
   1468          void get_available_commands() {
   \                     _Z22get_available_commandsv: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1469          
   1470            // if any immediate commands remain, don't get other commands yet
   1471            if (drain_injected_commands_P()) return;
   \        0x2   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531925drain_injected_commands_PEv
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD107             BNE.N    ??get_available_commands_0
   1472          //#if MASK_FOR_SPACE
   1473            get_serial_commands();
   \        0xA   0x.... 0x....      BL       _Z19get_serial_commandsv
   1474          //#endif
   1475          
   1476          #ifdef USE_MKS_WIFI
   1477            get_wifi_commands();
   \        0xE   0x.... 0x....      BL       _Z17get_wifi_commandsv
   1478          #endif
   1479          
   1480            #if ENABLED(SDSUPPORT)
   1481           // #if MASK_FOR_SPACE
   1482              get_sdcard_commands();
   \       0x12   0xE8BD 0x4001      POP      {R0,LR}
   \       0x16   0x.... 0x....      B.W      _Z19get_sdcard_commandsv
   \                     ??get_available_commands_0: (+1)
   \       0x1A   0xBD01             POP      {R0,PC}          ;; return
   1483           //#endif
   1484            #endif
   1485          }
   1486          

   \                                 In section .text, align 4
   1487          inline bool code_has_value() {
   1488            int i = 1;
   \                     _Z14code_has_valuev: (+1)
   \        0x0   0x2001             MOVS     R0,#+1
   1489            char c = seen_pointer[i];
   \        0x2   0x490C             LDR.N    R1,??code_has_value_0
   \        0x4   0x6AC9             LDR      R1,[R1, #+44]
   \        0x6   0xF991 0x2001      LDRSB    R2,[R1, #+1]
   \        0xA   0xE001             B.N      ??code_has_value_1
   1490            while (c == ' ') c = seen_pointer[++i];
   \                     ??code_has_value_2: (+1)
   \        0xC   0x1C40             ADDS     R0,R0,#+1
   \        0xE   0x560A             LDRSB    R2,[R1, R0]
   \                     ??code_has_value_1: (+1)
   \       0x10   0x2A20             CMP      R2,#+32
   \       0x12   0xD0FB             BEQ.N    ??code_has_value_2
   1491            if (c == '-' || c == '+') c = seen_pointer[++i];
   \       0x14   0x2A2D             CMP      R2,#+45
   \       0x16   0xD001             BEQ.N    ??code_has_value_3
   \       0x18   0x2A2B             CMP      R2,#+43
   \       0x1A   0xD101             BNE.N    ??code_has_value_4
   \                     ??code_has_value_3: (+1)
   \       0x1C   0x1C40             ADDS     R0,R0,#+1
   \       0x1E   0x560A             LDRSB    R2,[R1, R0]
   1492            if (c == '.') c = seen_pointer[++i];
   \                     ??code_has_value_4: (+1)
   \       0x20   0x2A2E             CMP      R2,#+46
   \       0x22   0xD101             BNE.N    ??code_has_value_5
   \       0x24   0x1C49             ADDS     R1,R1,#+1
   \       0x26   0x560A             LDRSB    R2,[R1, R0]
   1493            return NUMERIC(c);
   \                     ??code_has_value_5: (+1)
   \       0x28   0x3A30             SUBS     R2,R2,#+48
   \       0x2A   0x2A0A             CMP      R2,#+10
   \       0x2C   0x4180             SBCS     R0,R0,R0
   \       0x2E   0x0FC0             LSRS     R0,R0,#+31
   \       0x30   0x4770             BX       LR               ;; return
   \       0x32   0xBF00             Nop      
   \                     ??code_has_value_0:
   \       0x34   0x....'....        DC32     axis_relative_modes
   1494          }
   1495          

   \                                 In section .text, align 4
   1496          inline float code_value_float() {
   \                     _Z16code_value_floatv: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   1497            char* e = strchr(seen_pointer, 'E');
   \        0x2   0x480D             LDR.N    R0,??code_value_float_0
   \        0x4   0x6AC5             LDR      R5,[R0, #+44]
   \        0x6   0x2145             MOVS     R1,#+69
   \        0x8   0x4628             MOV      R0,R5
   \        0xA   0x.... 0x....      BL       __iar_Strchr
   \        0xE   0x0004             MOVS     R4,R0
   1498            if (!e) return strtod(seen_pointer + 1, NULL);
   \       0x10   0xD107             BNE.N    ??code_value_float_1
   \       0x12   0x2100             MOVS     R1,#+0
   \       0x14   0x1C68             ADDS     R0,R5,#+1
   \       0x16   0x.... 0x....      BL       strtod
   \       0x1A   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \       0x1E   0x.... 0x....      B.W      __aeabi_d2f
   1499            *e = 0;
   \                     ??code_value_float_1: (+1)
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x7020             STRB     R0,[R4, #+0]
   1500            float ret = strtod(seen_pointer + 1, NULL);
   \       0x26   0x4601             MOV      R1,R0
   \       0x28   0x1C68             ADDS     R0,R5,#+1
   \       0x2A   0x.... 0x....      BL       strtod
   \       0x2E   0x.... 0x....      BL       __aeabi_d2f
   1501            *e = 'E';
   \       0x32   0x2145             MOVS     R1,#+69
   \       0x34   0x7021             STRB     R1,[R4, #+0]
   1502            return ret;
   \       0x36   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   \                     ??code_value_float_0:
   \       0x38   0x....'....        DC32     axis_relative_modes
   1503          }
   1504          

   \                                 In section .text, align 4
   1505          inline unsigned long code_value_ulong() { return strtoul(seen_pointer + 1, NULL, 10); }
   \                     _Z16code_value_ulongv: (+1)
   \        0x0   0x220A             MOVS     R2,#+10
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x4802             LDR.N    R0,??code_value_ulong_0
   \        0x6   0x6AC0             LDR      R0,[R0, #+44]
   \        0x8   0x1C40             ADDS     R0,R0,#+1
   \        0xA   0x.... 0x....      B.W      strtoul
   \        0xE   0xBF00             Nop      
   \                     ??code_value_ulong_0:
   \       0x10   0x....'....        DC32     axis_relative_modes
   1506          

   \                                 In section .text, align 4
   1507          inline long code_value_long() { return strtol(seen_pointer + 1, NULL, 10); }
   \                     _Z15code_value_longv: (+1)
   \        0x0   0x220A             MOVS     R2,#+10
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x4802             LDR.N    R0,??code_value_long_0
   \        0x6   0x6AC0             LDR      R0,[R0, #+44]
   \        0x8   0x1C40             ADDS     R0,R0,#+1
   \        0xA   0x.... 0x....      B.W      strtol
   \        0xE   0xBF00             Nop      
   \                     ??code_value_long_0:
   \       0x10   0x....'....        DC32     axis_relative_modes
   1508          

   \                                 In section .text, align 4
   1509          inline int code_value_int() { return (int)strtol(seen_pointer + 1, NULL, 10); }
   \                     _Z14code_value_intv: (+1)
   \        0x0   0x220A             MOVS     R2,#+10
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x4802             LDR.N    R0,??code_value_int_0
   \        0x6   0x6AC0             LDR      R0,[R0, #+44]
   \        0x8   0x1C40             ADDS     R0,R0,#+1
   \        0xA   0x.... 0x....      B.W      strtol
   \        0xE   0xBF00             Nop      
   \                     ??code_value_int_0:
   \       0x10   0x....'....        DC32     axis_relative_modes
   1510          

   \                                 In section .text, align 4
   1511          inline uint16_t code_value_ushort() { return (uint16_t)strtoul(seen_pointer + 1, NULL, 10); }
   \                     _Z17code_value_ushortv: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x220A             MOVS     R2,#+10
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x4803             LDR.N    R0,??code_value_ushort_0
   \        0x8   0x6AC0             LDR      R0,[R0, #+44]
   \        0xA   0x1C40             ADDS     R0,R0,#+1
   \        0xC   0x.... 0x....      BL       strtoul
   \       0x10   0xB280             UXTH     R0,R0
   \       0x12   0xBD02             POP      {R1,PC}          ;; return
   \                     ??code_value_ushort_0:
   \       0x14   0x....'....        DC32     axis_relative_modes
   1512          

   \                                 In section .text, align 4
   1513          inline uint8_t code_value_byte() { return (uint8_t)(constrain(strtol(seen_pointer + 1, NULL, 10), 0, 255)); }
   \                     _Z15code_value_bytev: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4C0F             LDR.N    R4,??code_value_byte_0
   \        0x4   0x220A             MOVS     R2,#+10
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x6AE0             LDR      R0,[R4, #+44]
   \        0xA   0x1C40             ADDS     R0,R0,#+1
   \        0xC   0x.... 0x....      BL       strtol
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD501             BPL.N    ??code_value_byte_1
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xE010             B.N      ??code_value_byte_2
   \                     ??code_value_byte_1: (+1)
   \       0x18   0x220A             MOVS     R2,#+10
   \       0x1A   0x2100             MOVS     R1,#+0
   \       0x1C   0x6AE0             LDR      R0,[R4, #+44]
   \       0x1E   0x1C40             ADDS     R0,R0,#+1
   \       0x20   0x.... 0x....      BL       strtol
   \       0x24   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x28   0xDB01             BLT.N    ??code_value_byte_3
   \       0x2A   0x20FF             MOVS     R0,#+255
   \       0x2C   0xE005             B.N      ??code_value_byte_2
   \                     ??code_value_byte_3: (+1)
   \       0x2E   0x220A             MOVS     R2,#+10
   \       0x30   0x2100             MOVS     R1,#+0
   \       0x32   0x6AE0             LDR      R0,[R4, #+44]
   \       0x34   0x1C40             ADDS     R0,R0,#+1
   \       0x36   0x.... 0x....      BL       strtol
   \                     ??code_value_byte_2: (+1)
   \       0x3A   0xB2C0             UXTB     R0,R0
   \       0x3C   0xBD10             POP      {R4,PC}          ;; return
   \       0x3E   0xBF00             Nop      
   \                     ??code_value_byte_0:
   \       0x40   0x....'....        DC32     axis_relative_modes
   1514          

   \                                 In section .text, align 2
   1515          inline bool code_value_bool() { return !code_has_value() || code_value_byte() > 0; }
   \                     _Z15code_value_boolv: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x.... 0x....      BL       _Z14code_has_valuev
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD006             BEQ.N    ??code_value_bool_0
   \        0xA   0x.... 0x....      BL       _Z15code_value_bytev
   \        0xE   0x1E40             SUBS     R0,R0,#+1
   \       0x10   0x4180             SBCS     R0,R0,R0
   \       0x12   0x43C0             MVNS     R0,R0
   \       0x14   0x0FC0             LSRS     R0,R0,#+31
   \       0x16   0xBD02             POP      {R1,PC}
   \                     ??code_value_bool_0: (+1)
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0xBD02             POP      {R1,PC}          ;; return
   1516          
   1517          #if ENABLED(INCH_MODE_SUPPORT)
   1518            inline void set_input_linear_units(LinearUnit units) {
   1519              switch (units) {
   1520                case LINEARUNIT_INCH:
   1521                  linear_unit_factor = 25.4;
   1522                  break;
   1523                case LINEARUNIT_MM:
   1524                default:
   1525                  linear_unit_factor = 1.0;
   1526                  break;
   1527              }
   1528              volumetric_unit_factor = pow(linear_unit_factor, 3.0);
   1529            }
   1530          
   1531            inline float axis_unit_factor(const AxisEnum axis) {
   1532              return (axis >= E_AXIS && volumetric_enabled ? volumetric_unit_factor : linear_unit_factor);
   1533            }
   1534          
   1535            inline float code_value_linear_units() { return code_value_float() * linear_unit_factor; }
   1536            inline float code_value_axis_units(const AxisEnum axis) { return code_value_float() * axis_unit_factor(axis); }
   1537            inline float code_value_per_axis_unit(const AxisEnum axis) { return code_value_float() / axis_unit_factor(axis); }
   1538          #endif
   1539          
   1540          #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
   1541            inline void set_input_temp_units(TempUnit units) { input_temp_units = units; }
   1542            float to_temp_units(const float &c) {
   1543              switch (input_temp_units) {
   1544                case TEMPUNIT_F:
   1545                  return c * 0.5555555556 + 32.0;
   1546                case TEMPUNIT_K:
   1547                  return c + 273.15;
   1548                case TEMPUNIT_C:
   1549                default:
   1550                  return c;
   1551              }
   1552            }
   1553          
   1554            int16_t code_value_temp_abs() {
   1555          	const float c = code_value_float();
   1556              switch (input_temp_units) {
   1557                case TEMPUNIT_F:
   1558          		  return (int16_t)((c - 32.0) * 0.5555555556);
   1559                case TEMPUNIT_K:
   1560          		  return (int16_t)(c - 273.15);
   1561                case TEMPUNIT_C:
   1562                default:
   1563          		  return (int16_t)(c);
   1564              }
   1565            }
   1566          
   1567            int16_t code_value_temp_diff() {
   1568              switch (input_temp_units) {
   1569                case TEMPUNIT_F:
   1570                  return code_value_float() * 0.5555555556;
   1571          		case TEMPUNIT_C:
   1572          		case TEMPUNIT_K:
   1573                default:
   1574                  return code_value_float();
   1575              }
   1576            }
   1577          #else

   \                                 In section .text, align 2, keep-with-next
   1578            int16_t code_value_temp_abs() { return code_value_int(); }
   \                     _Z19code_value_temp_absv: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x.... 0x....      BL       _Z14code_value_intv
   \        0x6   0xB200             SXTH     R0,R0
   \        0x8   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   1579            int16_t code_value_temp_diff() { return code_value_int(); }
   \                     _Z20code_value_temp_diffv: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x.... 0x....      BL       _Z14code_value_intv
   \        0x6   0xB200             SXTH     R0,R0
   \        0x8   0xBD02             POP      {R1,PC}          ;; return
   1580          #endif
   1581          

   \                                 In section .text, align 2
   1582          FORCE_INLINE millis_t code_value_millis() { return code_value_ulong(); }
   \                     _Z17code_value_millisv: (+1)
   \        0x0   0x.... 0x....      B.W      _Z16code_value_ulongv

   \                                 In section .text, align 4
   1583          inline millis_t code_value_millis_from_seconds() { return code_value_float() * 1000; }
                                                                           ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     _Z30code_value_millis_from_secondsv: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x.... 0x....      BL       _Z16code_value_floatv
   \        0x6   0x4903             LDR.N    R1,??code_value_millis_from_seconds_0  ;; 0x447a0000
   \        0x8   0x.... 0x....      BL       __aeabi_fmul
   \        0xC   0xE8BD 0x4002      POP      {R1,LR}
   \       0x10   0x.... 0x....      B.W      __aeabi_f2uiz
   \                     ??code_value_millis_from_seconds_0:
   \       0x14   0x447A'0000        DC32     0x447a0000
   1584          

   \                                 In section .text, align 2, keep-with-next
   1585          bool code_seen(char code) {
   \                     _Z9code_seenc: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4601             MOV      R1,R0
   1586            seen_pointer = strchr(current_command_args, code);
   \        0x4   0x.... 0x....      LDR.W    R4,??DataTable116_2
   \        0x8   0x6AA0             LDR      R0,[R4, #+40]
   \        0xA   0x.... 0x....      BL       __iar_Strchr
   \        0xE   0x62E0             STR      R0,[R4, #+44]
   1587            return (seen_pointer != NULL); // Return TRUE if the code-letter was found
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD001             BEQ.N    ??code_seen_0
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0xBD10             POP      {R4,PC}
   \                     ??code_seen_0: (+1)
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xBD10             POP      {R4,PC}          ;; return
   1588          }
   1589          
   1590          /**
   1591           * Set target_extruder from the T parameter or the active_extruder
   1592           *
   1593           * Returns TRUE if the target is invalid
   1594           */

   \                                 In section .text, align 2, keep-with-next
   1595          bool get_target_extruder_from_command(int code) {
   \                     _Z32get_target_extruder_from_commandi: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   1596            if (code_seen('T')) {
   \        0x4   0x.... 0x....      LDR.W    R5,??DataTable112_3
   \        0x8   0x2054             MOVS     R0,#+84
   \        0xA   0x.... 0x....      BL       _Z9code_seenc
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD042             BEQ.N    ??get_target_extruder_from_command_0
   1597              if (code_value_byte() >= EXTRUDERS) {
   \       0x12   0x.... 0x....      BL       _Z15code_value_bytev
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD03A             BEQ.N    ??get_target_extruder_from_command_1
   1598                SERIAL_ECHO_START;
   \       0x1A   0x.... 0x....      LDR.W    R0,??DataTable116_3
   \       0x1E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1599                SERIAL_CHAR('M');
   \       0x22   0x79E8             LDRB     R0,[R5, #+7]
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD105             BNE.N    ??get_target_extruder_from_command_2
   \       0x28   0x214D             MOVS     R1,#+77
   \       0x2A   0x.... 0x....      LDR.W    R0,??DataTable116_4
   \       0x2E   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \       0x32   0xE005             B.N      ??get_target_extruder_from_command_3
   \                     ??get_target_extruder_from_command_2: (+1)
   \       0x34   0x2200             MOVS     R2,#+0
   \       0x36   0x214D             MOVS     R1,#+77
   \       0x38   0x.... 0x....      LDR.W    R0,??DataTable116_5
   \       0x3C   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   1600                SERIAL_ECHO(code);
   \                     ??get_target_extruder_from_command_3: (+1)
   \       0x40   0x79E8             LDRB     R0,[R5, #+7]
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD106             BNE.N    ??get_target_extruder_from_command_4
   \       0x46   0x220A             MOVS     R2,#+10
   \       0x48   0x4621             MOV      R1,R4
   \       0x4A   0x.... 0x....      LDR.W    R0,??DataTable116_4
   \       0x4E   0x.... 0x....      BL       _ZN12MarlinSerial5printEii
   \       0x52   0xE005             B.N      ??get_target_extruder_from_command_5
   \                     ??get_target_extruder_from_command_4: (+1)
   \       0x54   0x220A             MOVS     R2,#+10
   \       0x56   0x4621             MOV      R1,R4
   \       0x58   0x.... 0x....      LDR.W    R0,??DataTable116_5
   \       0x5C   0x.... 0x....      BL       _ZN12MarlinSerial5printEii
   1601                SERIAL_ECHOLNPAIR(" " MSG_INVALID_EXTRUDER " ", code_value_byte());
   \                     ??get_target_extruder_from_command_5: (+1)
   \       0x60   0x.... 0x....      BL       _Z15code_value_bytev
   \       0x64   0x4601             MOV      R1,R0
   \       0x66   0x.... 0x....      ADR.W    R0,?_1
   \       0x6A   0x.... 0x....      BL       _Z17serial_echopair_PPKch
   \       0x6E   0x79E8             LDRB     R0,[R5, #+7]
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xD105             BNE.N    ??get_target_extruder_from_command_6
   \       0x74   0x210A             MOVS     R1,#+10
   \       0x76   0x.... 0x....      LDR.W    R0,??DataTable116_4
   \       0x7A   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \       0x7E   0xE005             B.N      ??get_target_extruder_from_command_7
   \                     ??get_target_extruder_from_command_6: (+1)
   \       0x80   0x2200             MOVS     R2,#+0
   \       0x82   0x210A             MOVS     R1,#+10
   \       0x84   0x.... 0x....      LDR.W    R0,??DataTable116_5
   \       0x88   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   1602                return true;
   \                     ??get_target_extruder_from_command_7: (+1)
   \       0x8C   0x2001             MOVS     R0,#+1
   \       0x8E   0xBD32             POP      {R1,R4,R5,PC}
   1603              }
   1604              target_extruder = code_value_byte();
   \                     ??get_target_extruder_from_command_1: (+1)
   \       0x90   0x.... 0x....      BL       _Z15code_value_bytev
   \       0x94   0x7168             STRB     R0,[R5, #+5]
   \       0x96   0xE001             B.N      ??get_target_extruder_from_command_8
   1605            }
   1606            else
   1607              target_extruder = active_extruder;
   \                     ??get_target_extruder_from_command_0: (+1)
   \       0x98   0x78A8             LDRB     R0,[R5, #+2]
   \       0x9A   0x7168             STRB     R0,[R5, #+5]
   1608          
   1609            return false;
   \                     ??get_target_extruder_from_command_8: (+1)
   \       0x9C   0x2000             MOVS     R0,#+0
   \       0x9E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1610          }
   1611          
   1612          #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
   1613            bool extruder_duplication_enabled = false; // Used in Dual X mode 2
   1614          #endif
   1615          
   1616          #if ENABLED(DUAL_X_CARRIAGE)
   1617          
   1618            static DualXMode dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
   1619          
   1620            static float x_home_pos(const int extruder) {
   1621              if (extruder == 0)
   1622                return LOGICAL_X_POSITION(base_home_pos(X_AXIS));
   1623              else
   1624                /**
   1625                 * In dual carriage mode the extruder offset provides an override of the
   1626                 * second X-carriage position when homed - otherwise X2_HOME_POS is used.
   1627                 * This allows soft recalibration of the second extruder home position
   1628                 * without firmware reflash (through the M218 command).
   1629                 */
   1630                return LOGICAL_X_POSITION(hotend_offset[X_AXIS][1] > 0 ? hotend_offset[X_AXIS][1] : X2_HOME_POS);
   1631            }
   1632          
   1633            static int x_home_dir(const int extruder) { return extruder ? X2_HOME_DIR : X_HOME_DIR; }
   1634          
   1635            static float inactive_extruder_x_pos = X2_MAX_POS; // used in mode 0 & 1
   1636            static bool active_extruder_parked = false;        // used in mode 1 & 2
   1637            static float raised_parked_position[XYZE];         // used in mode 1
   1638            static millis_t delayed_move_time = 0;             // used in mode 1
   1639            static float duplicate_extruder_x_offset = DEFAULT_DUPLICATION_X_OFFSET; // used in mode 2
   1640            static int16_t duplicate_extruder_temp_offset = 0; // used in mode 2
   1641          
   1642          #endif // DUAL_X_CARRIAGE
   1643          
   1644          #if HAS_WORKSPACE_OFFSET || ENABLED(DUAL_X_CARRIAGE)
   1645          
   1646            /**
   1647             * Software endstops can be used to monitor the open end of
   1648             * an axis that has a hardware endstop on the other end. Or
   1649             * they can prevent axes from moving past endstops and grinding.
   1650             *
   1651             * To keep doing their job as the coordinate system changes,
   1652             * the software endstop positions must be refreshed to remain
   1653             * at the same positions relative to the machine.
   1654             */

   \                                 In section .text, align 2, keep-with-next
   1655            void update_software_endstops(const AxisEnum axis) {
   \                     _Z24update_software_endstops8AxisEnum: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   1656              const float offs = 0.0
   1657                #if HAS_HOME_OFFSET
   1658                  + home_offset[axis]
   1659                #endif
   1660                #if HAS_POSITION_SHIFT
   1661                  + position_shift[axis]
   1662                #endif
   1663              ;
   \        0x4   0x.... 0x....      LDR.W    R5,??DataTable112_3
   \        0x8   0xEB05 0x0680      ADD      R6,R5,R0, LSL #+2
   \        0xC   0x6BB1             LDR      R1,[R6, #+56]
   \        0xE   0x.... 0x....      LDR.W    R2,??DataTable116_7
   \       0x12   0xEB02 0x0080      ADD      R0,R2,R0, LSL #+2
   \       0x16   0x6BC0             LDR      R0,[R0, #+60]
   \       0x18   0x.... 0x....      BL       __aeabi_fadd
   \       0x1C   0x4607             MOV      R7,R0
   1664          
   1665              #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
   1666                workspace_offset[axis] = offs;
   \       0x1E   0x6477             STR      R7,[R6, #+68]
   1667              #endif
   1668          
   1669              #if ENABLED(DUAL_X_CARRIAGE)
   1670                if (axis == X_AXIS) {
   1671          
   1672                  // In Dual X mode hotend_offset[X] is T1's home position
   1673                  float dual_max_x = max(hotend_offset[X_AXIS][1], X2_MAX_POS);
   1674          
   1675                  if (active_extruder != 0) {
   1676                    // T1 can move from X2_MIN_POS to X2_MAX_POS or X2 home position (whichever is larger)
   1677                    soft_endstop_min[X_AXIS] = X2_MIN_POS + offs;
   1678                    soft_endstop_max[X_AXIS] = dual_max_x + offs;
   1679                  }
   1680                  else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE) {
   1681                    // In Duplication Mode, T0 can move as far left as X_MIN_POS
   1682                    // but not so far to the right that T1 would move past the end
   1683                    soft_endstop_min[X_AXIS] = base_min_pos(X_AXIS) + offs;
   1684                    soft_endstop_max[X_AXIS] = min(base_max_pos(X_AXIS), dual_max_x - duplicate_extruder_x_offset) + offs;
   1685                  }
   1686                  else {
   1687                    // In other modes, T0 can move from X_MIN_POS to X_MAX_POS
   1688                    soft_endstop_min[axis] = base_min_pos(axis) + offs;
   1689                    soft_endstop_max[axis] = base_max_pos(axis) + offs;
   1690                  }
   1691                }
   1692              #else
   1693                soft_endstop_min[axis] = base_min_pos(axis) + offs;
   \       0x20   0x4620             MOV      R0,R4
   \       0x22   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531912base_min_posE8AxisEnum
   \       0x26   0x4639             MOV      R1,R7
   \       0x28   0x.... 0x....      BL       __aeabi_fadd
   \       0x2C   0x6530             STR      R0,[R6, #+80]
   1694                soft_endstop_max[axis] = base_max_pos(axis) + offs;
   \       0x2E   0x4620             MOV      R0,R4
   \       0x30   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531912base_max_posE8AxisEnum
   \       0x34   0x4639             MOV      R1,R7
   \       0x36   0x.... 0x....      BL       __aeabi_fadd
   \       0x3A   0x65F0             STR      R0,[R6, #+92]
   1695              #endif
   1696          
   1697              #if ENABLED(DEBUG_LEVELING_FEATURE)
   1698                if (DEBUGGING(LEVELING)) {
   1699                  SERIAL_ECHOPAIR("For ", axis_codes[axis]);
   1700                  #if HAS_HOME_OFFSET
   1701                    SERIAL_ECHOPAIR(" axis:\n home_offset = ", home_offset[axis]);
   1702                  #endif
   1703                  #if HAS_POSITION_SHIFT
   1704                    SERIAL_ECHOPAIR("\n position_shift = ", position_shift[axis]);
   1705                  #endif
   1706                  SERIAL_ECHOPAIR("\n soft_endstop_min = ", soft_endstop_min[axis]);
   1707                  SERIAL_ECHOLNPAIR("\n soft_endstop_max = ", soft_endstop_max[axis]);
   1708                }
   1709              #endif
   1710          
   1711          //    #if ENABLED(DELTA)
   1712          	if(MACHINETPYE == DELTA)
   \       0x3C   0x.... 0x....      LDR.W    R0,??DataTable113_4
   \       0x40   0xF9B0 0x0058      LDRSH    R0,[R0, #+88]
   \       0x44   0x2802             CMP      R0,#+2
   \       0x46   0xD109             BNE.N    ??update_software_endstops_0
   1713                if (axis == Z_AXIS)
   \       0x48   0x2C02             CMP      R4,#+2
   \       0x4A   0xD107             BNE.N    ??update_software_endstops_0
   1714                  delta_clip_start_height = soft_endstop_max[axis] - delta_safe_distance_from_top();
   \       0x4C   0x.... 0x....      BL       _Z28delta_safe_distance_from_topv
   \       0x50   0x4601             MOV      R1,R0
   \       0x52   0x6E68             LDR      R0,[R5, #+100]
   \       0x54   0x.... 0x....      BL       __aeabi_fsub
   \       0x58   0xF8C5 0x0080      STR      R0,[R5, #+128]
   1715            //  #endif
   1716            }
   \                     ??update_software_endstops_0: (+1)
   \       0x5C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1717          
   1718          #endif // HAS_WORKSPACE_OFFSET || DUAL_X_CARRIAGE
   1719          
   1720          //#if HAS_M206_COMMAND	//mks_delta
   1721          #if 1
   1722            /**
   1723             * Change the home offset for an axis, update the current
   1724             * position and the software endstops to retain the same
   1725             * relative distance to the new home.
   1726             *
   1727             * Since this changes the current_position, code should
   1728             * call sync_plan_position soon after this.
   1729             */

   \                                 In section .text, align 2, keep-with-next
   1730            static void set_home_offset(const AxisEnum axis, const float v) {
   \                     _ZN37_INTERNAL_15_Marlin_main_cpp_3178531915set_home_offsetE8AxisEnumf: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   1731            if(MACHINETPYE == DELTA)	return;
   \        0x6   0x.... 0x....      LDR.W    R0,??DataTable113_4
   \        0xA   0xF9B0 0x0058      LDRSH    R0,[R0, #+88]
   \        0xE   0x2802             CMP      R0,#+2
   \       0x10   0xD011             BEQ.N    ??set_home_offset_0
   1732            	
   1733              current_position[axis] += v - home_offset[axis];
   \       0x12   0x.... 0x....      LDR.W    R0,??DataTable112_3
   \       0x16   0x4621             MOV      R1,R4
   \       0x18   0xEB00 0x0681      ADD      R6,R0,R1, LSL #+2
   \       0x1C   0x4628             MOV      R0,R5
   \       0x1E   0x6BB1             LDR      R1,[R6, #+56]
   \       0x20   0x.... 0x....      BL       __aeabi_fsub
   \       0x24   0x68B1             LDR      R1,[R6, #+8]
   \       0x26   0x.... 0x....      BL       __aeabi_fadd
   \       0x2A   0x60B0             STR      R0,[R6, #+8]
   1734              home_offset[axis] = v;
   \       0x2C   0x63B5             STR      R5,[R6, #+56]
   1735              update_software_endstops(axis);
   \       0x2E   0x4620             MOV      R0,R4
   \       0x30   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x34   0x....             B.N      _Z24update_software_endstops8AxisEnum
   \                     ??set_home_offset_0: (+1)
   \       0x36   0xBD70             POP      {R4-R6,PC}       ;; return
   1736            }
   1737          #endif // HAS_M206_COMMAND
   1738          
   1739          /**
   1740           * Set an axis' current position to its home position (after homing).
   1741           *
   1742           * For Core and Cartesian robots this applies one-to-one when an
   1743           * individual axis has been homed.
   1744           *
   1745           * DELTA should wait until all homing is done before setting the XYZ
   1746           * current_position to home, because homing is a single operation.
   1747           * In the case where the axis positions are already known and previously
   1748           * homed, DELTA could home to X or Y individually by moving either one
   1749           * to the center. However, homing Z always homes XY and Z.
   1750           *
   1751           * SCARA should wait until all XY homing is done before setting the XY
   1752           * current_position to home, because neither X nor Y is at home until
   1753           * both are at home. Z can however be homed individually.
   1754           *
   1755           * Callers must sync the planner position after calling this!
   1756           */

   \                                 In section .text, align 2, keep-with-next
   1757          static void set_axis_is_at_home(AxisEnum axis) {
   \                     _ZN37_INTERNAL_15_Marlin_main_cpp_3178531919set_axis_is_at_homeE8AxisEnum: (+1)
   \        0x0   0xE92D 0x47FF      PUSH     {R0-R10,LR}
   \        0x4   0x4604             MOV      R4,R0
   1758            #if ENABLED(DEBUG_LEVELING_FEATURE)
   1759              if (DEBUGGING(LEVELING)) {
   1760                SERIAL_ECHOPAIR(">>> set_axis_is_at_home(", axis_codes[axis]);
   1761                SERIAL_CHAR(')');
   1762                SERIAL_EOL;
   1763              }
   1764            #endif
   1765          
   1766            axis_known_position[axis] = axis_homed[axis] = true;
   \        0x6   0x46A0             MOV      R8,R4
   \        0x8   0x.... 0x....      LDR.W    R5,??DataTable116_7
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0xF805 0x0008      STRB     R0,[R5, R8]
   \       0x12   0x.... 0x....      LDR.W    R1,??DataTable116_2
   \       0x16   0x4441             ADD      R1,R1,R8
   \       0x18   0x7108             STRB     R0,[R1, #+4]
   1767          
   1768            #if HAS_POSITION_SHIFT
   1769              position_shift[axis] = 0;
   \       0x1A   0xEB05 0x0988      ADD      R9,R5,R8, LSL #+2
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0xF8C9 0x003C      STR      R0,[R9, #+60]
   1770              update_software_endstops(axis);
   \       0x24   0x4620             MOV      R0,R4
   \       0x26   0x.... 0x....      BL       _Z24update_software_endstops8AxisEnum
   1771            #endif
   1772          
   1773            #if ENABLED(DUAL_X_CARRIAGE)
   1774              if (axis == X_AXIS && (active_extruder == 1 || dual_x_carriage_mode == DXC_DUPLICATION_MODE)) {
   1775                current_position[X_AXIS] = x_home_pos(active_extruder);
   1776                return;
   1777              }
   1778            #endif
   1779          
   1780            //#if ENABLED(MORGAN_SCARA)
   1781            if(MACHINETPYE&MORGAN_SCARA)
   \       0x2A   0x.... 0x....      LDR.W    R6,??DataTable112_3
   \       0x2E   0x.... 0x....      LDR.W    R7,??DataTable113_4
   \       0x32   0xF8B7 0x0058      LDRH     R0,[R7, #+88]
   \       0x36   0x05C0             LSLS     R0,R0,#+23
   \       0x38   0xD541             BPL.N    ??set_axis_is_at_home_0
   1782            	{
   1783              /**
   1784               * Morgan SCARA homes XY at the same time
   1785               */
   1786              if (axis == X_AXIS || axis == Y_AXIS) {
   \       0x3A   0x0020             MOVS     R0,R4
   \       0x3C   0xD001             BEQ.N    ??set_axis_is_at_home_1
   \       0x3E   0x2801             CMP      R0,#+1
   \       0x40   0xD132             BNE.N    ??set_axis_is_at_home_2
   1787          
   1788                float homeposition[XYZ];
   1789                LOOP_XYZ(i) homeposition[i] = LOGICAL_POSITION(base_home_pos((AxisEnum)i), i);
   \                     ??set_axis_is_at_home_1: (+1)
   \       0x42   0xF04F 0x0A00      MOV      R10,#+0
   \       0x46   0xE00E             B.N      ??set_axis_is_at_home_3
   \                     ??set_axis_is_at_home_4: (+1)
   \       0x48   0x4650             MOV      R0,R10
   \       0x4A   0xB240             SXTB     R0,R0
   \       0x4C   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531913base_home_posE8AxisEnum
   \       0x50   0xF106 0x0144      ADD      R1,R6,#+68
   \       0x54   0xF851 0x102A      LDR      R1,[R1, R10, LSL #+2]
   \       0x58   0x.... 0x....      BL       __aeabi_fadd
   \       0x5C   0x4669             MOV      R1,SP
   \       0x5E   0xF841 0x002A      STR      R0,[R1, R10, LSL #+2]
   \       0x62   0xF10A 0x0A01      ADD      R10,R10,#+1
   \                     ??set_axis_is_at_home_3: (+1)
   \       0x66   0xF1BA 0x0F03      CMP      R10,#+3
   \       0x6A   0xDBED             BLT.N    ??set_axis_is_at_home_4
   1790          
   1791                // SERIAL_ECHOPAIR("homeposition X:", homeposition[X_AXIS]);
   1792                // SERIAL_ECHOLNPAIR(" Y:", homeposition[Y_AXIS]);
   1793          
   1794                /**
   1795                 * Get Home position SCARA arm angles using inverse kinematics,
   1796                 * and calculate homing offset using forward kinematics
   1797                 */
   1798                inverse_kinematics_MORGAN_SCARA(homeposition);
   \       0x6C   0x4668             MOV      R0,SP
   \       0x6E   0x.... 0x....      BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
   1799                forward_kinematics_SCARA(delta[A_AXIS], delta[B_AXIS]);
   \       0x72   0xF106 0x016C      ADD      R1,R6,#+108
   \       0x76   0xF106 0x0068      ADD      R0,R6,#+104
   \       0x7A   0x.... 0x....      BL       _Z24forward_kinematics_SCARARKfS0_
   1800          
   1801                // SERIAL_ECHOPAIR("Cartesian X:", cartes[X_AXIS]);
   1802                // SERIAL_ECHOLNPAIR(" Y:", cartes[Y_AXIS]);
   1803          
   1804                current_position[axis] = LOGICAL_POSITION(cartes[axis], axis);
   \       0x7E   0xEB06 0x0888      ADD      R8,R6,R8, LSL #+2
   \       0x82   0xF8D9 0x1028      LDR      R1,[R9, #+40]
   \       0x86   0xF8D8 0x0044      LDR      R0,[R8, #+68]
   \       0x8A   0x.... 0x....      BL       __aeabi_fadd
   \       0x8E   0xF8C8 0x0008      STR      R0,[R8, #+8]
   1805          
   1806                /**
   1807                 * SCARA home positions are based on configuration since the actual
   1808                 * limits are determined by the inverse kinematic transform.
   1809                 */
   1810                soft_endstop_min[axis] = base_min_pos(axis); // + (cartes[axis] - base_home_pos(axis));
   \       0x92   0x4620             MOV      R0,R4
   \       0x94   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531912base_min_posE8AxisEnum
   \       0x98   0xF8C8 0x0050      STR      R0,[R8, #+80]
   1811                soft_endstop_max[axis] = base_max_pos(axis); // + (cartes[axis] - base_home_pos(axis));
   \       0x9C   0x4620             MOV      R0,R4
   \       0x9E   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531912base_max_posE8AxisEnum
   \       0xA2   0xF8C8 0x005C      STR      R0,[R8, #+92]
   \       0xA6   0xE015             B.N      ??set_axis_is_at_home_5
   1812              }
   1813              else
   1814            //#endif
   1815            {
   1816              current_position[axis] = LOGICAL_POSITION(base_home_pos(axis), axis);
   \                     ??set_axis_is_at_home_2: (+1)
   \       0xA8   0xEB06 0x0888      ADD      R8,R6,R8, LSL #+2
   \       0xAC   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531913base_home_posE8AxisEnum
   \       0xB0   0xF8D8 0x1044      LDR      R1,[R8, #+68]
   \       0xB4   0x.... 0x....      BL       __aeabi_fadd
   \       0xB8   0xF8C8 0x0008      STR      R0,[R8, #+8]
   \       0xBC   0xE00A             B.N      ??set_axis_is_at_home_5
   1817            }
   1818            	}
   1819            else
   1820            	{
   1821            	current_position[axis] = LOGICAL_POSITION(base_home_pos(axis), axis);
   \                     ??set_axis_is_at_home_0: (+1)
   \       0xBE   0xEB06 0x0888      ADD      R8,R6,R8, LSL #+2
   \       0xC2   0x4620             MOV      R0,R4
   \       0xC4   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531913base_home_posE8AxisEnum
   \       0xC8   0xF8D8 0x1044      LDR      R1,[R8, #+68]
   \       0xCC   0x.... 0x....      BL       __aeabi_fadd
   \       0xD0   0xF8C8 0x0008      STR      R0,[R8, #+8]
   1822            	}
   1823            /**
   1824             * Z Probe Z Homing? Account for the probe's Z offset.
   1825             */
   1826            //#if HAS_BED_PROBE && Z_HOME_DIR < 0	/*--mks cfg--*/
   1827            #if HAS_BED_PROBE
   1828            if(Z_HOME_DIR < 0){
   \                     ??set_axis_is_at_home_5: (+1)
   \       0xD4   0xF997 0x0006      LDRSB    R0,[R7, #+6]
   \       0xD8   0x2800             CMP      R0,#+0
   \       0xDA   0xD512             BPL.N    ??set_axis_is_at_home_6
   1829              if (axis == Z_AXIS) {
   \       0xDC   0x2C02             CMP      R4,#+2
   \       0xDE   0xD110             BNE.N    ??set_axis_is_at_home_6
   1830            //#define HOMING_Z_WITH_PROBE (HAS_BED_PROBE && Z_HOME_DIR < 0 && ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))		
   1831                #if HOMING_Z_WITH_PROBE
   1832          	  	if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
   \       0xE0   0xF897 0x0099      LDRB     R0,[R7, #+153]
   \       0xE4   0x2801             CMP      R0,#+1
   \       0xE6   0xD105             BNE.N    ??set_axis_is_at_home_7
   1833                	{
   1834                  current_position[Z_AXIS] -= zprobe_zoffset;
   \       0xE8   0x6930             LDR      R0,[R6, #+16]
   \       0xEA   0x6CA9             LDR      R1,[R5, #+72]
   \       0xEC   0x.... 0x....      BL       __aeabi_fsub
   \       0xF0   0x6130             STR      R0,[R6, #+16]
   \       0xF2   0xE006             B.N      ??set_axis_is_at_home_6
   1835          
   1836                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   1837                    if (DEBUGGING(LEVELING)) {
   1838                      SERIAL_ECHOLNPGM("*** Z HOMED WITH PROBE (Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) ***");
   1839                      SERIAL_ECHOLNPAIR("> zprobe_zoffset = ", zprobe_zoffset);
   1840                    }
   1841                  #endif
   1842                	}
   1843          		else
   1844          			{
   1845          			if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("*** Z HOMED TO ENDSTOP (Z_MIN_PROBE_ENDSTOP) ***");
   \                     ??set_axis_is_at_home_7: (+1)
   \       0xF4   0x7870             LDRB     R0,[R6, #+1]
   \       0xF6   0x0680             LSLS     R0,R0,#+26
   \       0xF8   0xD503             BPL.N    ??set_axis_is_at_home_6
   \       0xFA   0x.... 0x....      ADR.W    R0,?_2
   \       0xFE   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1846          			}
   1847                #elif ENABLED(DEBUG_LEVELING_FEATURE)
   1848          
   1849                  if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("*** Z HOMED TO ENDSTOP (Z_MIN_PROBE_ENDSTOP) ***");
   1850          
   1851                #endif
   1852              }
   1853            	}
   1854            #endif
   1855          
   1856            #if ENABLED(DEBUG_LEVELING_FEATURE)
   1857              if (DEBUGGING(LEVELING)) {
   1858                #if HAS_HOME_OFFSET
   1859                  SERIAL_ECHOPAIR("> home_offset[", axis_codes[axis]);
   1860                  SERIAL_ECHOLNPAIR("] = ", home_offset[axis]);
   1861                #endif
   1862                DEBUG_POS("", current_position);
   1863                SERIAL_ECHOPAIR("<<< set_axis_is_at_home(", axis_codes[axis]);
   1864                SERIAL_CHAR(')');
   1865                SERIAL_EOL;
   1866              }
   1867            #endif
   1868          }
   \                     ??set_axis_is_at_home_6: (+1)
   \      0x102   0xE8BD 0x87FF      POP      {R0-R10,PC}      ;; return
   1869          
   1870          /**
   1871           * Some planner shorthand inline functions
   1872           */

   \                                 In section .text, align 4
   1873          inline float get_homing_bump_feedrate(AxisEnum axis) {
   \                     _Z24get_homing_bump_feedrate8AxisEnum: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x4604             MOV      R4,R0
   1874          //  int constexpr homing_bump_divisor[] = HOMING_BUMP_DIVISOR;
   1875          	int  homing_bump_divisor[4];
   1876          	if(MACHINETPYE == DELTA)
   \        0x6   0x4668             MOV      R0,SP
   \        0x8   0x4912             LDR.N    R1,??get_homing_bump_feedrate_0
   \        0xA   0xF9B1 0x1058      LDRSH    R1,[R1, #+88]
   \        0xE   0x2902             CMP      R1,#+2
   \       0x10   0xD104             BNE.N    ??get_homing_bump_feedrate_1
   1877          	{
   1878          	homing_bump_divisor[0] = 10;
   \       0x12   0x210A             MOVS     R1,#+10
   \       0x14   0x9100             STR      R1,[SP, #+0]
   1879          	homing_bump_divisor[1] = 10;
   \       0x16   0x6041             STR      R1,[R0, #+4]
   1880          	homing_bump_divisor[2] = 10;
   \       0x18   0x6081             STR      R1,[R0, #+8]
   \       0x1A   0xE004             B.N      ??get_homing_bump_feedrate_2
   1881          	}
   1882          	else
   1883          	{
   1884          	homing_bump_divisor[0] = 2;
   \                     ??get_homing_bump_feedrate_1: (+1)
   \       0x1C   0x2102             MOVS     R1,#+2
   \       0x1E   0x9100             STR      R1,[SP, #+0]
   1885          	homing_bump_divisor[1] = 2;
   \       0x20   0x6041             STR      R1,[R0, #+4]
   1886          	homing_bump_divisor[2] = 4;
   \       0x22   0x2104             MOVS     R1,#+4
   \       0x24   0x6081             STR      R1,[R0, #+8]
   1887          	}
   1888          
   1889            int hbd = homing_bump_divisor[axis];
   \                     ??get_homing_bump_feedrate_2: (+1)
   \       0x26   0xF850 0x5024      LDR      R5,[R0, R4, LSL #+2]
   1890            if (hbd < 1) {
   \       0x2A   0x2D01             CMP      R5,#+1
   \       0x2C   0xDA06             BGE.N    ??get_homing_bump_feedrate_3
   1891              hbd = 10;
   \       0x2E   0x250A             MOVS     R5,#+10
   1892              SERIAL_ECHO_START;
   \       0x30   0x4809             LDR.N    R0,??get_homing_bump_feedrate_0+0x4
   \       0x32   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1893              SERIAL_ECHOLNPGM("Warning: Homing Bump Divisor < 1");
   \       0x36   0x4809             LDR.N    R0,??get_homing_bump_feedrate_0+0x8
   \       0x38   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1894            }
   1895            return homing_feedrate_mm_s[axis] / hbd;
   \                     ??get_homing_bump_feedrate_3: (+1)
   \       0x3C   0x4628             MOV      R0,R5
   \       0x3E   0x.... 0x....      BL       __aeabi_i2f
   \       0x42   0x4601             MOV      R1,R0
   \       0x44   0x4806             LDR.N    R0,??get_homing_bump_feedrate_0+0xC
   \       0x46   0xEB00 0x0084      ADD      R0,R0,R4, LSL #+2
   \       0x4A   0x6A80             LDR      R0,[R0, #+40]
   \       0x4C   0x.... 0x....      BL       __aeabi_fdiv
   \       0x50   0xB005             ADD      SP,SP,#+20
   \       0x52   0xBD30             POP      {R4,R5,PC}       ;; return
   \                     ??get_homing_bump_feedrate_0:
   \       0x54   0x....'....        DC32     mksCfg
   \       0x58   0x....'....        DC32     echomagic
   \       0x5C   0x....'....        DC32     _ZZ24get_homing_bump_feedrate8AxisEnumEs
   \       0x60   0x....'....        DC32     mks_heating_busy
   1896          }
   1897          
   1898          //
   1899          // line_to_current_position
   1900          // Move the planner to the current position from wherever it last moved
   1901          // (or from wherever it has been told it is located).
   1902          //

   \                                 In section .text, align 4
   1903          inline void line_to_current_position() {
   \                     _Z24line_to_current_positionv: (+1)
   \        0x0   0xB5E0             PUSH     {R5-R7,LR}
   1904            planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], feedrate_mm_s, active_extruder);
   \        0x2   0x4807             LDR.N    R0,??line_to_current_position_0
   \        0x4   0x7881             LDRB     R1,[R0, #+2]
   \        0x6   0x9101             STR      R1,[SP, #+4]
   \        0x8   0xF100 0x0174      ADD      R1,R0,#+116
   \        0xC   0x9100             STR      R1,[SP, #+0]
   \        0xE   0xF100 0x0314      ADD      R3,R0,#+20
   \       0x12   0x6902             LDR      R2,[R0, #+16]
   \       0x14   0x68C1             LDR      R1,[R0, #+12]
   \       0x16   0x6880             LDR      R0,[R0, #+8]
   \       0x18   0x.... 0x....      BL       _ZN7Planner11buffer_lineEfffRKfS1_h
   1905          }
   \       0x1C   0xBD07             POP      {R0-R2,PC}       ;; return
   \       0x1E   0xBF00             Nop      
   \                     ??line_to_current_position_0:
   \       0x20   0x....'....        DC32     mks_heating_busy
   1906          
   1907          //
   1908          // line_to_destination
   1909          // Move the planner, not necessarily synced with current_position
   1910          //

   \                                 In section .text, align 4
   1911          inline void line_to_destination(float fr_mm_s) {
   \                     _Z19line_to_destinationf: (+1)
   \        0x0   0xB501             PUSH     {R0,LR}
   \        0x2   0xB082             SUB      SP,SP,#+8
   1912            planner.buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], fr_mm_s, active_extruder);
   \        0x4   0x4806             LDR.N    R0,??line_to_destination_0
   \        0x6   0x7881             LDRB     R1,[R0, #+2]
   \        0x8   0x9101             STR      R1,[SP, #+4]
   \        0xA   0xA902             ADD      R1,SP,#+8
   \        0xC   0x9100             STR      R1,[SP, #+0]
   \        0xE   0xF100 0x0324      ADD      R3,R0,#+36
   \       0x12   0x6A02             LDR      R2,[R0, #+32]
   \       0x14   0x69C1             LDR      R1,[R0, #+28]
   \       0x16   0x6980             LDR      R0,[R0, #+24]
   \       0x18   0x.... 0x....      BL       _ZN7Planner11buffer_lineEfffRKfS1_h
   1913          }
   \       0x1C   0xBD07             POP      {R0-R2,PC}       ;; return
   \       0x1E   0xBF00             Nop      
   \                     ??line_to_destination_0:
   \       0x20   0x....'....        DC32     mks_heating_busy

   \                                 In section .text, align 4
   1914          inline void line_to_destination() { line_to_destination(feedrate_mm_s); }
   \                     _Z19line_to_destinationv: (+1)
   \        0x0   0x4801             LDR.N    R0,??line_to_destination_1
   \        0x2   0x6F40             LDR      R0,[R0, #+116]
   \        0x4   0x.... 0x....      B.W      _Z19line_to_destinationf
   \                     ??line_to_destination_1:
   \        0x8   0x....'....        DC32     mks_heating_busy
   1915          

   \                                 In section .text, align 4
   1916          inline void set_current_to_destination() { COPY(current_position, destination); }
   \                     _Z26set_current_to_destinationv: (+1)
   \        0x0   0x4803             LDR.N    R0,??set_current_to_destination_0
   \        0x2   0x2210             MOVS     R2,#+16
   \        0x4   0xF100 0x0118      ADD      R1,R0,#+24
   \        0x8   0x3008             ADDS     R0,R0,#+8
   \        0xA   0x.... 0x....      B.W      __aeabi_memcpy
   \        0xE   0xBF00             Nop      
   \                     ??set_current_to_destination_0:
   \       0x10   0x....'....        DC32     mks_heating_busy

   \                                 In section .text, align 4
   1917          inline void set_destination_to_current() { COPY(destination, current_position); }
   \                     _Z26set_destination_to_currentv: (+1)
   \        0x0   0x4803             LDR.N    R0,??set_destination_to_current_0
   \        0x2   0x2210             MOVS     R2,#+16
   \        0x4   0xF100 0x0108      ADD      R1,R0,#+8
   \        0x8   0x3018             ADDS     R0,R0,#+24
   \        0xA   0x.... 0x....      B.W      __aeabi_memcpy
   \        0xE   0xBF00             Nop      
   \                     ??set_destination_to_current_0:
   \       0x10   0x....'....        DC32     mks_heating_busy
   1918          
   1919          //#if IS_KINEMATIC	//mks_delta
   1920          #if 1
   1921            /**
   1922             * Calculate delta, start a line, and set current_position to destination
   1923             */

   \                                 In section .text, align 2, keep-with-next
   1924            void prepare_uninterpolated_move_to_destination(const float fr_mm_s=0.0) {
   \                     _Z42prepare_uninterpolated_move_to_destinationf: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   1925              #if ENABLED(DEBUG_LEVELING_FEATURE)
   1926                if (DEBUGGING(LEVELING)) DEBUG_POS("prepare_uninterpolated_move_to_destination", destination);
   1927              #endif
   1928          
   1929              if ( current_position[X_AXIS] == destination[X_AXIS]
   1930                && current_position[Y_AXIS] == destination[Y_AXIS]
   1931                && current_position[Z_AXIS] == destination[Z_AXIS]
   1932                && current_position[E_AXIS] == destination[E_AXIS]
   1933              ) return;
   \        0x4   0x.... 0x....      LDR.W    R5,??DataTable112_3
   \        0x8   0x68A8             LDR      R0,[R5, #+8]
   \        0xA   0x69A9             LDR      R1,[R5, #+24]
   \        0xC   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0x10   0xD10E             BNE.N    ??prepare_uninterpolated_move_to_destination_0
   \       0x12   0x68E8             LDR      R0,[R5, #+12]
   \       0x14   0x69E9             LDR      R1,[R5, #+28]
   \       0x16   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0x1A   0xD109             BNE.N    ??prepare_uninterpolated_move_to_destination_0
   \       0x1C   0x6928             LDR      R0,[R5, #+16]
   \       0x1E   0x6A29             LDR      R1,[R5, #+32]
   \       0x20   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0x24   0xD104             BNE.N    ??prepare_uninterpolated_move_to_destination_0
   \       0x26   0x6968             LDR      R0,[R5, #+20]
   \       0x28   0x6A69             LDR      R1,[R5, #+36]
   \       0x2A   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0x2E   0xD020             BEQ.N    ??prepare_uninterpolated_move_to_destination_1
   1934          
   1935              refresh_cmd_timeout();
   \                     ??prepare_uninterpolated_move_to_destination_0: (+1)
   \       0x30   0x.... 0x....      BL       _Z19refresh_cmd_timeoutv
   1936              planner.buffer_line_kinematic(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s), active_extruder);
   \       0x34   0x4620             MOV      R0,R4
   \       0x36   0x2100             MOVS     R1,#+0
   \       0x38   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0x3C   0xD100             BNE.N    ??prepare_uninterpolated_move_to_destination_2
   \       0x3E   0x6F6C             LDR      R4,[R5, #+116]
   \                     ??prepare_uninterpolated_move_to_destination_2: (+1)
   \       0x40   0x6FA8             LDR      R0,[R5, #+120]
   \       0x42   0x.... 0x....      BL       __aeabi_i2f
   \       0x46   0x4621             MOV      R1,R4
   \       0x48   0x.... 0x....      BL       __aeabi_fmul
   \       0x4C   0x.... 0x....      BL       __aeabi_f2d
   \       0x50   0x.... 0x....      LDR.W    R2,??DataTable120  ;; 0x47ae147b
   \       0x54   0x.... 0x....      LDR.W    R3,??DataTable121  ;; 0x3f847ae1
   \       0x58   0x.... 0x....      BL       __aeabi_dmul
   \       0x5C   0x.... 0x....      BL       __aeabi_d2f
   \       0x60   0x9000             STR      R0,[SP, #+0]
   \       0x62   0x78AA             LDRB     R2,[R5, #+2]
   \       0x64   0x4669             MOV      R1,SP
   \       0x66   0xF105 0x0018      ADD      R0,R5,#+24
   \       0x6A   0x.... 0x....      BL       _ZN7Planner21buffer_line_kinematicEPKfRS0_h
   1937              set_current_to_destination();
   \       0x6E   0x.... 0x....      BL       _Z26set_current_to_destinationv
   1938            }
   \                     ??prepare_uninterpolated_move_to_destination_1: (+1)
   \       0x72   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1939          #endif // IS_KINEMATIC
   1940          
   1941          /**
   1942           *  Plan a move to (X, Y, Z) and set the current_position
   1943           *  The final current_position may not be the one that was requested
   1944           */

   \                                 In section .text, align 2, keep-with-next
   1945          void do_blocking_move_to(const float &x, const float &y, const float &z, const float &fr_mm_s /*=0.0*/) {
   \                     _Z19do_blocking_move_toRKfS0_S0_S0_: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x460F             MOV      R7,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x4699             MOV      R9,R3
   1946            const float old_feedrate_mm_s = feedrate_mm_s;
   \        0xC   0x.... 0x....      LDR.W    R4,??DataTable112_3
   \       0x10   0x6F65             LDR      R5,[R4, #+116]
   1947          
   1948            #if ENABLED(DEBUG_LEVELING_FEATURE)
   1949              if (DEBUGGING(LEVELING)) print_xyz(PSTR(">>> do_blocking_move_to"), NULL, x, y, z);
   1950            #endif
   1951          
   1952            //#if ENABLED(DELTA)	//mks_delta
   1953            if(MACHINETPYE == DELTA) {
   \       0x12   0x.... 0x....      LDR.W    R0,??DataTable113_4
   \       0x16   0xF9B0 0x0058      LDRSH    R0,[R0, #+88]
   \       0x1A   0x2802             CMP      R0,#+2
   \       0x1C   0xD141             BNE.N    ??do_blocking_move_to_0
   1954          	
   1955              feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
   \       0x1E   0xF8D9 0x2000      LDR      R2,[R9, #+0]
   \       0x22   0x4610             MOV      R0,R2
   \       0x24   0x2100             MOVS     R1,#+0
   \       0x26   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0x2A   0xD001             BEQ.N    ??do_blocking_move_to_1
   \       0x2C   0x6762             STR      R2,[R4, #+116]
   \       0x2E   0xE001             B.N      ??do_blocking_move_to_2
   \                     ??do_blocking_move_to_1: (+1)
   \       0x30   0x6FE0             LDR      R0,[R4, #+124]
   \       0x32   0x6760             STR      R0,[R4, #+116]
   1956          
   1957              set_destination_to_current();          // sync destination at the start
   \                     ??do_blocking_move_to_2: (+1)
   \       0x34   0x.... 0x....      BL       _Z26set_destination_to_currentv
   1958          
   1959              #if ENABLED(DEBUG_LEVELING_FEATURE)
   1960                if (DEBUGGING(LEVELING)) DEBUG_POS("set_destination_to_current", destination);
   1961              #endif
   1962          
   1963              // when in the danger zone
   1964              if (current_position[Z_AXIS] > delta_clip_start_height) {
   \       0x38   0xF8D4 0x0080      LDR      R0,[R4, #+128]
   \       0x3C   0x6921             LDR      R1,[R4, #+16]
   \       0x3E   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x42   0xD213             BCS.N    ??do_blocking_move_to_3
   1965                if (z > delta_clip_start_height) {   // staying in the danger zone
   \       0x44   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \       0x48   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x4C   0xD20A             BCS.N    ??do_blocking_move_to_4
   1966                  destination[X_AXIS] = x;           // move directly (uninterpolated)
   \       0x4E   0x6830             LDR      R0,[R6, #+0]
   \       0x50   0x61A0             STR      R0,[R4, #+24]
   1967                  destination[Y_AXIS] = y;
   \       0x52   0x6838             LDR      R0,[R7, #+0]
   \       0x54   0x61E0             STR      R0,[R4, #+28]
   1968                  destination[Z_AXIS] = z;
   \       0x56   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x5A   0x6220             STR      R0,[R4, #+32]
   1969                  prepare_uninterpolated_move_to_destination(); // set_current_to_destination
   \       0x5C   0x2000             MOVS     R0,#+0
   \       0x5E   0xE8BD 0x43F2      POP      {R1,R4-R9,LR}
   \       0x62   0x....             B.N      _Z42prepare_uninterpolated_move_to_destinationf
   1970                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   1971                    if (DEBUGGING(LEVELING)) DEBUG_POS("danger zone move", current_position);
   1972                  #endif
   1973                  return;
   1974                }
   1975                else {
   1976                  destination[Z_AXIS] = delta_clip_start_height;
   \                     ??do_blocking_move_to_4: (+1)
   \       0x64   0x6220             STR      R0,[R4, #+32]
   1977                  prepare_uninterpolated_move_to_destination(); // set_current_to_destination
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0x.... 0x....      BL       _Z42prepare_uninterpolated_move_to_destinationf
   1978                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   1979                    if (DEBUGGING(LEVELING)) DEBUG_POS("zone border move", current_position);
   1980                  #endif
   1981                }
   1982              }
   1983          
   1984              if (z > current_position[Z_AXIS]) {    // raising?
   \                     ??do_blocking_move_to_3: (+1)
   \       0x6C   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \       0x70   0x6920             LDR      R0,[R4, #+16]
   \       0x72   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x76   0xD203             BCS.N    ??do_blocking_move_to_5
   1985                destination[Z_AXIS] = z;
   \       0x78   0x6221             STR      R1,[R4, #+32]
   1986                prepare_uninterpolated_move_to_destination();   // set_current_to_destination
   \       0x7A   0x2000             MOVS     R0,#+0
   \       0x7C   0x.... 0x....      BL       _Z42prepare_uninterpolated_move_to_destinationf
   1987                #if ENABLED(DEBUG_LEVELING_FEATURE)
   1988                  if (DEBUGGING(LEVELING)) DEBUG_POS("z raise move", current_position);
   1989                #endif
   1990              }
   1991          
   1992              destination[X_AXIS] = x;
   \                     ??do_blocking_move_to_5: (+1)
   \       0x80   0x6830             LDR      R0,[R6, #+0]
   \       0x82   0x61A0             STR      R0,[R4, #+24]
   1993              destination[Y_AXIS] = y;
   \       0x84   0x6838             LDR      R0,[R7, #+0]
   \       0x86   0x61E0             STR      R0,[R4, #+28]
   1994              prepare_move_to_destination();         // set_current_to_destination
   \       0x88   0x.... 0x....      BL       _Z27prepare_move_to_destinationv
   1995              #if ENABLED(DEBUG_LEVELING_FEATURE)
   1996                if (DEBUGGING(LEVELING)) DEBUG_POS("xy move", current_position);
   1997              #endif
   1998          
   1999              if (z < current_position[Z_AXIS]) {    // lowering?
   \       0x8C   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x90   0x6921             LDR      R1,[R4, #+16]
   \       0x92   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x96   0xD27A             BCS.N    ??do_blocking_move_to_6
   2000                destination[Z_AXIS] = z;
   \       0x98   0x6220             STR      R0,[R4, #+32]
   2001                prepare_uninterpolated_move_to_destination();   // set_current_to_destination
   \       0x9A   0x2000             MOVS     R0,#+0
   \       0x9C   0x.... 0x....      BL       _Z42prepare_uninterpolated_move_to_destinationf
   \       0xA0   0xE075             B.N      ??do_blocking_move_to_6
   2002                #if ENABLED(DEBUG_LEVELING_FEATURE)
   2003                  if (DEBUGGING(LEVELING)) DEBUG_POS("z lower move", current_position);
   2004                #endif
   2005              }
   2006            	}
   2007            //#elif IS_SCARA
   2008          	else if(MACHINETPYE&IS_SCARA) {
   \                     ??do_blocking_move_to_0: (+1)
   \       0xA2   0xF410 0x7F40      TST      R0,#0x300
   \       0xA6   0xD035             BEQ.N    ??do_blocking_move_to_7
   2009              set_destination_to_current();
   \       0xA8   0x.... 0x....      BL       _Z26set_destination_to_currentv
   2010          
   2011              // If Z needs to raise, do it before moving XY
   2012              if (destination[Z_AXIS] < z) {
   \       0xAC   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \       0xB0   0x6A20             LDR      R0,[R4, #+32]
   \       0xB2   0x.... 0x....      BL       __aeabi_cfcmple
   \       0xB6   0xD20B             BCS.N    ??do_blocking_move_to_8
   2013                destination[Z_AXIS] = z;
   \       0xB8   0x6221             STR      R1,[R4, #+32]
   2014                prepare_uninterpolated_move_to_destination(fr_mm_s ? fr_mm_s : homing_feedrate_mm_s[Z_AXIS]);
   \       0xBA   0xF8D9 0x2000      LDR      R2,[R9, #+0]
   \       0xBE   0x4610             MOV      R0,R2
   \       0xC0   0x2100             MOVS     R1,#+0
   \       0xC2   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0xC6   0xD100             BNE.N    ??do_blocking_move_to_9
   \       0xC8   0x6B22             LDR      R2,[R4, #+48]
   \                     ??do_blocking_move_to_9: (+1)
   \       0xCA   0x4610             MOV      R0,R2
   \       0xCC   0x.... 0x....      BL       _Z42prepare_uninterpolated_move_to_destinationf
   2015              }
   2016          
   2017              destination[X_AXIS] = x;
   \                     ??do_blocking_move_to_8: (+1)
   \       0xD0   0x6830             LDR      R0,[R6, #+0]
   \       0xD2   0x61A0             STR      R0,[R4, #+24]
   2018              destination[Y_AXIS] = y;
   \       0xD4   0x6838             LDR      R0,[R7, #+0]
   \       0xD6   0x61E0             STR      R0,[R4, #+28]
   2019              prepare_uninterpolated_move_to_destination(fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S);
   \       0xD8   0xF8D9 0x2000      LDR      R2,[R9, #+0]
   \       0xDC   0x4610             MOV      R0,R2
   \       0xDE   0x2100             MOVS     R1,#+0
   \       0xE0   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0xE4   0xD100             BNE.N    ??do_blocking_move_to_10
   \       0xE6   0x6FE2             LDR      R2,[R4, #+124]
   \                     ??do_blocking_move_to_10: (+1)
   \       0xE8   0x4610             MOV      R0,R2
   \       0xEA   0x.... 0x....      BL       _Z42prepare_uninterpolated_move_to_destinationf
   2020          
   2021              // If Z needs to lower, do it after moving XY
   2022              if (destination[Z_AXIS] > z) {
   \       0xEE   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xF2   0x6A21             LDR      R1,[R4, #+32]
   \       0xF4   0x.... 0x....      BL       __aeabi_cfcmple
   \       0xF8   0xD249             BCS.N    ??do_blocking_move_to_6
   2023                destination[Z_AXIS] = z;
   \       0xFA   0x6220             STR      R0,[R4, #+32]
   2024                prepare_uninterpolated_move_to_destination(fr_mm_s ? fr_mm_s : homing_feedrate_mm_s[Z_AXIS]);
   \       0xFC   0xF8D9 0x2000      LDR      R2,[R9, #+0]
   \      0x100   0x4610             MOV      R0,R2
   \      0x102   0x2100             MOVS     R1,#+0
   \      0x104   0x.... 0x....      BL       __aeabi_cfcmpeq
   \      0x108   0xD100             BNE.N    ??do_blocking_move_to_11
   \      0x10A   0x6B22             LDR      R2,[R4, #+48]
   \                     ??do_blocking_move_to_11: (+1)
   \      0x10C   0x4610             MOV      R0,R2
   \      0x10E   0x.... 0x....      BL       _Z42prepare_uninterpolated_move_to_destinationf
   \      0x112   0xE03C             B.N      ??do_blocking_move_to_6
   2025              }
   2026          		}
   2027            //#else
   2028          	else {
   2029              // If Z needs to raise, do it before moving XY
   2030              if (current_position[Z_AXIS] < z) {
   \                     ??do_blocking_move_to_7: (+1)
   \      0x114   0x6920             LDR      R0,[R4, #+16]
   \      0x116   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \      0x11A   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x11E   0xD20F             BCS.N    ??do_blocking_move_to_12
   2031                feedrate_mm_s = fr_mm_s ? fr_mm_s : homing_feedrate_mm_s[Z_AXIS];
   \      0x120   0xF8D9 0x2000      LDR      R2,[R9, #+0]
   \      0x124   0x4610             MOV      R0,R2
   \      0x126   0x2100             MOVS     R1,#+0
   \      0x128   0x.... 0x....      BL       __aeabi_cfcmpeq
   \      0x12C   0xD001             BEQ.N    ??do_blocking_move_to_13
   \      0x12E   0x6762             STR      R2,[R4, #+116]
   \      0x130   0xE001             B.N      ??do_blocking_move_to_14
   \                     ??do_blocking_move_to_13: (+1)
   \      0x132   0x6B20             LDR      R0,[R4, #+48]
   \      0x134   0x6760             STR      R0,[R4, #+116]
   2032                current_position[Z_AXIS] = z;
   \                     ??do_blocking_move_to_14: (+1)
   \      0x136   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x13A   0x6120             STR      R0,[R4, #+16]
   2033                line_to_current_position();
   \      0x13C   0x.... 0x....      BL       _Z24line_to_current_positionv
   2034              }
   2035          
   2036              feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
   \                     ??do_blocking_move_to_12: (+1)
   \      0x140   0xF8D9 0x2000      LDR      R2,[R9, #+0]
   \      0x144   0x4610             MOV      R0,R2
   \      0x146   0x2100             MOVS     R1,#+0
   \      0x148   0x.... 0x....      BL       __aeabi_cfcmpeq
   \      0x14C   0xD001             BEQ.N    ??do_blocking_move_to_15
   \      0x14E   0x6762             STR      R2,[R4, #+116]
   \      0x150   0xE001             B.N      ??do_blocking_move_to_16
   \                     ??do_blocking_move_to_15: (+1)
   \      0x152   0x6FE0             LDR      R0,[R4, #+124]
   \      0x154   0x6760             STR      R0,[R4, #+116]
   2037              current_position[X_AXIS] = x;
   \                     ??do_blocking_move_to_16: (+1)
   \      0x156   0x6830             LDR      R0,[R6, #+0]
   \      0x158   0x60A0             STR      R0,[R4, #+8]
   2038              current_position[Y_AXIS] = y;
   \      0x15A   0x6838             LDR      R0,[R7, #+0]
   \      0x15C   0x60E0             STR      R0,[R4, #+12]
   2039              line_to_current_position();
   \      0x15E   0x.... 0x....      BL       _Z24line_to_current_positionv
   2040          
   2041              // If Z needs to lower, do it after moving XY
   2042              if (current_position[Z_AXIS] > z) {
   \      0x162   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x166   0x6921             LDR      R1,[R4, #+16]
   \      0x168   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x16C   0xD20F             BCS.N    ??do_blocking_move_to_6
   2043                feedrate_mm_s = fr_mm_s ? fr_mm_s : homing_feedrate_mm_s[Z_AXIS];
   \      0x16E   0xF8D9 0x2000      LDR      R2,[R9, #+0]
   \      0x172   0x4610             MOV      R0,R2
   \      0x174   0x2100             MOVS     R1,#+0
   \      0x176   0x.... 0x....      BL       __aeabi_cfcmpeq
   \      0x17A   0xD001             BEQ.N    ??do_blocking_move_to_17
   \      0x17C   0x6762             STR      R2,[R4, #+116]
   \      0x17E   0xE001             B.N      ??do_blocking_move_to_18
   \                     ??do_blocking_move_to_17: (+1)
   \      0x180   0x6B20             LDR      R0,[R4, #+48]
   \      0x182   0x6760             STR      R0,[R4, #+116]
   2044                current_position[Z_AXIS] = z;
   \                     ??do_blocking_move_to_18: (+1)
   \      0x184   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x188   0x6120             STR      R0,[R4, #+16]
   2045                line_to_current_position();
   \      0x18A   0x.... 0x....      BL       _Z24line_to_current_positionv
   2046              }
   2047          		}
   2048            //#endif
   2049          
   2050            stepper.synchronize();
   \                     ??do_blocking_move_to_6: (+1)
   \      0x18E   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   2051          
   2052            feedrate_mm_s = old_feedrate_mm_s;
   \      0x192   0x6765             STR      R5,[R4, #+116]
   2053          
   2054            #if ENABLED(DEBUG_LEVELING_FEATURE)
   2055              if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< do_blocking_move_to");
   2056            #endif
   2057          }
   \      0x194   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   2058          void do_blocking_move_to_x(const float &x, const float &fr_mm_s/*=0.0*/) {
   \                     _Z21do_blocking_move_to_xRKfS0_: (+1)
   \        0x0   0x460B             MOV      R3,R1
   2059            do_blocking_move_to(x, current_position[Y_AXIS], current_position[Z_AXIS], fr_mm_s);
   \        0x2   0x....             LDR.N    R1,??DataTable112_3
   \        0x4   0xF101 0x0210      ADD      R2,R1,#+16
   \        0x8   0x310C             ADDS     R1,R1,#+12
   \        0xA   0x....             B.N      _Z19do_blocking_move_toRKfS0_S0_S0_
   2060          }

   \                                 In section .text, align 2, keep-with-next
   2061          void do_blocking_move_to_z(const float &z, const float &fr_mm_s/*=0.0*/) {
   \                     _Z21do_blocking_move_to_zRKfS0_: (+1)
   \        0x0   0x4602             MOV      R2,R0
   \        0x2   0x460B             MOV      R3,R1
   2062            do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], z, fr_mm_s);
   \        0x4   0x....             LDR.N    R0,??DataTable112_3
   \        0x6   0xF100 0x010C      ADD      R1,R0,#+12
   \        0xA   0x3008             ADDS     R0,R0,#+8
   \        0xC   0x....             B.N      _Z19do_blocking_move_toRKfS0_S0_S0_
   2063          }

   \                                 In section .text, align 2, keep-with-next
   2064          void do_blocking_move_to_xy(const float &x, const float &y, const float &fr_mm_s/*=0.0*/) {
   \                     _Z22do_blocking_move_to_xyRKfS0_S0_: (+1)
   \        0x0   0x4613             MOV      R3,R2
   2065            do_blocking_move_to(x, y, current_position[Z_AXIS], fr_mm_s);
   \        0x2   0x.... 0x....      LDR.W    R2,??DataTable123
   \        0x6   0x....             B.N      _Z19do_blocking_move_toRKfS0_S0_S0_
   2066          }
   2067          
   2068          //
   2069          // Prepare to do endstop or probe moves
   2070          // with custom feedrates.
   2071          //
   2072          //  - Save current feedrates
   2073          //  - Reset the rate multiplier
   2074          //  - Reset the command timeout
   2075          //  - Enable the endstops (for endstop moves)
   2076          //

   \                                 In section .text, align 2, keep-with-next
   2077          static void setup_for_endstop_or_probe_move() {
   2078            #if ENABLED(DEBUG_LEVELING_FEATURE)
   2079              if (DEBUGGING(LEVELING)) DEBUG_POS("setup_for_endstop_or_probe_move", current_position);
   2080            #endif
   2081            saved_feedrate_mm_s = feedrate_mm_s;
   \                     _ZN37_INTERNAL_15_Marlin_main_cpp_3178531931setup_for_endstop_or_probe_moveEv: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable122
   \        0x4   0x....             LDR.N    R1,??DataTable112_3
   \        0x6   0x6F4A             LDR      R2,[R1, #+116]
   \        0x8   0x6002             STR      R2,[R0, #+0]
   2082            saved_feedrate_percentage = feedrate_percentage;
   \        0xA   0x6F8A             LDR      R2,[R1, #+120]
   \        0xC   0x6042             STR      R2,[R0, #+4]
   2083            feedrate_percentage = 100;
   \        0xE   0x2064             MOVS     R0,#+100
   \       0x10   0x6788             STR      R0,[R1, #+120]
   2084            refresh_cmd_timeout();
   \       0x12   0x.... 0x....      B.W      _Z19refresh_cmd_timeoutv
   2085          }
   2086          

   \                                 In section .text, align 2, keep-with-next
   2087          static void clean_up_after_endstop_or_probe_move() {
   2088            #if ENABLED(DEBUG_LEVELING_FEATURE)
   2089              if (DEBUGGING(LEVELING)) DEBUG_POS("clean_up_after_endstop_or_probe_move", current_position);
   2090            #endif
   2091            feedrate_mm_s = saved_feedrate_mm_s;
   \                     _ZN37_INTERNAL_15_Marlin_main_cpp_3178531936clean_up_after_endstop_or_probe_moveEv: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable112_3
   \        0x2   0x.... 0x....      LDR.W    R1,??DataTable122
   \        0x6   0x680A             LDR      R2,[R1, #+0]
   \        0x8   0x6742             STR      R2,[R0, #+116]
   2092            feedrate_percentage = saved_feedrate_percentage;
   \        0xA   0x6849             LDR      R1,[R1, #+4]
   \        0xC   0x6781             STR      R1,[R0, #+120]
   2093            refresh_cmd_timeout();
   \        0xE   0x.... 0x....      B.W      _Z19refresh_cmd_timeoutv
   2094          }
   2095          
   2096          #if HAS_BED_PROBE
   2097            /**
   2098             * Raise Z to a minimum height to make room for a probe to move
   2099             */

   \                                 In section .text, align 4
   2100            inline void do_probe_raise(float z_raise) {
   \                     _Z14do_probe_raisef: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x4601             MOV      R1,R0
   2101              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2102                if (DEBUGGING(LEVELING)) {
   2103                  SERIAL_ECHOPAIR("do_probe_raise(", z_raise);
   2104                  SERIAL_CHAR(')');
   2105                  SERIAL_EOL;
   2106                }
   2107              #endif
   2108          
   2109              float z_dest = LOGICAL_Z_POSITION(z_raise);
   \        0x4   0x4C13             LDR.N    R4,??do_probe_raise_0
   \        0x6   0x6CE0             LDR      R0,[R4, #+76]
   \        0x8   0x.... 0x....      BL       __aeabi_fadd
   \        0xC   0x9000             STR      R0,[SP, #+0]
   2110              if (zprobe_zoffset < 0) z_dest -= zprobe_zoffset;
   \        0xE   0x4812             LDR.N    R0,??do_probe_raise_0+0x4
   \       0x10   0x6C82             LDR      R2,[R0, #+72]
   \       0x12   0x4610             MOV      R0,R2
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x1A   0xD204             BCS.N    ??do_probe_raise_1
   \       0x1C   0x9800             LDR      R0,[SP, #+0]
   \       0x1E   0x4611             MOV      R1,R2
   \       0x20   0x.... 0x....      BL       __aeabi_fsub
   \       0x24   0x9000             STR      R0,[SP, #+0]
   2111          //    #if ENABLED(DELTA)
   2112          	  if(MACHINETPYE == DELTA)
   \                     ??do_probe_raise_1: (+1)
   \       0x26   0x480D             LDR.N    R0,??do_probe_raise_0+0x8
   \       0x28   0xF9B0 0x0058      LDRSH    R0,[R0, #+88]
   \       0x2C   0x2802             CMP      R0,#+2
   \       0x2E   0xD104             BNE.N    ??do_probe_raise_2
   2113          	      z_dest -= home_offset[Z_AXIS];
   \       0x30   0x9800             LDR      R0,[SP, #+0]
   \       0x32   0x6C21             LDR      R1,[R4, #+64]
   \       0x34   0x.... 0x....      BL       __aeabi_fsub
   \       0x38   0x9000             STR      R0,[SP, #+0]
   2114          //    #endif
   2115          
   2116              if (z_dest > current_position[Z_AXIS])
   \                     ??do_probe_raise_2: (+1)
   \       0x3A   0x6920             LDR      R0,[R4, #+16]
   \       0x3C   0x9900             LDR      R1,[SP, #+0]
   \       0x3E   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x42   0xD205             BCS.N    ??do_probe_raise_3
   2117                do_blocking_move_to_z(z_dest);
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0x9001             STR      R0,[SP, #+4]
   \       0x48   0xA901             ADD      R1,SP,#+4
   \       0x4A   0x4668             MOV      R0,SP
   \       0x4C   0x.... 0x....      BL       _Z21do_blocking_move_to_zRKfS0_
   2118            }
   \                     ??do_probe_raise_3: (+1)
   \       0x50   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   \       0x52   0xBF00             Nop      
   \                     ??do_probe_raise_0:
   \       0x54   0x....'....        DC32     mks_heating_busy
   \       0x58   0x....'....        DC32     axis_homed
   \       0x5C   0x....'....        DC32     mksCfg
   2119          
   2120          #endif //HAS_BED_PROBE
   2121          
   2122          #if HAS_PROBING_PROCEDURE || HOTENDS > 1 || ENABLED(Z_PROBE_ALLEN_KEY) || ENABLED(Z_PROBE_SLED) || ENABLED(NOZZLE_CLEAN_FEATURE) || ENABLED(NOZZLE_PARK_FEATURE) || ENABLED(DELTA_AUTO_CALIBRATION)
   2123          

   \                                 In section .text, align 2, keep-with-next
   2124            bool axis_unhomed_error(const bool x, const bool y, const bool z) {
   \                     _Z18axis_unhomed_errorbbb: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   2125              const bool xx = x && !axis_homed[X_AXIS],
   \        0x2   0x2800             CMP      R0,#+0
   \        0x4   0xD006             BEQ.N    ??axis_unhomed_error_0
   \        0x6   0x.... 0x....      LDR.W    R0,??DataTable116_7
   \        0xA   0x7800             LDRB     R0,[R0, #+0]
   \        0xC   0x1E44             SUBS     R4,R0,#+1
   \        0xE   0x41A4             SBCS     R4,R4,R4
   \       0x10   0x0FE4             LSRS     R4,R4,#+31
   \       0x12   0xE000             B.N      ??axis_unhomed_error_1
   \                     ??axis_unhomed_error_0: (+1)
   \       0x14   0x2400             MOVS     R4,#+0
   2126                         yy = y && !axis_homed[Y_AXIS],
   \                     ??axis_unhomed_error_1: (+1)
   \       0x16   0x2900             CMP      R1,#+0
   \       0x18   0xD006             BEQ.N    ??axis_unhomed_error_2
   \       0x1A   0x.... 0x....      LDR.W    R0,??DataTable116_7
   \       0x1E   0x7840             LDRB     R0,[R0, #+1]
   \       0x20   0x1E46             SUBS     R6,R0,#+1
   \       0x22   0x41B6             SBCS     R6,R6,R6
   \       0x24   0x0FF6             LSRS     R6,R6,#+31
   \       0x26   0xE000             B.N      ??axis_unhomed_error_3
   \                     ??axis_unhomed_error_2: (+1)
   \       0x28   0x2600             MOVS     R6,#+0
   2127                         zz = z && !axis_homed[Z_AXIS];
   \                     ??axis_unhomed_error_3: (+1)
   \       0x2A   0x2A00             CMP      R2,#+0
   \       0x2C   0xD006             BEQ.N    ??axis_unhomed_error_4
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable116_7
   \       0x32   0x7880             LDRB     R0,[R0, #+2]
   \       0x34   0x1E45             SUBS     R5,R0,#+1
   \       0x36   0x41AD             SBCS     R5,R5,R5
   \       0x38   0x0FED             LSRS     R5,R5,#+31
   \       0x3A   0xE000             B.N      ??axis_unhomed_error_5
   \                     ??axis_unhomed_error_4: (+1)
   \       0x3C   0x2500             MOVS     R5,#+0
   2128              if (xx || yy || zz) {
   \                     ??axis_unhomed_error_5: (+1)
   \       0x3E   0xEA46 0x0004      ORR      R0,R6,R4
   \       0x42   0x4328             ORRS     R0,R5,R0
   \       0x44   0xD031             BEQ.N    ??axis_unhomed_error_6
   2129                SERIAL_ECHO_START;
   \       0x46   0x.... 0x....      LDR.W    R0,??DataTable116_3
   \       0x4A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2130                SERIAL_ECHOPGM(MSG_HOME " ");
   \       0x4E   0x.... 0x....      ADR.W    R0,?_3
   \       0x52   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2131                if (xx) SERIAL_ECHOPGM(MSG_X);
   \       0x56   0x2C00             CMP      R4,#+0
   \       0x58   0xD002             BEQ.N    ??axis_unhomed_error_7
   \       0x5A   0x....             ADR.N    R0,??DataTable113  ;; "X"
   \       0x5C   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2132                if (yy) SERIAL_ECHOPGM(MSG_Y);
   \                     ??axis_unhomed_error_7: (+1)
   \       0x60   0x2E00             CMP      R6,#+0
   \       0x62   0xD002             BEQ.N    ??axis_unhomed_error_8
   \       0x64   0x....             ADR.N    R0,??DataTable113_1  ;; "Y"
   \       0x66   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2133                if (zz) SERIAL_ECHOPGM(MSG_Z);
   \                     ??axis_unhomed_error_8: (+1)
   \       0x6A   0x2D00             CMP      R5,#+0
   \       0x6C   0xD002             BEQ.N    ??axis_unhomed_error_9
   \       0x6E   0x....             ADR.N    R0,??DataTable113_2  ;; "Z"
   \       0x70   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2134                SERIAL_ECHOLNPGM(" " MSG_FIRST);
   \                     ??axis_unhomed_error_9: (+1)
   \       0x74   0x.... 0x....      ADR.W    R0,?_7
   \       0x78   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2135          
   2136                #if ENABLED(ULTRA_LCD)
   2137                  lcd_status_printf_P(0, PSTR(MSG_HOME " %s%s%s " MSG_FIRST), xx ? MSG_X : "", yy ? MSG_Y : "", zz ? MSG_Z : "");
   \       0x7C   0x2D00             CMP      R5,#+0
   \       0x7E   0xD001             BEQ.N    ??axis_unhomed_error_10
   \       0x80   0x....             ADR.N    R0,??DataTable113_2  ;; "Z"
   \       0x82   0xE000             B.N      ??axis_unhomed_error_11
   \                     ??axis_unhomed_error_10: (+1)
   \       0x84   0x....             ADR.N    R0,??DataTable113_3  ;; ""
   \                     ??axis_unhomed_error_11: (+1)
   \       0x86   0x2E00             CMP      R6,#+0
   \       0x88   0xD001             BEQ.N    ??axis_unhomed_error_12
   \       0x8A   0x....             ADR.N    R3,??DataTable113_1  ;; "Y"
   \       0x8C   0xE000             B.N      ??axis_unhomed_error_13
   \                     ??axis_unhomed_error_12: (+1)
   \       0x8E   0x....             ADR.N    R3,??DataTable113_3  ;; ""
   \                     ??axis_unhomed_error_13: (+1)
   \       0x90   0x2C00             CMP      R4,#+0
   \       0x92   0xD001             BEQ.N    ??axis_unhomed_error_14
   \       0x94   0x....             ADR.N    R2,??DataTable113  ;; "X"
   \       0x96   0xE000             B.N      ??axis_unhomed_error_15
   \                     ??axis_unhomed_error_14: (+1)
   \       0x98   0x....             ADR.N    R2,??DataTable113_3  ;; ""
   \                     ??axis_unhomed_error_15: (+1)
   \       0x9A   0x9000             STR      R0,[SP, #+0]
   \       0x9C   0x.... 0x....      ADR.W    R1,?_8
   \       0xA0   0x2000             MOVS     R0,#+0
   \       0xA2   0x.... 0x....      BL       _Z19lcd_status_printf_PhPKcz
   2138                #endif
   2139                return true;
   \       0xA6   0x2001             MOVS     R0,#+1
   \       0xA8   0xBD76             POP      {R1,R2,R4-R6,PC}
   2140              }
   2141              return false;
   \                     ??axis_unhomed_error_6: (+1)
   \       0xAA   0x2000             MOVS     R0,#+0
   \       0xAC   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   2142            }
   2143          
   2144          #endif
   2145          
   2146          #if ENABLED(Z_PROBE_SLED)
   2147          
   2148            #ifndef SLED_DOCKING_OFFSET
   2149              #define SLED_DOCKING_OFFSET 0
   2150            #endif
   2151          
   2152            /**
   2153             * Method to dock/undock a sled designed by Charles Bell.
   2154             *
   2155             * stow[in]     If false, move to MAX_X and engage the solenoid
   2156             *              If true, move to MAX_X and release the solenoid
   2157             */
   2158            static void dock_sled(bool stow) {
   2159              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2160                if (DEBUGGING(LEVELING)) {
   2161                  SERIAL_ECHOPAIR("dock_sled(", stow);
   2162                  SERIAL_CHAR(')');
   2163                  SERIAL_EOL;
   2164                }
   2165              #endif
   2166          
   2167              // Dock sled a bit closer to ensure proper capturing
   2168              do_blocking_move_to_x(X_MAX_POS + SLED_DOCKING_OFFSET - ((stow) ? 1 : 0));
   2169          
   2170              #if HAS_SOLENOID_1 && DISABLED(EXT_SOLENOID)
   2171                WRITE(SOL1_PIN, !stow); // switch solenoid
   2172              #endif
   2173            }
   2174          
   2175          #elif ENABLED(Z_PROBE_ALLEN_KEY)
   2176          
   2177            void run_deploy_moves_script() {
   2178              #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Z)
   2179                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_X
   2180                  #define Z_PROBE_ALLEN_KEY_DEPLOY_1_X current_position[X_AXIS]
   2181                #endif
   2182                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_Y
   2183                  #define Z_PROBE_ALLEN_KEY_DEPLOY_1_Y current_position[Y_AXIS]
   2184                #endif
   2185                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_Z
   2186                  #define Z_PROBE_ALLEN_KEY_DEPLOY_1_Z current_position[Z_AXIS]
   2187                #endif
   2188                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE
   2189                  #define Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE 0.0
   2190                #endif
   2191                do_blocking_move_to(Z_PROBE_ALLEN_KEY_DEPLOY_1_X, Z_PROBE_ALLEN_KEY_DEPLOY_1_Y, Z_PROBE_ALLEN_KEY_DEPLOY_1_Z, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE));
   2192              #endif
   2193              #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_Z)
   2194                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_X
   2195                  #define Z_PROBE_ALLEN_KEY_DEPLOY_2_X current_position[X_AXIS]
   2196                #endif
   2197                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_Y
   2198                  #define Z_PROBE_ALLEN_KEY_DEPLOY_2_Y current_position[Y_AXIS]
   2199                #endif
   2200                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_Z
   2201                  #define Z_PROBE_ALLEN_KEY_DEPLOY_2_Z current_position[Z_AXIS]
   2202                #endif
   2203                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE
   2204                  #define Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE 0.0
   2205                #endif
   2206                do_blocking_move_to(Z_PROBE_ALLEN_KEY_DEPLOY_2_X, Z_PROBE_ALLEN_KEY_DEPLOY_2_Y, Z_PROBE_ALLEN_KEY_DEPLOY_2_Z, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE));
   2207              #endif
   2208              #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_Z)
   2209                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_X
   2210                  #define Z_PROBE_ALLEN_KEY_DEPLOY_3_X current_position[X_AXIS]
   2211                #endif
   2212                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_Y
   2213                  #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Y current_position[Y_AXIS]
   2214                #endif
   2215                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_Z
   2216                  #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Z current_position[Z_AXIS]
   2217                #endif
   2218                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE
   2219                  #define Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE 0.0
   2220                #endif
   2221                do_blocking_move_to(Z_PROBE_ALLEN_KEY_DEPLOY_3_X, Z_PROBE_ALLEN_KEY_DEPLOY_3_Y, Z_PROBE_ALLEN_KEY_DEPLOY_3_Z, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE));
   2222              #endif
   2223              #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_Z)
   2224                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_X
   2225                  #define Z_PROBE_ALLEN_KEY_DEPLOY_4_X current_position[X_AXIS]
   2226                #endif
   2227                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_Y
   2228                  #define Z_PROBE_ALLEN_KEY_DEPLOY_4_Y current_position[Y_AXIS]
   2229                #endif
   2230                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_Z
   2231                  #define Z_PROBE_ALLEN_KEY_DEPLOY_4_Z current_position[Z_AXIS]
   2232                #endif
   2233                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE
   2234                  #define Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE 0.0
   2235                #endif
   2236                do_blocking_move_to(Z_PROBE_ALLEN_KEY_DEPLOY_4_X, Z_PROBE_ALLEN_KEY_DEPLOY_4_Y, Z_PROBE_ALLEN_KEY_DEPLOY_4_Z, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE));
   2237              #endif
   2238              #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_Z)
   2239                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_X
   2240                  #define Z_PROBE_ALLEN_KEY_DEPLOY_5_X current_position[X_AXIS]
   2241                #endif
   2242                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_Y
   2243                  #define Z_PROBE_ALLEN_KEY_DEPLOY_5_Y current_position[Y_AXIS]
   2244                #endif
   2245                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_Z
   2246                  #define Z_PROBE_ALLEN_KEY_DEPLOY_5_Z current_position[Z_AXIS]
   2247                #endif
   2248                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE
   2249                  #define Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE 0.0
   2250                #endif
   2251                do_blocking_move_to(Z_PROBE_ALLEN_KEY_DEPLOY_5_X, Z_PROBE_ALLEN_KEY_DEPLOY_5_Y, Z_PROBE_ALLEN_KEY_DEPLOY_5_Z, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE));
   2252              #endif
   2253            }
   2254          
   2255            void run_stow_moves_script() {
   2256              #if defined(Z_PROBE_ALLEN_KEY_STOW_1_X) || defined(Z_PROBE_ALLEN_KEY_STOW_1_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_1_Z)
   2257                #ifndef Z_PROBE_ALLEN_KEY_STOW_1_X
   2258                  #define Z_PROBE_ALLEN_KEY_STOW_1_X current_position[X_AXIS]
   2259                #endif
   2260                #ifndef Z_PROBE_ALLEN_KEY_STOW_1_Y
   2261                  #define Z_PROBE_ALLEN_KEY_STOW_1_Y current_position[Y_AXIS]
   2262                #endif
   2263                #ifndef Z_PROBE_ALLEN_KEY_STOW_1_Z
   2264                  #define Z_PROBE_ALLEN_KEY_STOW_1_Z current_position[Z_AXIS]
   2265                #endif
   2266                #ifndef Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE
   2267                  #define Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE 0.0
   2268                #endif
   2269                do_blocking_move_to(Z_PROBE_ALLEN_KEY_STOW_1_X, Z_PROBE_ALLEN_KEY_STOW_1_Y, Z_PROBE_ALLEN_KEY_STOW_1_Z, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE));
   2270              #endif
   2271              #if defined(Z_PROBE_ALLEN_KEY_STOW_2_X) || defined(Z_PROBE_ALLEN_KEY_STOW_2_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_2_Z)
   2272                #ifndef Z_PROBE_ALLEN_KEY_STOW_2_X
   2273                  #define Z_PROBE_ALLEN_KEY_STOW_2_X current_position[X_AXIS]
   2274                #endif
   2275                #ifndef Z_PROBE_ALLEN_KEY_STOW_2_Y
   2276                  #define Z_PROBE_ALLEN_KEY_STOW_2_Y current_position[Y_AXIS]
   2277                #endif
   2278                #ifndef Z_PROBE_ALLEN_KEY_STOW_2_Z
   2279                  #define Z_PROBE_ALLEN_KEY_STOW_2_Z current_position[Z_AXIS]
   2280                #endif
   2281                #ifndef Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE
   2282                  #define Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE 0.0
   2283                #endif
   2284                do_blocking_move_to(Z_PROBE_ALLEN_KEY_STOW_2_X, Z_PROBE_ALLEN_KEY_STOW_2_Y, Z_PROBE_ALLEN_KEY_STOW_2_Z, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE));
   2285              #endif
   2286              #if defined(Z_PROBE_ALLEN_KEY_STOW_3_X) || defined(Z_PROBE_ALLEN_KEY_STOW_3_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_3_Z)
   2287                #ifndef Z_PROBE_ALLEN_KEY_STOW_3_X
   2288                  #define Z_PROBE_ALLEN_KEY_STOW_3_X current_position[X_AXIS]
   2289                #endif
   2290                #ifndef Z_PROBE_ALLEN_KEY_STOW_3_Y
   2291                  #define Z_PROBE_ALLEN_KEY_STOW_3_Y current_position[Y_AXIS]
   2292                #endif
   2293                #ifndef Z_PROBE_ALLEN_KEY_STOW_3_Z
   2294                  #define Z_PROBE_ALLEN_KEY_STOW_3_Z current_position[Z_AXIS]
   2295                #endif
   2296                #ifndef Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE
   2297                  #define Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE 0.0
   2298                #endif
   2299                do_blocking_move_to(Z_PROBE_ALLEN_KEY_STOW_3_X, Z_PROBE_ALLEN_KEY_STOW_3_Y, Z_PROBE_ALLEN_KEY_STOW_3_Z, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE));
   2300              #endif
   2301              #if defined(Z_PROBE_ALLEN_KEY_STOW_4_X) || defined(Z_PROBE_ALLEN_KEY_STOW_4_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_4_Z)
   2302                #ifndef Z_PROBE_ALLEN_KEY_STOW_4_X
   2303                  #define Z_PROBE_ALLEN_KEY_STOW_4_X current_position[X_AXIS]
   2304                #endif
   2305                #ifndef Z_PROBE_ALLEN_KEY_STOW_4_Y
   2306                  #define Z_PROBE_ALLEN_KEY_STOW_4_Y current_position[Y_AXIS]
   2307                #endif
   2308                #ifndef Z_PROBE_ALLEN_KEY_STOW_4_Z
   2309                  #define Z_PROBE_ALLEN_KEY_STOW_4_Z current_position[Z_AXIS]
   2310                #endif
   2311                #ifndef Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE
   2312                  #define Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE 0.0
   2313                #endif
   2314                do_blocking_move_to(Z_PROBE_ALLEN_KEY_STOW_4_X, Z_PROBE_ALLEN_KEY_STOW_4_Y, Z_PROBE_ALLEN_KEY_STOW_4_Z, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE));
   2315              #endif
   2316              #if defined(Z_PROBE_ALLEN_KEY_STOW_5_X) || defined(Z_PROBE_ALLEN_KEY_STOW_5_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_5_Z)
   2317                #ifndef Z_PROBE_ALLEN_KEY_STOW_5_X
   2318                  #define Z_PROBE_ALLEN_KEY_STOW_5_X current_position[X_AXIS]
   2319                #endif
   2320                #ifndef Z_PROBE_ALLEN_KEY_STOW_5_Y
   2321                  #define Z_PROBE_ALLEN_KEY_STOW_5_Y current_position[Y_AXIS]
   2322                #endif
   2323                #ifndef Z_PROBE_ALLEN_KEY_STOW_5_Z
   2324                  #define Z_PROBE_ALLEN_KEY_STOW_5_Z current_position[Z_AXIS]
   2325                #endif
   2326                #ifndef Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE
   2327                  #define Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE 0.0
   2328                #endif
   2329                do_blocking_move_to(Z_PROBE_ALLEN_KEY_STOW_5_X, Z_PROBE_ALLEN_KEY_STOW_5_Y, Z_PROBE_ALLEN_KEY_STOW_5_Z, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE));
   2330              #endif
   2331            }
   2332          
   2333          #endif
   2334          #if ENABLED(PROBING_FANS_OFF)
   2335            void fans_pause(bool p) {
   2336              if (p && fans_paused) { // If called out of order something is wrong
   2337                SERIAL_ERROR_START;
   2338                SERIAL_ERRORLNPGM("Fans already paused!");
   2339                return;
   2340              }
   2341          
   2342              if (!p && !fans_paused) {
   2343                SERIAL_ERROR_START;
   2344                SERIAL_ERRORLNPGM("Fans already unpaused!");
   2345                return;
   2346              }
   2347          
   2348              if (p) {
   2349                for (uint8_t x = 0;x < FAN_COUNT;x++) {
   2350                  paused_fanSpeeds[x] = fanSpeeds[x];
   2351                  fanSpeeds[x] = 0;
   2352                }
   2353              }
   2354              else {
   2355                for (uint8_t x = 0;x < FAN_COUNT;x++)
   2356                  fanSpeeds[x] = paused_fanSpeeds[x];
   2357              }
   2358          
   2359              fans_paused = p;
   2360            }
   2361          #endif
   2362          
   2363          #if HAS_BED_PROBE
   2364          
   2365            // TRIGGERED_WHEN_STOWED_TEST can easily be extended to servo probes, ... if needed.
   2366            #if ENABLED(PROBE_IS_TRIGGERED_WHEN_STOWED_TEST)
   2367          //    #if ENABLED(Z_MIN_PROBE_ENDSTOP)
   2368          	#if 1	//mks
   2369                #define _TRIGGERED_WHEN_STOWED_TEST (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)
   2370              #else
   2371                #define _TRIGGERED_WHEN_STOWED_TEST (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)
   2372              #endif
   2373            #endif
   2374          
   2375          #if QUIET_PROBING
   2376              void probing_pause(bool pause) {
   2377          	#if ENABLED(PROBING_HEATERS_OFF)
   2378                  thermalManager.pause(pause);
   2379          	#endif
   2380          
   2381          	#if ENABLED(PROBING_FANS_OFF)
   2382                  fans_pause(pause);
   2383          	#endif
   2384          
   2385                if(pause) safe_delay(25);
   2386              }
   2387          #endif
   2388          
   2389          #if ENABLED(BLTOUCH)
   2390          
   2391              void bltouch_command(int angle) {
   2392                servo[Z_ENDSTOP_SERVO_NR].move(angle);  // Give the BL-Touch the command and wait
   2393                safe_delay(BLTOUCH_DELAY);
   2394              }
   2395          
   2396              void set_bltouch_deployed(const bool deploy) {
   2397          
   2398          	if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
   2399          		{
   2400          		if (deploy && (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)) 
   2401          		  { 	 // If BL-Touch says it's triggered
   2402          		  bltouch_command(BLTOUCH_RESET);	 //  try to reset it.
   2403          		  bltouch_command(BLTOUCH_DEPLOY);	 // Also needs to deploy and stow to
   2404          		  bltouch_command(BLTOUCH_STOW);	 //  clear the triggered condition.
   2405          		  safe_delay(1500); 				 // Wait for internal self-test to complete.
   2406          											 //  (Measured completion time was 0.65 seconds
   2407          											 //   after reset, deploy, and stow sequence)
   2408          		  if ((READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)) { 			 // If it still claims to be triggered...
   2409          			SERIAL_ERROR_START;
   2410          			SERIAL_ERRORLNPGM(MSG_STOP_BLTOUCH);
   2411          			stop(); 						 // punt!
   2412          		  	}
   2413          			}
   2414          		
   2415          		}
   2416          	else if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN
   2417          		{
   2418          		if (deploy && (READ(Z_MAX_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)) 
   2419          		  { 	 // If BL-Touch says it's triggered
   2420          		  bltouch_command(BLTOUCH_RESET);	 //  try to reset it.
   2421          		  bltouch_command(BLTOUCH_DEPLOY);	 // Also needs to deploy and stow to
   2422          		  bltouch_command(BLTOUCH_STOW);	 //  clear the triggered condition.
   2423          		  safe_delay(1500); 				 // Wait for internal self-test to complete.
   2424          											 //  (Measured completion time was 0.65 seconds
   2425          											 //   after reset, deploy, and stow sequence)
   2426          		  if ((READ(Z_MAX_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)) { 			 // If it still claims to be triggered...
   2427          			SERIAL_ERROR_START;
   2428          			SERIAL_ERRORLNPGM(MSG_STOP_BLTOUCH);
   2429          			stop(); 						 // punt!
   2430          		  }
   2431          		}
   2432          		
   2433          		}
   2434          
   2435                bltouch_command(deploy ? BLTOUCH_DEPLOY : BLTOUCH_STOW);
   2436          
   2437                #if ENABLED(DEBUG_LEVELING_FEATURE)
   2438                  if (DEBUGGING(LEVELING)) {
   2439                    SERIAL_ECHOPAIR("set_bltouch_deployed(", deploy);
   2440                    SERIAL_CHAR(')');
   2441                    SERIAL_EOL;
   2442                  }
   2443                #endif
   2444              }
   2445          
   2446            #endif // BLTOUCH
   2447          
   2448            // returns false for ok and true for failure

   \                                 In section .text, align 2, keep-with-next
   2449            bool set_probe_deployed(bool deploy) {
   \                     _Z18set_probe_deployedb: (+1)
   \        0x0   0xB51F             PUSH     {R0-R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   2450          
   2451              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2452                if (DEBUGGING(LEVELING)) {
   2453                  DEBUG_POS("set_probe_deployed", current_position);
   2454                  SERIAL_ECHOLNPAIR("deploy: ", deploy);
   2455                }
   2456              #endif
   2457          
   2458              if (endstops.z_probe_enabled == deploy) return false;
   \        0x4   0x.... 0x....      LDR.W    R0,??DataTable123_1
   \        0x8   0x7800             LDRB     R0,[R0, #+0]
   \        0xA   0x4621             MOV      R1,R4
   \        0xC   0x4288             CMP      R0,R1
   \        0xE   0xD101             BNE.N    ??set_probe_deployed_0
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0xE01B             B.N      ??set_probe_deployed_1
   2459          
   2460              // Make room for probe
   2461              //do_probe_raise(_Z_CLEARANCE_DEPLOY_PROBE);	//mks
   2462              do_probe_raise(Z_CLEARANCE_DEPLOY_PROBE>Z_CLEARANCE_BETWEEN_PROBES ? Z_CLEARANCE_DEPLOY_PROBE : Z_CLEARANCE_BETWEEN_PROBES);
   \                     ??set_probe_deployed_0: (+1)
   \       0x14   0x....             LDR.N    R0,??DataTable113_4
   \       0x16   0x6E41             LDR      R1,[R0, #+100]
   \       0x18   0x6E80             LDR      R0,[R0, #+104]
   \       0x1A   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x1E   0xD300             BCC.N    ??set_probe_deployed_2
   \       0x20   0x4601             MOV      R1,R0
   \                     ??set_probe_deployed_2: (+1)
   \       0x22   0x4608             MOV      R0,R1
   \       0x24   0x.... 0x....      BL       _Z14do_probe_raisef
   2463          
   2464              // When deploying make sure BLTOUCH is not already triggered
   2465              #if ENABLED(BLTOUCH)
   2466          
   2467          	if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
   2468          		{
   2469          		if (deploy && (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)) 
   2470          		  { 	 // If BL-Touch says it's triggered
   2471          		  bltouch_command(BLTOUCH_RESET);	 // try to reset it.
   2472          		  bltouch_command(BLTOUCH_DEPLOY);	 // Also needs to deploy and stow to
   2473          		  bltouch_command(BLTOUCH_STOW);	 // clear the triggered condition.
   2474          		  safe_delay(1500); 				 // wait for internal self test to complete
   2475          											 //   measured completion time was 0.65 seconds
   2476          											 //   after reset, deploy & stow sequence
   2477          		  if ((READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)) { 			 // If it still claims to be triggered...
   2478          			SERIAL_ERROR_START;
   2479          			SERIAL_ERRORLNPGM(MSG_STOP_BLTOUCH);
   2480          			stop(); 						 // punt!
   2481          			return true;
   2482          		  }
   2483          		}
   2484          
   2485          		}
   2486          	else if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN
   2487          		{
   2488          		if (deploy && (READ(Z_MAX_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)) 
   2489          		  { 	 // If BL-Touch says it's triggered
   2490          		  bltouch_command(BLTOUCH_RESET);	 // try to reset it.
   2491          		  bltouch_command(BLTOUCH_DEPLOY);	 // Also needs to deploy and stow to
   2492          		  bltouch_command(BLTOUCH_STOW);	 // clear the triggered condition.
   2493          		  safe_delay(1500); 				 // wait for internal self test to complete
   2494          											 //   measured completion time was 0.65 seconds
   2495          											 //   after reset, deploy & stow sequence
   2496          		  if ((READ(Z_MAX_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)) { 			 // If it still claims to be triggered...
   2497          			SERIAL_ERROR_START;
   2498          			SERIAL_ERRORLNPGM(MSG_STOP_BLTOUCH);
   2499          			stop(); 						 // punt!
   2500          			return true;
   2501          		  }
   2502          		}
   2503          		
   2504          		}
   2505          
   2506          	  
   2507              #elif ENABLED(Z_PROBE_SLED)
   2508                if (axis_unhomed_error(true, false, false)) {
   2509                  SERIAL_ERROR_START;
   2510                  SERIAL_ERRORLNPGM(MSG_STOP_UNHOMED);
   2511                  stop();
   2512                  return true;
   2513                }
   2514              #elif ENABLED(Z_PROBE_ALLEN_KEY)
   2515                if (axis_unhomed_error(true, true,  true )) {
   2516                  SERIAL_ERROR_START;
   2517                  SERIAL_ERRORLNPGM(MSG_STOP_UNHOMED);
   2518                  stop();
   2519                  return true;
   2520                }
   2521              #endif
   2522          
   2523              const float oldXpos = current_position[X_AXIS],
   \       0x28   0x....             LDR.N    R0,??DataTable112_3
   \       0x2A   0x6881             LDR      R1,[R0, #+8]
   \       0x2C   0x9102             STR      R1,[SP, #+8]
   2524                          oldYpos = current_position[Y_AXIS];
   \       0x2E   0x68C1             LDR      R1,[R0, #+12]
   \       0x30   0x9101             STR      R1,[SP, #+4]
   2525          
   2526              #ifdef _TRIGGERED_WHEN_STOWED_TEST
   2527          
   2528                // If endstop is already false, the Z probe is deployed
   2529                bool _triggered_bool =false;
   2530          	if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
   2531          		_triggered_bool = (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING);
   2532          	else if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)
   2533          		_triggered_bool = (READ(Z_MAX_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING);
   2534          	
   2535                //if (_TRIGGERED_WHEN_STOWED_TEST == deploy) 
   2536          	if (_triggered_bool == deploy) 
   2537          	  {     // closed after the probe specific actions.
   2538                                                                 // Would a goto be less ugly?
   2539                  //while (!_TRIGGERED_WHEN_STOWED_TEST) idle(); // would offer the opportunity
   2540                                                                 // for a triggered when stowed manual probe.
   2541          
   2542                  if (!deploy) endstops.enable_z_probe(false); // Switch off triggered when stowed probes early
   2543                                                               // otherwise an Allen-Key probe can't be stowed.
   2544              #endif
   2545          
   2546                  #if ENABLED(SOLENOID_PROBE)
   2547          
   2548                    #if HAS_SOLENOID_1
   2549                      WRITE(SOL1_PIN, deploy);
   2550                    #endif
   2551          
   2552                  #elif ENABLED(Z_PROBE_SLED)
   2553          
   2554                    dock_sled(!deploy);
   2555          
   2556                  #elif HAS_Z_SERVO_ENDSTOP && DISABLED(BLTOUCH)
   2557          
   2558                    servo[Z_ENDSTOP_SERVO_NR].move(z_servo_angle[deploy ? 0 : 1]);
   2559          
   2560                  #elif ENABLED(Z_PROBE_ALLEN_KEY)
   2561          
   2562                    deploy ? run_deploy_moves_script() : run_stow_moves_script();
   2563          
   2564                  #endif
   2565          
   2566              #ifdef _TRIGGERED_WHEN_STOWED_TEST
   2567                } // _TRIGGERED_WHEN_STOWED_TEST == deploy
   2568          
   2569          
   2570          		//bool _triggered_bool =false;
   2571          	  if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
   2572          		  _triggered_bool = (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING);
   2573          	  else if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)
   2574          		  _triggered_bool = (READ(Z_MAX_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING);
   2575          
   2576          //      if (_TRIGGERED_WHEN_STOWED_TEST == deploy) { // State hasn't changed?
   2577          	  if (_triggered_bool == deploy) { // State hasn't changed?
   2578          
   2579                  if (IsRunning()) {
   2580                    SERIAL_ERROR_START;
   2581                    SERIAL_ERRORLNPGM("Z-Probe failed");
   2582                    LCD_ALERTMESSAGEPGM("Err: ZPROBE");
   2583                  }
   2584                  stop();
   2585                  return true;
   2586          
   2587                } // _TRIGGERED_WHEN_STOWED_TEST == deploy
   2588          
   2589              #endif
   2590          
   2591              do_blocking_move_to(oldXpos, oldYpos, current_position[Z_AXIS]); // return to position before deploy
   \       0x32   0x2100             MOVS     R1,#+0
   \       0x34   0x9100             STR      R1,[SP, #+0]
   \       0x36   0x466B             MOV      R3,SP
   \       0x38   0xF100 0x0210      ADD      R2,R0,#+16
   \       0x3C   0xA901             ADD      R1,SP,#+4
   \       0x3E   0xA802             ADD      R0,SP,#+8
   \       0x40   0x.... 0x....      BL       _Z19do_blocking_move_toRKfS0_S0_S0_
   2592              endstops.enable_z_probe(deploy);
   \       0x44   0x4620             MOV      R0,R4
   \       0x46   0x.... 0x....      BL       _ZN8Endstops14enable_z_probeEb
   2593              return false;
   \       0x4A   0x2000             MOVS     R0,#+0
   \                     ??set_probe_deployed_1: (+1)
   \       0x4C   0xB004             ADD      SP,SP,#+16
   \       0x4E   0xBD10             POP      {R4,PC}          ;; return
   2594            }
   2595          

   \                                 In section .text, align 2, keep-with-next
   2596            static void do_probe_move(float z, float fr_mm_m) {
   \                     _ZN37_INTERNAL_15_Marlin_main_cpp_3178531913do_probe_moveEff: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x460C             MOV      R4,R1
   2597              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2598                if (DEBUGGING(LEVELING)) DEBUG_POS(">>> do_probe_move", current_position);
   2599              #endif
   2600          
   2601              // Deploy BLTouch at the start of any probe
   2602              #if ENABLED(BLTOUCH)
   2603                set_bltouch_deployed(true);
   2604              #endif
   2605          
   2606          #if QUIET_PROBING
   2607                probing_pause(true);
   2608          #endif
   2609          
   2610              // Move down until probe triggered
   2611              do_blocking_move_to_z(LOGICAL_Z_POSITION(z), MMM_TO_MMS(fr_mm_m));
   \        0x4   0x....             LDR.N    R1,??DataTable112_3
   \        0x6   0x6CC9             LDR      R1,[R1, #+76]
   \        0x8   0x.... 0x....      BL       __aeabi_fadd
   \        0xC   0x9001             STR      R0,[SP, #+4]
   \        0xE   0x4620             MOV      R0,R4
   \       0x10   0x....             LDR.N    R1,??DataTable113_5  ;; 0x42700000
   \       0x12   0x.... 0x....      BL       __aeabi_fdiv
   \       0x16   0x9000             STR      R0,[SP, #+0]
   \       0x18   0x4669             MOV      R1,SP
   \       0x1A   0xA801             ADD      R0,SP,#+4
   \       0x1C   0x.... 0x....      BL       _Z21do_blocking_move_to_zRKfS0_
   2612          
   2613          #if QUIET_PROBING
   2614                probing_pause(false);
   2615          #endif
   2616          
   2617              // Retract BLTouch immediately after a probe
   2618              #if ENABLED(BLTOUCH)
   2619                set_bltouch_deployed(false);
   2620              #endif
   2621          
   2622              // Clear endstop flags
   2623              endstops.hit_on_purpose();
   \       0x20   0x.... 0x....      BL       _ZN8Endstops14hit_on_purposeEv
   2624          
   2625              // Get Z where the steppers were interrupted
   2626              set_current_from_steppers_for_axis(Z_AXIS);
   \       0x24   0x2002             MOVS     R0,#+2
   \       0x26   0x.... 0x....      BL       _Z34set_current_from_steppers_for_axis8AxisEnum
   2627          
   2628              // Tell the planner where we actually are
   2629              SYNC_PLAN_POSITION_KINEMATIC();
   \       0x2A   0x.... 0x....      BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
   2630          
   2631              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2632                if (DEBUGGING(LEVELING)) DEBUG_POS("<<< do_probe_move", current_position);
   2633              #endif
   2634            }
   \       0x2E   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   2635          
   2636            // Do a single Z probe and return with current_position[Z_AXIS]
   2637            // at the height where the probe triggered.

   \                                 In section .text, align 2, keep-with-next
   2638            static float run_z_probe() {
   \                     _ZN37_INTERNAL_15_Marlin_main_cpp_3178531911run_z_probeEv: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   2639          
   2640              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2641                if (DEBUGGING(LEVELING)) DEBUG_POS(">>> run_z_probe", current_position);
   2642              #endif
   2643          
   2644              // Prevent stepper_inactive_time from running out and EXTRUDER_RUNOUT_PREVENT from extruding
   2645              refresh_cmd_timeout();
   \        0x2   0x.... 0x....      BL       _Z19refresh_cmd_timeoutv
   2646          
   2647              #if ENABLED(PROBE_DOUBLE_TOUCH)
   2648          
   2649                // Do a first probe at the fast speed
   2650                do_probe_move(-(Z_MAX_LENGTH) - 10, Z_PROBE_SPEED_FAST);
   2651          
   2652                #if ENABLED(DEBUG_LEVELING_FEATURE)
   2653                  float first_probe_z = current_position[Z_AXIS];
   2654                  if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("1st Probe Z:", first_probe_z);
   2655                #endif
   2656          
   2657                // move up by the bump distance
   2658                do_blocking_move_to_z(current_position[Z_AXIS] + home_bump_mm(Z_AXIS), MMM_TO_MMS(Z_PROBE_SPEED_FAST));
   2659          
   2660              #else
   2661          
   2662                // If the nozzle is above the travel height then
   2663                // move down quickly before doing the slow probe
   2664                float z = LOGICAL_Z_POSITION(Z_CLEARANCE_BETWEEN_PROBES);
   \        0x6   0x....             LDR.N    R4,??DataTable112_3
   \        0x8   0x....             LDR.N    R5,??DataTable113_4
   \        0xA   0x6EA9             LDR      R1,[R5, #+104]
   \        0xC   0x6CE0             LDR      R0,[R4, #+76]
   \        0xE   0x.... 0x....      BL       __aeabi_fadd
   \       0x12   0x9000             STR      R0,[SP, #+0]
   2665                if (zprobe_zoffset < 0) z -= zprobe_zoffset;
   \       0x14   0x.... 0x....      LDR.W    R6,??DataTable116_7
   \       0x18   0x6CB2             LDR      R2,[R6, #+72]
   \       0x1A   0x4610             MOV      R0,R2
   \       0x1C   0x2100             MOVS     R1,#+0
   \       0x1E   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x22   0xD204             BCS.N    ??run_z_probe_0
   \       0x24   0x9800             LDR      R0,[SP, #+0]
   \       0x26   0x4611             MOV      R1,R2
   \       0x28   0x.... 0x....      BL       __aeabi_fsub
   \       0x2C   0x9000             STR      R0,[SP, #+0]
   2666               // #if ENABLED(DELTA)
   2667               if(MACHINETPYE == DELTA)
   \                     ??run_z_probe_0: (+1)
   \       0x2E   0xF9B5 0x0058      LDRSH    R0,[R5, #+88]
   \       0x32   0x2802             CMP      R0,#+2
   \       0x34   0xD104             BNE.N    ??run_z_probe_1
   2668                  z -= home_offset[Z_AXIS];
   \       0x36   0x9800             LDR      R0,[SP, #+0]
   \       0x38   0x6C21             LDR      R1,[R4, #+64]
   \       0x3A   0x.... 0x....      BL       __aeabi_fsub
   \       0x3E   0x9000             STR      R0,[SP, #+0]
   2669                //#endif
   2670                if (z < current_position[Z_AXIS])
   \                     ??run_z_probe_1: (+1)
   \       0x40   0x9800             LDR      R0,[SP, #+0]
   \       0x42   0x6921             LDR      R1,[R4, #+16]
   \       0x44   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x48   0xD208             BCS.N    ??run_z_probe_2
   2671                  do_blocking_move_to_z(z, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
   \       0x4A   0x6FA8             LDR      R0,[R5, #+120]
   \       0x4C   0x....             LDR.N    R1,??DataTable113_5  ;; 0x42700000
   \       0x4E   0x.... 0x....      BL       __aeabi_fdiv
   \       0x52   0x9001             STR      R0,[SP, #+4]
   \       0x54   0xA901             ADD      R1,SP,#+4
   \       0x56   0x4668             MOV      R0,SP
   \       0x58   0x.... 0x....      BL       _Z21do_blocking_move_to_zRKfS0_
   2672          
   2673              #endif
   2674          
   2675              // move down slowly to find bed
   2676              do_probe_move(-(Z_MAX_LENGTH) - 10, Z_PROBE_SPEED_SLOW);
   \                     ??run_z_probe_2: (+1)
   \       0x5C   0x6FE9             LDR      R1,[R5, #+124]
   \       0x5E   0x460F             MOV      R7,R1
   \       0x60   0x6928             LDR      R0,[R5, #+16]
   \       0x62   0x69E9             LDR      R1,[R5, #+28]
   \       0x64   0x.... 0x....      BL       __aeabi_fsub
   \       0x68   0x.... 0x....      LDR.W    R1,??DataTable126  ;; 0xc1200000
   \       0x6C   0x.... 0x....      BL       __aeabi_fadd
   \       0x70   0x4639             MOV      R1,R7
   \       0x72   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531913do_probe_moveEff
   2677          
   2678              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2679                if (DEBUGGING(LEVELING)) DEBUG_POS("<<< run_z_probe", current_position);
   2680              #endif
   2681          
   2682              // Debug: compare probe heights
   2683              #if ENABLED(PROBE_DOUBLE_TOUCH) && ENABLED(DEBUG_LEVELING_FEATURE)
   2684                if (DEBUGGING(LEVELING)) {
   2685                  SERIAL_ECHOPAIR("2nd Probe Z:", current_position[Z_AXIS]);
   2686                  SERIAL_ECHOLNPAIR(" Discrepancy:", first_probe_z - current_position[Z_AXIS]);
   2687                }
   2688              #endif
   2689              return current_position[Z_AXIS] + zprobe_zoffset;
   \       0x76   0x6921             LDR      R1,[R4, #+16]
   \       0x78   0x6CB0             LDR      R0,[R6, #+72]
   \       0x7A   0x.... 0x....      BL       __aeabi_fadd
   \       0x7E   0xBDFE             POP      {R1-R7,PC}       ;; return
   2690            }
   2691          
   2692            /**
   2693             * - Move to the given XY
   2694             * - Deploy the probe, if not already deployed
   2695             * - Probe the bed, get the Z position
   2696             * - Depending on the 'stow' flag
   2697             *   - Stow the probe, or
   2698             *   - Raise to the BETWEEN height
   2699             * - Return the probed Z position
   2700             */

   \                                 In section .text, align 2, keep-with-next
   2701            float probe_pt(const float x, const float y, const bool stow/*=true*/, const int verbose_level/*=1*/) {
   \                     _Z8probe_ptffbi: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x4682             MOV      R10,R0
   \        0x6   0x460F             MOV      R7,R1
   \        0x8   0x4693             MOV      R11,R2
   \        0xA   0x4698             MOV      R8,R3
   2702              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2703                if (DEBUGGING(LEVELING)) {
   2704                  SERIAL_ECHOPAIR(">>> probe_pt(", x);
   2705                  SERIAL_ECHOPAIR(", ", y);
   2706                  SERIAL_ECHOPAIR(", ", stow ? "" : "no ");
   2707                  SERIAL_ECHOLNPGM("stow)");
   2708                  DEBUG_POS("", current_position);
   2709                }
   2710              #endif
   2711          
   2712              const float old_feedrate_mm_s = feedrate_mm_s;
   \        0xC   0x.... 0x....      LDR.W    R4,??DataTable126_1
   \       0x10   0x6F65             LDR      R5,[R4, #+116]
   2713          
   2714          //    #if ENABLED(DELTA)
   2715          	if(MACHINETPYE == DELTA)	{
   \       0x12   0x.... 0x....      LDR.W    R9,??DataTable113_4
   \       0x16   0xF9B9 0x0058      LDRSH    R0,[R9, #+88]
   \       0x1A   0x2802             CMP      R0,#+2
   \       0x1C   0xD10C             BNE.N    ??probe_pt_0
   2716                if (current_position[Z_AXIS] > delta_clip_start_height)
   \       0x1E   0xF8D4 0x0080      LDR      R0,[R4, #+128]
   \       0x22   0x6921             LDR      R1,[R4, #+16]
   \       0x24   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x28   0xD206             BCS.N    ??probe_pt_0
   2717                  do_blocking_move_to_z(delta_clip_start_height);
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x9000             STR      R0,[SP, #+0]
   \       0x2E   0x4669             MOV      R1,SP
   \       0x30   0xF104 0x0080      ADD      R0,R4,#+128
   \       0x34   0x.... 0x....      BL       _Z21do_blocking_move_to_zRKfS0_
   2718              }	//#endif
   2719          
   2720              // Ensure a minimum height before moving the probe
   2721              do_probe_raise(Z_CLEARANCE_BETWEEN_PROBES);
   \                     ??probe_pt_0: (+1)
   \       0x38   0xF8D9 0x0068      LDR      R0,[R9, #+104]
   \       0x3C   0x.... 0x....      BL       _Z14do_probe_raisef
   2722          
   2723              feedrate_mm_s = XY_PROBE_FEEDRATE_MM_S;
   \       0x40   0x6FE0             LDR      R0,[R4, #+124]
   \       0x42   0x6760             STR      R0,[R4, #+116]
   2724          
   2725              // Move the probe to the given XY
   2726              do_blocking_move_to_xy(x - (X_PROBE_OFFSET_FROM_EXTRUDER), y - (Y_PROBE_OFFSET_FROM_EXTRUDER));
   \       0x44   0x4650             MOV      R0,R10
   \       0x46   0xF8D9 0x106C      LDR      R1,[R9, #+108]
   \       0x4A   0x.... 0x....      BL       __aeabi_fsub
   \       0x4E   0x9002             STR      R0,[SP, #+8]
   \       0x50   0x4638             MOV      R0,R7
   \       0x52   0xF8D9 0x1070      LDR      R1,[R9, #+112]
   \       0x56   0x.... 0x....      BL       __aeabi_fsub
   \       0x5A   0x9001             STR      R0,[SP, #+4]
   \       0x5C   0x2000             MOVS     R0,#+0
   \       0x5E   0x9000             STR      R0,[SP, #+0]
   \       0x60   0x466A             MOV      R2,SP
   \       0x62   0xA901             ADD      R1,SP,#+4
   \       0x64   0xA802             ADD      R0,SP,#+8
   \       0x66   0x.... 0x....      BL       _Z22do_blocking_move_to_xyRKfS0_S0_
   2727          
   2728              if (DEPLOY_PROBE()) return NAN;
   \       0x6A   0x2001             MOVS     R0,#+1
   \       0x6C   0x.... 0x....      BL       _Z18set_probe_deployedb
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xD123             BNE.N    ??probe_pt_1
   2729          
   2730              const float measured_z = run_z_probe();
   \       0x74   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531911run_z_probeEv
   \       0x78   0x4606             MOV      R6,R0
   2731          
   2732              if (!stow)
   \       0x7A   0xF1BB 0x0F00      CMP      R11,#+0
   \       0x7E   0xD118             BNE.N    ??probe_pt_2
   2733                do_probe_raise(Z_CLEARANCE_BETWEEN_PROBES);
   \       0x80   0xF8D9 0x0068      LDR      R0,[R9, #+104]
   \       0x84   0x.... 0x....      BL       _Z14do_probe_raisef
   2734              else
   2735                if (STOW_PROBE()) return NAN;
   2736          
   2737              if (verbose_level > 2) {
   \                     ??probe_pt_3: (+1)
   \       0x88   0xF1B8 0x0F03      CMP      R8,#+3
   \       0x8C   0xDB5B             BLT.N    ??probe_pt_4
   2738                SERIAL_PROTOCOLPGM("Bed X: ");
   \       0x8E   0x.... 0x....      ADR.W    R0,?_10
   \       0x92   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2739                SERIAL_PROTOCOL_F(x, 3);
   \       0x96   0x4650             MOV      R0,R10
   \       0x98   0x.... 0x....      BL       __aeabi_f2d
   \       0x9C   0x4602             MOV      R2,R0
   \       0x9E   0x460B             MOV      R3,R1
   \       0xA0   0x79E0             LDRB     R0,[R4, #+7]
   \       0xA2   0x2800             CMP      R0,#+0
   \       0xA4   0xD10D             BNE.N    ??probe_pt_5
   \       0xA6   0x2003             MOVS     R0,#+3
   \       0xA8   0x9000             STR      R0,[SP, #+0]
   \       0xAA   0x....             LDR.N    R0,??DataTable116_4
   \       0xAC   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   \       0xB0   0xE00C             B.N      ??probe_pt_6
   \                     ??probe_pt_2: (+1)
   \       0xB2   0x2000             MOVS     R0,#+0
   \       0xB4   0x.... 0x....      BL       _Z18set_probe_deployedb
   \       0xB8   0x2800             CMP      R0,#+0
   \       0xBA   0xD0E5             BEQ.N    ??probe_pt_3
   \                     ??probe_pt_1: (+1)
   \       0xBC   0xF06F 0x4000      MVN      R0,#-2147483648
   \       0xC0   0xE043             B.N      ??probe_pt_7
   \                     ??probe_pt_5: (+1)
   \       0xC2   0x2003             MOVS     R0,#+3
   \       0xC4   0x9000             STR      R0,[SP, #+0]
   \       0xC6   0x....             LDR.N    R0,??DataTable116_5
   \       0xC8   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   2740                SERIAL_PROTOCOLPGM(" Y: ");
   \                     ??probe_pt_6: (+1)
   \       0xCC   0x.... 0x....      ADR.W    R0,?_11
   \       0xD0   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2741                SERIAL_PROTOCOL_F(y, 3);
   \       0xD4   0x4638             MOV      R0,R7
   \       0xD6   0x.... 0x....      BL       __aeabi_f2d
   \       0xDA   0x4602             MOV      R2,R0
   \       0xDC   0x460B             MOV      R3,R1
   \       0xDE   0x79E0             LDRB     R0,[R4, #+7]
   \       0xE0   0x2800             CMP      R0,#+0
   \       0xE2   0xD105             BNE.N    ??probe_pt_8
   \       0xE4   0x2003             MOVS     R0,#+3
   \       0xE6   0x9000             STR      R0,[SP, #+0]
   \       0xE8   0x....             LDR.N    R0,??DataTable116_4
   \       0xEA   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   \       0xEE   0xE004             B.N      ??probe_pt_9
   \                     ??probe_pt_8: (+1)
   \       0xF0   0x2003             MOVS     R0,#+3
   \       0xF2   0x9000             STR      R0,[SP, #+0]
   \       0xF4   0x....             LDR.N    R0,??DataTable116_5
   \       0xF6   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   2742                SERIAL_PROTOCOLPGM(" Z: ");
   \                     ??probe_pt_9: (+1)
   \       0xFA   0x.... 0x....      ADR.W    R0,?_12
   \       0xFE   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2743                SERIAL_PROTOCOL_F(measured_z, 3);
   \      0x102   0x4630             MOV      R0,R6
   \      0x104   0x.... 0x....      BL       __aeabi_f2d
   \      0x108   0x79E2             LDRB     R2,[R4, #+7]
   \      0x10A   0x2A00             CMP      R2,#+0
   \      0x10C   0xD107             BNE.N    ??probe_pt_10
   \      0x10E   0x2203             MOVS     R2,#+3
   \      0x110   0x9200             STR      R2,[SP, #+0]
   \      0x112   0x4602             MOV      R2,R0
   \      0x114   0x460B             MOV      R3,R1
   \      0x116   0x....             LDR.N    R0,??DataTable116_4
   \      0x118   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   \      0x11C   0xE006             B.N      ??probe_pt_11
   \                     ??probe_pt_10: (+1)
   \      0x11E   0x2203             MOVS     R2,#+3
   \      0x120   0x9200             STR      R2,[SP, #+0]
   \      0x122   0x4602             MOV      R2,R0
   \      0x124   0x460B             MOV      R3,R1
   \      0x126   0x....             LDR.N    R0,??DataTable116_5
   \      0x128   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   2744                SERIAL_EOL;
   \                     ??probe_pt_11: (+1)
   \      0x12C   0x79E0             LDRB     R0,[R4, #+7]
   \      0x12E   0x2800             CMP      R0,#+0
   \      0x130   0xD104             BNE.N    ??probe_pt_12
   \      0x132   0x210A             MOVS     R1,#+10
   \      0x134   0x....             LDR.N    R0,??DataTable116_4
   \      0x136   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \      0x13A   0xE004             B.N      ??probe_pt_4
   \                     ??probe_pt_12: (+1)
   \      0x13C   0x2200             MOVS     R2,#+0
   \      0x13E   0x210A             MOVS     R1,#+10
   \      0x140   0x....             LDR.N    R0,??DataTable116_5
   \      0x142   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   2745              }
   2746          
   2747              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2748                if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< probe_pt");
   2749              #endif
   2750          
   2751              feedrate_mm_s = old_feedrate_mm_s;
   \                     ??probe_pt_4: (+1)
   \      0x146   0x6765             STR      R5,[R4, #+116]
   2752          
   2753              return measured_z;
   \      0x148   0x4630             MOV      R0,R6
   \                     ??probe_pt_7: (+1)
   \      0x14A   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
   2754            }
   2755          
   2756          #endif // HAS_BED_PROBE
   2757          
   2758          //#if HAS_LEVELING
   2759          #if 1
   2760            /**
   2761             * Turn bed leveling on or off, fixing the current
   2762             * position as-needed.
   2763             *
   2764             * Disable: Current position = physical position
   2765             *  Enable: Current position = "unleveled" physical position
   2766             */

   \                                 In section .text, align 2, keep-with-next
   2767            void set_bed_leveling_enabled(bool enable/*=true*/) {
   \                     _Z24set_bed_leveling_enabledb: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   2768          /*--mks cfg--begin MESH_BED_LEVELING */  
   2769          /*
   2770              #if ENABLED(MESH_BED_LEVELING)
   2771          
   2772                if (enable != mbl.active()) {
   2773          
   2774                  if (!enable)
   2775                    planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS]);
   2776          
   2777                  mbl.set_active(enable && mbl.has_mesh());
   2778          
   2779                  if (enable && mbl.has_mesh()) planner.unapply_leveling(current_position);
   2780                }
   2781          
   2782              #elif ENABLED(AUTO_BED_LEVELING_UBL)
   2783          
   2784                ubl.state.active = enable;
   2785                //set_current_from_steppers_for_axis(Z_AXIS);
   2786          
   2787              #else
   2788          
   2789                #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
   2790                  const bool can_change = (!enable || (bilinear_grid_spacing[0] && bilinear_grid_spacing[1]));
   2791                #else
   2792                  constexpr bool can_change = true;
   2793                #endif
   2794          
   2795                if (can_change && enable != planner.abl_enabled) {
   2796          
   2797                  #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
   2798                    // Force bilinear_z_offset to re-calculate next time
   2799                    const float reset[XYZ] = { -9999.999, -9999.999, 0 };
   2800                    (void)bilinear_z_offset(reset);
   2801                  #endif
   2802          
   2803                  planner.abl_enabled = enable;
   2804                  if (!enable)
   2805                    set_current_from_steppers_for_axis(
   2806                      #if ABL_PLANAR
   2807                        ALL_AXES
   2808                      #else
   2809                        Z_AXIS
   2810                      #endif
   2811                    );
   2812                  else
   2813                    planner.unapply_leveling(current_position);
   2814                }
   2815              #endif
   2816          */
   2817          
   2818          //#if ENABLED(MESH_BED_LEVELING)
   2819          if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
   \        0x4   0x.... 0x....      LDR.W    R5,??DataTable126_2
   \        0x8   0xF895 0x1040      LDRB     R1,[R5, #+64]
   \        0xC   0x2920             CMP      R1,#+32
   \        0xE   0xD127             BNE.N    ??set_bed_leveling_enabled_0
   2820          {
   2821                if (enable != mbl.active()) {
   \       0x10   0x4625             MOV      R5,R4
   \       0x12   0x.... 0x....      BL       _ZN17mesh_bed_leveling6activeEv
   \       0x16   0x4285             CMP      R5,R0
   \       0x18   0xD060             BEQ.N    ??set_bed_leveling_enabled_1
   2822          
   2823                  if (!enable)
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0xD108             BNE.N    ??set_bed_leveling_enabled_2
   2824                    planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS]);
   \       0x1E   0x.... 0x....      LDR.W    R0,??DataTable126_1
   \       0x22   0xF100 0x0210      ADD      R2,R0,#+16
   \       0x26   0xF100 0x010C      ADD      R1,R0,#+12
   \       0x2A   0x3008             ADDS     R0,R0,#+8
   \       0x2C   0x.... 0x....      BL       _ZN7Planner14apply_levelingERfS0_S0_
   2825          
   2826                  mbl.set_active(enable && mbl.has_mesh());
   \                     ??set_bed_leveling_enabled_2: (+1)
   \       0x30   0x0020             MOVS     R0,R4
   \       0x32   0xD006             BEQ.N    ??set_bed_leveling_enabled_3
   \       0x34   0x.... 0x....      BL       _ZN17mesh_bed_leveling8has_meshEv
   \       0x38   0x1E40             SUBS     R0,R0,#+1
   \       0x3A   0x4180             SBCS     R0,R0,R0
   \       0x3C   0x43C0             MVNS     R0,R0
   \       0x3E   0x0FC0             LSRS     R0,R0,#+31
   \       0x40   0xE000             B.N      ??set_bed_leveling_enabled_4
   \                     ??set_bed_leveling_enabled_3: (+1)
   \       0x42   0x2000             MOVS     R0,#+0
   \                     ??set_bed_leveling_enabled_4: (+1)
   \       0x44   0x.... 0x....      BL       _ZN17mesh_bed_leveling10set_activeEb
   2827          
   2828                  if (enable && mbl.has_mesh()) planner.unapply_leveling(current_position);
   \       0x48   0x2C00             CMP      R4,#+0
   \       0x4A   0xD047             BEQ.N    ??set_bed_leveling_enabled_1
   \       0x4C   0x.... 0x....      BL       _ZN17mesh_bed_leveling8has_meshEv
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD043             BEQ.N    ??set_bed_leveling_enabled_1
   \       0x54   0x.... 0x....      LDR.W    R0,??DataTable126_3
   \       0x58   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x5C   0x.... 0x....      B.W      _ZN7Planner16unapply_levelingEPf
   2829                }
   2830          }
   2831          //#else
   2832          else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
   \                     ??set_bed_leveling_enabled_0: (+1)
   \       0x60   0x2910             CMP      R1,#+16
   \       0x62   0xD103             BNE.N    ??set_bed_leveling_enabled_5
   2833          {
   2834          	ubl.state.active = enable;
   \       0x64   0x.... 0x....      LDR.W    R0,??DataTable126_4
   \       0x68   0x7004             STRB     R4,[R0, #+0]
   \       0x6A   0xBD70             POP      {R4-R6,PC}
   2835          	//set_current_from_steppers_for_axis(Z_AXIS);
   2836          
   2837          }
   2838          	else
   2839          {
   2840          	/*--mks cfg--begin AUTO_BED_LEVELING_BILINEAR */
   2841          /*
   2842            #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
   2843          		  const bool can_change = (!enable || (bilinear_grid_spacing[0] && bilinear_grid_spacing[1]));
   2844            #else
   2845          		  constexpr bool can_change = true;
   2846            #endif
   2847            */
   2848          	bool can_change;
   2849          	if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
   \                     ??set_bed_leveling_enabled_5: (+1)
   \       0x6C   0x2908             CMP      R1,#+8
   \       0x6E   0xD10E             BNE.N    ??set_bed_leveling_enabled_6
   2850          		{
   2851          		can_change= (!enable || (bilinear_grid_spacing[0] && bilinear_grid_spacing[1]));
   \       0x70   0x0020             MOVS     R0,R4
   \       0x72   0xD00C             BEQ.N    ??set_bed_leveling_enabled_6
   \       0x74   0x.... 0x....      LDR.W    R2,??DataTable126_5
   \       0x78   0x6890             LDR      R0,[R2, #+8]
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD005             BEQ.N    ??set_bed_leveling_enabled_7
   \       0x7E   0x68D0             LDR      R0,[R2, #+12]
   \       0x80   0x1E40             SUBS     R0,R0,#+1
   \       0x82   0x4180             SBCS     R0,R0,R0
   \       0x84   0x43C0             MVNS     R0,R0
   \       0x86   0x0FC0             LSRS     R0,R0,#+31
   \       0x88   0xE002             B.N      ??set_bed_leveling_enabled_8
   \                     ??set_bed_leveling_enabled_7: (+1)
   \       0x8A   0x2000             MOVS     R0,#+0
   \       0x8C   0xE000             B.N      ??set_bed_leveling_enabled_8
   2852          		}
   2853          		else
   2854          			{
   2855          			can_change = true;
   \                     ??set_bed_leveling_enabled_6: (+1)
   \       0x8E   0x2001             MOVS     R0,#+1
   2856          			}
   2857          	
   2858          	  
   2859          	if (can_change && enable != planner.abl_enabled) {
   \                     ??set_bed_leveling_enabled_8: (+1)
   \       0x90   0x2800             CMP      R0,#+0
   \       0x92   0xD023             BEQ.N    ??set_bed_leveling_enabled_1
   \       0x94   0x.... 0x....      LDR.W    R6,??DataTable126_6
   \       0x98   0x4620             MOV      R0,R4
   \       0x9A   0x7832             LDRB     R2,[R6, #+0]
   \       0x9C   0x4290             CMP      R0,R2
   \       0x9E   0xD01D             BEQ.N    ??set_bed_leveling_enabled_1
   2860          
   2861          /*
   2862          	#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
   2863          			// Force bilinear_z_offset to re-calculate next time
   2864          			const float reset[XYZ] = { -9999.999, -9999.999, 0 };
   2865          			(void)bilinear_z_offset(reset);
   2866          	#endif
   2867          */	
   2868          			if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
   \       0xA0   0x2908             CMP      R1,#+8
   \       0xA2   0xD103             BNE.N    ??set_bed_leveling_enabled_9
   2869          				{
   2870          				const float reset[XYZ] = { -9999.999, -9999.999, 0 };
   2871          				(void)bilinear_z_offset(reset);
   \       0xA4   0x.... 0x....      ADR.W    R0,`set_bed_leveling_enabled(bool){3}{5}{8}{9}::reset`
   \       0xA8   0x.... 0x....      BL       _Z17bilinear_z_offsetPKf
   2872          				}
   2873          			
   2874          		  planner.abl_enabled = enable;
   \                     ??set_bed_leveling_enabled_9: (+1)
   \       0xAC   0x7034             STRB     R4,[R6, #+0]
   2875          		  if (!enable)
   \       0xAE   0x2C00             CMP      R4,#+0
   \       0xB0   0xD10E             BNE.N    ??set_bed_leveling_enabled_10
   2876          		  	{
   2877          			if(BED_LEVELING_METHOD&ABL_PLANAR)
   \       0xB2   0xF895 0x0040      LDRB     R0,[R5, #+64]
   \       0xB6   0xF010 0x0F06      TST      R0,#0x6
   \       0xBA   0xD004             BEQ.N    ??set_bed_leveling_enabled_11
   2878          				{set_current_from_steppers_for_axis(ALL_AXES);}
   \       0xBC   0x2064             MOVS     R0,#+100
   \       0xBE   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0xC2   0x.... 0x....      B.W      _Z34set_current_from_steppers_for_axis8AxisEnum
   2879          			else
   2880          				{set_current_from_steppers_for_axis(Z_AXIS);}
   \                     ??set_bed_leveling_enabled_11: (+1)
   \       0xC6   0x2002             MOVS     R0,#+2
   \       0xC8   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0xCC   0x.... 0x....      B.W      _Z34set_current_from_steppers_for_axis8AxisEnum
   2881          		  	}
   2882          		  else
   2883          			{planner.unapply_leveling(current_position);}
   \                     ??set_bed_leveling_enabled_10: (+1)
   \       0xD0   0x.... 0x....      LDR.W    R0,??DataTable126_3
   \       0xD4   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0xD8   0x.... 0x....      B.W      _ZN7Planner16unapply_levelingEPf
   2884          		}
   2885          }
   2886          //#endif
   2887          	/*--mks cfg--end MESH_BED_LEVELING */
   2888            }
   \                     ??set_bed_leveling_enabled_1: (+1)
   \       0xDC   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     `set_bed_leveling_enabled(bool){3}{5}{8}{9}::reset`:
   \        0x0   0xC61C'3FFF        DC32 0C61C3FFFH, 0C61C3FFFH, 0H
   \              0xC61C'3FFF  
   \              0x0000'0000  
   2889          
   2890          
   2891            #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
   2892          

   \                                 In section .text, align 2, keep-with-next
   2893              void set_z_fade_height(const float zfh) {
   \                     _Z17set_z_fade_heightf: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x4602             MOV      R2,R0
   2894                planner.z_fade_height = zfh;
   \        0x4   0x.... 0x....      LDR.W    R0,??DataTable126_7
   \        0x8   0x6002             STR      R2,[R0, #+0]
   2895                planner.inverse_z_fade_height = RECIPROCAL(zfh);
   \        0xA   0x4610             MOV      R0,R2
   \        0xC   0x.... 0x....      LDR.W    R1,??DataTable126_8  ;; 0xb58637bd
   \       0x10   0x.... 0x....      BL       __aeabi_cfrcmple
   \       0x14   0xD809             BHI.N    ??set_z_fade_height_0
   \       0x16   0x.... 0x....      LDR.W    R1,??DataTable127  ;; 0x358637be
   \       0x1A   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x1E   0xD204             BCS.N    ??set_z_fade_height_0
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x.... 0x....      LDR.W    R1,??DataTable127_1
   \       0x26   0x6008             STR      R0,[R1, #+0]
   \       0x28   0xE007             B.N      ??set_z_fade_height_1
   \                     ??set_z_fade_height_0: (+1)
   \       0x2A   0xF04F 0x507E      MOV      R0,#+1065353216
   \       0x2E   0x4611             MOV      R1,R2
   \       0x30   0x.... 0x....      BL       __aeabi_fdiv
   \       0x34   0x.... 0x....      LDR.W    R1,??DataTable127_1
   \       0x38   0x6008             STR      R0,[R1, #+0]
   2896          
   2897          /*--mks cfg--begin MESH_BED_LEVELING */
   2898          /*
   2899                if (
   2900                  #if ENABLED(MESH_BED_LEVELING)
   2901                    mbl.active()
   2902                  #else
   2903                    planner.abl_enabled
   2904                  #endif
   2905                ) {
   2906                  set_current_from_steppers_for_axis(
   2907                    #if ABL_PLANAR
   2908                      ALL_AXES
   2909                    #else
   2910                      Z_AXIS
   2911                    #endif
   2912                  );
   2913                }
   2914          */
   2915          	if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
   \                     ??set_z_fade_height_1: (+1)
   \       0x3A   0x.... 0x....      LDR.W    R0,??DataTable126_2
   \       0x3E   0xF890 0x1040      LDRB     R1,[R0, #+64]
   \       0x42   0x2920             CMP      R1,#+32
   \       0x44   0xD108             BNE.N    ??set_z_fade_height_2
   2916          		{
   2917          		if(mbl.active())
   \       0x46   0x.... 0x....      BL       _ZN17mesh_bed_leveling6activeEv
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD016             BEQ.N    ??set_z_fade_height_3
   2918          			{
   2919          				if(BED_LEVELING_METHOD&ABL_PLANAR)
   2920          					{set_current_from_steppers_for_axis(ALL_AXES);}
   2921          				else
   2922          					{set_current_from_steppers_for_axis(Z_AXIS);}
   \       0x4E   0x2002             MOVS     R0,#+2
   \       0x50   0xE8BD 0x4002      POP      {R1,LR}
   \       0x54   0x.... 0x....      B.W      _Z34set_current_from_steppers_for_axis8AxisEnum
   2923          			}
   2924          		}
   2925          	else
   2926          		{
   2927          		if(planner.abl_enabled)
   \                     ??set_z_fade_height_2: (+1)
   \       0x58   0x.... 0x....      LDR.W    R0,??DataTable126_6
   \       0x5C   0x7800             LDRB     R0,[R0, #+0]
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD00C             BEQ.N    ??set_z_fade_height_3
   2928          			{
   2929          			if(BED_LEVELING_METHOD&ABL_PLANAR)
   \       0x62   0xF011 0x0F06      TST      R1,#0x6
   \       0x66   0xD004             BEQ.N    ??set_z_fade_height_4
   2930          				{set_current_from_steppers_for_axis(ALL_AXES);}
   \       0x68   0x2064             MOVS     R0,#+100
   \       0x6A   0xE8BD 0x4002      POP      {R1,LR}
   \       0x6E   0x.... 0x....      B.W      _Z34set_current_from_steppers_for_axis8AxisEnum
   2931          			else
   2932          				{set_current_from_steppers_for_axis(Z_AXIS);}
   \                     ??set_z_fade_height_4: (+1)
   \       0x72   0x2002             MOVS     R0,#+2
   \       0x74   0xE8BD 0x4002      POP      {R1,LR}
   \       0x78   0x.... 0x....      B.W      _Z34set_current_from_steppers_for_axis8AxisEnum
   2933          			}
   2934          		}
   2935          /*--mks cfg--end MESH_BED_LEVELING */		
   2936              }
   \                     ??set_z_fade_height_3: (+1)
   \       0x7C   0xBD01             POP      {R0,PC}          ;; return
   2937          
   2938            #endif // LEVELING_FADE_HEIGHT
   2939          
   2940            /**
   2941             * Reset calibration results to zero.
   2942             */

   \                                 In section .text, align 2, keep-with-next
   2943            void reset_bed_level() {
   \                     _Z15reset_bed_levelv: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   2944              set_bed_leveling_enabled(false);
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   2945          	
   2946          	/*--mks cfg--begin AUTO_BED_LEVELING_BILINEAR */
   2947          /*	
   2948              #if ENABLED(MESH_BED_LEVELING)
   2949                if (mbl.has_mesh()) {
   2950                  mbl.reset();
   2951                  mbl.set_has_mesh(false);
   2952                }
   2953              #else
   2954                #if ENABLED(DEBUG_LEVELING_FEATURE)
   2955                  if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("reset_bed_level");
   2956                #endif
   2957                #if ABL_PLANAR
   2958                  planner.bed_level_matrix.set_to_identity();
   2959                #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
   2960                  bilinear_start[X_AXIS] = bilinear_start[Y_AXIS] =
   2961                  bilinear_grid_spacing[X_AXIS] = bilinear_grid_spacing[Y_AXIS] = 0;
   2962                  for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
   2963                    for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
   2964                      z_values[x][y] = NAN;
   2965                #elif ENABLED(AUTO_BED_LEVELING_UBL)
   2966                  ubl.reset();
   2967                #endif
   2968              #endif
   2969          */
   2970          
   2971          	if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
   \        0x8   0x.... 0x....      LDR.W    R0,??DataTable126_2
   \        0xC   0xF890 0x1040      LDRB     R1,[R0, #+64]
   \       0x10   0x2920             CMP      R1,#+32
   \       0x12   0xD10A             BNE.N    ??reset_bed_level_0
   2972          {
   2973          		  if (mbl.has_mesh()) {
   \       0x14   0x.... 0x....      BL       _ZN17mesh_bed_leveling8has_meshEv
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD03B             BEQ.N    ??reset_bed_level_1
   2974          			mbl.reset();
   \       0x1C   0x.... 0x....      BL       _ZN17mesh_bed_leveling5resetEv
   2975          			mbl.set_has_mesh(false);
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x26   0x.... 0x....      B.W      _ZN17mesh_bed_leveling12set_has_meshEb
   2976          		  }
   2977          }
   2978          else
   2979          {
   2980          
   2981            #if ENABLED(DEBUG_LEVELING_FEATURE)
   2982          			  if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("reset_bed_level");
   2983            #endif
   2984            if(BED_LEVELING_METHOD&ABL_PLANAR)
   \                     ??reset_bed_level_0: (+1)
   \       0x2A   0xF011 0x0F06      TST      R1,#0x6
   \       0x2E   0xD005             BEQ.N    ??reset_bed_level_2
   2985            	{
   2986            	planner.bed_level_matrix.set_to_identity();
   \       0x30   0x.... 0x....      LDR.W    R0,??DataTable127_2
   \       0x34   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x38   0x.... 0x....      B.W      _ZN10matrix_3x315set_to_identityEv
   2987            	}
   2988            else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
   \                     ??reset_bed_level_2: (+1)
   \       0x3C   0x2908             CMP      R1,#+8
   \       0x3E   0xD121             BNE.N    ??reset_bed_level_3
   2989            	{
   2990          	  bilinear_start[X_AXIS] = bilinear_start[Y_AXIS] =
   2991          	  bilinear_grid_spacing[X_AXIS] = bilinear_grid_spacing[Y_AXIS] = 0;
   \       0x40   0x.... 0x....      LDR.W    R1,??DataTable126_5
   \       0x44   0x2200             MOVS     R2,#+0
   \       0x46   0x60CA             STR      R2,[R1, #+12]
   \       0x48   0x608A             STR      R2,[R1, #+8]
   \       0x4A   0x614A             STR      R2,[R1, #+20]
   \       0x4C   0x610A             STR      R2,[R1, #+16]
   2992          	  for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
   \       0x4E   0x4611             MOV      R1,R2
   \       0x50   0xF100 0x0360      ADD      R3,R0,#+96
   \       0x54   0xF06F 0x4600      MVN      R6,#-2147483648
   \       0x58   0xE00F             B.N      ??reset_bed_level_4
   2993          		for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
   2994          		  z_values[x][y] = NAN;
   \                     ??reset_bed_level_5: (+1)
   \       0x5A   0x.... 0x....      LDR.W    R4,??DataTable127_3
   \       0x5E   0xEB04 0x1481      ADD      R4,R4,R1, LSL #+6
   \       0x62   0x4615             MOV      R5,R2
   \       0x64   0xB2ED             UXTB     R5,R5
   \       0x66   0xF844 0x6025      STR      R6,[R4, R5, LSL #+2]
   \       0x6A   0x1C52             ADDS     R2,R2,#+1
   \                     ??reset_bed_level_6: (+1)
   \       0x6C   0x4614             MOV      R4,R2
   \       0x6E   0x785D             LDRB     R5,[R3, #+1]
   \       0x70   0xB2E4             UXTB     R4,R4
   \       0x72   0x42AC             CMP      R4,R5
   \       0x74   0xD3F1             BCC.N    ??reset_bed_level_5
   \       0x76   0x1C49             ADDS     R1,R1,#+1
   \       0x78   0xB2C9             UXTB     R1,R1
   \                     ??reset_bed_level_4: (+1)
   \       0x7A   0x781A             LDRB     R2,[R3, #+0]
   \       0x7C   0x4291             CMP      R1,R2
   \       0x7E   0xDA09             BGE.N    ??reset_bed_level_1
   \       0x80   0x2200             MOVS     R2,#+0
   \       0x82   0xE7F3             B.N      ??reset_bed_level_6
   2995            	
   2996            	}
   2997            else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
   \                     ??reset_bed_level_3: (+1)
   \       0x84   0x2910             CMP      R1,#+16
   \       0x86   0xD105             BNE.N    ??reset_bed_level_1
   2998            	{
   2999            	ubl.reset();
   \       0x88   0x.... 0x....      LDR.W    R0,??DataTable129
   \       0x8C   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x90   0x.... 0x....      B.W      _ZN20unified_bed_leveling5resetEv
   3000            	}
   3001          }
   3002          	
   3003          	/*--mks cfg--end AUTO_BED_LEVELING_BILINEAR */
   3004            }
   \                     ??reset_bed_level_1: (+1)
   \       0x94   0xBD70             POP      {R4-R6,PC}       ;; return
   3005          
   3006          #endif // HAS_LEVELING
   3007          
   3008          //#if ENABLED(AUTO_BED_LEVELING_BILINEAR) || ENABLED(MESH_BED_LEVELING)
   3009          #if 1   /*--mks cfg--end AUTO_BED_LEVELING_BILINEAR */
   3010            /**
   3011             * Enable to produce output in JSON format suitable
   3012             * for SCAD or JavaScript mesh visualizers.
   3013             *
   3014             * Visualize meshes in OpenSCAD using the included script.
   3015             *
   3016             *   buildroot/shared/scripts/MarlinMesh.scad
   3017             */
   3018            //#define SCAD_MESH_OUTPUT
   3019          
   3020            /**
   3021             * Print calibration results for plotting or manual frame adjustment.
   3022             */
   3023             /*--mks cfg-- LCD_ MESH_BED_LEVELING */
   3024            //static void print_2d_array(const uint8_t sx, const uint8_t sy, const uint8_t precision, float (*fn)(const uint8_t, const uint8_t)) {

   \                                 In section .text, align 2, keep-with-next
   3025            static void print_2d_array(const uint8_t sx, const uint8_t sy, const uint8_t precision, const uint8_t fn) {
   \                     _ZN37_INTERNAL_15_Marlin_main_cpp_3178531914print_2d_arrayEhhhh: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x468A             MOV      R10,R1
   \        0x8   0x4614             MOV      R4,R2
   \        0xA   0x4699             MOV      R9,R3
   3026              #ifndef SCAD_MESH_OUTPUT
   3027                for (uint8_t x = 0; x < sx; x++) {
   \        0xC   0x2700             MOVS     R7,#+0
   \        0xE   0x.... 0x....      LDR.W    R5,??DataTable126_1
   \       0x12   0xE010             B.N      ??print_2d_array_0
   3028                  for (uint8_t i = 0; i < precision + 2 + (x < 10 ? 1 : 0); i++)
   3029                    SERIAL_PROTOCOLCHAR(' ');
   3030                  SERIAL_PROTOCOL((int)x);
   \                     ??print_2d_array_1: (+1)
   \       0x14   0x220A             MOVS     R2,#+10
   \       0x16   0x4639             MOV      R1,R7
   \       0x18   0x.... 0x....      LDR.W    R0,??DataTable129_1
   \       0x1C   0x.... 0x....      BL       _ZN12MarlinSerial5printEii
   \       0x20   0xE007             B.N      ??print_2d_array_2
   \                     ??print_2d_array_3: (+1)
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD1F6             BNE.N    ??print_2d_array_1
   \       0x26   0x220A             MOVS     R2,#+10
   \       0x28   0x4639             MOV      R1,R7
   \       0x2A   0x.... 0x....      LDR.W    R0,??DataTable128
   \       0x2E   0x.... 0x....      BL       _ZN12MarlinSerial5printEii
   \                     ??print_2d_array_2: (+1)
   \       0x32   0x1C7F             ADDS     R7,R7,#+1
   \       0x34   0xB2FF             UXTB     R7,R7
   \                     ??print_2d_array_0: (+1)
   \       0x36   0x46B0             MOV      R8,R6
   \       0x38   0x4547             CMP      R7,R8
   \       0x3A   0xDA1F             BGE.N    ??print_2d_array_4
   \       0x3C   0xF04F 0x0800      MOV      R8,#+0
   \       0x40   0xE018             B.N      ??print_2d_array_5
   \                     ??print_2d_array_6: (+1)
   \       0x42   0x2200             MOVS     R2,#+0
   \       0x44   0x2120             MOVS     R1,#+32
   \       0x46   0x.... 0x....      LDR.W    R0,??DataTable129_1
   \       0x4A   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   \       0x4E   0xE00F             B.N      ??print_2d_array_7
   \                     ??print_2d_array_8: (+1)
   \       0x50   0x2100             MOVS     R1,#+0
   \                     ??print_2d_array_9: (+1)
   \       0x52   0x79E8             LDRB     R0,[R5, #+7]
   \       0x54   0x4642             MOV      R2,R8
   \       0x56   0xB2D2             UXTB     R2,R2
   \       0x58   0x4623             MOV      R3,R4
   \       0x5A   0x18C9             ADDS     R1,R1,R3
   \       0x5C   0x1C89             ADDS     R1,R1,#+2
   \       0x5E   0x428A             CMP      R2,R1
   \       0x60   0xDADF             BGE.N    ??print_2d_array_3
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xD1ED             BNE.N    ??print_2d_array_6
   \       0x66   0x2120             MOVS     R1,#+32
   \       0x68   0x.... 0x....      LDR.W    R0,??DataTable128
   \       0x6C   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \                     ??print_2d_array_7: (+1)
   \       0x70   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??print_2d_array_5: (+1)
   \       0x74   0x2F0A             CMP      R7,#+10
   \       0x76   0xDAEB             BGE.N    ??print_2d_array_8
   \       0x78   0x2101             MOVS     R1,#+1
   \       0x7A   0xE7EA             B.N      ??print_2d_array_9
   3031                }
   3032                SERIAL_EOL;
   \                     ??print_2d_array_4: (+1)
   \       0x7C   0x79E8             LDRB     R0,[R5, #+7]
   \       0x7E   0x2800             CMP      R0,#+0
   \       0x80   0xD105             BNE.N    ??print_2d_array_10
   \       0x82   0x210A             MOVS     R1,#+10
   \       0x84   0x.... 0x....      LDR.W    R0,??DataTable128
   \       0x88   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \       0x8C   0xE005             B.N      ??print_2d_array_11
   \                     ??print_2d_array_10: (+1)
   \       0x8E   0x2200             MOVS     R2,#+0
   \       0x90   0x210A             MOVS     R1,#+10
   \       0x92   0x.... 0x....      LDR.W    R0,??DataTable129_1
   \       0x96   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   3033              #endif
   3034              #ifdef SCAD_MESH_OUTPUT
   3035                SERIAL_PROTOCOLLNPGM("measured_z = ["); // open 2D array
   3036              #endif
   3037              for (uint8_t y = 0; y < sy; y++) {
   \                     ??print_2d_array_11: (+1)
   \       0x9A   0x2600             MOVS     R6,#+0
   \       0x9C   0xE00F             B.N      ??print_2d_array_12
   3038                #ifdef SCAD_MESH_OUTPUT
   3039                  SERIAL_PROTOCOLLNPGM(" [");           // open sub-array
   3040                #else
   3041                  if (y < 10) SERIAL_PROTOCOLCHAR(' ');
   3042                  SERIAL_PROTOCOL((int)y);
   3043                #endif
   3044                for (uint8_t x = 0; x < sx; x++) {
   3045                  SERIAL_PROTOCOLCHAR(' ');
   3046                  //const float offset = fn(x, y); /*--mks cfg-- LCD_ MESH_BED_LEVELING */
   3047                  float offset;
   3048          		switch(fn)
   3049          			{
   3050          			case 0:	
   3051          			if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
   3052          				offset =z_values[x][y];
   3053          			break;
   3054          			case 1:	
   3055          			#if ENABLED(ABL_BILINEAR_SUBDIVISION)
   3056          				offset =z_values_virt[x][y];	
   3057          			#endif
   3058          			break;
   3059          			case 2:	
   3060          				if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
   3061                             offset =mbl.z_values[x][y];		
   3062                                    break;
   3063          			default:		break;
   3064          			}
   3065          		
   3066                  if (!isnan(offset)) {
   3067                    if (offset >= 0) SERIAL_PROTOCOLCHAR('+');
   3068                    SERIAL_PROTOCOL_F(offset, precision);
   3069                  }
   3070                  else {
   3071                    #ifdef SCAD_MESH_OUTPUT
   3072                      for (uint8_t i = 3; i < precision + 3; i++)
   3073                        SERIAL_PROTOCOLCHAR(' ');
   3074                      SERIAL_PROTOCOLPGM("NAN");
   3075                    #else
   3076                      for (uint8_t i = 0; i < precision + 3; i++)
   3077                        SERIAL_PROTOCOLCHAR(i ? '=' : ' ');
   3078                    #endif
   3079                  }
   3080                  #ifdef SCAD_MESH_OUTPUT
   3081                    if (x < sx - 1) SERIAL_PROTOCOLCHAR(',');
   3082                  #endif
   3083                }
   3084                #ifdef SCAD_MESH_OUTPUT
   3085                  SERIAL_PROTOCOLCHAR(' ');
   3086                  SERIAL_PROTOCOLCHAR(']');                     // close sub-array
   3087                  if (y < sy - 1) SERIAL_PROTOCOLCHAR(',');
   3088                #endif
   3089                SERIAL_EOL;
   \                     ??print_2d_array_13: (+1)
   \       0x9E   0x2200             MOVS     R2,#+0
   \       0xA0   0x210A             MOVS     R1,#+10
   \       0xA2   0x.... 0x....      LDR.W    R0,??DataTable129_1
   \       0xA6   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   \       0xAA   0xE006             B.N      ??print_2d_array_14
   \                     ??print_2d_array_15: (+1)
   \       0xAC   0x2800             CMP      R0,#+0
   \       0xAE   0xD1F6             BNE.N    ??print_2d_array_13
   \       0xB0   0x210A             MOVS     R1,#+10
   \       0xB2   0x.... 0x....      LDR.W    R0,??DataTable128
   \       0xB6   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \                     ??print_2d_array_14: (+1)
   \       0xBA   0x1C76             ADDS     R6,R6,#+1
   \       0xBC   0xB2F6             UXTB     R6,R6
   \                     ??print_2d_array_12: (+1)
   \       0xBE   0x4650             MOV      R0,R10
   \       0xC0   0x4286             CMP      R6,R0
   \       0xC2   0xF280 0x80A3      BGE.W    ??print_2d_array_16
   \       0xC6   0x2E0A             CMP      R6,#+10
   \       0xC8   0xDA0E             BGE.N    ??print_2d_array_17
   \       0xCA   0x79E8             LDRB     R0,[R5, #+7]
   \       0xCC   0x2800             CMP      R0,#+0
   \       0xCE   0xD105             BNE.N    ??print_2d_array_18
   \       0xD0   0x2120             MOVS     R1,#+32
   \       0xD2   0x.... 0x....      LDR.W    R0,??DataTable128
   \       0xD6   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \       0xDA   0xE005             B.N      ??print_2d_array_17
   \                     ??print_2d_array_18: (+1)
   \       0xDC   0x2200             MOVS     R2,#+0
   \       0xDE   0x2120             MOVS     R1,#+32
   \       0xE0   0x.... 0x....      LDR.W    R0,??DataTable129_1
   \       0xE4   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   \                     ??print_2d_array_17: (+1)
   \       0xE8   0x79E8             LDRB     R0,[R5, #+7]
   \       0xEA   0x2800             CMP      R0,#+0
   \       0xEC   0xD106             BNE.N    ??print_2d_array_19
   \       0xEE   0x220A             MOVS     R2,#+10
   \       0xF0   0x4631             MOV      R1,R6
   \       0xF2   0x.... 0x....      LDR.W    R0,??DataTable128
   \       0xF6   0x.... 0x....      BL       _ZN12MarlinSerial5printEii
   \       0xFA   0xE005             B.N      ??print_2d_array_20
   \                     ??print_2d_array_19: (+1)
   \       0xFC   0x220A             MOVS     R2,#+10
   \       0xFE   0x4631             MOV      R1,R6
   \      0x100   0x.... 0x....      LDR.W    R0,??DataTable129_1
   \      0x104   0x.... 0x....      BL       _ZN12MarlinSerial5printEii
   \                     ??print_2d_array_20: (+1)
   \      0x108   0x2700             MOVS     R7,#+0
   \      0x10A   0xE04D             B.N      ??print_2d_array_21
   \                     ??print_2d_array_22: (+1)
   \      0x10C   0x2200             MOVS     R2,#+0
   \      0x10E   0x2120             MOVS     R1,#+32
   \      0x110   0x.... 0x....      LDR.W    R0,??DataTable129_1
   \      0x114   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   \                     ??print_2d_array_23: (+1)
   \      0x118   0x4648             MOV      R0,R9
   \      0x11A   0x2800             CMP      R0,#+0
   \      0x11C   0xD002             BEQ.N    ??print_2d_array_24
   \      0x11E   0x2802             CMP      R0,#+2
   \      0x120   0xD00D             BEQ.N    ??print_2d_array_25
   \      0x122   0xE018             B.N      ??print_2d_array_26
   \                     ??print_2d_array_24: (+1)
   \      0x124   0x.... 0x....      LDR.W    R0,??DataTable126_2
   \      0x128   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \      0x12C   0x2808             CMP      R0,#+8
   \      0x12E   0xD112             BNE.N    ??print_2d_array_26
   \      0x130   0x.... 0x....      LDR.W    R0,??DataTable127_3
   \      0x134   0xEB00 0x1087      ADD      R0,R0,R7, LSL #+6
   \      0x138   0xF850 0xB026      LDR      R11,[R0, R6, LSL #+2]
   \      0x13C   0xE00B             B.N      ??print_2d_array_26
   \                     ??print_2d_array_25: (+1)
   \      0x13E   0x.... 0x....      LDR.W    R0,??DataTable126_2
   \      0x142   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \      0x146   0x2820             CMP      R0,#+32
   \      0x148   0xD105             BNE.N    ??print_2d_array_26
   \      0x14A   0x.... 0x....      LDR.W    R0,??DataTable130
   \      0x14E   0xEB00 0x1087      ADD      R0,R0,R7, LSL #+6
   \      0x152   0xF850 0xB026      LDR      R11,[R0, R6, LSL #+2]
   \                     ??print_2d_array_26: (+1)
   \      0x156   0x4658             MOV      R0,R11
   \      0x158   0x.... 0x....      BL       _Z5isnanf
   \      0x15C   0x2800             CMP      R0,#+0
   \      0x15E   0xD134             BNE.N    ??print_2d_array_27
   \      0x160   0x4658             MOV      R0,R11
   \      0x162   0x2100             MOVS     R1,#+0
   \      0x164   0x.... 0x....      BL       __aeabi_cfrcmple
   \      0x168   0xD80E             BHI.N    ??print_2d_array_28
   \      0x16A   0x79E8             LDRB     R0,[R5, #+7]
   \      0x16C   0x2800             CMP      R0,#+0
   \      0x16E   0xD105             BNE.N    ??print_2d_array_29
   \      0x170   0x212B             MOVS     R1,#+43
   \      0x172   0x.... 0x....      LDR.W    R0,??DataTable128
   \      0x176   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \      0x17A   0xE005             B.N      ??print_2d_array_28
   \                     ??print_2d_array_29: (+1)
   \      0x17C   0x460A             MOV      R2,R1
   \      0x17E   0x212B             MOVS     R1,#+43
   \      0x180   0x.... 0x....      LDR.W    R0,??DataTable129_1
   \      0x184   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   \                     ??print_2d_array_28: (+1)
   \      0x188   0x4658             MOV      R0,R11
   \      0x18A   0x.... 0x....      BL       __aeabi_f2d
   \      0x18E   0x4623             MOV      R3,R4
   \      0x190   0x79EA             LDRB     R2,[R5, #+7]
   \      0x192   0x2A00             CMP      R2,#+0
   \      0x194   0x9300             STR      R3,[SP, #+0]
   \      0x196   0x4602             MOV      R2,R0
   \      0x198   0x460B             MOV      R3,R1
   \      0x19A   0xD111             BNE.N    ??print_2d_array_30
   \      0x19C   0x.... 0x....      LDR.W    R0,??DataTable128
   \      0x1A0   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   \                     ??print_2d_array_31: (+1)
   \      0x1A4   0x1C7F             ADDS     R7,R7,#+1
   \      0x1A6   0xB2FF             UXTB     R7,R7
   \                     ??print_2d_array_21: (+1)
   \      0x1A8   0x79E8             LDRB     R0,[R5, #+7]
   \      0x1AA   0x4547             CMP      R7,R8
   \      0x1AC   0xF6BF 0xAF7E      BGE.W    ??print_2d_array_15
   \      0x1B0   0x2800             CMP      R0,#+0
   \      0x1B2   0xD1AB             BNE.N    ??print_2d_array_22
   \      0x1B4   0x2120             MOVS     R1,#+32
   \      0x1B6   0x.... 0x....      LDR.W    R0,??DataTable128
   \      0x1BA   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \      0x1BE   0xE7AB             B.N      ??print_2d_array_23
   \                     ??print_2d_array_30: (+1)
   \      0x1C0   0x.... 0x....      LDR.W    R0,??DataTable129_1
   \      0x1C4   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   \      0x1C8   0xE7EC             B.N      ??print_2d_array_31
   \                     ??print_2d_array_27: (+1)
   \      0x1CA   0x2000             MOVS     R0,#+0
   \      0x1CC   0x46A3             MOV      R11,R4
   \      0x1CE   0x4604             MOV      R4,R0
   \      0x1D0   0xE00B             B.N      ??print_2d_array_32
   \                     ??print_2d_array_33: (+1)
   \      0x1D2   0x2120             MOVS     R1,#+32
   \      0x1D4   0xE002             B.N      ??print_2d_array_34
   \                     ??print_2d_array_35: (+1)
   \      0x1D6   0x2C00             CMP      R4,#+0
   \      0x1D8   0xD0FB             BEQ.N    ??print_2d_array_33
   \      0x1DA   0x213D             MOVS     R1,#+61
   \                     ??print_2d_array_34: (+1)
   \      0x1DC   0x2200             MOVS     R2,#+0
   \      0x1DE   0x.... 0x....      LDR.W    R0,??DataTable129_1
   \      0x1E2   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   \                     ??print_2d_array_36: (+1)
   \      0x1E6   0x1C64             ADDS     R4,R4,#+1
   \      0x1E8   0xB2E4             UXTB     R4,R4
   \                     ??print_2d_array_32: (+1)
   \      0x1EA   0x4658             MOV      R0,R11
   \      0x1EC   0x1CC0             ADDS     R0,R0,#+3
   \      0x1EE   0x4284             CMP      R4,R0
   \      0x1F0   0xDA1E             BGE.N    ??print_2d_array_37
   \      0x1F2   0x79E8             LDRB     R0,[R5, #+7]
   \      0x1F4   0x2800             CMP      R0,#+0
   \      0x1F6   0xD1EE             BNE.N    ??print_2d_array_35
   \      0x1F8   0x2C00             CMP      R4,#+0
   \      0x1FA   0xD001             BEQ.N    ??print_2d_array_38
   \      0x1FC   0x213D             MOVS     R1,#+61
   \      0x1FE   0xE000             B.N      ??print_2d_array_39
   \                     ??print_2d_array_38: (+1)
   \      0x200   0x2120             MOVS     R1,#+32
   \                     ??print_2d_array_39: (+1)
   \      0x202   0x.... 0x....      LDR.W    R0,??DataTable128
   \      0x206   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \      0x20A   0xE7EC             B.N      ??print_2d_array_36
   3090              }
   3091              #ifdef SCAD_MESH_OUTPUT
   3092                SERIAL_PROTOCOLPGM("\n];");                     // close 2D array
   3093              #endif
   3094              SERIAL_EOL;
   \                     ??print_2d_array_16: (+1)
   \      0x20C   0x79E8             LDRB     R0,[R5, #+7]
   \      0x20E   0x2800             CMP      R0,#+0
   \      0x210   0xD106             BNE.N    ??print_2d_array_40
   \      0x212   0x210A             MOVS     R1,#+10
   \      0x214   0x.... 0x....      LDR.W    R0,??DataTable128
   \      0x218   0xE8BD 0x4FF4      POP      {R2,R4-R11,LR}
   \      0x21C   0x.... 0x....      B.W      _ZN12MarlinSerial5writeEh
   \                     ??print_2d_array_40: (+1)
   \      0x220   0x2200             MOVS     R2,#+0
   \      0x222   0x210A             MOVS     R1,#+10
   \      0x224   0x.... 0x....      LDR.W    R0,??DataTable129_1
   \      0x228   0xE8BD 0x4FF8      POP      {R3-R11,LR}
   \      0x22C   0x.... 0x....      B.W      _ZN12MarlinSerial5printEci
   \                     ??print_2d_array_37: (+1)
   \      0x230   0x465C             MOV      R4,R11
   \      0x232   0xE7B7             B.N      ??print_2d_array_31
   3095            }
   3096          
   3097          #endif
   3098          
   3099          //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
   3100          #if 1  /*--mks cfg-- AUTO_BED_LEVELING_BILINEAR */
   3101          
   3102            /**
   3103             * Extrapolate a single point from its neighbors
   3104             */

   \                                 In section .text, align 2, keep-with-next
   3105            static void extrapolate_one_point(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir) {
   \                     _ZN37_INTERNAL_15_Marlin_main_cpp_3178531921extrapolate_one_pointEhhaa: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4681             MOV      R9,R0
   \        0x6   0x4688             MOV      R8,R1
   \        0x8   0x4617             MOV      R7,R2
   \        0xA   0x469A             MOV      R10,R3
   3106              #if ENABLED(DEBUG_LEVELING_FEATURE)
   3107                if (DEBUGGING(LEVELING)) {
   3108                  SERIAL_ECHOPGM("Extrapolate [");
   3109                  if (x < 10) SERIAL_CHAR(' ');
   3110                  SERIAL_ECHO((int)x);
   3111                  SERIAL_CHAR(xdir ? (xdir > 0 ? '+' : '-') : ' ');
   3112                  SERIAL_CHAR(' ');
   3113                  if (y < 10) SERIAL_CHAR(' ');
   3114                  SERIAL_ECHO((int)y);
   3115                  SERIAL_CHAR(ydir ? (ydir > 0 ? '+' : '-') : ' ');
   3116                  SERIAL_CHAR(']');
   3117                }
   3118              #endif
   3119              if (!isnan(z_values[x][y])) {
   \        0xC   0x.... 0x....      LDR.W    R6,??DataTable127_3
   \       0x10   0xEB16 0x1480      ADDS     R4,R6,R0, LSL #+6
   \       0x14   0x4645             MOV      R5,R8
   \       0x16   0xF854 0x0025      LDR      R0,[R4, R5, LSL #+2]
   \       0x1A   0x.... 0x....      BL       _Z5isnanf
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD077             BEQ.N    ??extrapolate_one_point_0
   3120                #if ENABLED(DEBUG_LEVELING_FEATURE)
   3121                  if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM(" (done)");
   3122                #endif
   3123                return;  // Don't overwrite good values.
   3124              }
   3125              SERIAL_EOL;
   \       0x22   0x.... 0x....      LDR.W    R0,??DataTable126_1
   \       0x26   0x79C0             LDRB     R0,[R0, #+7]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD105             BNE.N    ??extrapolate_one_point_1
   \       0x2C   0x210A             MOVS     R1,#+10
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable128
   \       0x32   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \       0x36   0xE005             B.N      ??extrapolate_one_point_2
   \                     ??extrapolate_one_point_1: (+1)
   \       0x38   0x2200             MOVS     R2,#+0
   \       0x3A   0x210A             MOVS     R1,#+10
   \       0x3C   0x.... 0x....      LDR.W    R0,??DataTable129_1
   \       0x40   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   3126          
   3127              // Get X neighbors, Y neighbors, and XY neighbors
   3128              const uint8_t x1 = x + xdir, y1 = y + ydir, x2 = x1 + xdir, y2 = y1 + ydir;
   \                     ??extrapolate_one_point_2: (+1)
   \       0x44   0x44B9             ADD      R9,R7,R9
   \       0x46   0xFA5F 0xF989      UXTB     R9,R9
   \       0x4A   0x44D0             ADD      R8,R10,R8
   \       0x4C   0xFA5F 0xF888      UXTB     R8,R8
   3129              float a1 = z_values[x1][y ], a2 = z_values[x2][y ],
   \       0x50   0xEB06 0x1089      ADD      R0,R6,R9, LSL #+6
   \       0x54   0xF850 0x1025      LDR      R1,[R0, R5, LSL #+2]
   \       0x58   0x9100             STR      R1,[SP, #+0]
   \       0x5A   0x444F             ADD      R7,R7,R9
   \       0x5C   0xB2FF             UXTB     R7,R7
   \       0x5E   0xEB16 0x1187      ADDS     R1,R6,R7, LSL #+6
   \       0x62   0xF851 0x6025      LDR      R6,[R1, R5, LSL #+2]
   3130                    b1 = z_values[x ][y1], b2 = z_values[x ][y2],
   \       0x66   0xF854 0x7028      LDR      R7,[R4, R8, LSL #+2]
   \       0x6A   0x44C2             ADD      R10,R10,R8
   \       0x6C   0xFA5F 0xFA8A      UXTB     R10,R10
   \       0x70   0xF854 0x902A      LDR      R9,[R4, R10, LSL #+2]
   3131                    c1 = z_values[x1][y1], c2 = z_values[x2][y2];
   \       0x74   0xF850 0x8028      LDR      R8,[R0, R8, LSL #+2]
   \       0x78   0xF851 0xA02A      LDR      R10,[R1, R10, LSL #+2]
   3132          
   3133              // Treat far unprobed points as zero, near as equal to far
   3134              if (isnan(a2)) a2 = 0.0; if (isnan(a1)) a1 = a2;
   \       0x7C   0x4630             MOV      R0,R6
   \       0x7E   0x.... 0x....      BL       _Z5isnanf
   \       0x82   0x2800             CMP      R0,#+0
   \       0x84   0xD000             BEQ.N    ??extrapolate_one_point_3
   \       0x86   0x2600             MOVS     R6,#+0
   \                     ??extrapolate_one_point_3: (+1)
   \       0x88   0x9800             LDR      R0,[SP, #+0]
   \       0x8A   0x.... 0x....      BL       _Z5isnanf
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xD000             BEQ.N    ??extrapolate_one_point_4
   \       0x92   0x9600             STR      R6,[SP, #+0]
   3135              if (isnan(b2)) b2 = 0.0; if (isnan(b1)) b1 = b2;
   \                     ??extrapolate_one_point_4: (+1)
   \       0x94   0x4648             MOV      R0,R9
   \       0x96   0x.... 0x....      BL       _Z5isnanf
   \       0x9A   0x2800             CMP      R0,#+0
   \       0x9C   0xD001             BEQ.N    ??extrapolate_one_point_5
   \       0x9E   0xF04F 0x0900      MOV      R9,#+0
   \                     ??extrapolate_one_point_5: (+1)
   \       0xA2   0x4638             MOV      R0,R7
   \       0xA4   0x.... 0x....      BL       _Z5isnanf
   \       0xA8   0x2800             CMP      R0,#+0
   \       0xAA   0xD000             BEQ.N    ??extrapolate_one_point_6
   \       0xAC   0x464F             MOV      R7,R9
   3136              if (isnan(c2)) c2 = 0.0; if (isnan(c1)) c1 = c2;
   \                     ??extrapolate_one_point_6: (+1)
   \       0xAE   0x4650             MOV      R0,R10
   \       0xB0   0x.... 0x....      BL       _Z5isnanf
   \       0xB4   0x2800             CMP      R0,#+0
   \       0xB6   0xD001             BEQ.N    ??extrapolate_one_point_7
   \       0xB8   0xF04F 0x0A00      MOV      R10,#+0
   \                     ??extrapolate_one_point_7: (+1)
   \       0xBC   0x4640             MOV      R0,R8
   \       0xBE   0x.... 0x....      BL       _Z5isnanf
   \       0xC2   0x2800             CMP      R0,#+0
   \       0xC4   0xD000             BEQ.N    ??extrapolate_one_point_8
   \       0xC6   0x46D0             MOV      R8,R10
   3137          
   3138              const float a = 2 * a1 - a2, b = 2 * b1 - b2, c = 2 * c1 - c2;
   3139          
   3140              // Take the average instead of the median
   3141              z_values[x][y] = (a + b + c) / 3.0;
   \                     ??extrapolate_one_point_8: (+1)
   \       0xC8   0xF04F 0x4B80      MOV      R11,#+1073741824
   \       0xCC   0x9800             LDR      R0,[SP, #+0]
   \       0xCE   0x4659             MOV      R1,R11
   \       0xD0   0x.... 0x....      BL       __aeabi_fmul
   \       0xD4   0x4631             MOV      R1,R6
   \       0xD6   0x.... 0x....      BL       __aeabi_fsub
   \       0xDA   0x4606             MOV      R6,R0
   \       0xDC   0x4638             MOV      R0,R7
   \       0xDE   0x4659             MOV      R1,R11
   \       0xE0   0x.... 0x....      BL       __aeabi_fmul
   \       0xE4   0x4649             MOV      R1,R9
   \       0xE6   0x.... 0x....      BL       __aeabi_fsub
   \       0xEA   0x4631             MOV      R1,R6
   \       0xEC   0x.... 0x....      BL       __aeabi_fadd
   \       0xF0   0x4606             MOV      R6,R0
   \       0xF2   0x4640             MOV      R0,R8
   \       0xF4   0x4659             MOV      R1,R11
   \       0xF6   0x.... 0x....      BL       __aeabi_fmul
   \       0xFA   0x4651             MOV      R1,R10
   \       0xFC   0x.... 0x....      BL       __aeabi_fsub
   \      0x100   0x4631             MOV      R1,R6
   \      0x102   0x.... 0x....      BL       __aeabi_fadd
   \      0x106   0x.... 0x....      LDR.W    R1,??DataTable131  ;; 0x40400000
   \      0x10A   0x.... 0x....      BL       __aeabi_fdiv
   \      0x10E   0xF844 0x0025      STR      R0,[R4, R5, LSL #+2]
   3142          
   3143              // Median is robust (ignores outliers).
   3144              // z_values[x][y] = (a < b) ? ((b < c) ? b : (c < a) ? a : c)
   3145              //                                : ((c < b) ? b : (a < c) ? a : c);
   3146            }
   \                     ??extrapolate_one_point_0: (+1)
   \      0x112   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
   3147          
   3148            //Enable this if your SCARA uses 180Â° of total area
   3149            //#define EXTRAPOLATE_FROM_EDGE
   3150          
   3151            #if ENABLED(EXTRAPOLATE_FROM_EDGE)
   3152              #if GRID_MAX_POINTS_X < GRID_MAX_POINTS_Y
   3153                #define HALF_IN_X
   3154              #elif GRID_MAX_POINTS_Y < GRID_MAX_POINTS_X
   3155                #define HALF_IN_Y
   3156              #endif
   3157            #endif
   3158          
   3159            /**
   3160             * Fill in the unprobed points (corners of circular print surface)
   3161             * using linear extrapolation, away from the center.
   3162             */

   \                                 In section .text, align 2, keep-with-next
   3163            static void extrapolate_unprobed_bed_level() {
   \                     _ZN37_INTERNAL_15_Marlin_main_cpp_3178531930extrapolate_unprobed_bed_levelEv: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   3164              #ifdef HALF_IN_X
   3165                constexpr uint8_t ctrx2 = 0, xlen = GRID_MAX_POINTS_X - 1;
   3166              #else
   3167                constexpr uint8_t ctrx1 = (GRID_MAX_POINTS_X - 1) / 2, // left-of-center
   \        0x4   0x.... 0x....      LDR.W    R0,??DataTable131_1
   \        0x8   0x7805             LDRB     R5,[R0, #+0]
   \        0xA   0x462C             MOV      R4,R5
   \        0xC   0x1E64             SUBS     R4,R4,#+1
   \        0xE   0xEB04 0x74D4      ADD      R4,R4,R4, LSR #+31
   \       0x12   0x1064             ASRS     R4,R4,#+1
   \       0x14   0xB2E4             UXTB     R4,R4
   3168                                  ctrx2 = (GRID_MAX_POINTS_X) / 2,     // right-of-center
   3169                                  xlen = ctrx1;
   \       0x16   0x4621             MOV      R1,R4
   \       0x18   0x9101             STR      R1,[SP, #+4]
   3170              #endif
   3171          
   3172              #ifdef HALF_IN_Y
   3173                constexpr uint8_t ctry2 = 0, ylen = GRID_MAX_POINTS_Y - 1;
   3174              #else
   3175                constexpr uint8_t ctry1 = (GRID_MAX_POINTS_Y - 1) / 2, // top-of-center
   \       0x1A   0x7847             LDRB     R7,[R0, #+1]
   \       0x1C   0x463E             MOV      R6,R7
   \       0x1E   0x1E76             SUBS     R6,R6,#+1
   \       0x20   0xEB06 0x76D6      ADD      R6,R6,R6, LSR #+31
   \       0x24   0x1076             ASRS     R6,R6,#+1
   \       0x26   0xB2F6             UXTB     R6,R6
   3176                                  ctry2 = (GRID_MAX_POINTS_Y) / 2,     // bottom-of-center
   3177                                  ylen = ctry1;
   \       0x28   0x46B0             MOV      R8,R6
   3178              #endif
   3179          
   3180              for (uint8_t xo = 0; xo <= xlen; xo++)
   \       0x2A   0xF04F 0x0900      MOV      R9,#+0
   \       0x2E   0xE03A             B.N      ??extrapolate_unprobed_bed_level_0
   3181                for (uint8_t yo = 0; yo <= ylen; yo++) {
   3182                  uint8_t x2 = ctrx2 + xo, y2 = ctry2 + yo;
   \                     ??extrapolate_unprobed_bed_level_1: (+1)
   \       0x30   0xEB09 0x0055      ADD      R0,R9,R5, LSR #+1
   \       0x34   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \       0x38   0xEB0A 0x0057      ADD      R0,R10,R7, LSR #+1
   \       0x3C   0xF88D 0x0001      STRB     R0,[SP, #+1]
   3183                  #ifndef HALF_IN_X
   3184                    const uint8_t x1 = ctrx1 - xo;
   \       0x40   0xEBA4 0x0009      SUB      R0,R4,R9
   \       0x44   0xF88D 0x0000      STRB     R0,[SP, #+0]
   3185                  #endif
   3186                  #ifndef HALF_IN_Y
   3187                    const uint8_t y1 = ctry1 - yo;
   \       0x48   0xEBA6 0x0B0A      SUB      R11,R6,R10
   3188                    #ifndef HALF_IN_X
   3189                      extrapolate_one_point(x1, y1, +1, +1);   //  left-below + +
   \       0x4C   0x2301             MOVS     R3,#+1
   \       0x4E   0x461A             MOV      R2,R3
   \       0x50   0x4659             MOV      R1,R11
   \       0x52   0xB2C9             UXTB     R1,R1
   \       0x54   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x58   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531921extrapolate_one_pointEhhaa
   3190                    #endif
   3191                    extrapolate_one_point(x2, y1, -1, +1);     // right-below - +
   \       0x5C   0x2301             MOVS     R3,#+1
   \       0x5E   0xF04F 0x32FF      MOV      R2,#-1
   \       0x62   0x4659             MOV      R1,R11
   \       0x64   0xB2C9             UXTB     R1,R1
   \       0x66   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \       0x6A   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531921extrapolate_one_pointEhhaa
   3192                  #endif
   3193                  #ifndef HALF_IN_X
   3194                    extrapolate_one_point(x1, y2, +1, -1);     //  left-above + -
   \       0x6E   0xF04F 0x33FF      MOV      R3,#-1
   \       0x72   0x2201             MOVS     R2,#+1
   \       0x74   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \       0x78   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x7C   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531921extrapolate_one_pointEhhaa
   3195                  #endif
   3196                  extrapolate_one_point(x2, y2, -1, -1);       // right-above - -
   \       0x80   0xF04F 0x33FF      MOV      R3,#-1
   \       0x84   0x461A             MOV      R2,R3
   \       0x86   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \       0x8A   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \       0x8E   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531921extrapolate_one_pointEhhaa
   3197                }
   \       0x92   0xF10A 0x0A01      ADD      R10,R10,#+1
   \       0x96   0xFA5F 0xFA8A      UXTB     R10,R10
   \                     ??extrapolate_unprobed_bed_level_2: (+1)
   \       0x9A   0x45D0             CMP      R8,R10
   \       0x9C   0xDAC8             BGE.N    ??extrapolate_unprobed_bed_level_1
   \       0x9E   0xF109 0x0901      ADD      R9,R9,#+1
   \       0xA2   0xFA5F 0xF989      UXTB     R9,R9
   \                     ??extrapolate_unprobed_bed_level_0: (+1)
   \       0xA6   0x9801             LDR      R0,[SP, #+4]
   \       0xA8   0x4548             CMP      R0,R9
   \       0xAA   0xDB02             BLT.N    ??extrapolate_unprobed_bed_level_3
   \       0xAC   0xF04F 0x0A00      MOV      R10,#+0
   \       0xB0   0xE7F3             B.N      ??extrapolate_unprobed_bed_level_2
   3198          
   3199            }
   \                     ??extrapolate_unprobed_bed_level_3: (+1)
   \       0xB2   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
   3200          

   \                                 In section .text, align 2, keep-with-next
   3201            static void print_bilinear_leveling_grid() {
   \                     _ZN37_INTERNAL_15_Marlin_main_cpp_3178531928print_bilinear_leveling_gridEv: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   3202              SERIAL_ECHOLNPGM("Bilinear Leveling Grid:");
   \        0x2   0x.... 0x....      ADR.W    R0,?_13
   \        0x6   0x.... 0x....      BL       _Z14serialprintPGMPKc
   3203          	/*--mks cfg-- LCD_ MESH_BED_LEVELING */
   3204          	/*
   3205              print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 3,
   3206                [](const uint8_t ix, const uint8_t iy) { return z_values[ix][iy]; }
   3207              );
   3208          	*/
   3209              print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 3,0);
   \        0xA   0x.... 0x....      LDR.W    R0,??DataTable131_1
   \        0xE   0x2300             MOVS     R3,#+0
   \       0x10   0x2203             MOVS     R2,#+3
   \       0x12   0x7841             LDRB     R1,[R0, #+1]
   \       0x14   0x7800             LDRB     R0,[R0, #+0]
   \       0x16   0xE8BD 0x5000      POP      {R12,LR}
   \       0x1A   0x....             B.N      _ZN37_INTERNAL_15_Marlin_main_cpp_3178531914print_2d_arrayEhhhh
   3210            }
   3211          
   3212            #if ENABLED(ABL_BILINEAR_SUBDIVISION)
   3213          
   3214              #define ABL_GRID_POINTS_VIRT_X (GRID_MAX_POINTS_X - 1) * (BILINEAR_SUBDIVISIONS) + 1
   3215              #define ABL_GRID_POINTS_VIRT_Y (GRID_MAX_POINTS_Y - 1) * (BILINEAR_SUBDIVISIONS) + 1
   3216              #define ABL_TEMP_POINTS_X (GRID_MAX_POINTS_X + 2)
   3217              #define ABL_TEMP_POINTS_Y (GRID_MAX_POINTS_Y + 2)
   3218              float z_values_virt[ABL_GRID_POINTS_VIRT_X][ABL_GRID_POINTS_VIRT_Y];
   3219              int bilinear_grid_spacing_virt[2] = { 0 };
   3220              float bilinear_grid_factor_virt[2] = { 0 };
   3221          
   3222              static void bed_level_virt_print() {
   3223                SERIAL_ECHOLNPGM("Subdivided with CATMULL ROM Leveling Grid:");
   3224          	  /*--mks cfg-- LCD_ MESH_BED_LEVELING */
   3225          	  /*
   3226                print_2d_array(ABL_GRID_POINTS_VIRT_X, ABL_GRID_POINTS_VIRT_Y, 5,
   3227                  [](const uint8_t ix, const uint8_t iy) { return z_values_virt[ix][iy]; }
   3228                );*/
   3229                print_2d_array(ABL_GRID_POINTS_VIRT_X, ABL_GRID_POINTS_VIRT_Y, 5,1);
   3230              }
   3231          
   3232              #define LINEAR_EXTRAPOLATION(E, I) ((E) * 2 - (I))
   3233              float bed_level_virt_coord(const uint8_t x, const uint8_t y) {
   3234                uint8_t ep = 0, ip = 1;
   3235                if (!x || x == ABL_TEMP_POINTS_X - 1) {
   3236                  if (x) {
   3237                    ep = GRID_MAX_POINTS_X - 1;
   3238                    ip = GRID_MAX_POINTS_X - 2;
   3239                  }
   3240                  if (WITHIN(y, 1, ABL_TEMP_POINTS_Y - 2))
   3241                    return LINEAR_EXTRAPOLATION(
   3242                      z_values[ep][y - 1],
   3243                      z_values[ip][y - 1]
   3244                    );
   3245                  else
   3246                    return LINEAR_EXTRAPOLATION(
   3247                      bed_level_virt_coord(ep + 1, y),
   3248                      bed_level_virt_coord(ip + 1, y)
   3249                    );
   3250                }
   3251                if (!y || y == ABL_TEMP_POINTS_Y - 1) {
   3252                  if (y) {
   3253                    ep = GRID_MAX_POINTS_Y - 1;
   3254                    ip = GRID_MAX_POINTS_Y - 2;
   3255                  }
   3256                  if (WITHIN(x, 1, ABL_TEMP_POINTS_X - 2))
   3257                    return LINEAR_EXTRAPOLATION(
   3258                      z_values[x - 1][ep],
   3259                      z_values[x - 1][ip]
   3260                    );
   3261                  else
   3262                    return LINEAR_EXTRAPOLATION(
   3263                      bed_level_virt_coord(x, ep + 1),
   3264                      bed_level_virt_coord(x, ip + 1)
   3265                    );
   3266                }
   3267                return z_values[x - 1][y - 1];
   3268              }
   3269          
   3270              static float bed_level_virt_cmr(const float p[4], const uint8_t i, const float t) {
   3271                return (
   3272                    p[i-1] * -t * sq(1 - t)
   3273                  + p[i]   * (2 - 5 * sq(t) + 3 * t * sq(t))
   3274                  + p[i+1] * t * (1 + 4 * t - 3 * sq(t))
   3275                  - p[i+2] * sq(t) * (1 - t)
   3276                ) * 0.5;
   3277              }
   3278          
   3279              static float bed_level_virt_2cmr(const uint8_t x, const uint8_t y, const float &tx, const float &ty) {
   3280                float row[4], column[4];
   3281                for (uint8_t i = 0; i < 4; i++) {
   3282                  for (uint8_t j = 0; j < 4; j++) {
   3283                    column[j] = bed_level_virt_coord(i + x - 1, j + y - 1);
   3284                  }
   3285                  row[i] = bed_level_virt_cmr(column, 1, ty);
   3286                }
   3287                return bed_level_virt_cmr(row, 1, tx);
   3288              }
   3289          
   3290              void bed_level_virt_interpolate() {
   3291                bilinear_grid_spacing_virt[X_AXIS] = bilinear_grid_spacing[X_AXIS] / (BILINEAR_SUBDIVISIONS);
   3292                bilinear_grid_spacing_virt[Y_AXIS] = bilinear_grid_spacing[Y_AXIS] / (BILINEAR_SUBDIVISIONS);
   3293                bilinear_grid_factor_virt[X_AXIS] = RECIPROCAL(bilinear_grid_spacing_virt[X_AXIS]);
   3294                bilinear_grid_factor_virt[Y_AXIS] = RECIPROCAL(bilinear_grid_spacing_virt[Y_AXIS]);
   3295                for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
   3296                  for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
   3297                    for (uint8_t ty = 0; ty < BILINEAR_SUBDIVISIONS; ty++)
   3298                      for (uint8_t tx = 0; tx < BILINEAR_SUBDIVISIONS; tx++) {
   3299                        if ((ty && y == GRID_MAX_POINTS_Y - 1) || (tx && x == GRID_MAX_POINTS_X - 1))
   3300                          continue;
   3301                        z_values_virt[x * (BILINEAR_SUBDIVISIONS) + tx][y * (BILINEAR_SUBDIVISIONS) + ty] =
   3302                          bed_level_virt_2cmr(
   3303                            x + 1,
   3304                            y + 1,
   3305                            (float)tx / (BILINEAR_SUBDIVISIONS),
   3306                            (float)ty / (BILINEAR_SUBDIVISIONS)
   3307                          );
   3308                      }
   3309              }
   3310            #endif // ABL_BILINEAR_SUBDIVISION
   3311          
   3312            // Refresh after other values have been updated

   \                                 In section .text, align 2, keep-with-next
   3313            void refresh_bed_level() {
   \                     _Z17refresh_bed_levelv: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   3314              bilinear_grid_factor[X_AXIS] = RECIPROCAL(bilinear_grid_spacing[X_AXIS]);
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable126_5
   \        0x6   0x68A0             LDR      R0,[R4, #+8]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD101             BNE.N    ??refresh_bed_level_0
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0xE00A             B.N      ??refresh_bed_level_1
   \                     ??refresh_bed_level_0: (+1)
   \       0x10   0x.... 0x....      BL       __aeabi_i2d
   \       0x14   0x4602             MOV      R2,R0
   \       0x16   0x460B             MOV      R3,R1
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x.... 0x....      LDR.W    R1,??DataTable133  ;; 0x3ff00000
   \       0x1E   0x.... 0x....      BL       __aeabi_ddiv
   \       0x22   0x.... 0x....      BL       __aeabi_d2f
   \                     ??refresh_bed_level_1: (+1)
   \       0x26   0x61A0             STR      R0,[R4, #+24]
   3315              bilinear_grid_factor[Y_AXIS] = RECIPROCAL(bilinear_grid_spacing[Y_AXIS]);
   \       0x28   0x68E0             LDR      R0,[R4, #+12]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD101             BNE.N    ??refresh_bed_level_2
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0xE00A             B.N      ??refresh_bed_level_3
   \                     ??refresh_bed_level_2: (+1)
   \       0x32   0x.... 0x....      BL       __aeabi_i2d
   \       0x36   0x4602             MOV      R2,R0
   \       0x38   0x460B             MOV      R3,R1
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x.... 0x....      LDR.W    R1,??DataTable133  ;; 0x3ff00000
   \       0x40   0x.... 0x....      BL       __aeabi_ddiv
   \       0x44   0x.... 0x....      BL       __aeabi_d2f
   \                     ??refresh_bed_level_3: (+1)
   \       0x48   0x61E0             STR      R0,[R4, #+28]
   3316              #if ENABLED(ABL_BILINEAR_SUBDIVISION)
   3317                bed_level_virt_interpolate();
   3318              #endif
   3319            }
   \       0x4A   0xBD10             POP      {R4,PC}          ;; return
   3320          
   3321          #endif // AUTO_BED_LEVELING_BILINEAR
   3322          
   3323          /**
   3324           * Home an individual linear axis
   3325           */

   \                                 In section .text, align 2, keep-with-next
   3326          static void do_homing_move(const AxisEnum axis, float distance, float fr_mm_s=0.0) {
   \                     _ZN37_INTERNAL_15_Marlin_main_cpp_3178531914do_homing_moveE8AxisEnumff: (+1)
   \        0x0   0xB5F7             PUSH     {R0-R2,R4-R7,LR}
   \        0x2   0x460D             MOV      R5,R1
   3327          
   3328            #if ENABLED(DEBUG_LEVELING_FEATURE)
   3329              if (DEBUGGING(LEVELING)) {
   3330                SERIAL_ECHOPAIR(">>> do_homing_move(", axis_codes[axis]);
   3331                SERIAL_ECHOPAIR(", ", distance);
   3332                SERIAL_ECHOPAIR(", ", fr_mm_s);
   3333                SERIAL_CHAR(')');
   3334                SERIAL_EOL;
   3335              }
   3336            #endif
   3337          
   3338            #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
   3339            if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)){	/*--mks cfg--*/
   3340              const bool deploy_bltouch = (axis == Z_AXIS && distance < 0);
   3341              if (deploy_bltouch) set_bltouch_deployed(true);
   3342            		}
   3343            #endif
   3344          
   3345          #if QUIET_PROBING
   3346              if (axis == Z_AXIS) probing_pause(true);
   3347          #endif
   3348          
   3349            // Tell the planner we're at Z=0
   3350            current_position[axis] = 0;
   \        0x4   0x.... 0x....      LDR.W    R4,??DataTable126_1
   \        0x8   0xEB04 0x0680      ADD      R6,R4,R0, LSL #+2
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x60B0             STR      R0,[R6, #+8]
   3351          
   3352           // #if IS_SCARA	//mks_delta
   3353           if(MACHINETPYE&IS_SCARA) { 	
   \       0x10   0x.... 0x....      LDR.W    R7,??DataTable126_2
   \       0x14   0xF8B7 0x0058      LDRH     R0,[R7, #+88]
   \       0x18   0xF410 0x7F40      TST      R0,#0x300
   \       0x1C   0xD022             BEQ.N    ??do_homing_move_0
   3354              SYNC_PLAN_POSITION_KINEMATIC();
   \       0x1E   0x.... 0x....      BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
   3355              current_position[axis] = distance;
   \       0x22   0x60B5             STR      R5,[R6, #+8]
   3356          	if(MACHINETPYE&IS_SCARA)
   \       0x24   0xF8B7 0x0058      LDRH     R0,[R7, #+88]
   \       0x28   0xF410 0x7F40      TST      R0,#0x300
   \       0x2C   0xF104 0x0008      ADD      R0,R4,#+8
   \       0x30   0xD002             BEQ.N    ??do_homing_move_1
   3357          		inverse_kinematics_MORGAN_SCARA(current_position);
   \       0x32   0x.... 0x....      BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
   \       0x36   0xE001             B.N      ??do_homing_move_2
   3358          		else
   3359          	    inverse_kinematics(current_position);
   \                     ??do_homing_move_1: (+1)
   \       0x38   0x.... 0x....      BL       _Z18inverse_kinematicsPKf
   3360              planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate_mm_s[axis], active_extruder);
   \                     ??do_homing_move_2: (+1)
   \       0x3C   0x9802             LDR      R0,[SP, #+8]
   \       0x3E   0x2100             MOVS     R1,#+0
   \       0x40   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0x44   0xD001             BEQ.N    ??do_homing_move_3
   \       0x46   0xA802             ADD      R0,SP,#+8
   \       0x48   0xE001             B.N      ??do_homing_move_4
   \                     ??do_homing_move_3: (+1)
   \       0x4A   0xF106 0x0028      ADD      R0,R6,#+40
   \                     ??do_homing_move_4: (+1)
   \       0x4E   0x78A1             LDRB     R1,[R4, #+2]
   \       0x50   0x9101             STR      R1,[SP, #+4]
   \       0x52   0x9000             STR      R0,[SP, #+0]
   \       0x54   0xF104 0x0314      ADD      R3,R4,#+20
   \       0x58   0x6F22             LDR      R2,[R4, #+112]
   \       0x5A   0x6EE1             LDR      R1,[R4, #+108]
   \       0x5C   0x6EA0             LDR      R0,[R4, #+104]
   \       0x5E   0x.... 0x....      BL       _ZN7Planner11buffer_lineEfffRKfS1_h
   \       0x62   0xE015             B.N      ??do_homing_move_5
   3361           	}
   3362          //  #else
   3363          	else
   3364          		{
   3365              sync_plan_position();
   \                     ??do_homing_move_0: (+1)
   \       0x64   0x.... 0x....      BL       _Z18sync_plan_positionv
   3366              current_position[axis] = distance;
   \       0x68   0x60B5             STR      R5,[R6, #+8]
   3367              planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate_mm_s[axis], active_extruder);
   \       0x6A   0x9802             LDR      R0,[SP, #+8]
   \       0x6C   0x2100             MOVS     R1,#+0
   \       0x6E   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0x72   0xD001             BEQ.N    ??do_homing_move_6
   \       0x74   0xA802             ADD      R0,SP,#+8
   \       0x76   0xE001             B.N      ??do_homing_move_7
   \                     ??do_homing_move_6: (+1)
   \       0x78   0xF106 0x0028      ADD      R0,R6,#+40
   \                     ??do_homing_move_7: (+1)
   \       0x7C   0x78A1             LDRB     R1,[R4, #+2]
   \       0x7E   0x9101             STR      R1,[SP, #+4]
   \       0x80   0x9000             STR      R0,[SP, #+0]
   \       0x82   0xF104 0x0314      ADD      R3,R4,#+20
   \       0x86   0x6922             LDR      R2,[R4, #+16]
   \       0x88   0x68E1             LDR      R1,[R4, #+12]
   \       0x8A   0x68A0             LDR      R0,[R4, #+8]
   \       0x8C   0x.... 0x....      BL       _ZN7Planner11buffer_lineEfffRKfS1_h
   3368          		}
   3369            //#endif
   3370          
   3371            stepper.synchronize();
   \                     ??do_homing_move_5: (+1)
   \       0x90   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   3372          
   3373          #if QUIET_PROBING
   3374              if (axis == Z_AXIS) probing_pause(false);
   3375          #endif
   3376          
   3377            #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
   3378            if((Z_HOME_DIR < 0) &&  (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))	/*--mks cfg--*/
   3379            	{
   3380              if (deploy_bltouch) set_bltouch_deployed(false);
   3381            	}
   3382            #endif
   3383          
   3384            endstops.hit_on_purpose();
   \       0x94   0x.... 0x....      BL       _ZN8Endstops14hit_on_purposeEv
   3385          
   3386            #if ENABLED(DEBUG_LEVELING_FEATURE)
   3387              if (DEBUGGING(LEVELING)) {
   3388                SERIAL_ECHOPAIR("<<< do_homing_move(", axis_codes[axis]);
   3389                SERIAL_CHAR(')');
   3390                SERIAL_EOL;
   3391              }
   3392            #endif
   3393          }
   \       0x98   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
   3394          
   3395          /**
   3396           * TMC2130 specific sensorless homing using stallGuard2.
   3397           * stallGuard2 only works when in spreadCycle mode.
   3398           * spreadCycle and stealthChop are mutually exclusive.
   3399           */
   3400          #if ENABLED(SENSORLESS_HOMING)
   3401            void tmc2130_sensorless_homing(TMC2130Stepper &st, bool enable=true) {
   3402              #if ENABLED(STEALTHCHOP)
   3403                if (enable) {
   3404                  st.coolstep_min_speed(1024UL * 1024UL - 1UL);
   3405                  st.stealthChop(0);
   3406                }
   3407                else {
   3408                  st.coolstep_min_speed(0);
   3409                  st.stealthChop(1);
   3410                }
   3411              #endif
   3412          
   3413              st.diag1_stall(enable ? 1 : 0);
   3414            }
   3415          #endif
   3416          
   3417          /**
   3418           * Home an individual "raw axis" to its endstop.
   3419           * This applies to XYZ on Cartesian and Core robots, and
   3420           * to the individual ABC steppers on DELTA and SCARA.
   3421           *
   3422           * At the end of the procedure the axis is marked as
   3423           * homed and the current position of that axis is updated.
   3424           * Kinematic robots should wait till all axes are homed
   3425           * before updating the current position.
   3426           */
   3427          
   3428          #define HOMEAXIS(LETTER) homeaxis(LETTER##_AXIS)
   3429          

   \                                 In section .text, align 2, keep-with-next
   3430          static void homeaxis(const AxisEnum axis) {
   \                     _ZN37_INTERNAL_15_Marlin_main_cpp_317853198homeaxisE8AxisEnum: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4604             MOV      R4,R0
   3431          
   3432            //#if IS_SCARA
   3433          #define CAN_HOME(A) \
   3434          	(axis == A##_AXIS && ((A##_MIN_PIN > -1 && A##_HOME_DIR < 0) || (A##_MAX_PIN > -1 && A##_HOME_DIR > 0)))
   3435          
   3436            if(MACHINETPYE&IS_SCARA)
   \        0x6   0x....             LDR.N    R5,??DataTable126_2
   \        0x8   0xF8B5 0x0058      LDRH     R0,[R5, #+88]
   \        0xC   0xF410 0x7F40      TST      R0,#0x300
   \       0x10   0xD016             BEQ.N    ??homeaxis_0
   3437              // Only Z homing (with probe) is permitted
   3438              if (axis != Z_AXIS) { BUZZ(100, 880); return; }
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0x2802             CMP      R0,#+2
   \       0x16   0xD00E             BEQ.N    ??homeaxis_1
   \       0x18   0x2064             MOVS     R0,#+100
   \       0x1A   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   \       0x1E   0xF44F 0x705C      MOV      R0,#+880
   \       0x22   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \       0x26   0x466A             MOV      R2,SP
   \       0x28   0xF10D 0x0102      ADD      R1,SP,#+2
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable133_3
   \       0x30   0x.... 0x....      BL       _ZN6Buzzer4toneERKtS1_
   \       0x34   0xE0BC             B.N      ??homeaxis_2
   \                     ??homeaxis_1: (+1)
   \       0x36   0xF995 0x0006      LDRSB    R0,[R5, #+6]
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xF000 0x80B8      BEQ.W    ??homeaxis_2
   3439            //#else
   3440            else
   3441              if (!CAN_HOME(X) && !CAN_HOME(Y) && !CAN_HOME(Z)) return;
   3442            //#endif
   3443          
   3444            #if ENABLED(DEBUG_LEVELING_FEATURE)
   3445              if (DEBUGGING(LEVELING)) {
   3446                SERIAL_ECHOPAIR(">>> homeaxis(", axis_codes[axis]);
   3447                SERIAL_CHAR(')');
   3448                SERIAL_EOL;
   3449              }
   3450            #endif
   3451          
   3452            const int axis_home_dir =
   3453              #if ENABLED(DUAL_X_CARRIAGE)
   3454                (axis == X_AXIS) ? x_home_dir(active_extruder) :
   3455              #endif
   3456              home_dir(axis);
   \                     ??homeaxis_0: (+1)
   \       0x40   0x4620             MOV      R0,R4
   \       0x42   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_317853198home_dirE8AxisEnum
   \       0x46   0x4606             MOV      R6,R0
   3457          
   3458            // Homing Z towards the bed? Deploy the Z probe or endstop.
   3459            #if HOMING_Z_WITH_PROBE
   3460            if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))	/*--mks cfg--*/
   \       0x48   0xF995 0x0006      LDRSB    R0,[R5, #+6]
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD50C             BPL.N    ??homeaxis_3
   \       0x50   0xF895 0x0099      LDRB     R0,[R5, #+153]
   \       0x54   0x2801             CMP      R0,#+1
   \       0x56   0xD108             BNE.N    ??homeaxis_3
   3461             { if (axis == Z_AXIS && DEPLOY_PROBE()) return;}
   \       0x58   0x4620             MOV      R0,R4
   \       0x5A   0x2802             CMP      R0,#+2
   \       0x5C   0xD105             BNE.N    ??homeaxis_3
   \       0x5E   0x2001             MOVS     R0,#+1
   \       0x60   0x.... 0x....      BL       _Z18set_probe_deployedb
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xF040 0x80A3      BNE.W    ??homeaxis_2
   3462            #endif
   3463          
   3464            // Set a flag for Z motor locking
   3465            #if ENABLED(Z_DUAL_ENDSTOPS)
   3466              if (axis == Z_AXIS) stepper.set_homing_flag(true);
   3467            #endif
   3468          
   3469            // Disable stealthChop if used. Enable diag1 pin on driver.
   3470            #if ENABLED(SENSORLESS_HOMING)
   3471              #if ENABLED(X_IS_TMC2130)
   3472                if (axis == X_AXIS) tmc2130_sensorless_homing(stepperX);
   3473              #endif
   3474              #if ENABLED(Y_IS_TMC2130)
   3475                if (axis == Y_AXIS) tmc2130_sensorless_homing(stepperY);
   3476              #endif
   3477            #endif
   3478          
   3479            // Fast move towards endstop until triggered
   3480            #if ENABLED(DEBUG_LEVELING_FEATURE)
   3481              if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 1 Fast:");
   3482            #endif
   3483            do_homing_move(axis, 1.1 * max_length(axis) * axis_home_dir);
   \                     ??homeaxis_3: (+1)
   \       0x6A   0x4620             MOV      R0,R4
   \       0x6C   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531910max_lengthE8AxisEnum
   \       0x70   0x2200             MOVS     R2,#+0
   \       0x72   0x4617             MOV      R7,R2
   \       0x74   0x.... 0x....      BL       __aeabi_f2d
   \       0x78   0x.... 0x....      LDR.W    R2,??DataTable133_4  ;; 0x9999999a
   \       0x7C   0x.... 0x....      LDR.W    R3,??DataTable133_5  ;; 0x3ff19999
   \       0x80   0x.... 0x....      BL       __aeabi_dmul
   \       0x84   0x4680             MOV      R8,R0
   \       0x86   0x4689             MOV      R9,R1
   \       0x88   0x4630             MOV      R0,R6
   \       0x8A   0x.... 0x....      BL       __aeabi_i2d
   \       0x8E   0x4642             MOV      R2,R8
   \       0x90   0x464B             MOV      R3,R9
   \       0x92   0x.... 0x....      BL       __aeabi_dmul
   \       0x96   0x.... 0x....      BL       __aeabi_d2f
   \       0x9A   0x4601             MOV      R1,R0
   \       0x9C   0x463A             MOV      R2,R7
   \       0x9E   0x4620             MOV      R0,R4
   \       0xA0   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531914do_homing_moveE8AxisEnumff
   3484          
   3485            // When homing Z with probe respect probe clearance
   3486            /*--mks cfg begin--*/
   3487          /*  
   3488            const float bump = axis_home_dir * (
   3489            #if HOMING_Z_WITH_PROBE
   3490                (axis == Z_AXIS) ? max(Z_CLEARANCE_BETWEEN_PROBES, home_bump_mm(Z_AXIS)) :
   3491            #endif
   3492              home_bump_mm(axis)
   3493            );
   3494          */
   3495          
   3496          float bump = 0;
   3497          #if HOMING_Z_WITH_PROBE
   3498          	if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))	/*--mks cfg--*/
   \       0xA4   0xF995 0x0006      LDRSB    R0,[R5, #+6]
   \       0xA8   0x2800             CMP      R0,#+0
   \       0xAA   0xD51F             BPL.N    ??homeaxis_4
   \       0xAC   0xF895 0x0099      LDRB     R0,[R5, #+153]
   \       0xB0   0x2801             CMP      R0,#+1
   \       0xB2   0xD11B             BNE.N    ??homeaxis_4
   3499          		bump = axis_home_dir*((axis == Z_AXIS) ? max(Z_CLEARANCE_BETWEEN_PROBES, home_bump_mm(Z_AXIS)) :home_bump_mm(axis));
   \       0xB4   0x4620             MOV      R0,R4
   \       0xB6   0x2802             CMP      R0,#+2
   \       0xB8   0xD10C             BNE.N    ??homeaxis_5
   \       0xBA   0x6EAF             LDR      R7,[R5, #+104]
   \       0xBC   0x2002             MOVS     R0,#+2
   \       0xBE   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531912home_bump_mmE8AxisEnum
   \       0xC2   0x4639             MOV      R1,R7
   \       0xC4   0x.... 0x....      BL       __aeabi_cfcmple
   \       0xC8   0xD307             BCC.N    ??homeaxis_6
   \       0xCA   0x2002             MOVS     R0,#+2
   \       0xCC   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531912home_bump_mmE8AxisEnum
   \       0xD0   0x4607             MOV      R7,R0
   \       0xD2   0xE002             B.N      ??homeaxis_6
   \                     ??homeaxis_5: (+1)
   \       0xD4   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531912home_bump_mmE8AxisEnum
   \       0xD8   0x4607             MOV      R7,R0
   \                     ??homeaxis_6: (+1)
   \       0xDA   0x4630             MOV      R0,R6
   \       0xDC   0x.... 0x....      BL       __aeabi_i2f
   \       0xE0   0x4601             MOV      R1,R0
   \       0xE2   0x4638             MOV      R0,R7
   \       0xE4   0x.... 0x....      BL       __aeabi_fmul
   \       0xE8   0x4606             MOV      R6,R0
   \       0xEA   0xE00B             B.N      ??homeaxis_7
   3500          	else
   3501          		bump = axis_home_dir *home_bump_mm(axis);
   \                     ??homeaxis_4: (+1)
   \       0xEC   0x4630             MOV      R0,R6
   \       0xEE   0x.... 0x....      BL       __aeabi_i2f
   \       0xF2   0x4606             MOV      R6,R0
   \       0xF4   0x4620             MOV      R0,R4
   \       0xF6   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531912home_bump_mmE8AxisEnum
   \       0xFA   0x4601             MOV      R1,R0
   \       0xFC   0x4630             MOV      R0,R6
   \       0xFE   0x.... 0x....      BL       __aeabi_fmul
   \      0x102   0x4606             MOV      R6,R0
   3502          #else
   3503          	bump = axis_home_dir *home_bump_mm(axis);
   3504          #endif
   3505          
   3506          
   3507          ///////////////////////////
   3508          /*
   3509           float bump;
   3510          #if HOMING_Z_WITH_PROBE
   3511          if(Z_HOME_DIR < 0)
   3512          	bump = axis_home_dir * ((axis == Z_AXIS) ? max(Z_CLEARANCE_BETWEEN_PROBES, home_bump_mm(Z_AXIS)) :home_bump_mm(axis));
   3513          #else
   3514          	bump = axis_home_dir * (home_bump_mm(axis));
   3515          #endif
   3516          */	
   3517          	/*--mks cfg end--*/
   3518          
   3519            // If a second homing move is configured...
   3520            if (bump) {
   \                     ??homeaxis_7: (+1)
   \      0x104   0x4630             MOV      R0,R6
   \      0x106   0x2100             MOVS     R1,#+0
   \      0x108   0x.... 0x....      BL       __aeabi_cfcmpeq
   \      0x10C   0xD015             BEQ.N    ??homeaxis_8
   3521              // Move away from the endstop by the axis HOME_BUMP_MM
   3522              #if ENABLED(DEBUG_LEVELING_FEATURE)
   3523                if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Move Away:");
   3524              #endif
   3525              do_homing_move(axis, -bump);
   \      0x10E   0x460A             MOV      R2,R1
   \      0x110   0x4631             MOV      R1,R6
   \      0x112   0xF081 0x4100      EOR      R1,R1,#0x80000000
   \      0x116   0x4620             MOV      R0,R4
   \      0x118   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531914do_homing_moveE8AxisEnumff
   3526          
   3527              // Slow move towards endstop until triggered
   3528              #if ENABLED(DEBUG_LEVELING_FEATURE)
   3529                if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 2 Slow:");
   3530              #endif
   3531              do_homing_move(axis, 2 * bump, get_homing_bump_feedrate(axis));
   \      0x11C   0x4620             MOV      R0,R4
   \      0x11E   0x.... 0x....      BL       _Z24get_homing_bump_feedrate8AxisEnum
   \      0x122   0x4602             MOV      R2,R0
   \      0x124   0x4617             MOV      R7,R2
   \      0x126   0xF04F 0x4180      MOV      R1,#+1073741824
   \      0x12A   0x4630             MOV      R0,R6
   \      0x12C   0x.... 0x....      BL       __aeabi_fmul
   \      0x130   0x4601             MOV      R1,R0
   \      0x132   0x463A             MOV      R2,R7
   \      0x134   0x4620             MOV      R0,R4
   \      0x136   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531914do_homing_moveE8AxisEnumff
   3532            }
   3533          
   3534            #if ENABLED(Z_DUAL_ENDSTOPS)
   3535              if (axis == Z_AXIS) {
   3536                float adj = fabs(z_endstop_adj);
   3537                bool lockZ1;
   3538                if (axis_home_dir > 0) {
   3539                  adj = -adj;
   3540                  lockZ1 = (z_endstop_adj > 0);
   3541                }
   3542                else
   3543                  lockZ1 = (z_endstop_adj < 0);
   3544          
   3545                if (lockZ1) stepper.set_z_lock(true); else stepper.set_z2_lock(true);
   3546          
   3547                // Move to the adjusted endstop height
   3548                do_homing_move(axis, adj);
   3549          
   3550                if (lockZ1) stepper.set_z_lock(false); else stepper.set_z2_lock(false);
   3551                stepper.set_homing_flag(false);
   3552              } // Z_AXIS
   3553            #endif
   3554          
   3555           // #if IS_SCARA
   3556            if(MACHINETPYE&IS_SCARA)
   \                     ??homeaxis_8: (+1)
   \      0x13A   0xF9B5 0x0058      LDRSH    R0,[R5, #+88]
   \      0x13E   0xF410 0x7F40      TST      R0,#0x300
   \      0x142   0xD005             BEQ.N    ??homeaxis_9
   3557            	{
   3558              set_axis_is_at_home(axis);
   \      0x144   0x4620             MOV      R0,R4
   \      0x146   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531919set_axis_is_at_homeE8AxisEnum
   3559              SYNC_PLAN_POSITION_KINEMATIC();
   \      0x14A   0x.... 0x....      BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
   \      0x14E   0xE022             B.N      ??homeaxis_10
   3560            	}
   3561          //  #elif ENABLED(DELTA)
   3562          	else if(MACHINETPYE == DELTA) {
   \                     ??homeaxis_9: (+1)
   \      0x150   0x4626             MOV      R6,R4
   \      0x152   0x2802             CMP      R0,#+2
   \      0x154   0xD115             BNE.N    ??homeaxis_11
   3563              // Delta has already moved all three towers up in G28
   3564              // so here it re-homes each tower in turn.
   3565              // Delta homing treats the axes as normal linear axes.
   3566          
   3567              // retrace by the amount specified in endstop_adj
   3568              if (endstop_adj[axis] * Z_HOME_DIR < 0) {
   \      0x156   0x.... 0x....      LDR.W    R0,??DataTable135_2
   \      0x15A   0xF850 0x6026      LDR      R6,[R0, R6, LSL #+2]
   \      0x15E   0xF995 0x0006      LDRSB    R0,[R5, #+6]
   \      0x162   0x.... 0x....      BL       __aeabi_i2f
   \      0x166   0x4601             MOV      R1,R0
   \      0x168   0x4630             MOV      R0,R6
   \      0x16A   0x.... 0x....      BL       __aeabi_fmul
   \      0x16E   0x2100             MOVS     R1,#+0
   \      0x170   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x174   0xD20F             BCS.N    ??homeaxis_10
   3569                #if ENABLED(DEBUG_LEVELING_FEATURE)
   3570                  if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("endstop_adj:");
   3571                #endif
   3572                do_homing_move(axis, endstop_adj[axis]);
   \      0x176   0x460A             MOV      R2,R1
   \      0x178   0x4631             MOV      R1,R6
   \      0x17A   0x4620             MOV      R0,R4
   \      0x17C   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531914do_homing_moveE8AxisEnumff
   \      0x180   0xE009             B.N      ??homeaxis_10
   3573             		 }
   3574          	  }
   3575            //#else
   3576          	else {
   3577              // For cartesian/core machines,
   3578              // set the axis to its home position
   3579              set_axis_is_at_home(axis);
   \                     ??homeaxis_11: (+1)
   \      0x182   0x4620             MOV      R0,R4
   \      0x184   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531919set_axis_is_at_homeE8AxisEnum
   3580              sync_plan_position();
   \      0x188   0x.... 0x....      BL       _Z18sync_plan_positionv
   3581          
   3582              destination[axis] = current_position[axis];
   \      0x18C   0x....             LDR.N    R0,??DataTable126_1
   \      0x18E   0xEB00 0x0086      ADD      R0,R0,R6, LSL #+2
   \      0x192   0x6881             LDR      R1,[R0, #+8]
   \      0x194   0x6181             STR      R1,[R0, #+24]
   3583          
   3584              #if ENABLED(DEBUG_LEVELING_FEATURE)
   3585                if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
   3586              #endif
   3587          	}
   3588            //#endif
   3589          
   3590            // Re-enable stealthChop if used. Disable diag1 pin on driver.
   3591            #if ENABLED(SENSORLESS_HOMING)
   3592              #if ENABLED(X_IS_TMC2130)
   3593                if (axis == X_AXIS) tmc2130_sensorless_homing(stepperX, false);
   3594              #endif
   3595              #if ENABLED(Y_IS_TMC2130)
   3596                if (axis == Y_AXIS) tmc2130_sensorless_homing(stepperY, false);
   3597              #endif
   3598            #endif
   3599          
   3600            // Put away the Z probe
   3601            #if HOMING_Z_WITH_PROBE
   3602            if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))	/*--mks cfg--*/
   \                     ??homeaxis_10: (+1)
   \      0x196   0xF995 0x0006      LDRSB    R0,[R5, #+6]
   \      0x19A   0x2800             CMP      R0,#+0
   \      0x19C   0xD508             BPL.N    ??homeaxis_2
   \      0x19E   0xF895 0x0099      LDRB     R0,[R5, #+153]
   \      0x1A2   0x2801             CMP      R0,#+1
   \      0x1A4   0xD104             BNE.N    ??homeaxis_2
   3603             { if (axis == Z_AXIS && STOW_PROBE()) return;}
   \      0x1A6   0x2C02             CMP      R4,#+2
   \      0x1A8   0xD102             BNE.N    ??homeaxis_2
   \      0x1AA   0x2000             MOVS     R0,#+0
   \      0x1AC   0x.... 0x....      BL       _Z18set_probe_deployedb
   3604            #endif
   3605          
   3606            #if ENABLED(DEBUG_LEVELING_FEATURE)
   3607              if (DEBUGGING(LEVELING)) {
   3608                SERIAL_ECHOPAIR("<<< homeaxis(", axis_codes[axis]);
   3609                SERIAL_CHAR(')');
   3610                SERIAL_EOL;
   3611              }
   3612            #endif
   3613          } // homeaxis()
   \                     ??homeaxis_2: (+1)
   \      0x1B0   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
   3614          
   3615          #if ENABLED(FWRETRACT)
   3616          
   3617            void retract(const bool retracting, const bool swapping = false) {
   3618          
   3619              static float hop_height;
   3620          
   3621              if (retracting == retracted[active_extruder]) return;
   3622          
   3623              const float old_feedrate_mm_s = feedrate_mm_s;
   3624          
   3625              set_destination_to_current();
   3626          
   3627              if (retracting) {
   3628          
   3629                feedrate_mm_s = retract_feedrate_mm_s;
   3630                current_position[E_AXIS] += (swapping ? retract_length_swap : retract_length) / volumetric_multiplier[active_extruder];
   3631                sync_plan_position_e();
   3632                prepare_move_to_destination();
   3633          
   3634                if (retract_zlift > 0.01) {
   3635                  hop_height = current_position[Z_AXIS];
   3636                  // Pretend current position is lower
   3637                  current_position[Z_AXIS] -= retract_zlift;
   3638                  SYNC_PLAN_POSITION_KINEMATIC();
   3639                  // Raise up to the old current_position
   3640                  prepare_move_to_destination();
   3641                }
   3642              }
   3643              else {
   3644          
   3645                // If the height hasn't been altered, undo the Z hop
   3646                if (retract_zlift > 0.01 && hop_height == current_position[Z_AXIS]) {
   3647                  // Pretend current position is higher. Z will lower on the next move
   3648                  current_position[Z_AXIS] += retract_zlift;
   3649                  SYNC_PLAN_POSITION_KINEMATIC();
   3650                  // Lower Z
   3651                  prepare_move_to_destination();
   3652                }
   3653          
   3654                feedrate_mm_s = retract_recover_feedrate_mm_s;
   3655                const float move_e = swapping ? retract_length_swap + retract_recover_length_swap : retract_length + retract_recover_length;
   3656                current_position[E_AXIS] -= move_e / volumetric_multiplier[active_extruder];
   3657                sync_plan_position_e();
   3658          
   3659                // Recover E
   3660                prepare_move_to_destination();
   3661              }
   3662          
   3663              feedrate_mm_s = old_feedrate_mm_s;
   3664              retracted[active_extruder] = retracting;
   3665          
   3666            } // retract()
   3667          
   3668          #endif // FWRETRACT
   3669          
   3670          #if ENABLED(MIXING_EXTRUDER)
   3671          
   3672            void normalize_mix() {
   3673              float mix_total = 0.0;
   3674              for (uint8_t i = 0; i < MIXING_STEPPERS; i++) mix_total += RECIPROCAL(mixing_factor[i]);
   3675              // Scale all values if they don't add up to ~1.0
   3676              if (!NEAR(mix_total, 1.0)) {
   3677                SERIAL_PROTOCOLLNPGM("Warning: Mix factors must add up to 1.0. Scaling.");
   3678                for (uint8_t i = 0; i < MIXING_STEPPERS; i++) mixing_factor[i] *= mix_total;
   3679              }
   3680            }
   3681          
   3682            #if ENABLED(DIRECT_MIXING_IN_G1)
   3683              // Get mixing parameters from the GCode
   3684              // The total "must" be 1.0 (but it will be normalized)
   3685              // If no mix factors are given, the old mix is preserved
   3686              void gcode_get_mix() {
   3687                const char* mixing_codes = "ABCDHI";
   3688                byte mix_bits = 0;
   3689                for (uint8_t i = 0; i < MIXING_STEPPERS; i++) {
   3690                  if (code_seen(mixing_codes[i])) {
   3691                    SBI(mix_bits, i);
   3692                    float v = code_value_float();
   3693                    NOLESS(v, 0.0);
   3694                    mixing_factor[i] = RECIPROCAL(v);
   3695                  }
   3696                }
   3697                // If any mixing factors were included, clear the rest
   3698                // If none were included, preserve the last mix
   3699                if (mix_bits) {
   3700                  for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
   3701                    if (!TEST(mix_bits, i)) mixing_factor[i] = 0.0;
   3702                  normalize_mix();
   3703                }
   3704              }
   3705            #endif
   3706          
   3707          #endif
   3708          
   3709          /**
   3710           * ***************************************************************************
   3711           * ***************************** G-CODE HANDLING *****************************
   3712           * ***************************************************************************
   3713           */
   3714          
   3715          /**
   3716           * Set XYZE destination and feedrate from the current GCode command
   3717           *
   3718           *  - Set destination from included axis codes
   3719           *  - Set to current for missing axis codes
   3720           *  - Set the feedrate, if included
   3721           */

   \                                 In section .text, align 2, keep-with-next
   3722          void gcode_get_destination() {
   \                     _Z21gcode_get_destinationv: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   3723            LOOP_XYZE(i) {
   \        0x2   0x2400             MOVS     R4,#+0
   \        0x4   0xE007             B.N      ??gcode_get_destination_0
   3724              if (code_seen(axis_codes[i]))
   3725                destination[i] = code_value_axis_units((AxisEnum)i) + (axis_relative_modes[i] || relative_mode ? current_position[i] : 0);
   3726              else
   3727                destination[i] = current_position[i];
   \                     ??gcode_get_destination_1: (+1)
   \        0x6   0x68A8             LDR      R0,[R5, #+8]
   \        0x8   0x61A8             STR      R0,[R5, #+24]
   \        0xA   0xE003             B.N      ??gcode_get_destination_2
   \                     ??gcode_get_destination_3: (+1)
   \        0xC   0x2100             MOVS     R1,#+0
   \                     ??gcode_get_destination_4: (+1)
   \        0xE   0x.... 0x....      BL       __aeabi_fadd
   \       0x12   0x61A8             STR      R0,[R5, #+24]
   \                     ??gcode_get_destination_2: (+1)
   \       0x14   0x1C64             ADDS     R4,R4,#+1
   \                     ??gcode_get_destination_0: (+1)
   \       0x16   0x2C04             CMP      R4,#+4
   \       0x18   0xDA14             BGE.N    ??gcode_get_destination_5
   \       0x1A   0x.... 0x....      LDR.W    R0,??DataTable136_2
   \       0x1E   0xEB00 0x0584      ADD      R5,R0,R4, LSL #+2
   \       0x22   0x.... 0x....      ADR.W    R0,axis_codes
   \       0x26   0x5700             LDRSB    R0,[R0, R4]
   \       0x28   0x.... 0x....      BL       _Z9code_seenc
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD0EA             BEQ.N    ??gcode_get_destination_1
   \       0x30   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x34   0x.... 0x....      LDR.W    R1,??DataTable136_3
   \       0x38   0x5D0A             LDRB     R2,[R1, R4]
   \       0x3A   0x7B09             LDRB     R1,[R1, #+12]
   \       0x3C   0x430A             ORRS     R2,R1,R2
   \       0x3E   0xD0E5             BEQ.N    ??gcode_get_destination_3
   \       0x40   0x68A9             LDR      R1,[R5, #+8]
   \       0x42   0xE7E4             B.N      ??gcode_get_destination_4
   3728            }
   3729          
   3730            if (code_seen('F') && code_value_linear_units() > 0.0)
   \                     ??gcode_get_destination_5: (+1)
   \       0x44   0x2046             MOVS     R0,#+70
   \       0x46   0x.... 0x....      BL       _Z9code_seenc
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD00E             BEQ.N    ??gcode_get_destination_6
   \       0x4E   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x52   0x2100             MOVS     R1,#+0
   \       0x54   0x.... 0x....      BL       __aeabi_cfrcmple
   \       0x58   0xD208             BCS.N    ??gcode_get_destination_6
   3731              feedrate_mm_s = MMM_TO_MMS(code_value_linear_units());
   \       0x5A   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x5E   0x.... 0x....      LDR.W    R1,??DataTable136_4  ;; 0x42700000
   \       0x62   0x.... 0x....      BL       __aeabi_fdiv
   \       0x66   0x.... 0x....      LDR.W    R1,??DataTable136_2
   \       0x6A   0x6748             STR      R0,[R1, #+116]
   3732          
   3733            #if ENABLED(PRINTCOUNTER)
   3734              if (!DEBUGGING(DRYRUN))
   3735                print_job_timer.incFilamentUsed(destination[E_AXIS] - current_position[E_AXIS]);
   3736            #endif
   3737          
   3738            // Get ABCDHI mixing factors
   3739            #if ENABLED(MIXING_EXTRUDER) && ENABLED(DIRECT_MIXING_IN_G1)
   3740              gcode_get_mix();
   3741            #endif
   3742          }
   \                     ??gcode_get_destination_6: (+1)
   \       0x6C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   3743          

   \                                 In section .text, align 2, keep-with-next
   3744          void unknown_command_error() {
   \                     _Z21unknown_command_errorv: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   3745            SERIAL_ECHO_START;
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable136_5
   \        0x6   0x.... 0x....      BL       _Z14serialprintPGMPKc
   3746            SERIAL_ECHOPAIR(MSG_UNKNOWN_COMMAND, current_command);
   \        0xA   0x.... 0x....      LDR.W    R0,??DataTable136_3
   \        0xE   0x6A41             LDR      R1,[R0, #+36]
   \       0x10   0x.... 0x....      ADR.W    R0,?_14
   \       0x14   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
   3747            SERIAL_CHAR('"');
   \       0x18   0x....             LDR.N    R4,??DataTable126_1
   \       0x1A   0x79E0             LDRB     R0,[R4, #+7]
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD105             BNE.N    ??unknown_command_error_0
   \       0x20   0x2122             MOVS     R1,#+34
   \       0x22   0x.... 0x....      LDR.W    R0,??DataTable128
   \       0x26   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \       0x2A   0xE005             B.N      ??unknown_command_error_1
   \                     ??unknown_command_error_0: (+1)
   \       0x2C   0x2200             MOVS     R2,#+0
   \       0x2E   0x2122             MOVS     R1,#+34
   \       0x30   0x.... 0x....      LDR.W    R0,??DataTable136_6
   \       0x34   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   3748            SERIAL_EOL;
   \                     ??unknown_command_error_1: (+1)
   \       0x38   0x79E0             LDRB     R0,[R4, #+7]
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD106             BNE.N    ??unknown_command_error_2
   \       0x3E   0x210A             MOVS     R1,#+10
   \       0x40   0x.... 0x....      LDR.W    R0,??DataTable128
   \       0x44   0xE8BD 0x4010      POP      {R4,LR}
   \       0x48   0x.... 0x....      B.W      _ZN12MarlinSerial5writeEh
   \                     ??unknown_command_error_2: (+1)
   \       0x4C   0x2200             MOVS     R2,#+0
   \       0x4E   0x210A             MOVS     R1,#+10
   \       0x50   0x.... 0x....      LDR.W    R0,??DataTable136_6
   \       0x54   0xE8BD 0x4010      POP      {R4,LR}
   \       0x58   0x.... 0x....      B.W      _ZN12MarlinSerial5printEci
   3749          }
   3750          
   3751          #if ENABLED(HOST_KEEPALIVE_FEATURE)
   3752          
   3753            /**
   3754             * Output a "busy" message at regular intervals
   3755             * while the machine is not accepting commands.
   3756             */

   \                                 In section .text, align 4, keep-with-next
   3757            void host_keepalive() {
   \                     _Z14host_keepalivev: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   3758              const millis_t ms = millis();
   \        0x2   0x.... 0x....      BL       HAL_GetTick
   \        0x6   0x4605             MOV      R5,R0
   3759              if (host_keepalive_interval && busy_state != NOT_BUSY) {
   \        0x8   0x.... 0x....      LDR.W    R4,??DataTable136_7
   \        0xC   0x7820             LDRB     R0,[R4, #+0]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD028             BEQ.N    ??host_keepalive_1
   \       0x12   0x....             LDR.N    R0,??DataTable126_1
   \       0x14   0xF990 0x0006      LDRSB    R0,[R0, #+6]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD023             BEQ.N    ??host_keepalive_1
   3760                if (PENDING(ms, next_busy_signal_ms)) return;
   \       0x1C   0x6861             LDR      R1,[R4, #+4]
   \       0x1E   0x1A69             SUBS     R1,R5,R1
   \       0x20   0xD426             BMI.N    ??host_keepalive_2
   3761                switch (busy_state) {
   \       0x22   0x1E40             SUBS     R0,R0,#+1
   \       0x24   0x2803             CMP      R0,#+3
   \       0x26   0xD81D             BHI.N    ??host_keepalive_1
   \       0x28   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??host_keepalive_0:
   \       0x2C   0x02 0x02          DC8      0x2,0x2,0xB,0x14
   \              0x0B 0x14    
   3762                  case IN_HANDLER:
   3763                  case IN_PROCESS:
   3764                    SERIAL_ECHO_START;
   \                     ??host_keepalive_3: (+1)
   \       0x30   0x.... 0x....      LDR.W    R0,??DataTable136_5
   \       0x34   0x.... 0x....      BL       _Z14serialprintPGMPKc
   3765                    SERIAL_ECHOLNPGM(MSG_BUSY_PROCESSING);
   \       0x38   0x.... 0x....      ADR.W    R0,?_15
   \       0x3C   0x.... 0x....      BL       _Z14serialprintPGMPKc
   3766                    break;
   \       0x40   0xE010             B.N      ??host_keepalive_1
   3767                  case PAUSED_FOR_USER:
   3768                    SERIAL_ECHO_START;
   \                     ??host_keepalive_4: (+1)
   \       0x42   0x.... 0x....      LDR.W    R0,??DataTable136_5
   \       0x46   0x.... 0x....      BL       _Z14serialprintPGMPKc
   3769                    SERIAL_ECHOLNPGM(MSG_BUSY_PAUSED_FOR_USER);
   \       0x4A   0x.... 0x....      ADR.W    R0,?_16
   \       0x4E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   3770                    break;
   \       0x52   0xE007             B.N      ??host_keepalive_1
   3771                  case PAUSED_FOR_INPUT:
   3772                    SERIAL_ECHO_START;
   \                     ??host_keepalive_5: (+1)
   \       0x54   0x.... 0x....      LDR.W    R0,??DataTable136_5
   \       0x58   0x.... 0x....      BL       _Z14serialprintPGMPKc
   3773                    SERIAL_ECHOLNPGM(MSG_BUSY_PAUSED_FOR_INPUT);
   \       0x5C   0x.... 0x....      ADR.W    R0,?_17
   \       0x60   0x.... 0x....      BL       _Z14serialprintPGMPKc
   3774                    break;
   3775                  default:
   3776                    break;
   3777                }
   3778              }
   3779              next_busy_signal_ms = ms + host_keepalive_interval * 1000UL;
   \                     ??host_keepalive_1: (+1)
   \       0x64   0x7821             LDRB     R1,[R4, #+0]
   \       0x66   0xF44F 0x707A      MOV      R0,#+1000
   \       0x6A   0xFB00 0x5501      MLA      R5,R0,R1,R5
   \       0x6E   0x6065             STR      R5,[R4, #+4]
   3780            }
   \                     ??host_keepalive_2: (+1)
   \       0x70   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   3781          
   3782          #endif //HOST_KEEPALIVE_FEATURE
   3783          

   \                                 In section .text, align 2, keep-with-next
   3784          bool position_is_reachable(const float target[XYZ]
   3785            #if HAS_BED_PROBE
   3786              , bool by_probe=false
   3787            #endif
   3788          ) {
   \                     _Z21position_is_reachablePKfb: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x4688             MOV      R8,R1
   3789            float dx = RAW_X_POSITION(target[X_AXIS]),
   \        0x8   0x.... 0x....      LDR.W    R9,??DataTable136_2
   \        0xC   0x6820             LDR      R0,[R4, #+0]
   \        0xE   0xF8D9 0x1044      LDR      R1,[R9, #+68]
   \       0x12   0x.... 0x....      BL       __aeabi_fsub
   \       0x16   0x4605             MOV      R5,R0
   3790                  dy = RAW_Y_POSITION(target[Y_AXIS]);
   \       0x18   0x6860             LDR      R0,[R4, #+4]
   \       0x1A   0xF8D9 0x1048      LDR      R1,[R9, #+72]
   \       0x1E   0x.... 0x....      BL       __aeabi_fsub
   \       0x22   0x4607             MOV      R7,R0
   3791          
   3792            #if HAS_BED_PROBE
   3793              if (by_probe) {
   \       0x24   0x.... 0x....      LDR.W    R6,??DataTable136_8
   \       0x28   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x2C   0xD009             BEQ.N    ??position_is_reachable_0
   3794                dx -= X_PROBE_OFFSET_FROM_EXTRUDER;
   \       0x2E   0x4628             MOV      R0,R5
   \       0x30   0x6EF1             LDR      R1,[R6, #+108]
   \       0x32   0x.... 0x....      BL       __aeabi_fsub
   \       0x36   0x4605             MOV      R5,R0
   3795                dy -= Y_PROBE_OFFSET_FROM_EXTRUDER;
   \       0x38   0x4638             MOV      R0,R7
   \       0x3A   0x6F31             LDR      R1,[R6, #+112]
   \       0x3C   0x.... 0x....      BL       __aeabi_fsub
   \       0x40   0x4607             MOV      R7,R0
   3796              }
   3797            #endif
   3798          
   3799          //mks_delta		begin
   3800          /*
   3801            #if IS_SCARA
   3802              #if MIDDLE_DEAD_ZONE_R > 0
   3803                const float R2 = HYPOT2(dx - SCARA_OFFSET_X, dy - SCARA_OFFSET_Y);
   3804                return R2 >= sq(float(MIDDLE_DEAD_ZONE_R)) && R2 <= sq(L1 + L2);
   3805              #else
   3806                return HYPOT2(dx - SCARA_OFFSET_X, dy - SCARA_OFFSET_Y) <= sq(L1 + L2);
   3807              #endif
   3808            #elif ENABLED(DELTA)
   3809              return HYPOT2(dx, dy) <= sq((float)(DELTA_PRINTABLE_RADIUS));
   3810            #else
   3811              const float dz = RAW_Z_POSITION(target[Z_AXIS]);
   3812              return WITHIN(dx, X_MIN_POS - 0.0001, X_MAX_POS + 0.0001)
   3813                  && WITHIN(dy, Y_MIN_POS - 0.0001, Y_MAX_POS + 0.0001)
   3814                  && WITHIN(dz, Z_MIN_POS - 0.0001, Z_MAX_POS + 0.0001);
   3815            #endif
   3816            */
   3817          ///////////
   3818          
   3819            float dz;
   3820          
   3821            if(MACHINETPYE&IS_SCARA)
   \                     ??position_is_reachable_0: (+1)
   \       0x42   0xF9B6 0x0058      LDRSH    R0,[R6, #+88]
   \       0x46   0xF410 0x7F40      TST      R0,#0x300
   \       0x4A   0xD04E             BEQ.N    ??position_is_reachable_1
   3822            	{
   3823          	#if MIDDLE_DEAD_ZONE_R > 0
   3824          		const float R2 = HYPOT2(dx - SCARA_OFFSET_X, dy - SCARA_OFFSET_Y);
   3825          		return R2 >= sq(float(MIDDLE_DEAD_ZONE_R)) && R2 <= sq(L1 + L2);
   3826          	#else
   3827          		return HYPOT2(dx - SCARA_OFFSET_X, dy - SCARA_OFFSET_Y) <= sq(L1 + L2);
   \       0x4C   0x.... 0x....      LDR.W    R9,??DataTable136_9  ;; 0x43960000
   \       0x50   0x2402             MOVS     R4,#+2
   \       0x52   0xF04F 0x567E      MOV      R6,#+1065353216
   \       0x56   0x46B0             MOV      R8,R6
   \       0x58   0xE004             B.N      ??position_is_reachable_2
   \                     ??position_is_reachable_3: (+1)
   \       0x5A   0x4648             MOV      R0,R9
   \       0x5C   0x4649             MOV      R1,R9
   \       0x5E   0x.... 0x....      BL       __aeabi_fmul
   \       0x62   0x4681             MOV      R9,R0
   \                     ??position_is_reachable_2: (+1)
   \       0x64   0x07E0             LSLS     R0,R4,#+31
   \       0x66   0xD504             BPL.N    ??position_is_reachable_4
   \       0x68   0x4640             MOV      R0,R8
   \       0x6A   0x4649             MOV      R1,R9
   \       0x6C   0x.... 0x....      BL       __aeabi_fmul
   \       0x70   0x4680             MOV      R8,R0
   \                     ??position_is_reachable_4: (+1)
   \       0x72   0x0864             LSRS     R4,R4,#+1
   \       0x74   0xD1F1             BNE.N    ??position_is_reachable_3
   \       0x76   0x.... 0x....      LDR.W    R0,??DataTable136_10  ;; 0xc2c80000
   \       0x7A   0x4629             MOV      R1,R5
   \       0x7C   0x.... 0x....      BL       __aeabi_fadd
   \       0x80   0x4681             MOV      R9,R0
   \       0x82   0x2402             MOVS     R4,#+2
   \       0x84   0x4635             MOV      R5,R6
   \       0x86   0xE004             B.N      ??position_is_reachable_5
   \                     ??position_is_reachable_6: (+1)
   \       0x88   0x4648             MOV      R0,R9
   \       0x8A   0x4649             MOV      R1,R9
   \       0x8C   0x.... 0x....      BL       __aeabi_fmul
   \       0x90   0x4681             MOV      R9,R0
   \                     ??position_is_reachable_5: (+1)
   \       0x92   0x07E0             LSLS     R0,R4,#+31
   \       0x94   0xD504             BPL.N    ??position_is_reachable_7
   \       0x96   0x4628             MOV      R0,R5
   \       0x98   0x4649             MOV      R1,R9
   \       0x9A   0x.... 0x....      BL       __aeabi_fmul
   \       0x9E   0x4605             MOV      R5,R0
   \                     ??position_is_reachable_7: (+1)
   \       0xA0   0x0864             LSRS     R4,R4,#+1
   \       0xA2   0xD1F1             BNE.N    ??position_is_reachable_6
   \       0xA4   0x.... 0x....      LDR.W    R0,??DataTable136_11  ;; 0x42600000
   \       0xA8   0x4639             MOV      R1,R7
   \       0xAA   0x.... 0x....      BL       __aeabi_fadd
   \       0xAE   0x4607             MOV      R7,R0
   \       0xB0   0x2402             MOVS     R4,#+2
   \       0xB2   0xE004             B.N      ??position_is_reachable_8
   \                     ??position_is_reachable_9: (+1)
   \       0xB4   0x4638             MOV      R0,R7
   \       0xB6   0x4639             MOV      R1,R7
   \       0xB8   0x.... 0x....      BL       __aeabi_fmul
   \       0xBC   0x4607             MOV      R7,R0
   \                     ??position_is_reachable_8: (+1)
   \       0xBE   0x07E0             LSLS     R0,R4,#+31
   \       0xC0   0xD504             BPL.N    ??position_is_reachable_10
   \       0xC2   0x4630             MOV      R0,R6
   \       0xC4   0x4639             MOV      R1,R7
   \       0xC6   0x.... 0x....      BL       __aeabi_fmul
   \       0xCA   0x4606             MOV      R6,R0
   \                     ??position_is_reachable_10: (+1)
   \       0xCC   0x0864             LSRS     R4,R4,#+1
   \       0xCE   0xD1F1             BNE.N    ??position_is_reachable_9
   3828          	#endif
   3829            	}
   \       0xD0   0x4628             MOV      R0,R5
   \       0xD2   0x4631             MOV      R1,R6
   \       0xD4   0x.... 0x....      BL       __aeabi_fadd
   \       0xD8   0x4601             MOV      R1,R0
   \       0xDA   0x4640             MOV      R0,R8
   \       0xDC   0x.... 0x....      BL       __aeabi_cfrcmple
   \       0xE0   0xD801             BHI.N    ??position_is_reachable_11
   \       0xE2   0x2001             MOVS     R0,#+1
   \       0xE4   0xE0B3             B.N      ??position_is_reachable_12
   \                     ??position_is_reachable_11: (+1)
   \       0xE6   0x2000             MOVS     R0,#+0
   \       0xE8   0xE0B1             B.N      ??position_is_reachable_12
   3830            else if(MACHINETPYE == DELTA)
   \                     ??position_is_reachable_1: (+1)
   \       0xEA   0x2802             CMP      R0,#+2
   \       0xEC   0xD142             BNE.N    ??position_is_reachable_13
   3831            	{
   3832          	  return HYPOT2(dx, dy) <= sq((float)(DELTA_PRINTABLE_RADIUS));
   \       0xEE   0xF8D6 0x9054      LDR      R9,[R6, #+84]
   \       0xF2   0x2402             MOVS     R4,#+2
   \       0xF4   0xF04F 0x567E      MOV      R6,#+1065353216
   \       0xF8   0x46B0             MOV      R8,R6
   \       0xFA   0xE004             B.N      ??position_is_reachable_14
   \                     ??position_is_reachable_15: (+1)
   \       0xFC   0x4648             MOV      R0,R9
   \       0xFE   0x4649             MOV      R1,R9
   \      0x100   0x.... 0x....      BL       __aeabi_fmul
   \      0x104   0x4681             MOV      R9,R0
   \                     ??position_is_reachable_14: (+1)
   \      0x106   0x07E0             LSLS     R0,R4,#+31
   \      0x108   0xD504             BPL.N    ??position_is_reachable_16
   \      0x10A   0x4640             MOV      R0,R8
   \      0x10C   0x4649             MOV      R1,R9
   \      0x10E   0x.... 0x....      BL       __aeabi_fmul
   \      0x112   0x4680             MOV      R8,R0
   \                     ??position_is_reachable_16: (+1)
   \      0x114   0x0864             LSRS     R4,R4,#+1
   \      0x116   0xD1F1             BNE.N    ??position_is_reachable_15
   \      0x118   0x2402             MOVS     R4,#+2
   \      0x11A   0x46B1             MOV      R9,R6
   \      0x11C   0xE004             B.N      ??position_is_reachable_17
   \                     ??position_is_reachable_18: (+1)
   \      0x11E   0x4628             MOV      R0,R5
   \      0x120   0x4629             MOV      R1,R5
   \      0x122   0x.... 0x....      BL       __aeabi_fmul
   \      0x126   0x4605             MOV      R5,R0
   \                     ??position_is_reachable_17: (+1)
   \      0x128   0x07E0             LSLS     R0,R4,#+31
   \      0x12A   0xD504             BPL.N    ??position_is_reachable_19
   \      0x12C   0x4648             MOV      R0,R9
   \      0x12E   0x4629             MOV      R1,R5
   \      0x130   0x.... 0x....      BL       __aeabi_fmul
   \      0x134   0x4681             MOV      R9,R0
   \                     ??position_is_reachable_19: (+1)
   \      0x136   0x0864             LSRS     R4,R4,#+1
   \      0x138   0xD1F1             BNE.N    ??position_is_reachable_18
   \      0x13A   0x2402             MOVS     R4,#+2
   \      0x13C   0xE004             B.N      ??position_is_reachable_20
   \                     ??position_is_reachable_21: (+1)
   \      0x13E   0x4638             MOV      R0,R7
   \      0x140   0x4639             MOV      R1,R7
   \      0x142   0x.... 0x....      BL       __aeabi_fmul
   \      0x146   0x4607             MOV      R7,R0
   \                     ??position_is_reachable_20: (+1)
   \      0x148   0x07E0             LSLS     R0,R4,#+31
   \      0x14A   0xD504             BPL.N    ??position_is_reachable_22
   \      0x14C   0x4630             MOV      R0,R6
   \      0x14E   0x4639             MOV      R1,R7
   \      0x150   0x.... 0x....      BL       __aeabi_fmul
   \      0x154   0x4606             MOV      R6,R0
   \                     ??position_is_reachable_22: (+1)
   \      0x156   0x0864             LSRS     R4,R4,#+1
   \      0x158   0xD1F1             BNE.N    ??position_is_reachable_21
   3833            	}
   \      0x15A   0x4648             MOV      R0,R9
   \      0x15C   0x4631             MOV      R1,R6
   \      0x15E   0x.... 0x....      BL       __aeabi_fadd
   \      0x162   0x4601             MOV      R1,R0
   \      0x164   0x4640             MOV      R0,R8
   \      0x166   0x.... 0x....      BL       __aeabi_cfrcmple
   \      0x16A   0xD801             BHI.N    ??position_is_reachable_23
   \      0x16C   0x2001             MOVS     R0,#+1
   \      0x16E   0xE06E             B.N      ??position_is_reachable_12
   \                     ??position_is_reachable_23: (+1)
   \      0x170   0x2000             MOVS     R0,#+0
   \      0x172   0xE06C             B.N      ??position_is_reachable_12
   3834            else
   3835            	{
   3836          	  dz = RAW_Z_POSITION(target[Z_AXIS]);
   \                     ??position_is_reachable_13: (+1)
   \      0x174   0x68A0             LDR      R0,[R4, #+8]
   \      0x176   0xF8D9 0x104C      LDR      R1,[R9, #+76]
   \      0x17A   0x.... 0x....      BL       __aeabi_fsub
   \      0x17E   0x9000             STR      R0,[SP, #+0]
   3837          	  return WITHIN(dx, X_MIN_POS - 0.0001, X_MAX_POS + 0.0001)
   3838          		  && WITHIN(dy, Y_MIN_POS - 0.0001, Y_MAX_POS + 0.0001)
   3839          		  && WITHIN(dz, Z_MIN_POS - 0.0001, Z_MAX_POS + 0.0001);
   \      0x180   0x4628             MOV      R0,R5
   \      0x182   0x.... 0x....      BL       __aeabi_f2d
   \      0x186   0x4604             MOV      R4,R0
   \      0x188   0x460D             MOV      R5,R1
   \      0x18A   0x.... 0x....      LDR.W    R10,??DataTable136_12  ;; 0xeb1c432d
   \      0x18E   0x.... 0x....      LDR.W    R11,??DataTable136_13  ;; 0xbf1a36e2
   \      0x192   0x68B0             LDR      R0,[R6, #+8]
   \      0x194   0x.... 0x....      BL       __aeabi_f2d
   \      0x198   0x4652             MOV      R2,R10
   \      0x19A   0x465B             MOV      R3,R11
   \      0x19C   0x.... 0x....      BL       __aeabi_dadd
   \      0x1A0   0x4602             MOV      R2,R0
   \      0x1A2   0x460B             MOV      R3,R1
   \      0x1A4   0x4620             MOV      R0,R4
   \      0x1A6   0x4629             MOV      R1,R5
   \      0x1A8   0x.... 0x....      BL       __aeabi_cdrcmple
   \      0x1AC   0xD84E             BHI.N    ??position_is_reachable_24
   \      0x1AE   0x46D0             MOV      R8,R10
   \      0x1B0   0x.... 0x....      LDR.W    R9,??DataTable136_14  ;; 0x3f1a36e2
   \      0x1B4   0x6970             LDR      R0,[R6, #+20]
   \      0x1B6   0x.... 0x....      BL       __aeabi_f2d
   \      0x1BA   0x4642             MOV      R2,R8
   \      0x1BC   0x464B             MOV      R3,R9
   \      0x1BE   0x.... 0x....      BL       __aeabi_dadd
   \      0x1C2   0x4622             MOV      R2,R4
   \      0x1C4   0x462B             MOV      R3,R5
   \      0x1C6   0x.... 0x....      BL       __aeabi_cdrcmple
   \      0x1CA   0xD83F             BHI.N    ??position_is_reachable_24
   \      0x1CC   0x4638             MOV      R0,R7
   \      0x1CE   0x.... 0x....      BL       __aeabi_f2d
   \      0x1D2   0x4604             MOV      R4,R0
   \      0x1D4   0x460D             MOV      R5,R1
   \      0x1D6   0x68F0             LDR      R0,[R6, #+12]
   \      0x1D8   0x.... 0x....      BL       __aeabi_f2d
   \      0x1DC   0x4652             MOV      R2,R10
   \      0x1DE   0x465B             MOV      R3,R11
   \      0x1E0   0x.... 0x....      BL       __aeabi_dadd
   \      0x1E4   0x4602             MOV      R2,R0
   \      0x1E6   0x460B             MOV      R3,R1
   \      0x1E8   0x4620             MOV      R0,R4
   \      0x1EA   0x4629             MOV      R1,R5
   \      0x1EC   0x.... 0x....      BL       __aeabi_cdrcmple
   \      0x1F0   0xD82C             BHI.N    ??position_is_reachable_24
   \      0x1F2   0x69B0             LDR      R0,[R6, #+24]
   \      0x1F4   0x.... 0x....      BL       __aeabi_f2d
   \      0x1F8   0x4642             MOV      R2,R8
   \      0x1FA   0x464B             MOV      R3,R9
   \      0x1FC   0x.... 0x....      BL       __aeabi_dadd
   \      0x200   0x4622             MOV      R2,R4
   \      0x202   0x462B             MOV      R3,R5
   \      0x204   0x.... 0x....      BL       __aeabi_cdrcmple
   \      0x208   0xD820             BHI.N    ??position_is_reachable_24
   \      0x20A   0x9800             LDR      R0,[SP, #+0]
   \      0x20C   0x.... 0x....      BL       __aeabi_f2d
   \      0x210   0x4604             MOV      R4,R0
   \      0x212   0x460D             MOV      R5,R1
   \      0x214   0x6930             LDR      R0,[R6, #+16]
   \      0x216   0x.... 0x....      BL       __aeabi_f2d
   \      0x21A   0x4652             MOV      R2,R10
   \      0x21C   0x465B             MOV      R3,R11
   \      0x21E   0x.... 0x....      BL       __aeabi_dadd
   \      0x222   0x4602             MOV      R2,R0
   \      0x224   0x460B             MOV      R3,R1
   \      0x226   0x4620             MOV      R0,R4
   \      0x228   0x4629             MOV      R1,R5
   \      0x22A   0x.... 0x....      BL       __aeabi_cdrcmple
   \      0x22E   0xD80D             BHI.N    ??position_is_reachable_24
   \      0x230   0x69F0             LDR      R0,[R6, #+28]
   \      0x232   0x.... 0x....      BL       __aeabi_f2d
   \      0x236   0x4642             MOV      R2,R8
   \      0x238   0x464B             MOV      R3,R9
   \      0x23A   0x.... 0x....      BL       __aeabi_dadd
   \      0x23E   0x4622             MOV      R2,R4
   \      0x240   0x462B             MOV      R3,R5
   \      0x242   0x.... 0x....      BL       __aeabi_cdrcmple
   \      0x246   0xD801             BHI.N    ??position_is_reachable_24
   \      0x248   0x2001             MOVS     R0,#+1
   \      0x24A   0xE000             B.N      ??position_is_reachable_12
   \                     ??position_is_reachable_24: (+1)
   \      0x24C   0x2000             MOVS     R0,#+0
   \                     ??position_is_reachable_12: (+1)
   \      0x24E   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   3840            	}
   3841          
   3842          //mks_delta	  end
   3843          
   3844            
   3845          }
   3846          
   3847          /**************************************************
   3848           ***************** GCode Handlers *****************
   3849           **************************************************/
   3850          
   3851          /**
   3852           * G0, G1: Coordinated movement of X Y Z E axes
   3853           */

   \                                 In section .text, align 2
   3854          	inline void gcode_G0_G1(
   3855          	) {
   \                     _Z11gcode_G0_G1v: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   3856          	  if (IsRunning()) {
   \        0x2   0x.... 0x....      BL       _Z9IsRunningv
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD005             BEQ.N    ??gcode_G0_G1_0
   3857          		gcode_get_destination(); // For X Y Z E F
   \        0xA   0x.... 0x....      BL       _Z21gcode_get_destinationv
   3858          	
   3859              #if ENABLED(FWRETRACT)
   3860          	
   3861          		  if (autoretract_enabled && !(code_seen('X') || code_seen('Y') || code_seen('Z')) && code_seen('E')) {
   3862          			const float echange = destination[E_AXIS] - current_position[E_AXIS];
   3863          			// Is this move an attempt to retract or recover?
   3864          			if ((echange < -MIN_RETRACT && !retracted[active_extruder]) || (echange > MIN_RETRACT && retracted[active_extruder])) {
   3865          			  current_position[E_AXIS] = destination[E_AXIS]; // hide the slicer-generated retract/recover from calculations
   3866          			  sync_plan_position_e();  // AND from the planner
   3867          			  retract(!retracted[active_extruder]);
   3868          			  return;
   3869          			}
   3870          		  }
   3871          	
   3872              #endif //FWRETRACT
   3873          	
   3874          		  prepare_move_to_destination(); //mks step1  destination[]={1.0,0.0,100.0,0.0}
   \        0xE   0xE8BD 0x4001      POP      {R0,LR}
   \       0x12   0x.... 0x....      B.W      _Z27prepare_move_to_destinationv
   3875          	  }
   3876          	}
   \                     ??gcode_G0_G1_0: (+1)
   \       0x16   0xBD01             POP      {R0,PC}          ;; return
   3877          

   \                                 In section .text, align 2
   3878            inline void gcode_G0_G1_SCARA(
   3879          	  bool fast_move=false
   3880            ) {
   \                     _Z17gcode_G0_G1_SCARAb: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   3881          	if (IsRunning()) {
   \        0x4   0x.... 0x....      BL       _Z9IsRunningv
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD00C             BEQ.N    ??gcode_G0_G1_SCARA_0
   3882          	  gcode_get_destination(); // For X Y Z E F
   \        0xC   0x.... 0x....      BL       _Z21gcode_get_destinationv
   3883            
   3884            #if ENABLED(FWRETRACT)
   3885            
   3886          		if (autoretract_enabled && !(code_seen('X') || code_seen('Y') || code_seen('Z')) && code_seen('E')) {
   3887          		  const float echange = destination[E_AXIS] - current_position[E_AXIS];
   3888          		  // Is this move an attempt to retract or recover?
   3889          		  if ((echange < -MIN_RETRACT && !retracted[active_extruder]) || (echange > MIN_RETRACT && retracted[active_extruder])) {
   3890          			current_position[E_AXIS] = destination[E_AXIS]; // hide the slicer-generated retract/recover from calculations
   3891          			sync_plan_position_e();  // AND from the planner
   3892          			retract(!retracted[active_extruder]);
   3893          			return;
   3894          		  }
   3895          		}
   3896            
   3897            #endif //FWRETRACT
   3898            
   3899          		fast_move ? prepare_uninterpolated_move_to_destination() : prepare_move_to_destination();
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD004             BEQ.N    ??gcode_G0_G1_SCARA_1
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xE8BD 0x4010      POP      {R4,LR}
   \       0x1A   0x.... 0x....      B.W      _Z42prepare_uninterpolated_move_to_destinationf
   \                     ??gcode_G0_G1_SCARA_1: (+1)
   \       0x1E   0xE8BD 0x4010      POP      {R4,LR}
   \       0x22   0x.... 0x....      B.W      _Z27prepare_move_to_destinationv
   3900          	}
   3901            }
   \                     ??gcode_G0_G1_SCARA_0: (+1)
   \       0x26   0xBD10             POP      {R4,PC}          ;; return
   3902          
   3903          /**
   3904           * G2: Clockwise Arc
   3905           * G3: Counterclockwise Arc
   3906           *
   3907           * This command has two forms: IJ-form and R-form.
   3908           *
   3909           *  - I specifies an X offset. J specifies a Y offset.
   3910           *    At least one of the IJ parameters is required.
   3911           *    X and Y can be omitted to do a complete circle.
   3912           *    The given XY is not error-checked. The arc ends
   3913           *     based on the angle of the destination.
   3914           *    Mixing I or J with R will throw an error.
   3915           *
   3916           *  - R specifies the radius. X or Y is required.
   3917           *    Omitting both X and Y will throw an error.
   3918           *    X or Y must differ from the current XY.
   3919           *    Mixing R with I or J will throw an error.
   3920           *
   3921           *  Examples:
   3922           *
   3923           *    G2 I10           ; CW circle centered at X+10
   3924           *    G3 X20 Y12 R14   ; CCW circle with r=14 ending at X20 Y12
   3925           */
   3926          #if ENABLED(ARC_SUPPORT)

   \                                 In section .text, align 4
   3927            inline void gcode_G2_G3(bool clockwise) {
   \                     _Z11gcode_G2_G3b: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB089             SUB      SP,SP,#+36
   \        0x6   0x4604             MOV      R4,R0
   3928              if (IsRunning()) {
   \        0x8   0x.... 0x....      BL       _Z9IsRunningv
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xF000 0x8111      BEQ.W    ??gcode_G2_G3_1
   3929          
   3930                #if ENABLED(SF_ARC_FIX)
   3931                  const bool relative_mode_backup = relative_mode;
   3932                  relative_mode = true;
   3933                #endif
   3934          
   3935                gcode_get_destination();
   \       0x12   0x.... 0x....      BL       _Z21gcode_get_destinationv
   3936          
   3937                #if ENABLED(SF_ARC_FIX)
   3938                  relative_mode = relative_mode_backup;
   3939                #endif
   3940          
   3941                float arc_offset[2] = { 0.0, 0.0 };
   \       0x16   0xA805             ADD      R0,SP,#+20
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0x460A             MOV      R2,R1
   \       0x1C   0xE9C0 0x1200      STRD     R1,R2,[R0, #+0]
   \       0x20   0xF88D 0x4000      STRB     R4,[SP, #+0]
   3942                if (code_seen('R')) {
   \       0x24   0x2052             MOVS     R0,#+82
   \       0x26   0x.... 0x....      BL       _Z9code_seenc
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xF000 0x80DA      BEQ.W    ??gcode_G2_G3_2
   3943                  const float r = code_value_linear_units(),
   \       0x30   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x34   0x4605             MOV      R5,R0
   3944                              x1 = current_position[X_AXIS], y1 = current_position[Y_AXIS],
   \       0x36   0x4881             LDR.N    R0,??gcode_G2_G3_0
   \       0x38   0x6881             LDR      R1,[R0, #+8]
   \       0x3A   0x9102             STR      R1,[SP, #+8]
   \       0x3C   0x68C1             LDR      R1,[R0, #+12]
   \       0x3E   0x9101             STR      R1,[SP, #+4]
   3945                              x2 = destination[X_AXIS], y2 = destination[Y_AXIS];
   \       0x40   0x6981             LDR      R1,[R0, #+24]
   \       0x42   0x9104             STR      R1,[SP, #+16]
   \       0x44   0x69C0             LDR      R0,[R0, #+28]
   \       0x46   0x9003             STR      R0,[SP, #+12]
   3946                  if (r && (x2 != x1 || y2 != y1)) {
   \       0x48   0x4628             MOV      R0,R5
   \       0x4A   0x2100             MOVS     R1,#+0
   \       0x4C   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0x50   0xF000 0x80D8      BEQ.W    ??gcode_G2_G3_3
   \       0x54   0x9804             LDR      R0,[SP, #+16]
   \       0x56   0x9902             LDR      R1,[SP, #+8]
   \       0x58   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0x5C   0xD105             BNE.N    ??gcode_G2_G3_4
   \       0x5E   0x9803             LDR      R0,[SP, #+12]
   \       0x60   0x9901             LDR      R1,[SP, #+4]
   \       0x62   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0x66   0xF000 0x80CD      BEQ.W    ??gcode_G2_G3_3
   3947                    const float e = clockwise ^ (r < 0) ? -1 : 1,           // clockwise -1/1, counterclockwise 1/-1
   \                     ??gcode_G2_G3_4: (+1)
   \       0x6A   0x4628             MOV      R0,R5
   \       0x6C   0x2100             MOVS     R1,#+0
   \       0x6E   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x72   0xD201             BCS.N    ??gcode_G2_G3_5
   \       0x74   0x2001             MOVS     R0,#+1
   \       0x76   0xE000             B.N      ??gcode_G2_G3_6
   \                     ??gcode_G2_G3_5: (+1)
   \       0x78   0x4608             MOV      R0,R1
   \                     ??gcode_G2_G3_6: (+1)
   \       0x7A   0xF04F 0x577E      MOV      R7,#+1065353216
   \       0x7E   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \       0x82   0xEA90 0x0F01      TEQ      R0,R1
   \       0x86   0xD001             BEQ.N    ??gcode_G2_G3_7
   \       0x88   0x4E6D             LDR.N    R6,??gcode_G2_G3_0+0x4  ;; 0xbf800000
   \       0x8A   0xE000             B.N      ??gcode_G2_G3_8
   \                     ??gcode_G2_G3_7: (+1)
   \       0x8C   0x463E             MOV      R6,R7
   3948                                dx = x2 - x1, dy = y2 - y1,                 // X and Y differences
   \                     ??gcode_G2_G3_8: (+1)
   \       0x8E   0x9804             LDR      R0,[SP, #+16]
   \       0x90   0x9902             LDR      R1,[SP, #+8]
   \       0x92   0x.... 0x....      BL       __aeabi_fsub
   \       0x96   0x9008             STR      R0,[SP, #+32]
   \       0x98   0x9803             LDR      R0,[SP, #+12]
   \       0x9A   0x9901             LDR      R1,[SP, #+4]
   \       0x9C   0x.... 0x....      BL       __aeabi_fsub
   \       0xA0   0x9007             STR      R0,[SP, #+28]
   3949                                d = HYPOT(dx, dy),                          // Linear distance between the points
   \       0xA2   0xF8DD 0x9020      LDR      R9,[SP, #+32]
   \       0xA6   0x2402             MOVS     R4,#+2
   \       0xA8   0x46B8             MOV      R8,R7
   \       0xAA   0xE004             B.N      ??gcode_G2_G3_9
   \                     ??gcode_G2_G3_10: (+1)
   \       0xAC   0x4648             MOV      R0,R9
   \       0xAE   0x4649             MOV      R1,R9
   \       0xB0   0x.... 0x....      BL       __aeabi_fmul
   \       0xB4   0x4681             MOV      R9,R0
   \                     ??gcode_G2_G3_9: (+1)
   \       0xB6   0x07E0             LSLS     R0,R4,#+31
   \       0xB8   0xD504             BPL.N    ??gcode_G2_G3_11
   \       0xBA   0x4640             MOV      R0,R8
   \       0xBC   0x4649             MOV      R1,R9
   \       0xBE   0x.... 0x....      BL       __aeabi_fmul
   \       0xC2   0x4680             MOV      R8,R0
   \                     ??gcode_G2_G3_11: (+1)
   \       0xC4   0x0864             LSRS     R4,R4,#+1
   \       0xC6   0xD1F1             BNE.N    ??gcode_G2_G3_10
   \       0xC8   0xF8DD 0x901C      LDR      R9,[SP, #+28]
   \       0xCC   0x2402             MOVS     R4,#+2
   \       0xCE   0x46BA             MOV      R10,R7
   \       0xD0   0xE004             B.N      ??gcode_G2_G3_12
   \                     ??gcode_G2_G3_13: (+1)
   \       0xD2   0x4648             MOV      R0,R9
   \       0xD4   0x4649             MOV      R1,R9
   \       0xD6   0x.... 0x....      BL       __aeabi_fmul
   \       0xDA   0x4681             MOV      R9,R0
   \                     ??gcode_G2_G3_12: (+1)
   \       0xDC   0x07E0             LSLS     R0,R4,#+31
   \       0xDE   0xD504             BPL.N    ??gcode_G2_G3_14
   \       0xE0   0x4650             MOV      R0,R10
   \       0xE2   0x4649             MOV      R1,R9
   \       0xE4   0x.... 0x....      BL       __aeabi_fmul
   \       0xE8   0x4682             MOV      R10,R0
   \                     ??gcode_G2_G3_14: (+1)
   \       0xEA   0x0864             LSRS     R4,R4,#+1
   \       0xEC   0xD1F1             BNE.N    ??gcode_G2_G3_13
   \       0xEE   0x4640             MOV      R0,R8
   \       0xF0   0x4651             MOV      R1,R10
   \       0xF2   0x.... 0x....      BL       __aeabi_fadd
   \       0xF6   0x.... 0x....      BL       sqrtf
   \       0xFA   0x4682             MOV      R10,R0
   3950                                h = sqrt(sq(r) - sq(d * 0.5)),              // Distance to the arc pivot-point
   \       0xFC   0x2402             MOVS     R4,#+2
   \       0xFE   0xE004             B.N      ??gcode_G2_G3_15
   \                     ??gcode_G2_G3_16: (+1)
   \      0x100   0x4628             MOV      R0,R5
   \      0x102   0x4629             MOV      R1,R5
   \      0x104   0x.... 0x....      BL       __aeabi_fmul
   \      0x108   0x4605             MOV      R5,R0
   \                     ??gcode_G2_G3_15: (+1)
   \      0x10A   0x07E0             LSLS     R0,R4,#+31
   \      0x10C   0xD504             BPL.N    ??gcode_G2_G3_17
   \      0x10E   0x4638             MOV      R0,R7
   \      0x110   0x4629             MOV      R1,R5
   \      0x112   0x.... 0x....      BL       __aeabi_fmul
   \      0x116   0x4607             MOV      R7,R0
   \                     ??gcode_G2_G3_17: (+1)
   \      0x118   0x0864             LSRS     R4,R4,#+1
   \      0x11A   0xD1F1             BNE.N    ??gcode_G2_G3_16
   \      0x11C   0x4650             MOV      R0,R10
   \      0x11E   0x.... 0x....      BL       __aeabi_f2d
   \      0x122   0x2200             MOVS     R2,#+0
   \      0x124   0x4B47             LDR.N    R3,??gcode_G2_G3_0+0x8  ;; 0x3fe00000
   \      0x126   0x.... 0x....      BL       __aeabi_dmul
   \      0x12A   0xF04F 0x0B02      MOV      R11,#+2
   \      0x12E   0x2400             MOVS     R4,#+0
   \      0x130   0x4D45             LDR.N    R5,??gcode_G2_G3_0+0xC  ;; 0x3ff00000
   \      0x132   0x4680             MOV      R8,R0
   \      0x134   0x4689             MOV      R9,R1
   \      0x136   0xE007             B.N      ??gcode_G2_G3_18
   \                     ??gcode_G2_G3_19: (+1)
   \      0x138   0x4640             MOV      R0,R8
   \      0x13A   0x4649             MOV      R1,R9
   \      0x13C   0x4642             MOV      R2,R8
   \      0x13E   0x464B             MOV      R3,R9
   \      0x140   0x.... 0x....      BL       __aeabi_dmul
   \      0x144   0x4680             MOV      R8,R0
   \      0x146   0x4689             MOV      R9,R1
   \                     ??gcode_G2_G3_18: (+1)
   \      0x148   0xEA5F 0x70CB      LSLS     R0,R11,#+31
   \      0x14C   0xD507             BPL.N    ??gcode_G2_G3_20
   \      0x14E   0x4642             MOV      R2,R8
   \      0x150   0x464B             MOV      R3,R9
   \      0x152   0x4620             MOV      R0,R4
   \      0x154   0x4629             MOV      R1,R5
   \      0x156   0x.... 0x....      BL       __aeabi_dmul
   \      0x15A   0x4604             MOV      R4,R0
   \      0x15C   0x460D             MOV      R5,R1
   \                     ??gcode_G2_G3_20: (+1)
   \      0x15E   0xEA5F 0x0B5B      LSRS     R11,R11,#+1
   \      0x162   0xD1E9             BNE.N    ??gcode_G2_G3_19
   \      0x164   0x4638             MOV      R0,R7
   \      0x166   0x.... 0x....      BL       __aeabi_f2d
   \      0x16A   0x4622             MOV      R2,R4
   \      0x16C   0x462B             MOV      R3,R5
   \      0x16E   0x.... 0x....      BL       __aeabi_dsub
   \      0x172   0x.... 0x....      BL       sqrt
   \      0x176   0x.... 0x....      BL       __aeabi_d2f
   \      0x17A   0x4601             MOV      R1,R0
   3951                                mx = (x1 + x2) * 0.5, my = (y1 + y2) * 0.5, // Point between the two points
   3952                                sx = -dy / d, sy = dx / d,                  // Slope of the perpendicular bisector
   3953                                cx = mx + e * h * sx, cy = my + e * h * sy; // Pivot-point of the arc
   3954                    arc_offset[X_AXIS] = cx - x1;
   \      0x17C   0x4630             MOV      R0,R6
   \      0x17E   0x.... 0x....      BL       __aeabi_fmul
   \      0x182   0x4604             MOV      R4,R0
   \      0x184   0xF04F 0x557C      MOV      R5,#+1056964608
   \      0x188   0x9902             LDR      R1,[SP, #+8]
   \      0x18A   0x9804             LDR      R0,[SP, #+16]
   \      0x18C   0x.... 0x....      BL       __aeabi_fadd
   \      0x190   0x4629             MOV      R1,R5
   \      0x192   0x.... 0x....      BL       __aeabi_fmul
   \      0x196   0x4606             MOV      R6,R0
   \      0x198   0x9807             LDR      R0,[SP, #+28]
   \      0x19A   0x4651             MOV      R1,R10
   \      0x19C   0x.... 0x....      BL       __aeabi_fdiv
   \      0x1A0   0x4621             MOV      R1,R4
   \      0x1A2   0x.... 0x....      BL       __aeabi_fmul
   \      0x1A6   0x4601             MOV      R1,R0
   \      0x1A8   0x4630             MOV      R0,R6
   \      0x1AA   0x.... 0x....      BL       __aeabi_fsub
   \      0x1AE   0x9902             LDR      R1,[SP, #+8]
   \      0x1B0   0x.... 0x....      BL       __aeabi_fsub
   \      0x1B4   0x9005             STR      R0,[SP, #+20]
   3955                    arc_offset[Y_AXIS] = cy - y1;
   \      0x1B6   0x9901             LDR      R1,[SP, #+4]
   \      0x1B8   0x9803             LDR      R0,[SP, #+12]
   \      0x1BA   0x.... 0x....      BL       __aeabi_fadd
   \      0x1BE   0x4629             MOV      R1,R5
   \      0x1C0   0x.... 0x....      BL       __aeabi_fmul
   \      0x1C4   0x4605             MOV      R5,R0
   \      0x1C6   0x9808             LDR      R0,[SP, #+32]
   \      0x1C8   0x4651             MOV      R1,R10
   \      0x1CA   0x.... 0x....      BL       __aeabi_fdiv
   \      0x1CE   0x4621             MOV      R1,R4
   \      0x1D0   0x.... 0x....      BL       __aeabi_fmul
   \      0x1D4   0x4629             MOV      R1,R5
   \      0x1D6   0x.... 0x....      BL       __aeabi_fadd
   \      0x1DA   0x9901             LDR      R1,[SP, #+4]
   \      0x1DC   0x.... 0x....      BL       __aeabi_fsub
   \      0x1E0   0x9006             STR      R0,[SP, #+24]
   \      0x1E2   0xE00F             B.N      ??gcode_G2_G3_3
   3956                  }
   3957                }
   3958                else {
   3959                  if (code_seen('I')) arc_offset[X_AXIS] = code_value_linear_units();
   \                     ??gcode_G2_G3_2: (+1)
   \      0x1E4   0x2049             MOVS     R0,#+73
   \      0x1E6   0x.... 0x....      BL       _Z9code_seenc
   \      0x1EA   0x2800             CMP      R0,#+0
   \      0x1EC   0xD002             BEQ.N    ??gcode_G2_G3_21
   \      0x1EE   0x.... 0x....      BL       _Z16code_value_floatv
   \      0x1F2   0x9005             STR      R0,[SP, #+20]
   3960                  if (code_seen('J')) arc_offset[Y_AXIS] = code_value_linear_units();
   \                     ??gcode_G2_G3_21: (+1)
   \      0x1F4   0x204A             MOVS     R0,#+74
   \      0x1F6   0x.... 0x....      BL       _Z9code_seenc
   \      0x1FA   0x2800             CMP      R0,#+0
   \      0x1FC   0xD002             BEQ.N    ??gcode_G2_G3_3
   \      0x1FE   0x.... 0x....      BL       _Z16code_value_floatv
   \      0x202   0x9006             STR      R0,[SP, #+24]
   3961                }
   3962          
   3963                if (arc_offset[0] || arc_offset[1]) {
   \                     ??gcode_G2_G3_3: (+1)
   \      0x204   0x9805             LDR      R0,[SP, #+20]
   \      0x206   0x2100             MOVS     R1,#+0
   \      0x208   0x.... 0x....      BL       __aeabi_cfcmpeq
   \      0x20C   0xD103             BNE.N    ??gcode_G2_G3_22
   \      0x20E   0x9806             LDR      R0,[SP, #+24]
   \      0x210   0x.... 0x....      BL       __aeabi_cfcmpeq
   \      0x214   0xD008             BEQ.N    ??gcode_G2_G3_23
   3964                  // Send an arc to the planner
   3965                  plan_arc(destination, arc_offset, clockwise);
   \                     ??gcode_G2_G3_22: (+1)
   \      0x216   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \      0x21A   0xA905             ADD      R1,SP,#+20
   \      0x21C   0x480B             LDR.N    R0,??gcode_G2_G3_0+0x10
   \      0x21E   0x.... 0x....      BL       _Z8plan_arcPfS_h
   3966                  refresh_cmd_timeout();
   \      0x222   0x.... 0x....      BL       _Z19refresh_cmd_timeoutv
   \      0x226   0xE005             B.N      ??gcode_G2_G3_1
   3967                }
   3968                else {
   3969                  // Bad arguments
   3970                  SERIAL_ERROR_START;
   \                     ??gcode_G2_G3_23: (+1)
   \      0x228   0x4809             LDR.N    R0,??gcode_G2_G3_0+0x14
   \      0x22A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   3971                  SERIAL_ERRORLNPGM(MSG_ERR_ARC_ARGS);
   \      0x22E   0x4809             LDR.N    R0,??gcode_G2_G3_0+0x18
   \      0x230   0x.... 0x....      BL       _Z14serialprintPGMPKc
   3972                }
   3973              }
   3974            }
   \                     ??gcode_G2_G3_1: (+1)
   \      0x234   0xB009             ADD      SP,SP,#+36
   \      0x236   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \      0x23A   0xBF00             Nop      
   \                     ??gcode_G2_G3_0:
   \      0x23C   0x....'....        DC32     mks_heating_busy
   \      0x240   0xBF80'0000        DC32     0xbf800000
   \      0x244   0x3FE0'0000        DC32     0x3fe00000
   \      0x248   0x3FF0'0000        DC32     0x3ff00000
   \      0x24C   0x....'....        DC32     mks_heating_busy+0x18
   \      0x250   0x....'....        DC32     errormagic
   \      0x254   0x....'....        DC32     _ZZ11gcode_G2_G3bEs

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_78:
   \        0x0   0x0000'0000        DC32 0H, 0H
   \              0x0000'0000  
   3975          #endif
   3976          
   3977          /**
   3978           * G4: Dwell S<seconds> or P<milliseconds>
   3979           */

   \                                 In section .text, align 4
   3980          inline void gcode_G4() {
   \                     _Z8gcode_G4v: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   3981            millis_t dwell_ms = 0;
   \        0x2   0x2400             MOVS     R4,#+0
   3982          
   3983            if (code_seen('P')) dwell_ms = code_value_millis(); // milliseconds to wait
   \        0x4   0x2050             MOVS     R0,#+80
   \        0x6   0x.... 0x....      BL       _Z9code_seenc
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD002             BEQ.N    ??gcode_G4_1
   \        0xE   0x.... 0x....      BL       _Z17code_value_millisv
   \       0x12   0x4604             MOV      R4,R0
   3984            if (code_seen('S')) dwell_ms = code_value_millis_from_seconds(); // seconds to wait
   \                     ??gcode_G4_1: (+1)
   \       0x14   0x2053             MOVS     R0,#+83
   \       0x16   0x.... 0x....      BL       _Z9code_seenc
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD002             BEQ.N    ??gcode_G4_2
   \       0x1E   0x.... 0x....      BL       _Z30code_value_millis_from_secondsv
   \       0x22   0x4604             MOV      R4,R0
   3985          
   3986            stepper.synchronize();
   \                     ??gcode_G4_2: (+1)
   \       0x24   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   3987            refresh_cmd_timeout();
   \       0x28   0x.... 0x....      BL       _Z19refresh_cmd_timeoutv
   3988            dwell_ms += previous_cmd_ms;  // keep track of when we started waiting
   \       0x2C   0x4809             LDR.N    R0,??gcode_G4_0
   \       0x2E   0x6B80             LDR      R0,[R0, #+56]
   \       0x30   0x1904             ADDS     R4,R0,R4
   3989          
   3990            if (!lcd_hasstatus()) LCD_MESSAGEPGM(MSG_DWELL);
   \       0x32   0x.... 0x....      BL       _Z13lcd_hasstatusv
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD107             BNE.N    ??gcode_G4_3
   \       0x3A   0x2100             MOVS     R1,#+0
   \       0x3C   0x4806             LDR.N    R0,??gcode_G4_0+0x4
   \       0x3E   0x.... 0x....      BL       _Z16lcd_setstatuspgmPKch
   \       0x42   0xE002             B.N      ??gcode_G4_3
   3991          
   3992            while (PENDING(millis(), dwell_ms)) idle();
   \                     ??gcode_G4_4: (+1)
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0x.... 0x....      BL       _Z4idleb
   \                     ??gcode_G4_3: (+1)
   \       0x4A   0x.... 0x....      BL       HAL_GetTick
   \       0x4E   0x1B00             SUBS     R0,R0,R4
   \       0x50   0xD4F8             BMI.N    ??gcode_G4_4
   3993          }
   \       0x52   0xBD10             POP      {R4,PC}          ;; return
   \                     ??gcode_G4_0:
   \       0x54   0x....'....        DC32     axis_relative_modes
   \       0x58   0x....'....        DC32     _ZZ8gcode_G4vEs
   3994          
   3995          #if ENABLED(BEZIER_CURVE_SUPPORT)
   3996          
   3997            /**
   3998             * Parameters interpreted according to:
   3999             * http://linuxcnc.org/docs/2.6/html/gcode/gcode.html#sec:G5-Cubic-Spline
   4000             * However I, J omission is not supported at this point; all
   4001             * parameters can be omitted and default to zero.
   4002             */
   4003          
   4004            /**
   4005             * G5: Cubic B-spline
   4006             */
   4007            inline void gcode_G5() {
   4008              if (IsRunning()) {
   4009          
   4010                gcode_get_destination();
   4011          
   4012                const float offset[] = {
   4013                  code_seen('I') ? code_value_linear_units() : 0.0,
   4014                  code_seen('J') ? code_value_linear_units() : 0.0,
   4015                  code_seen('P') ? code_value_linear_units() : 0.0,
   4016                  code_seen('Q') ? code_value_linear_units() : 0.0
   4017                };
   4018          
   4019                plan_cubic_move(offset);
   4020              }
   4021            }
   4022          
   4023          #endif // BEZIER_CURVE_SUPPORT
   4024          
   4025          #if ENABLED(FWRETRACT)
   4026          
   4027            /**
   4028             * G10 - Retract filament according to settings of M207
   4029             * G11 - Recover filament according to settings of M208
   4030             */
   4031            inline void gcode_G10_G11(bool doRetract=false) {
   4032              #if EXTRUDERS > 1
   4033                if (doRetract) {
   4034                  retracted_swap[active_extruder] = (code_seen('S') && code_value_bool()); // checks for swap retract argument
   4035                }
   4036              #endif
   4037              retract(doRetract
   4038               #if EXTRUDERS > 1
   4039                , retracted_swap[active_extruder]
   4040               #endif
   4041              );
   4042            }
   4043          
   4044          #endif //FWRETRACT
   4045          
   4046          #if ENABLED(NOZZLE_CLEAN_FEATURE)
   4047            /**
   4048             * G12: Clean the nozzle
   4049             */
   4050            inline void gcode_G12() {
   4051              // Don't allow nozzle cleaning without homing first
   4052              if (axis_unhomed_error(true, true, true)) return;
   4053          
   4054              const uint8_t pattern = code_seen('P') ? code_value_ushort() : 0,
   4055                            strokes = code_seen('S') ? code_value_ushort() : NOZZLE_CLEAN_STROKES,
   4056                            objects = code_seen('T') ? code_value_ushort() : NOZZLE_CLEAN_TRIANGLES;
   4057              const float radius = code_seen('R') ? code_value_float() : NOZZLE_CLEAN_CIRCLE_RADIUS;
   4058          
   4059              Nozzle::clean(pattern, strokes, radius, objects);
   4060            }
   4061          #endif
   4062          
   4063          #if ENABLED(INCH_MODE_SUPPORT)
   4064            /**
   4065             * G20: Set input mode to inches
   4066             */
   4067            inline void gcode_G20() { set_input_linear_units(LINEARUNIT_INCH); }
   4068          
   4069            /**
   4070             * G21: Set input mode to millimeters
   4071             */
   4072            inline void gcode_G21() { set_input_linear_units(LINEARUNIT_MM); }
   4073          #endif
   4074          
   4075          #if ENABLED(NOZZLE_PARK_FEATURE)
   4076            /**
   4077             * G27: Park the nozzle
   4078             */
   4079            inline void gcode_G27() {
   4080              // Don't allow nozzle parking without homing first
   4081              if (axis_unhomed_error(true, true, true)) return;
   4082              Nozzle::park(code_seen('P') ? code_value_ushort() : 0);
   4083            }
   4084          #endif // NOZZLE_PARK_FEATURE
   4085          
   4086          //#if ENABLED(QUICK_HOME)	//mks_delta
   4087          #if 1

   \                                 In section .text, align 2, keep-with-next
   4088            static void quick_home_xy() {
   \                     _ZN37_INTERNAL_15_Marlin_main_cpp_3178531913quick_home_xyEv: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   4089          
   4090              // Pretend the current position is 0,0
   4091              current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
   \        0x4   0x.... 0x....      LDR.W    R6,??DataTable136_2
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x60F0             STR      R0,[R6, #+12]
   \        0xC   0x60B0             STR      R0,[R6, #+8]
   4092              sync_plan_position();
   \        0xE   0x.... 0x....      BL       _Z18sync_plan_positionv
   4093          
   4094              const int x_axis_home_dir =
   4095                #if ENABLED(DUAL_X_CARRIAGE)
   4096                  x_home_dir(active_extruder)
   4097                #else
   4098                  home_dir(X_AXIS)
   4099                #endif
   4100              ;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_317853198home_dirE8AxisEnum
   \       0x18   0x4681             MOV      R9,R0
   4101          
   4102              const float mlx = max_length(X_AXIS),
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531910max_lengthE8AxisEnum
   \       0x20   0x4680             MOV      R8,R0
   4103                          mly = max_length(Y_AXIS),
   \       0x22   0x2001             MOVS     R0,#+1
   \       0x24   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531910max_lengthE8AxisEnum
   \       0x28   0x4607             MOV      R7,R0
   4104                          mlratio = mlx > mly ? mly / mlx : mlx / mly,
   \       0x2A   0x4641             MOV      R1,R8
   \       0x2C   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x30   0xD203             BCS.N    ??quick_home_xy_0
   \       0x32   0x.... 0x....      BL       __aeabi_fdiv
   \       0x36   0x4683             MOV      R11,R0
   \       0x38   0xE004             B.N      ??quick_home_xy_1
   \                     ??quick_home_xy_0: (+1)
   \       0x3A   0x4640             MOV      R0,R8
   \       0x3C   0x4639             MOV      R1,R7
   \       0x3E   0x.... 0x....      BL       __aeabi_fdiv
   \       0x42   0x4683             MOV      R11,R0
   4105                          fr_mm_s = min(homing_feedrate_mm_s[X_AXIS], homing_feedrate_mm_s[Y_AXIS]) * sqrt(sq(mlratio) + 1.0);
   \                     ??quick_home_xy_1: (+1)
   \       0x44   0x6AF1             LDR      R1,[R6, #+44]
   \       0x46   0x6AB0             LDR      R0,[R6, #+40]
   \       0x48   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x4C   0xD201             BCS.N    ??quick_home_xy_2
   \       0x4E   0x4605             MOV      R5,R0
   \       0x50   0xE000             B.N      ??quick_home_xy_3
   \                     ??quick_home_xy_2: (+1)
   \       0x52   0x460D             MOV      R5,R1
   \                     ??quick_home_xy_3: (+1)
   \       0x54   0x2402             MOVS     R4,#+2
   \       0x56   0xF04F 0x5A7E      MOV      R10,#+1065353216
   \       0x5A   0xE004             B.N      ??quick_home_xy_4
   \                     ??quick_home_xy_5: (+1)
   \       0x5C   0x4658             MOV      R0,R11
   \       0x5E   0x4659             MOV      R1,R11
   \       0x60   0x.... 0x....      BL       __aeabi_fmul
   \       0x64   0x4683             MOV      R11,R0
   \                     ??quick_home_xy_4: (+1)
   \       0x66   0x07E0             LSLS     R0,R4,#+31
   \       0x68   0xD504             BPL.N    ??quick_home_xy_6
   \       0x6A   0x4650             MOV      R0,R10
   \       0x6C   0x4659             MOV      R1,R11
   \       0x6E   0x.... 0x....      BL       __aeabi_fmul
   \       0x72   0x4682             MOV      R10,R0
   \                     ??quick_home_xy_6: (+1)
   \       0x74   0x0864             LSRS     R4,R4,#+1
   \       0x76   0xD1F1             BNE.N    ??quick_home_xy_5
   \       0x78   0x4628             MOV      R0,R5
   \       0x7A   0x.... 0x....      BL       __aeabi_f2d
   \       0x7E   0x4604             MOV      R4,R0
   \       0x80   0x460D             MOV      R5,R1
   \       0x82   0x4650             MOV      R0,R10
   \       0x84   0x.... 0x....      BL       __aeabi_f2d
   \       0x88   0x2200             MOVS     R2,#+0
   \       0x8A   0x.... 0x....      LDR.W    R3,??DataTable133  ;; 0x3ff00000
   \       0x8E   0x.... 0x....      BL       __aeabi_dadd
   \       0x92   0x.... 0x....      BL       sqrt
   \       0x96   0x4622             MOV      R2,R4
   \       0x98   0x462B             MOV      R3,R5
   \       0x9A   0x.... 0x....      BL       __aeabi_dmul
   \       0x9E   0x.... 0x....      BL       __aeabi_d2f
   \       0xA2   0x9002             STR      R0,[SP, #+8]
   4106          
   4107              do_blocking_move_to_xy(0.1 * mlx * x_axis_home_dir, 0.1 * mly * home_dir(Y_AXIS), fr_mm_s);
   \       0xA4   0x.... 0x....      LDR.W    R4,??DataTable133_4  ;; 0x9999999a
   \       0xA8   0x.... 0x....      LDR.W    R5,??DataTable136_15  ;; 0x3fb99999
   \       0xAC   0x4640             MOV      R0,R8
   \       0xAE   0x.... 0x....      BL       __aeabi_f2d
   \       0xB2   0x4622             MOV      R2,R4
   \       0xB4   0x462B             MOV      R3,R5
   \       0xB6   0x.... 0x....      BL       __aeabi_dmul
   \       0xBA   0x4682             MOV      R10,R0
   \       0xBC   0x468B             MOV      R11,R1
   \       0xBE   0x4648             MOV      R0,R9
   \       0xC0   0x.... 0x....      BL       __aeabi_i2d
   \       0xC4   0x4652             MOV      R2,R10
   \       0xC6   0x465B             MOV      R3,R11
   \       0xC8   0x.... 0x....      BL       __aeabi_dmul
   \       0xCC   0x.... 0x....      BL       __aeabi_d2f
   \       0xD0   0x9001             STR      R0,[SP, #+4]
   \       0xD2   0x4638             MOV      R0,R7
   \       0xD4   0x.... 0x....      BL       __aeabi_f2d
   \       0xD8   0x4622             MOV      R2,R4
   \       0xDA   0x462B             MOV      R3,R5
   \       0xDC   0x.... 0x....      BL       __aeabi_dmul
   \       0xE0   0x4604             MOV      R4,R0
   \       0xE2   0x460D             MOV      R5,R1
   \       0xE4   0x2001             MOVS     R0,#+1
   \       0xE6   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_317853198home_dirE8AxisEnum
   \       0xEA   0x.... 0x....      BL       __aeabi_i2d
   \       0xEE   0x4622             MOV      R2,R4
   \       0xF0   0x462B             MOV      R3,R5
   \       0xF2   0x.... 0x....      BL       __aeabi_dmul
   \       0xF6   0x.... 0x....      BL       __aeabi_d2f
   \       0xFA   0x9000             STR      R0,[SP, #+0]
   \       0xFC   0xAA02             ADD      R2,SP,#+8
   \       0xFE   0x4669             MOV      R1,SP
   \      0x100   0xA801             ADD      R0,SP,#+4
   \      0x102   0x.... 0x....      BL       _Z22do_blocking_move_to_xyRKfS0_S0_
   4108              endstops.hit_on_purpose(); // clear endstop hit flags
   \      0x106   0x.... 0x....      BL       _ZN8Endstops14hit_on_purposeEv
   4109              current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
   \      0x10A   0x2000             MOVS     R0,#+0
   \      0x10C   0x60F0             STR      R0,[R6, #+12]
   \      0x10E   0x60B0             STR      R0,[R6, #+8]
   4110            }
   \      0x110   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
   4111          
   4112          #endif // QUICK_HOME
   4113          
   4114          #if ENABLED(DEBUG_LEVELING_FEATURE)
   4115          
   4116            void log_machine_info() 
   4117          {
   4118          }
   4119          
   4120          #endif // DEBUG_LEVELING_FEATURE
   4121          
   4122          //#if ENABLED(DELTA)	//mks_delta
   4123          #if 1
   4124            /**
   4125             * A delta can only safely home all axes at the same time
   4126             * This is like quick_home_xy() but for 3 towers.
   4127             */

   \                                 In section .text, align 4
   4128            inline void home_delta() {
   \                     _Z10home_deltav: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   4129              #if ENABLED(DEBUG_LEVELING_FEATURE)
   4130                if (DEBUGGING(LEVELING)) DEBUG_POS(">>> home_delta", current_position);
   4131              #endif
   4132              // Init the current position of all carriages to 0,0,0
   4133              ZERO(current_position);
   \        0x2   0x4C1A             LDR.N    R4,??home_delta_0
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x2110             MOVS     R1,#+16
   \        0x8   0xF104 0x0008      ADD      R0,R4,#+8
   \        0xC   0x.... 0x....      BL       __aeabi_memset
   4134              sync_plan_position();
   \       0x10   0x.... 0x....      BL       _Z18sync_plan_positionv
   4135          
   4136              // Move all carriages together linearly until an endstop is hit.
   4137              current_position[X_AXIS] = current_position[Y_AXIS] = current_position[Z_AXIS] = (Z_MAX_LENGTH + 10);
   \       0x14   0x4916             LDR.N    R1,??home_delta_0+0x4
   \       0x16   0x69C8             LDR      R0,[R1, #+28]
   \       0x18   0x6909             LDR      R1,[R1, #+16]
   \       0x1A   0x.... 0x....      BL       __aeabi_fsub
   \       0x1E   0x4915             LDR.N    R1,??home_delta_0+0x8  ;; 0x41200000
   \       0x20   0x.... 0x....      BL       __aeabi_fadd
   \       0x24   0x6120             STR      R0,[R4, #+16]
   \       0x26   0x60E0             STR      R0,[R4, #+12]
   \       0x28   0x60A0             STR      R0,[R4, #+8]
   4138              feedrate_mm_s = homing_feedrate_mm_s[X_AXIS];
   \       0x2A   0x6AA0             LDR      R0,[R4, #+40]
   \       0x2C   0x6760             STR      R0,[R4, #+116]
   4139              line_to_current_position();
   \       0x2E   0x.... 0x....      BL       _Z24line_to_current_positionv
   4140              stepper.synchronize();
   \       0x32   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   4141              endstops.hit_on_purpose(); // clear endstop hit flags
   \       0x36   0x.... 0x....      BL       _ZN8Endstops14hit_on_purposeEv
   4142          
   4143              // At least one carriage has reached the top.
   4144              // Now re-home each carriage separately.
   4145              HOMEAXIS(A);
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_317853198homeaxisE8AxisEnum
   4146              HOMEAXIS(B);
   \       0x40   0x2001             MOVS     R0,#+1
   \       0x42   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_317853198homeaxisE8AxisEnum
   4147              HOMEAXIS(C);
   \       0x46   0x2002             MOVS     R0,#+2
   \       0x48   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_317853198homeaxisE8AxisEnum
   4148          
   4149              // Set all carriages to their home positions
   4150              // Do this here all at once for Delta, because
   4151              // XYZ isn't ABC. Applying this per-tower would
   4152              // give the impression that they are the same.
   4153              LOOP_XYZ(i) set_axis_is_at_home((AxisEnum)i);
   \       0x4C   0x2400             MOVS     R4,#+0
   \       0x4E   0xE004             B.N      ??home_delta_1
   \                     ??home_delta_2: (+1)
   \       0x50   0x4620             MOV      R0,R4
   \       0x52   0xB240             SXTB     R0,R0
   \       0x54   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531919set_axis_is_at_homeE8AxisEnum
   \       0x58   0x1C64             ADDS     R4,R4,#+1
   \                     ??home_delta_1: (+1)
   \       0x5A   0x4620             MOV      R0,R4
   \       0x5C   0xB2C0             UXTB     R0,R0
   \       0x5E   0x2803             CMP      R0,#+3
   \       0x60   0xDBF6             BLT.N    ??home_delta_2
   4154          
   4155              SYNC_PLAN_POSITION_KINEMATIC();
   \       0x62   0xE8BD 0x4010      POP      {R4,LR}
   \       0x66   0x.... 0x....      B.W      _Z28SYNC_PLAN_POSITION_KINEMATICv
   \       0x6A   0xBF00             Nop      
   \                     ??home_delta_0:
   \       0x6C   0x....'....        DC32     mks_heating_busy
   \       0x70   0x....'....        DC32     mksCfg
   \       0x74   0x4120'0000        DC32     0x41200000
   4156          
   4157              #if ENABLED(DEBUG_LEVELING_FEATURE)
   4158                if (DEBUGGING(LEVELING)) DEBUG_POS("<<< home_delta", current_position);
   4159              #endif
   4160            }
   4161          
   4162          #endif // DELTA
   4163          
   4164          #if ENABLED(Z_SAFE_HOMING)
   4165          
   4166            inline void home_z_safely() {
   4167          
   4168              // Disallow Z homing if X or Y are unknown
   4169              if (!axis_known_position[X_AXIS] || !axis_known_position[Y_AXIS]) {
   4170                LCD_MESSAGEPGM(MSG_ERR_Z_HOMING);
   4171                SERIAL_ECHO_START;
   4172                SERIAL_ECHOLNPGM(MSG_ERR_Z_HOMING);
   4173                return;
   4174              }
   4175          
   4176              #if ENABLED(DEBUG_LEVELING_FEATURE)
   4177                if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Z_SAFE_HOMING >>>");
   4178              #endif
   4179          
   4180              SYNC_PLAN_POSITION_KINEMATIC();
   4181          
   4182              /**
   4183               * Move the Z probe (or just the nozzle) to the safe homing point
   4184               */
   4185              destination[X_AXIS] = LOGICAL_X_POSITION(Z_SAFE_HOMING_X_POINT);
   4186              destination[Y_AXIS] = LOGICAL_Y_POSITION(Z_SAFE_HOMING_Y_POINT);
   4187              destination[Z_AXIS] = current_position[Z_AXIS]; // Z is already at the right height
   4188          
   4189          #if 0		/*--mks cfg--*/
   4190              if (position_is_reachable(
   4191                    destination
   4192                    #if HOMING_Z_WITH_PROBE
   4193                      , true
   4194                    #endif
   4195                  )
   4196              ) 
   4197          #endif    
   4198          bool cfg_tmp_bool;    
   4199           if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))	/*--mks cfg--*/
   4200          	{
   4201          	#if HOMING_Z_WITH_PROBE
   4202              cfg_tmp_bool = (position_is_reachable(destination , true)); 
   4203          	#else
   4204              cfg_tmp_bool = (position_is_reachable(destination)); 
   4205          	#endif
   4206          	}
   4207          else
   4208          	cfg_tmp_bool = (position_is_reachable(destination));
   4209          
   4210          	if(cfg_tmp_bool)
   4211          		
   4212              {
   4213          
   4214                #if HOMING_Z_WITH_PROBE
   4215          	  if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))	/*--mks cfg--*/
   4216          	  	{	/*--mks cfg--*/
   4217                  destination[X_AXIS] -= X_PROBE_OFFSET_FROM_EXTRUDER;
   4218                  destination[Y_AXIS] -= Y_PROBE_OFFSET_FROM_EXTRUDER;
   4219          	  	}
   4220                #endif
   4221          
   4222                #if ENABLED(DEBUG_LEVELING_FEATURE)
   4223                  if (DEBUGGING(LEVELING)) DEBUG_POS("Z_SAFE_HOMING", destination);
   4224                #endif
   4225          
   4226                // This causes the carriage on Dual X to unpark
   4227                #if ENABLED(DUAL_X_CARRIAGE)
   4228                  active_extruder_parked = false;
   4229                #endif
   4230          
   4231                do_blocking_move_to_xy(destination[X_AXIS], destination[Y_AXIS]);
   4232                HOMEAXIS(Z);
   4233              }
   4234              else {
   4235                LCD_MESSAGEPGM(MSG_ZPROBE_OUT);
   4236                SERIAL_ECHO_START;
   4237                SERIAL_ECHOLNPGM(MSG_ZPROBE_OUT);
   4238              }
   4239          
   4240              #if ENABLED(DEBUG_LEVELING_FEATURE)
   4241                if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< Z_SAFE_HOMING");
   4242              #endif
   4243            }
   4244          
   4245          #endif // Z_SAFE_HOMING
   4246          
   4247          #if ENABLED(PROBE_MANUALLY)
   4248            bool g29_in_progress = false;
   4249          #else
   4250            constexpr bool g29_in_progress = false;
   4251          #endif
   4252          
   4253          /**
   4254           * G28: Home all axes according to settings
   4255           *
   4256           * Parameters
   4257           *
   4258           *  None  Home to all axes with no parameters.
   4259           *        With QUICK_HOME enabled XY will home together, then Z.
   4260           *
   4261           * Cartesian parameters
   4262           *
   4263           *  X   Home to the X endstop
   4264           *  Y   Home to the Y endstop
   4265           *  Z   Home to the Z endstop
   4266           *
   4267           */

   \                                 In section .text, align 4
   4268          inline void gcode_G28() {
   \                     _Z9gcode_G28v: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   4269          
   4270            #if ENABLED(DEBUG_LEVELING_FEATURE)
   4271              if (DEBUGGING(LEVELING)) {
   4272                SERIAL_ECHOLNPGM(">>> gcode_G28");
   4273                log_machine_info();
   4274              }
   4275            #endif
   4276          
   4277            // Wait for planner moves to finish!
   4278            stepper.synchronize();
   \        0x4   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   4279          
   4280            // Cancel the active G29 session
   4281            #if ENABLED(PROBE_MANUALLY)
   4282              g29_in_progress = false;
   4283            #endif
   4284          
   4285            // Disable the leveling matrix before homing
   4286          //  #if HAS_LEVELING
   4287             bool bed_leveling_state_at_entry;
   4288            if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
   \        0x8   0xF8DF 0xB14C      LDR.W    R11,??gcode_G28_0
   \        0xC   0xF10B 0x093F      ADD      R9,R11,#+63
   \       0x10   0xF899 0x0001      LDRB     R0,[R9, #+1]
   \       0x14   0x2810             CMP      R0,#+16
   \       0x16   0xD102             BNE.N    ??gcode_G28_1
   4289              bed_leveling_state_at_entry = ubl.state.active;
   \       0x18   0x4950             LDR.N    R1,??gcode_G28_0+0x4
   \       0x1A   0xF891 0xA000      LDRB     R10,[R1, #+0]
   4290          
   4291            if(BED_LEVELING_METHOD&HAS_LEVELING)
   \                     ??gcode_G28_1: (+1)
   \       0x1E   0xF010 0x0F3E      TST      R0,#0x3E
   \       0x22   0xD002             BEQ.N    ??gcode_G28_2
   4292            	{
   4293          	//#if ENABLED(AUTO_BED_LEVELING_UBL)
   4294          	/*if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_UBL)
   4295          		{
   4296          		const bool bed_leveling_state_at_entry = ubl.state.active;
   4297          		}*/
   4298          	//#endif
   4299          	
   4300              set_bed_leveling_enabled(false);
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   4301            	}
   4302            //#endif
   4303          
   4304            // Always home with tool 0 active
   4305            #if HOTENDS > 1
   4306              const uint8_t old_tool_index = active_extruder;
   4307              tool_change(0, 0, true);
   4308            #endif
   4309          
   4310            #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
   4311              extruder_duplication_enabled = false;
   4312            #endif
   4313          
   4314            setup_for_endstop_or_probe_move();
   \                     ??gcode_G28_2: (+1)
   \       0x2A   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531931setup_for_endstop_or_probe_moveEv
   4315            #if ENABLED(DEBUG_LEVELING_FEATURE)
   4316              if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> endstops.enable(true)");
   4317            #endif
   4318            endstops.enable(true); // Enable endstops for next homing move
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0x.... 0x....      BL       _ZN8Endstops6enableEb
   4319          
   4320            //#if ENABLED(DELTA)
   4321            if(MACHINETPYE == DELTA)
   \       0x34   0xF9BB 0x0058      LDRSH    R0,[R11, #+88]
   \       0x38   0x2802             CMP      R0,#+2
   \       0x3A   0xD102             BNE.N    ??gcode_G28_3
   4322          
   4323              home_delta();
   \       0x3C   0x.... 0x....      BL       _Z10home_deltav
   \       0x40   0xE07A             B.N      ??gcode_G28_4
   4324          
   4325            //#else // NOT DELTA
   4326          	else 
   4327          		{
   4328              const bool homeX = code_seen('X'), homeY = code_seen('Y'), homeZ = code_seen('Z'),
   \                     ??gcode_G28_3: (+1)
   \       0x42   0x2058             MOVS     R0,#+88
   \       0x44   0x.... 0x....      BL       _Z9code_seenc
   \       0x48   0x4606             MOV      R6,R0
   \       0x4A   0x2059             MOVS     R0,#+89
   \       0x4C   0x.... 0x....      BL       _Z9code_seenc
   \       0x50   0x4605             MOV      R5,R0
   \       0x52   0x205A             MOVS     R0,#+90
   \       0x54   0x.... 0x....      BL       _Z9code_seenc
   \       0x58   0x4607             MOV      R7,R0
   4329                         home_all_axis = (!homeX && !homeY && !homeZ) || (homeX && homeY && homeZ);
   \       0x5A   0xEA45 0x0806      ORR      R8,R5,R6
   \       0x5E   0xEA57 0x0008      ORRS     R0,R7,R8
   \       0x62   0xD009             BEQ.N    ??gcode_G28_5
   \       0x64   0x2E00             CMP      R6,#+0
   \       0x66   0xD009             BEQ.N    ??gcode_G28_6
   \       0x68   0x2D00             CMP      R5,#+0
   \       0x6A   0xD007             BEQ.N    ??gcode_G28_6
   \       0x6C   0x463C             MOV      R4,R7
   \       0x6E   0x1E64             SUBS     R4,R4,#+1
   \       0x70   0x41A4             SBCS     R4,R4,R4
   \       0x72   0x43E4             MVNS     R4,R4
   \       0x74   0x0FE4             LSRS     R4,R4,#+31
   \       0x76   0xE002             B.N      ??gcode_G28_7
   \                     ??gcode_G28_5: (+1)
   \       0x78   0x2401             MOVS     R4,#+1
   \       0x7A   0xE000             B.N      ??gcode_G28_7
   \                     ??gcode_G28_6: (+1)
   \       0x7C   0x2400             MOVS     R4,#+0
   4330          
   4331              set_destination_to_current();
   \                     ??gcode_G28_7: (+1)
   \       0x7E   0x.... 0x....      BL       _Z26set_destination_to_currentv
   4332          
   4333             // #if Z_HOME_DIR > 0  // If homing away from BED do Z first
   4334          if(Z_HOME_DIR > 0){		/*--mks cfg--*/
   \       0x82   0xF99B 0x0006      LDRSB    R0,[R11, #+6]
   \       0x86   0x2800             CMP      R0,#+0
   \       0x88   0xDD07             BLE.N    ??gcode_G28_8
   4335                if (home_all_axis || homeZ) {
   \       0x8A   0x2C00             CMP      R4,#+0
   \       0x8C   0xD101             BNE.N    ??gcode_G28_9
   \       0x8E   0x2F00             CMP      R7,#+0
   \       0x90   0xD01B             BEQ.N    ??gcode_G28_10
   4336                  HOMEAXIS(Z);
   \                     ??gcode_G28_9: (+1)
   \       0x92   0x2002             MOVS     R0,#+2
   \       0x94   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_317853198homeaxisE8AxisEnum
   \       0x98   0xE017             B.N      ??gcode_G28_10
   4337                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   4338                    if (DEBUGGING(LEVELING)) DEBUG_POS("> HOMEAXIS(Z)", current_position);
   4339                  #endif
   4340                }
   4341          }
   4342             // #else	/*--mks cfg--*/
   4343             else
   4344              	{
   4345                if ((home_all_axis || homeX || homeY) && (mksReprint.mks_printer_state != MKS_REPRINTED)) {    // mksReprint.mks_printer_state
   \                     ??gcode_G28_8: (+1)
   \       0x9A   0x2C00             CMP      R4,#+0
   \       0x9C   0xD102             BNE.N    ??gcode_G28_11
   \       0x9E   0xF1B8 0x0F00      CMP      R8,#+0
   \       0xA2   0xD012             BEQ.N    ??gcode_G28_10
   \                     ??gcode_G28_11: (+1)
   \       0xA4   0x482E             LDR.N    R0,??gcode_G28_0+0x8
   \       0xA6   0xF890 0x0068      LDRB     R0,[R0, #+104]
   \       0xAA   0x28AB             CMP      R0,#+171
   \       0xAC   0xD00D             BEQ.N    ??gcode_G28_10
   4346                  // Raise Z before homing any other axes and z is not already high enough (never lower z)
   4347                  destination[Z_AXIS] = LOGICAL_Z_POSITION(Z_HOMING_HEIGHT);
   \       0xAE   0x4A2D             LDR.N    R2,??gcode_G28_0+0xC
   \       0xB0   0x6CD1             LDR      R1,[R2, #+76]
   \       0xB2   0x6211             STR      R1,[R2, #+32]
   4348                  if (destination[Z_AXIS] > current_position[Z_AXIS]) {
   \       0xB4   0x6910             LDR      R0,[R2, #+16]
   \       0xB6   0x.... 0x....      BL       __aeabi_cfcmple
   \       0xBA   0xD206             BCS.N    ??gcode_G28_10
   4349          
   4350                    #if ENABLED(DEBUG_LEVELING_FEATURE)
   4351                      if (DEBUGGING(LEVELING))
   4352                        SERIAL_ECHOLNPAIR("Raise Z (before homing) to ", destination[Z_AXIS]);
   4353                    #endif
   4354          
   4355                    do_blocking_move_to_z(destination[Z_AXIS]);
   \       0xBC   0x2000             MOVS     R0,#+0
   \       0xBE   0x9000             STR      R0,[SP, #+0]
   \       0xC0   0x4669             MOV      R1,SP
   \       0xC2   0xF102 0x0020      ADD      R0,R2,#+32
   \       0xC6   0x.... 0x....      BL       _Z21do_blocking_move_to_zRKfS0_
   4356                  }
   4357                }
   4358              	}
   4359             // #endif	/*--mks cfg--*/
   4360          
   4361          //    #if ENABLED(QUICK_HOME)		//mks_delta
   4362             if(MACHINETPYE&IS_SCARA)
   \                     ??gcode_G28_10: (+1)
   \       0xCA   0xF8BB 0x0058      LDRH     R0,[R11, #+88]
   \       0xCE   0xF410 0x7F40      TST      R0,#0x300
   \       0xD2   0xD007             BEQ.N    ??gcode_G28_12
   4363                if (home_all_axis || (homeX && homeY)) quick_home_xy();
   \       0xD4   0x2C00             CMP      R4,#+0
   \       0xD6   0xD103             BNE.N    ??gcode_G28_13
   \       0xD8   0x2E00             CMP      R6,#+0
   \       0xDA   0xD003             BEQ.N    ??gcode_G28_12
   \       0xDC   0x2D00             CMP      R5,#+0
   \       0xDE   0xD001             BEQ.N    ??gcode_G28_12
   \                     ??gcode_G28_13: (+1)
   \       0xE0   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531913quick_home_xyEv
   4364          //    #endif
   4365          
   4366             // #if ENABLED(HOME_Y_BEFORE_X)	/*--mks cfg--*/
   4367          	if(HOME_Y_BEFORE_X)
   \                     ??gcode_G28_12: (+1)
   \       0xE4   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \       0xE8   0x2800             CMP      R0,#+0
   \       0xEA   0xD006             BEQ.N    ??gcode_G28_14
   4368                // Home Y
   4369                if (home_all_axis || homeY) {
   \       0xEC   0x2C00             CMP      R4,#+0
   \       0xEE   0xD101             BNE.N    ??gcode_G28_15
   \       0xF0   0x2D00             CMP      R5,#+0
   \       0xF2   0xD002             BEQ.N    ??gcode_G28_14
   4370                  HOMEAXIS(Y);
   \                     ??gcode_G28_15: (+1)
   \       0xF4   0x2001             MOVS     R0,#+1
   \       0xF6   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_317853198homeaxisE8AxisEnum
   4371                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   4372                    if (DEBUGGING(LEVELING)) DEBUG_POS("> homeY", current_position);
   4373                  #endif
   4374                }
   4375          
   4376              //#endif
   4377          
   4378              // Home X
   4379              if (home_all_axis || homeX) {
   \                     ??gcode_G28_14: (+1)
   \       0xFA   0x2C00             CMP      R4,#+0
   \       0xFC   0xD101             BNE.N    ??gcode_G28_16
   \       0xFE   0x2E00             CMP      R6,#+0
   \      0x100   0xD002             BEQ.N    ??gcode_G28_17
   4380          
   4381                #if ENABLED(DUAL_X_CARRIAGE)
   4382          
   4383                  // Always home the 2nd (right) extruder first
   4384                  active_extruder = 1;
   4385                  HOMEAXIS(X);
   4386          
   4387                  // Remember this extruder's position for later tool change
   4388                  inactive_extruder_x_pos = RAW_X_POSITION(current_position[X_AXIS]);
   4389          
   4390                  // Home the 1st (left) extruder
   4391                  active_extruder = 0;
   4392                  HOMEAXIS(X);
   4393          
   4394                  // Consider the active extruder to be parked
   4395                  COPY(raised_parked_position, current_position);
   4396                  delayed_move_time = 0;
   4397                  active_extruder_parked = true;
   4398          
   4399                #else
   4400          
   4401                  HOMEAXIS(X);
   \                     ??gcode_G28_16: (+1)
   \      0x102   0x2000             MOVS     R0,#+0
   \      0x104   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_317853198homeaxisE8AxisEnum
   4402          
   4403                #endif
   4404          
   4405                #if ENABLED(DEBUG_LEVELING_FEATURE)
   4406                  if (DEBUGGING(LEVELING)) DEBUG_POS("> homeX", current_position);
   4407                #endif
   4408              }
   4409          
   4410          //    #if DISABLED(HOME_Y_BEFORE_X)	/*--mks cfg--*/
   4411          	if(!HOME_Y_BEFORE_X)
   \                     ??gcode_G28_17: (+1)
   \      0x108   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \      0x10C   0x2800             CMP      R0,#+0
   \      0x10E   0xD106             BNE.N    ??gcode_G28_18
   4412                // Home Y
   4413                if (home_all_axis || homeY) {
   \      0x110   0x2C00             CMP      R4,#+0
   \      0x112   0xD101             BNE.N    ??gcode_G28_19
   \      0x114   0x2D00             CMP      R5,#+0
   \      0x116   0xD002             BEQ.N    ??gcode_G28_18
   4414                  HOMEAXIS(Y);
   \                     ??gcode_G28_19: (+1)
   \      0x118   0x2001             MOVS     R0,#+1
   \      0x11A   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_317853198homeaxisE8AxisEnum
   4415                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   4416                    if (DEBUGGING(LEVELING)) DEBUG_POS("> homeY", current_position);
   4417                  #endif
   4418                }
   4419              //#endif
   4420          
   4421              // Home Z last if homing towards the bed
   4422              //#if Z_HOME_DIR < 0	/*--mks cfg--*/
   4423          	if(Z_HOME_DIR < 0)
   \                     ??gcode_G28_18: (+1)
   \      0x11E   0xF99B 0x0006      LDRSB    R0,[R11, #+6]
   \      0x122   0x2800             CMP      R0,#+0
   \      0x124   0xD506             BPL.N    ??gcode_G28_20
   4424                if (home_all_axis || homeZ) {
   \      0x126   0x2C00             CMP      R4,#+0
   \      0x128   0xD101             BNE.N    ??gcode_G28_21
   \      0x12A   0x2F00             CMP      R7,#+0
   \      0x12C   0xD002             BEQ.N    ??gcode_G28_20
   4425                  #if ENABLED(Z_SAFE_HOMING)
   4426                    home_z_safely();
   4427                  #else
   4428                    HOMEAXIS(Z);
   \                     ??gcode_G28_21: (+1)
   \      0x12E   0x2002             MOVS     R0,#+2
   \      0x130   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_317853198homeaxisE8AxisEnum
   4429                  #endif
   4430                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   4431                    if (DEBUGGING(LEVELING)) DEBUG_POS("> (home_all_axis || homeZ) > final", current_position);
   4432                  #endif
   4433                } // home_all_axis || homeZ
   4434          
   4435          	//#endif // Z_HOME_DIR < 0	/*--mks cfg--*/
   4436          
   4437              SYNC_PLAN_POSITION_KINEMATIC();
   \                     ??gcode_G28_20: (+1)
   \      0x134   0x.... 0x....      BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
   4438          }
   4439            //#endif // !DELTA (gcode_G28)
   4440          
   4441            endstops.not_homing();
   \                     ??gcode_G28_4: (+1)
   \      0x138   0x.... 0x....      BL       _ZN8Endstops10not_homingEv
   4442          
   4443            #if ENABLED(DELTA) && ENABLED(DELTA_HOME_TO_SAFE_ZONE)
   4444              // move to a height where we can use the full xy-area
   4445              abc
   4446              do_blocking_move_to_z(delta_clip_start_height);
   4447            #endif
   4448          //#if ENABLED(AUTO_BED_LEVELING_UBL)
   4449          	if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
   \      0x13C   0xF899 0x0001      LDRB     R0,[R9, #+1]
   \      0x140   0x2810             CMP      R0,#+16
   \      0x142   0xD103             BNE.N    ??gcode_G28_22
   4450              set_bed_leveling_enabled(bed_leveling_state_at_entry);
   \      0x144   0x4650             MOV      R0,R10
   \      0x146   0xB2C0             UXTB     R0,R0
   \      0x148   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   4451          //#endif
   4452            clean_up_after_endstop_or_probe_move();
   \                     ??gcode_G28_22: (+1)
   \      0x14C   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531936clean_up_after_endstop_or_probe_moveEv
   4453          
   4454            // Restore the active tool after homing
   4455            #if HOTENDS > 1
   4456              tool_change(old_tool_index, 0, true);
   4457            #endif
   4458          
   4459            report_current_position();
   \      0x150   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531923report_current_positionEv
   4460          
   4461            #if ENABLED(DEBUG_LEVELING_FEATURE)
   4462              if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< gcode_G28");
   4463            #endif
   4464          } // G28
   \      0x154   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
   \                     ??gcode_G28_0:
   \      0x158   0x....'....        DC32     mksCfg
   \      0x15C   0x....'....        DC32     _ZN20unified_bed_leveling5stateE
   \      0x160   0x....'....        DC32     mksReprint
   \      0x164   0x....'....        DC32     mks_heating_busy
   4465          

   \                                 In section .text, align 2, keep-with-next
   4466          void home_all_axes() { gcode_G28(); }
   \                     _Z13home_all_axesv: (+1)
   \        0x0   0x.... 0x....      B.W      _Z9gcode_G28v
   4467          
   4468          #if HAS_PROBING_PROCEDURE
   4469          

   \                                 In section .text, align 2, keep-with-next
   4470            void out_of_range_error(const char* p_edge) {
   \                     _Z18out_of_range_errorPKc: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   4471              SERIAL_PROTOCOLPGM("?Probe ");
   \        0x4   0x.... 0x....      ADR.W    R0,?_18
   \        0x8   0x.... 0x....      BL       _Z14serialprintPGMPKc
   4472              serialprintPGM(p_edge);
   \        0xC   0x4620             MOV      R0,R4
   \        0xE   0x.... 0x....      BL       _Z14serialprintPGMPKc
   4473              SERIAL_PROTOCOLLNPGM(" position out of range.");
   \       0x12   0x.... 0x....      ADR.W    R0,?_19
   \       0x16   0xE8BD 0x4010      POP      {R4,LR}
   \       0x1A   0x.... 0x....      B.W      _Z14serialprintPGMPKc
   4474            }
   4475          
   4476          #endif
   4477          
   4478          /*--mks cfg-- MESH_BED_LEVELING */
   4479          //#if ENABLED(MESH_BED_LEVELING) || ENABLED(PROBE_MANUALLY)
   4480          #if 1

   \                                 In section .text, align 4
   4481            inline void _manual_goto_xy(const float &x, const float &y) {
   \                     _Z15_manual_goto_xyRKfS0_: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x460F             MOV      R7,R1
   4482              const float old_feedrate_mm_s = feedrate_mm_s;
   \        0x8   0x4C1D             LDR.N    R4,??_manual_goto_xy_0
   \        0xA   0x6F65             LDR      R5,[R4, #+116]
   4483          
   4484              //#if MANUAL_PROBE_HEIGHT > 0	//mks
   4485              #if 1
   4486                feedrate_mm_s = homing_feedrate_mm_s[Z_AXIS];
   \        0xC   0x6B20             LDR      R0,[R4, #+48]
   \        0xE   0x6760             STR      R0,[R4, #+116]
   4487                current_position[Z_AXIS] = LOGICAL_Z_POSITION(Z_MIN_POS) + MANUAL_PROBE_HEIGHT;
   \       0x10   0xF8DF 0x8070      LDR.W    R8,??_manual_goto_xy_0+0x4
   \       0x14   0xF8D8 0x1010      LDR      R1,[R8, #+16]
   \       0x18   0x6CE0             LDR      R0,[R4, #+76]
   \       0x1A   0x.... 0x....      BL       __aeabi_fadd
   \       0x1E   0xF8D8 0x1068      LDR      R1,[R8, #+104]
   \       0x22   0x.... 0x....      BL       __aeabi_fadd
   \       0x26   0x6120             STR      R0,[R4, #+16]
   4488                line_to_current_position();
   \       0x28   0x.... 0x....      BL       _Z24line_to_current_positionv
   4489              #endif
   4490          
   4491              feedrate_mm_s = MMM_TO_MMS(XY_PROBE_SPEED);
   \       0x2C   0xF8D8 0x0074      LDR      R0,[R8, #+116]
   \       0x30   0x4915             LDR.N    R1,??_manual_goto_xy_0+0x8  ;; 0x42700000
   \       0x32   0x.... 0x....      BL       __aeabi_fdiv
   \       0x36   0x6760             STR      R0,[R4, #+116]
   4492              current_position[X_AXIS] = LOGICAL_X_POSITION(x);
   \       0x38   0x6831             LDR      R1,[R6, #+0]
   \       0x3A   0x6C60             LDR      R0,[R4, #+68]
   \       0x3C   0x.... 0x....      BL       __aeabi_fadd
   \       0x40   0x60A0             STR      R0,[R4, #+8]
   4493              current_position[Y_AXIS] = LOGICAL_Y_POSITION(y);
   \       0x42   0x6839             LDR      R1,[R7, #+0]
   \       0x44   0x6CA0             LDR      R0,[R4, #+72]
   \       0x46   0x.... 0x....      BL       __aeabi_fadd
   \       0x4A   0x60E0             STR      R0,[R4, #+12]
   4494              line_to_current_position();
   \       0x4C   0x.... 0x....      BL       _Z24line_to_current_positionv
   4495          
   4496              //#if MANUAL_PROBE_HEIGHT > 0	//mks
   4497              #if 1
   4498                feedrate_mm_s = homing_feedrate_mm_s[Z_AXIS];
   \       0x50   0x6B20             LDR      R0,[R4, #+48]
   \       0x52   0x6760             STR      R0,[R4, #+116]
   4499                current_position[Z_AXIS] = LOGICAL_Z_POSITION(Z_MIN_POS) + 0.2; // just slightly over the bed
   \       0x54   0xF8D8 0x1010      LDR      R1,[R8, #+16]
   \       0x58   0x6CE0             LDR      R0,[R4, #+76]
   \       0x5A   0x.... 0x....      BL       __aeabi_fadd
   \       0x5E   0x.... 0x....      BL       __aeabi_f2d
   \       0x62   0x4A0A             LDR.N    R2,??_manual_goto_xy_0+0xC  ;; 0x9999999a
   \       0x64   0x4B0A             LDR.N    R3,??_manual_goto_xy_0+0x10  ;; 0x3fc99999
   \       0x66   0x.... 0x....      BL       __aeabi_dadd
   \       0x6A   0x.... 0x....      BL       __aeabi_d2f
   \       0x6E   0x6120             STR      R0,[R4, #+16]
   4500                line_to_current_position();
   \       0x70   0x.... 0x....      BL       _Z24line_to_current_positionv
   4501              #endif
   4502          
   4503              feedrate_mm_s = old_feedrate_mm_s;
   \       0x74   0x6765             STR      R5,[R4, #+116]
   4504              stepper.synchronize();
   \       0x76   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \       0x7A   0x.... 0x....      B.W      _ZN7Stepper11synchronizeEv
   \       0x7E   0xBF00             Nop      
   \                     ??_manual_goto_xy_0:
   \       0x80   0x....'....        DC32     mks_heating_busy
   \       0x84   0x....'....        DC32     mksCfg
   \       0x88   0x4270'0000        DC32     0x42700000
   \       0x8C   0x9999'999A        DC32     0x9999999a
   \       0x90   0x3FC9'9999        DC32     0x3fc99999
   4505            }
   4506          
   4507          #endif
   4508          
   4509          /*--mks cfg-- MESH_BED_LEVELING */
   4510          //#if ENABLED(MESH_BED_LEVELING)
   4511          #if 1
   4512            // Save 130 bytes with non-duplication of PSTR

   \                                 In section .text, align 2, keep-with-next
   4513            void say_not_entered() { SERIAL_PROTOCOLLNPGM(" not entered."); }
   \                     _Z15say_not_enteredv: (+1)
   \        0x0   0x.... 0x....      ADR.W    R0,?_20
   \        0x4   0x.... 0x....      B.W      _Z14serialprintPGMPKc
   4514          

   \                                 In section .text, align 2, keep-with-next
   4515            void mbl_mesh_report() {
   \                     _Z15mbl_mesh_reportv: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   4516              SERIAL_PROTOCOLLNPGM("Num X,Y: " STRINGIFY(GRID_MAX_POINTS_X) "," STRINGIFY(GRID_MAX_POINTS_Y));
   \        0x2   0x.... 0x....      ADR.W    R0,?_21
   \        0x6   0x.... 0x....      BL       _Z14serialprintPGMPKc
   4517              SERIAL_PROTOCOLPGM("Z offset: "); SERIAL_PROTOCOL_F(mbl.z_offset, 5);
   \        0xA   0x.... 0x....      ADR.W    R0,?_22
   \        0xE   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \       0x12   0x.... 0x....      LDR.W    R0,??DataTable136_16
   \       0x16   0x6800             LDR      R0,[R0, #+0]
   \       0x18   0x.... 0x....      BL       __aeabi_f2d
   \       0x1C   0x.... 0x....      LDR.W    R2,??DataTable136_2
   \       0x20   0x79D2             LDRB     R2,[R2, #+7]
   \       0x22   0x2A00             CMP      R2,#+0
   \       0x24   0xD108             BNE.N    ??mbl_mesh_report_0
   \       0x26   0x2205             MOVS     R2,#+5
   \       0x28   0x9200             STR      R2,[SP, #+0]
   \       0x2A   0x4602             MOV      R2,R0
   \       0x2C   0x460B             MOV      R3,R1
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable136_17
   \       0x32   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   \       0x36   0xE006             B.N      ??mbl_mesh_report_1
   \                     ??mbl_mesh_report_0: (+1)
   \       0x38   0x2205             MOVS     R2,#+5
   \       0x3A   0x9200             STR      R2,[SP, #+0]
   \       0x3C   0x4602             MOV      R2,R0
   \       0x3E   0x460B             MOV      R3,R1
   \       0x40   0x....             LDR.N    R0,??DataTable129_1
   \       0x42   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   4518              SERIAL_PROTOCOLLNPGM("\nMeasured points:");
   \                     ??mbl_mesh_report_1: (+1)
   \       0x46   0x.... 0x....      ADR.W    R0,?_23
   \       0x4A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   4519          	/*--mks cfg-- LCD_ MESH_BED_LEVELING */
   4520          	/*
   4521              print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 5,
   4522                [](const uint8_t ix, const uint8_t iy) { return mbl.z_values[ix][iy]; }
   4523              );*/
   4524              print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 5,2);
   \       0x4E   0x....             LDR.N    R0,??DataTable131_1
   \       0x50   0x2302             MOVS     R3,#+2
   \       0x52   0x2205             MOVS     R2,#+5
   \       0x54   0x7841             LDRB     R1,[R0, #+1]
   \       0x56   0x7800             LDRB     R0,[R0, #+0]
   \       0x58   0xE8BD 0x5000      POP      {R12,LR}
   \       0x5C   0x.... 0x....      B.W      _ZN37_INTERNAL_15_Marlin_main_cpp_3178531914print_2d_arrayEhhhh
   4525            }
   4526          

   \                                 In section .text, align 2, keep-with-next
   4527            void mesh_probing_done() {
   \                     _Z17mesh_probing_donev: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   4528              mbl.set_has_mesh(true);
   \        0x2   0x2001             MOVS     R0,#+1
   \        0x4   0x.... 0x....      BL       _ZN17mesh_bed_leveling12set_has_meshEb
   4529              home_all_axes();
   \        0x8   0x.... 0x....      BL       _Z13home_all_axesv
   4530              set_bed_leveling_enabled(true);
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0xE8BD 0x4002      POP      {R1,LR}
   \       0x12   0x.... 0x....      B.W      _Z24set_bed_leveling_enabledb
   4531              #if ENABLED(MESH_G28_REST_ORIGIN)
   4532                current_position[Z_AXIS] = LOGICAL_Z_POSITION(Z_MIN_POS);
   4533                set_destination_to_current();
   4534                line_to_destination(homing_feedrate_mm_s[Z_AXIS]);
   4535                stepper.synchronize();
   4536              #endif
   4537            }
   4538          
   4539            /**
   4540             * G29: Mesh-based Z probe, probes a grid and produces a
   4541             *      mesh to compensate for variable bed height
   4542             *
   4543             * Parameters With MESH_BED_LEVELING:
   4544             *
   4545             *  S0              Produce a mesh report
   4546             *  S1              Start probing mesh points
   4547             *  S2              Probe the next mesh point
   4548             *  S3 Xn Yn Zn.nn  Manually modify a single point
   4549             *  S4 Zn.nn        Set z offset. Positive away from bed, negative closer to bed.
   4550             *  S5              Reset and disable mesh
   4551             *
   4552             * The S0 report the points as below
   4553             *
   4554             *  +----> X-axis  1-n
   4555             *  |
   4556             *  |
   4557             *  v Y-axis  1-n
   4558             *
   4559             */
   4560          	  /*--mks cfg-- MESH_BED_LEVELING */
   4561          //  inline void gcode_G29() {

   \                                 In section .text, align 4
   4562            inline void gcode_G29_MESH_BED_LEVELING() {
   \                     _Z27gcode_G29_MESH_BED_LEVELINGv: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   4563              static int mbl_probe_index = -1;
   4564              #if HAS_SOFTWARE_ENDSTOPS
   4565                static bool enable_soft_endstops;
   4566              #endif
   4567          
   4568              const MeshLevelingState state = code_seen('S') ? (MeshLevelingState)code_value_byte() : MeshReport;
   \        0x2   0x2053             MOVS     R0,#+83
   \        0x4   0x.... 0x....      BL       _Z9code_seenc
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD003             BEQ.N    ??gcode_G29_MESH_BED_LEVELING_2
   \        0xC   0x.... 0x....      BL       _Z15code_value_bytev
   \       0x10   0xB240             SXTB     R0,R0
   \       0x12   0xE000             B.N      ??gcode_G29_MESH_BED_LEVELING_3
   \                     ??gcode_G29_MESH_BED_LEVELING_2: (+1)
   \       0x14   0x2000             MOVS     R0,#+0
   4569              if (!WITHIN(state, 0, 5)) {
   \                     ??gcode_G29_MESH_BED_LEVELING_3: (+1)
   \       0x16   0x2806             CMP      R0,#+6
   \       0x18   0xD303             BCC.N    ??gcode_G29_MESH_BED_LEVELING_4
   4570                SERIAL_PROTOCOLLNPGM("S out of range (0-5).");
   \       0x1A   0x4897             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1
   \       0x1C   0x.... 0x....      BL       _Z14serialprintPGMPKc
   4571                return;
   \       0x20   0xBD73             POP      {R0,R1,R4-R6,PC}
   4572              }
   4573          
   4574              int8_t px, py;
   4575          
   4576              switch (state) {
   \                     ??gcode_G29_MESH_BED_LEVELING_4: (+1)
   \       0x22   0x2805             CMP      R0,#+5
   \       0x24   0xF200 0x8124      BHI.W    ??gcode_G29_MESH_BED_LEVELING_5
   \       0x28   0xE8DF 0xF010      TBH      [PC, R0, LSL #+1]
   \                     ??gcode_G29_MESH_BED_LEVELING_0:
   \       0x2C   0x0006 0x0029      DC16     0x6,0x29,0x32,0x9A
   \               0x0032 0x009
   \              A            
   \       0x34   0x0105 0x0120      DC16     0x105,0x120
   4577                case MeshReport:
   4578                  if (mbl.has_mesh()) {
   \                     ??gcode_G29_MESH_BED_LEVELING_6: (+1)
   \       0x38   0x.... 0x....      BL       _ZN17mesh_bed_leveling8has_meshEv
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD01A             BEQ.N    ??gcode_G29_MESH_BED_LEVELING_7
   4579                    SERIAL_PROTOCOLLNPAIR("State: ", mbl.active() ? MSG_ON : MSG_OFF);
   \       0x40   0x.... 0x....      BL       _ZN17mesh_bed_leveling6activeEv
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD001             BEQ.N    ??gcode_G29_MESH_BED_LEVELING_8
   \       0x48   0x498C             LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_1+0x4
   \       0x4A   0xE000             B.N      ??gcode_G29_MESH_BED_LEVELING_9
   \                     ??gcode_G29_MESH_BED_LEVELING_8: (+1)
   \       0x4C   0x498C             LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_1+0x8
   \                     ??gcode_G29_MESH_BED_LEVELING_9: (+1)
   \       0x4E   0x488D             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0xC
   \       0x50   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
   \       0x54   0x488C             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x10
   \       0x56   0x79C0             LDRB     R0,[R0, #+7]
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD104             BNE.N    ??gcode_G29_MESH_BED_LEVELING_10
   \       0x5C   0x210A             MOVS     R1,#+10
   \       0x5E   0x488B             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x14
   \       0x60   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \       0x64   0xE004             B.N      ??gcode_G29_MESH_BED_LEVELING_11
   \                     ??gcode_G29_MESH_BED_LEVELING_10: (+1)
   \       0x66   0x2200             MOVS     R2,#+0
   \       0x68   0x210A             MOVS     R1,#+10
   \       0x6A   0x4889             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x18
   \       0x6C   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   4580                    mbl_mesh_report();
   \                     ??gcode_G29_MESH_BED_LEVELING_11: (+1)
   \       0x70   0x.... 0x....      BL       _Z15mbl_mesh_reportv
   \       0x74   0xE0FC             B.N      ??gcode_G29_MESH_BED_LEVELING_5
   4581                  }
   4582                  else
   4583                    SERIAL_PROTOCOLLNPGM("Mesh bed leveling has no data.");
   \                     ??gcode_G29_MESH_BED_LEVELING_7: (+1)
   \       0x76   0x4887             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x1C
   \       0x78   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \       0x7C   0xE0F8             B.N      ??gcode_G29_MESH_BED_LEVELING_5
   4584                  break;
   4585          
   4586                case MeshStart:
   4587                  mbl.reset();
   \                     ??gcode_G29_MESH_BED_LEVELING_12: (+1)
   \       0x7E   0x.... 0x....      BL       _ZN17mesh_bed_leveling5resetEv
   4588                  mbl_probe_index = 0;
   \       0x82   0x2000             MOVS     R0,#+0
   \       0x84   0x4984             LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_1+0x20
   \       0x86   0x6008             STR      R0,[R1, #+0]
   4589                  enqueue_and_echo_commands_P(PSTR("G28\nG29 S2"));
   \       0x88   0x4884             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x24
   \       0x8A   0x.... 0x....      BL       _Z27enqueue_and_echo_commands_PPKc
   4590                  break;
   \       0x8E   0xE0EF             B.N      ??gcode_G29_MESH_BED_LEVELING_5
   4591          
   4592                case MeshNext:
   4593                  if (mbl_probe_index < 0) {
   \                     ??gcode_G29_MESH_BED_LEVELING_13: (+1)
   \       0x90   0x4C81             LDR.N    R4,??gcode_G29_MESH_BED_LEVELING_1+0x20
   \       0x92   0x6820             LDR      R0,[R4, #+0]
   \       0x94   0x2800             CMP      R0,#+0
   \       0x96   0xD503             BPL.N    ??gcode_G29_MESH_BED_LEVELING_14
   4594                    SERIAL_PROTOCOLLNPGM("Start mesh probing with \"G29 S1\" first.");
   \       0x98   0x4881             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x28
   \       0x9A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   4595                    return;
   \       0x9E   0xBD73             POP      {R0,R1,R4-R6,PC}
   4596                  }
   4597                  // For each G29 S2...
   4598                  if (mbl_probe_index == 0) {
   \                     ??gcode_G29_MESH_BED_LEVELING_14: (+1)
   \       0xA0   0x4E80             LDR.N    R6,??gcode_G29_MESH_BED_LEVELING_1+0x2C
   \       0xA2   0x4D81             LDR.N    R5,??gcode_G29_MESH_BED_LEVELING_1+0x30
   \       0xA4   0xD102             BNE.N    ??gcode_G29_MESH_BED_LEVELING_15
   4599                    #if HAS_SOFTWARE_ENDSTOPS
   4600                      // For the initial G29 S2 save software endstop state
   4601                      enable_soft_endstops = soft_endstops_enabled;
   \       0xA6   0x7828             LDRB     R0,[R5, #+0]
   \       0xA8   0x7030             STRB     R0,[R6, #+0]
   \       0xAA   0xE006             B.N      ??gcode_G29_MESH_BED_LEVELING_16
   4602                    #endif
   4603                  }
   4604                  else {
   4605                    // For G29 S2 after adjusting Z.
   4606                    mbl.set_zigzag_z(mbl_probe_index - 1, current_position[Z_AXIS]);
   \                     ??gcode_G29_MESH_BED_LEVELING_15: (+1)
   \       0xAC   0x497F             LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_1+0x34
   \       0xAE   0x1E40             SUBS     R0,R0,#+1
   \       0xB0   0xB240             SXTB     R0,R0
   \       0xB2   0x.... 0x....      BL       _ZN17mesh_bed_leveling12set_zigzag_zEaRKf
   4607                    #if HAS_SOFTWARE_ENDSTOPS
   4608                      soft_endstops_enabled = enable_soft_endstops;
   \       0xB6   0x7830             LDRB     R0,[R6, #+0]
   \       0xB8   0x7028             STRB     R0,[R5, #+0]
   4609                    #endif
   4610                  }
   4611                  // If there's another point to sample, move there with optional lift.
   4612                  if (mbl_probe_index < (GRID_MAX_POINTS_X) * (GRID_MAX_POINTS_Y)) {
   \                     ??gcode_G29_MESH_BED_LEVELING_16: (+1)
   \       0xBA   0x6820             LDR      R0,[R4, #+0]
   \       0xBC   0x4A7C             LDR.N    R2,??gcode_G29_MESH_BED_LEVELING_1+0x38
   \       0xBE   0xF102 0x0660      ADD      R6,R2,#+96
   \       0xC2   0x7833             LDRB     R3,[R6, #+0]
   \       0xC4   0x7871             LDRB     R1,[R6, #+1]
   \       0xC6   0x434B             MULS     R3,R1,R3
   \       0xC8   0x4298             CMP      R0,R3
   \       0xCA   0xDA17             BGE.N    ??gcode_G29_MESH_BED_LEVELING_17
   4613                    mbl.zigzag(mbl_probe_index, px, py);
   \       0xCC   0x466A             MOV      R2,SP
   \       0xCE   0xF10D 0x0101      ADD      R1,SP,#+1
   \       0xD2   0xB240             SXTB     R0,R0
   \       0xD4   0x.... 0x....      BL       _ZN17mesh_bed_leveling6zigzagEaRaS0_
   4614                    _manual_goto_xy(mbl.index_to_xpos[px], mbl.index_to_ypos[py]);
   \       0xD8   0x4876             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x3C
   \       0xDA   0xF99D 0x1000      LDRSB    R1,[SP, #+0]
   \       0xDE   0xEB00 0x0181      ADD      R1,R0,R1, LSL #+2
   \       0xE2   0x4875             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x40
   \       0xE4   0xF99D 0x2001      LDRSB    R2,[SP, #+1]
   \       0xE8   0xEB00 0x0082      ADD      R0,R0,R2, LSL #+2
   \       0xEC   0x.... 0x....      BL       _Z15_manual_goto_xyRKfS0_
   4615          
   4616                    #if HAS_SOFTWARE_ENDSTOPS
   4617                      // Disable software endstops to allow manual adjustment
   4618                      // If G29 is not completed, they will not be re-enabled
   4619                      soft_endstops_enabled = false;
   \       0xF0   0x2000             MOVS     R0,#+0
   \       0xF2   0x7028             STRB     R0,[R5, #+0]
   4620                    #endif
   4621          
   4622                    mbl_probe_index++;
   \       0xF4   0x6820             LDR      R0,[R4, #+0]
   \       0xF6   0x1C40             ADDS     R0,R0,#+1
   \       0xF8   0x6020             STR      R0,[R4, #+0]
   \       0xFA   0xE0B9             B.N      ??gcode_G29_MESH_BED_LEVELING_5
   4623                  }
   4624                  else {
   4625                    // One last "return to the bed" (as originally coded) at completion
   4626                    current_position[Z_AXIS] = LOGICAL_Z_POSITION(Z_MIN_POS) + MANUAL_PROBE_HEIGHT;
   \                     ??gcode_G29_MESH_BED_LEVELING_17: (+1)
   \       0xFC   0x4D62             LDR.N    R5,??gcode_G29_MESH_BED_LEVELING_1+0x10
   \       0xFE   0x6911             LDR      R1,[R2, #+16]
   \      0x100   0x6CE8             LDR      R0,[R5, #+76]
   \      0x102   0x.... 0x....      BL       __aeabi_fadd
   \      0x106   0x68B1             LDR      R1,[R6, #+8]
   \      0x108   0x.... 0x....      BL       __aeabi_fadd
   \      0x10C   0x6128             STR      R0,[R5, #+16]
   4627                    line_to_current_position();
   \      0x10E   0x.... 0x....      BL       _Z24line_to_current_positionv
   4628                    stepper.synchronize();
   \      0x112   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   4629          
   4630                    // After recording the last point, activate home and activate
   4631                    mbl_probe_index = -1;
   \      0x116   0xF04F 0x30FF      MOV      R0,#-1
   \      0x11A   0x6020             STR      R0,[R4, #+0]
   4632                    SERIAL_PROTOCOLLNPGM("Mesh probing done.");
   \      0x11C   0x4867             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x44
   \      0x11E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   4633                    BUZZ(100, 659);
   \      0x122   0x2064             MOVS     R0,#+100
   \      0x124   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \      0x128   0xF240 0x2093      MOVW     R0,#+659
   \      0x12C   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   \      0x130   0xF505 0x7466      ADD      R4,R5,#+920
   \      0x134   0xF10D 0x0202      ADD      R2,SP,#+2
   \      0x138   0xA901             ADD      R1,SP,#+4
   \      0x13A   0x4620             MOV      R0,R4
   \      0x13C   0x.... 0x....      BL       _ZN6Buzzer4toneERKtS1_
   4634                    BUZZ(100, 698);
   \      0x140   0x2064             MOVS     R0,#+100
   \      0x142   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \      0x146   0xF240 0x20BA      MOVW     R0,#+698
   \      0x14A   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   \      0x14E   0xF10D 0x0202      ADD      R2,SP,#+2
   \      0x152   0xA901             ADD      R1,SP,#+4
   \      0x154   0x4620             MOV      R0,R4
   \      0x156   0x.... 0x....      BL       _ZN6Buzzer4toneERKtS1_
   4635                    mesh_probing_done();
   \      0x15A   0x.... 0x....      BL       _Z17mesh_probing_donev
   \      0x15E   0xE087             B.N      ??gcode_G29_MESH_BED_LEVELING_5
   4636                  }
   4637                  break;
   4638          
   4639                case MeshSet:
   4640                  if (code_seen('X')) {
   \                     ??gcode_G29_MESH_BED_LEVELING_18: (+1)
   \      0x160   0x2058             MOVS     R0,#+88
   \      0x162   0x.... 0x....      BL       _Z9code_seenc
   \      0x166   0x2800             CMP      R0,#+0
   \      0x168   0xD01F             BEQ.N    ??gcode_G29_MESH_BED_LEVELING_19
   4641                    px = code_value_int() - 1;
   \      0x16A   0x.... 0x....      BL       _Z14code_value_intv
   \      0x16E   0x1E40             SUBS     R0,R0,#+1
   \      0x170   0xF88D 0x0001      STRB     R0,[SP, #+1]
   4642                    if (!WITHIN(px, 0, GRID_MAX_POINTS_X - 1)) {
   \      0x174   0xF99D 0x0001      LDRSB    R0,[SP, #+1]
   \      0x178   0x2800             CMP      R0,#+0
   \      0x17A   0xD404             BMI.N    ??gcode_G29_MESH_BED_LEVELING_20
   \      0x17C   0x4C50             LDR.N    R4,??gcode_G29_MESH_BED_LEVELING_1+0x48
   \      0x17E   0x7821             LDRB     R1,[R4, #+0]
   \      0x180   0x1E49             SUBS     R1,R1,#+1
   \      0x182   0x4281             CMP      R1,R0
   \      0x184   0xDA03             BGE.N    ??gcode_G29_MESH_BED_LEVELING_21
   4643                      SERIAL_PROTOCOLLNPGM("X out of range (1-" STRINGIFY(GRID_MAX_POINTS_X) ").");
   \                     ??gcode_G29_MESH_BED_LEVELING_20: (+1)
   \      0x186   0x484F             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x4C
   \      0x188   0x.... 0x....      BL       _Z14serialprintPGMPKc
   4644                      return;
   \      0x18C   0xBD73             POP      {R0,R1,R4-R6,PC}
   4645                    }
   4646                  }
   4647                  else {
   4648                    SERIAL_CHAR('X'); say_not_entered();
   4649                    return;
   4650                  }
   4651          
   4652                  if (code_seen('Y')) {
   \                     ??gcode_G29_MESH_BED_LEVELING_21: (+1)
   \      0x18E   0x2059             MOVS     R0,#+89
   \      0x190   0x.... 0x....      BL       _Z9code_seenc
   \      0x194   0x2800             CMP      R0,#+0
   \      0x196   0xD117             BNE.N    ??gcode_G29_MESH_BED_LEVELING_22
   4653                    py = code_value_int() - 1;
   4654                    if (!WITHIN(py, 0, GRID_MAX_POINTS_Y - 1)) {
   4655                      SERIAL_PROTOCOLLNPGM("Y out of range (1-" STRINGIFY(GRID_MAX_POINTS_Y) ").");
   4656                      return;
   4657                    }
   4658                  }
   4659                  else {
   4660                    SERIAL_CHAR('Y'); say_not_entered();
   \      0x198   0x483B             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x10
   \      0x19A   0x79C0             LDRB     R0,[R0, #+7]
   \      0x19C   0x2800             CMP      R0,#+0
   \      0x19E   0xD132             BNE.N    ??gcode_G29_MESH_BED_LEVELING_23
   \      0x1A0   0x2159             MOVS     R1,#+89
   \      0x1A2   0x483A             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x14
   \      0x1A4   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \      0x1A8   0xE05D             B.N      ??gcode_G29_MESH_BED_LEVELING_24
   \                     ??gcode_G29_MESH_BED_LEVELING_19: (+1)
   \      0x1AA   0x4837             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x10
   \      0x1AC   0x79C0             LDRB     R0,[R0, #+7]
   \      0x1AE   0x2800             CMP      R0,#+0
   \      0x1B0   0xD104             BNE.N    ??gcode_G29_MESH_BED_LEVELING_25
   \      0x1B2   0x2158             MOVS     R1,#+88
   \      0x1B4   0x4835             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x14
   \      0x1B6   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \      0x1BA   0xE054             B.N      ??gcode_G29_MESH_BED_LEVELING_24
   \                     ??gcode_G29_MESH_BED_LEVELING_25: (+1)
   \      0x1BC   0x2200             MOVS     R2,#+0
   \      0x1BE   0x2158             MOVS     R1,#+88
   \      0x1C0   0x4833             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x18
   \      0x1C2   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   \      0x1C6   0xE04E             B.N      ??gcode_G29_MESH_BED_LEVELING_24
   \                     ??gcode_G29_MESH_BED_LEVELING_22: (+1)
   \      0x1C8   0x.... 0x....      BL       _Z14code_value_intv
   \      0x1CC   0x1E40             SUBS     R0,R0,#+1
   \      0x1CE   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \      0x1D2   0xF99D 0x0000      LDRSB    R0,[SP, #+0]
   \      0x1D6   0x2800             CMP      R0,#+0
   \      0x1D8   0xD403             BMI.N    ??gcode_G29_MESH_BED_LEVELING_26
   \      0x1DA   0x7861             LDRB     R1,[R4, #+1]
   \      0x1DC   0x1E49             SUBS     R1,R1,#+1
   \      0x1DE   0x4281             CMP      R1,R0
   \      0x1E0   0xDA03             BGE.N    ??gcode_G29_MESH_BED_LEVELING_27
   \                     ??gcode_G29_MESH_BED_LEVELING_26: (+1)
   \      0x1E2   0x4839             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x50
   \      0x1E4   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \      0x1E8   0xBD73             POP      {R0,R1,R4-R6,PC}
   4661                    return;
   4662                  }
   4663          
   4664                  if (code_seen('Z')) {
   \                     ??gcode_G29_MESH_BED_LEVELING_27: (+1)
   \      0x1EA   0x205A             MOVS     R0,#+90
   \      0x1EC   0x.... 0x....      BL       _Z9code_seenc
   \      0x1F0   0x2800             CMP      R0,#+0
   \      0x1F2   0xD10E             BNE.N    ??gcode_G29_MESH_BED_LEVELING_28
   4665                    mbl.z_values[px][py] = code_value_linear_units();
   4666                  }
   4667                  else {
   4668                    SERIAL_CHAR('Z'); say_not_entered();
   \      0x1F4   0x4824             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x10
   \      0x1F6   0x79C0             LDRB     R0,[R0, #+7]
   \      0x1F8   0x2800             CMP      R0,#+0
   \      0x1FA   0xD116             BNE.N    ??gcode_G29_MESH_BED_LEVELING_29
   \      0x1FC   0x215A             MOVS     R1,#+90
   \      0x1FE   0x4823             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x14
   \      0x200   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \      0x204   0xE02F             B.N      ??gcode_G29_MESH_BED_LEVELING_24
   \                     ??gcode_G29_MESH_BED_LEVELING_23: (+1)
   \      0x206   0x2200             MOVS     R2,#+0
   \      0x208   0x2159             MOVS     R1,#+89
   \      0x20A   0x4821             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x18
   \      0x20C   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   \      0x210   0xE029             B.N      ??gcode_G29_MESH_BED_LEVELING_24
   \                     ??gcode_G29_MESH_BED_LEVELING_28: (+1)
   \      0x212   0x.... 0x....      BL       _Z16code_value_floatv
   \      0x216   0x492D             LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_1+0x54
   \      0x218   0xF99D 0x2001      LDRSB    R2,[SP, #+1]
   \      0x21C   0xEB01 0x1182      ADD      R1,R1,R2, LSL #+6
   \      0x220   0xF99D 0x2000      LDRSB    R2,[SP, #+0]
   \      0x224   0xF841 0x0022      STR      R0,[R1, R2, LSL #+2]
   4669                    return;
   4670                  }
   4671                  break;
   \      0x228   0xE022             B.N      ??gcode_G29_MESH_BED_LEVELING_5
   \                     ??gcode_G29_MESH_BED_LEVELING_29: (+1)
   \      0x22A   0x2200             MOVS     R2,#+0
   \      0x22C   0x215A             MOVS     R1,#+90
   \      0x22E   0x4818             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x18
   \      0x230   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   \      0x234   0xE017             B.N      ??gcode_G29_MESH_BED_LEVELING_24
   4672          
   4673                case MeshSetZOffset:
   4674                  if (code_seen('Z')) {
   \                     ??gcode_G29_MESH_BED_LEVELING_30: (+1)
   \      0x236   0x205A             MOVS     R0,#+90
   \      0x238   0x.... 0x....      BL       _Z9code_seenc
   \      0x23C   0x2800             CMP      R0,#+0
   \      0x23E   0xD004             BEQ.N    ??gcode_G29_MESH_BED_LEVELING_31
   4675                    mbl.z_offset = code_value_linear_units();
   \      0x240   0x.... 0x....      BL       _Z16code_value_floatv
   \      0x244   0x4922             LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_1+0x58
   \      0x246   0x6008             STR      R0,[R1, #+0]
   4676                  }
   4677                  else {
   4678                    SERIAL_CHAR('Z'); say_not_entered();
   4679                    return;
   4680                  }
   4681                  break;
   \      0x248   0xE012             B.N      ??gcode_G29_MESH_BED_LEVELING_5
   \                     ??gcode_G29_MESH_BED_LEVELING_31: (+1)
   \      0x24A   0x480F             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x10
   \      0x24C   0x79C0             LDRB     R0,[R0, #+7]
   \      0x24E   0x2800             CMP      R0,#+0
   \      0x250   0xD104             BNE.N    ??gcode_G29_MESH_BED_LEVELING_32
   \      0x252   0x215A             MOVS     R1,#+90
   \      0x254   0x480D             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x14
   \      0x256   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \      0x25A   0xE004             B.N      ??gcode_G29_MESH_BED_LEVELING_24
   \                     ??gcode_G29_MESH_BED_LEVELING_32: (+1)
   \      0x25C   0x2200             MOVS     R2,#+0
   \      0x25E   0x215A             MOVS     R1,#+90
   \      0x260   0x480B             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_1+0x18
   \      0x262   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   \                     ??gcode_G29_MESH_BED_LEVELING_24: (+1)
   \      0x266   0x.... 0x....      BL       _Z15say_not_enteredv
   \      0x26A   0xBD73             POP      {R0,R1,R4-R6,PC}
   4682          
   4683                case MeshReset:
   4684                  reset_bed_level();
   \                     ??gcode_G29_MESH_BED_LEVELING_33: (+1)
   \      0x26C   0x.... 0x....      BL       _Z15reset_bed_levelv
   4685                  break;
   4686          
   4687              } // switch(state)
   4688          
   4689              report_current_position();
   \                     ??gcode_G29_MESH_BED_LEVELING_5: (+1)
   \      0x270   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531923report_current_positionEv
   4690            }
   \      0x274   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
   \      0x276   0xBF00             Nop      
   \                     ??gcode_G29_MESH_BED_LEVELING_1:
   \      0x278   0x....'....        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs
   \      0x27C   0x....'....        DC32     MSG_ON
   \      0x280   0x....'....        DC32     MSG_OFF
   \      0x284   0x....'....        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_0
   \      0x288   0x....'....        DC32     mks_heating_busy
   \      0x28C   0x....'....        DC32     customizedSerial
   \      0x290   0x....'....        DC32     serial2
   \      0x294   0x....'....        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_1
   \      0x298   0x....'....        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvE15mbl_probe_index
   \      0x29C   0x....'....        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_2
   \      0x2A0   0x....'....        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_3
   \      0x2A4   0x....'....        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvE20enable_soft_endstops
   \      0x2A8   0x....'....        DC32     soft_endstops_enabled
   \      0x2AC   0x....'....        DC32     mks_heating_busy+0x10
   \      0x2B0   0x....'....        DC32     mksCfg
   \      0x2B4   0x....'....        DC32     _ZN17mesh_bed_leveling13index_to_yposE
   \      0x2B8   0x....'....        DC32     _ZN17mesh_bed_leveling13index_to_xposE
   \      0x2BC   0x....'....        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_4
   \      0x2C0   0x....'....        DC32     mksCfg+0x60
   \      0x2C4   0x....'....        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_5
   \      0x2C8   0x....'....        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_6
   \      0x2CC   0x....'....        DC32     _ZN17mesh_bed_leveling8z_valuesE
   \      0x2D0   0x....'....        DC32     _ZN17mesh_bed_leveling8z_offsetE
   4691          
   4692          /*--mks cfg-- AUTO_BED_LEVELING_BILINEAR */
   4693          //#elif HAS_ABL && DISABLED(AUTO_BED_LEVELING_UBL)
   4694          #endif	//MESH_BED_LEVELING
   4695          #if 1
   4696          
   4697          //  #if ABL_GRID
   4698          	#if 1
   4699              #if ENABLED(PROBE_Y_FIRST)
   4700                #define PR_OUTER_VAR xCount
   4701                #define PR_OUTER_END abl_grid_points_x
   4702                #define PR_INNER_VAR yCount
   4703                #define PR_INNER_END abl_grid_points_y
   4704              #else
   4705                #define PR_OUTER_VAR yCount
   4706                #define PR_OUTER_END abl_grid_points_y
   4707                #define PR_INNER_VAR xCount
   4708                #define PR_INNER_END abl_grid_points_x
   4709              #endif
   4710            #endif
   4711          
   4712            /**
   4713             * G29: Detailed Z probe, probes the bed at 3 or more points.
   4714             *      Will fail if the printer has not been homed with G28.
   4715             *
   4716             * Enhanced G29 Auto Bed Leveling Probe Routine
   4717             *
   4718             *  D  Dry-Run mode. Just evaluate the bed Topology - Don't apply
   4719             *     or alter the bed level data. Useful to check the topology
   4720             *     after a first run of G29.
   4721             *
   4722             *  J  Jettison current bed leveling data
   4723             *
   4724             *  V  Set the verbose level (0-4). Example: "G29 V3"
   4725             *
   4726             * Parameters With LINEAR leveling only:
   4727             *
   4728             *  P  Set the size of the grid that will be probed (P x P points).
   4729             *     Example: "G29 P4"
   4730             *
   4731             *  X  Set the X size of the grid that will be probed (X x Y points).
   4732             *     Example: "G29 X7 Y5"
   4733             *
   4734             *  Y  Set the Y size of the grid that will be probed (X x Y points).
   4735             *
   4736             *  T  Generate a Bed Topology Report. Example: "G29 P5 T" for a detailed report.
   4737             *     This is useful for manual bed leveling and finding flaws in the bed (to
   4738             *     assist with part placement).
   4739             *     Not supported by non-linear delta printer bed leveling.
   4740             *
   4741             * Parameters With LINEAR and BILINEAR leveling only:
   4742             *
   4743             *  S  Set the XY travel speed between probe points (in units/min)
   4744             *
   4745             *  F  Set the Front limit of the probing grid
   4746             *  B  Set the Back limit of the probing grid
   4747             *  L  Set the Left limit of the probing grid
   4748             *  R  Set the Right limit of the probing grid
   4749             *
   4750             * Parameters with DEBUG_LEVELING_FEATURE only:
   4751             *
   4752             *  C  Make a totally fake grid with no actual probing.
   4753             *     For use in testing when no probing is possible.
   4754             *
   4755             * Parameters with BILINEAR leveling only:
   4756             *
   4757             *  Z  Supply an additional Z probe offset
   4758             *
   4759             * Extra parameters with PROBE_MANUALLY:
   4760             *
   4761             *  To do manual probing simply repeat G29 until the procedure is complete.
   4762             *  The first G29 accepts parameters. 'G29 Q' for status, 'G29 A' to abort.
   4763             *
   4764             *  Q  Query leveling and G29 state
   4765             *
   4766             *  A  Abort current leveling procedure
   4767             *
   4768             *  W  Write a mesh point. (Ignored during leveling.)
   4769             *  X  Required X for mesh point
   4770             *  Y  Required Y for mesh point
   4771             *  Z  Required Z for mesh point
   4772             *
   4773             * Without PROBE_MANUALLY:
   4774             *
   4775             *  E  By default G29 will engage the Z probe, test the bed, then disengage.
   4776             *     Include "E" to engage/disengage the Z probe for each sample.
   4777             *     There's no extra effect if you have a fixed Z probe.
   4778             *
   4779             */

   \                                 In section .text, align 4
   4780            inline void gcode_G29() {
   \                     _Z9gcode_G29v: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xF5AD 0x6D97      SUB      SP,SP,#+1208
   4781          
   4782              // G29 Q is also available if debugging
   4783              #if ENABLED(DEBUG_LEVELING_FEATURE)
   4784                const bool query = code_seen('Q');
   4785                const uint8_t old_debug_flags = marlin_debug_flags;
   4786                if (query) marlin_debug_flags |= DEBUG_LEVELING;
   4787                if (DEBUGGING(LEVELING)) {
   4788                  DEBUG_POS(">>> gcode_G29", current_position);
   4789                  log_machine_info();
   4790                }
   4791                marlin_debug_flags = old_debug_flags;
   4792                #if DISABLED(PROBE_MANUALLY)
   4793                  if (query) return;
   4794                #endif
   4795              #endif
   4796          
   4797              #if ENABLED(DEBUG_LEVELING_FEATURE) && DISABLED(PROBE_MANUALLY)
   4798                const bool faux = code_seen('C') && code_value_bool();
   4799              #else
   4800                bool constexpr faux = false;
   4801              #endif
   4802          
   4803          
   4804              // Don't allow auto-leveling without homing first
   4805              if (axis_unhomed_error(true, true, true)) return;
   \        0x8   0x2201             MOVS     R2,#+1
   \        0xA   0x4611             MOV      R1,R2
   \        0xC   0x4608             MOV      R0,R1
   \        0xE   0x.... 0x....      BL       _Z18axis_unhomed_errorbbb
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xF040 0x879B      BNE.W    ??gcode_G29_3
   4806          
   4807              // Define local vars 'static' for manual probing, 'auto' otherwise
   4808              #if ENABLED(PROBE_MANUALLY)
   4809                #define ABL_VAR static_nouse
   4810              #else
   4811                #define ABL_VAR
   4812              #endif
   4813          
   4814              ABL_VAR int verbose_level=0;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x900C             STR      R0,[SP, #+48]
   4815              ABL_VAR float xProbe=0, yProbe=0, measured_z=0;
   \       0x1C   0x9011             STR      R0,[SP, #+68]
   \       0x1E   0x9010             STR      R0,[SP, #+64]
   \       0x20   0x900F             STR      R0,[SP, #+60]
   4816              ABL_VAR bool dryrun=false, abl_should_enable=false;
   4817          
   4818          	ABL_VAR int abl_probe_index=0;
   \       0x22   0x9016             STR      R0,[SP, #+88]
   4819          
   4820              #if HAS_SOFTWARE_ENDSTOPS && ENABLED(PROBE_MANUALLY)
   4821                ABL_VAR bool enable_soft_endstops = true;
   4822              #endif
   4823          
   4824             // #if ABL_GRID
   4825          	//if(BED_LEVELING_METHOD&ABL_GRID)  
   4826          		//{
   4827          	
   4828          	#if ENABLED(PROBE_MANUALLY)
   4829          	  ABL_VAR uint8_t PR_OUTER_VAR;
   4830          	  ABL_VAR  int8_t PR_INNER_VAR;
   4831          	#endif
   4832          	
   4833          	ABL_VAR int left_probe_bed_position=0, right_probe_bed_position=0, front_probe_bed_position=0, back_probe_bed_position=0;
   \       0x24   0x9002             STR      R0,[SP, #+8]
   \       0x26   0x9001             STR      R0,[SP, #+4]
   4834          	ABL_VAR float xGridSpacing=0, yGridSpacing=0;
   \       0x28   0x9006             STR      R0,[SP, #+24]
   \       0x2A   0x9005             STR      R0,[SP, #+20]
   4835          #define ABL_GRID_MAX (GRID_MAX_POINTS_X) * (GRID_MAX_POINTS_Y)
   4836          
   4837          
   4838          //#if ABL_PLANAR
   4839            //if(BED_LEVELING_METHOD&ABL_PLANAR)
   4840            	//{
   4841            ABL_VAR uint8_t abl_grid_points_x = GRID_MAX_POINTS_X,
   \       0x2C   0xF8DF 0x6D3C      LDR.W    R6,??gcode_G29_0
   \       0x30   0xF106 0x0060      ADD      R0,R6,#+96
   \       0x34   0x9009             STR      R0,[SP, #+36]
   \       0x36   0x7800             LDRB     R0,[R0, #+0]
   \       0x38   0x4601             MOV      R1,R0
   \       0x3A   0x910B             STR      R1,[SP, #+44]
   4842          				  abl_grid_points_y = GRID_MAX_POINTS_Y;
   \       0x3C   0x9909             LDR      R1,[SP, #+36]
   \       0x3E   0x7849             LDRB     R1,[R1, #+1]
   \       0x40   0x460A             MOV      R2,R1
   \       0x42   0x9204             STR      R2,[SP, #+16]
   4843            ABL_VAR bool do_topography_map=false;
   \       0x44   0x2200             MOVS     R2,#+0
   \       0x46   0xF88D 0x200C      STRB     R2,[SP, #+12]
   4844           
   4845          
   4846            	//}
   4847          //#else // 3-point
   4848          /*
   4849          else
   4850          {
   4851            uint8_t constexpr abl_grid_points_x = GRID_MAX_POINTS_X,
   4852          					abl_grid_points_y = GRID_MAX_POINTS_Y;
   4853          }
   4854          */
   4855          //#endif
   4856          //#if ENABLED(AUTO_BED_LEVELING_LINEAR) || ENABLED(PROBE_MANUALLY)
   4857            //if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_LINEAR)
   4858            	//{
   4859            	int abl2;
   4860          	  //#if ABL_PLANAR
   4861          	  if(! (BED_LEVELING_METHOD&ABL_PLANAR)) abl2 = ABL_GRID_MAX;
   \       0x4A   0x4348             MULS     R0,R1,R0
   \       0x4C   0xF106 0x0140      ADD      R1,R6,#+64
   \       0x50   0x910D             STR      R1,[SP, #+52]
   \       0x52   0x7809             LDRB     R1,[R1, #+0]
   \       0x54   0xF011 0x0F06      TST      R1,#0x6
   \       0x58   0xD100             BNE.N    ??gcode_G29_4
   \       0x5A   0x900A             STR      R0,[SP, #+40]
   4862          	  //#endif
   4863            	//}
   4864          //#endif
   4865          
   4866          
   4867          
   4868                //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
   4869          	//if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_BILINEAR)
   4870          		//{
   4871                  ABL_VAR float zoffset;
   4872          		//}
   4873                //#elif ENABLED(AUTO_BED_LEVELING_LINEAR)
   4874          	  //else if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_LINEAR)
   4875          	  	//{
   4876                  ABL_VAR int indexIntoAB[GRID_MAX_POINTS_X_MAX][GRID_MAX_POINTS_Y_MAX];
   4877          
   4878          /*        ABL_VAR float eqnAMatrix[ABL_GRID_MAX * 3], // "A" matrix of the linear system of equations
   4879                               eqnBVector[ABL_GRID_MAX],     // "B" vector of Z points
   4880                               mean;*/
   4881          
   4882          /*
   4883          			  ABL_VAR float eqnAMatrix[9 * 3], // "A" matrix of the linear system of equations
   4884          						 eqnBVector[9],	   // "B" vector of Z points
   4885          						 mean;
   4886          */
   4887          
   4888                              
   4889          		ABL_VAR float *eqnAMatrix=NULL, // "A" matrix of the linear system of equations
   4890          			 		 *eqnBVector=NULL,	   // "B" vector of Z points
   4891          					 mean;
   4892          		
   4893          		eqnAMatrix = (float *)malloc((ABL_GRID_MAX * 3 + 1) * sizeof(float));
   \                     ??gcode_G29_4: (+1)
   \       0x5C   0xF106 0x0460      ADD      R4,R6,#+96
   \       0x60   0xEB00 0x0040      ADD      R0,R0,R0, LSL #+1
   \       0x64   0x1C40             ADDS     R0,R0,#+1
   \       0x66   0x0080             LSLS     R0,R0,#+2
   \       0x68   0x.... 0x....      BL       malloc
   \       0x6C   0x0005             MOVS     R5,R0
   4894          		if(eqnAMatrix == NULL)
   \       0x6E   0xD107             BNE.N    ??gcode_G29_5
   4895          			{
   4896          			Running = false;
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0xF8DF 0x1CFC      LDR.W    R1,??gcode_G29_0+0x4
   \       0x76   0x7008             STRB     R0,[R1, #+0]
   4897          			kill("malloc eqnAMatrix err!");
   \       0x78   0xF8DF 0x0CF8      LDR.W    R0,??gcode_G29_0+0x8
   \       0x7C   0x.... 0x....      BL       _Z4killPKc
   4898          			}
   4899          		for(int i=0;i<ABL_GRID_MAX * 3 + 1;i++)		*(eqnAMatrix+i) = 0.0;
   \                     ??gcode_G29_5: (+1)
   \       0x80   0x2100             MOVS     R1,#+0
   \       0x82   0xE003             B.N      ??gcode_G29_6
   \                     ??gcode_G29_7: (+1)
   \       0x84   0x2000             MOVS     R0,#+0
   \       0x86   0xF845 0x0021      STR      R0,[R5, R1, LSL #+2]
   \       0x8A   0x1C49             ADDS     R1,R1,#+1
   \                     ??gcode_G29_6: (+1)
   \       0x8C   0x7820             LDRB     R0,[R4, #+0]
   \       0x8E   0x7862             LDRB     R2,[R4, #+1]
   \       0x90   0x4350             MULS     R0,R2,R0
   \       0x92   0xEB00 0x0240      ADD      R2,R0,R0, LSL #+1
   \       0x96   0x1C52             ADDS     R2,R2,#+1
   \       0x98   0x4291             CMP      R1,R2
   \       0x9A   0xDBF3             BLT.N    ??gcode_G29_7
   4900          
   4901          		
   4902          		eqnBVector = (float *)malloc((ABL_GRID_MAX + 1) * sizeof(float));
   \       0x9C   0xF106 0x0760      ADD      R7,R6,#+96
   \       0xA0   0x1C40             ADDS     R0,R0,#+1
   \       0xA2   0x0080             LSLS     R0,R0,#+2
   \       0xA4   0x.... 0x....      BL       malloc
   \       0xA8   0x0004             MOVS     R4,R0
   4903          		if(eqnBVector == NULL)
   \       0xAA   0xD107             BNE.N    ??gcode_G29_8
   4904          			{
   4905          			Running = false;
   \       0xAC   0x2000             MOVS     R0,#+0
   \       0xAE   0xF8DF 0x1CC0      LDR.W    R1,??gcode_G29_0+0x4
   \       0xB2   0x7008             STRB     R0,[R1, #+0]
   4906          			kill("malloc eqnBVector err!");
   \       0xB4   0xF8DF 0x0CC0      LDR.W    R0,??gcode_G29_0+0xC
   \       0xB8   0x.... 0x....      BL       _Z4killPKc
   4907          			}
   4908          		for(int i=0;i<ABL_GRID_MAX + 1;i++) 	*(eqnBVector+i) = 0.0;
   \                     ??gcode_G29_8: (+1)
   \       0xBC   0x2000             MOVS     R0,#+0
   \       0xBE   0x46A0             MOV      R8,R4
   \       0xC0   0xE003             B.N      ??gcode_G29_9
   \                     ??gcode_G29_10: (+1)
   \       0xC2   0x2100             MOVS     R1,#+0
   \       0xC4   0xF848 0x1020      STR      R1,[R8, R0, LSL #+2]
   \       0xC8   0x1C40             ADDS     R0,R0,#+1
   \                     ??gcode_G29_9: (+1)
   \       0xCA   0x7839             LDRB     R1,[R7, #+0]
   \       0xCC   0x787A             LDRB     R2,[R7, #+1]
   \       0xCE   0x4351             MULS     R1,R2,R1
   \       0xD0   0x1C49             ADDS     R1,R1,#+1
   \       0xD2   0x4288             CMP      R0,R1
   \       0xD4   0xDBF5             BLT.N    ??gcode_G29_10
   4909          
   4910          		
   4911          	  //}
   4912                //#endif
   4913          
   4914          		//}
   4915              //#elif ENABLED(AUTO_BED_LEVELING_3POINT)
   4916              //else if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_3POINT)	
   4917          		//{
   4918                // Probe at 3 arbitrary points
   4919                ABL_VAR vector_3 points[3] = {
   4920                  vector_3(ABL_PROBE_PT_1_X, ABL_PROBE_PT_1_Y, 0),
   4921                  vector_3(ABL_PROBE_PT_2_X, ABL_PROBE_PT_2_Y, 0),
   4922                  vector_3(ABL_PROBE_PT_3_X, ABL_PROBE_PT_3_Y, 0)
   4923                };
   \       0xD6   0xF106 0x0060      ADD      R0,R6,#+96
   \       0xDA   0x9009             STR      R0,[SP, #+36]
   \       0xDC   0x2300             MOVS     R3,#+0
   \       0xDE   0x6C02             LDR      R2,[R0, #+64]
   \       0xE0   0x6BC1             LDR      R1,[R0, #+60]
   \       0xE2   0xA819             ADD      R0,SP,#+100
   \       0xE4   0x.... 0x....      BL       _ZN8vector_3C1Efff
   \       0xE8   0x2300             MOVS     R3,#+0
   \       0xEA   0x9809             LDR      R0,[SP, #+36]
   \       0xEC   0x6C82             LDR      R2,[R0, #+72]
   \       0xEE   0x6C41             LDR      R1,[R0, #+68]
   \       0xF0   0xA81C             ADD      R0,SP,#+112
   \       0xF2   0x.... 0x....      BL       _ZN8vector_3C1Efff
   \       0xF6   0x2300             MOVS     R3,#+0
   \       0xF8   0x9809             LDR      R0,[SP, #+36]
   \       0xFA   0x6D02             LDR      R2,[R0, #+80]
   \       0xFC   0x6CC1             LDR      R1,[R0, #+76]
   \       0xFE   0xA81F             ADD      R0,SP,#+124
   \      0x100   0x.... 0x....      BL       _ZN8vector_3C1Efff
   4924              //}
   4925              //#endif // AUTO_BED_LEVELING_3POINT
   4926          
   4927              /**
   4928               * On the initial G29 fetch command parameters.
   4929               */
   4930          
   4931          	
   4932              if (!g29_in_progress) {
   4933          
   4934          #if 0
   4935                #if ENABLED(PROBE_MANUALLY) || ENABLED(AUTO_BED_LEVELING_LINEAR)
   4936                  abl_probe_index = 0;
   4937                #endif
   4938          #else
   4939          		if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_LINEAR)
   4940          			abl_probe_index = 0;
   4941          #endif
   4942                abl_should_enable = planner.abl_enabled;
   \      0x104   0xF8DF 0x0C74      LDR.W    R0,??gcode_G29_0+0x10
   \      0x108   0x7800             LDRB     R0,[R0, #+0]
   \      0x10A   0xF88D 0x0020      STRB     R0,[SP, #+32]
   4943          
   4944                //#if ENABLED(AUTO_BED_LEVELING_BILINEAR) /*--mks cfg-- AUTO_BED_LEVELING_BILINEAR */
   4945          	if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR) {
   \      0x10E   0x980D             LDR      R0,[SP, #+52]
   \      0x110   0x7800             LDRB     R0,[R0, #+0]
   \      0x112   0x2808             CMP      R0,#+8
   \      0x114   0xF040 0x80EF      BNE.W    ??gcode_G29_11
   4946                  if (code_seen('W')) {
   \      0x118   0x2057             MOVS     R0,#+87
   \      0x11A   0x.... 0x....      BL       _Z9code_seenc
   \      0x11E   0x2800             CMP      R0,#+0
   \      0x120   0xF000 0x80E9      BEQ.W    ??gcode_G29_11
   4947                    if (!bilinear_grid_spacing[X_AXIS]) {
   \      0x124   0xF8DF 0x4C48      LDR.W    R4,??gcode_G29_0+0x4
   \      0x128   0x68A0             LDR      R0,[R4, #+8]
   \      0x12A   0x2800             CMP      R0,#+0
   \      0x12C   0xD109             BNE.N    ??gcode_G29_12
   4948                      SERIAL_ERROR_START;
   \      0x12E   0xF8DF 0x0C50      LDR.W    R0,??gcode_G29_0+0x14
   \      0x132   0x.... 0x....      BL       _Z14serialprintPGMPKc
   4949                      SERIAL_ERRORLNPGM("No bilinear grid");
   \      0x136   0xF8DF 0x0C4C      LDR.W    R0,??gcode_G29_0+0x18
   \      0x13A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   4950                      return;
   \      0x13E   0xF000 0xBF06      B.W      ??gcode_G29_3
   4951                    }
   4952          
   4953                    const float z = code_seen('Z') && code_has_value() ? code_value_float() : 99999;
   \                     ??gcode_G29_12: (+1)
   \      0x142   0x205A             MOVS     R0,#+90
   \      0x144   0x.... 0x....      BL       _Z9code_seenc
   \      0x148   0x2800             CMP      R0,#+0
   \      0x14A   0xD007             BEQ.N    ??gcode_G29_13
   \      0x14C   0x.... 0x....      BL       _Z14code_has_valuev
   \      0x150   0x2800             CMP      R0,#+0
   \      0x152   0xD003             BEQ.N    ??gcode_G29_13
   \      0x154   0x.... 0x....      BL       _Z16code_value_floatv
   \      0x158   0x4605             MOV      R5,R0
   \      0x15A   0xE001             B.N      ??gcode_G29_14
   \                     ??gcode_G29_13: (+1)
   \      0x15C   0xF8DF 0x5C28      LDR.W    R5,??gcode_G29_0+0x1C  ;; 0x47c34f80
   4954                    if (!WITHIN(z, -10, 10)) {
   \                     ??gcode_G29_14: (+1)
   \      0x160   0x4628             MOV      R0,R5
   \      0x162   0xF8DF 0x1C28      LDR.W    R1,??gcode_G29_0+0x20  ;; 0xc1200000
   \      0x166   0x.... 0x....      BL       __aeabi_cfrcmple
   \      0x16A   0xD804             BHI.N    ??gcode_G29_15
   \      0x16C   0xF8DF 0x1C20      LDR.W    R1,??gcode_G29_0+0x24  ;; 0x41200001
   \      0x170   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x174   0xD309             BCC.N    ??gcode_G29_16
   4955                      SERIAL_ERROR_START;
   \                     ??gcode_G29_15: (+1)
   \      0x176   0xF8DF 0x0C08      LDR.W    R0,??gcode_G29_0+0x14
   \      0x17A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   4956                      SERIAL_ERRORLNPGM("Bad Z value");
   \      0x17E   0xF8DF 0x0C14      LDR.W    R0,??gcode_G29_0+0x28
   \      0x182   0x.... 0x....      BL       _Z14serialprintPGMPKc
   4957                      return;
   \      0x186   0xF000 0xBEE2      B.W      ??gcode_G29_3
   4958                    }
   4959          
   4960                    const float x = code_seen('X') && code_has_value() ? code_value_float() : 99999,
   \                     ??gcode_G29_16: (+1)
   \      0x18A   0x2058             MOVS     R0,#+88
   \      0x18C   0x.... 0x....      BL       _Z9code_seenc
   \      0x190   0x2800             CMP      R0,#+0
   \      0x192   0xD007             BEQ.N    ??gcode_G29_17
   \      0x194   0x.... 0x....      BL       _Z14code_has_valuev
   \      0x198   0x2800             CMP      R0,#+0
   \      0x19A   0xD003             BEQ.N    ??gcode_G29_17
   \      0x19C   0x.... 0x....      BL       _Z16code_value_floatv
   \      0x1A0   0x4681             MOV      R9,R0
   \      0x1A2   0xE001             B.N      ??gcode_G29_18
   \                     ??gcode_G29_17: (+1)
   \      0x1A4   0xF8DF 0x9BE0      LDR.W    R9,??gcode_G29_0+0x1C  ;; 0x47c34f80
   4961                                y = code_seen('Y') && code_has_value() ? code_value_float() : 99999;
   \                     ??gcode_G29_18: (+1)
   \      0x1A8   0x2059             MOVS     R0,#+89
   \      0x1AA   0x.... 0x....      BL       _Z9code_seenc
   \      0x1AE   0x2800             CMP      R0,#+0
   \      0x1B0   0xD007             BEQ.N    ??gcode_G29_19
   \      0x1B2   0x.... 0x....      BL       _Z14code_has_valuev
   \      0x1B6   0x2800             CMP      R0,#+0
   \      0x1B8   0xD003             BEQ.N    ??gcode_G29_19
   \      0x1BA   0x.... 0x....      BL       _Z16code_value_floatv
   \      0x1BE   0x4606             MOV      R6,R0
   \      0x1C0   0xE001             B.N      ??gcode_G29_20
   \                     ??gcode_G29_19: (+1)
   \      0x1C2   0xF8DF 0x6BC4      LDR.W    R6,??gcode_G29_0+0x1C  ;; 0x47c34f80
   4962                    int8_t i = code_seen('I') && code_has_value() ? code_value_byte() : -1,
   \                     ??gcode_G29_20: (+1)
   \      0x1C6   0x2049             MOVS     R0,#+73
   \      0x1C8   0x.... 0x....      BL       _Z9code_seenc
   \      0x1CC   0x2800             CMP      R0,#+0
   \      0x1CE   0xD007             BEQ.N    ??gcode_G29_21
   \      0x1D0   0x.... 0x....      BL       _Z14code_has_valuev
   \      0x1D4   0x2800             CMP      R0,#+0
   \      0x1D6   0xD003             BEQ.N    ??gcode_G29_21
   \      0x1D8   0x.... 0x....      BL       _Z15code_value_bytev
   \      0x1DC   0x4607             MOV      R7,R0
   \      0x1DE   0xE001             B.N      ??gcode_G29_22
   \                     ??gcode_G29_21: (+1)
   \      0x1E0   0xF04F 0x37FF      MOV      R7,#-1
   4963                           j = code_seen('J') && code_has_value() ? code_value_byte() : -1;
   \                     ??gcode_G29_22: (+1)
   \      0x1E4   0x204A             MOVS     R0,#+74
   \      0x1E6   0x.... 0x....      BL       _Z9code_seenc
   \      0x1EA   0x2800             CMP      R0,#+0
   \      0x1EC   0xD007             BEQ.N    ??gcode_G29_23
   \      0x1EE   0x.... 0x....      BL       _Z14code_has_valuev
   \      0x1F2   0x2800             CMP      R0,#+0
   \      0x1F4   0xD003             BEQ.N    ??gcode_G29_23
   \      0x1F6   0x.... 0x....      BL       _Z15code_value_bytev
   \      0x1FA   0x4602             MOV      R2,R0
   \      0x1FC   0xE001             B.N      ??gcode_G29_24
   \                     ??gcode_G29_23: (+1)
   \      0x1FE   0xF04F 0x32FF      MOV      R2,#-1
   4964          
   4965                    if (x < 99998 && y < 99998) {
   \                     ??gcode_G29_24: (+1)
   \      0x202   0xF8DF 0x1CEC      LDR.W    R1,??gcode_G29_1  ;; 0x47c34f00
   \      0x206   0x4648             MOV      R0,R9
   \      0x208   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x20C   0xD24F             BCS.N    ??gcode_G29_25
   \      0x20E   0x4630             MOV      R0,R6
   \      0x210   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x214   0xD24B             BCS.N    ??gcode_G29_25
   4966                      // Get nearest i / j from x / y
   4967                      i = (x - LOGICAL_X_POSITION(bilinear_start[X_AXIS]) + 0.5 * xGridSpacing) / xGridSpacing;
                               ^
Warning[Pa093]: implicit conversion from floating point to integer
   \      0x216   0xF8DF 0x8CDC      LDR.W    R8,??gcode_G29_1+0x4
   \      0x21A   0x6920             LDR      R0,[R4, #+16]
   \      0x21C   0x.... 0x....      BL       __aeabi_i2f
   \      0x220   0xF8D8 0x1044      LDR      R1,[R8, #+68]
   \      0x224   0x.... 0x....      BL       __aeabi_fadd
   \      0x228   0x4601             MOV      R1,R0
   \      0x22A   0x4648             MOV      R0,R9
   \      0x22C   0x.... 0x....      BL       __aeabi_fsub
   \      0x230   0x.... 0x....      BL       __aeabi_f2d
   \      0x234   0x2200             MOVS     R2,#+0
   \      0x236   0x4613             MOV      R3,R2
   \      0x238   0x.... 0x....      BL       __aeabi_dadd
   \      0x23C   0x2200             MOVS     R2,#+0
   \      0x23E   0x4613             MOV      R3,R2
   \      0x240   0x.... 0x....      BL       __aeabi_ddiv
   \      0x244   0x.... 0x....      BL       __aeabi_d2iz
   \      0x248   0x4607             MOV      R7,R0
   4968                      j = (y - LOGICAL_Y_POSITION(bilinear_start[Y_AXIS]) + 0.5 * yGridSpacing) / yGridSpacing;
                               ^
Warning[Pa093]: implicit conversion from floating point to integer
   \      0x24A   0x6960             LDR      R0,[R4, #+20]
   \      0x24C   0x.... 0x....      BL       __aeabi_i2f
   \      0x250   0xF8D8 0x1048      LDR      R1,[R8, #+72]
   \      0x254   0x.... 0x....      BL       __aeabi_fadd
   \      0x258   0x4601             MOV      R1,R0
   \      0x25A   0x4630             MOV      R0,R6
   \      0x25C   0x.... 0x....      BL       __aeabi_fsub
   \      0x260   0x.... 0x....      BL       __aeabi_f2d
   \      0x264   0x2200             MOVS     R2,#+0
   \      0x266   0x4613             MOV      R3,R2
   \      0x268   0x.... 0x....      BL       __aeabi_dadd
   \      0x26C   0x2200             MOVS     R2,#+0
   \      0x26E   0x4613             MOV      R3,R2
   \      0x270   0x.... 0x....      BL       __aeabi_ddiv
   \      0x274   0x.... 0x....      BL       __aeabi_d2iz
   \      0x278   0x4602             MOV      R2,R0
   4969                      i = constrain(i, 0, GRID_MAX_POINTS_X - 1);
   \      0x27A   0x4638             MOV      R0,R7
   \      0x27C   0xB240             SXTB     R0,R0
   \      0x27E   0x2800             CMP      R0,#+0
   \      0x280   0xD501             BPL.N    ??gcode_G29_26
   \      0x282   0x2700             MOVS     R7,#+0
   \      0x284   0xE006             B.N      ??gcode_G29_27
   \                     ??gcode_G29_26: (+1)
   \      0x286   0x9909             LDR      R1,[SP, #+36]
   \      0x288   0x7809             LDRB     R1,[R1, #+0]
   \      0x28A   0x460B             MOV      R3,R1
   \      0x28C   0x1E5B             SUBS     R3,R3,#+1
   \      0x28E   0x4283             CMP      R3,R0
   \      0x290   0xDA00             BGE.N    ??gcode_G29_27
   \      0x292   0x1E4F             SUBS     R7,R1,#+1
   4970                      j = constrain(j, 0, GRID_MAX_POINTS_Y - 1);
   \                     ??gcode_G29_27: (+1)
   \      0x294   0x4610             MOV      R0,R2
   \      0x296   0xB240             SXTB     R0,R0
   \      0x298   0x2800             CMP      R0,#+0
   \      0x29A   0xD501             BPL.N    ??gcode_G29_28
   \      0x29C   0x2200             MOVS     R2,#+0
   \      0x29E   0xE006             B.N      ??gcode_G29_25
   \                     ??gcode_G29_28: (+1)
   \      0x2A0   0x9909             LDR      R1,[SP, #+36]
   \      0x2A2   0x7849             LDRB     R1,[R1, #+1]
   \      0x2A4   0x460B             MOV      R3,R1
   \      0x2A6   0x1E5B             SUBS     R3,R3,#+1
   \      0x2A8   0x4283             CMP      R3,R0
   \      0x2AA   0xDA00             BGE.N    ??gcode_G29_25
   \      0x2AC   0x1E4A             SUBS     R2,R1,#+1
   4971                    }
   4972                    if (WITHIN(i, 0, GRID_MAX_POINTS_X - 1) && WITHIN(j, 0, GRID_MAX_POINTS_Y)) {
   \                     ??gcode_G29_25: (+1)
   \      0x2AE   0xB27F             SXTB     R7,R7
   \      0x2B0   0x2F00             CMP      R7,#+0
   \      0x2B2   0xF100 0x864C      BMI.W    ??gcode_G29_3
   \      0x2B6   0x9809             LDR      R0,[SP, #+36]
   \      0x2B8   0x7800             LDRB     R0,[R0, #+0]
   \      0x2BA   0x1E40             SUBS     R0,R0,#+1
   \      0x2BC   0x42B8             CMP      R0,R7
   \      0x2BE   0xF2C0 0x8646      BLT.W    ??gcode_G29_3
   \      0x2C2   0x4614             MOV      R4,R2
   \      0x2C4   0xB264             SXTB     R4,R4
   \      0x2C6   0x2C00             CMP      R4,#+0
   \      0x2C8   0xF100 0x8641      BMI.W    ??gcode_G29_3
   \      0x2CC   0x9809             LDR      R0,[SP, #+36]
   \      0x2CE   0x7840             LDRB     R0,[R0, #+1]
   \      0x2D0   0xB252             SXTB     R2,R2
   \      0x2D2   0x4290             CMP      R0,R2
   \      0x2D4   0xF2C0 0x863B      BLT.W    ??gcode_G29_3
   4973                      set_bed_leveling_enabled(false);
   \      0x2D8   0x2000             MOVS     R0,#+0
   \      0x2DA   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   4974                      z_values[i][j] = z;
   \      0x2DE   0xF8DF 0x0CB0      LDR.W    R0,??gcode_G29_2
   \      0x2E2   0xEB00 0x1087      ADD      R0,R0,R7, LSL #+6
   \      0x2E6   0xF840 0x5024      STR      R5,[R0, R4, LSL #+2]
   4975                      #if ENABLED(ABL_BILINEAR_SUBDIVISION)
   4976                        bed_level_virt_interpolate();
   4977                      #endif
   4978                      set_bed_leveling_enabled(abl_should_enable);
   \      0x2EA   0xF89D 0x0020      LDRB     R0,[SP, #+32]
   \      0x2EE   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   4979                    }
   4980                    return;
   \      0x2F2   0xF000 0xBE2C      B.W      ??gcode_G29_3
   4981                  } // code_seen('W')
   4982          
   4983                }//#endif
   4984          
   4985          
   4986          
   4987                //#if HAS_LEVELING
   4988          	  if(BED_LEVELING_METHOD&HAS_LEVELING)
   \                     ??gcode_G29_11: (+1)
   \      0x2F6   0x980D             LDR      R0,[SP, #+52]
   \      0x2F8   0x7800             LDRB     R0,[R0, #+0]
   \      0x2FA   0xF010 0x0F3E      TST      R0,#0x3E
   \      0x2FE   0xD008             BEQ.N    ??gcode_G29_29
   4989          	  	{
   4990                  // Jettison bed leveling data
   4991                  if (code_seen('J')) {
   \      0x300   0x204A             MOVS     R0,#+74
   \      0x302   0x.... 0x....      BL       _Z9code_seenc
   \      0x306   0x2800             CMP      R0,#+0
   \      0x308   0xD003             BEQ.N    ??gcode_G29_29
   4992                    reset_bed_level();
   \      0x30A   0x.... 0x....      BL       _Z15reset_bed_levelv
   4993                    return;
   \      0x30E   0xF000 0xBE1E      B.W      ??gcode_G29_3
   4994                  }
   4995          	  	}
   4996                //#endif
   4997          
   4998                verbose_level = code_seen('V') && code_has_value() ? code_value_int() : 0;
   \                     ??gcode_G29_29: (+1)
   \      0x312   0x2056             MOVS     R0,#+86
   \      0x314   0x.... 0x....      BL       _Z9code_seenc
   \      0x318   0x2800             CMP      R0,#+0
   \      0x31A   0xD006             BEQ.N    ??gcode_G29_30
   \      0x31C   0x.... 0x....      BL       _Z14code_has_valuev
   \      0x320   0x2800             CMP      R0,#+0
   \      0x322   0xD002             BEQ.N    ??gcode_G29_30
   \      0x324   0x.... 0x....      BL       _Z14code_value_intv
   \      0x328   0x900C             STR      R0,[SP, #+48]
   4999                if (!WITHIN(verbose_level, 0, 4)) {
   \                     ??gcode_G29_30: (+1)
   \      0x32A   0x980C             LDR      R0,[SP, #+48]
   \      0x32C   0x2805             CMP      R0,#+5
   \      0x32E   0xD305             BCC.N    ??gcode_G29_31
   5000                  SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-4).");
   \      0x330   0xF8DF 0x0C60      LDR.W    R0,??gcode_G29_2+0x4
   \      0x334   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5001                  return;
   \      0x338   0xF000 0xBE09      B.W      ??gcode_G29_3
   5002                }
   5003          
   5004                dryrun = code_seen('D') && code_value_bool();
   \                     ??gcode_G29_31: (+1)
   \      0x33C   0x2044             MOVS     R0,#+68
   \      0x33E   0x.... 0x....      BL       _Z9code_seenc
   \      0x342   0x2800             CMP      R0,#+0
   \      0x344   0xD007             BEQ.N    ??gcode_G29_32
   \      0x346   0x.... 0x....      BL       _Z15code_value_boolv
   \      0x34A   0x1E40             SUBS     R0,R0,#+1
   \      0x34C   0x4180             SBCS     R0,R0,R0
   \      0x34E   0x43C0             MVNS     R0,R0
   \      0x350   0x0FC0             LSRS     R0,R0,#+31
   \      0x352   0x900E             STR      R0,[SP, #+56]
   \      0x354   0xE001             B.N      ??gcode_G29_33
   \                     ??gcode_G29_32: (+1)
   \      0x356   0x2000             MOVS     R0,#+0
   \      0x358   0x900E             STR      R0,[SP, #+56]
   5005          
   5006          	  /*--mks cfg--begin AUTO_BED_LEVELING_BILINEAR */
   5007          /*
   5008                #if ENABLED(AUTO_BED_LEVELING_LINEAR)
   5009          
   5010                  do_topography_map = verbose_level > 2 || code_seen('T');
   5011          
   5012                  // X and Y specify points in each direction, overriding the default
   5013                  // These values may be saved with the completed mesh
   5014                  abl_grid_points_x = code_seen('X') ? code_value_int() : GRID_MAX_POINTS_X;
   5015                  abl_grid_points_y = code_seen('Y') ? code_value_int() : GRID_MAX_POINTS_Y;
   5016                  if (code_seen('P')) abl_grid_points_x = abl_grid_points_y = code_value_int();
   5017          
   5018                  if (abl_grid_points_x < 2 || abl_grid_points_y < 2) {
   5019                    SERIAL_PROTOCOLLNPGM("?Number of probe points is implausible (2 minimum).");
   5020                    return;
   5021                  }
   5022          
   5023                  abl2 = abl_grid_points_x * abl_grid_points_y;
   5024          
   5025                #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
   5026          
   5027                  zoffset = code_seen('Z') ? code_value_linear_units() : 0;
   5028          
   5029                #endif
   5030          */		
   5031          
   5032          		if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_LINEAR)  {
   \                     ??gcode_G29_33: (+1)
   \      0x35A   0x980D             LDR      R0,[SP, #+52]
   \      0x35C   0x7800             LDRB     R0,[R0, #+0]
   \      0x35E   0x0741             LSLS     R1,R0,#+29
   \      0x360   0xD540             BPL.N    ??gcode_G29_34
   5033          
   5034                  do_topography_map = verbose_level > 2 || code_seen('T');
   \      0x362   0x980C             LDR      R0,[SP, #+48]
   \      0x364   0x2803             CMP      R0,#+3
   \      0x366   0xDA04             BGE.N    ??gcode_G29_35
   \      0x368   0x2054             MOVS     R0,#+84
   \      0x36A   0x.... 0x....      BL       _Z9code_seenc
   \      0x36E   0x2800             CMP      R0,#+0
   \      0x370   0xD002             BEQ.N    ??gcode_G29_36
   \                     ??gcode_G29_35: (+1)
   \      0x372   0x2001             MOVS     R0,#+1
   \      0x374   0xF88D 0x000C      STRB     R0,[SP, #+12]
   5035          
   5036                  // X and Y specify points in each direction, overriding the default
   5037                  // These values may be saved with the completed mesh
   5038                  abl_grid_points_x = code_seen('X') ? code_value_int() : GRID_MAX_POINTS_X;
   \                     ??gcode_G29_36: (+1)
   \      0x378   0x2058             MOVS     R0,#+88
   \      0x37A   0x.... 0x....      BL       _Z9code_seenc
   \      0x37E   0x2800             CMP      R0,#+0
   \      0x380   0xD004             BEQ.N    ??gcode_G29_37
   \      0x382   0x.... 0x....      BL       _Z14code_value_intv
   \      0x386   0xB2C0             UXTB     R0,R0
   \      0x388   0x900B             STR      R0,[SP, #+44]
   \      0x38A   0xE002             B.N      ??gcode_G29_38
   \                     ??gcode_G29_37: (+1)
   \      0x38C   0x9809             LDR      R0,[SP, #+36]
   \      0x38E   0x7800             LDRB     R0,[R0, #+0]
   \      0x390   0x900B             STR      R0,[SP, #+44]
   5039                  abl_grid_points_y = code_seen('Y') ? code_value_int() : GRID_MAX_POINTS_Y;
   \                     ??gcode_G29_38: (+1)
   \      0x392   0x2059             MOVS     R0,#+89
   \      0x394   0x.... 0x....      BL       _Z9code_seenc
   \      0x398   0x2800             CMP      R0,#+0
   \      0x39A   0xD004             BEQ.N    ??gcode_G29_39
   \      0x39C   0x.... 0x....      BL       _Z14code_value_intv
   \      0x3A0   0xB2C0             UXTB     R0,R0
   \      0x3A2   0x9004             STR      R0,[SP, #+16]
   \      0x3A4   0xE002             B.N      ??gcode_G29_40
   \                     ??gcode_G29_39: (+1)
   \      0x3A6   0x9809             LDR      R0,[SP, #+36]
   \      0x3A8   0x7840             LDRB     R0,[R0, #+1]
   \      0x3AA   0x9004             STR      R0,[SP, #+16]
   5040                  if (code_seen('P')) abl_grid_points_x = abl_grid_points_y = code_value_int();
   \                     ??gcode_G29_40: (+1)
   \      0x3AC   0x2050             MOVS     R0,#+80
   \      0x3AE   0x.... 0x....      BL       _Z9code_seenc
   \      0x3B2   0x2800             CMP      R0,#+0
   \      0x3B4   0xD006             BEQ.N    ??gcode_G29_41
   \      0x3B6   0x.... 0x....      BL       _Z14code_value_intv
   \      0x3BA   0xB2C0             UXTB     R0,R0
   \      0x3BC   0x9004             STR      R0,[SP, #+16]
   \      0x3BE   0xA804             ADD      R0,SP,#+16
   \      0x3C0   0x7800             LDRB     R0,[R0, #+0]
   \      0x3C2   0x900B             STR      R0,[SP, #+44]
   5041          
   5042                  if (abl_grid_points_x < 2 || abl_grid_points_y < 2) {
   \                     ??gcode_G29_41: (+1)
   \      0x3C4   0x980B             LDR      R0,[SP, #+44]
   \      0x3C6   0x2801             CMP      R0,#+1
   \      0x3C8   0xDD02             BLE.N    ??gcode_G29_42
   \      0x3CA   0x9804             LDR      R0,[SP, #+16]
   \      0x3CC   0x2801             CMP      R0,#+1
   \      0x3CE   0xDC05             BGT.N    ??gcode_G29_43
   5043                    SERIAL_PROTOCOLLNPGM("?Number of probe points is implausible (2 minimum).");
   \                     ??gcode_G29_42: (+1)
   \      0x3D0   0xF8DF 0x0BC4      LDR.W    R0,??gcode_G29_2+0x8
   \      0x3D4   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5044                    return;
   \      0x3D8   0xF000 0xBDB9      B.W      ??gcode_G29_3
   5045                  }
   5046          
   5047                  abl2 = abl_grid_points_x * abl_grid_points_y;
   \                     ??gcode_G29_43: (+1)
   \      0x3DC   0x990B             LDR      R1,[SP, #+44]
   \      0x3DE   0x4341             MULS     R1,R0,R1
   \      0x3E0   0x910A             STR      R1,[SP, #+40]
   \      0x3E2   0xE00C             B.N      ??gcode_G29_44
   5048          			}
   5049          		else if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_BILINEAR)
   \                     ??gcode_G29_34: (+1)
   \      0x3E4   0x0700             LSLS     R0,R0,#+28
   \      0x3E6   0xD50A             BPL.N    ??gcode_G29_44
   5050          			{
   5051                  	zoffset = code_seen('Z') ? code_value_linear_units() : 0;
   \      0x3E8   0x205A             MOVS     R0,#+90
   \      0x3EA   0x.... 0x....      BL       _Z9code_seenc
   \      0x3EE   0x2800             CMP      R0,#+0
   \      0x3F0   0xD003             BEQ.N    ??gcode_G29_45
   \      0x3F2   0x.... 0x....      BL       _Z16code_value_floatv
   \      0x3F6   0x9007             STR      R0,[SP, #+28]
   \      0x3F8   0xE001             B.N      ??gcode_G29_44
   \                     ??gcode_G29_45: (+1)
   \      0x3FA   0x2000             MOVS     R0,#+0
   \      0x3FC   0x9007             STR      R0,[SP, #+28]
   5052          			}
   5053          
   5054          	  /*--mks cfg--end AUTO_BED_LEVELING_BILINEAR */
   5055          
   5056          
   5057                //#if ABL_GRID
   5058          	if(BED_LEVELING_METHOD&ABL_GRID)  {
   \                     ??gcode_G29_44: (+1)
   \      0x3FE   0x980D             LDR      R0,[SP, #+52]
   \      0x400   0x7800             LDRB     R0,[R0, #+0]
   \      0x402   0xF010 0x0F0C      TST      R0,#0xC
   \      0x406   0xF000 0x80F5      BEQ.W    ??gcode_G29_46
   5059          	
   5060                  xy_probe_feedrate_mm_s = MMM_TO_MMS(code_seen('S') ? code_value_linear_units() : XY_PROBE_SPEED);
   \      0x40A   0x2053             MOVS     R0,#+83
   \      0x40C   0x.... 0x....      BL       _Z9code_seenc
   \      0x410   0x2800             CMP      R0,#+0
   \      0x412   0xD002             BEQ.N    ??gcode_G29_47
   \      0x414   0x.... 0x....      BL       _Z16code_value_floatv
   \      0x418   0xE001             B.N      ??gcode_G29_48
   \                     ??gcode_G29_47: (+1)
   \      0x41A   0x9809             LDR      R0,[SP, #+36]
   \      0x41C   0x6940             LDR      R0,[R0, #+20]
   \                     ??gcode_G29_48: (+1)
   \      0x41E   0xF8DF 0x6AD4      LDR.W    R6,??gcode_G29_1+0x4
   \      0x422   0xF8DF 0x1B78      LDR.W    R1,??gcode_G29_2+0xC  ;; 0x42700000
   \      0x426   0x.... 0x....      BL       __aeabi_fdiv
   \      0x42A   0x67F0             STR      R0,[R6, #+124]
   5061          
   5062                  left_probe_bed_position = code_seen('L') ? (int)code_value_linear_units() : LOGICAL_X_POSITION(LEFT_PROBE_BED_POSITION);
                                                 ^
Warning[Pa093]: implicit conversion from floating point to integer
   \      0x42C   0x204C             MOVS     R0,#+76
   \      0x42E   0x.... 0x....      BL       _Z9code_seenc
   \      0x432   0x2800             CMP      R0,#+0
   \      0x434   0xD005             BEQ.N    ??gcode_G29_49
   \      0x436   0x.... 0x....      BL       _Z16code_value_floatv
   \      0x43A   0x.... 0x....      BL       __aeabi_f2iz
   \      0x43E   0x9002             STR      R0,[SP, #+8]
   \      0x440   0xE007             B.N      ??gcode_G29_50
   \                     ??gcode_G29_49: (+1)
   \      0x442   0x9809             LDR      R0,[SP, #+36]
   \      0x444   0x6A80             LDR      R0,[R0, #+40]
   \      0x446   0x6C71             LDR      R1,[R6, #+68]
   \      0x448   0x.... 0x....      BL       __aeabi_fadd
   \      0x44C   0x.... 0x....      BL       __aeabi_f2iz
   \      0x450   0x9002             STR      R0,[SP, #+8]
   5063                  right_probe_bed_position = code_seen('R') ? (int)code_value_linear_units() : LOGICAL_X_POSITION(RIGHT_PROBE_BED_POSITION);
                                                  ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??gcode_G29_50: (+1)
   \      0x452   0x2052             MOVS     R0,#+82
   \      0x454   0x.... 0x....      BL       _Z9code_seenc
   \      0x458   0x2800             CMP      R0,#+0
   \      0x45A   0xD005             BEQ.N    ??gcode_G29_51
   \      0x45C   0x.... 0x....      BL       _Z16code_value_floatv
   \      0x460   0x.... 0x....      BL       __aeabi_f2iz
   \      0x464   0x4604             MOV      R4,R0
   \      0x466   0xE007             B.N      ??gcode_G29_52
   \                     ??gcode_G29_51: (+1)
   \      0x468   0x9809             LDR      R0,[SP, #+36]
   \      0x46A   0x6AC0             LDR      R0,[R0, #+44]
   \      0x46C   0x6C71             LDR      R1,[R6, #+68]
   \      0x46E   0x.... 0x....      BL       __aeabi_fadd
   \      0x472   0x.... 0x....      BL       __aeabi_f2iz
   \      0x476   0x4604             MOV      R4,R0
   5064                  front_probe_bed_position = code_seen('F') ? (int)code_value_linear_units() : LOGICAL_Y_POSITION(FRONT_PROBE_BED_POSITION);
                                                  ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??gcode_G29_52: (+1)
   \      0x478   0x2046             MOVS     R0,#+70
   \      0x47A   0x.... 0x....      BL       _Z9code_seenc
   \      0x47E   0x2800             CMP      R0,#+0
   \      0x480   0xD005             BEQ.N    ??gcode_G29_53
   \      0x482   0x.... 0x....      BL       _Z16code_value_floatv
   \      0x486   0x.... 0x....      BL       __aeabi_f2iz
   \      0x48A   0x9001             STR      R0,[SP, #+4]
   \      0x48C   0xE007             B.N      ??gcode_G29_54
   \                     ??gcode_G29_53: (+1)
   \      0x48E   0x9809             LDR      R0,[SP, #+36]
   \      0x490   0x6B00             LDR      R0,[R0, #+48]
   \      0x492   0x6CB1             LDR      R1,[R6, #+72]
   \      0x494   0x.... 0x....      BL       __aeabi_fadd
   \      0x498   0x.... 0x....      BL       __aeabi_f2iz
   \      0x49C   0x9001             STR      R0,[SP, #+4]
   5065                  back_probe_bed_position = code_seen('B') ? (int)code_value_linear_units() : LOGICAL_Y_POSITION(BACK_PROBE_BED_POSITION);
                                                 ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??gcode_G29_54: (+1)
   \      0x49E   0x2042             MOVS     R0,#+66
   \      0x4A0   0x.... 0x....      BL       _Z9code_seenc
   \      0x4A4   0x2800             CMP      R0,#+0
   \      0x4A6   0xD005             BEQ.N    ??gcode_G29_55
   \      0x4A8   0x.... 0x....      BL       _Z16code_value_floatv
   \      0x4AC   0x.... 0x....      BL       __aeabi_f2iz
   \      0x4B0   0x4606             MOV      R6,R0
   \      0x4B2   0xE007             B.N      ??gcode_G29_56
   \                     ??gcode_G29_55: (+1)
   \      0x4B4   0x9809             LDR      R0,[SP, #+36]
   \      0x4B6   0x6B40             LDR      R0,[R0, #+52]
   \      0x4B8   0x6CB1             LDR      R1,[R6, #+72]
   \      0x4BA   0x.... 0x....      BL       __aeabi_fadd
   \      0x4BE   0x.... 0x....      BL       __aeabi_f2iz
   \      0x4C2   0x4606             MOV      R6,R0
   5066          
   5067                  const bool left_out_l = left_probe_bed_position < LOGICAL_X_POSITION(MIN_PROBE_X),
   \                     ??gcode_G29_56: (+1)
   \      0x4C4   0xF8DF 0x0A2C      LDR.W    R0,??gcode_G29_1+0x4
   \      0x4C8   0xF8D0 0xA044      LDR      R10,[R0, #+68]
   \      0x4CC   0xF8DF 0x7AD0      LDR.W    R7,??gcode_G29_2+0x10
   \      0x4D0   0x6839             LDR      R1,[R7, #+0]
   \      0x4D2   0x4650             MOV      R0,R10
   \      0x4D4   0x.... 0x....      BL       __aeabi_fadd
   \      0x4D8   0x4601             MOV      R1,R0
   \      0x4DA   0x4689             MOV      R9,R1
   \      0x4DC   0x9802             LDR      R0,[SP, #+8]
   \      0x4DE   0x.... 0x....      BL       __aeabi_i2f
   \      0x4E2   0x4649             MOV      R1,R9
   \      0x4E4   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x4E8   0xD304             BCC.N    ??gcode_G29_57
   5068                             left_out = left_out_l || left_probe_bed_position > right_probe_bed_position - (MIN_PROBE_EDGE),
   \      0x4EA   0xF1A4 0x000A      SUB      R0,R4,#+10
   \      0x4EE   0x9902             LDR      R1,[SP, #+8]
   \      0x4F0   0x4288             CMP      R0,R1
   \      0x4F2   0xDA02             BGE.N    ??gcode_G29_58
   \                     ??gcode_G29_57: (+1)
   \      0x4F4   0xF04F 0x0901      MOV      R9,#+1
   \      0x4F8   0xE001             B.N      ??gcode_G29_59
   \                     ??gcode_G29_58: (+1)
   \      0x4FA   0xF04F 0x0900      MOV      R9,#+0
   5069                             right_out_r = right_probe_bed_position > LOGICAL_X_POSITION(MAX_PROBE_X),
   \                     ??gcode_G29_59: (+1)
   \      0x4FE   0x4620             MOV      R0,R4
   \      0x500   0x.... 0x....      BL       __aeabi_i2f
   \      0x504   0x4601             MOV      R1,R0
   \      0x506   0x468B             MOV      R11,R1
   \      0x508   0x6879             LDR      R1,[R7, #+4]
   \      0x50A   0x4650             MOV      R0,R10
   \      0x50C   0x.... 0x....      BL       __aeabi_fadd
   \      0x510   0x4659             MOV      R1,R11
   \      0x512   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x516   0xD303             BCC.N    ??gcode_G29_60
   5070                             right_out = right_out_r || right_probe_bed_position < left_probe_bed_position + MIN_PROBE_EDGE,
   \      0x518   0x9802             LDR      R0,[SP, #+8]
   \      0x51A   0x300A             ADDS     R0,R0,#+10
   \      0x51C   0x4284             CMP      R4,R0
   \      0x51E   0xDA02             BGE.N    ??gcode_G29_61
   \                     ??gcode_G29_60: (+1)
   \      0x520   0xF04F 0x0A01      MOV      R10,#+1
   \      0x524   0xE001             B.N      ??gcode_G29_62
   \                     ??gcode_G29_61: (+1)
   \      0x526   0xF04F 0x0A00      MOV      R10,#+0
   5071                             front_out_f = front_probe_bed_position < LOGICAL_Y_POSITION(MIN_PROBE_Y),
   \                     ??gcode_G29_62: (+1)
   \      0x52A   0x68B8             LDR      R0,[R7, #+8]
   \      0x52C   0xF8DF 0x19C4      LDR.W    R1,??gcode_G29_1+0x4
   \      0x530   0x6C89             LDR      R1,[R1, #+72]
   \      0x532   0x.... 0x....      BL       __aeabi_fadd
   \      0x536   0x4601             MOV      R1,R0
   \      0x538   0x468B             MOV      R11,R1
   \      0x53A   0x9801             LDR      R0,[SP, #+4]
   \      0x53C   0x.... 0x....      BL       __aeabi_i2f
   \      0x540   0x4659             MOV      R1,R11
   \      0x542   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x546   0xD304             BCC.N    ??gcode_G29_63
   5072                             front_out = front_out_f || front_probe_bed_position > back_probe_bed_position - (MIN_PROBE_EDGE),
   \      0x548   0xF1A6 0x000A      SUB      R0,R6,#+10
   \      0x54C   0x9901             LDR      R1,[SP, #+4]
   \      0x54E   0x4288             CMP      R0,R1
   \      0x550   0xDA02             BGE.N    ??gcode_G29_64
   \                     ??gcode_G29_63: (+1)
   \      0x552   0xF04F 0x0B01      MOV      R11,#+1
   \      0x556   0xE001             B.N      ??gcode_G29_65
   \                     ??gcode_G29_64: (+1)
   \      0x558   0xF04F 0x0B00      MOV      R11,#+0
   5073                             back_out_b = back_probe_bed_position > LOGICAL_Y_POSITION(MAX_PROBE_Y),
   \                     ??gcode_G29_65: (+1)
   \      0x55C   0x4630             MOV      R0,R6
   \      0x55E   0x.... 0x....      BL       __aeabi_i2f
   \      0x562   0x4601             MOV      R1,R0
   \      0x564   0x9100             STR      R1,[SP, #+0]
   \      0x566   0x68F8             LDR      R0,[R7, #+12]
   \      0x568   0xF8DF 0x1988      LDR.W    R1,??gcode_G29_1+0x4
   \      0x56C   0x6C89             LDR      R1,[R1, #+72]
   \      0x56E   0x.... 0x....      BL       __aeabi_fadd
   \      0x572   0x9900             LDR      R1,[SP, #+0]
   \      0x574   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x578   0xD303             BCC.N    ??gcode_G29_66
   5074                             back_out = back_out_b || back_probe_bed_position < front_probe_bed_position + MIN_PROBE_EDGE;
   \      0x57A   0x9801             LDR      R0,[SP, #+4]
   \      0x57C   0x300A             ADDS     R0,R0,#+10
   \      0x57E   0x4286             CMP      R6,R0
   \      0x580   0xDA01             BGE.N    ??gcode_G29_67
   \                     ??gcode_G29_66: (+1)
   \      0x582   0x2701             MOVS     R7,#+1
   \      0x584   0xE000             B.N      ??gcode_G29_68
   \                     ??gcode_G29_67: (+1)
   \      0x586   0x2700             MOVS     R7,#+0
   5075          
   5076                  if (left_out || right_out || front_out || back_out) {
   \                     ??gcode_G29_68: (+1)
   \      0x588   0xEA4A 0x0009      ORR      R0,R10,R9
   \      0x58C   0xEA4B 0x0000      ORR      R0,R11,R0
   \      0x590   0x4338             ORRS     R0,R7,R0
   \      0x592   0xD01D             BEQ.N    ??gcode_G29_69
   5077                    if (left_out) {
   \      0x594   0xF1B9 0x0F00      CMP      R9,#+0
   \      0x598   0xD003             BEQ.N    ??gcode_G29_70
   5078                      out_of_range_error(PSTR("(L)eft"));
   \      0x59A   0xF8DF 0x0A08      LDR.W    R0,??gcode_G29_2+0x14
   \      0x59E   0x.... 0x....      BL       _Z18out_of_range_errorPKc
   5079                      left_probe_bed_position = left_out_l ? LOGICAL_X_POSITION(MIN_PROBE_X) : right_probe_bed_position - (MIN_PROBE_EDGE);
                                                     ^
Warning[Pa093]: implicit conversion from floating point to integer
   5080                    }
   5081                    if (right_out) {
   \                     ??gcode_G29_70: (+1)
   \      0x5A2   0xF1BA 0x0F00      CMP      R10,#+0
   \      0x5A6   0xD003             BEQ.N    ??gcode_G29_71
   5082                      out_of_range_error(PSTR("(R)ight"));
   \      0x5A8   0xF8DF 0x09FC      LDR.W    R0,??gcode_G29_2+0x18
   \      0x5AC   0x.... 0x....      BL       _Z18out_of_range_errorPKc
   5083                      right_probe_bed_position = right_out_r ? LOGICAL_Y_POSITION(MAX_PROBE_X) : left_probe_bed_position + MIN_PROBE_EDGE;
                                                      ^
Warning[Pa093]: implicit conversion from floating point to integer
   5084                    }
   5085                    if (front_out) {
   \                     ??gcode_G29_71: (+1)
   \      0x5B0   0xF1BB 0x0F00      CMP      R11,#+0
   \      0x5B4   0xD003             BEQ.N    ??gcode_G29_72
   5086                      out_of_range_error(PSTR("(F)ront"));
   \      0x5B6   0xF8DF 0x09F4      LDR.W    R0,??gcode_G29_2+0x1C
   \      0x5BA   0x.... 0x....      BL       _Z18out_of_range_errorPKc
   5087                      front_probe_bed_position = front_out_f ? LOGICAL_Y_POSITION(MIN_PROBE_Y) : back_probe_bed_position - (MIN_PROBE_EDGE);
                                                      ^
Warning[Pa093]: implicit conversion from floating point to integer
   5088                    }
   5089                    if (back_out) {
   \                     ??gcode_G29_72: (+1)
   \      0x5BE   0x2F00             CMP      R7,#+0
   \      0x5C0   0xF000 0x84C5      BEQ.W    ??gcode_G29_3
   5090                      out_of_range_error(PSTR("(B)ack"));
   \      0x5C4   0xF8DF 0x09E8      LDR.W    R0,??gcode_G29_2+0x20
   \      0x5C8   0x.... 0x....      BL       _Z18out_of_range_errorPKc
   5091                      back_probe_bed_position = back_out_b ? LOGICAL_Y_POSITION(MAX_PROBE_Y) : front_probe_bed_position + MIN_PROBE_EDGE;
                                                     ^
Warning[Pa093]: implicit conversion from floating point to integer
   5092                    }
   5093                    return;
   \      0x5CC   0xF000 0xBCBF      B.W      ??gcode_G29_3
   5094                  }
   5095          
   5096                  // probe at the points of a lattice grid
   5097                  xGridSpacing = (right_probe_bed_position - left_probe_bed_position) / (abl_grid_points_x - 1);
   \                     ??gcode_G29_69: (+1)
   \      0x5D0   0x9802             LDR      R0,[SP, #+8]
   \      0x5D2   0x1A24             SUBS     R4,R4,R0
   \      0x5D4   0x980B             LDR      R0,[SP, #+44]
   \      0x5D6   0x1E40             SUBS     R0,R0,#+1
   \      0x5D8   0xFB94 0xF0F0      SDIV     R0,R4,R0
   \      0x5DC   0x.... 0x....      BL       __aeabi_i2f
   \      0x5E0   0x9006             STR      R0,[SP, #+24]
   5098                  yGridSpacing = (back_probe_bed_position - front_probe_bed_position) / (abl_grid_points_y - 1);
   \      0x5E2   0x9801             LDR      R0,[SP, #+4]
   \      0x5E4   0x1A36             SUBS     R6,R6,R0
   \      0x5E6   0x9804             LDR      R0,[SP, #+16]
   \      0x5E8   0x1E40             SUBS     R0,R0,#+1
   \      0x5EA   0xFB96 0xF0F0      SDIV     R0,R6,R0
   \      0x5EE   0x.... 0x....      BL       __aeabi_i2f
   \      0x5F2   0x9005             STR      R0,[SP, #+20]
   5099          		}
   5100                //#endif // ABL_GRID
   5101          
   5102                if (verbose_level > 0) {
   \                     ??gcode_G29_46: (+1)
   \      0x5F4   0x980C             LDR      R0,[SP, #+48]
   \      0x5F6   0x2800             CMP      R0,#+0
   \      0x5F8   0xDD0A             BLE.N    ??gcode_G29_73
   5103                  SERIAL_PROTOCOLLNPGM("G29 Auto Bed Leveling");
   \      0x5FA   0xF8DF 0x09B8      LDR.W    R0,??gcode_G29_2+0x24
   \      0x5FE   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5104                  if (dryrun) SERIAL_PROTOCOLLNPGM("Running in DRY-RUN mode");
   \      0x602   0x980E             LDR      R0,[SP, #+56]
   \      0x604   0x2800             CMP      R0,#+0
   \      0x606   0xD003             BEQ.N    ??gcode_G29_73
   \      0x608   0xF8DF 0x09AC      LDR.W    R0,??gcode_G29_2+0x28
   \      0x60C   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5105                }
   5106          
   5107                stepper.synchronize();
   \                     ??gcode_G29_73: (+1)
   \      0x610   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   5108          
   5109                // Disable auto bed leveling during G29
   5110                planner.abl_enabled = false;
   \      0x614   0x2000             MOVS     R0,#+0
   \      0x616   0xF8DF 0x1764      LDR.W    R1,??gcode_G29_0+0x10
   \      0x61A   0x7008             STRB     R0,[R1, #+0]
   5111          
   5112                if (!dryrun) {
   \      0x61C   0x980E             LDR      R0,[SP, #+56]
   \      0x61E   0x2800             CMP      R0,#+0
   \      0x620   0xD104             BNE.N    ??gcode_G29_74
   5113                  // Re-orient the current position without leveling
   5114                  // based on where the steppers are positioned.
   5115                  set_current_from_steppers_for_axis(ALL_AXES);
   \      0x622   0x2064             MOVS     R0,#+100
   \      0x624   0x.... 0x....      BL       _Z34set_current_from_steppers_for_axis8AxisEnum
   5116          
   5117                  // Sync the planner to where the steppers stopped
   5118                  SYNC_PLAN_POSITION_KINEMATIC();
   \      0x628   0x.... 0x....      BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
   5119                }
   5120          
   5121                if (!faux) setup_for_endstop_or_probe_move();
   \                     ??gcode_G29_74: (+1)
   \      0x62C   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531931setup_for_endstop_or_probe_moveEv
   5122          
   5123                //xProbe = yProbe = measured_z = 0;
   5124          
   5125                #if HAS_BED_PROBE
   5126                  // Deploy the probe. Probe will raise if needed.
   5127                  if (DEPLOY_PROBE()) {
   \      0x630   0x2001             MOVS     R0,#+1
   \      0x632   0x.... 0x....      BL       _Z18set_probe_deployedb
   \      0x636   0x2800             CMP      R0,#+0
   \      0x638   0xF040 0x8214      BNE.W    ??gcode_G29_75
   5128                    planner.abl_enabled = abl_should_enable;
   5129                    return;
   5130                  }
   5131                #endif
   5132          
   5133          	  /*--mks cfg--begin AUTO_BED_LEVELING_BILINEAR */
   5134          /*
   5135                #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
   5136          
   5137                  if ( xGridSpacing != bilinear_grid_spacing[X_AXIS]
   5138                    || yGridSpacing != bilinear_grid_spacing[Y_AXIS]
   5139                    || left_probe_bed_position != LOGICAL_X_POSITION(bilinear_start[X_AXIS])
   5140                    || front_probe_bed_position != LOGICAL_Y_POSITION(bilinear_start[Y_AXIS])
   5141                  ) {
   5142                    if (dryrun) {
   5143                      // Before reset bed level, re-enable to correct the position
   5144                      planner.abl_enabled = abl_should_enable;
   5145                    }
   5146                    // Reset grid to 0.0 or "not probed". (Also disables ABL)
   5147                    reset_bed_level();
   5148          
   5149                    // Initialize a grid with the given dimensions
   5150                    bilinear_grid_spacing[X_AXIS] = xGridSpacing;
   5151                    bilinear_grid_spacing[Y_AXIS] = yGridSpacing;
   5152                    bilinear_start[X_AXIS] = RAW_X_POSITION(left_probe_bed_position);
   5153                    bilinear_start[Y_AXIS] = RAW_Y_POSITION(front_probe_bed_position);
   5154          
   5155                    // Can't re-enable (on error) until the new grid is written
   5156                    abl_should_enable = false;
   5157                  }
   5158          
   5159                #elif ENABLED(AUTO_BED_LEVELING_LINEAR)
   5160          
   5161                  mean = 0.0;
   5162          
   5163                #endif // AUTO_BED_LEVELING_LINEAR
   5164          */
   5165          	if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
   \      0x63C   0x980D             LDR      R0,[SP, #+52]
   \      0x63E   0x7800             LDRB     R0,[R0, #+0]
   \      0x640   0x2808             CMP      R0,#+8
   \      0x642   0xD15B             BNE.N    ??gcode_G29_76
   5166          		{
   5167                  if ( xGridSpacing != bilinear_grid_spacing[X_AXIS]
   5168                    || yGridSpacing != bilinear_grid_spacing[Y_AXIS]
   5169                    || left_probe_bed_position != LOGICAL_X_POSITION(bilinear_start[X_AXIS])
   5170                    || front_probe_bed_position != LOGICAL_Y_POSITION(bilinear_start[Y_AXIS])
   5171                  ) {
   \      0x644   0xF8DF 0x4728      LDR.W    R4,??gcode_G29_0+0x4
   \      0x648   0x68A0             LDR      R0,[R4, #+8]
   \      0x64A   0x.... 0x....      BL       __aeabi_i2f
   \      0x64E   0x4601             MOV      R1,R0
   \      0x650   0x9806             LDR      R0,[SP, #+24]
   \      0x652   0x.... 0x....      BL       __aeabi_cfcmpeq
   \      0x656   0xD127             BNE.N    ??gcode_G29_77
   \      0x658   0x68E0             LDR      R0,[R4, #+12]
   \      0x65A   0x.... 0x....      BL       __aeabi_i2f
   \      0x65E   0x4601             MOV      R1,R0
   \      0x660   0x9805             LDR      R0,[SP, #+20]
   \      0x662   0x.... 0x....      BL       __aeabi_cfcmpeq
   \      0x666   0xD11F             BNE.N    ??gcode_G29_77
   \      0x668   0xF8DF 0x6888      LDR.W    R6,??gcode_G29_1+0x4
   \      0x66C   0x9802             LDR      R0,[SP, #+8]
   \      0x66E   0x.... 0x....      BL       __aeabi_i2f
   \      0x672   0x4607             MOV      R7,R0
   \      0x674   0x6920             LDR      R0,[R4, #+16]
   \      0x676   0x.... 0x....      BL       __aeabi_i2f
   \      0x67A   0x6C71             LDR      R1,[R6, #+68]
   \      0x67C   0x.... 0x....      BL       __aeabi_fadd
   \      0x680   0x4601             MOV      R1,R0
   \      0x682   0x4638             MOV      R0,R7
   \      0x684   0x.... 0x....      BL       __aeabi_cfcmpeq
   \      0x688   0xD10E             BNE.N    ??gcode_G29_77
   \      0x68A   0x9801             LDR      R0,[SP, #+4]
   \      0x68C   0x.... 0x....      BL       __aeabi_i2f
   \      0x690   0x4607             MOV      R7,R0
   \      0x692   0x6960             LDR      R0,[R4, #+20]
   \      0x694   0x.... 0x....      BL       __aeabi_i2f
   \      0x698   0x6CB1             LDR      R1,[R6, #+72]
   \      0x69A   0x.... 0x....      BL       __aeabi_fadd
   \      0x69E   0x4601             MOV      R1,R0
   \      0x6A0   0x4638             MOV      R0,R7
   \      0x6A2   0x.... 0x....      BL       __aeabi_cfcmpeq
   \      0x6A6   0xD02D             BEQ.N    ??gcode_G29_78
   5172                    if (dryrun) {
   \                     ??gcode_G29_77: (+1)
   \      0x6A8   0x980E             LDR      R0,[SP, #+56]
   \      0x6AA   0x2800             CMP      R0,#+0
   \      0x6AC   0xD004             BEQ.N    ??gcode_G29_79
   5173                      // Before reset bed level, re-enable to correct the position
   5174                      planner.abl_enabled = abl_should_enable;
   \      0x6AE   0xF89D 0x0020      LDRB     R0,[SP, #+32]
   \      0x6B2   0xF8DF 0x16C8      LDR.W    R1,??gcode_G29_0+0x10
   \      0x6B6   0x7008             STRB     R0,[R1, #+0]
   5175                    }
   5176                    // Reset grid to 0.0 or "not probed". (Also disables ABL)
   5177                    reset_bed_level();
   \                     ??gcode_G29_79: (+1)
   \      0x6B8   0x.... 0x....      BL       _Z15reset_bed_levelv
   5178          
   5179                    // Initialize a grid with the given dimensions
   5180                    bilinear_grid_spacing[X_AXIS] = xGridSpacing;
                                                         ^
Warning[Pa093]: implicit conversion from floating point to integer
   \      0x6BC   0x9806             LDR      R0,[SP, #+24]
   \      0x6BE   0x.... 0x....      BL       __aeabi_f2iz
   \      0x6C2   0x60A0             STR      R0,[R4, #+8]
   5181                    bilinear_grid_spacing[Y_AXIS] = yGridSpacing;
                                                         ^
Warning[Pa093]: implicit conversion from floating point to integer
   \      0x6C4   0x9805             LDR      R0,[SP, #+20]
   \      0x6C6   0x.... 0x....      BL       __aeabi_f2iz
   \      0x6CA   0x60E0             STR      R0,[R4, #+12]
   5182                    bilinear_start[X_AXIS] = RAW_X_POSITION(left_probe_bed_position);
                                                  ^
Warning[Pa093]: implicit conversion from floating point to integer
   \      0x6CC   0xF8DF 0x6824      LDR.W    R6,??gcode_G29_1+0x4
   \      0x6D0   0x9802             LDR      R0,[SP, #+8]
   \      0x6D2   0x.... 0x....      BL       __aeabi_i2f
   \      0x6D6   0x6C71             LDR      R1,[R6, #+68]
   \      0x6D8   0x.... 0x....      BL       __aeabi_fsub
   \      0x6DC   0x.... 0x....      BL       __aeabi_f2iz
   \      0x6E0   0x6120             STR      R0,[R4, #+16]
   5183                    bilinear_start[Y_AXIS] = RAW_Y_POSITION(front_probe_bed_position);
                                                  ^
Warning[Pa093]: implicit conversion from floating point to integer
   \      0x6E2   0x9801             LDR      R0,[SP, #+4]
   \      0x6E4   0x.... 0x....      BL       __aeabi_i2f
   \      0x6E8   0x6CB1             LDR      R1,[R6, #+72]
   \      0x6EA   0x.... 0x....      BL       __aeabi_fsub
   \      0x6EE   0x.... 0x....      BL       __aeabi_f2iz
   \      0x6F2   0x6160             STR      R0,[R4, #+20]
   5184          
   5185                    // Can't re-enable (on error) until the new grid is written
   5186                    abl_should_enable = false;
   \      0x6F4   0x2000             MOVS     R0,#+0
   \      0x6F6   0xF88D 0x0020      STRB     R0,[SP, #+32]
   \      0x6FA   0xE003             B.N      ??gcode_G29_78
   5187                  }
   5188          		
   5189          		}
   5190          		else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_LINEAR)
   \                     ??gcode_G29_76: (+1)
   \      0x6FC   0x2804             CMP      R0,#+4
   \      0x6FE   0xD101             BNE.N    ??gcode_G29_78
   5191          			{
   5192          			mean = 0.0;
   \      0x700   0x2000             MOVS     R0,#+0
   \      0x702   0x9013             STR      R0,[SP, #+76]
   5193          			}
   5194          	  /*--mks cfg--end AUTO_BED_LEVELING_BILINEAR */
   5195          
   5196          
   5197                //#if ENABLED(AUTO_BED_LEVELING_3POINT)
   5198          	  if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_3POINT)
   \                     ??gcode_G29_78: (+1)
   \      0x704   0x980D             LDR      R0,[SP, #+52]
   \      0x706   0x7800             LDRB     R0,[R0, #+0]
   \      0x708   0x2802             CMP      R0,#+2
   \      0x70A   0xD104             BNE.N    ??gcode_G29_80
   5199          	  	{
   5200                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   5201                    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> 3-point Leveling");
   5202                  #endif
   5203          
   5204                  // Probe at 3 arbitrary points
   5205                  points[0].z = points[1].z = points[2].z = 0;
   \      0x70C   0xA819             ADD      R0,SP,#+100
   \      0x70E   0x2100             MOVS     R1,#+0
   \      0x710   0x6201             STR      R1,[R0, #+32]
   \      0x712   0x6141             STR      R1,[R0, #+20]
   \      0x714   0x6081             STR      R1,[R0, #+8]
   5206              	}
   5207                //#endif // AUTO_BED_LEVELING_3POINT
   5208          
   5209              } // !g29_in_progress
   5210          
   5211              #if ENABLED(PROBE_MANUALLY)
   5212          
   5213                // Abort current G29 procedure, go back to ABLStart
   5214                if (code_seen('A') && g29_in_progress) {
   5215                  SERIAL_PROTOCOLLNPGM("Manual G29 aborted");
   5216                  #if HAS_SOFTWARE_ENDSTOPS
   5217                    soft_endstops_enabled = enable_soft_endstops;
   5218                  #endif
   5219                  planner.abl_enabled = abl_should_enable;
   5220                  g29_in_progress = false;
   5221                }
   5222          
   5223                // Query G29 status
   5224                if (code_seen('Q')) {
   5225                  if (!g29_in_progress)
   5226                    SERIAL_PROTOCOLLNPGM("Manual G29 idle");
   5227                  else {
   5228                    SERIAL_PROTOCOLPAIR("Manual G29 point ", abl_probe_index + 1);
   5229                    SERIAL_PROTOCOLLNPAIR(" of ", abl2);
   5230                  }
   5231                }
   5232          
   5233                if (code_seen('A') || code_seen('Q')) return;
   5234          
   5235                // Fall through to probe the first point
   5236                g29_in_progress = true;
   5237          
   5238                if (abl_probe_index == 0) {
   5239                  // For the initial G29 save software endstop state
   5240                  #if HAS_SOFTWARE_ENDSTOPS
   5241                    enable_soft_endstops = soft_endstops_enabled;
   5242                  #endif
   5243                }
   5244                else {
   5245                  // For G29 after adjusting Z.
   5246                  // Save the previous Z before going to the next point
   5247                  measured_z = current_position[Z_AXIS];
   5248          
   5249          		/*--mks cfg--begin AUTO_BED_LEVELING_BILINEAR */
   5250          /*
   5251                  #if ENABLED(AUTO_BED_LEVELING_LINEAR)
   5252          
   5253                    mean += measured_z;
   5254                    eqnBVector[abl_probe_index] = measured_z;
   5255                    eqnAMatrix[abl_probe_index + 0 * abl2] = xProbe;
   5256                    eqnAMatrix[abl_probe_index + 1 * abl2] = yProbe;
   5257                    eqnAMatrix[abl_probe_index + 2 * abl2] = 1;
   5258          
   5259                  #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
   5260          
   5261                    z_values[xCount][yCount] = measured_z + zoffset;
   5262          
   5263                  #elif ENABLED(AUTO_BED_LEVELING_3POINT)
   5264          
   5265                    points[i].z = measured_z;
   5266          
   5267                  #endif
   5268          */
   5269          		if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
   5270          			z_values[xCount][yCount] = measured_z + zoffset;
   5271          		/*--mks cfg--end AUTO_BED_LEVELING_BILINEAR */		
   5272                }
   5273          
   5274                //
   5275                // If there's another point to sample, move there with optional lift.
   5276                //
   5277          
   5278                //#if ABL_GRID
   5279          	  if(BED_LEVELING_METHOD&ABL_GRID)
   5280          	  	{
   5281                  // Find a next point to probe
   5282                  // On the first G29 this will be the first probe point
   5283                  while (abl_probe_index < abl2) {
   5284          
   5285                    // Set xCount, yCount based on abl_probe_index, with zig-zag
   5286                    PR_OUTER_VAR = abl_probe_index / PR_INNER_END;
   5287                    PR_INNER_VAR = abl_probe_index - (PR_OUTER_VAR * PR_INNER_END);
   5288          
   5289                    bool zig = (PR_OUTER_VAR & 1) != ((PR_OUTER_END) & 1);
   5290          
   5291                    if (zig) PR_INNER_VAR = (PR_INNER_END - 1) - PR_INNER_VAR;
   5292          
   5293                    const float xBase = left_probe_bed_position + xGridSpacing * xCount,
   5294                                yBase = front_probe_bed_position + yGridSpacing * yCount;
   5295          
   5296                    xProbe = floor(xBase + (xBase < 0 ? 0 : 0.5));
   5297                    yProbe = floor(yBase + (yBase < 0 ? 0 : 0.5));
   5298          
   5299                    //#if ENABLED(AUTO_BED_LEVELING_LINEAR)
   5300          		  if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_LINEAR)
   5301                      indexIntoAB[xCount][yCount] = abl_probe_index;
   5302                    //#endif
   5303          
   5304                    float pos[XYZ] = { xProbe, yProbe, 0 };
   5305                    if (position_is_reachable(pos)) break;
   5306                    ++abl_probe_index;
   5307                  }
   5308          
   5309                  // Is there a next point to move to?
   5310                  if (abl_probe_index < abl2) {
   5311                    _manual_goto_xy(xProbe, yProbe); // Can be used here too!
   5312                    ++abl_probe_index;
   5313                    #if HAS_SOFTWARE_ENDSTOPS
   5314                      // Disable software endstops to allow manual adjustment
   5315                      // If G29 is not completed, they will not be re-enabled
   5316                      soft_endstops_enabled = false;
   5317                    #endif
   5318                    return;
   5319                  }
   5320                  else {
   5321                    // Then leveling is done!
   5322                    // G29 finishing code goes here
   5323          
   5324                    // After recording the last point, activate abl
   5325                    SERIAL_PROTOCOLLNPGM("Grid probing done.");
   5326                    g29_in_progress = false;
   5327          
   5328                    // Re-enable software endstops, if needed
   5329                    #if HAS_SOFTWARE_ENDSTOPS
   5330                      soft_endstops_enabled = enable_soft_endstops;
   5331                    #endif
   5332                  }
   5333          	  	}
   5334                //#elif ENABLED(AUTO_BED_LEVELING_3POINT)
   5335          	  else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_3POINT)	{
   5336                  // Probe at 3 arbitrary points
   5337                  if (abl_probe_index < 3) {
   5338                    xProbe = LOGICAL_X_POSITION(points[i].x);
   5339                    yProbe = LOGICAL_Y_POSITION(points[i].y);
   5340                    ++abl_probe_index;
   5341                    #if HAS_SOFTWARE_ENDSTOPS
   5342                      // Disable software endstops to allow manual adjustment
   5343                      // If G29 is not completed, they will not be re-enabled
   5344                      soft_endstops_enabled = false;
   5345                    #endif
   5346                    return;
   5347                  }
   5348                  else {
   5349          
   5350                    SERIAL_PROTOCOLLNPGM("3-point probing done.");
   5351                    g29_in_progress = false;
   5352          
   5353                    // Re-enable software endstops, if needed
   5354                    #if HAS_SOFTWARE_ENDSTOPS
   5355                      soft_endstops_enabled = enable_soft_endstops;
   5356                    #endif
   5357          
   5358                    if (!dryrun) {
   5359                      vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
   5360                      if (planeNormal.z < 0) {
   5361                        planeNormal.x *= -1;
   5362                        planeNormal.y *= -1;
   5363                        planeNormal.z *= -1;
   5364                      }
   5365                      planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
   5366                      ABC
   5367                      // Can't re-enable (on error) until the new grid is written
   5368                      abl_should_enable = false;
   5369                    }
   5370          
   5371                  }
   5372          	  }
   5373                //#endif // AUTO_BED_LEVELING_3POINT
   5374          
   5375              #else // !PROBE_MANUALLY
   5376          
   5377                bool stow_probe_after_each = code_seen('E');
   \                     ??gcode_G29_80: (+1)
   \      0x716   0x2045             MOVS     R0,#+69
   \      0x718   0x.... 0x....      BL       _Z9code_seenc
   \      0x71C   0x4601             MOV      R1,R0
   5378          
   5379                //#if ABL_GRID
   5380          		if(BED_LEVELING_METHOD&ABL_GRID)  {
   \      0x71E   0x980D             LDR      R0,[SP, #+52]
   \      0x720   0x7800             LDRB     R0,[R0, #+0]
   \      0x722   0xF010 0x0F0C      TST      R0,#0xC
   \      0x726   0xF000 0x80FD      BEQ.W    ??gcode_G29_81
   5381          
   5382                  bool zig = PR_OUTER_END & 1;  // Always end at RIGHT and BACK_PROBE_BED_POSITION
   \      0x72A   0x9804             LDR      R0,[SP, #+16]
   \      0x72C   0xF000 0x0001      AND      R0,R0,#0x1
   \      0x730   0xF88D 0x0001      STRB     R0,[SP, #+1]
   5383          
   5384                  // Outer loop is Y with PROBE_Y_FIRST disabled
   5385                  for (uint8_t PR_OUTER_VAR = 0; PR_OUTER_VAR < PR_OUTER_END; PR_OUTER_VAR++) {
   \      0x734   0x2200             MOVS     R2,#+0
   \      0x736   0xE00F             B.N      ??gcode_G29_82
   5386          
   5387                    int8_t inStart, inStop, inInc;
   5388          
   5389                    if (zig) { // away from origin
   5390                      inStart = 0;
   5391                      inStop = PR_INNER_END;
   5392                      inInc = 1;
   5393                    }
   5394                    else {     // towards origin
   5395                      inStart = PR_INNER_END - 1;
   5396                      inStop = -1;
   5397                      inInc = -1;
   5398                    }
   5399          
   5400                    zig ^= true; // zag
   5401          
   5402                    // Inner loop is Y with PROBE_Y_FIRST enabled
   5403                    for (int8_t PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; PR_INNER_VAR += inInc) {
   \                     ??gcode_G29_83: (+1)
   \      0x738   0xF8CD 0xB044      STR      R11,[SP, #+68]
   \      0x73C   0x9610             STR      R6,[SP, #+64]
   \      0x73E   0xF8CD 0xA03C      STR      R10,[SP, #+60]
   \      0x742   0xF8CD 0x9058      STR      R9,[SP, #+88]
   \      0x746   0x9413             STR      R4,[SP, #+76]
   \      0x748   0x9D14             LDR      R5,[SP, #+80]
   \      0x74A   0xF8DD 0x8054      LDR      R8,[SP, #+84]
   \      0x74E   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \      0x752   0x9A12             LDR      R2,[SP, #+72]
   \      0x754   0x1C52             ADDS     R2,R2,#+1
   \      0x756   0xB2D2             UXTB     R2,R2
   \                     ??gcode_G29_82: (+1)
   \      0x758   0x9804             LDR      R0,[SP, #+16]
   \      0x75A   0x4282             CMP      R2,R0
   \      0x75C   0xF280 0x817D      BGE.W    ??gcode_G29_84
   \      0x760   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \      0x764   0x2800             CMP      R0,#+0
   \      0x766   0xD005             BEQ.N    ??gcode_G29_85
   \      0x768   0x2000             MOVS     R0,#+0
   \      0x76A   0xAB0B             ADD      R3,SP,#+44
   \      0x76C   0xF993 0x3000      LDRSB    R3,[R3, #+0]
   \      0x770   0x2701             MOVS     R7,#+1
   \      0x772   0xE004             B.N      ??gcode_G29_86
   \                     ??gcode_G29_85: (+1)
   \      0x774   0x980B             LDR      R0,[SP, #+44]
   \      0x776   0x1E40             SUBS     R0,R0,#+1
   \      0x778   0xF04F 0x33FF      MOV      R3,#-1
   \      0x77C   0x461F             MOV      R7,R3
   \                     ??gcode_G29_86: (+1)
   \      0x77E   0xF89D 0x4001      LDRB     R4,[SP, #+1]
   \      0x782   0xF084 0x0401      EOR      R4,R4,#0x1
   \      0x786   0x1E64             SUBS     R4,R4,#+1
   \      0x788   0x41A4             SBCS     R4,R4,R4
   \      0x78A   0x43E4             MVNS     R4,R4
   \      0x78C   0x0FE4             LSRS     R4,R4,#+31
   \      0x78E   0xF88D 0x4001      STRB     R4,[SP, #+1]
   \      0x792   0xB240             SXTB     R0,R0
   \      0x794   0xF8DD 0xB044      LDR      R11,[SP, #+68]
   \      0x798   0x9E10             LDR      R6,[SP, #+64]
   \      0x79A   0xF8DD 0xA03C      LDR      R10,[SP, #+60]
   \      0x79E   0xF8DD 0x9058      LDR      R9,[SP, #+88]
   \      0x7A2   0x9C13             LDR      R4,[SP, #+76]
   \      0x7A4   0x9514             STR      R5,[SP, #+80]
   \      0x7A6   0xF8CD 0x8054      STR      R8,[SP, #+84]
   \      0x7AA   0xF88D 0x1000      STRB     R1,[SP, #+0]
   \      0x7AE   0x9212             STR      R2,[SP, #+72]
   \      0x7B0   0x9311             STR      R3,[SP, #+68]
   \      0x7B2   0x9710             STR      R7,[SP, #+64]
   \      0x7B4   0x4605             MOV      R5,R0
   \      0x7B6   0xE073             B.N      ??gcode_G29_87
   5404          
   5405                      float xBase = left_probe_bed_position + xGridSpacing * xCount,
   5406                            yBase = front_probe_bed_position + yGridSpacing * yCount;
   5407          
   5408                      xProbe = floor(xBase + (xBase < 0 ? 0 : 0.5));
   5409                      yProbe = floor(yBase + (yBase < 0 ? 0 : 0.5));
   5410          
   5411                      //#if ENABLED(AUTO_BED_LEVELING_LINEAR)
   5412          			if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_LINEAR)
   5413                        indexIntoAB[xCount][yCount] = ++abl_probe_index;
   5414                      //#endif
   5415          
   5416          			//mks_delta    begin
   5417          			/*
   5418                      #if IS_KINEMATIC
   5419                        // Avoid probing outside the round or hexagonal area
   5420                        const float pos[XYZ] = { xProbe, yProbe, 0 };
   5421                        if (!position_is_reachable(pos, true)) continue;
   5422                      #endif
   5423          			*/
   5424          			const float pos[XYZ] = { xProbe, yProbe, 0 };
   5425          			if(MACHINETPYE & IS_KINEMATIC)
   5426          				{
   5427          				if (!position_is_reachable(pos, true)) continue;
   5428          				}
   5429          			
   5430          			//mks_delta    end
   5431                    /*--mks cfg-- random*/
   5432                      //measured_z = faux ? 0.001 * random(-100, 101) : probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
   5433          	int16_t randData = rand()%200;
   5434          	if(randData > 100)	randData = 100 - randData;
   5435                  measured_z = faux ? 0.001 * randData : probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
   5436                      
   5437                      if (isnan(measured_z)) {
   5438                        planner.abl_enabled = abl_should_enable;
   5439                        return;
   5440                      }
   5441          			/*--mks cfg--begin AUTO_BED_LEVELING_BILINEAR */
   5442          /*
   5443                      #if ENABLED(AUTO_BED_LEVELING_LINEAR)
   5444          
   5445                        mean += measured_z;
   5446                        eqnBVector[abl_probe_index] = measured_z;
   5447                        eqnAMatrix[abl_probe_index + 0 * abl2] = xProbe;
   5448                        eqnAMatrix[abl_probe_index + 1 * abl2] = yProbe;
   5449                        eqnAMatrix[abl_probe_index + 2 * abl2] = 1;
   5450          
   5451                      #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
   5452          
   5453                        z_values[xCount][yCount] = measured_z + zoffset;
   5454          
   5455                      #endif
   5456          */
   5457          			if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_LINEAR)
   5458          				{
   5459          				mean += measured_z;
   5460          				/*
   5461          				eqnBVector[abl_probe_index] = measured_z;
   5462          				eqnAMatrix[abl_probe_index + 0 * abl2] = xProbe;
   5463          				eqnAMatrix[abl_probe_index + 1 * abl2] = yProbe;
   5464          				eqnAMatrix[abl_probe_index + 2 * abl2] = 1;
   5465          				*/
   5466          					*(eqnBVector+abl_probe_index) = measured_z;
   5467          					*(eqnAMatrix+abl_probe_index + 0 * abl2) = xProbe;
   5468          					*(eqnAMatrix+abl_probe_index + 1 * abl2) = yProbe;
   5469          					*(eqnAMatrix+abl_probe_index + 2 * abl2) = 1;
   5470          				
   5471          				}
   5472          			else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
   \                     ??gcode_G29_88: (+1)
   \      0x7B8   0x2808             CMP      R0,#+8
   \      0x7BA   0xD169             BNE.N    ??gcode_G29_89
   5473          				{z_values[xCount][yCount] = measured_z + zoffset;}
   \      0x7BC   0xF8DF 0x07D0      LDR.W    R0,??gcode_G29_2
   \      0x7C0   0xEB10 0x1785      ADDS     R7,R0,R5, LSL #+6
   \      0x7C4   0xF8DD 0x8048      LDR      R8,[SP, #+72]
   \      0x7C8   0x9907             LDR      R1,[SP, #+28]
   \      0x7CA   0x4650             MOV      R0,R10
   \      0x7CC   0x.... 0x....      BL       __aeabi_fadd
   \      0x7D0   0xF847 0x0028      STR      R0,[R7, R8, LSL #+2]
   \      0x7D4   0xE05C             B.N      ??gcode_G29_89
   \                     ??gcode_G29_90: (+1)
   \      0x7D6   0xF8DF 0x77E4      LDR.W    R7,??gcode_G29_2+0x2C  ;; 0x3fe00000
   \                     ??gcode_G29_91: (+1)
   \      0x7DA   0x.... 0x....      BL       __aeabi_f2d
   \      0x7DE   0x4602             MOV      R2,R0
   \      0x7E0   0x460B             MOV      R3,R1
   \      0x7E2   0x4630             MOV      R0,R6
   \      0x7E4   0x4639             MOV      R1,R7
   \      0x7E6   0x.... 0x....      BL       __aeabi_dadd
   \      0x7EA   0x.... 0x....      BL       floor
   \      0x7EE   0x.... 0x....      BL       __aeabi_d2f
   \      0x7F2   0x4606             MOV      R6,R0
   \      0x7F4   0x980D             LDR      R0,[SP, #+52]
   \      0x7F6   0x7800             LDRB     R0,[R0, #+0]
   \      0x7F8   0x2804             CMP      R0,#+4
   \      0x7FA   0xD107             BNE.N    ??gcode_G29_92
   \      0x7FC   0xF109 0x0901      ADD      R9,R9,#+1
   \      0x800   0xA82E             ADD      R0,SP,#+184
   \      0x802   0xEB00 0x1085      ADD      R0,R0,R5, LSL #+6
   \      0x806   0x9912             LDR      R1,[SP, #+72]
   \      0x808   0xF840 0x9021      STR      R9,[R0, R1, LSL #+2]
   \                     ??gcode_G29_92: (+1)
   \      0x80C   0xA816             ADD      R0,SP,#+88
   \      0x80E   0x2100             MOVS     R1,#+0
   \      0x810   0x460A             MOV      R2,R1
   \      0x812   0x460B             MOV      R3,R1
   \      0x814   0xE880 0x000E      STM      R0,{R1-R3}
   \      0x818   0xF8CD 0xB058      STR      R11,[SP, #+88]
   \      0x81C   0x9617             STR      R6,[SP, #+92]
   \      0x81E   0x980D             LDR      R0,[SP, #+52]
   \      0x820   0x8B00             LDRH     R0,[R0, #+24]
   \      0x822   0xF240 0x3102      MOVW     R1,#+770
   \      0x826   0x4208             TST      R0,R1
   \      0x828   0xD005             BEQ.N    ??gcode_G29_93
   \      0x82A   0x2101             MOVS     R1,#+1
   \      0x82C   0xA816             ADD      R0,SP,#+88
   \      0x82E   0x.... 0x....      BL       _Z21position_is_reachablePKfb
   \      0x832   0x2800             CMP      R0,#+0
   \      0x834   0xD031             BEQ.N    ??gcode_G29_94
   \                     ??gcode_G29_93: (+1)
   \      0x836   0x.... 0x....      BL       rand
   \      0x83A   0x9B0C             LDR      R3,[SP, #+48]
   \      0x83C   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \      0x840   0x4631             MOV      R1,R6
   \      0x842   0x4658             MOV      R0,R11
   \      0x844   0x.... 0x....      BL       _Z8probe_ptffbi
   \      0x848   0x.... 0x....      BL       __aeabi_f2d
   \      0x84C   0x.... 0x....      BL       __aeabi_d2f
   \      0x850   0x4682             MOV      R10,R0
   \      0x852   0x.... 0x....      BL       _Z5isnanf
   \      0x856   0x2800             CMP      R0,#+0
   \      0x858   0xF040 0x8104      BNE.W    ??gcode_G29_75
   \      0x85C   0x980D             LDR      R0,[SP, #+52]
   \      0x85E   0x7800             LDRB     R0,[R0, #+0]
   \      0x860   0x2804             CMP      R0,#+4
   \      0x862   0xD1A9             BNE.N    ??gcode_G29_88
   \      0x864   0x4620             MOV      R0,R4
   \      0x866   0x4651             MOV      R1,R10
   \      0x868   0x.... 0x....      BL       __aeabi_fadd
   \      0x86C   0x4604             MOV      R4,R0
   \      0x86E   0x9815             LDR      R0,[SP, #+84]
   \      0x870   0xF840 0xA029      STR      R10,[R0, R9, LSL #+2]
   \      0x874   0x9814             LDR      R0,[SP, #+80]
   \      0x876   0xF840 0xB029      STR      R11,[R0, R9, LSL #+2]
   \      0x87A   0x9814             LDR      R0,[SP, #+80]
   \      0x87C   0xEB00 0x0089      ADD      R0,R0,R9, LSL #+2
   \      0x880   0x990A             LDR      R1,[SP, #+40]
   \      0x882   0xF840 0x6021      STR      R6,[R0, R1, LSL #+2]
   \      0x886   0xF04F 0x517E      MOV      R1,#+1065353216
   \      0x88A   0x9A0A             LDR      R2,[SP, #+40]
   \      0x88C   0xF840 0x1032      STR      R1,[R0, R2, LSL #+3]
   5474          			/*--mks cfg--end AUTO_BED_LEVELING_BILINEAR */
   5475          
   5476                      abl_should_enable = false;
   \                     ??gcode_G29_89: (+1)
   \      0x890   0x2000             MOVS     R0,#+0
   \      0x892   0xF88D 0x0020      STRB     R0,[SP, #+32]
   5477                      idle();
   \      0x896   0x.... 0x....      BL       _Z4idleb
   \                     ??gcode_G29_94: (+1)
   \      0x89A   0x9810             LDR      R0,[SP, #+64]
   \      0x89C   0x1945             ADDS     R5,R0,R5
   \      0x89E   0xB26D             SXTB     R5,R5
   \                     ??gcode_G29_87: (+1)
   \      0x8A0   0x9811             LDR      R0,[SP, #+68]
   \      0x8A2   0x4285             CMP      R5,R0
   \      0x8A4   0xF43F 0xAF48      BEQ.W    ??gcode_G29_83
   \      0x8A8   0x9802             LDR      R0,[SP, #+8]
   \      0x8AA   0x.... 0x....      BL       __aeabi_i2f
   \      0x8AE   0x4606             MOV      R6,R0
   \      0x8B0   0x4628             MOV      R0,R5
   \      0x8B2   0x.... 0x....      BL       __aeabi_i2f
   \      0x8B6   0x4601             MOV      R1,R0
   \      0x8B8   0x9806             LDR      R0,[SP, #+24]
   \      0x8BA   0x.... 0x....      BL       __aeabi_fmul
   \      0x8BE   0x4601             MOV      R1,R0
   \      0x8C0   0x4630             MOV      R0,R6
   \      0x8C2   0x.... 0x....      BL       __aeabi_fadd
   \      0x8C6   0x4680             MOV      R8,R0
   \      0x8C8   0x9801             LDR      R0,[SP, #+4]
   \      0x8CA   0x.... 0x....      BL       __aeabi_i2f
   \      0x8CE   0x4606             MOV      R6,R0
   \      0x8D0   0xA812             ADD      R0,SP,#+72
   \      0x8D2   0x7800             LDRB     R0,[R0, #+0]
   \      0x8D4   0x.... 0x....      BL       __aeabi_ui2f
   \      0x8D8   0x4601             MOV      R1,R0
   \      0x8DA   0x9805             LDR      R0,[SP, #+20]
   \      0x8DC   0x.... 0x....      BL       __aeabi_fmul
   \      0x8E0   0x4601             MOV      R1,R0
   \      0x8E2   0x4630             MOV      R0,R6
   \      0x8E4   0x.... 0x....      BL       __aeabi_fadd
   \      0x8E8   0x900F             STR      R0,[SP, #+60]
   \      0x8EA   0x4640             MOV      R0,R8
   \      0x8EC   0x2100             MOVS     R1,#+0
   \      0x8EE   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x8F2   0x460E             MOV      R6,R1
   \      0x8F4   0xD201             BCS.N    ??gcode_G29_95
   \      0x8F6   0x460F             MOV      R7,R1
   \      0x8F8   0xE001             B.N      ??gcode_G29_96
   \                     ??gcode_G29_95: (+1)
   \      0x8FA   0xF8DF 0x76C0      LDR.W    R7,??gcode_G29_2+0x2C  ;; 0x3fe00000
   \                     ??gcode_G29_96: (+1)
   \      0x8FE   0x.... 0x....      BL       __aeabi_f2d
   \      0x902   0x4632             MOV      R2,R6
   \      0x904   0x463B             MOV      R3,R7
   \      0x906   0x.... 0x....      BL       __aeabi_dadd
   \      0x90A   0x.... 0x....      BL       floor
   \      0x90E   0x.... 0x....      BL       __aeabi_d2f
   \      0x912   0x4683             MOV      R11,R0
   \      0x914   0x980F             LDR      R0,[SP, #+60]
   \      0x916   0x4631             MOV      R1,R6
   \      0x918   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x91C   0xF4BF 0xAF5B      BCS.W    ??gcode_G29_90
   \      0x920   0x460F             MOV      R7,R1
   \      0x922   0xE75A             B.N      ??gcode_G29_91
   5478          
   5479                    } // inner
   5480                  } // outer
   5481          			}
   5482                //#elif ENABLED(AUTO_BED_LEVELING_3POINT)
   5483          		else if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_3POINT)  {
   \                     ??gcode_G29_81: (+1)
   \      0x924   0x0780             LSLS     R0,R0,#+30
   \      0x926   0xF140 0x8098      BPL.W    ??gcode_G29_84
   5484                  // Probe at 3 arbitrary points
   5485          
   5486                  for (uint8_t i = 0; i < 3; ++i) {
   \      0x92A   0x2400             MOVS     R4,#+0
   \      0x92C   0xF8DD 0xB030      LDR      R11,[SP, #+48]
   \      0x930   0x9E11             LDR      R6,[SP, #+68]
   \      0x932   0x9F10             LDR      R7,[SP, #+64]
   \      0x934   0x980F             LDR      R0,[SP, #+60]
   \      0x936   0xF88D 0x1000      STRB     R1,[SP, #+0]
   \      0x93A   0xF10D 0x096C      ADD      R9,SP,#+108
   \      0x93E   0xE023             B.N      ??gcode_G29_97
   5487                    // Retain the last probe position
   5488                    xProbe = LOGICAL_X_POSITION(points[i].x);
   \                     ??gcode_G29_98: (+1)
   \      0x940   0xEB04 0x0044      ADD      R0,R4,R4, LSL #+1
   \      0x944   0xEA4F 0x0A80      LSL      R10,R0,#+2
   \      0x948   0xF8DF 0x75A8      LDR.W    R7,??gcode_G29_1+0x4
   \      0x94C   0xA819             ADD      R0,SP,#+100
   \      0x94E   0xF850 0x100A      LDR      R1,[R0, R10]
   \      0x952   0x6C78             LDR      R0,[R7, #+68]
   \      0x954   0x.... 0x....      BL       __aeabi_fadd
   \      0x958   0x4606             MOV      R6,R0
   5489                    yProbe = LOGICAL_Y_POSITION(points[i].y);
   \      0x95A   0xA81A             ADD      R0,SP,#+104
   \      0x95C   0xF850 0x100A      LDR      R1,[R0, R10]
   \      0x960   0x6CB8             LDR      R0,[R7, #+72]
   \      0x962   0x.... 0x....      BL       __aeabi_fadd
   \      0x966   0x4607             MOV      R7,R0
   5490                    /*--mks cfg-- random*/
   5491                    //measured_z = points[i].z = faux ? 0.001 * random(-100, 101) : probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
   5492          	int16_t randData = rand()%200;
   \      0x968   0x.... 0x....      BL       rand
   5493          	if(randData > 100)	randData = 100 - randData;
   5494          	measured_z = points[i].z = faux ? 0.001 * randData : probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
   \      0x96C   0x465B             MOV      R3,R11
   \      0x96E   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \      0x972   0x4639             MOV      R1,R7
   \      0x974   0x4630             MOV      R0,R6
   \      0x976   0x.... 0x....      BL       _Z8probe_ptffbi
   \      0x97A   0x.... 0x....      BL       __aeabi_f2d
   \      0x97E   0x.... 0x....      BL       __aeabi_d2f
   \      0x982   0xF849 0x000A      STR      R0,[R9, R10]
   5495                  }
   \      0x986   0x1C64             ADDS     R4,R4,#+1
   \                     ??gcode_G29_97: (+1)
   \      0x988   0x2C03             CMP      R4,#+3
   \      0x98A   0xDBD9             BLT.N    ??gcode_G29_98
   \      0x98C   0xF8CD 0xB030      STR      R11,[SP, #+48]
   \      0x990   0x9611             STR      R6,[SP, #+68]
   \      0x992   0x9710             STR      R7,[SP, #+64]
   \      0x994   0x900F             STR      R0,[SP, #+60]
   5496          
   5497                  if (isnan(measured_z)) {
   \      0x996   0x.... 0x....      BL       _Z5isnanf
   \      0x99A   0x2800             CMP      R0,#+0
   \      0x99C   0xD162             BNE.N    ??gcode_G29_75
   5498                    planner.abl_enabled = abl_should_enable;
   5499                    return;
   5500                  }
   5501          
   5502                  if (!dryrun) {
   \      0x99E   0x980E             LDR      R0,[SP, #+56]
   \      0x9A0   0x2800             CMP      R0,#+0
   \      0x9A2   0xD15A             BNE.N    ??gcode_G29_84
   5503                    vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
   \      0x9A4   0xAC19             ADD      R4,SP,#+100
   \      0x9A6   0xF104 0x000C      ADD      R0,R4,#+12
   \      0x9AA   0xB082             SUB      SP,SP,#+8
   \      0x9AC   0x4669             MOV      R1,SP
   \      0x9AE   0xC80C             LDM      R0!,{R2,R3}
   \      0x9B0   0xC10C             STM      R1!,{R2,R3}
   \      0x9B2   0x6802             LDR      R2,[R0, #+0]
   \      0x9B4   0x600A             STR      R2,[R1, #+0]
   \      0x9B6   0xBC0C             POP      {R2,R3}
   \      0x9B8   0xA91F             ADD      R1,SP,#+124
   \      0x9BA   0xA814             ADD      R0,SP,#+80
   \      0x9BC   0x.... 0x....      BL       _ZN8vector_3miES_
   \      0x9C0   0xF104 0x000C      ADD      R0,R4,#+12
   \      0x9C4   0xB082             SUB      SP,SP,#+8
   \      0x9C6   0x4669             MOV      R1,SP
   \      0x9C8   0xC80C             LDM      R0!,{R2,R3}
   \      0x9CA   0xC10C             STM      R1!,{R2,R3}
   \      0x9CC   0x6802             LDR      R2,[R0, #+0]
   \      0x9CE   0x600A             STR      R2,[R1, #+0]
   \      0x9D0   0xBC0C             POP      {R2,R3}
   \      0x9D2   0xA919             ADD      R1,SP,#+100
   \      0x9D4   0xA805             ADD      R0,SP,#+20
   \      0x9D6   0x.... 0x....      BL       _ZN8vector_3miES_
   \      0x9DA   0xA814             ADD      R0,SP,#+80
   \      0x9DC   0x466A             MOV      R2,SP
   \      0x9DE   0xC80A             LDM      R0!,{R1,R3}
   \      0x9E0   0xC20A             STM      R2!,{R1,R3}
   \      0x9E2   0x6803             LDR      R3,[R0, #+0]
   \      0x9E4   0x6013             STR      R3,[R2, #+0]
   \      0x9E6   0xA805             ADD      R0,SP,#+20
   \      0x9E8   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0x9EC   0x.... 0x....      BL       _ZN8vector_35crossES_S_
   \      0x9F0   0xA822             ADD      R0,SP,#+136
   \      0x9F2   0xA905             ADD      R1,SP,#+20
   \      0x9F4   0xE891 0x001C      LDM      R1,{R2-R4}
   \      0x9F8   0xE880 0x001C      STM      R0,{R2-R4}
   \      0x9FC   0xA922             ADD      R1,SP,#+136
   \      0x9FE   0xA805             ADD      R0,SP,#+20
   \      0xA00   0x.... 0x....      BL       _ZN8vector_310get_normalEv
   \      0xA04   0x4668             MOV      R0,SP
   \      0xA06   0xA905             ADD      R1,SP,#+20
   \      0xA08   0xE891 0x001C      LDM      R1,{R2-R4}
   \      0xA0C   0xE880 0x001C      STM      R0,{R2-R4}
   5504                    if (planeNormal.z < 0) {
   \      0xA10   0x4620             MOV      R0,R4
   \      0xA12   0x2100             MOVS     R1,#+0
   \      0xA14   0x.... 0x....      BL       __aeabi_cfcmple
   \      0xA18   0xD210             BCS.N    ??gcode_G29_99
   5505                      planeNormal.x *= -1;
   \      0xA1A   0xF8DF 0x65A4      LDR.W    R6,??gcode_G29_2+0x30  ;; 0xbf800000
   \      0xA1E   0x4611             MOV      R1,R2
   \      0xA20   0x4630             MOV      R0,R6
   \      0xA22   0x.... 0x....      BL       __aeabi_fmul
   \      0xA26   0x9000             STR      R0,[SP, #+0]
   5506                      planeNormal.y *= -1;
   \      0xA28   0x9901             LDR      R1,[SP, #+4]
   \      0xA2A   0x4630             MOV      R0,R6
   \      0xA2C   0x.... 0x....      BL       __aeabi_fmul
   \      0xA30   0x9001             STR      R0,[SP, #+4]
   5507                      planeNormal.z *= -1;
   \      0xA32   0x4620             MOV      R0,R4
   \      0xA34   0x4631             MOV      R1,R6
   \      0xA36   0x.... 0x....      BL       __aeabi_fmul
   \      0xA3A   0x9002             STR      R0,[SP, #+8]
   5508                    }
   5509                    planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
   \                     ??gcode_G29_99: (+1)
   \      0xA3C   0x4668             MOV      R0,SP
   \      0xA3E   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0xA42   0xA825             ADD      R0,SP,#+148
   \      0xA44   0x.... 0x....      BL       _ZN10matrix_3x314create_look_atE8vector_3
   \      0xA48   0xF8DF 0x0578      LDR.W    R0,??gcode_G29_2+0x34
   \      0xA4C   0xA925             ADD      R1,SP,#+148
   \      0xA4E   0x2224             MOVS     R2,#+36
   \      0xA50   0x.... 0x....      BL       __aeabi_memcpy4
   5510          
   5511                    // Can't re-enable (on error) until the new grid is written
   5512                    abl_should_enable = false;
   \      0xA54   0x2000             MOVS     R0,#+0
   \      0xA56   0xF88D 0x0020      STRB     R0,[SP, #+32]
   5513                  }
   5514          			}
   5515                //#endif // AUTO_BED_LEVELING_3POINT
   5516          
   5517                // Raise to _Z_CLEARANCE_DEPLOY_PROBE. Stow the probe.
   5518                if (STOW_PROBE()) {
   \                     ??gcode_G29_84: (+1)
   \      0xA5A   0x2000             MOVS     R0,#+0
   \      0xA5C   0x.... 0x....      BL       _Z18set_probe_deployedb
   \      0xA60   0x2800             CMP      R0,#+0
   \      0xA62   0xD004             BEQ.N    ??gcode_G29_100
   5519                  planner.abl_enabled = abl_should_enable;
   \                     ??gcode_G29_75: (+1)
   \      0xA64   0xF89D 0x0020      LDRB     R0,[SP, #+32]
   \      0xA68   0x49C4             LDR.N    R1,??gcode_G29_0+0x10
   \      0xA6A   0x7008             STRB     R0,[R1, #+0]
   5520                  return;
   \      0xA6C   0xE26F             B.N      ??gcode_G29_3
   5521                }
   5522          
   5523              #endif // !PROBE_MANUALLY
   5524          
   5525              //
   5526              // G29 Finishing Code
   5527              //
   5528              // Unless this is a dry run, auto bed leveling will
   5529              // definitely be enabled after this point
   5530              //
   5531          
   5532              // Restore state after probing
   5533              if (!faux) clean_up_after_endstop_or_probe_move();
   \                     ??gcode_G29_100: (+1)
   \      0xA6E   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531936clean_up_after_endstop_or_probe_moveEv
   5534          
   5535              #if ENABLED(DEBUG_LEVELING_FEATURE)
   5536                if (DEBUGGING(LEVELING)) DEBUG_POS("> probing complete", current_position);
   5537              #endif
   5538          
   5539              // Calculate leveling, print reports, correct the position
   5540          /*--mks cfg--begin AUTO_BED_LEVELING_BILINEAR */    
   5541          /*    #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
   5542          
   5543                if (!dryrun) extrapolate_unprobed_bed_level();
   5544                print_bilinear_leveling_grid();
   5545          
   5546                refresh_bed_level();
   5547          
   5548                #if ENABLED(ABL_BILINEAR_SUBDIVISION)
   5549                  bed_level_virt_print();
   5550                #endif
   5551          
   5552              #elif ENABLED(AUTO_BED_LEVELING_LINEAR)
   5553          
   5554                // For LINEAR leveling calculate matrix, print reports, correct the position
   5555          
   5556                float plane_equation_coefficients[3];
   5557                qr_solve(plane_equation_coefficients, abl2, 3, eqnAMatrix, eqnBVector);
   5558          
   5559                mean /= abl2;
   5560          
   5561                if (verbose_level) {
   5562                  SERIAL_PROTOCOLPGM("Eqn coefficients: a: ");
   5563                  SERIAL_PROTOCOL_F(plane_equation_coefficients[0], 8);
   5564                  SERIAL_PROTOCOLPGM(" b: ");
   5565                  SERIAL_PROTOCOL_F(plane_equation_coefficients[1], 8);
   5566                  SERIAL_PROTOCOLPGM(" d: ");
   5567                  SERIAL_PROTOCOL_F(plane_equation_coefficients[2], 8);
   5568                  SERIAL_EOL;
   5569                  if (verbose_level > 2) {
   5570                    SERIAL_PROTOCOLPGM("Mean of sampled points: ");
   5571                    SERIAL_PROTOCOL_F(mean, 8);
   5572                    SERIAL_EOL;
   5573                  }
   5574                }
   5575          
   5576                // Create the matrix but don't correct the position yet
   5577                if (!dryrun) {
   5578                  planner.bed_level_matrix = matrix_3x3::create_look_at(
   5579                    vector_3(-plane_equation_coefficients[0], -plane_equation_coefficients[1], 1)
   5580                  );
   5581                }
   5582          
   5583                // Show the Topography map if enabled
   5584                if (do_topography_map) {
   5585          
   5586                  SERIAL_PROTOCOLLNPGM("\nBed Height Topography:\n"
   5587                                         "   +--- BACK --+\n"
   5588                                         "   |           |\n"
   5589                                         " L |    (+)    | R\n"
   5590                                         " E |           | I\n"
   5591                                         " F | (-) N (+) | G\n"
   5592                                         " T |           | H\n"
   5593                                         "   |    (-)    | T\n"
   5594                                         "   |           |\n"
   5595                                         "   O-- FRONT --+\n"
   5596                                         " (0,0)");
   5597          
   5598                  float min_diff = 999;
   5599          
   5600                  for (int8_t yy = abl_grid_points_y - 1; yy >= 0; yy--) {
   5601                    for (uint8_t xx = 0; xx < abl_grid_points_x; xx++) {
   5602                      int ind = indexIntoAB[xx][yy];
   5603                      float diff = eqnBVector[ind] - mean,
   5604                            x_tmp = eqnAMatrix[ind + 0 * abl2],
   5605                            y_tmp = eqnAMatrix[ind + 1 * abl2],
   5606                            z_tmp = 0;
   5607          
   5608                      apply_rotation_xyz(planner.bed_level_matrix, x_tmp, y_tmp, z_tmp);
   5609          
   5610                      NOMORE(min_diff, eqnBVector[ind] - z_tmp);
   5611          
   5612                      if (diff >= 0.0)
   5613                        SERIAL_PROTOCOLPGM(" +");   // Include + for column alignment
   5614                      else
   5615                        SERIAL_PROTOCOLCHAR(' ');
   5616                      SERIAL_PROTOCOL_F(diff, 5);
   5617                    } // xx
   5618                    SERIAL_EOL;
   5619                  } // yy
   5620                  SERIAL_EOL;
   5621          
   5622                  if (verbose_level > 3) {
   5623                    SERIAL_PROTOCOLLNPGM("\nCorrected Bed Height vs. Bed Topology:");
   5624          
   5625                    for (int8_t yy = abl_grid_points_y - 1; yy >= 0; yy--) {
   5626                      for (uint8_t xx = 0; xx < abl_grid_points_x; xx++) {
   5627                        int ind = indexIntoAB[xx][yy];
   5628                        float x_tmp = eqnAMatrix[ind + 0 * abl2],
   5629                              y_tmp = eqnAMatrix[ind + 1 * abl2],
   5630                              z_tmp = 0;
   5631          
   5632                        apply_rotation_xyz(planner.bed_level_matrix, x_tmp, y_tmp, z_tmp);
   5633          
   5634                        float diff = eqnBVector[ind] - z_tmp - min_diff;
   5635                        if (diff >= 0.0)
   5636                          SERIAL_PROTOCOLPGM(" +");
   5637                        // Include + for column alignment
   5638                        else
   5639                          SERIAL_PROTOCOLCHAR(' ');
   5640                        SERIAL_PROTOCOL_F(diff, 5);
   5641                      } // xx
   5642                      SERIAL_EOL;
   5643                    } // yy
   5644                    SERIAL_EOL;
   5645                  }
   5646                } //do_topography_map
   5647          
   5648              #endif // AUTO_BED_LEVELING_LINEAR
   5649          */
   5650          
   5651          		 // #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
   5652          	if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)  {
   \      0xA72   0x980D             LDR      R0,[SP, #+52]
   \      0xA74   0x7800             LDRB     R0,[R0, #+0]
   \      0xA76   0x2808             CMP      R0,#+8
   \      0xA78   0xD109             BNE.N    ??gcode_G29_101
   5653          		  if (!dryrun) extrapolate_unprobed_bed_level();
   \      0xA7A   0x980E             LDR      R0,[SP, #+56]
   \      0xA7C   0x2800             CMP      R0,#+0
   \      0xA7E   0xD101             BNE.N    ??gcode_G29_102
   \      0xA80   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531930extrapolate_unprobed_bed_levelEv
   5654          		  print_bilinear_leveling_grid();
   \                     ??gcode_G29_102: (+1)
   \      0xA84   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531928print_bilinear_leveling_gridEv
   5655          	
   5656          		  refresh_bed_level();
   \      0xA88   0x.... 0x....      BL       _Z17refresh_bed_levelv
   \      0xA8C   0xE1E3             B.N      ??gcode_G29_103
   5657          	
   5658                #if ENABLED(ABL_BILINEAR_SUBDIVISION)
   5659          			bed_level_virt_print();
   5660                #endif
   5661          		}
   5662              //#elif ENABLED(AUTO_BED_LEVELING_LINEAR)
   5663          		else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_LINEAR)  {
   \                     ??gcode_G29_101: (+1)
   \      0xA8E   0x2804             CMP      R0,#+4
   \      0xA90   0xF040 0x81E1      BNE.W    ??gcode_G29_103
   5664          		  // For LINEAR leveling calculate matrix, print reports, correct the position
   5665          	
   5666          		  float plane_equation_coefficients[3];
   5667          
   5668          		  qr_solve(plane_equation_coefficients, abl2, 3, eqnAMatrix, eqnBVector);
   \      0xA94   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \      0xA98   0x462B             MOV      R3,R5
   \      0xA9A   0x2203             MOVS     R2,#+3
   \      0xA9C   0x990A             LDR      R1,[SP, #+40]
   \      0xA9E   0xA814             ADD      R0,SP,#+80
   \      0xAA0   0x.... 0x....      BL       _Z8qr_solvePfiiS_S_
   5669          	
   5670          		  mean /= abl2;
   \      0xAA4   0x980A             LDR      R0,[SP, #+40]
   \      0xAA6   0x.... 0x....      BL       __aeabi_i2f
   \      0xAAA   0x4601             MOV      R1,R0
   \      0xAAC   0x9813             LDR      R0,[SP, #+76]
   \      0xAAE   0x.... 0x....      BL       __aeabi_fdiv
   \      0xAB2   0x4683             MOV      R11,R0
   5671          	
   5672          		  if (verbose_level) {
   \      0xAB4   0xAC14             ADD      R4,SP,#+80
   \      0xAB6   0x980C             LDR      R0,[SP, #+48]
   \      0xAB8   0x2800             CMP      R0,#+0
   \      0xABA   0xF000 0x8087      BEQ.W    ??gcode_G29_104
   5673          			SERIAL_PROTOCOLPGM("Eqn coefficients: a: ");
   \      0xABE   0xF8DF 0x0508      LDR.W    R0,??gcode_G29_2+0x38
   \      0xAC2   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5674          			SERIAL_PROTOCOL_F(plane_equation_coefficients[0], 8);
   \      0xAC6   0x9814             LDR      R0,[SP, #+80]
   \      0xAC8   0x.... 0x....      BL       __aeabi_f2d
   \      0xACC   0x4602             MOV      R2,R0
   \      0xACE   0x460B             MOV      R3,R1
   \      0xAD0   0xF8DF 0x6420      LDR.W    R6,??gcode_G29_1+0x4
   \      0xAD4   0x79F0             LDRB     R0,[R6, #+7]
   \      0xAD6   0x2800             CMP      R0,#+0
   \      0xAD8   0xD106             BNE.N    ??gcode_G29_105
   \      0xADA   0x2008             MOVS     R0,#+8
   \      0xADC   0x9000             STR      R0,[SP, #+0]
   \      0xADE   0xF8DF 0x04EC      LDR.W    R0,??gcode_G29_2+0x3C
   \      0xAE2   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   \      0xAE6   0xE005             B.N      ??gcode_G29_106
   \                     ??gcode_G29_105: (+1)
   \      0xAE8   0x2008             MOVS     R0,#+8
   \      0xAEA   0x9000             STR      R0,[SP, #+0]
   \      0xAEC   0xF8DF 0x04E0      LDR.W    R0,??gcode_G29_2+0x40
   \      0xAF0   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   5675          			SERIAL_PROTOCOLPGM(" b: ");
   \                     ??gcode_G29_106: (+1)
   \      0xAF4   0xF8DF 0x04DC      LDR.W    R0,??gcode_G29_2+0x44
   \      0xAF8   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5676          			SERIAL_PROTOCOL_F(plane_equation_coefficients[1], 8);
   \      0xAFC   0x6860             LDR      R0,[R4, #+4]
   \      0xAFE   0x.... 0x....      BL       __aeabi_f2d
   \      0xB02   0x4602             MOV      R2,R0
   \      0xB04   0x460B             MOV      R3,R1
   \      0xB06   0x79F0             LDRB     R0,[R6, #+7]
   \      0xB08   0x2800             CMP      R0,#+0
   \      0xB0A   0xD106             BNE.N    ??gcode_G29_107
   \      0xB0C   0x2008             MOVS     R0,#+8
   \      0xB0E   0x9000             STR      R0,[SP, #+0]
   \      0xB10   0xF8DF 0x04B8      LDR.W    R0,??gcode_G29_2+0x3C
   \      0xB14   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   \      0xB18   0xE005             B.N      ??gcode_G29_108
   \                     ??gcode_G29_107: (+1)
   \      0xB1A   0x2008             MOVS     R0,#+8
   \      0xB1C   0x9000             STR      R0,[SP, #+0]
   \      0xB1E   0xF8DF 0x04B0      LDR.W    R0,??gcode_G29_2+0x40
   \      0xB22   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   5677          			SERIAL_PROTOCOLPGM(" d: ");
   \                     ??gcode_G29_108: (+1)
   \      0xB26   0xF8DF 0x04B0      LDR.W    R0,??gcode_G29_2+0x48
   \      0xB2A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5678          			SERIAL_PROTOCOL_F(plane_equation_coefficients[2], 8);
   \      0xB2E   0x68A0             LDR      R0,[R4, #+8]
   \      0xB30   0x.... 0x....      BL       __aeabi_f2d
   \      0xB34   0x4602             MOV      R2,R0
   \      0xB36   0x460B             MOV      R3,R1
   \      0xB38   0x79F0             LDRB     R0,[R6, #+7]
   \      0xB3A   0x2800             CMP      R0,#+0
   \      0xB3C   0xD106             BNE.N    ??gcode_G29_109
   \      0xB3E   0x2008             MOVS     R0,#+8
   \      0xB40   0x9000             STR      R0,[SP, #+0]
   \      0xB42   0xF8DF 0x0488      LDR.W    R0,??gcode_G29_2+0x3C
   \      0xB46   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   \      0xB4A   0xE005             B.N      ??gcode_G29_110
   \                     ??gcode_G29_109: (+1)
   \      0xB4C   0x2008             MOVS     R0,#+8
   \      0xB4E   0x9000             STR      R0,[SP, #+0]
   \      0xB50   0xF8DF 0x047C      LDR.W    R0,??gcode_G29_2+0x40
   \      0xB54   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   5679          			SERIAL_EOL;
   \                     ??gcode_G29_110: (+1)
   \      0xB58   0x79F0             LDRB     R0,[R6, #+7]
   \      0xB5A   0x2800             CMP      R0,#+0
   \      0xB5C   0xD105             BNE.N    ??gcode_G29_111
   \      0xB5E   0x210A             MOVS     R1,#+10
   \      0xB60   0xF8DF 0x0468      LDR.W    R0,??gcode_G29_2+0x3C
   \      0xB64   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \      0xB68   0xE005             B.N      ??gcode_G29_112
   \                     ??gcode_G29_111: (+1)
   \      0xB6A   0x2200             MOVS     R2,#+0
   \      0xB6C   0x210A             MOVS     R1,#+10
   \      0xB6E   0xF8DF 0x0460      LDR.W    R0,??gcode_G29_2+0x40
   \      0xB72   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   5680          			if (verbose_level > 2) {
   \                     ??gcode_G29_112: (+1)
   \      0xB76   0x980C             LDR      R0,[SP, #+48]
   \      0xB78   0x2803             CMP      R0,#+3
   \      0xB7A   0xDB27             BLT.N    ??gcode_G29_104
   5681          			  SERIAL_PROTOCOLPGM("Mean of sampled points: ");
   \      0xB7C   0xF8DF 0x045C      LDR.W    R0,??gcode_G29_2+0x4C
   \      0xB80   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5682          			  SERIAL_PROTOCOL_F(mean, 8);
   \      0xB84   0x4658             MOV      R0,R11
   \      0xB86   0x.... 0x....      BL       __aeabi_f2d
   \      0xB8A   0x4602             MOV      R2,R0
   \      0xB8C   0x460B             MOV      R3,R1
   \      0xB8E   0x79F0             LDRB     R0,[R6, #+7]
   \      0xB90   0x2800             CMP      R0,#+0
   \      0xB92   0xD106             BNE.N    ??gcode_G29_113
   \      0xB94   0x2008             MOVS     R0,#+8
   \      0xB96   0x9000             STR      R0,[SP, #+0]
   \      0xB98   0xF8DF 0x0430      LDR.W    R0,??gcode_G29_2+0x3C
   \      0xB9C   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   \      0xBA0   0xE005             B.N      ??gcode_G29_114
   \                     ??gcode_G29_113: (+1)
   \      0xBA2   0x2008             MOVS     R0,#+8
   \      0xBA4   0x9000             STR      R0,[SP, #+0]
   \      0xBA6   0xF8DF 0x0428      LDR.W    R0,??gcode_G29_2+0x40
   \      0xBAA   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   5683          			  SERIAL_EOL;
   \                     ??gcode_G29_114: (+1)
   \      0xBAE   0x79F0             LDRB     R0,[R6, #+7]
   \      0xBB0   0x2800             CMP      R0,#+0
   \      0xBB2   0xD105             BNE.N    ??gcode_G29_115
   \      0xBB4   0x210A             MOVS     R1,#+10
   \      0xBB6   0xF8DF 0x0414      LDR.W    R0,??gcode_G29_2+0x3C
   \      0xBBA   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \      0xBBE   0xE005             B.N      ??gcode_G29_104
   \                     ??gcode_G29_115: (+1)
   \      0xBC0   0x2200             MOVS     R2,#+0
   \      0xBC2   0x210A             MOVS     R1,#+10
   \      0xBC4   0xF8DF 0x0408      LDR.W    R0,??gcode_G29_2+0x40
   \      0xBC8   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   5684          			}
   5685          		  }
   5686          	
   5687          		  // Create the matrix but don't correct the position yet
   5688          		  if (!dryrun) {
   \                     ??gcode_G29_104: (+1)
   \      0xBCC   0x980E             LDR      R0,[SP, #+56]
   \      0xBCE   0x2800             CMP      R0,#+0
   \      0xBD0   0xD116             BNE.N    ??gcode_G29_116
   5689          			planner.bed_level_matrix = matrix_3x3::create_look_at(
   5690          			  vector_3(-plane_equation_coefficients[0], -plane_equation_coefficients[1], 1)
   5691          			);
   \      0xBD2   0xF04F 0x537E      MOV      R3,#+1065353216
   \      0xBD6   0x6862             LDR      R2,[R4, #+4]
   \      0xBD8   0xF082 0x4200      EOR      R2,R2,#0x80000000
   \      0xBDC   0x9914             LDR      R1,[SP, #+80]
   \      0xBDE   0xF081 0x4100      EOR      R1,R1,#0x80000000
   \      0xBE2   0x4668             MOV      R0,SP
   \      0xBE4   0x.... 0x....      BL       _ZN8vector_3C1Efff
   \      0xBE8   0x4668             MOV      R0,SP
   \      0xBEA   0xE890 0x000E      LDM      R0,{R1-R3}
   \      0xBEE   0xA822             ADD      R0,SP,#+136
   \      0xBF0   0x.... 0x....      BL       _ZN10matrix_3x314create_look_atE8vector_3
   \      0xBF4   0xF8DF 0x03CC      LDR.W    R0,??gcode_G29_2+0x34
   \      0xBF8   0xA922             ADD      R1,SP,#+136
   \      0xBFA   0x2224             MOVS     R2,#+36
   \      0xBFC   0x.... 0x....      BL       __aeabi_memcpy4
   5692          		  }
   5693          	
   5694          		  // Show the Topography map if enabled
   5695          		  if (do_topography_map) {
   \                     ??gcode_G29_116: (+1)
   \      0xC00   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \      0xC04   0x2800             CMP      R0,#+0
   \      0xC06   0xF000 0x8126      BEQ.W    ??gcode_G29_103
   5696          	
   5697          			SERIAL_PROTOCOLLNPGM("\nBed Height Topography:\n"
   5698          								   "   +--- BACK --+\n"
   5699          								   "   |		   |\n"
   5700          								   " L |	(+)    | R\n"
   5701          								   " E |		   | I\n"
   5702          								   " F | (-) N (+) | G\n"
   5703          								   " T |		   | H\n"
   5704          								   "   |	(-)    | T\n"
   5705          								   "   |		   |\n"
   5706          								   "   O-- FRONT --+\n"
   5707          								   " (0,0)");
   \      0xC0A   0xF8DF 0x03D4      LDR.W    R0,??gcode_G29_2+0x50
   \      0xC0E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5708          	
   5709          			float min_diff = 999;
   \      0xC12   0xF8DF 0x43D0      LDR.W    R4,??gcode_G29_2+0x54  ;; 0x4479c000
   5710          	
   5711          			for (int8_t yy = abl_grid_points_y - 1; yy >= 0; yy--) {
   \      0xC16   0x9804             LDR      R0,[SP, #+16]
   \      0xC18   0x1E40             SUBS     R0,R0,#+1
   \      0xC1A   0xB240             SXTB     R0,R0
   \      0xC1C   0x9018             STR      R0,[SP, #+96]
   \      0xC1E   0xF8DD 0xA060      LDR      R10,[SP, #+96]
   \      0xC22   0xE014             B.N      ??gcode_G29_117
   5712          			  for (uint8_t xx = 0; xx < abl_grid_points_x; xx++) {
   5713          				int ind = indexIntoAB[xx][yy];
   5714          /*				
   5715          				float diff = eqnBVector[ind] - mean,
   5716          					  x_tmp = eqnAMatrix[ind + 0 * abl2],
   5717          					  y_tmp = eqnAMatrix[ind + 1 * abl2],
   5718          					  z_tmp = 0;
   5719          */
   5720          	float diff = *(eqnBVector+ind) - mean,
   5721          		  x_tmp = *(eqnAMatrix+ind + 0 * abl2),
   5722          		  y_tmp = *(eqnAMatrix+ind + 1 * abl2),
   5723          		  z_tmp = 0;
   5724          				
   5725          				apply_rotation_xyz(planner.bed_level_matrix, x_tmp, y_tmp, z_tmp);
   5726          	
   5727          				//NOMORE(min_diff, eqnBVector[ind] - z_tmp);
   5728          				NOMORE(min_diff, *(eqnBVector+ind) - z_tmp);
   5729          				if (diff >= 0.0)
   5730          				  {SERIAL_PROTOCOLPGM(" +");}   // Include + for column alignment
   5731          				else
   5732                          		{ SERIAL_PROTOCOLCHAR(' ');}
   5733          				SERIAL_PROTOCOL_F(diff, 5);
   5734          			  } // xx
   5735          			  SERIAL_EOL;
   \                     ??gcode_G29_118: (+1)
   \      0xC24   0x2200             MOVS     R2,#+0
   \      0xC26   0x210A             MOVS     R1,#+10
   \      0xC28   0xF8DF 0x03A4      LDR.W    R0,??gcode_G29_2+0x40
   \      0xC2C   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   \      0xC30   0xE009             B.N      ??gcode_G29_119
   \                     ??gcode_G29_120: (+1)
   \      0xC32   0x464D             MOV      R5,R9
   \      0xC34   0x48AF             LDR.N    R0,??gcode_G29_1+0x4
   \      0xC36   0x79C0             LDRB     R0,[R0, #+7]
   \      0xC38   0x2800             CMP      R0,#+0
   \      0xC3A   0xD1F3             BNE.N    ??gcode_G29_118
   \      0xC3C   0x210A             MOVS     R1,#+10
   \      0xC3E   0xF8DF 0x038C      LDR.W    R0,??gcode_G29_2+0x3C
   \      0xC42   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \                     ??gcode_G29_119: (+1)
   \      0xC46   0xF1AA 0x0A01      SUB      R10,R10,#+1
   \      0xC4A   0xFA4F 0xFA8A      SXTB     R10,R10
   \                     ??gcode_G29_117: (+1)
   \      0xC4E   0xF1BA 0x0F00      CMP      R10,#+0
   \      0xC52   0xD466             BMI.N    ??gcode_G29_121
   \      0xC54   0x2000             MOVS     R0,#+0
   \      0xC56   0x46A9             MOV      R9,R5
   \      0xC58   0x4605             MOV      R5,R0
   \      0xC5A   0xE01C             B.N      ??gcode_G29_122
   \                     ??gcode_G29_123: (+1)
   \      0xC5C   0x2005             MOVS     R0,#+5
   \      0xC5E   0x9000             STR      R0,[SP, #+0]
   \      0xC60   0xF8DF 0x036C      LDR.W    R0,??gcode_G29_2+0x40
   \      0xC64   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   \      0xC68   0xE014             B.N      ??gcode_G29_124
   \                     ??gcode_G29_125: (+1)
   \      0xC6A   0x460A             MOV      R2,R1
   \      0xC6C   0x2120             MOVS     R1,#+32
   \      0xC6E   0xF8DF 0x0360      LDR.W    R0,??gcode_G29_2+0x40
   \      0xC72   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   \                     ??gcode_G29_126: (+1)
   \      0xC76   0x4630             MOV      R0,R6
   \      0xC78   0x.... 0x....      BL       __aeabi_f2d
   \      0xC7C   0x4602             MOV      R2,R0
   \      0xC7E   0x460B             MOV      R3,R1
   \      0xC80   0x489C             LDR.N    R0,??gcode_G29_1+0x4
   \      0xC82   0x79C0             LDRB     R0,[R0, #+7]
   \      0xC84   0x2800             CMP      R0,#+0
   \      0xC86   0xD1E9             BNE.N    ??gcode_G29_123
   \      0xC88   0x2005             MOVS     R0,#+5
   \      0xC8A   0x9000             STR      R0,[SP, #+0]
   \      0xC8C   0xF8DF 0x033C      LDR.W    R0,??gcode_G29_2+0x3C
   \      0xC90   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   \                     ??gcode_G29_124: (+1)
   \      0xC94   0x1C6D             ADDS     R5,R5,#+1
   \                     ??gcode_G29_122: (+1)
   \      0xC96   0x4628             MOV      R0,R5
   \      0xC98   0xB2C0             UXTB     R0,R0
   \      0xC9A   0x990B             LDR      R1,[SP, #+44]
   \      0xC9C   0x4288             CMP      R0,R1
   \      0xC9E   0xDAC8             BGE.N    ??gcode_G29_120
   \      0xCA0   0xA92E             ADD      R1,SP,#+184
   \      0xCA2   0xEB01 0x1080      ADD      R0,R1,R0, LSL #+6
   \      0xCA6   0xF850 0x702A      LDR      R7,[R0, R10, LSL #+2]
   \      0xCAA   0xF858 0x0027      LDR      R0,[R8, R7, LSL #+2]
   \      0xCAE   0x4659             MOV      R1,R11
   \      0xCB0   0x.... 0x....      BL       __aeabi_fsub
   \      0xCB4   0x4606             MOV      R6,R0
   \      0xCB6   0xF859 0x0027      LDR      R0,[R9, R7, LSL #+2]
   \      0xCBA   0x9017             STR      R0,[SP, #+92]
   \      0xCBC   0xEB09 0x0087      ADD      R0,R9,R7, LSL #+2
   \      0xCC0   0x990A             LDR      R1,[SP, #+40]
   \      0xCC2   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \      0xCC6   0x9013             STR      R0,[SP, #+76]
   \      0xCC8   0x2000             MOVS     R0,#+0
   \      0xCCA   0x9012             STR      R0,[SP, #+72]
   \      0xCCC   0xA812             ADD      R0,SP,#+72
   \      0xCCE   0x9007             STR      R0,[SP, #+28]
   \      0xCD0   0xA813             ADD      R0,SP,#+76
   \      0xCD2   0x9006             STR      R0,[SP, #+24]
   \      0xCD4   0xA817             ADD      R0,SP,#+92
   \      0xCD6   0x9005             STR      R0,[SP, #+20]
   \      0xCD8   0x49BA             LDR.N    R1,??gcode_G29_2+0x34
   \      0xCDA   0xB084             SUB      SP,SP,#+16
   \      0xCDC   0x4668             MOV      R0,SP
   \      0xCDE   0x2224             MOVS     R2,#+36
   \      0xCE0   0x.... 0x....      BL       __aeabi_memcpy4
   \      0xCE4   0xBC0F             POP      {R0-R3}
   \      0xCE6   0x.... 0x....      BL       _Z18apply_rotation_xyz10matrix_3x3RfS0_S0_
   \      0xCEA   0xF858 0x0027      LDR      R0,[R8, R7, LSL #+2]
   \      0xCEE   0x9912             LDR      R1,[SP, #+72]
   \      0xCF0   0x.... 0x....      BL       __aeabi_fsub
   \      0xCF4   0x4621             MOV      R1,R4
   \      0xCF6   0x.... 0x....      BL       __aeabi_cfcmple
   \      0xCFA   0xD200             BCS.N    ??gcode_G29_127
   \      0xCFC   0x4604             MOV      R4,R0
   \                     ??gcode_G29_127: (+1)
   \      0xCFE   0x4630             MOV      R0,R6
   \      0xD00   0x2100             MOVS     R1,#+0
   \      0xD02   0x.... 0x....      BL       __aeabi_cfrcmple
   \      0xD06   0xD803             BHI.N    ??gcode_G29_128
   \      0xD08   0x48B7             LDR.N    R0,??gcode_G29_2+0x58
   \      0xD0A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \      0xD0E   0xE7B2             B.N      ??gcode_G29_126
   \                     ??gcode_G29_128: (+1)
   \      0xD10   0x4878             LDR.N    R0,??gcode_G29_1+0x4
   \      0xD12   0x79C0             LDRB     R0,[R0, #+7]
   \      0xD14   0x2800             CMP      R0,#+0
   \      0xD16   0xD1A8             BNE.N    ??gcode_G29_125
   \      0xD18   0x2120             MOVS     R1,#+32
   \      0xD1A   0x48AC             LDR.N    R0,??gcode_G29_2+0x3C
   \      0xD1C   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \      0xD20   0xE7A9             B.N      ??gcode_G29_126
   5736          			} // yy
   5737          			SERIAL_EOL;
   \                     ??gcode_G29_121: (+1)
   \      0xD22   0x4874             LDR.N    R0,??gcode_G29_1+0x4
   \      0xD24   0x79C0             LDRB     R0,[R0, #+7]
   \      0xD26   0x2800             CMP      R0,#+0
   \      0xD28   0xD104             BNE.N    ??gcode_G29_129
   \      0xD2A   0x210A             MOVS     R1,#+10
   \      0xD2C   0x48A7             LDR.N    R0,??gcode_G29_2+0x3C
   \      0xD2E   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \      0xD32   0xE004             B.N      ??gcode_G29_130
   \                     ??gcode_G29_129: (+1)
   \      0xD34   0x2200             MOVS     R2,#+0
   \      0xD36   0x210A             MOVS     R1,#+10
   \      0xD38   0x48A5             LDR.N    R0,??gcode_G29_2+0x40
   \      0xD3A   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   5738          	
   5739          			if (verbose_level > 3) {
   \                     ??gcode_G29_130: (+1)
   \      0xD3E   0x980C             LDR      R0,[SP, #+48]
   \      0xD40   0x2804             CMP      R0,#+4
   \      0xD42   0xF2C0 0x8088      BLT.W    ??gcode_G29_103
   5740          			  SERIAL_PROTOCOLLNPGM("\nCorrected Bed Height vs. Bed Topology:");
   \      0xD46   0x48A9             LDR.N    R0,??gcode_G29_2+0x5C
   \      0xD48   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5741          	
   5742          			  for (int8_t yy = abl_grid_points_y - 1; yy >= 0; yy--) {
   \      0xD4C   0x9F18             LDR      R7,[SP, #+96]
   \      0xD4E   0xE113             B.N      ??gcode_G29_131
   5743          				for (uint8_t xx = 0; xx < abl_grid_points_x; xx++) {
   5744          				  int ind = indexIntoAB[xx][yy];
   5745          /*				  
   5746          				  float x_tmp = eqnAMatrix[ind + 0 * abl2],
   5747          						y_tmp = eqnAMatrix[ind + 1 * abl2],
   5748          						z_tmp = 0;
   5749          */
   5750          	float x_tmp = *(eqnAMatrix+ind + 0 * abl2),
   5751          		  y_tmp = *(eqnAMatrix+ind + 1 * abl2),
   5752          		  z_tmp = 0;
   5753          
   5754          
   5755          				  apply_rotation_xyz(planner.bed_level_matrix, x_tmp, y_tmp, z_tmp);
   5756          	
   5757          				  //float diff = eqnBVector[ind] - z_tmp - min_diff;
   5758          				  float diff = *(eqnBVector+ind) - z_tmp - min_diff;
   5759          				  if (diff >= 0.0)
   5760          				 {SERIAL_PROTOCOLPGM(" +");}
   5761          				  // Include + for column alignment
   5762          				  else
   5763                           		 {SERIAL_PROTOCOLCHAR(' ');}
   5764          				  SERIAL_PROTOCOL_F(diff, 5);
   5765          				} // xx
   5766          				SERIAL_EOL;
   \                     ??gcode_G29_132: (+1)
   \      0xD50   0x2200             MOVS     R2,#+0
   \      0xD52   0x210A             MOVS     R1,#+10
   \      0xD54   0x489E             LDR.N    R0,??gcode_G29_2+0x40
   \      0xD56   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   \      0xD5A   0xE10B             B.N      ??gcode_G29_133
   \                     ??gcode_G29_134: (+1)
   \      0xD5C   0x2205             MOVS     R2,#+5
   \      0xD5E   0x9200             STR      R2,[SP, #+0]
   \      0xD60   0x4602             MOV      R2,R0
   \      0xD62   0x460B             MOV      R3,R1
   \      0xD64   0x489A             LDR.N    R0,??gcode_G29_2+0x40
   \      0xD66   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   \      0xD6A   0xE028             B.N      ??gcode_G29_135
   \                     ??gcode_G29_0:
   \      0xD6C   0x....'....        DC32     mksCfg
   \      0xD70   0x....'....        DC32     Running
   \      0xD74   0x....'....        DC32     _ZZ9gcode_G29vEs
   \      0xD78   0x....'....        DC32     _ZZ9gcode_G29vEs_0
   \      0xD7C   0x....'....        DC32     _ZN7Planner11abl_enabledE
   \      0xD80   0x....'....        DC32     errormagic
   \      0xD84   0x....'....        DC32     _ZZ9gcode_G29vEs_1
   \      0xD88   0x47C3'4F80        DC32     0x47c34f80
   \      0xD8C   0xC120'0000        DC32     0xc1200000
   \      0xD90   0x4120'0001        DC32     0x41200001
   \      0xD94   0x....'....        DC32     _ZZ9gcode_G29vEs_2
   \                     ??gcode_G29_136: (+1)
   \      0xD98   0x460A             MOV      R2,R1
   \      0xD9A   0x2120             MOVS     R1,#+32
   \      0xD9C   0x488C             LDR.N    R0,??gcode_G29_2+0x40
   \      0xD9E   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   \                     ??gcode_G29_137: (+1)
   \      0xDA2   0x4630             MOV      R0,R6
   \      0xDA4   0x.... 0x....      BL       __aeabi_f2d
   \      0xDA8   0x4A52             LDR.N    R2,??gcode_G29_1+0x4
   \      0xDAA   0x79D2             LDRB     R2,[R2, #+7]
   \      0xDAC   0x2A00             CMP      R2,#+0
   \      0xDAE   0xD1D5             BNE.N    ??gcode_G29_134
   \      0xDB0   0x2205             MOVS     R2,#+5
   \      0xDB2   0x9200             STR      R2,[SP, #+0]
   \      0xDB4   0x4602             MOV      R2,R0
   \      0xDB6   0x460B             MOV      R3,R1
   \      0xDB8   0x4884             LDR.N    R0,??gcode_G29_2+0x3C
   \      0xDBA   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   \                     ??gcode_G29_135: (+1)
   \      0xDBE   0x1C64             ADDS     R4,R4,#+1
   \                     ??gcode_G29_138: (+1)
   \      0xDC0   0x4620             MOV      R0,R4
   \      0xDC2   0xB2C0             UXTB     R0,R0
   \      0xDC4   0x4558             CMP      R0,R11
   \      0xDC6   0xF280 0x80C7      BGE.W    ??gcode_G29_139
   \      0xDCA   0xA92E             ADD      R1,SP,#+184
   \      0xDCC   0xEB01 0x1080      ADD      R0,R1,R0, LSL #+6
   \      0xDD0   0xF850 0x6027      LDR      R6,[R0, R7, LSL #+2]
   \      0xDD4   0xF855 0x0026      LDR      R0,[R5, R6, LSL #+2]
   \      0xDD8   0x9012             STR      R0,[SP, #+72]
   \      0xDDA   0xEB05 0x0086      ADD      R0,R5,R6, LSL #+2
   \      0xDDE   0xF850 0x002A      LDR      R0,[R0, R10, LSL #+2]
   \      0xDE2   0x900B             STR      R0,[SP, #+44]
   \      0xDE4   0x2000             MOVS     R0,#+0
   \      0xDE6   0x900A             STR      R0,[SP, #+40]
   \      0xDE8   0xA80A             ADD      R0,SP,#+40
   \      0xDEA   0x9007             STR      R0,[SP, #+28]
   \      0xDEC   0xA80B             ADD      R0,SP,#+44
   \      0xDEE   0x9006             STR      R0,[SP, #+24]
   \      0xDF0   0xA812             ADD      R0,SP,#+72
   \      0xDF2   0x9005             STR      R0,[SP, #+20]
   \      0xDF4   0x4973             LDR.N    R1,??gcode_G29_2+0x34
   \      0xDF6   0xB084             SUB      SP,SP,#+16
   \      0xDF8   0x4668             MOV      R0,SP
   \      0xDFA   0x2224             MOVS     R2,#+36
   \      0xDFC   0x.... 0x....      BL       __aeabi_memcpy4
   \      0xE00   0xBC0F             POP      {R0-R3}
   \      0xE02   0x.... 0x....      BL       _Z18apply_rotation_xyz10matrix_3x3RfS0_S0_
   \      0xE06   0xF858 0x0026      LDR      R0,[R8, R6, LSL #+2]
   \      0xE0A   0x990A             LDR      R1,[SP, #+40]
   \      0xE0C   0x.... 0x....      BL       __aeabi_fsub
   \      0xE10   0x4649             MOV      R1,R9
   \      0xE12   0x.... 0x....      BL       __aeabi_fsub
   \      0xE16   0x4606             MOV      R6,R0
   \      0xE18   0x2100             MOVS     R1,#+0
   \      0xE1A   0x.... 0x....      BL       __aeabi_cfrcmple
   \      0xE1E   0xD803             BHI.N    ??gcode_G29_140
   \      0xE20   0x4871             LDR.N    R0,??gcode_G29_2+0x58
   \      0xE22   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \      0xE26   0xE7BC             B.N      ??gcode_G29_137
   \                     ??gcode_G29_140: (+1)
   \      0xE28   0x4832             LDR.N    R0,??gcode_G29_1+0x4
   \      0xE2A   0x79C0             LDRB     R0,[R0, #+7]
   \      0xE2C   0x2800             CMP      R0,#+0
   \      0xE2E   0xD1B3             BNE.N    ??gcode_G29_136
   \      0xE30   0x2120             MOVS     R1,#+32
   \      0xE32   0x4866             LDR.N    R0,??gcode_G29_2+0x3C
   \      0xE34   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \      0xE38   0xE7B3             B.N      ??gcode_G29_137
   5767          			  } // yy
   5768          			  SERIAL_EOL;
   \                     ??gcode_G29_141: (+1)
   \      0xE3A   0x482E             LDR.N    R0,??gcode_G29_1+0x4
   \      0xE3C   0x79C0             LDRB     R0,[R0, #+7]
   \      0xE3E   0x2800             CMP      R0,#+0
   \      0xE40   0xD104             BNE.N    ??gcode_G29_142
   \      0xE42   0x210A             MOVS     R1,#+10
   \      0xE44   0x4861             LDR.N    R0,??gcode_G29_2+0x3C
   \      0xE46   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \      0xE4A   0xE004             B.N      ??gcode_G29_103
   \                     ??gcode_G29_142: (+1)
   \      0xE4C   0x2200             MOVS     R2,#+0
   \      0xE4E   0x210A             MOVS     R1,#+10
   \      0xE50   0x485F             LDR.N    R0,??gcode_G29_2+0x40
   \      0xE52   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   5769          			}
   5770          		  } //do_topography_map
   5771          			}
   5772             // #endif // AUTO_BED_LEVELING_LINEAR
   5773          
   5774          
   5775          	/*--mks cfg--end AUTO_BED_LEVELING_BILINEAR */
   5776          
   5777          
   5778          	/*--mks cfg--begin AUTO_BED_LEVELING_BILINEAR */
   5779          /*
   5780              #if ABL_PLANAR
   5781          
   5782                // For LINEAR and 3POINT leveling correct the current position
   5783          
   5784                if (verbose_level > 0)
   5785                  planner.bed_level_matrix.debug(PSTR("\n\nBed Level Correction Matrix:"));
   5786          
   5787                if (!dryrun) {
   5788                  //
   5789                  // Correct the current XYZ position based on the tilted plane.
   5790                  //
   5791          
   5792                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   5793                    if (DEBUGGING(LEVELING)) DEBUG_POS("G29 uncorrected XYZ", current_position);
   5794                  #endif
   5795          
   5796                  float converted[XYZ];
   5797                  COPY(converted, current_position);
   5798          
   5799                  planner.abl_enabled = true;
   5800                  planner.unapply_leveling(converted); // use conversion machinery
   5801                  planner.abl_enabled = false;
   5802          
   5803                  // Use the last measured distance to the bed, if possible
   5804                  if ( NEAR(current_position[X_AXIS], xProbe - (X_PROBE_OFFSET_FROM_EXTRUDER))
   5805                    && NEAR(current_position[Y_AXIS], yProbe - (Y_PROBE_OFFSET_FROM_EXTRUDER))
   5806                  ) {
   5807                    float simple_z = current_position[Z_AXIS] - measured_z;
   5808                    #if ENABLED(DEBUG_LEVELING_FEATURE)
   5809                      if (DEBUGGING(LEVELING)) {
   5810                        SERIAL_ECHOPAIR("Z from Probe:", simple_z);
   5811                        SERIAL_ECHOPAIR("  Matrix:", converted[Z_AXIS]);
   5812                        SERIAL_ECHOLNPAIR("  Discrepancy:", simple_z - converted[Z_AXIS]);
   5813                      }
   5814                    #endif
   5815                    converted[Z_AXIS] = simple_z;
   5816                  }
   5817          
   5818                  // The rotated XY and corrected Z are now current_position
   5819                  COPY(current_position, converted);
   5820          
   5821                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   5822                    if (DEBUGGING(LEVELING)) DEBUG_POS("G29 corrected XYZ", current_position);
   5823                  #endif
   5824                }
   5825          
   5826              #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
   5827          
   5828                if (!dryrun) {
   5829                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   5830                    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("G29 uncorrected Z:", current_position[Z_AXIS]);
   5831                  #endif
   5832          
   5833                  // Unapply the offset because it is going to be immediately applied
   5834                  // and cause compensation movement in Z
   5835                  current_position[Z_AXIS] -= bilinear_z_offset(current_position);
   5836          
   5837                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   5838                    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR(" corrected Z:", current_position[Z_AXIS]);
   5839                  #endif
   5840                }
   5841          
   5842              #endif // ABL_PLANAR
   5843          */
   5844          
   5845          //#if ABL_PLANAR
   5846             if(BED_LEVELING_METHOD&ABL_PLANAR)	{
   \                     ??gcode_G29_103: (+1)
   \      0xE56   0x980D             LDR      R0,[SP, #+52]
   \      0xE58   0x7800             LDRB     R0,[R0, #+0]
   \      0xE5A   0xF010 0x0F06      TST      R0,#0x6
   \      0xE5E   0xD04B             BEQ.N    ??gcode_G29_143
   5847          	 // For LINEAR and 3POINT leveling correct the current position
   5848             
   5849          	 if (verbose_level > 0)
   \      0xE60   0x980C             LDR      R0,[SP, #+48]
   \      0xE62   0x2800             CMP      R0,#+0
   \      0xE64   0xDD03             BLE.N    ??gcode_G29_144
   5850          	   planner.bed_level_matrix.debug(PSTR("\n\nBed Level Correction Matrix:"));
   \      0xE66   0x4962             LDR.N    R1,??gcode_G29_2+0x60
   \      0xE68   0x4856             LDR.N    R0,??gcode_G29_2+0x34
   \      0xE6A   0x.... 0x....      BL       _ZN10matrix_3x35debugEPKc
   5851             
   5852          	 if (!dryrun) {
   \                     ??gcode_G29_144: (+1)
   \      0xE6E   0x980E             LDR      R0,[SP, #+56]
   \      0xE70   0x2800             CMP      R0,#+0
   \      0xE72   0xD150             BNE.N    ??gcode_G29_145
   5853          	   //
   5854          	   // Correct the current XYZ position based on the tilted plane.
   5855          	   //
   5856             
   5857          	#if ENABLED(DEBUG_LEVELING_FEATURE)
   5858          		 if (DEBUGGING(LEVELING)) DEBUG_POS("G29 uncorrected XYZ", current_position);
   5859          	#endif
   5860             
   5861          	   float converted[XYZ];
   5862          	   COPY(converted, current_position);
   \      0xE74   0x220C             MOVS     R2,#+12
   \      0xE76   0x495F             LDR.N    R1,??gcode_G29_2+0x64
   \      0xE78   0x4668             MOV      R0,SP
   \      0xE7A   0x.... 0x....      BL       __aeabi_memcpy
   5863             
   5864          	   planner.abl_enabled = true;
   \      0xE7E   0x2001             MOVS     R0,#+1
   \      0xE80   0x495D             LDR.N    R1,??gcode_G29_2+0x68
   \      0xE82   0x7008             STRB     R0,[R1, #+0]
   5865          	   planner.unapply_leveling(converted); // use conversion machinery
   \      0xE84   0x4668             MOV      R0,SP
   \      0xE86   0x.... 0x....      BL       _ZN7Planner16unapply_levelingEPf
   5866          	   planner.abl_enabled = false;
   \      0xE8A   0x2000             MOVS     R0,#+0
   \      0xE8C   0x495A             LDR.N    R1,??gcode_G29_2+0x68
   \      0xE8E   0x7008             STRB     R0,[R1, #+0]
   5867             
   5868          	   // Use the last measured distance to the bed, if possible
   5869          	   if ( NEAR(current_position[X_AXIS], xProbe - (X_PROBE_OFFSET_FROM_EXTRUDER))
   5870          		 && NEAR(current_position[Y_AXIS], yProbe - (Y_PROBE_OFFSET_FROM_EXTRUDER))
   5871          	   ) {
   \      0xE90   0x9809             LDR      R0,[SP, #+36]
   \      0xE92   0x68C0             LDR      R0,[R0, #+12]
   \      0xE94   0x9911             LDR      R1,[SP, #+68]
   \      0xE96   0x.... 0x....      BL       __aeabi_fsub
   \      0xE9A   0x4916             LDR.N    R1,??gcode_G29_1+0x4
   \      0xE9C   0x6889             LDR      R1,[R1, #+8]
   \      0xE9E   0x.... 0x....      BL       __aeabi_fadd
   \      0xEA2   0x4C56             LDR.N    R4,??gcode_G29_2+0x6C  ;; 0xb58637bd
   \      0xEA4   0x4621             MOV      R1,R4
   \      0xEA6   0x.... 0x....      BL       __aeabi_cfrcmple
   \      0xEAA   0xD81B             BHI.N    ??gcode_G29_146
   \      0xEAC   0x4E54             LDR.N    R6,??gcode_G29_2+0x70  ;; 0x358637be
   \      0xEAE   0x4631             MOV      R1,R6
   \      0xEB0   0x.... 0x....      BL       __aeabi_cfcmple
   \      0xEB4   0xD216             BCS.N    ??gcode_G29_146
   \      0xEB6   0x9809             LDR      R0,[SP, #+36]
   \      0xEB8   0x6900             LDR      R0,[R0, #+16]
   \      0xEBA   0x9910             LDR      R1,[SP, #+64]
   \      0xEBC   0x.... 0x....      BL       __aeabi_fsub
   \      0xEC0   0x490C             LDR.N    R1,??gcode_G29_1+0x4
   \      0xEC2   0x68C9             LDR      R1,[R1, #+12]
   \      0xEC4   0x.... 0x....      BL       __aeabi_fadd
   \      0xEC8   0x4621             MOV      R1,R4
   \      0xECA   0x.... 0x....      BL       __aeabi_cfrcmple
   \      0xECE   0xD809             BHI.N    ??gcode_G29_146
   \      0xED0   0x4631             MOV      R1,R6
   \      0xED2   0x.... 0x....      BL       __aeabi_cfcmple
   \      0xED6   0xD205             BCS.N    ??gcode_G29_146
   5872          		 float simple_z = current_position[Z_AXIS] - measured_z;
   5873          	  #if ENABLED(DEBUG_LEVELING_FEATURE)
   5874          		   if (DEBUGGING(LEVELING)) {
   5875          			 SERIAL_ECHOPAIR("Z from Probe:", simple_z);
   5876          			 SERIAL_ECHOPAIR("	Matrix:", converted[Z_AXIS]);
   5877          			 SERIAL_ECHOLNPAIR("  Discrepancy:", simple_z - converted[Z_AXIS]);
   5878          		   }
   5879          	  #endif
   5880          		 converted[Z_AXIS] = simple_z;
   \      0xED8   0x4806             LDR.N    R0,??gcode_G29_1+0x4
   \      0xEDA   0x6900             LDR      R0,[R0, #+16]
   \      0xEDC   0x990F             LDR      R1,[SP, #+60]
   \      0xEDE   0x.... 0x....      BL       __aeabi_fsub
   \      0xEE2   0x9002             STR      R0,[SP, #+8]
   5881          	   }
   5882             
   5883          	   // The rotated XY and corrected Z are now current_position
   5884          	   COPY(current_position, converted);
   \                     ??gcode_G29_146: (+1)
   \      0xEE4   0x220C             MOVS     R2,#+12
   \      0xEE6   0x4669             MOV      R1,SP
   \      0xEE8   0x4842             LDR.N    R0,??gcode_G29_2+0x64
   \      0xEEA   0x.... 0x....      BL       __aeabi_memcpy
   5885             
   5886          	#if ENABLED(DEBUG_LEVELING_FEATURE)
   5887          		 if (DEBUGGING(LEVELING)) DEBUG_POS("G29 corrected XYZ", current_position);
   5888          	#endif
   5889          	 }
   5890            	}
   \      0xEEE   0xE012             B.N      ??gcode_G29_145
   \                     ??gcode_G29_1:
   \      0xEF0   0x47C3'4F00        DC32     0x47c34f00
   \      0xEF4   0x....'....        DC32     mks_heating_busy
   5891          //#elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
   5892             else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR) {
   \                     ??gcode_G29_143: (+1)
   \      0xEF8   0x2808             CMP      R0,#+8
   \      0xEFA   0xD10C             BNE.N    ??gcode_G29_145
   5893          	 if (!dryrun) {
   \      0xEFC   0x980E             LDR      R0,[SP, #+56]
   \      0xEFE   0x2800             CMP      R0,#+0
   \      0xF00   0xD109             BNE.N    ??gcode_G29_145
   5894          	#if ENABLED(DEBUG_LEVELING_FEATURE)
   5895          		 if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("G29 uncorrected Z:", current_position[Z_AXIS]);
   5896          	#endif
   5897             
   5898          	   // Unapply the offset because it is going to be immediately applied
   5899          	   // and cause compensation movement in Z
   5900          	   current_position[Z_AXIS] -= bilinear_z_offset(current_position);
   \      0xF02   0x4C40             LDR.N    R4,??gcode_G29_2+0x74
   \      0xF04   0xF104 0x0008      ADD      R0,R4,#+8
   \      0xF08   0x.... 0x....      BL       _Z17bilinear_z_offsetPKf
   \      0xF0C   0x4601             MOV      R1,R0
   \      0xF0E   0x6920             LDR      R0,[R4, #+16]
   \      0xF10   0x.... 0x....      BL       __aeabi_fsub
   \      0xF14   0x6120             STR      R0,[R4, #+16]
   5901             
   5902          	#if ENABLED(DEBUG_LEVELING_FEATURE)
   5903          		 if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR(" corrected Z:", current_position[Z_AXIS]);
   5904          	#endif
   5905          	 }
   5906             	}
   5907          //#endif // ABL_PLANAR
   5908          	
   5909          	/*--mks cfg--end AUTO_BED_LEVELING_BILINEAR */
   5910          
   5911          
   5912              #ifdef Z_PROBE_END_SCRIPT
   5913                #if ENABLED(DEBUG_LEVELING_FEATURE)
   5914                  if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
   5915                #endif
   5916                enqueue_and_echo_commands_P(PSTR(Z_PROBE_END_SCRIPT));
   5917                stepper.synchronize();
   5918              #endif
   5919          
   5920              #if ENABLED(DEBUG_LEVELING_FEATURE)
   5921                if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< gcode_G29");
   5922              #endif
   5923          
   5924              report_current_position();
   \                     ??gcode_G29_145: (+1)
   \      0xF16   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531923report_current_positionEv
   5925          
   5926              KEEPALIVE_STATE(IN_HANDLER);
   \      0xF1A   0x2001             MOVS     R0,#+1
   \      0xF1C   0x4939             LDR.N    R1,??gcode_G29_2+0x74
   \      0xF1E   0x7188             STRB     R0,[R1, #+6]
   5927          
   5928              // Auto Bed Leveling is complete! Enable if possible.
   5929              planner.abl_enabled = dryrun ? abl_should_enable : true;
   \      0xF20   0x980E             LDR      R0,[SP, #+56]
   \      0xF22   0x2800             CMP      R0,#+0
   \      0xF24   0xD004             BEQ.N    ??gcode_G29_147
   \      0xF26   0xF89D 0x0020      LDRB     R0,[SP, #+32]
   \      0xF2A   0x4933             LDR.N    R1,??gcode_G29_2+0x68
   \      0xF2C   0x7008             STRB     R0,[R1, #+0]
   \      0xF2E   0xE002             B.N      ??gcode_G29_148
   \                     ??gcode_G29_147: (+1)
   \      0xF30   0x2001             MOVS     R0,#+1
   \      0xF32   0x4931             LDR.N    R1,??gcode_G29_2+0x68
   \      0xF34   0x7008             STRB     R0,[R1, #+0]
   5930          
   5931              if (planner.abl_enabled)
   \                     ??gcode_G29_148: (+1)
   \      0xF36   0x4608             MOV      R0,R1
   \      0xF38   0x7800             LDRB     R0,[R0, #+0]
   \      0xF3A   0x2800             CMP      R0,#+0
   \      0xF3C   0xD001             BEQ.N    ??gcode_G29_149
   5932                SYNC_PLAN_POSITION_KINEMATIC();
   \      0xF3E   0x.... 0x....      BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
   5933          
   5934          	//if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_LINEAR)
   5935          	
   5936          	free(eqnBVector);
   \                     ??gcode_G29_149: (+1)
   \      0xF42   0x4640             MOV      R0,R8
   \      0xF44   0x.... 0x....      BL       free
   5937          	free(eqnAMatrix);
   \      0xF48   0x4628             MOV      R0,R5
   \      0xF4A   0x.... 0x....      BL       free
   5938               
   5939            }
   \                     ??gcode_G29_3: (+1)
   \      0xF4E   0xF50D 0x6D80      ADD      SP,SP,#+1024
   \      0xF52   0xB02F             ADD      SP,SP,#+188
   \      0xF54   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \                     ??gcode_G29_139: (+1)
   \      0xF58   0xF8CD 0xB02C      STR      R11,[SP, #+44]
   \      0xF5C   0xF8CD 0xA028      STR      R10,[SP, #+40]
   \      0xF60   0x464C             MOV      R4,R9
   \      0xF62   0x4828             LDR.N    R0,??gcode_G29_2+0x74
   \      0xF64   0x79C0             LDRB     R0,[R0, #+7]
   \      0xF66   0x2800             CMP      R0,#+0
   \      0xF68   0xF47F 0xAEF2      BNE.W    ??gcode_G29_132
   \      0xF6C   0x210A             MOVS     R1,#+10
   \      0xF6E   0x4817             LDR.N    R0,??gcode_G29_2+0x3C
   \      0xF70   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \                     ??gcode_G29_133: (+1)
   \      0xF74   0x1E7F             SUBS     R7,R7,#+1
   \      0xF76   0xB27F             SXTB     R7,R7
   \                     ??gcode_G29_131: (+1)
   \      0xF78   0x2F00             CMP      R7,#+0
   \      0xF7A   0xF53F 0xAF5E      BMI.W    ??gcode_G29_141
   \      0xF7E   0x2000             MOVS     R0,#+0
   \      0xF80   0xF8DD 0xB02C      LDR      R11,[SP, #+44]
   \      0xF84   0xF8DD 0xA028      LDR      R10,[SP, #+40]
   \      0xF88   0x46A1             MOV      R9,R4
   \      0xF8A   0x4604             MOV      R4,R0
   \      0xF8C   0xE718             B.N      ??gcode_G29_138
   \      0xF8E   0xBF00             Nop      
   \                     ??gcode_G29_2:
   \      0xF90   0x....'....        DC32     z_values
   \      0xF94   0x....'....        DC32     _ZZ9gcode_G29vEs_3
   \      0xF98   0x....'....        DC32     _ZZ9gcode_G29vEs_4
   \      0xF9C   0x4270'0000        DC32     0x42700000
   \      0xFA0   0x....'....        DC32     mksTmp
   \      0xFA4   0x....'....        DC32     _ZZ9gcode_G29vEs_5
   \      0xFA8   0x....'....        DC32     _ZZ9gcode_G29vEs_6
   \      0xFAC   0x....'....        DC32     _ZZ9gcode_G29vEs_7
   \      0xFB0   0x....'....        DC32     _ZZ9gcode_G29vEs_8
   \      0xFB4   0x....'....        DC32     _ZZ9gcode_G29vEs_9
   \      0xFB8   0x....'....        DC32     _ZZ9gcode_G29vEs__10_
   \      0xFBC   0x3FE0'0000        DC32     0x3fe00000
   \      0xFC0   0xBF80'0000        DC32     0xbf800000
   \      0xFC4   0x....'....        DC32     _ZN7Planner16bed_level_matrixE
   \      0xFC8   0x....'....        DC32     _ZZ9gcode_G29vEs__11_
   \      0xFCC   0x....'....        DC32     customizedSerial
   \      0xFD0   0x....'....        DC32     serial2
   \      0xFD4   0x....'....        DC32     _ZZ9gcode_G29vEs__12_
   \      0xFD8   0x....'....        DC32     _ZZ9gcode_G29vEs__13_
   \      0xFDC   0x....'....        DC32     _ZZ9gcode_G29vEs__14_
   \      0xFE0   0x....'....        DC32     _ZZ9gcode_G29vEs__15_
   \      0xFE4   0x4479'C000        DC32     0x4479c000
   \      0xFE8   0x....'....        DC32     _ZZ9gcode_G29vEs__16_
   \      0xFEC   0x....'....        DC32     _ZZ9gcode_G29vEs__17_
   \      0xFF0   0x....'....        DC32     _ZZ9gcode_G29vEs__18_
   \      0xFF4   0x....'....        DC32     mks_heating_busy+0x8
   \      0xFF8   0x....'....        DC32     _ZN7Planner11abl_enabledE
   \      0xFFC   0xB586'37BD        DC32     0xb58637bd
   \     0x1000   0x3586'37BE        DC32     0x358637be
   \     0x1004   0x....'....        DC32     mks_heating_busy

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_79:
   \        0x0   0x0000'0000        DC32 0H, 0H, 0H
   \              0x0000'0000  
   \              0x0000'0000  
   5940          
   5941          #endif // HAS_ABL && !AUTO_BED_LEVELING_UBL
   5942          
   5943          #if HAS_BED_PROBE
   5944          
   5945            /**
   5946             * G30: Do a single Z probe at the current XY
   5947             *
   5948             * Parameters:
   5949             *
   5950             *   X   Probe X position (default current X)
   5951             *   Y   Probe Y position (default current Y)
   5952             *   S0  Leave the probe deployed
   5953             */

   \                                 In section .text, align 4
   5954            inline void gcode_G30() {
   \                     _Z9gcode_G30v: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   5955              const float xpos = code_seen('X') ? code_value_linear_units() : current_position[X_AXIS] + X_PROBE_OFFSET_FROM_EXTRUDER,
   \        0x4   0x4E40             LDR.N    R6,??gcode_G30_0
   \        0x6   0x2058             MOVS     R0,#+88
   \        0x8   0x.... 0x....      BL       _Z9code_seenc
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD003             BEQ.N    ??gcode_G30_1
   \       0x10   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x14   0x4681             MOV      R9,R0
   \       0x16   0xE005             B.N      ??gcode_G30_2
   \                     ??gcode_G30_1: (+1)
   \       0x18   0x68B1             LDR      R1,[R6, #+8]
   \       0x1A   0x483C             LDR.N    R0,??gcode_G30_0+0x4
   \       0x1C   0x6AC0             LDR      R0,[R0, #+44]
   \       0x1E   0x.... 0x....      BL       __aeabi_fadd
   \       0x22   0x4681             MOV      R9,R0
   5956                          ypos = code_seen('Y') ? code_value_linear_units() : current_position[Y_AXIS] + Y_PROBE_OFFSET_FROM_EXTRUDER,
   \                     ??gcode_G30_2: (+1)
   \       0x24   0x2059             MOVS     R0,#+89
   \       0x26   0x.... 0x....      BL       _Z9code_seenc
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD003             BEQ.N    ??gcode_G30_3
   \       0x2E   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x32   0x4607             MOV      R7,R0
   \       0x34   0xE005             B.N      ??gcode_G30_4
   \                     ??gcode_G30_3: (+1)
   \       0x36   0x68F1             LDR      R1,[R6, #+12]
   \       0x38   0x4834             LDR.N    R0,??gcode_G30_0+0x4
   \       0x3A   0x6B00             LDR      R0,[R0, #+48]
   \       0x3C   0x.... 0x....      BL       __aeabi_fadd
   \       0x40   0x4607             MOV      R7,R0
   5957                          pos[XYZ] = { xpos, ypos, LOGICAL_Z_POSITION(0) };
   \                     ??gcode_G30_4: (+1)
   \       0x42   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \       0x46   0x9701             STR      R7,[SP, #+4]
   \       0x48   0x6CF0             LDR      R0,[R6, #+76]
   \       0x4A   0x9002             STR      R0,[SP, #+8]
   5958          
   5959              if (!position_is_reachable(pos, true)) return;
   \       0x4C   0x2101             MOVS     R1,#+1
   \       0x4E   0x4668             MOV      R0,SP
   \       0x50   0x.... 0x....      BL       _Z21position_is_reachablePKfb
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD054             BEQ.N    ??gcode_G30_5
   5960          
   5961              // Disable leveling so the planner won't mess with us
   5962              //#if HAS_LEVELING
   5963          	if(BED_LEVELING_METHOD&HAS_LEVELING)
   \       0x58   0x482D             LDR.N    R0,??gcode_G30_0+0x8
   \       0x5A   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \       0x5E   0xF010 0x0F3E      TST      R0,#0x3E
   \       0x62   0xD002             BEQ.N    ??gcode_G30_6
   5964                set_bed_leveling_enabled(false);
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   5965              //#endif
   5966          
   5967              setup_for_endstop_or_probe_move();
   \                     ??gcode_G30_6: (+1)
   \       0x6A   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531931setup_for_endstop_or_probe_moveEv
   5968          
   5969              const float measured_z = probe_pt(xpos, ypos, !code_seen('S') || code_value_bool(), 1);
   \       0x6E   0x2053             MOVS     R0,#+83
   \       0x70   0x.... 0x....      BL       _Z9code_seenc
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD006             BEQ.N    ??gcode_G30_7
   \       0x78   0x.... 0x....      BL       _Z15code_value_boolv
   \       0x7C   0x1E42             SUBS     R2,R0,#+1
   \       0x7E   0x4192             SBCS     R2,R2,R2
   \       0x80   0x43D2             MVNS     R2,R2
   \       0x82   0x0FD2             LSRS     R2,R2,#+31
   \       0x84   0xE000             B.N      ??gcode_G30_8
   \                     ??gcode_G30_7: (+1)
   \       0x86   0x2201             MOVS     R2,#+1
   \                     ??gcode_G30_8: (+1)
   \       0x88   0x2301             MOVS     R3,#+1
   \       0x8A   0x4639             MOV      R1,R7
   \       0x8C   0x4648             MOV      R0,R9
   \       0x8E   0x.... 0x....      BL       _Z8probe_ptffbi
   \       0x92   0x4680             MOV      R8,R0
   5970          
   5971              SERIAL_PROTOCOLPAIR("Bed X: ", FIXFLOAT(xpos));
   \       0x94   0x4C1F             LDR.N    R4,??gcode_G30_0+0xC  ;; 0x88e368f1
   \       0x96   0x4D20             LDR.N    R5,??gcode_G30_0+0x10  ;; 0x3ee4f8b5
   \       0x98   0x4648             MOV      R0,R9
   \       0x9A   0x.... 0x....      BL       __aeabi_f2d
   \       0x9E   0x4622             MOV      R2,R4
   \       0xA0   0x462B             MOV      R3,R5
   \       0xA2   0x.... 0x....      BL       __aeabi_dadd
   \       0xA6   0x4602             MOV      R2,R0
   \       0xA8   0x460B             MOV      R3,R1
   \       0xAA   0x481C             LDR.N    R0,??gcode_G30_0+0x14
   \       0xAC   0x.... 0x....      BL       _Z17serial_echopair_PPKcd
   5972              SERIAL_PROTOCOLPAIR(" Y: ", FIXFLOAT(ypos));
   \       0xB0   0x4638             MOV      R0,R7
   \       0xB2   0x.... 0x....      BL       __aeabi_f2d
   \       0xB6   0x4622             MOV      R2,R4
   \       0xB8   0x462B             MOV      R3,R5
   \       0xBA   0x.... 0x....      BL       __aeabi_dadd
   \       0xBE   0x4602             MOV      R2,R0
   \       0xC0   0x460B             MOV      R3,R1
   \       0xC2   0x4817             LDR.N    R0,??gcode_G30_0+0x18
   \       0xC4   0x.... 0x....      BL       _Z17serial_echopair_PPKcd
   5973              SERIAL_PROTOCOLLNPAIR(" Z: ", FIXFLOAT(measured_z));
   \       0xC8   0x4640             MOV      R0,R8
   \       0xCA   0x.... 0x....      BL       __aeabi_f2d
   \       0xCE   0x4622             MOV      R2,R4
   \       0xD0   0x462B             MOV      R3,R5
   \       0xD2   0x.... 0x....      BL       __aeabi_dadd
   \       0xD6   0x4602             MOV      R2,R0
   \       0xD8   0x460B             MOV      R3,R1
   \       0xDA   0x4812             LDR.N    R0,??gcode_G30_0+0x1C
   \       0xDC   0x.... 0x....      BL       _Z17serial_echopair_PPKcd
   \       0xE0   0x79F0             LDRB     R0,[R6, #+7]
   \       0xE2   0x2800             CMP      R0,#+0
   \       0xE4   0xD104             BNE.N    ??gcode_G30_9
   \       0xE6   0x210A             MOVS     R1,#+10
   \       0xE8   0x480F             LDR.N    R0,??gcode_G30_0+0x20
   \       0xEA   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \       0xEE   0xE004             B.N      ??gcode_G30_10
   \                     ??gcode_G30_9: (+1)
   \       0xF0   0x2200             MOVS     R2,#+0
   \       0xF2   0x210A             MOVS     R1,#+10
   \       0xF4   0x480D             LDR.N    R0,??gcode_G30_0+0x24
   \       0xF6   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   5974          
   5975              clean_up_after_endstop_or_probe_move();
   \                     ??gcode_G30_10: (+1)
   \       0xFA   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531936clean_up_after_endstop_or_probe_moveEv
   5976          
   5977              report_current_position();
   \       0xFE   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531923report_current_positionEv
   5978            }
   \                     ??gcode_G30_5: (+1)
   \      0x102   0xE8BD 0x83F7      POP      {R0-R2,R4-R9,PC}  ;; return
   \      0x106   0xBF00             Nop      
   \                     ??gcode_G30_0:
   \      0x108   0x....'....        DC32     mks_heating_busy
   \      0x10C   0x....'....        DC32     mksCfg+0x40
   \      0x110   0x....'....        DC32     mksCfg
   \      0x114   0x88E3'68F1        DC32     0x88e368f1
   \      0x118   0x3EE4'F8B5        DC32     0x3ee4f8b5
   \      0x11C   0x....'....        DC32     _ZZ9gcode_G30vEs
   \      0x120   0x....'....        DC32     _ZZ9gcode_G30vEs_0
   \      0x124   0x....'....        DC32     _ZZ9gcode_G30vEs_1
   \      0x128   0x....'....        DC32     customizedSerial
   \      0x12C   0x....'....        DC32     serial2
   5979          
   5980            #if ENABLED(Z_PROBE_SLED)
   5981          
   5982              /**
   5983               * G31: Deploy the Z probe
   5984               */
   5985              inline void gcode_G31() { DEPLOY_PROBE(); }
   5986          
   5987              /**
   5988               * G32: Stow the Z probe
   5989               */
   5990              inline void gcode_G32() { STOW_PROBE(); }
   5991          
   5992            #endif // Z_PROBE_SLED
   5993          
   5994            #if ENABLED(DELTA_AUTO_CALIBRATION)
   5995              /**
   5996               * G33 - Delta '1-4-7-point' Auto-Calibration
   5997               *       Calibrate height, endstops, delta radius, and tower angles.
   5998               *
   5999               * Parameters:
   6000               *
   6001               *   P  Number of probe points:
   6002               *
   6003               *      P1     Probe center and set height only.
   6004               *      P2     Probe center and towers. Set height, endstops, and delta radius.
   6005               *      P3     Probe all positions: center, towers and opposite towers. Set all.
   6006               *      P4-P7  Probe all positions at different locations and average them.
   6007               *
   6008               *   A  Abort delta height calibration after 1 probe (only P1)
   6009               *
   6010               *   O  Use opposite tower points instead of tower points (only P2)
   6011               *
   6012               *   T  Don't calibrate tower angle corrections (P3-P7)
   6013               *
   6014               *   V  Verbose level:
   6015               *
   6016               *      V0  Dry-run mode. Report settings and probe results. No calibration.
   6017               *      V1  Report settings
   6018               *      V2  Report settings and probe results
   6019               */
   6020              inline void gcode_G33() {
   6021          
   6022                const int8_t probe_points = code_seen('P') ? code_value_int() : DELTA_CALIBRATION_DEFAULT_POINTS;
   6023                if (!WITHIN(probe_points, 1, 7)) {
   6024                  SERIAL_PROTOCOLLNPGM("?(P)oints is implausible (1 to 7).");
   6025                  return;
   6026                }
   6027          
   6028                const int8_t verbose_level = code_seen('V') ? code_value_byte() : 1;
   6029                if (!WITHIN(verbose_level, 0, 2)) {
   6030                  SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-2).");
   6031                  return;
   6032                }
   6033          
   6034                const bool do_height_only       = probe_points == 1,
   6035                           do_center_and_towers = probe_points == 2,
   6036                           do_all_positions     = probe_points == 3,
   6037                           do_circle_x2         = probe_points == 5,
   6038                           do_circle_x3         = probe_points == 6,
   6039                           do_circle_x4         = probe_points == 7,
   6040                           probe_center_plus_3  = probe_points >= 3,
   6041                           point_averaging      = probe_points >= 4,
   6042                           probe_center_plus_6  = probe_points >= 5;
   6043          
   6044                const char negating_parameter = do_height_only ? 'A' : do_center_and_towers ? 'O' : 'T';
   6045                int8_t probe_mode = code_seen(negating_parameter) && code_value_bool() ? -probe_points : probe_points;
   6046          
   6047                SERIAL_PROTOCOLLNPGM("G33 Auto Calibrate");
   6048          
   6049                //#if HAS_LEVELING
   6050          	  if(BED_LEVELING_METHOD&HAS_LEVELING)
   6051                  set_bed_leveling_enabled(false);
   6052                //#endif
   6053          
   6054                home_all_axes();
   6055          
   6056                const static char save_message[] PROGMEM = "Save with M500 and/or copy to Configuration.h";
   6057                float test_precision,
   6058                      zero_std_dev = (verbose_level ? 999.0 : 0.0), // 0.0 in dry-run mode : forced end
   6059                      e_old[XYZ] = {
   6060                        endstop_adj[A_AXIS],
   6061                        endstop_adj[B_AXIS],
   6062                        endstop_adj[C_AXIS]
   6063                      },
   6064                      dr_old = delta_radius,
   6065                      zh_old = home_offset[Z_AXIS],
   6066                      alpha_old = delta_tower_angle_trim[A_AXIS],
   6067                      beta_old = delta_tower_angle_trim[B_AXIS];
   6068          
   6069                // print settings
   6070          
   6071                SERIAL_PROTOCOLPGM("Checking... AC");
   6072                if (verbose_level == 0) SERIAL_PROTOCOLPGM(" (DRY-RUN)");
   6073                SERIAL_EOL;
   6074                LCD_MESSAGEPGM("Checking... AC");
   6075          
   6076                SERIAL_PROTOCOLPAIR(".Height:", DELTA_HEIGHT + home_offset[Z_AXIS]);
   6077                if (!do_height_only) {
   6078                  SERIAL_PROTOCOLPGM("    Ex:");
   6079                  if (endstop_adj[A_AXIS] >= 0) SERIAL_CHAR('+');
   6080                  SERIAL_PROTOCOL_F(endstop_adj[A_AXIS], 2);
   6081                  SERIAL_PROTOCOLPGM("  Ey:");
   6082                  if (endstop_adj[B_AXIS] >= 0) SERIAL_CHAR('+');
   6083                  SERIAL_PROTOCOL_F(endstop_adj[B_AXIS], 2);
   6084                  SERIAL_PROTOCOLPGM("  Ez:");
   6085                  if (endstop_adj[C_AXIS] >= 0) SERIAL_CHAR('+');
   6086                  SERIAL_PROTOCOL_F(endstop_adj[C_AXIS], 2);
   6087                  SERIAL_PROTOCOLPAIR("    Radius:", delta_radius);
   6088                }
   6089                SERIAL_EOL;
   6090                if (probe_mode > 2) { // negative disables tower angles
   6091                  SERIAL_PROTOCOLPGM(".Tower angle :    Tx:");
   6092                  if (delta_tower_angle_trim[A_AXIS] >= 0) SERIAL_CHAR('+');
   6093                  SERIAL_PROTOCOL_F(delta_tower_angle_trim[A_AXIS], 2);
   6094                  SERIAL_PROTOCOLPGM("  Ty:");
   6095                  if (delta_tower_angle_trim[B_AXIS] >= 0) SERIAL_CHAR('+');
   6096                  SERIAL_PROTOCOL_F(delta_tower_angle_trim[B_AXIS], 2);
   6097                  SERIAL_PROTOCOLPGM("  Tz:+0.00");
   6098                  SERIAL_EOL;
   6099                }
   6100          
   6101                #if ENABLED(Z_PROBE_SLED)
   6102                  DEPLOY_PROBE();
   6103                #endif
   6104          
   6105                int8_t iterations = 0;
   6106          
   6107                do {
   6108          
   6109                  float z_at_pt[13] = { 0 },
   6110                        S1 = 0.0,
   6111                        S2 = 0.0;
   6112                  int16_t N = 0;
   6113          
   6114                  test_precision = zero_std_dev;
   6115                  iterations++;
   6116          
   6117                  // Probe the points
   6118          
   6119                  if (!do_all_positions && !do_circle_x3) { // probe the center
   6120                    setup_for_endstop_or_probe_move();
   6121                    z_at_pt[0] += probe_pt(0.0, 0.0 , true, 1);
   6122                    clean_up_after_endstop_or_probe_move();
   6123                  }
   6124                  if (probe_center_plus_3) { // probe extra center points
   6125                    for (int8_t axis = probe_center_plus_6 ? 11 : 9; axis > 0; axis -= probe_center_plus_6 ? 2 : 4) {
   6126                      setup_for_endstop_or_probe_move();
   6127                      z_at_pt[0] += probe_pt(
   6128                        cos(RADIANS(180 + 30 * axis)) * (0.1 * delta_calibration_radius),
   6129                        sin(RADIANS(180 + 30 * axis)) * (0.1 * delta_calibration_radius), true, 1);
   6130                      clean_up_after_endstop_or_probe_move();
   6131                    }
   6132                    z_at_pt[0] /= float(do_circle_x2 ? 7 : probe_points);
   6133                  }
   6134                  if (!do_height_only) {  // probe the radius
   6135                    bool zig_zag = true;
   6136                    for (uint8_t axis = (probe_mode == -2 ? 3 : 1); axis < 13;
   6137                                 axis += (do_center_and_towers ? 4 : do_all_positions ? 2 : 1)) {
   6138                      float offset_circles = (do_circle_x4 ? (zig_zag ? 1.5 : 1.0) :
   6139                                              do_circle_x3 ? (zig_zag ? 1.0 : 0.5) :
   6140                                              do_circle_x2 ? (zig_zag ? 0.5 : 0.0) : 0);
   6141                      for (float circles = -offset_circles ; circles <= offset_circles; circles++) {
   6142                        setup_for_endstop_or_probe_move();
   6143                        z_at_pt[axis] += probe_pt(
   6144                          cos(RADIANS(180 + 30 * axis)) * delta_calibration_radius *
   6145                          (1 + circles * 0.1 * (zig_zag ? 1 : -1)),
   6146                          sin(RADIANS(180 + 30 * axis)) * delta_calibration_radius *
   6147                          (1 + circles * 0.1 * (zig_zag ? 1 : -1)), true, 1);
   6148                        clean_up_after_endstop_or_probe_move();
   6149                      }
   6150                      zig_zag = !zig_zag;
   6151                      z_at_pt[axis] /= (2 * offset_circles + 1);
   6152                    }
   6153                  }
   6154                  if (point_averaging) // average intermediates to tower and opposites
   6155                    for (uint8_t axis = 1; axis <= 11; axis += 2)
   6156                      z_at_pt[axis] = (z_at_pt[axis] + (z_at_pt[axis + 1] + z_at_pt[(axis + 10) % 12 + 1]) / 2.0) / 2.0;
   6157          
   6158                  S1 += z_at_pt[0];
   6159                  S2 += sq(z_at_pt[0]);
   6160                  N++;
   6161                  if (!do_height_only) // std dev from zero plane
   6162                    for (uint8_t axis = (probe_mode == -2 ? 3 : 1); axis < 13; axis += (do_center_and_towers ? 4 : 2)) {
   6163                      S1 += z_at_pt[axis];
   6164                      S2 += sq(z_at_pt[axis]);
   6165                      N++;
   6166                    }
   6167                  zero_std_dev = round(sqrt(S2 / N) * 1000.0) / 1000.0 + 0.00001;
   6168          
   6169                  // Solve matrices
   6170          
   6171                  if (zero_std_dev < test_precision) {
   6172                    COPY(e_old, endstop_adj);
   6173                    dr_old = delta_radius;
   6174                    zh_old = home_offset[Z_AXIS];
   6175                    alpha_old = delta_tower_angle_trim[A_AXIS];
   6176                    beta_old = delta_tower_angle_trim[B_AXIS];
   6177          
   6178                    float e_delta[XYZ] = { 0.0 }, r_delta = 0.0,
   6179                          t_alpha = 0.0, t_beta = 0.0;
   6180                    const float r_diff = delta_radius - delta_calibration_radius,
   6181                                h_factor = 1.00 + r_diff * 0.001,                          //1.02 for r_diff = 20mm
   6182                                r_factor = -(1.75 + 0.005 * r_diff + 0.001 * sq(r_diff)),  //2.25 for r_diff = 20mm
   6183                                a_factor = 100.0 / delta_calibration_radius;               //1.25 for cal_rd = 80mm
   6184          
   6185                    #define ZP(N,I) ((N) * z_at_pt[I])
   6186                    #define Z1000(I) ZP(1.00, I)
   6187                    #define Z1050(I) ZP(h_factor, I)
   6188                    #define Z0700(I) ZP(h_factor * 2.0 / 3.00, I)
   6189                    #define Z0350(I) ZP(h_factor / 3.00, I)
   6190                    #define Z0175(I) ZP(h_factor / 6.00, I)
   6191                    #define Z2250(I) ZP(r_factor, I)
   6192                    #define Z0750(I) ZP(r_factor / 3.00, I)
   6193                    #define Z0375(I) ZP(r_factor / 6.00, I)
   6194                    #define Z0444(I) ZP(a_factor * 4.0 / 9.0, I)
   6195                    #define Z0888(I) ZP(a_factor * 8.0 / 9.0, I)
   6196          
   6197                    switch (probe_mode) {
   6198                      case -1:
   6199                        test_precision = 0.00;
   6200                      case 1:
   6201                        LOOP_XYZ(i) e_delta[i] = Z1000(0);
   6202                        break;
   6203          
   6204                      case 2:
   6205                        e_delta[X_AXIS] = Z1050(0) + Z0700(1) - Z0350(5) - Z0350(9);
   6206                        e_delta[Y_AXIS] = Z1050(0) - Z0350(1) + Z0700(5) - Z0350(9);
   6207                        e_delta[Z_AXIS] = Z1050(0) - Z0350(1) - Z0350(5) + Z0700(9);
   6208                        r_delta         = Z2250(0) - Z0750(1) - Z0750(5) - Z0750(9);
   6209                        break;
   6210          
   6211                      case -2:
   6212                        e_delta[X_AXIS] = Z1050(0) - Z0700(7) + Z0350(11) + Z0350(3);
   6213                        e_delta[Y_AXIS] = Z1050(0) + Z0350(7) - Z0700(11) + Z0350(3);
   6214                        e_delta[Z_AXIS] = Z1050(0) + Z0350(7) + Z0350(11) - Z0700(3);
   6215                        r_delta         = Z2250(0) - Z0750(7) - Z0750(11) - Z0750(3);
   6216                        break;
   6217          
   6218                      default:
   6219                        e_delta[X_AXIS] = Z1050(0) + Z0350(1) - Z0175(5) - Z0175(9) - Z0350(7) + Z0175(11) + Z0175(3);
   6220                        e_delta[Y_AXIS] = Z1050(0) - Z0175(1) + Z0350(5) - Z0175(9) + Z0175(7) - Z0350(11) + Z0175(3);
   6221                        e_delta[Z_AXIS] = Z1050(0) - Z0175(1) - Z0175(5) + Z0350(9) + Z0175(7) + Z0175(11) - Z0350(3);
   6222                        r_delta         = Z2250(0) - Z0375(1) - Z0375(5) - Z0375(9) - Z0375(7) - Z0375(11) - Z0375(3);
   6223          
   6224                        if (probe_mode > 0) {  // negative disables tower angles
   6225                          t_alpha = + Z0444(1) - Z0888(5) + Z0444(9) + Z0444(7) - Z0888(11) + Z0444(3);
   6226                          t_beta  = - Z0888(1) + Z0444(5) + Z0444(9) - Z0888(7) + Z0444(11) + Z0444(3);
   6227                        }
   6228                        break;
   6229                    }
   6230          
   6231                    LOOP_XYZ(axis) endstop_adj[axis] += e_delta[axis];
   6232                    delta_radius += r_delta;
   6233                    delta_tower_angle_trim[A_AXIS] += t_alpha;
   6234                    delta_tower_angle_trim[B_AXIS] -= t_beta;
   6235          
   6236                    // adjust delta_height and endstops by the max amount
   6237                    const float z_temp = MAX3(endstop_adj[A_AXIS], endstop_adj[B_AXIS], endstop_adj[C_AXIS]);
   6238                    home_offset[Z_AXIS] -= z_temp;
   6239                    LOOP_XYZ(i) endstop_adj[i] -= z_temp;
   6240          
   6241                    recalc_delta_settings(delta_radius, delta_diagonal_rod);
   6242                  }
   6243                  else {   // step one back
   6244                    COPY(endstop_adj, e_old);
   6245                    delta_radius = dr_old;
   6246                    home_offset[Z_AXIS] = zh_old;
   6247                    delta_tower_angle_trim[A_AXIS] = alpha_old;
   6248                    delta_tower_angle_trim[B_AXIS] = beta_old;
   6249          
   6250                    recalc_delta_settings(delta_radius, delta_diagonal_rod);
   6251                  }
   6252          
   6253                   // print report
   6254          
   6255                  if (verbose_level != 1) {
   6256                    SERIAL_PROTOCOLPGM(".      c:");
   6257                    if (z_at_pt[0] > 0) SERIAL_CHAR('+');
   6258                    SERIAL_PROTOCOL_F(z_at_pt[0], 2);
   6259                    if (probe_mode == 2 || probe_center_plus_3) {
   6260                      SERIAL_PROTOCOLPGM("     x:");
   6261                      if (z_at_pt[1] >= 0) SERIAL_CHAR('+');
   6262                      SERIAL_PROTOCOL_F(z_at_pt[1], 2);
   6263                      SERIAL_PROTOCOLPGM("   y:");
   6264                      if (z_at_pt[5] >= 0) SERIAL_CHAR('+');
   6265                      SERIAL_PROTOCOL_F(z_at_pt[5], 2);
   6266                      SERIAL_PROTOCOLPGM("   z:");
   6267                      if (z_at_pt[9] >= 0) SERIAL_CHAR('+');
   6268                      SERIAL_PROTOCOL_F(z_at_pt[9], 2);
   6269                    }
   6270                    if (probe_mode != -2) SERIAL_EOL;
   6271                    if (probe_mode == -2 || probe_center_plus_3) {
   6272                      if (probe_center_plus_3) {
   6273                        SERIAL_CHAR('.');
   6274                        SERIAL_PROTOCOL_SP(13);
   6275                      }
   6276                      SERIAL_PROTOCOLPGM("    yz:");
   6277                      if (z_at_pt[7] >= 0) SERIAL_CHAR('+');
   6278                      SERIAL_PROTOCOL_F(z_at_pt[7], 2);
   6279                      SERIAL_PROTOCOLPGM("  zx:");
   6280                      if (z_at_pt[11] >= 0) SERIAL_CHAR('+');
   6281                      SERIAL_PROTOCOL_F(z_at_pt[11], 2);
   6282                      SERIAL_PROTOCOLPGM("  xy:");
   6283                      if (z_at_pt[3] >= 0) SERIAL_CHAR('+');
   6284                      SERIAL_PROTOCOL_F(z_at_pt[3], 2);
   6285                      SERIAL_EOL;
   6286                    }
   6287                  }
   6288                  if (test_precision != 0.0) {                                 // !forced end
   6289                    if (zero_std_dev >= test_precision) {                      // end iterations
   6290                      SERIAL_PROTOCOLPGM("Calibration OK");
   6291                      SERIAL_PROTOCOL_SP(36);
   6292                      SERIAL_PROTOCOLPGM("rolling back.");
   6293                      SERIAL_EOL;
   6294                      LCD_MESSAGEPGM("Calibration OK");
   6295                    }
   6296                    else {                                                     // !end iterations
   6297                      char mess[15] = "No convergence";
   6298                      if (iterations < 31)
   6299                        sprintf_P(mess, PSTR("Iteration : %02i"), (int)iterations);
   6300                      SERIAL_PROTOCOL(mess);
   6301                      SERIAL_PROTOCOL_SP(36);
   6302                      SERIAL_PROTOCOLPGM("std dev:");
   6303                      SERIAL_PROTOCOL_F(zero_std_dev, 3);
   6304                      SERIAL_EOL;
   6305                      lcd_setstatus(mess);
   6306                    }
   6307                    SERIAL_PROTOCOLPAIR(".Height:", DELTA_HEIGHT + home_offset[Z_AXIS]);
   6308                    if (!do_height_only) {
   6309                      SERIAL_PROTOCOLPGM("    Ex:");
   6310                      if (endstop_adj[A_AXIS] >= 0) SERIAL_CHAR('+');
   6311                      SERIAL_PROTOCOL_F(endstop_adj[A_AXIS], 2);
   6312                      SERIAL_PROTOCOLPGM("  Ey:");
   6313                      if (endstop_adj[B_AXIS] >= 0) SERIAL_CHAR('+');
   6314                      SERIAL_PROTOCOL_F(endstop_adj[B_AXIS], 2);
   6315                      SERIAL_PROTOCOLPGM("  Ez:");
   6316                      if (endstop_adj[C_AXIS] >= 0) SERIAL_CHAR('+');
   6317                      SERIAL_PROTOCOL_F(endstop_adj[C_AXIS], 2);
   6318                      SERIAL_PROTOCOLPAIR("    Radius:", delta_radius);
   6319                    }
   6320                    SERIAL_EOL;
   6321                    if (probe_mode > 2) { // negative disables tower angles
   6322                      SERIAL_PROTOCOLPGM(".Tower angle :    Tx:");
   6323                      if (delta_tower_angle_trim[A_AXIS] >= 0) SERIAL_CHAR('+');
   6324                      SERIAL_PROTOCOL_F(delta_tower_angle_trim[A_AXIS], 2);
   6325                      SERIAL_PROTOCOLPGM("  Ty:");
   6326                      if (delta_tower_angle_trim[B_AXIS] >= 0) SERIAL_CHAR('+');
   6327                      SERIAL_PROTOCOL_F(delta_tower_angle_trim[B_AXIS], 2);
   6328                      SERIAL_PROTOCOLPGM("  Tz:+0.00");
   6329                      SERIAL_EOL;
   6330                    }
   6331                    if (zero_std_dev >= test_precision)
   6332                      serialprintPGM(save_message);
   6333                      SERIAL_EOL;
   6334                  }
   6335                  else {                                                       // forced end
   6336                    if (verbose_level == 0) {
   6337                      SERIAL_PROTOCOLPGM("End DRY-RUN");
   6338                      SERIAL_PROTOCOL_SP(39);
   6339                      SERIAL_PROTOCOLPGM("std dev:");
   6340                      SERIAL_PROTOCOL_F(zero_std_dev, 3);
   6341                      SERIAL_EOL;
   6342                    }
   6343                    else {
   6344                      SERIAL_PROTOCOLLNPGM("Calibration OK");
   6345                      LCD_MESSAGEPGM("Calibration OK");
   6346                      SERIAL_PROTOCOLPAIR(".Height:", DELTA_HEIGHT + home_offset[Z_AXIS]);
   6347                      SERIAL_EOL;
   6348                      serialprintPGM(save_message);
   6349                      SERIAL_EOL;
   6350                    }
   6351                  }
   6352          
   6353                  stepper.synchronize();
   6354          
   6355                  home_all_axes();
   6356          
   6357                } while (zero_std_dev < test_precision && iterations < 31);
   6358          
   6359                #if ENABLED(Z_PROBE_SLED)
   6360                  RETRACT_PROBE();
   6361                #endif
   6362              }
   6363          
   6364            #endif // DELTA_AUTO_CALIBRATION
   6365          
   6366          #endif // HAS_BED_PROBE
   6367          
   6368          
   6369          #if ENABLED(G38_PROBE_TARGET)
   6370          
   6371            static bool G38_run_probe() {
   6372          
   6373              bool G38_pass_fail = false;
   6374          
   6375              // Get direction of move and retract
   6376              float retract_mm[XYZ];
   6377              LOOP_XYZ(i) {
   6378                float dist = destination[i] - current_position[i];
   6379                retract_mm[i] = fabs(dist) < G38_MINIMUM_MOVE ? 0 : home_bump_mm((AxisEnum)i) * (dist > 0 ? -1 : 1);
   6380              }
   6381          
   6382              stepper.synchronize();  // wait until the machine is idle
   6383          
   6384              // Move until destination reached or target hit
   6385              endstops.enable(true);
   6386              G38_move = true;
   6387              G38_endstop_hit = false;
   6388              prepare_move_to_destination();
   6389              stepper.synchronize();
   6390              G38_move = false;
   6391          
   6392              endstops.hit_on_purpose();
   6393              set_current_from_steppers_for_axis(ALL_AXES);
   6394              SYNC_PLAN_POSITION_KINEMATIC();
   6395          
   6396              if (G38_endstop_hit) {
   6397          
   6398                G38_pass_fail = true;
   6399          
   6400                #if ENABLED(PROBE_DOUBLE_TOUCH)
   6401                  // Move away by the retract distance
   6402                  set_destination_to_current();
   6403                  LOOP_XYZ(i) destination[i] += retract_mm[i];
   6404                  endstops.enable(false);
   6405                  prepare_move_to_destination();
   6406                  stepper.synchronize();
   6407          
   6408                  feedrate_mm_s /= 4;
   6409          
   6410                  // Bump the target more slowly
   6411                  LOOP_XYZ(i) destination[i] -= retract_mm[i] * 2;
   6412          
   6413                  endstops.enable(true);
   6414                  G38_move = true;
   6415                  prepare_move_to_destination();
   6416                  stepper.synchronize();
   6417                  G38_move = false;
   6418          
   6419                  set_current_from_steppers_for_axis(ALL_AXES);
   6420                  SYNC_PLAN_POSITION_KINEMATIC();
   6421                #endif
   6422              }
   6423          
   6424              endstops.hit_on_purpose();
   6425              endstops.not_homing();
   6426              return G38_pass_fail;
   6427            }
   6428          
   6429            /**
   6430             * G38.2 - probe toward workpiece, stop on contact, signal error if failure
   6431             * G38.3 - probe toward workpiece, stop on contact
   6432             *
   6433             * Like G28 except uses Z min probe for all axes
   6434             */
   6435            inline void gcode_G38(bool is_38_2) {
   6436              // Get X Y Z E F
   6437              gcode_get_destination();
   6438          
   6439              setup_for_endstop_or_probe_move();
   6440          
   6441              // If any axis has enough movement, do the move
   6442              LOOP_XYZ(i)
   6443                if (fabs(destination[i] - current_position[i]) >= G38_MINIMUM_MOVE) {
   6444                  if (!code_seen('F')) feedrate_mm_s = homing_feedrate_mm_s[i];
   6445                  // If G38.2 fails throw an error
   6446                  if (!G38_run_probe() && is_38_2) {
   6447                    SERIAL_ERROR_START;
   6448                    SERIAL_ERRORLNPGM("Failed to reach target");
   6449                  }
   6450                  break;
   6451                }
   6452          
   6453              clean_up_after_endstop_or_probe_move();
   6454            }
   6455          
   6456          #endif // G38_PROBE_TARGET
   6457          
   6458          /**
   6459           * G92: Set current position to given X Y Z E
   6460           */

   \                                 In section .text, align 4
   6461          inline void gcode_G92() {
   \                     _Z9gcode_G92v: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   6462            bool didXYZ = false,
   \        0x4   0x2500             MOVS     R5,#+0
   6463                 didE = code_seen('E');
   \        0x6   0x2045             MOVS     R0,#+69
   \        0x8   0x.... 0x....      BL       _Z9code_seenc
   \        0xC   0x0004             MOVS     R4,R0
   6464          
   6465            if (!didE) stepper.synchronize();
   \        0xE   0xD101             BNE.N    ??gcode_G92_1
   \       0x10   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   6466          
   6467            LOOP_XYZE(i) {
   \                     ??gcode_G92_1: (+1)
   \       0x14   0x462E             MOV      R6,R5
   \                     ??gcode_G92_2: (+1)
   \       0x16   0x2E03             CMP      R6,#+3
   \       0x18   0xDC35             BGT.N    ??gcode_G92_3
   6468              if (code_seen(axis_codes[i])) {
   \       0x1A   0x481D             LDR.N    R0,??gcode_G92_0
   \       0x1C   0x5780             LDRSB    R0,[R0, R6]
   \       0x1E   0x.... 0x....      BL       _Z9code_seenc
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD025             BEQ.N    ??gcode_G92_4
   6469          //      #if IS_SCARA	//mks_delta
   6470          		if(MACHINETPYE&IS_SCARA) {
   \       0x26   0x481B             LDR.N    R0,??gcode_G92_0+0x4
   \       0x28   0xEB00 0x0786      ADD      R7,R0,R6, LSL #+2
   \       0x2C   0x481A             LDR.N    R0,??gcode_G92_0+0x8
   \       0x2E   0xF8B0 0x0058      LDRH     R0,[R0, #+88]
   \       0x32   0xF410 0x7F40      TST      R0,#0x300
   \       0x36   0xD116             BNE.N    ??gcode_G92_5
   6471                  current_position[i] = code_value_axis_units((AxisEnum)i);
   6472                  if (i != E_AXIS) didXYZ = true;}
   6473          //      #else
   6474          		else {
   6475                  #if HAS_POSITION_SHIFT
   6476                    const float p = current_position[i];
   \       0x38   0xF8D7 0x8008      LDR      R8,[R7, #+8]
   6477                  #endif
   6478                  float v = code_value_axis_units((AxisEnum)i);
   \       0x3C   0x.... 0x....      BL       _Z16code_value_floatv
   6479          
   6480                  current_position[i] = v;
   \       0x40   0x60B8             STR      R0,[R7, #+8]
   6481          
   6482                  if (i != E_AXIS) {
   \       0x42   0x2E03             CMP      R6,#+3
   \       0x44   0xD015             BEQ.N    ??gcode_G92_4
   6483                    didXYZ = true;
   \       0x46   0x2501             MOVS     R5,#+1
   6484                    #if HAS_POSITION_SHIFT
   6485                      position_shift[i] += v - p; // Offset the coordinate space
   \       0x48   0x4914             LDR.N    R1,??gcode_G92_0+0xC
   \       0x4A   0xEB01 0x0786      ADD      R7,R1,R6, LSL #+2
   \       0x4E   0x4641             MOV      R1,R8
   \       0x50   0x.... 0x....      BL       __aeabi_fsub
   \       0x54   0x6BF9             LDR      R1,[R7, #+60]
   \       0x56   0x.... 0x....      BL       __aeabi_fadd
   \       0x5A   0x63F8             STR      R0,[R7, #+60]
   6486                      update_software_endstops((AxisEnum)i);
   \       0x5C   0x4630             MOV      R0,R6
   \       0x5E   0xB240             SXTB     R0,R0
   \       0x60   0x.... 0x....      BL       _Z24update_software_endstops8AxisEnum
   \       0x64   0xE005             B.N      ??gcode_G92_4
   6487                    #endif
   6488                  }
   6489                } //#endif
   \                     ??gcode_G92_5: (+1)
   \       0x66   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x6A   0x60B8             STR      R0,[R7, #+8]
   \       0x6C   0x2E03             CMP      R6,#+3
   \       0x6E   0xD000             BEQ.N    ??gcode_G92_4
   \       0x70   0x2501             MOVS     R5,#+1
   6490              }
   6491            }
   \                     ??gcode_G92_4: (+1)
   \       0x72   0x1C76             ADDS     R6,R6,#+1
   \       0x74   0xE7CF             B.N      ??gcode_G92_2
   6492            if (didXYZ)
   6493              SYNC_PLAN_POSITION_KINEMATIC();
   6494            else if (didE)
   \                     ??gcode_G92_6: (+1)
   \       0x76   0x2C00             CMP      R4,#+0
   \       0x78   0xD001             BEQ.N    ??gcode_G92_7
   6495              sync_plan_position_e();
   \       0x7A   0x.... 0x....      BL       _Z20sync_plan_position_ev
   6496          
   6497            report_current_position();
   \                     ??gcode_G92_7: (+1)
   \       0x7E   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \       0x82   0x.... 0x....      B.W      _ZN37_INTERNAL_15_Marlin_main_cpp_3178531923report_current_positionEv
   \                     ??gcode_G92_3: (+1)
   \       0x86   0x2D00             CMP      R5,#+0
   \       0x88   0xD0F5             BEQ.N    ??gcode_G92_6
   \       0x8A   0x.... 0x....      BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
   \       0x8E   0xE7F6             B.N      ??gcode_G92_7
   \                     ??gcode_G92_0:
   \       0x90   0x....'....        DC32     axis_codes
   \       0x94   0x....'....        DC32     mks_heating_busy
   \       0x98   0x....'....        DC32     mksCfg
   \       0x9C   0x....'....        DC32     axis_homed
   6498          }
   6499          
   6500          #if HAS_RESUME_CONTINUE
   6501          
   6502            /**
   6503             * M0: Unconditional stop - Wait for user button press on LCD
   6504             * M1: Conditional stop   - Wait for user button press on LCD
   6505             */

   \                                 In section .text, align 4
   6506            inline void gcode_M0_M1() {
   \                     _Z11gcode_M0_M1v: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   6507              const char * const args = current_command_args;
   \        0x4   0x4D2F             LDR.N    R5,??gcode_M0_M1_0
   \        0x6   0x6AAE             LDR      R6,[R5, #+40]
   6508          
   6509              millis_t codenum = 0;
   \        0x8   0x2400             MOVS     R4,#+0
   6510              bool hasP = false, hasS = false;
   \        0xA   0x4627             MOV      R7,R4
   \        0xC   0x46A0             MOV      R8,R4
   6511              if (code_seen('P')) {
   \        0xE   0x2050             MOVS     R0,#+80
   \       0x10   0x.... 0x....      BL       _Z9code_seenc
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD004             BEQ.N    ??gcode_M0_M1_1
   6512                codenum = code_value_millis(); // milliseconds to wait
   \       0x18   0x.... 0x....      BL       _Z17code_value_millisv
   \       0x1C   0x0004             MOVS     R4,R0
   6513                hasP = codenum > 0;
   \       0x1E   0xD000             BEQ.N    ??gcode_M0_M1_1
   \       0x20   0x2701             MOVS     R7,#+1
   6514              }
   6515              if (code_seen('S')) {
   \                     ??gcode_M0_M1_1: (+1)
   \       0x22   0x2053             MOVS     R0,#+83
   \       0x24   0x.... 0x....      BL       _Z9code_seenc
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD005             BEQ.N    ??gcode_M0_M1_2
   6516                codenum = code_value_millis_from_seconds(); // seconds to wait
   \       0x2C   0x.... 0x....      BL       _Z30code_value_millis_from_secondsv
   \       0x30   0x0004             MOVS     R4,R0
   6517                hasS = codenum > 0;
   \       0x32   0xD001             BEQ.N    ??gcode_M0_M1_2
   \       0x34   0xF04F 0x0801      MOV      R8,#+1
   6518              }
   6519          
   6520              #if ENABLED(ULTIPANEL)
   6521          
   6522                if (!hasP && !hasS && *args != '\0')
   \                     ??gcode_M0_M1_2: (+1)
   \       0x38   0xEA58 0x0707      ORRS     R7,R8,R7
   \       0x3C   0xD108             BNE.N    ??gcode_M0_M1_3
   \       0x3E   0xF996 0x0000      LDRSB    R0,[R6, #+0]
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD004             BEQ.N    ??gcode_M0_M1_3
   6523                  lcd_setstatus(args, true);
   \       0x46   0x2101             MOVS     R1,#+1
   \       0x48   0x4630             MOV      R0,R6
   \       0x4A   0x.... 0x....      BL       _Z13lcd_setstatusPKcb
   \       0x4E   0xE003             B.N      ??gcode_M0_M1_4
   6524                else {
   6525                  LCD_MESSAGEPGM(MSG_USERWAIT);
   \                     ??gcode_M0_M1_3: (+1)
   \       0x50   0x2100             MOVS     R1,#+0
   \       0x52   0x481D             LDR.N    R0,??gcode_M0_M1_0+0x4
   \       0x54   0x.... 0x....      BL       _Z16lcd_setstatuspgmPKch
   6526                  #if ENABLED(LCD_PROGRESS_BAR) && PROGRESS_MSG_EXPIRE > 0
   6527                    dontExpireStatus();
   6528                  #endif
   6529                }
   6530          
   6531              #else
   6532          
   6533                if (!hasP && !hasS && *args != '\0') {
   6534                  SERIAL_ECHO_START;
   6535                  SERIAL_ECHOLN(args);
   6536                }
   6537          
   6538              #endif
   6539          
   6540              KEEPALIVE_STATE(PAUSED_FOR_USER);
   \                     ??gcode_M0_M1_4: (+1)
   \       0x58   0x4E1C             LDR.N    R6,??gcode_M0_M1_0+0x8
   \       0x5A   0x2003             MOVS     R0,#+3
   \       0x5C   0x71B0             STRB     R0,[R6, #+6]
   6541              wait_for_user = true;
   \       0x5E   0x2001             MOVS     R0,#+1
   \       0x60   0x7130             STRB     R0,[R6, #+4]
   6542          
   6543              stepper.synchronize();
   \       0x62   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   6544              refresh_cmd_timeout();
   \       0x66   0x.... 0x....      BL       _Z19refresh_cmd_timeoutv
   6545          
   6546              if (codenum > 0) {
   \       0x6A   0x2C00             CMP      R4,#+0
   \       0x6C   0xD00C             BEQ.N    ??gcode_M0_M1_5
   6547                codenum += previous_cmd_ms;  // wait until this time for a click
   \       0x6E   0x6BA8             LDR      R0,[R5, #+56]
   \       0x70   0x1904             ADDS     R4,R0,R4
   6548                while (PENDING(millis(), codenum) && wait_for_user) idle();
   \                     ??gcode_M0_M1_6: (+1)
   \       0x72   0x.... 0x....      BL       HAL_GetTick
   \       0x76   0x1B00             SUBS     R0,R0,R4
   \       0x78   0xD51E             BPL.N    ??gcode_M0_M1_7
   \       0x7A   0x7930             LDRB     R0,[R6, #+4]
   \       0x7C   0x2800             CMP      R0,#+0
   \       0x7E   0xD01B             BEQ.N    ??gcode_M0_M1_7
   \       0x80   0x2000             MOVS     R0,#+0
   \       0x82   0x.... 0x....      BL       _Z4idleb
   \       0x86   0xE7F4             B.N      ??gcode_M0_M1_6
   6549              }
   6550              else {
   6551                #if ENABLED(ULTIPANEL)
   6552                  if (lcd_detected()) {
   \                     ??gcode_M0_M1_5: (+1)
   \       0x88   0x.... 0x....      BL       _Z12lcd_detectedv
   \       0x8C   0x2800             CMP      R0,#+0
   \       0x8E   0xD103             BNE.N    ??gcode_M0_M1_8
   \       0x90   0xE012             B.N      ??gcode_M0_M1_7
   6553                    while (wait_for_user) idle();
   \                     ??gcode_M0_M1_9: (+1)
   \       0x92   0x2000             MOVS     R0,#+0
   \       0x94   0x.... 0x....      BL       _Z4idleb
   \                     ??gcode_M0_M1_8: (+1)
   \       0x98   0x7930             LDRB     R0,[R6, #+4]
   \       0x9A   0x2800             CMP      R0,#+0
   \       0x9C   0xD1F9             BNE.N    ??gcode_M0_M1_9
   6554                    IS_SD_PRINTING ? LCD_MESSAGEPGM(MSG_RESUMING) : LCD_MESSAGEPGM(WELCOME_MSG);
   \       0x9E   0x480C             LDR.N    R0,??gcode_M0_M1_0+0xC
   \       0xA0   0x7880             LDRB     R0,[R0, #+2]
   \       0xA2   0x2800             CMP      R0,#+0
   \       0xA4   0xD004             BEQ.N    ??gcode_M0_M1_10
   \       0xA6   0x2100             MOVS     R1,#+0
   \       0xA8   0x480A             LDR.N    R0,??gcode_M0_M1_0+0x10
   \       0xAA   0x.... 0x....      BL       _Z16lcd_setstatuspgmPKch
   \       0xAE   0xE003             B.N      ??gcode_M0_M1_7
   \                     ??gcode_M0_M1_10: (+1)
   \       0xB0   0x2100             MOVS     R1,#+0
   \       0xB2   0x4809             LDR.N    R0,??gcode_M0_M1_0+0x14
   \       0xB4   0x.... 0x....      BL       _Z16lcd_setstatuspgmPKch
   6555                  }
   6556                #else
   6557                  while (wait_for_user) idle();
   6558                #endif
   6559              }
   6560          
   6561              wait_for_user = false;
   \                     ??gcode_M0_M1_7: (+1)
   \       0xB8   0x2000             MOVS     R0,#+0
   \       0xBA   0x7130             STRB     R0,[R6, #+4]
   6562              KEEPALIVE_STATE(IN_HANDLER);
   \       0xBC   0x2001             MOVS     R0,#+1
   \       0xBE   0x71B0             STRB     R0,[R6, #+6]
   6563            }
   \       0xC0   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   \                     ??gcode_M0_M1_0:
   \       0xC4   0x....'....        DC32     axis_relative_modes
   \       0xC8   0x....'....        DC32     MSG_USERWAIT
   \       0xCC   0x....'....        DC32     mks_heating_busy
   \       0xD0   0x....'....        DC32     card
   \       0xD4   0x....'....        DC32     _ZZ11gcode_M0_M1vEs
   \       0xD8   0x....'....        DC32     WELCOME_MSG
   6564          
   6565          #endif // HAS_RESUME_CONTINUE
   6566          
   6567          /**
   6568           * M17: Enable power on all stepper motors
   6569           */

   \                                 In section .text, align 4
   6570          inline void gcode_M17() {
   \                     _Z9gcode_M17v: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   6571            LCD_MESSAGEPGM(MSG_NO_MOVE);
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x4803             LDR.N    R0,??gcode_M17_0
   \        0x6   0x.... 0x....      BL       _Z16lcd_setstatuspgmPKch
   6572            enable_all_steppers();
   \        0xA   0xE8BD 0x4001      POP      {R0,LR}
   \        0xE   0x.... 0x....      B.W      _Z19enable_all_steppersv
   \       0x12   0xBF00             Nop      
   \                     ??gcode_M17_0:
   \       0x14   0x....'....        DC32     _ZZ9gcode_M17vEs
   6573          }
   6574          
   6575          //mks_delta		begin
   6576          /*
   6577          #if IS_KINEMATIC
   6578            #define RUNPLAN(RATE_MM_S) planner.buffer_line_kinematic(destination, RATE_MM_S, active_extruder)
   6579          #else
   6580            #define RUNPLAN(RATE_MM_S) line_to_destination(RATE_MM_S)
   6581          #endif
   6582          */

   \                                 In section .text, align 2, keep-with-next
   6583          void RUNPLAN(float RATE_MM_S)
   6584          {
   \                     _Z7RUNPLANf: (+1)
   \        0x0   0xB501             PUSH     {R0,LR}
   6585          	if(MACHINETPYE & IS_KINEMATIC)
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable136_8
   \        0x6   0xF8B0 0x0058      LDRH     R0,[R0, #+88]
   \        0xA   0xF240 0x3102      MOVW     R1,#+770
   \        0xE   0x4208             TST      R0,R1
   \       0x10   0xD007             BEQ.N    ??RUNPLAN_0
   6586          		planner.buffer_line_kinematic(destination, RATE_MM_S, active_extruder);
   \       0x12   0x.... 0x....      LDR.W    R0,??DataTable136_2
   \       0x16   0x7882             LDRB     R2,[R0, #+2]
   \       0x18   0x4669             MOV      R1,SP
   \       0x1A   0x3018             ADDS     R0,R0,#+24
   \       0x1C   0x.... 0x....      BL       _ZN7Planner21buffer_line_kinematicEPKfRS0_h
   \       0x20   0xBD01             POP      {R0,PC}
   6587          	else
   6588          		line_to_destination(RATE_MM_S);
   \                     ??RUNPLAN_0: (+1)
   \       0x22   0x9800             LDR      R0,[SP, #+0]
   \       0x24   0x.... 0x....      BL       _Z19line_to_destinationf
   6589          }
   \       0x28   0xBD01             POP      {R0,PC}          ;; return
   6590          //mks_delta		end
   6591          
   6592          #if ENABLED(PARK_HEAD_ON_PAUSE)
   6593            float resume_position[XYZE];
   6594            bool move_away_flag = false;
   6595          
   6596            inline void move_back_on_resume() {
   6597              if (!move_away_flag) return;
   6598              move_away_flag = false;
   6599          
   6600              // Set extruder to saved position
   6601              destination[E_AXIS] = current_position[E_AXIS] = resume_position[E_AXIS];
   6602              planner.set_e_position_mm(current_position[E_AXIS]);
   6603          
   6604              //#if IS_KINEMATIC	//mks_delta
   6605              if(MACHINETPYE & IS_KINEMATIC)
   6606                // Move XYZ to starting position
   6607                planner.buffer_line_kinematic(lastpos, FILAMENT_CHANGE_XY_FEEDRATE, active_extruder);
   6608              //#else
   6609              else
   6610              	{
   6611                // Move XY to starting position, then Z
   6612                destination[X_AXIS] = resume_position[X_AXIS];
   6613                destination[Y_AXIS] = resume_position[Y_AXIS];
   6614                RUNPLAN(FILAMENT_CHANGE_XY_FEEDRATE);
   6615                destination[Z_AXIS] = resume_position[Z_AXIS];
   6616                RUNPLAN(FILAMENT_CHANGE_Z_FEEDRATE);
   6617              	}
   6618          	//#endif
   6619              stepper.synchronize();
   6620          
   6621              #if ENABLED(FILAMENT_RUNOUT_SENSOR)
   6622                filament_ran_out = false;
   6623              #endif
   6624              set_current_to_destination();
   6625            }
   6626          
   6627          #endif // PARK_HEAD_ON_PAUSE
   6628          
   6629          #if ENABLED(SDSUPPORT)
   6630          
   6631            /**
   6632             * M20: List SD card to serial output
   6633             */

   \                                 In section .text, align 4
   6634            inline void gcode_M20() {
   \                     _Z9gcode_M20v: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   6635              SERIAL_PROTOCOLLNPGM(MSG_BEGIN_FILE_LIST);
   \        0x2   0x4805             LDR.N    R0,??gcode_M20_0
   \        0x4   0x.... 0x....      BL       _Z14serialprintPGMPKc
   6636              card.ls();
   \        0x8   0x4804             LDR.N    R0,??gcode_M20_0+0x4
   \        0xA   0x.... 0x....      BL       _ZN10CardReader2lsEv
   6637              SERIAL_PROTOCOLLNPGM(MSG_END_FILE_LIST);
   \        0xE   0x4804             LDR.N    R0,??gcode_M20_0+0x8
   \       0x10   0xE8BD 0x4002      POP      {R1,LR}
   \       0x14   0x.... 0x....      B.W      _Z14serialprintPGMPKc
   \                     ??gcode_M20_0:
   \       0x18   0x....'....        DC32     _ZZ9gcode_M20vEs
   \       0x1C   0x....'....        DC32     card
   \       0x20   0x....'....        DC32     _ZZ9gcode_M20vEs_0
   6638            }
   6639          
   6640            /**
   6641             * M21: Init SD Card
   6642             */

   \                                 In section .text, align 4
   6643            inline void gcode_M21() { card.initsd(); }
   \                     _Z9gcode_M21v: (+1)
   \        0x0   0x4801             LDR.N    R0,??gcode_M21_0
   \        0x2   0x.... 0x....      B.W      _ZN10CardReader6initsdEv
   \        0x6   0xBF00             Nop      
   \                     ??gcode_M21_0:
   \        0x8   0x....'....        DC32     card
   6644          
   6645            /**
   6646             * M22: Release SD Card
   6647             */

   \                                 In section .text, align 4
   6648            inline void gcode_M22() { card.release(); }
   \                     _Z9gcode_M22v: (+1)
   \        0x0   0x4801             LDR.N    R0,??gcode_M22_0
   \        0x2   0x.... 0x....      B.W      _ZN10CardReader7releaseEv
   \        0x6   0xBF00             Nop      
   \                     ??gcode_M22_0:
   \        0x8   0x....'....        DC32     card
   6649          
   6650            /**
   6651             * M23: Open a file
   6652             */
   6653          #ifdef USE_MKS_WIFI    

   \                                 In section .text, align 4
   6654            inline void gcode_M23() { 
   \                     _Z9gcode_M23v: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   6655            	if(card.openFile(current_command_args, true) < 0)
   \        0x2   0x4C17             LDR.N    R4,??gcode_M23_0
   \        0x4   0x4D17             LDR.N    R5,??gcode_M23_0+0x4
   \        0x6   0x2300             MOVS     R3,#+0
   \        0x8   0x2201             MOVS     R2,#+1
   \        0xA   0x6AA9             LDR      R1,[R5, #+40]
   \        0xC   0x4620             MOV      R0,R4
   \        0xE   0x.... 0x....      BL       _ZN10CardReader8openFileEPcbb
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD522             BPL.N    ??gcode_M23_1
   6656            	{
   6657            		/*for 8.3 principle*/
   6658          		char *gSuffix = strstr((char *)current_command_args, ".g");
   \       0x16   0x6AAD             LDR      R5,[R5, #+40]
   \       0x18   0x4913             LDR.N    R1,??gcode_M23_0+0x8
   \       0x1A   0x4628             MOV      R0,R5
   \       0x1C   0x.... 0x....      BL       __iar_Strstr
   6659          		if(!gSuffix)
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD103             BNE.N    ??gcode_M23_2
   6660          		{
   6661          			gSuffix = strstr((char *)current_command_args, ".G");		
   \       0x24   0x4911             LDR.N    R1,??gcode_M23_0+0xC
   \       0x26   0x4628             MOV      R0,R5
   \       0x28   0x.... 0x....      BL       __iar_Strstr
   6662          		}
   6663          		if(gSuffix)
   \                     ??gcode_M23_2: (+1)
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD015             BEQ.N    ??gcode_M23_1
   6664          		{
   6665          			*(gSuffix + 2) = '\0';
   \       0x30   0x2100             MOVS     R1,#+0
   \       0x32   0x7081             STRB     R1,[R0, #+2]
   6666          			if((uint32_t)gSuffix - (uint32_t)current_command_args > 8)
   \       0x34   0x1B40             SUBS     R0,R0,R5
   \       0x36   0x2809             CMP      R0,#+9
   \       0x38   0xD307             BCC.N    ??gcode_M23_3
   6667          			{
   6668          				current_command_args[7] = '~';
   \       0x3A   0x207E             MOVS     R0,#+126
   \       0x3C   0x71E8             STRB     R0,[R5, #+7]
   6669          				current_command_args[8] = '.';
   \       0x3E   0x202E             MOVS     R0,#+46
   \       0x40   0x7228             STRB     R0,[R5, #+8]
   6670          				current_command_args[9] = 'g';
   \       0x42   0x2067             MOVS     R0,#+103
   \       0x44   0x7268             STRB     R0,[R5, #+9]
   6671          				current_command_args[10] = '\0';
   \       0x46   0x4608             MOV      R0,R1
   \       0x48   0x72A8             STRB     R0,[R5, #+10]
   6672          			}
   6673          			card.openFile(current_command_args, true) ;
   \                     ??gcode_M23_3: (+1)
   \       0x4A   0x460B             MOV      R3,R1
   \       0x4C   0x2201             MOVS     R2,#+1
   \       0x4E   0x4629             MOV      R1,R5
   \       0x50   0x4620             MOV      R0,R4
   \       0x52   0xB001             ADD      SP,SP,#+4
   \       0x54   0xE8BD 0x4030      POP      {R4,R5,LR}
   \       0x58   0x.... 0x....      B.W      _ZN10CardReader8openFileEPcbb
   6674          		}
   6675            	}
   6676            }
   \                     ??gcode_M23_1: (+1)
   \       0x5C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \       0x5E   0xBF00             Nop      
   \                     ??gcode_M23_0:
   \       0x60   0x....'....        DC32     card
   \       0x64   0x....'....        DC32     axis_relative_modes
   \       0x68   0x....'....        DC32     _ZZ9gcode_M23vEs
   \       0x6C   0x....'....        DC32     _ZZ9gcode_M23vEs_0
   6677          #else
   6678          inline void gcode_M23() { card.openFile(current_command_args, true); }
   6679          #endif
   6680            /**
   6681             * M24: Start or Resume SD Print
   6682             */

   \                                 In section .text, align 4
   6683            inline void gcode_M24() {
   \                     _Z9gcode_M24v: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   6684            
   6685          	mks_resumePrint();
   \        0x2   0x.... 0x....      BL       mks_resumePrint
   6686          
   6687              #if ENABLED(PARK_HEAD_ON_PAUSE)
   6688                move_back_on_resume();
   6689              #endif
   6690          
   6691          #ifdef USE_MKS_WIFI
   6692              if(card.lastOpenOk())
   \        0x6   0x4C07             LDR.N    R4,??gcode_M24_0
   \        0x8   0x4620             MOV      R0,R4
   \        0xA   0x.... 0x....      BL       _ZN10CardReader10lastOpenOkEv
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD007             BEQ.N    ??gcode_M24_1
   6693          #endif		
   6694             {
   6695              card.startFileprint();
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0x.... 0x....      BL       _ZN10CardReader14startFileprintEv
   6696              print_job_timer.start();
   \       0x18   0x4803             LDR.N    R0,??gcode_M24_0+0x4
   \       0x1A   0xE8BD 0x4010      POP      {R4,LR}
   \       0x1E   0x.... 0x....      B.W      _ZN9Stopwatch5startEv
   6697            }
   6698            }
   \                     ??gcode_M24_1: (+1)
   \       0x22   0xBD10             POP      {R4,PC}          ;; return
   \                     ??gcode_M24_0:
   \       0x24   0x....'....        DC32     card
   \       0x28   0x....'....        DC32     mks_heating_busy+0x388
   6699          
   6700            /**
   6701             * M25: Pause SD Print
   6702             */

   \                                 In section .text, align 4
   6703            inline void gcode_M25() {
   \                     _Z9gcode_M25v: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   6704              card.pauseSDPrint();
   \        0x2   0x4805             LDR.N    R0,??gcode_M25_0
   \        0x4   0x.... 0x....      BL       _ZN10CardReader12pauseSDPrintEv
   6705              print_job_timer.pause();
   \        0x8   0x4804             LDR.N    R0,??gcode_M25_0+0x4
   \        0xA   0x.... 0x....      BL       _ZN9Stopwatch5pauseEv
   6706          
   6707              #if ENABLED(PARK_HEAD_ON_PAUSE)
   6708                enqueue_and_echo_commands_P(PSTR("M125")); // Must be enqueued with pauseSDPrint set to be last in the buffer
   6709              #endif
   6710          	mksReprint.mks_printer_state = MKS_PAUSING;
   \        0xE   0x20A8             MOVS     R0,#+168
   \       0x10   0x4903             LDR.N    R1,??gcode_M25_0+0x8
   \       0x12   0xF881 0x0068      STRB     R0,[R1, #+104]
   6711            }
   \       0x16   0xBD01             POP      {R0,PC}          ;; return
   \                     ??gcode_M25_0:
   \       0x18   0x....'....        DC32     card
   \       0x1C   0x....'....        DC32     mks_heating_busy+0x388
   \       0x20   0x....'....        DC32     mksReprint
   6712          
   6713            /**
   6714             * M26: Set SD Card file index
   6715             */

   \                                 In section .text, align 4
   6716            inline void gcode_M26() {
   \                     _Z9gcode_M26v: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   6717              if (card.cardOK && code_seen('S'))
   \        0x2   0x4C09             LDR.N    R4,??gcode_M26_0
   \        0x4   0x78E0             LDRB     R0,[R4, #+3]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD00C             BEQ.N    ??gcode_M26_1
   \        0xA   0x2053             MOVS     R0,#+83
   \        0xC   0x.... 0x....      BL       _Z9code_seenc
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD007             BEQ.N    ??gcode_M26_1
   6718                card.setIndex(code_value_long());
   \       0x14   0x.... 0x....      BL       _Z15code_value_longv
   \       0x18   0x4601             MOV      R1,R0
   \       0x1A   0x4620             MOV      R0,R4
   \       0x1C   0xE8BD 0x4010      POP      {R4,LR}
   \       0x20   0x.... 0x....      B.W      _ZN10CardReader8setIndexEl
   6719            }
   \                     ??gcode_M26_1: (+1)
   \       0x24   0xBD10             POP      {R4,PC}          ;; return
   \       0x26   0xBF00             Nop      
   \                     ??gcode_M26_0:
   \       0x28   0x....'....        DC32     card
   6720          
   6721            /**
   6722             * M27: Get SD Card status
   6723             */

   \                                 In section .text, align 4
   6724            inline void gcode_M27() { card.getStatus(); }
   \                     _Z9gcode_M27v: (+1)
   \        0x0   0x4801             LDR.N    R0,??gcode_M27_0
   \        0x2   0x.... 0x....      B.W      _ZN10CardReader9getStatusEv
   \        0x6   0xBF00             Nop      
   \                     ??gcode_M27_0:
   \        0x8   0x....'....        DC32     card
   6725          
   6726            /**
   6727             * M28: Start SD Write
   6728             */

   \                                 In section .text, align 4
   6729            inline void gcode_M28() { card.openFile(current_command_args, false); }
   \                     _Z9gcode_M28v: (+1)
   \        0x0   0x2300             MOVS     R3,#+0
   \        0x2   0x461A             MOV      R2,R3
   \        0x4   0x4802             LDR.N    R0,??gcode_M28_0
   \        0x6   0x6A81             LDR      R1,[R0, #+40]
   \        0x8   0x4802             LDR.N    R0,??gcode_M28_0+0x4
   \        0xA   0x.... 0x....      B.W      _ZN10CardReader8openFileEPcbb
   \        0xE   0xBF00             Nop      
   \                     ??gcode_M28_0:
   \       0x10   0x....'....        DC32     axis_relative_modes
   \       0x14   0x....'....        DC32     card
   6730          
   6731            /**
   6732             * M29: Stop SD Write
   6733             * Processed in write to file routine above
   6734             */

   \                                 In section .text, align 2
   6735            inline void gcode_M29() {
   6736              // card.saving = false;
   6737            }
   \                     _Z9gcode_M29v: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   6738          
   6739            /**
   6740             * M30 <filename>: Delete SD Card file
   6741             */

   \                                 In section .text, align 4
   6742            inline void gcode_M30() {
   \                     _Z9gcode_M30v: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   6743              if (card.cardOK) {
   \        0x2   0x4C08             LDR.N    R4,??gcode_M30_0
   \        0x4   0x78E0             LDRB     R0,[R4, #+3]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD00A             BEQ.N    ??gcode_M30_1
   6744                card.closefile();
   \        0xA   0x2100             MOVS     R1,#+0
   \        0xC   0x4620             MOV      R0,R4
   \        0xE   0x.... 0x....      BL       _ZN10CardReader9closefileEb
   6745                card.removeFile(current_command_args);
   \       0x12   0x4805             LDR.N    R0,??gcode_M30_0+0x4
   \       0x14   0x6A81             LDR      R1,[R0, #+40]
   \       0x16   0x4620             MOV      R0,R4
   \       0x18   0xE8BD 0x4010      POP      {R4,LR}
   \       0x1C   0x.... 0x....      B.W      _ZN10CardReader10removeFileEPc
   6746              }
   6747            }
   \                     ??gcode_M30_1: (+1)
   \       0x20   0xBD10             POP      {R4,PC}          ;; return
   \       0x22   0xBF00             Nop      
   \                     ??gcode_M30_0:
   \       0x24   0x....'....        DC32     card
   \       0x28   0x....'....        DC32     axis_relative_modes
   6748          
   6749          #endif // SDSUPPORT
   6750          
   6751          /**
   6752           * M31: Get the time since the start of SD Print (or last M109)
   6753           */

   \                                 In section .text, align 4
   6754          inline void gcode_M31() {
   \                     _Z9gcode_M31v: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
   6755            char buffer[21];
   6756            duration_t elapsed = print_job_timer.duration();
   \        0x4   0x4C13             LDR.N    R4,??gcode_M31_0
   \        0x6   0xF504 0x7062      ADD      R0,R4,#+904
   \        0xA   0x.... 0x....      BL       _ZN9Stopwatch8durationEv
   \        0xE   0x9000             STR      R0,[SP, #+0]
   \       0x10   0x4669             MOV      R1,SP
   \       0x12   0xA801             ADD      R0,SP,#+4
   \       0x14   0x.... 0x....      BL       _ZN10duration_tC1ERKj
   6757            elapsed.toString(buffer);
   \       0x18   0xA902             ADD      R1,SP,#+8
   \       0x1A   0x.... 0x....      BL       _ZNK10duration_t8toStringEPc
   6758            lcd_setstatus(buffer);
   \       0x1E   0x2100             MOVS     R1,#+0
   \       0x20   0xA802             ADD      R0,SP,#+8
   \       0x22   0x.... 0x....      BL       _Z13lcd_setstatusPKcb
   6759          
   6760            SERIAL_ECHO_START;
   \       0x26   0x480C             LDR.N    R0,??gcode_M31_0+0x4
   \       0x28   0x.... 0x....      BL       _Z14serialprintPGMPKc
   6761            SERIAL_ECHOLNPAIR("Print time: ", buffer);
   \       0x2C   0xA902             ADD      R1,SP,#+8
   \       0x2E   0x480B             LDR.N    R0,??gcode_M31_0+0x8
   \       0x30   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
   \       0x34   0x79E0             LDRB     R0,[R4, #+7]
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD104             BNE.N    ??gcode_M31_1
   \       0x3A   0x210A             MOVS     R1,#+10
   \       0x3C   0x4808             LDR.N    R0,??gcode_M31_0+0xC
   \       0x3E   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \       0x42   0xE004             B.N      ??gcode_M31_2
   \                     ??gcode_M31_1: (+1)
   \       0x44   0x2200             MOVS     R2,#+0
   \       0x46   0x210A             MOVS     R1,#+10
   \       0x48   0x4806             LDR.N    R0,??gcode_M31_0+0x10
   \       0x4A   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   6762          }
   \                     ??gcode_M31_2: (+1)
   \       0x4E   0xB008             ADD      SP,SP,#+32
   \       0x50   0xBD10             POP      {R4,PC}          ;; return
   \       0x52   0xBF00             Nop      
   \                     ??gcode_M31_0:
   \       0x54   0x....'....        DC32     mks_heating_busy
   \       0x58   0x....'....        DC32     echomagic
   \       0x5C   0x....'....        DC32     _ZZ9gcode_M31vEs
   \       0x60   0x....'....        DC32     customizedSerial
   \       0x64   0x....'....        DC32     serial2
   6763          
   6764          #if ENABLED(SDSUPPORT)
   6765          
   6766            /**
   6767             * M32: Select file and start SD Print
   6768             */

   \                                 In section .text, align 4
   6769            inline void gcode_M32() {
   \                     _Z9gcode_M32v: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   6770              if (card.sdprinting)
   \        0x2   0x4C1E             LDR.N    R4,??gcode_M32_0
   \        0x4   0x78A0             LDRB     R0,[R4, #+2]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD001             BEQ.N    ??gcode_M32_1
   6771                stepper.synchronize();
   \        0xA   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   6772          
   6773              char* namestartpos = strchr(current_command_args, '!');  // Find ! to indicate filename string start.
   \                     ??gcode_M32_1: (+1)
   \        0xE   0x4D1C             LDR.N    R5,??gcode_M32_0+0x4
   \       0x10   0x6AAE             LDR      R6,[R5, #+40]
   \       0x12   0x2121             MOVS     R1,#+33
   \       0x14   0x4630             MOV      R0,R6
   \       0x16   0x.... 0x....      BL       __iar_Strchr
   6774              if (!namestartpos)
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD000             BEQ.N    ??gcode_M32_2
   6775                namestartpos = current_command_args; // Default name position, 4 letters after the M
   6776              else
   6777                namestartpos++; //to skip the '!'
   \       0x1E   0x1C46             ADDS     R6,R0,#+1
   6778          
   6779              bool call_procedure = code_seen('P') && (seen_pointer < namestartpos);
   \                     ??gcode_M32_2: (+1)
   \       0x20   0x2050             MOVS     R0,#+80
   \       0x22   0x.... 0x....      BL       _Z9code_seenc
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD004             BEQ.N    ??gcode_M32_3
   \       0x2A   0x6AE8             LDR      R0,[R5, #+44]
   \       0x2C   0x42B0             CMP      R0,R6
   \       0x2E   0x41BF             SBCS     R7,R7,R7
   \       0x30   0x0FFF             LSRS     R7,R7,#+31
   \       0x32   0xE000             B.N      ??gcode_M32_4
   \                     ??gcode_M32_3: (+1)
   \       0x34   0x2700             MOVS     R7,#+0
   6780          
   6781              if (card.cardOK) {
   \                     ??gcode_M32_4: (+1)
   \       0x36   0x78E0             LDRB     R0,[R4, #+3]
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD01D             BEQ.N    ??gcode_M32_5
   6782                card.openFile(namestartpos, true, call_procedure);
   \       0x3C   0x463B             MOV      R3,R7
   \       0x3E   0x2201             MOVS     R2,#+1
   \       0x40   0x4631             MOV      R1,R6
   \       0x42   0x4620             MOV      R0,R4
   \       0x44   0x.... 0x....      BL       _ZN10CardReader8openFileEPcbb
   6783          
   6784                if (code_seen('S') && seen_pointer < namestartpos) // "S" (must occur _before_ the filename!)
   \       0x48   0x2053             MOVS     R0,#+83
   \       0x4A   0x.... 0x....      BL       _Z9code_seenc
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD008             BEQ.N    ??gcode_M32_6
   \       0x52   0x6AE8             LDR      R0,[R5, #+44]
   \       0x54   0x42B0             CMP      R0,R6
   \       0x56   0xD205             BCS.N    ??gcode_M32_6
   6785                  card.setIndex(code_value_long());
   \       0x58   0x.... 0x....      BL       _Z15code_value_longv
   \       0x5C   0x4601             MOV      R1,R0
   \       0x5E   0x4620             MOV      R0,R4
   \       0x60   0x.... 0x....      BL       _ZN10CardReader8setIndexEl
   6786          
   6787                card.startFileprint();
   \                     ??gcode_M32_6: (+1)
   \       0x64   0x4620             MOV      R0,R4
   \       0x66   0x.... 0x....      BL       _ZN10CardReader14startFileprintEv
   6788          
   6789                // Procedure calls count as normal print time.
   6790                if (!call_procedure) print_job_timer.start();
   \       0x6A   0x2F00             CMP      R7,#+0
   \       0x6C   0xD104             BNE.N    ??gcode_M32_5
   \       0x6E   0x4805             LDR.N    R0,??gcode_M32_0+0x8
   \       0x70   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \       0x74   0x.... 0x....      B.W      _ZN9Stopwatch5startEv
   6791              }
   6792            }
   \                     ??gcode_M32_5: (+1)
   \       0x78   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   \       0x7A   0xBF00             Nop      
   \                     ??gcode_M32_0:
   \       0x7C   0x....'....        DC32     card
   \       0x80   0x....'....        DC32     axis_relative_modes
   \       0x84   0x....'....        DC32     mks_heating_busy+0x388
   6793          
   6794            #if ENABLED(LONG_FILENAME_HOST_SUPPORT)
   6795          
   6796              /**
   6797               * M33: Get the long full path of a file or folder
   6798               *
   6799               * Parameters:
   6800               *   <dospath> Case-insensitive DOS-style path to a file or folder
   6801               *
   6802               * Example:
   6803               *   M33 miscel~1/armchair/armcha~1.gco
   6804               *
   6805               * Output:
   6806               *   /Miscellaneous/Armchair/Armchair.gcode
   6807               */
   6808              inline void gcode_M33() {
   6809                card.printLongPath(current_command_args);
   6810              }
   6811          
   6812            #endif
   6813          
   6814            #if ENABLED(SDCARD_SORT_ALPHA) && ENABLED(SDSORT_GCODE)
   6815              /**
   6816               * M34: Set SD Card Sorting Options
   6817               */
   6818              inline void gcode_M34() {
   6819                if (code_seen('S')) card.setSortOn(code_value_bool());
   6820                if (code_seen('F')) {
   6821                  int v = code_value_long();
   6822                  card.setSortFolders(v < 0 ? -1 : v > 0 ? 1 : 0);
   6823                }
   6824                //if (code_seen('R')) card.setSortReverse(code_value_bool());
   6825              }
   6826            #endif // SDCARD_SORT_ALPHA && SDSORT_GCODE
   6827          
   6828            /**
   6829             * M928: Start SD Write
   6830             */

   \                                 In section .text, align 4
   6831            inline void gcode_M928() {
   6832              card.openLogFile(current_command_args);
   \                     _Z10gcode_M928v: (+1)
   \        0x0   0x4802             LDR.N    R0,??gcode_M928_0
   \        0x2   0x6A81             LDR      R1,[R0, #+40]
   \        0x4   0x4802             LDR.N    R0,??gcode_M928_0+0x4
   \        0x6   0x.... 0x....      B.W      _ZN10CardReader11openLogFileEPc
   \        0xA   0xBF00             Nop      
   \                     ??gcode_M928_0:
   \        0xC   0x....'....        DC32     axis_relative_modes
   \       0x10   0x....'....        DC32     card
   6833            }
   6834          
   6835          #endif // SDSUPPORT
   6836          
   6837          /**
   6838           * Sensitive pin test for M42, M226
   6839           */

   \                                 In section .text, align 2, keep-with-next
   6840          static bool pin_is_protected(uint8_t pin) {
   6841            static const int sensitive_pins[] = SENSITIVE_PINS;
   6842            for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
   \                     _ZN37_INTERNAL_15_Marlin_main_cpp_3178531916pin_is_protectedEh: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0xE000             B.N      ??pin_is_protected_0
   \                     ??pin_is_protected_1: (+1)
   \        0x4   0x1C49             ADDS     R1,R1,#+1
   \                     ??pin_is_protected_0: (+1)
   \        0x6   0x460A             MOV      R2,R1
   \        0x8   0xB2D2             UXTB     R2,R2
   \        0xA   0x2A28             CMP      R2,#+40
   \        0xC   0xD20A             BCS.N    ??pin_is_protected_2
   6843              if (sensitive_pins[i] == pin) return true;
   \        0xE   0x.... 0x....      ADR.W    R2,`pin_is_protected(uint8_t)::sensitive_pins`
   \       0x12   0x460B             MOV      R3,R1
   \       0x14   0xB2DB             UXTB     R3,R3
   \       0x16   0xF852 0x2023      LDR      R2,[R2, R3, LSL #+2]
   \       0x1A   0x4603             MOV      R3,R0
   \       0x1C   0x429A             CMP      R2,R3
   \       0x1E   0xD1F1             BNE.N    ??pin_is_protected_1
   \       0x20   0x2001             MOVS     R0,#+1
   \       0x22   0x4770             BX       LR
   6844            return false;
   \                     ??pin_is_protected_2: (+1)
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x4770             BX       LR               ;; return
   6845          }

   \                                 In section .text, align 4, keep-with-next
   \                     `pin_is_protected(uint8_t)::sensitive_pins`:
   \        0x0   0x0000'0000        DC32 0, 1, 3, 2, 14, 4, 4, 6, 5, 14, 7, 7, 9, 8, 14, 10, 11, 11, -1, 15
   \              0x0000'0001  
   \              0x0000'0003  
   \              0x0000'0002  
   \              0x0000'000E  
   \              0x0000'0004  
   \              0x0000'0004  
   \              0x0000'0006  
   \              0x0000'0005  
   \              0x0000'000E  
   \              0x0000'0007  
   \              0x0000'0007  
   \              0x0000'0009  
   \              0x0000'0008  
   \              0x0000'000E  
   \              0x0000'000A  
   \              0x0000'000B  
   \              0x0000'000B  
   \              0xFFFF'FFFF  
   \              0x0000'000F  
   \       0x50   0x0000'0011        DC32 17, -1, -1, -1, 13, 12, 30, -1, -1, 15, 79, 16, -1, 78, -1, -1, -1
   \              0xFFFF'FFFF  
   \              0xFFFF'FFFF  
   \              0xFFFF'FFFF  
   \              0x0000'000D  
   \              0x0000'000C  
   \              0x0000'001E  
   \              0xFFFF'FFFF  
   \              0xFFFF'FFFF  
   \              0x0000'000F  
   \              0x0000'004F  
   \              0x0000'0010  
   \              0xFFFF'FFFF  
   \              0x0000'004E  
   \              0xFFFF'FFFF  
   \              0xFFFF'FFFF  
   \              0xFFFF'FFFF  
   \       0x94   0xFFFF'FFFF        DC32 -1, -1, -1
   \              0xFFFF'FFFF  
   \              0xFFFF'FFFF  
   6846          
   6847          /**
   6848           * M42: Change pin status via GCode
   6849           *
   6850           *  P<pin>  Pin number (LED if omitted)
   6851           *  S<byte> Pin status from 0 - 255
   6852           */

   \                                 In section .text, align 4
   6853          inline void gcode_M42() {
   \                     _Z9gcode_M42v: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   6854            if (!code_seen('S')) return;
   \        0x2   0x2053             MOVS     R0,#+83
   \        0x4   0x.... 0x....      BL       _Z9code_seenc
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD035             BEQ.N    ??gcode_M42_1
   6855          
   6856            int pin_status = code_value_int();
   \        0xC   0x.... 0x....      BL       _Z14code_value_intv
   \       0x10   0x4604             MOV      R4,R0
   6857            if (!WITHIN(pin_status, 0, 255)) return;
   \       0x12   0xF5B4 0x7F80      CMP      R4,#+256
   \       0x16   0xD22F             BCS.N    ??gcode_M42_1
   6858          
   6859            int pin_number = code_seen('P') ? code_value_int() : LED_PIN;
   \       0x18   0x2050             MOVS     R0,#+80
   \       0x1A   0x.... 0x....      BL       _Z9code_seenc
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD003             BEQ.N    ??gcode_M42_2
   \       0x22   0x.... 0x....      BL       _Z14code_value_intv
   \       0x26   0x4605             MOV      R5,R0
   \       0x28   0xE001             B.N      ??gcode_M42_3
   \                     ??gcode_M42_2: (+1)
   \       0x2A   0xF04F 0x35FF      MOV      R5,#-1
   6860            if (pin_number < 0) return;
   \                     ??gcode_M42_3: (+1)
   \       0x2E   0x2D00             CMP      R5,#+0
   \       0x30   0xD422             BMI.N    ??gcode_M42_1
   6861          
   6862            if (pin_is_protected(pin_number)) {
   \       0x32   0x4628             MOV      R0,R5
   \       0x34   0xB2C0             UXTB     R0,R0
   \       0x36   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531916pin_is_protectedEh
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD007             BEQ.N    ??gcode_M42_4
   6863              SERIAL_ERROR_START;
   \       0x3E   0x480F             LDR.N    R0,??gcode_M42_0
   \       0x40   0x.... 0x....      BL       _Z14serialprintPGMPKc
   6864              SERIAL_ERRORLNPGM(MSG_ERR_PROTECTED_PIN);
   \       0x44   0x480E             LDR.N    R0,??gcode_M42_0+0x4
   \       0x46   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \       0x4A   0x.... 0x....      B.W      _Z14serialprintPGMPKc
   6865              return;
   6866            }
   6867          
   6868            pinMode(pin_number, OUTPUT);
   6869            digitalWrite(pin_number, pin_status);
   \                     ??gcode_M42_4: (+1)
   \       0x4E   0x2D00             CMP      R5,#+0
   \       0x50   0x4622             MOV      R2,R4
   \       0x52   0xB252             SXTB     R2,R2
   \       0x54   0xD408             BMI.N    ??gcode_M42_5
   \       0x56   0x480B             LDR.N    R0,??gcode_M42_0+0x8
   \       0x58   0xF830 0x1015      LDRH     R1,[R0, R5, LSL #+1]
   \       0x5C   0x480A             LDR.N    R0,??gcode_M42_0+0xC
   \       0x5E   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \       0x62   0x.... 0x....      BL       HAL_GPIO_WritePin
   \       0x66   0xE003             B.N      ??gcode_M42_6
   \                     ??gcode_M42_5: (+1)
   \       0x68   0x2100             MOVS     R1,#+0
   \       0x6A   0x4608             MOV      R0,R1
   \       0x6C   0x.... 0x....      BL       HAL_GPIO_WritePin
   6870            //analogWrite(pin_number, pin_status);	/*--mks--*/
   6871          
   6872            #if FAN_COUNT > 0
   6873              switch (pin_number) {
   \                     ??gcode_M42_6: (+1)
   \       0x70   0x2D11             CMP      R5,#+17
   \       0x72   0xD101             BNE.N    ??gcode_M42_1
   6874                #if HAS_FAN0
   6875                  case FAN_PIN: fanSpeeds[0] = pin_status; break;
   \       0x74   0x4805             LDR.N    R0,??gcode_M42_0+0x10
   \       0x76   0x6004             STR      R4,[R0, #+0]
   6876                #endif
   6877                #if HAS_FAN1
   6878                  case FAN1_PIN: fanSpeeds[1] = pin_status; break;
   6879                #endif
   6880                #if HAS_FAN2
   6881                  case FAN2_PIN: fanSpeeds[2] = pin_status; break;
   6882                #endif
   6883              }
   6884            #endif
   6885          }
   \                     ??gcode_M42_1: (+1)
   \       0x78   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \       0x7A   0xBF00             Nop      
   \                     ??gcode_M42_0:
   \       0x7C   0x....'....        DC32     errormagic
   \       0x80   0x....'....        DC32     _ZZ9gcode_M42vEs
   \       0x84   0x....'....        DC32     gArrayGpioPin
   \       0x88   0x....'....        DC32     gArrayGpioPort
   \       0x8C   0x....'....        DC32     fanSpeeds
   6886          
   6887          #if ENABLED(PINS_DEBUGGING)
   6888          
   6889            #include "pinsDebug.h"
   6890          
   6891            inline void toggle_pins() {
   6892              const bool I_flag = code_seen('I') && code_value_bool();
   6893              const int repeat = code_seen('R') ? code_value_int() : 1,
   6894                        start = code_seen('S') ? code_value_int() : 0,
   6895                        end = code_seen('E') ? code_value_int() : NUM_DIGITAL_PINS - 1,
   6896                        wait = code_seen('W') ? code_value_int() : 500;
   6897          
   6898              for (uint8_t pin = start; pin <= end; pin++) {
   6899                if (!I_flag && pin_is_protected(pin)) {
   6900                  SERIAL_ECHOPAIR("Sensitive Pin: ", pin);
   6901                  SERIAL_ECHOLNPGM(" untouched.");
   6902                }
   6903                else {
   6904                  SERIAL_ECHOPAIR("Pulsing Pin: ", pin);
   6905                  pinMode(pin, OUTPUT);
   6906                  for (int16_t j = 0; j < repeat; j++) {
   6907                    digitalWrite(pin, 0);
   6908                    safe_delay(wait);
   6909                    digitalWrite(pin, 1);
   6910                    safe_delay(wait);
   6911                    digitalWrite(pin, 0);
   6912                    safe_delay(wait);
   6913                  }
   6914                }
   6915                SERIAL_CHAR('\n');
   6916              }
   6917              SERIAL_ECHOLNPGM("Done.");
   6918          
   6919            } // toggle_pins
   6920          
   6921            inline void servo_probe_test() {
   6922              #if !(NUM_SERVOS > 0 && HAS_SERVO_0)
   6923          
   6924                SERIAL_ERROR_START;
   6925                SERIAL_ERRORLNPGM("SERVO not setup");
   6926          
   6927              #elif !HAS_Z_SERVO_ENDSTOP
   6928          
   6929                SERIAL_ERROR_START;
   6930                SERIAL_ERRORLNPGM("Z_ENDSTOP_SERVO_NR not setup");
   6931          
   6932              #else
   6933          
   6934                const uint8_t probe_index = code_seen('P') ? code_value_byte() : Z_ENDSTOP_SERVO_NR;
   6935          
   6936                SERIAL_PROTOCOLLNPGM("Servo probe test");
   6937                SERIAL_PROTOCOLLNPAIR(".  using index:  ", probe_index);
   6938                SERIAL_PROTOCOLLNPAIR(".  deploy angle: ", z_servo_angle[0]);
   6939                SERIAL_PROTOCOLLNPAIR(".  stow angle:   ", z_servo_angle[1]);
   6940          
   6941                bool probe_inverting;
   6942          
   6943                //#if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
   6944                uint8_t PROBE_TEST_PIN = 0;
   6945          	  if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
   6946          	  	{
   6947          
   6948                 // #define PROBE_TEST_PIN Z_MIN_PIN
   6949          		PROBE_TEST_PIN = Z_MIN_PIN;
   6950          
   6951                  SERIAL_PROTOCOLLNPAIR(". probe uses Z_MIN pin: ", PROBE_TEST_PIN);
   6952                  SERIAL_PROTOCOLLNPGM(". uses Z_MIN_ENDSTOP_INVERTING (ignores Z_MIN_PROBE_ENDSTOP_INVERTING)");
   6953                  SERIAL_PROTOCOLPGM(". Z_MIN_ENDSTOP_INVERTING: ");
   6954          
   6955          		/*--mks cfg begin-- Z_MIN_ENDSTOP_INVERTING */
   6956          		/*
   6957          		#if Z_MIN_ENDSTOP_INVERTING
   6958                    SERIAL_PROTOCOLLNPGM("true");
   6959                  #else
   6960                    SERIAL_PROTOCOLLNPGM("false");
   6961                  #endif
   6962          		*/
   6963          		if(Z_MIN_ENDSTOP_INVERTING)
   6964          			SERIAL_PROTOCOLLNPGM("true");
   6965          		else
   6966          			SERIAL_PROTOCOLLNPGM("false");
   6967          		/*--mks cfg end-- Z_MIN_ENDSTOP_INVERTING */
   6968          
   6969                  probe_inverting = Z_MIN_ENDSTOP_INVERTING;
   6970          	  	}
   6971                //#elif ENABLED(Z_MIN_PROBE_ENDSTOP)
   6972          	  else if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN
   6973          	  	{
   6974          
   6975                  //#define PROBE_TEST_PIN Z_MIN_PROBE_PIN
   6976          		PROBE_TEST_PIN = Z_MAX_PIN;
   6977                  SERIAL_PROTOCOLLNPAIR(". probe uses Z_MIN_PROBE_PIN: ", PROBE_TEST_PIN);
   6978                  SERIAL_PROTOCOLLNPGM(". uses Z_MIN_PROBE_ENDSTOP_INVERTING (ignores Z_MIN_ENDSTOP_INVERTING)");
   6979                  SERIAL_PROTOCOLPGM(". Z_MIN_PROBE_ENDSTOP_INVERTING: ");
   6980          
   6981          	/*--mks cfg begin-- Z_MIN_ENDSTOP_INVERTING */
   6982          	/*
   6983                  #if Z_MIN_PROBE_ENDSTOP_INVERTING
   6984                    SERIAL_PROTOCOLLNPGM("true");
   6985                  #else
   6986                    SERIAL_PROTOCOLLNPGM("false");
   6987                  #endif
   6988          		*/
   6989          		if(Z_MIN_PROBE_ENDSTOP_INVERTING)
   6990          			SERIAL_PROTOCOLLNPGM("true");
   6991          			else
   6992          				SERIAL_PROTOCOLLNPGM("false");
   6993          	/*--mks cfg end-- Z_MIN_ENDSTOP_INVERTING */
   6994          
   6995                  probe_inverting = Z_MIN_PROBE_ENDSTOP_INVERTING;
   6996          	  	}
   6997                //#endif
   6998          
   6999                SERIAL_PROTOCOLLNPGM(". deploy & stow 4 times");
   7000                pinMode(PROBE_TEST_PIN, INPUT_PULLUP);
   7001                bool deploy_state;
   7002                bool stow_state;
   7003                for (uint8_t i = 0; i < 4; i++) {
   7004                  servo[probe_index].move(z_servo_angle[0]); //deploy
   7005                  safe_delay(500);
   7006                  deploy_state = digitalRead(PROBE_TEST_PIN);
   7007                  servo[probe_index].move(z_servo_angle[1]); //stow
   7008                  safe_delay(500);
   7009                  stow_state = digitalRead(PROBE_TEST_PIN);
   7010                }
   7011                if (probe_inverting != deploy_state) SERIAL_PROTOCOLLNPGM("WARNING - INVERTING setting probably backwards");
   7012          
   7013                refresh_cmd_timeout();
   7014          
   7015                if (deploy_state != stow_state) {
   7016                  SERIAL_PROTOCOLLNPGM("BLTouch clone detected");
   7017                  if (deploy_state) {
   7018                    SERIAL_PROTOCOLLNPGM(".  DEPLOYED state: HIGH (logic 1)");
   7019                    SERIAL_PROTOCOLLNPGM(".  STOWED (triggered) state: LOW (logic 0)");
   7020                  }
   7021                  else {
   7022                    SERIAL_PROTOCOLLNPGM(".  DEPLOYED state: LOW (logic 0)");
   7023                    SERIAL_PROTOCOLLNPGM(".  STOWED (triggered) state: HIGH (logic 1)");
   7024                  }
   7025                  #if ENABLED(BLTOUCH)
   7026                    SERIAL_PROTOCOLLNPGM("ERROR: BLTOUCH enabled - set this device up as a Z Servo Probe with inverting as true.");
   7027                  #endif
   7028          
   7029                }
   7030                else {                                           // measure active signal length
   7031                  servo[probe_index].move(z_servo_angle[0]);     // deploy
   7032                  safe_delay(500);
   7033                  SERIAL_PROTOCOLLNPGM("please trigger probe");
   7034                  uint16_t probe_counter = 0;
   7035          
   7036                  // Allow 30 seconds max for operator to trigger probe
   7037                  for (uint16_t j = 0; j < 500 * 30 && probe_counter == 0 ; j++) {
   7038          
   7039                    safe_delay(2);
   7040          
   7041                    if (0 == j % (500 * 1)) // keep cmd_timeout happy
   7042                      refresh_cmd_timeout();
   7043          
   7044                    if (deploy_state != digitalRead(PROBE_TEST_PIN)) { // probe triggered
   7045          
   7046                      for (probe_counter = 1; probe_counter < 50 && deploy_state != digitalRead(PROBE_TEST_PIN); ++probe_counter)
   7047                        safe_delay(2);
   7048          
   7049                      if (probe_counter == 50)
   7050                        SERIAL_PROTOCOLLNPGM("Z Servo Probe detected"); // >= 100mS active time
   7051                      else if (probe_counter >= 2)
   7052                        SERIAL_PROTOCOLLNPAIR("BLTouch compatible probe detected - pulse width (+/- 4mS): ", probe_counter * 2); // allow 4 - 100mS pulse
   7053                      else
   7054                        SERIAL_PROTOCOLLNPGM("noise detected - please re-run test"); // less than 2mS pulse
   7055          
   7056                      servo[probe_index].move(z_servo_angle[1]); //stow
   7057          
   7058                    }  // pulse detected
   7059          
   7060                  } // for loop waiting for trigger
   7061          
   7062                  if (probe_counter == 0) SERIAL_PROTOCOLLNPGM("trigger not detected");
   7063          
   7064                } // measure active signal length
   7065          
   7066              #endif
   7067          
   7068            } // servo_probe_test
   7069          
   7070            /**
   7071             * M43: Pin debug - report pin state, watch pins, toggle pins and servo probe test/report
   7072             *
   7073             *  M43         - report name and state of pin(s)
   7074             *                  P<pin>  Pin to read or watch. If omitted, reads all pins.
   7075             *                  I       Flag to ignore Marlin's pin protection.
   7076             *
   7077             *  M43 W       - Watch pins -reporting changes- until reset, click, or M108.
   7078             *                  P<pin>  Pin to read or watch. If omitted, read/watch all pins.
   7079             *                  I       Flag to ignore Marlin's pin protection.
   7080             *
   7081             *  M43 E<bool> - Enable / disable background endstop monitoring
   7082             *                  - Machine continues to operate
   7083             *                  - Reports changes to endstops
   7084             *                  - Toggles LED when an endstop changes
   7085             *                  - Can not reliably catch the 5mS pulse from BLTouch type probes
   7086             *
   7087             *  M43 T       - Toggle pin(s) and report which pin is being toggled
   7088             *                  S<pin>  - Start Pin number.   If not given, will default to 0
   7089             *                  L<pin>  - End Pin number.   If not given, will default to last pin defined for this board
   7090             *                  I       - Flag to ignore Marlin's pin protection.   Use with caution!!!!
   7091             *                  R       - Repeat pulses on each pin this number of times before continueing to next pin
   7092             *                  W       - Wait time (in miliseconds) between pulses.  If not given will default to 500
   7093             *
   7094             *  M43 S       - Servo probe test
   7095             *                  P<index> - Probe index (optional - defaults to 0
   7096             */
   7097            inline void gcode_M43() {
   7098          
   7099              if (code_seen('T')) {   // must be first ot else it's "S" and "E" parameters will execute endstop or servo test
   7100                toggle_pins();
   7101                return;
   7102              }
   7103          
   7104              // Enable or disable endstop monitoring
   7105              if (code_seen('E')) {
   7106                endstop_monitor_flag = code_value_bool();
   7107                SERIAL_PROTOCOLPGM("endstop monitor ");
   7108                SERIAL_PROTOCOL(endstop_monitor_flag ? "en" : "dis");
   7109                SERIAL_PROTOCOLLNPGM("abled");
   7110                return;
   7111              }
   7112          
   7113              if (code_seen('S')) {
   7114                servo_probe_test();
   7115                return;
   7116              }
   7117          
   7118              // Get the range of pins to test or watch
   7119              const uint8_t first_pin = code_seen('P') ? code_value_byte() : 0,
   7120                            last_pin = code_seen('P') ? first_pin : NUM_DIGITAL_PINS - 1;
   7121          
   7122              if (first_pin > last_pin) return;
   7123          
   7124              const bool ignore_protection = code_seen('I') && code_value_bool();
   7125          
   7126              // Watch until click, M108, or reset
   7127              if (code_seen('W') && code_value_bool()) {
   7128                SERIAL_PROTOCOLLNPGM("Watching pins");
   7129                byte pin_state[last_pin - first_pin + 1];
   7130                for (int8_t pin = first_pin; pin <= last_pin; pin++) {
   7131                  if (pin_is_protected(pin) && !ignore_protection) continue;
   7132                  pinMode(pin, INPUT_PULLUP);
   7133                  /*
   7134                    if (IS_ANALOG(pin))
   7135                      pin_state[pin - first_pin] = analogRead(pin - analogInputToDigitalPin(0)); // int16_t pin_state[...]
   7136                    else
   7137                  //*/
                          ^
Warning[Pe009]: nested comment is not allowed
   7138                      pin_state[pin - first_pin] = digitalRead(pin);
   7139                }
   7140          
   7141                #if HAS_RESUME_CONTINUE
   7142                  wait_for_user = true;
   7143                  KEEPALIVE_STATE(PAUSED_FOR_USER);
   7144                #endif
   7145          
   7146                for (;;) {
   7147                  for (int8_t pin = first_pin; pin <= last_pin; pin++) {
   7148                    if (pin_is_protected(pin)) continue;
   7149                    const byte val =
   7150                      /*
   7151                        IS_ANALOG(pin)
   7152                          ? analogRead(pin - analogInputToDigitalPin(0)) : // int16_t val
   7153                          :
   7154                      //*/
                              ^
Warning[Pe009]: nested comment is not allowed
   7155                        digitalRead(pin);
   7156                    if (val != pin_state[pin - first_pin]) {
   7157                      report_pin_state(pin);
   7158                      pin_state[pin - first_pin] = val;
   7159                    }
   7160                  }
   7161          
   7162                  #if HAS_RESUME_CONTINUE
   7163                    if (!wait_for_user) {
   7164                      KEEPALIVE_STATE(IN_HANDLER);
   7165                      break;
   7166                    }
   7167                  #endif
   7168          
   7169                  safe_delay(500);
   7170                }
   7171                return;
   7172              }
   7173          
   7174              // Report current state of selected pin(s)
   7175              for (uint8_t pin = first_pin; pin <= last_pin; pin++)
   7176                report_pin_state_extended(pin, ignore_protection);
   7177            }
   7178          
   7179          #endif // PINS_DEBUGGING
   7180          
   7181          #if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
   7182          
   7183            /**
   7184             * M48: Z probe repeatability measurement function.
   7185             *
   7186             * Usage:
   7187             *   M48 <P#> <X#> <Y#> <V#> <E> <L#>
   7188             *     P = Number of sampled points (4-50, default 10)
   7189             *     X = Sample X position
   7190             *     Y = Sample Y position
   7191             *     V = Verbose level (0-4, default=1)
   7192             *     E = Engage Z probe for each reading
   7193             *     L = Number of legs of movement before probe
   7194             *     S = Schizoid (Or Star if you prefer)
   7195             *
   7196             * This function assumes the bed has been homed.  Specifically, that a G28 command
   7197             * as been issued prior to invoking the M48 Z probe repeatability measurement function.
   7198             * Any information generated by a prior G29 Bed leveling command will be lost and need to be
   7199             * regenerated.
   7200             */
   7201            inline void gcode_M48() {
   7202          
   7203              if (axis_unhomed_error(true, true, true)) return;
   7204          
   7205              const int8_t verbose_level = code_seen('V') ? code_value_byte() : 1;
   7206              if (!WITHIN(verbose_level, 0, 4)) {
   7207          		SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-4).");
   7208                return;
   7209              }
   7210          
   7211              if (verbose_level > 0)
   7212                SERIAL_PROTOCOLLNPGM("M48 Z-Probe Repeatability Test");
   7213          
   7214              int8_t n_samples = code_seen('P') ? code_value_byte() : 10;
   7215              if (!WITHIN(n_samples, 4, 50)) {
   7216                SERIAL_PROTOCOLLNPGM("?Sample size not plausible (4-50).");
   7217                return;
   7218              }
   7219          
   7220              float X_current = current_position[X_AXIS],
   7221                    Y_current = current_position[Y_AXIS];
   7222          
   7223              bool stow_probe_after_each = code_seen('E');
   7224          
   7225              float X_probe_location = code_seen('X') ? code_value_linear_units() : X_current + X_PROBE_OFFSET_FROM_EXTRUDER;
   7226              #if DISABLED(DELTA)
   7227                if (!WITHIN(X_probe_location, LOGICAL_X_POSITION(MIN_PROBE_X), LOGICAL_X_POSITION(MAX_PROBE_X))) {
   7228                  out_of_range_error(PSTR("X"));
   7229                  return;
   7230                }
   7231              #endif
   7232          
   7233              float Y_probe_location = code_seen('Y') ? code_value_linear_units() : Y_current + Y_PROBE_OFFSET_FROM_EXTRUDER;
   7234              #if DISABLED(DELTA)
   7235                if (!WITHIN(Y_probe_location, LOGICAL_Y_POSITION(MIN_PROBE_Y), LOGICAL_Y_POSITION(MAX_PROBE_Y))) {
   7236                  out_of_range_error(PSTR("Y"));
   7237                  return;
   7238                }
   7239              #else
   7240                float pos[XYZ] = { X_probe_location, Y_probe_location, 0 };
   7241                if (!position_is_reachable(pos, true)) {
   7242                  SERIAL_PROTOCOLLNPGM("? (X,Y) location outside of probeable radius.");
   7243                  return;
   7244                }
   7245              #endif
   7246          
   7247              bool seen_L = code_seen('L');
   7248              uint8_t n_legs = seen_L ? code_value_byte() : 0;
   7249              if (n_legs > 15) {
   7250                SERIAL_PROTOCOLLNPGM("?Number of legs in movement not plausible (0-15).");
   7251                return;
   7252              }
   7253              if (n_legs == 1) n_legs = 2;
   7254          
   7255              bool schizoid_flag = code_seen('S');
   7256              if (schizoid_flag && !seen_L) n_legs = 7;
   7257          
   7258              /**
   7259               * Now get everything to the specified probe point So we can safely do a
   7260               * probe to get us close to the bed.  If the Z-Axis is far from the bed,
   7261               * we don't want to use that as a starting point for each probe.
   7262               */
   7263              if (verbose_level > 2)
   7264                SERIAL_PROTOCOLLNPGM("Positioning the probe...");
   7265          
   7266              // Disable bed level correction in M48 because we want the raw data when we probe
   7267          
   7268          	/*--mks cfg--begin MESH_BED_LEVELING */
   7269          /*	
   7270              #if HAS_LEVELING
   7271                const bool was_enabled =
   7272                  #if ENABLED(AUTO_BED_LEVELING_UBL)
   7273                    ubl.state.active
   7274                  #elif ENABLED(MESH_BED_LEVELING)
   7275                    mbl.active()
   7276                  #else
   7277                    planner.abl_enabled
   7278                  #endif
   7279                ;
   7280                set_bed_leveling_enabled(false);
   7281              #endif
   7282          */
   7283          	bool was_enabled;
   7284          	if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
   7285          		was_enabled = ubl.state.active;
   7286          	else if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
   7287          		was_enabled = mbl.active();
   7288          	else if(BED_LEVELING_METHOD != NULL_BED_LEVELING)
   7289          		was_enabled = planner.abl_enabled;
   7290          
   7291          	if(BED_LEVELING_METHOD != NULL_BED_LEVELING)
   7292          		set_bed_leveling_enabled(false);
   7293          
   7294          	/*--mks cfg--end MESH_BED_LEVELING */
   7295          
   7296              setup_for_endstop_or_probe_move();
   7297          
   7298              // Move to the first point, deploy, and probe
   7299              probe_pt(X_probe_location, Y_probe_location, stow_probe_after_each, verbose_level);
   7300          
   7301          	/*--mks cfg-random*/
   7302              //randomSeed(millis());
   7303          	srand(millis());
   7304          	
   7305              double mean = 0.0, sigma = 0.0, min = 99999.9, max = -99999.9, sample_set[n_samples];
   7306          
   7307              for (uint8_t n = 0; n < n_samples; n++) {
   7308                if (n_legs) {
   7309                  int dir = (random(0, 10) > 5.0) ? -1 : 1;  // clockwise or counter clockwise
   7310                  float angle = random(0.0, 360.0),
   7311                        radius = random(
   7312                          #if ENABLED(DELTA)
   7313                            DELTA_PROBEABLE_RADIUS / 8, DELTA_PROBEABLE_RADIUS / 3
   7314                          #else
   7315                            5, X_MAX_LENGTH / 8
   7316                          #endif
   7317                        );
   7318          
   7319                  if (verbose_level > 3) {
   7320                    SERIAL_ECHOPAIR("Starting radius: ", radius);
   7321                    SERIAL_ECHOPAIR("   angle: ", angle);
   7322                    SERIAL_ECHOPGM(" Direction: ");
   7323                    if (dir > 0) SERIAL_ECHOPGM("Counter-");
   7324                    SERIAL_ECHOLNPGM("Clockwise");
   7325                  }
   7326          
   7327                  for (uint8_t l = 0; l < n_legs - 1; l++) {
   7328                    double delta_angle;
   7329          
   7330                    if (schizoid_flag)
   7331                      // The points of a 5 point star are 72 degrees apart.  We need to
   7332                      // skip a point and go to the next one on the star.
   7333                      delta_angle = dir * 2.0 * 72.0;
   7334          
   7335                    else
   7336                      // If we do this line, we are just trying to move further
   7337                      // around the circle.
   7338                      /*--mks cfg-random*/
   7339                      delta_angle = dir * (float) random(25, 45);
   7340          		
   7341                    angle += delta_angle;
   7342          
   7343                    while (angle > 360.0)   // We probably do not need to keep the angle between 0 and 2*PI, but the
   7344                      angle -= 360.0;       // Arduino documentation says the trig functions should not be given values
   7345                    while (angle < 0.0)     // outside of this range.   It looks like they behave correctly with
   7346                      angle += 360.0;       // numbers outside of the range, but just to be safe we clamp them.
   7347          
   7348                    X_current = X_probe_location - (X_PROBE_OFFSET_FROM_EXTRUDER) + cos(RADIANS(angle)) * radius;
   7349                    Y_current = Y_probe_location - (Y_PROBE_OFFSET_FROM_EXTRUDER) + sin(RADIANS(angle)) * radius;
   7350          
   7351                    #if DISABLED(DELTA)
   7352                      X_current = constrain(X_current, X_MIN_POS, X_MAX_POS);
   7353                      Y_current = constrain(Y_current, Y_MIN_POS, Y_MAX_POS);
   7354                    #else
   7355                      // If we have gone out too far, we can do a simple fix and scale the numbers
   7356                      // back in closer to the origin.
   7357                      while (HYPOT(X_current, Y_current) > DELTA_PROBEABLE_RADIUS) {
   7358                        X_current *= 0.8;
   7359                        Y_current *= 0.8;
   7360                        if (verbose_level > 3) {
   7361                          SERIAL_ECHOPAIR("Pulling point towards center:", X_current);
   7362                          SERIAL_ECHOLNPAIR(", ", Y_current);
   7363                        }
   7364                      }
   7365                    #endif
   7366                    if (verbose_level > 3) {
   7367                      SERIAL_PROTOCOLPGM("Going to:");
   7368                      SERIAL_ECHOPAIR(" X", X_current);
   7369                      SERIAL_ECHOPAIR(" Y", Y_current);
   7370                      SERIAL_ECHOLNPAIR(" Z", current_position[Z_AXIS]);
   7371                    }
   7372                    do_blocking_move_to_xy(X_current, Y_current);
   7373                  } // n_legs loop
   7374                } // n_legs
   7375          
   7376                // Probe a single point
   7377                sample_set[n] = probe_pt(X_probe_location, Y_probe_location, stow_probe_after_each, 0);
   7378          
   7379                /**
   7380                 * Get the current mean for the data points we have so far
   7381                 */
   7382                double sum = 0.0;
   7383                for (uint8_t j = 0; j <= n; j++) sum += sample_set[j];
   7384                mean = sum / (n + 1);
   7385          
   7386                NOMORE(min, sample_set[n]);
   7387                NOLESS(max, sample_set[n]);
   7388          
   7389                /**
   7390                 * Now, use that mean to calculate the standard deviation for the
   7391                 * data points we have so far
   7392                 */
   7393                sum = 0.0;
   7394                for (uint8_t j = 0; j <= n; j++)
   7395                  sum += sq(sample_set[j] - mean);
   7396          
   7397                sigma = sqrt(sum / (n + 1));
   7398                if (verbose_level > 0) {
   7399                  if (verbose_level > 1) {
   7400                    SERIAL_PROTOCOL(n + 1);
   7401                    SERIAL_PROTOCOLPGM(" of ");
   7402                    SERIAL_PROTOCOL((int)n_samples);
   7403                    SERIAL_PROTOCOLPGM(": z: ");
   7404                    SERIAL_PROTOCOL_F(sample_set[n], 3);
   7405                    if (verbose_level > 2) {
   7406                      SERIAL_PROTOCOLPGM(" mean: ");
   7407                      SERIAL_PROTOCOL_F(mean, 4);
   7408                      SERIAL_PROTOCOLPGM(" sigma: ");
   7409                      SERIAL_PROTOCOL_F(sigma, 6);
   7410                      SERIAL_PROTOCOLPGM(" min: ");
   7411                      SERIAL_PROTOCOL_F(min, 3);
   7412                      SERIAL_PROTOCOLPGM(" max: ");
   7413                      SERIAL_PROTOCOL_F(max, 3);
   7414                      SERIAL_PROTOCOLPGM(" range: ");
   7415                      SERIAL_PROTOCOL_F(max-min, 3);
   7416                    }
   7417                    SERIAL_EOL;
   7418                  }
   7419                }
   7420          
   7421              } // End of probe loop
   7422          
   7423              if (STOW_PROBE()) return;
   7424          
   7425              SERIAL_PROTOCOLPGM("Finished!");
   7426              SERIAL_EOL;
   7427          
   7428              if (verbose_level > 0) {
   7429                SERIAL_PROTOCOLPGM("Mean: ");
   7430                SERIAL_PROTOCOL_F(mean, 6);
   7431                SERIAL_PROTOCOLPGM(" Min: ");
   7432                SERIAL_PROTOCOL_F(min, 3);
   7433                SERIAL_PROTOCOLPGM(" Max: ");
   7434                SERIAL_PROTOCOL_F(max, 3);
   7435                SERIAL_PROTOCOLPGM(" Range: ");
   7436                SERIAL_PROTOCOL_F(max-min, 3);
   7437                SERIAL_EOL;
   7438              }
   7439          
   7440              SERIAL_PROTOCOLPGM("Standard Deviation: ");
   7441              SERIAL_PROTOCOL_F(sigma, 6);
   7442              SERIAL_EOL;
   7443              SERIAL_EOL;
   7444          
   7445              clean_up_after_endstop_or_probe_move();
   7446          
   7447              // Re-enable bed level correction if it had been on
   7448              //#if HAS_LEVELING
   7449          	if(BED_LEVELING_METHOD&HAS_LEVELING)
   7450                set_bed_leveling_enabled(was_enabled);
   7451              //#endif
   7452          
   7453              report_current_position();
   7454            }
   7455          
   7456          #endif // Z_MIN_PROBE_REPEATABILITY_TEST
   7457          
   7458          //#if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(UBL_G26_MESH_EDITING)
   7459          #if 1

   \                                 In section .text, align 4
   7460            inline void gcode_M49() {
   \                     _Z9gcode_M49v: (+1)
   \        0x0   0x480E             LDR.N    R0,??gcode_M49_0
   \        0x2   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \        0x6   0x2810             CMP      R0,#+16
   \        0x8   0xD000             BEQ.N    ??gcode_M49_1
   \        0xA   0x4770             BX       LR
   \                     ??gcode_M49_1: (+1)
   \        0xC   0xB510             PUSH     {R4,LR}
   7461            if(BED_LEVELING_METHOD != AUTO_BED_LEVELING_UBL) 
   7462            	return;
   7463            
   7464              ubl.g26_debug_flag ^= true;
   \        0xE   0x4C0C             LDR.N    R4,??gcode_M49_0+0x4
   \       0x10   0x7820             LDRB     R0,[R4, #+0]
   \       0x12   0xF080 0x0001      EOR      R0,R0,#0x1
   \       0x16   0x1E40             SUBS     R0,R0,#+1
   \       0x18   0x4180             SBCS     R0,R0,R0
   \       0x1A   0x43C0             MVNS     R0,R0
   \       0x1C   0x0FC0             LSRS     R0,R0,#+31
   \       0x1E   0x7020             STRB     R0,[R4, #+0]
   7465              SERIAL_PROTOCOLPGM("UBL Debug Flag turned ");
   \       0x20   0x4808             LDR.N    R0,??gcode_M49_0+0x8
   \       0x22   0x.... 0x....      BL       _Z14serialprintPGMPKc
   7466              serialprintPGM(ubl.g26_debug_flag ? PSTR("on.") : PSTR("off."));
   \       0x26   0x7820             LDRB     R0,[R4, #+0]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD001             BEQ.N    ??gcode_M49_2
   \       0x2C   0x4806             LDR.N    R0,??gcode_M49_0+0xC
   \       0x2E   0xE000             B.N      ??gcode_M49_3
   \                     ??gcode_M49_2: (+1)
   \       0x30   0x4806             LDR.N    R0,??gcode_M49_0+0x10
   \                     ??gcode_M49_3: (+1)
   \       0x32   0xE8BD 0x4010      POP      {R4,LR}
   \       0x36   0x.... 0x....      B.W      _Z14serialprintPGMPKc
   \       0x3A   0xBF00             Nop      
   \                     ??gcode_M49_0:
   \       0x3C   0x....'....        DC32     mksCfg
   \       0x40   0x....'....        DC32     _ZN20unified_bed_leveling14g26_debug_flagE
   \       0x44   0x....'....        DC32     _ZZ9gcode_M49vEs
   \       0x48   0x....'....        DC32     _ZZ9gcode_M49vEs_0
   \       0x4C   0x....'....        DC32     _ZZ9gcode_M49vEs_1
   7467            }
   7468          
   7469          #endif // AUTO_BED_LEVELING_UBL && UBL_G26_MESH_EDITING
   7470          
   7471          /**
   7472           * M75: Start print timer
   7473           */

   \                                 In section .text, align 4
   7474          inline void gcode_M75() { print_job_timer.start(); }
   \                     _Z9gcode_M75v: (+1)
   \        0x0   0x4801             LDR.N    R0,??gcode_M75_0
   \        0x2   0x.... 0x....      B.W      _ZN9Stopwatch5startEv
   \        0x6   0xBF00             Nop      
   \                     ??gcode_M75_0:
   \        0x8   0x....'....        DC32     mks_heating_busy+0x388
   7475          
   7476          /**
   7477           * M76: Pause print timer
   7478           */

   \                                 In section .text, align 4
   7479          inline void gcode_M76() { print_job_timer.pause(); }
   \                     _Z9gcode_M76v: (+1)
   \        0x0   0x4801             LDR.N    R0,??gcode_M76_0
   \        0x2   0x.... 0x....      B.W      _ZN9Stopwatch5pauseEv
   \        0x6   0xBF00             Nop      
   \                     ??gcode_M76_0:
   \        0x8   0x....'....        DC32     mks_heating_busy+0x388
   7480          
   7481          /**
   7482           * M77: Stop print timer
   7483           */

   \                                 In section .text, align 4
   7484          inline void gcode_M77() { print_job_timer.stop(); }
   \                     _Z9gcode_M77v: (+1)
   \        0x0   0x4801             LDR.N    R0,??gcode_M77_0
   \        0x2   0x.... 0x....      B.W      _ZN9Stopwatch4stopEv
   \        0x6   0xBF00             Nop      
   \                     ??gcode_M77_0:
   \        0x8   0x....'....        DC32     mks_heating_busy+0x388
   7485          
   7486          #if ENABLED(PRINTCOUNTER)
   7487            /**
   7488             * M78: Show print statistics
   7489             */
   7490            inline void gcode_M78() {
   7491              // "M78 S78" will reset the statistics
   7492              if (code_seen('S') && code_value_int() == 78)
   7493                print_job_timer.initStats();
   7494              else
   7495                print_job_timer.showStats();
   7496            }
   7497          #endif
   7498          
   7499          /**
   7500           * M104: Set hot end temperature
   7501           */

   \                                 In section .text, align 4
   7502          inline void gcode_M104() {
   \                     _Z10gcode_M104v: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   7503            if (get_target_extruder_from_command(104)) return;
   \        0x2   0x2068             MOVS     R0,#+104
   \        0x4   0x.... 0x....      BL       _Z32get_target_extruder_from_commandi
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD162             BNE.N    ??gcode_M104_2
   7504            if (DEBUGGING(DRYRUN)) return;
   \        0xC   0x4C31             LDR.N    R4,??gcode_M104_1
   \        0xE   0x7860             LDRB     R0,[R4, #+1]
   \       0x10   0x0700             LSLS     R0,R0,#+28
   \       0x12   0xD45E             BMI.N    ??gcode_M104_2
   7505          
   7506            #if ENABLED(SINGLENOZZLE)
   7507              if (target_extruder != active_extruder) return;
   7508            #endif
   7509          
   7510            if (code_seen('S')) {
   \       0x14   0x2053             MOVS     R0,#+83
   \       0x16   0x.... 0x....      BL       _Z9code_seenc
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD055             BEQ.N    ??gcode_M104_3
   7511              const int16_t temp = code_value_temp_abs();
   \       0x1E   0x.... 0x....      BL       _Z19code_value_temp_absv
   7512              thermalManager.setTargetHotend(temp, target_extruder);
   \       0x22   0x7961             LDRB     R1,[R4, #+5]
   \       0x24   0x460D             MOV      R5,R1
   \       0x26   0x.... 0x....      BL       __aeabi_i2f
   \       0x2A   0x4629             MOV      R1,R5
   \       0x2C   0x.... 0x....      BL       _ZN11Temperature15setTargetHotendEfh
   7513              #if ENABLED(DUAL_X_CARRIAGE)
   7514                if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && target_extruder == 0)
   7515                  thermalManager.setTargetHotend(temp ? temp + duplicate_extruder_temp_offset : 0, 1);
   7516              #endif
   7517          
   7518              #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
   7519                /**
   7520                 * Stop the timer at the end of print. Start is managed by 'heat and wait' M109.
   7521                 * We use half EXTRUDE_MINTEMP here to allow nozzles to be put into hot
   7522                 * standby mode, for instance in a dual extruder setup, without affecting
   7523                 * the running print timer.
   7524                 */
   7525                if (code_value_temp_abs() <= (EXTRUDE_MINTEMP) / 2) {
   \       0x30   0x.... 0x....      BL       _Z19code_value_temp_absv
   \       0x34   0x4D28             LDR.N    R5,??gcode_M104_1+0x4
   \       0x36   0x.... 0x....      BL       __aeabi_i2f
   \       0x3A   0x4601             MOV      R1,R0
   \       0x3C   0x460E             MOV      R6,R1
   \       0x3E   0x6829             LDR      R1,[R5, #+0]
   \       0x40   0xF04F 0x507C      MOV      R0,#+1056964608
   \       0x44   0x.... 0x....      BL       __aeabi_fmul
   \       0x48   0x4631             MOV      R1,R6
   \       0x4A   0x.... 0x....      BL       __aeabi_cfrcmple
   \       0x4E   0xD807             BHI.N    ??gcode_M104_4
   7526                  print_job_timer.stop();
   \       0x50   0xF504 0x7062      ADD      R0,R4,#+904
   \       0x54   0x.... 0x....      BL       _ZN9Stopwatch4stopEv
   7527                  LCD_MESSAGEPGM(WELCOME_MSG);
   \       0x58   0x2100             MOVS     R1,#+0
   \       0x5A   0x4820             LDR.N    R0,??gcode_M104_1+0x8
   \       0x5C   0x.... 0x....      BL       _Z16lcd_setstatuspgmPKch
   7528                }
   7529              #endif
   7530          
   7531          //    if (code_value_temp_abs() > thermalManager.degHotend(target_extruder)) lcd_status_printf_P(0, PSTR("E%i %s"), target_extruder + 1, MSG_HEATING);
   7532          //	if (code_value_temp_abs() > thermalManager.degHotend(target_extruder)) LCD_MESSAGEPGM("E1 Heating..."); 	  //mks
   7533          
   7534          	if (code_value_temp_abs() > thermalManager.degHotend(target_extruder))
   \                     ??gcode_M104_4: (+1)
   \       0x60   0x7960             LDRB     R0,[R4, #+5]
   \       0x62   0x.... 0x....      BL       _ZN11Temperature9degHotendEh
   \       0x66   0x4606             MOV      R6,R0
   \       0x68   0x.... 0x....      BL       _Z19code_value_temp_absv
   \       0x6C   0x.... 0x....      BL       __aeabi_i2f
   \       0x70   0x4601             MOV      R1,R0
   \       0x72   0x4630             MOV      R0,R6
   \       0x74   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x78   0xD227             BCS.N    ??gcode_M104_3
   7535          		{
   7536          		switch(target_extruder)
   \       0x7A   0x7960             LDRB     R0,[R4, #+5]
   \       0x7C   0x2804             CMP      R0,#+4
   \       0x7E   0xD824             BHI.N    ??gcode_M104_3
   \       0x80   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??gcode_M104_0:
   \       0x84   0x03 0x10          DC8      0x3,0x10,0x15,0x1A
   \              0x15 0x1A    
   \       0x88   0x1F 0x00          DC8      0x1F,0x0
   7537          			{
   7538          			case 0:
   7539          				if(mksCfg.lcd_language == 1) LCD_MESSAGEPGM("E1 \x80\xc4\x9b...");
   \                     ??gcode_M104_5: (+1)
   \       0x8A   0x7CA8             LDRB     R0,[R5, #+18]
   \       0x8C   0x2801             CMP      R0,#+1
   \       0x8E   0xD104             BNE.N    ??gcode_M104_6
   \       0x90   0x2100             MOVS     R1,#+0
   \       0x92   0x4813             LDR.N    R0,??gcode_M104_1+0xC
   \       0x94   0x.... 0x....      BL       _Z16lcd_setstatuspgmPKch
   \       0x98   0xE017             B.N      ??gcode_M104_3
   7540          				else LCD_MESSAGEPGM("E1 Heating...");
   \                     ??gcode_M104_6: (+1)
   \       0x9A   0x2100             MOVS     R1,#+0
   \       0x9C   0x4811             LDR.N    R0,??gcode_M104_1+0x10
   \       0x9E   0x.... 0x....      BL       _Z16lcd_setstatuspgmPKch
   \       0xA2   0xE012             B.N      ??gcode_M104_3
   7541          				break;
   7542          			case 1:
   7543          				LCD_MESSAGEPGM("E2 Heating...");
   \                     ??gcode_M104_7: (+1)
   \       0xA4   0x2100             MOVS     R1,#+0
   \       0xA6   0x4810             LDR.N    R0,??gcode_M104_1+0x14
   \       0xA8   0x.... 0x....      BL       _Z16lcd_setstatuspgmPKch
   7544          				break;
   \       0xAC   0xE00D             B.N      ??gcode_M104_3
   7545          			case 2:
   7546          				LCD_MESSAGEPGM("E3 Heating...");
   \                     ??gcode_M104_8: (+1)
   \       0xAE   0x2100             MOVS     R1,#+0
   \       0xB0   0x480E             LDR.N    R0,??gcode_M104_1+0x18
   \       0xB2   0x.... 0x....      BL       _Z16lcd_setstatuspgmPKch
   7547          				break;
   \       0xB6   0xE008             B.N      ??gcode_M104_3
   7548          			case 3:
   7549          				LCD_MESSAGEPGM("E4 Heating...");
   \                     ??gcode_M104_9: (+1)
   \       0xB8   0x2100             MOVS     R1,#+0
   \       0xBA   0x480D             LDR.N    R0,??gcode_M104_1+0x1C
   \       0xBC   0x.... 0x....      BL       _Z16lcd_setstatuspgmPKch
   7550          				break;
   \       0xC0   0xE003             B.N      ??gcode_M104_3
   7551          			case 4:
   7552          				LCD_MESSAGEPGM("E5 Heating...");
   \                     ??gcode_M104_10: (+1)
   \       0xC2   0x2100             MOVS     R1,#+0
   \       0xC4   0x480B             LDR.N    R0,??gcode_M104_1+0x20
   \       0xC6   0x.... 0x....      BL       _Z16lcd_setstatuspgmPKch
   7553          				break;
   7554          			default: break;
   7555          				
   7556          			}
   7557          		}
   7558          
   7559            }
   7560          
   7561            #if ENABLED(AUTOTEMP)
   7562              planner.autotemp_M104_M109();
   \                     ??gcode_M104_3: (+1)
   \       0xCA   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0xCE   0x.... 0x....      B.W      _ZN7Planner18autotemp_M104_M109Ev
   \                     ??gcode_M104_2: (+1)
   \       0xD2   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??gcode_M104_1:
   \       0xD4   0x....'....        DC32     mks_heating_busy
   \       0xD8   0x....'....        DC32     mksCfg+0x2C
   \       0xDC   0x....'....        DC32     WELCOME_MSG
   \       0xE0   0x....'....        DC32     _ZZ10gcode_M104vEs
   \       0xE4   0x....'....        DC32     _ZZ10gcode_M104vEs_0
   \       0xE8   0x....'....        DC32     _ZZ10gcode_M104vEs_1
   \       0xEC   0x....'....        DC32     _ZZ10gcode_M104vEs_2
   \       0xF0   0x....'....        DC32     _ZZ10gcode_M104vEs_3
   \       0xF4   0x....'....        DC32     _ZZ10gcode_M104vEs_4
   7563            #endif
   7564          }
   7565          
   7566          //#if HAS_TEMP_HOTEND || HAS_TEMP_BED	/*--mks cfg-- HAS_TEMP_BED --*/
   7567          #if 1

   \                                 In section .text, align 2, keep-with-next
   7568            void print_heaterstates() {
   \                     _Z18print_heaterstatesv: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   7569              #if HAS_TEMP_HOTEND
   7570                SERIAL_PROTOCOLPGM(" T:");
   \        0x4   0x....             ADR.N    R0,??DataTable132  ;; " T:"
   \        0x6   0x.... 0x....      BL       _Z14serialprintPGMPKc
   7571                SERIAL_PROTOCOL(thermalManager.degHotend(target_extruder));
   \        0xA   0x.... 0x....      LDR.W    R4,??DataTable136_2
   \        0xE   0x7960             LDRB     R0,[R4, #+5]
   \       0x10   0x.... 0x....      LDR.W    R5,??DataTable136_6
   \       0x14   0x.... 0x....      LDR.W    R6,??DataTable136_17
   \       0x18   0x79E1             LDRB     R1,[R4, #+7]
   \       0x1A   0x2900             CMP      R1,#+0
   \       0x1C   0xD10B             BNE.N    ??print_heaterstates_0
   \       0x1E   0x.... 0x....      BL       _ZN11Temperature9degHotendEh
   \       0x22   0x2102             MOVS     R1,#+2
   \       0x24   0x9100             STR      R1,[SP, #+0]
   \       0x26   0x.... 0x....      BL       __aeabi_f2d
   \       0x2A   0x4602             MOV      R2,R0
   \       0x2C   0x460B             MOV      R3,R1
   \       0x2E   0x4630             MOV      R0,R6
   \       0x30   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   \       0x34   0xE00A             B.N      ??print_heaterstates_1
   \                     ??print_heaterstates_0: (+1)
   \       0x36   0x.... 0x....      BL       _ZN11Temperature9degHotendEh
   \       0x3A   0x2102             MOVS     R1,#+2
   \       0x3C   0x9100             STR      R1,[SP, #+0]
   \       0x3E   0x.... 0x....      BL       __aeabi_f2d
   \       0x42   0x4602             MOV      R2,R0
   \       0x44   0x460B             MOV      R3,R1
   \       0x46   0x4628             MOV      R0,R5
   \       0x48   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   7572                SERIAL_PROTOCOLPGM(" /");
   \                     ??print_heaterstates_1: (+1)
   \       0x4C   0x.... 0x....      ADR.W    R8,??DataTable133_1  ;; 0x20, 0x2F, 0x00, 0x00
   \       0x50   0x4640             MOV      R0,R8
   \       0x52   0x.... 0x....      BL       _Z14serialprintPGMPKc
   7573                SERIAL_PROTOCOL(thermalManager.degTargetHotend(target_extruder));
   \       0x56   0x7960             LDRB     R0,[R4, #+5]
   \       0x58   0x79E1             LDRB     R1,[R4, #+7]
   \       0x5A   0x2900             CMP      R1,#+0
   \       0x5C   0xD10B             BNE.N    ??print_heaterstates_2
   \       0x5E   0x.... 0x....      BL       _ZN11Temperature15degTargetHotendEh
   \       0x62   0x2102             MOVS     R1,#+2
   \       0x64   0x9100             STR      R1,[SP, #+0]
   \       0x66   0x.... 0x....      BL       __aeabi_f2d
   \       0x6A   0x4602             MOV      R2,R0
   \       0x6C   0x460B             MOV      R3,R1
   \       0x6E   0x4630             MOV      R0,R6
   \       0x70   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   \       0x74   0xE00A             B.N      ??print_heaterstates_3
   \                     ??print_heaterstates_2: (+1)
   \       0x76   0x.... 0x....      BL       _ZN11Temperature15degTargetHotendEh
   \       0x7A   0x2102             MOVS     R1,#+2
   \       0x7C   0x9100             STR      R1,[SP, #+0]
   \       0x7E   0x.... 0x....      BL       __aeabi_f2d
   \       0x82   0x4602             MOV      R2,R0
   \       0x84   0x460B             MOV      R3,R1
   \       0x86   0x4628             MOV      R0,R5
   \       0x88   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   7574                #if ENABLED(SHOW_TEMP_ADC_VALUES)
   7575                  SERIAL_PROTOCOLPAIR(" (", thermalManager.rawHotendTemp(target_extruder) / OVERSAMPLENR);
   7576                  SERIAL_PROTOCOLCHAR(')');
   7577                #endif
   7578                 // SERIAL_PROTOCOLLNPGM(".");       //mks add
   7579              #endif
   7580          /*--mks cfg begin-- HAS_TEMP_BED */	
   7581          /*    #if HAS_TEMP_BED
   7582                SERIAL_PROTOCOLPGM(" B:");
   7583                SERIAL_PROTOCOL(thermalManager.degBed());
   7584                SERIAL_PROTOCOLPGM(" /");
   7585                SERIAL_PROTOCOL(thermalManager.degTargetBed());
   7586                #if ENABLED(SHOW_TEMP_ADC_VALUES)
   7587                  SERIAL_PROTOCOLPAIR(" (", thermalManager.rawBedTemp() / OVERSAMPLENR);
   7588                  SERIAL_PROTOCOLCHAR(')');
   7589                #endif
   7590              #endif
   7591          */	
   7592          	if(HAS_TEMP_BED)
   \                     ??print_heaterstates_3: (+1)
   \       0x8C   0x.... 0x....      LDR.W    R7,??DataTable136_8
   \       0x90   0xF897 0x0036      LDRB     R0,[R7, #+54]
   \       0x94   0x2800             CMP      R0,#+0
   \       0x96   0xD039             BEQ.N    ??print_heaterstates_4
   7593          		{
   7594          		SERIAL_PROTOCOLPGM(" B:");
   \       0x98   0x....             ADR.N    R0,??DataTable133_2  ;; " B:"
   \       0x9A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   7595          		SERIAL_PROTOCOL(thermalManager.degBed());
   \       0x9E   0x79E0             LDRB     R0,[R4, #+7]
   \       0xA0   0x2800             CMP      R0,#+0
   \       0xA2   0xD10B             BNE.N    ??print_heaterstates_5
   \       0xA4   0x.... 0x....      BL       _ZN11Temperature6degBedEv
   \       0xA8   0x2102             MOVS     R1,#+2
   \       0xAA   0x9100             STR      R1,[SP, #+0]
   \       0xAC   0x.... 0x....      BL       __aeabi_f2d
   \       0xB0   0x4602             MOV      R2,R0
   \       0xB2   0x460B             MOV      R3,R1
   \       0xB4   0x4630             MOV      R0,R6
   \       0xB6   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   \       0xBA   0xE00A             B.N      ??print_heaterstates_6
   \                     ??print_heaterstates_5: (+1)
   \       0xBC   0x.... 0x....      BL       _ZN11Temperature6degBedEv
   \       0xC0   0x2102             MOVS     R1,#+2
   \       0xC2   0x9100             STR      R1,[SP, #+0]
   \       0xC4   0x.... 0x....      BL       __aeabi_f2d
   \       0xC8   0x4602             MOV      R2,R0
   \       0xCA   0x460B             MOV      R3,R1
   \       0xCC   0x4628             MOV      R0,R5
   \       0xCE   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   7596          		SERIAL_PROTOCOLPGM(" /");
   \                     ??print_heaterstates_6: (+1)
   \       0xD2   0x4640             MOV      R0,R8
   \       0xD4   0x.... 0x....      BL       _Z14serialprintPGMPKc
   7597          		SERIAL_PROTOCOL(thermalManager.degTargetBed());
   \       0xD8   0x79E0             LDRB     R0,[R4, #+7]
   \       0xDA   0x2800             CMP      R0,#+0
   \       0xDC   0xD10B             BNE.N    ??print_heaterstates_7
   \       0xDE   0x.... 0x....      BL       _ZN11Temperature12degTargetBedEv
   \       0xE2   0x2102             MOVS     R1,#+2
   \       0xE4   0x9100             STR      R1,[SP, #+0]
   \       0xE6   0x.... 0x....      BL       __aeabi_f2d
   \       0xEA   0x4602             MOV      R2,R0
   \       0xEC   0x460B             MOV      R3,R1
   \       0xEE   0x4630             MOV      R0,R6
   \       0xF0   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   \       0xF4   0xE00A             B.N      ??print_heaterstates_4
   \                     ??print_heaterstates_7: (+1)
   \       0xF6   0x.... 0x....      BL       _ZN11Temperature12degTargetBedEv
   \       0xFA   0x2102             MOVS     R1,#+2
   \       0xFC   0x9100             STR      R1,[SP, #+0]
   \       0xFE   0x.... 0x....      BL       __aeabi_f2d
   \      0x102   0x4602             MOV      R2,R0
   \      0x104   0x460B             MOV      R3,R1
   \      0x106   0x4628             MOV      R0,R5
   \      0x108   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   7598          		#if ENABLED(SHOW_TEMP_ADC_VALUES)
   7599          		  SERIAL_PROTOCOLPAIR(" (", thermalManager.rawBedTemp() / OVERSAMPLENR);
   7600          		  SERIAL_PROTOCOLCHAR(')');
   7601          		#endif
   7602          		}
   7603          /*--mks cfg end-- HAS_TEMP_BED */
   7604              #if HOTENDS > 1
   7605                HOTEND_LOOP() {
   7606                  SERIAL_PROTOCOLPAIR(" T", e);
   7607                  SERIAL_PROTOCOLCHAR(':');
   7608                  SERIAL_PROTOCOL(thermalManager.degHotend(e));
   7609                  SERIAL_PROTOCOLPGM(" /");
   7610                  SERIAL_PROTOCOL(thermalManager.degTargetHotend(e));
   7611                  #if ENABLED(SHOW_TEMP_ADC_VALUES)
   7612                    SERIAL_PROTOCOLPAIR(" (", thermalManager.rawHotendTemp(e) / OVERSAMPLENR);
   7613                    SERIAL_PROTOCOLCHAR(')');
   7614                  #endif
   7615                }
   7616              #endif
   7617              SERIAL_PROTOCOLPGM(" @:");
   \                     ??print_heaterstates_4: (+1)
   \      0x10C   0x....             ADR.N    R0,??DataTable134  ;; " @:"
   \      0x10E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   7618              SERIAL_PROTOCOL(thermalManager.getHeaterPower(target_extruder));
   \      0x112   0x7960             LDRB     R0,[R4, #+5]
   \      0x114   0x79E1             LDRB     R1,[R4, #+7]
   \      0x116   0x2900             CMP      R1,#+0
   \      0x118   0xD107             BNE.N    ??print_heaterstates_8
   \      0x11A   0x.... 0x....      BL       _ZN11Temperature14getHeaterPowerEi
   \      0x11E   0x4601             MOV      R1,R0
   \      0x120   0x220A             MOVS     R2,#+10
   \      0x122   0x4630             MOV      R0,R6
   \      0x124   0x.... 0x....      BL       _ZN12MarlinSerial5printEii
   \      0x128   0xE006             B.N      ??print_heaterstates_9
   \                     ??print_heaterstates_8: (+1)
   \      0x12A   0x.... 0x....      BL       _ZN11Temperature14getHeaterPowerEi
   \      0x12E   0x220A             MOVS     R2,#+10
   \      0x130   0x4601             MOV      R1,R0
   \      0x132   0x4628             MOV      R0,R5
   \      0x134   0x.... 0x....      BL       _ZN12MarlinSerial5printEii
   7619          	
   7620             // #if HAS_TEMP_BED	/*--mks cfg-- HAS_TEMP_BED --*/
   7621          	if(HAS_TEMP_BED) {
   \                     ??print_heaterstates_9: (+1)
   \      0x138   0xF897 0x0036      LDRB     R0,[R7, #+54]
   \      0x13C   0x2800             CMP      R0,#+0
   \      0x13E   0xD01C             BEQ.N    ??print_heaterstates_10
   7622             	  SERIAL_PROTOCOLPGM(" B@:");
   \      0x140   0x.... 0x....      ADR.W    R0,?_28
   \      0x144   0x.... 0x....      BL       _Z14serialprintPGMPKc
   7623                SERIAL_PROTOCOL(thermalManager.getHeaterPower(-1));
   \      0x148   0x79E0             LDRB     R0,[R4, #+7]
   \      0x14A   0x2800             CMP      R0,#+0
   \      0x14C   0xF04F 0x30FF      MOV      R0,#-1
   \      0x150   0xD109             BNE.N    ??print_heaterstates_11
   \      0x152   0x.... 0x....      BL       _ZN11Temperature14getHeaterPowerEi
   \      0x156   0x220A             MOVS     R2,#+10
   \      0x158   0x4601             MOV      R1,R0
   \      0x15A   0x4630             MOV      R0,R6
   \      0x15C   0xB002             ADD      SP,SP,#+8
   \      0x15E   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \      0x162   0x.... 0x....      B.W      _ZN12MarlinSerial5printEii
   \                     ??print_heaterstates_11: (+1)
   \      0x166   0x.... 0x....      BL       _ZN11Temperature14getHeaterPowerEi
   \      0x16A   0x220A             MOVS     R2,#+10
   \      0x16C   0x4601             MOV      R1,R0
   \      0x16E   0x4628             MOV      R0,R5
   \      0x170   0xB002             ADD      SP,SP,#+8
   \      0x172   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \      0x176   0x.... 0x....      B.W      _ZN12MarlinSerial5printEii
   7624                //SERIAL_PROTOCOLLNPGM(".");       //mks add
   7625              }//#endif
   7626          	
   7627              #if HOTENDS > 1
   7628                HOTEND_LOOP() {
   7629                  SERIAL_PROTOCOLPAIR(" @", e);
   7630                  SERIAL_PROTOCOLCHAR(':');
   7631                  SERIAL_PROTOCOL(thermalManager.getHeaterPower(e));
   7632                }
   7633              #endif
   7634            }
   \                     ??print_heaterstates_10: (+1)
   \      0x17A   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return
   7635          #endif
   7636          
   7637          /**
   7638           * M105: Read hot end and bed temperature
   7639           */

   \                                 In section .text, align 4
   7640          inline void gcode_M105() {
   \                     _Z10gcode_M105v: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   7641            if (get_target_extruder_from_command(105)) return;
   \        0x2   0x2069             MOVS     R0,#+105
   \        0x4   0x.... 0x....      BL       _Z32get_target_extruder_from_commandi
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD115             BNE.N    ??gcode_M105_1
   7642          
   7643            /*--mks cfg begin-- HAS_TEMP_BED */
   7644            /*
   7645            #if HAS_TEMP_HOTEND || HAS_TEMP_BED
   7646              SERIAL_PROTOCOLPGM(MSG_OK);
   7647              print_heaterstates();
   7648            #else // !HAS_TEMP_HOTEND && !HAS_TEMP_BED
   7649              SERIAL_ERROR_START;
   7650              SERIAL_ERRORLNPGM(MSG_ERR_NO_THERMISTORS);
   7651            #endif
   7652          */
   7653          	  SERIAL_PROTOCOLPGM(MSG_OK);
   \        0xC   0x480B             LDR.N    R0,??gcode_M105_0
   \        0xE   0x.... 0x....      BL       _Z14serialprintPGMPKc
   7654          	  print_heaterstates();
   \       0x12   0x.... 0x....      BL       _Z18print_heaterstatesv
   7655          
   7656            /*--mks cfg end-- HAS_TEMP_BED */
   7657          
   7658            SERIAL_EOL;
   \       0x16   0x480A             LDR.N    R0,??gcode_M105_0+0x4
   \       0x18   0x79C0             LDRB     R0,[R0, #+7]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD105             BNE.N    ??gcode_M105_2
   \       0x1E   0x210A             MOVS     R1,#+10
   \       0x20   0x4808             LDR.N    R0,??gcode_M105_0+0x8
   \       0x22   0xE8BD 0x4004      POP      {R2,LR}
   \       0x26   0x.... 0x....      B.W      _ZN12MarlinSerial5writeEh
   \                     ??gcode_M105_2: (+1)
   \       0x2A   0x2200             MOVS     R2,#+0
   \       0x2C   0x210A             MOVS     R1,#+10
   \       0x2E   0x4806             LDR.N    R0,??gcode_M105_0+0xC
   \       0x30   0xE8BD 0x4008      POP      {R3,LR}
   \       0x34   0x.... 0x....      B.W      _ZN12MarlinSerial5printEci
   7659          }
   \                     ??gcode_M105_1: (+1)
   \       0x38   0xBD01             POP      {R0,PC}          ;; return
   \       0x3A   0xBF00             Nop      
   \                     ??gcode_M105_0:
   \       0x3C   0x....'....        DC32     _ZZ10gcode_M105vEs
   \       0x40   0x....'....        DC32     mks_heating_busy
   \       0x44   0x....'....        DC32     customizedSerial
   \       0x48   0x....'....        DC32     serial2
   7660          
   7661          /*--mks cfg-- HAS_TEMP_BED --*/
   7662          //#if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
   7663          #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND )
   7664          
   7665            static uint8_t auto_report_temp_interval;
   7666            static millis_t next_temp_report_ms;
   7667          
   7668            /**
   7669             * M155: Set temperature auto-report interval. M155 S<seconds>
   7670             */
   7671            inline void gcode_M155() {
   7672              if (code_seen('S')) {
   7673                auto_report_temp_interval = code_value_byte();
   7674                NOMORE(auto_report_temp_interval, 60);
   7675                next_temp_report_ms = millis() + 1000UL * auto_report_temp_interval;
   7676              }
   7677            }
   7678          
   7679            inline void auto_report_temperatures() {
   7680              if (auto_report_temp_interval && ELAPSED(millis(), next_temp_report_ms)) {
   7681                next_temp_report_ms = millis() + 1000UL * auto_report_temp_interval;
   7682                print_heaterstates();
   7683                SERIAL_EOL;
   7684              }
   7685            }
   7686          
   7687          #endif // AUTO_REPORT_TEMPERATURES
   7688          
   7689          #if FAN_COUNT > 0
   7690          
   7691            /**
   7692             * M106: Set Fan Speed
   7693             *
   7694             *  S<int>   Speed between 0-255
   7695             *  P<index> Fan index, if more than one fan
   7696             */

   \                                 In section .text, align 4
   7697            inline void gcode_M106() {
   \                     _Z10gcode_M106v: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   7698              uint16_t s = code_seen('S') ? code_value_ushort() : 255,
   \        0x2   0x2053             MOVS     R0,#+83
   \        0x4   0x.... 0x....      BL       _Z9code_seenc
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD003             BEQ.N    ??gcode_M106_1
   \        0xC   0x.... 0x....      BL       _Z17code_value_ushortv
   \       0x10   0x4604             MOV      R4,R0
   \       0x12   0xE000             B.N      ??gcode_M106_2
   \                     ??gcode_M106_1: (+1)
   \       0x14   0x24FF             MOVS     R4,#+255
   7699                       p = code_seen('P') ? code_value_ushort() : 0;
   \                     ??gcode_M106_2: (+1)
   \       0x16   0x2050             MOVS     R0,#+80
   \       0x18   0x.... 0x....      BL       _Z9code_seenc
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD002             BEQ.N    ??gcode_M106_3
   \       0x20   0x.... 0x....      BL       _Z17code_value_ushortv
   \       0x24   0xE000             B.N      ??gcode_M106_4
   \                     ??gcode_M106_3: (+1)
   \       0x26   0x2000             MOVS     R0,#+0
   7700              NOMORE(s, 255);
   \                     ??gcode_M106_4: (+1)
   \       0x28   0x2CFF             CMP      R4,#+255
   \       0x2A   0xDD00             BLE.N    ??gcode_M106_5
   \       0x2C   0x24FF             MOVS     R4,#+255
   7701              if (p < FAN_COUNT) 	/*--mks--*/
   \                     ??gcode_M106_5: (+1)
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD109             BNE.N    ??gcode_M106_6
   7702          		{
   7703          		fanSpeeds[p] = s;
   \       0x32   0x4805             LDR.N    R0,??gcode_M106_0
   \       0x34   0x6004             STR      R4,[R0, #+0]
   7704          		TIM1->CCR1 = s*10000/255;
   \       0x36   0xF242 0x7010      MOVW     R0,#+10000
   \       0x3A   0x4344             MULS     R4,R0,R4
   \       0x3C   0x20FF             MOVS     R0,#+255
   \       0x3E   0xFB94 0xF0F0      SDIV     R0,R4,R0
   \       0x42   0x4902             LDR.N    R1,??gcode_M106_0+0x4  ;; 0x40012c34
   \       0x44   0x6008             STR      R0,[R1, #+0]
   7705          		}
   7706            }
   \                     ??gcode_M106_6: (+1)
   \       0x46   0xBD10             POP      {R4,PC}          ;; return
   \                     ??gcode_M106_0:
   \       0x48   0x....'....        DC32     fanSpeeds
   \       0x4C   0x4001'2C34        DC32     0x40012c34
   7707          
   7708            /**
   7709             * M107: Fan Off
   7710             */

   \                                 In section .text, align 4
   7711            inline void gcode_M107() {
   \                     _Z10gcode_M107v: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   7712              uint16_t p = code_seen('P') ? code_value_ushort() : 0;
   \        0x2   0x2050             MOVS     R0,#+80
   \        0x4   0x.... 0x....      BL       _Z9code_seenc
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD002             BEQ.N    ??gcode_M107_1
   \        0xC   0x.... 0x....      BL       _Z17code_value_ushortv
   \       0x10   0xE000             B.N      ??gcode_M107_2
   \                     ??gcode_M107_1: (+1)
   \       0x12   0x2000             MOVS     R0,#+0
   7713              if (p < FAN_COUNT) 	/*--mks--*/
   \                     ??gcode_M107_2: (+1)
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD104             BNE.N    ??gcode_M107_3
   7714          		{
   7715          		fanSpeeds[p] = 0;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x4902             LDR.N    R1,??gcode_M107_0
   \       0x1C   0x6008             STR      R0,[R1, #+0]
   7716          		TIM1->CCR1 = 0 ;
   \       0x1E   0x4902             LDR.N    R1,??gcode_M107_0+0x4  ;; 0x40012c34
   \       0x20   0x6008             STR      R0,[R1, #+0]
   7717              	}
   7718            }
   \                     ??gcode_M107_3: (+1)
   \       0x22   0xBD01             POP      {R0,PC}          ;; return
   \                     ??gcode_M107_0:
   \       0x24   0x....'....        DC32     fanSpeeds
   \       0x28   0x4001'2C34        DC32     0x40012c34
   7719          
   7720          #endif // FAN_COUNT > 0
   7721          
   7722          #if DISABLED(EMERGENCY_PARSER)
   7723          
   7724            /**
   7725             * M108: Stop the waiting for heaters in M109, M190, M303. Does not affect the target temperature.
   7726             */

   \                                 In section .text, align 4
   7727            inline void gcode_M108() { wait_for_heatup = false; }
   \                     _Z10gcode_M108v: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x4901             LDR.N    R1,??gcode_M108_0
   \        0x4   0x70C8             STRB     R0,[R1, #+3]
   \        0x6   0x4770             BX       LR               ;; return
   \                     ??gcode_M108_0:
   \        0x8   0x....'....        DC32     mks_heating_busy
   7728          
   7729          
   7730            /**
   7731             * M112: Emergency Stop
   7732             */

   \                                 In section .text, align 4
   7733            inline void gcode_M112() { kill(PSTR(MSG_KILLED)); }
   \                     _Z10gcode_M112v: (+1)
   \        0x0   0x4801             LDR.N    R0,??gcode_M112_0
   \        0x2   0x.... 0x....      B.W      _Z4killPKc
   \        0x6   0xBF00             Nop      
   \                     ??gcode_M112_0:
   \        0x8   0x....'....        DC32     _ZZ10gcode_M112vEs
   7734          
   7735          
   7736            /**
   7737             * M410: Quickstop - Abort all planned moves
   7738             *
   7739             * This will stop the carriages mid-move, so most likely they
   7740             * will be out of sync with the stepper position after this.
   7741             */

   \                                 In section .text, align 2
   7742            inline void gcode_M410() { quickstop_stepper(); }
   \                     _Z10gcode_M410v: (+1)
   \        0x0   0x.... 0x....      B.W      _Z17quickstop_stepperv
   7743          
   7744          #endif
   7745          
   7746          /**
   7747           * M109: Sxxx Wait for extruder(s) to reach temperature. Waits only when heating.
   7748           *       Rxxx Wait for extruder(s) to reach temperature. Waits when heating and cooling.
   7749           */
   7750          
   7751          #ifndef MIN_COOLING_SLOPE_DEG
   7752            #define MIN_COOLING_SLOPE_DEG 1.50
   7753          #endif
   7754          #ifndef MIN_COOLING_SLOPE_TIME
   7755            #define MIN_COOLING_SLOPE_TIME 60
   7756          #endif
   7757          

   \                                 In section .text, align 4
   7758          inline void gcode_M109() {
   \                     _Z10gcode_M109v: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   7759          
   7760            if (get_target_extruder_from_command(109)) return;
   \        0x4   0x206D             MOVS     R0,#+109
   \        0x6   0x.... 0x....      BL       _Z32get_target_extruder_from_commandi
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xF040 0x8116      BNE.W    ??gcode_M109_2
   7761            if (DEBUGGING(DRYRUN)) return;
   \       0x10   0x488B             LDR.N    R0,??gcode_M109_1
   \       0x12   0x7840             LDRB     R0,[R0, #+1]
   \       0x14   0x0700             LSLS     R0,R0,#+28
   \       0x16   0xF100 0x8111      BMI.W    ??gcode_M109_2
   7762          
   7763            #if ENABLED(SINGLENOZZLE)
   7764              if (target_extruder != active_extruder) return;
   7765            #endif
   7766          
   7767            const bool no_wait_for_cooling = code_seen('S');
   \       0x1A   0x2053             MOVS     R0,#+83
   \       0x1C   0x.... 0x....      BL       _Z9code_seenc
   \       0x20   0x0004             MOVS     R4,R0
   7768            if (no_wait_for_cooling || code_seen('R')) {
   \       0x22   0xD105             BNE.N    ??gcode_M109_3
   \       0x24   0x2052             MOVS     R0,#+82
   \       0x26   0x.... 0x....      BL       _Z9code_seenc
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xF000 0x8106      BEQ.W    ??gcode_M109_2
   7769              const int16_t temp = code_value_temp_abs();
   \                     ??gcode_M109_3: (+1)
   \       0x30   0x.... 0x....      BL       _Z19code_value_temp_absv
   7770              thermalManager.setTargetHotend(temp, target_extruder);
   \       0x34   0x4D82             LDR.N    R5,??gcode_M109_1
   \       0x36   0x7969             LDRB     R1,[R5, #+5]
   \       0x38   0x460E             MOV      R6,R1
   \       0x3A   0x.... 0x....      BL       __aeabi_i2f
   \       0x3E   0x4631             MOV      R1,R6
   \       0x40   0x.... 0x....      BL       _ZN11Temperature15setTargetHotendEfh
   7771              #if ENABLED(DUAL_X_CARRIAGE)
   7772                if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && target_extruder == 0)
   7773                  thermalManager.setTargetHotend(temp ? temp + duplicate_extruder_temp_offset : 0, 1);
   7774              #endif
   7775          
   7776              #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
   7777                /**
   7778                 * Use half EXTRUDE_MINTEMP to allow nozzles to be put into hot
   7779                 * standby mode, (e.g., in a dual extruder setup) without affecting
   7780                 * the running print timer.
   7781                 */
   7782                if (code_value_temp_abs() <= (EXTRUDE_MINTEMP) / 2) {
   \       0x44   0x.... 0x....      BL       _Z19code_value_temp_absv
   \       0x48   0xF505 0x7662      ADD      R6,R5,#+904
   \       0x4C   0x.... 0x....      BL       __aeabi_i2f
   \       0x50   0x4601             MOV      R1,R0
   \       0x52   0x460F             MOV      R7,R1
   \       0x54   0x487B             LDR.N    R0,??gcode_M109_1+0x4
   \       0x56   0x6AC1             LDR      R1,[R0, #+44]
   \       0x58   0xF04F 0x507C      MOV      R0,#+1056964608
   \       0x5C   0x.... 0x....      BL       __aeabi_fmul
   \       0x60   0x4639             MOV      R1,R7
   \       0x62   0x.... 0x....      BL       __aeabi_cfrcmple
   \       0x66   0x4630             MOV      R0,R6
   \       0x68   0xD806             BHI.N    ??gcode_M109_4
   7783                  print_job_timer.stop();
   \       0x6A   0x.... 0x....      BL       _ZN9Stopwatch4stopEv
   7784                  LCD_MESSAGEPGM(WELCOME_MSG);
   \       0x6E   0x2100             MOVS     R1,#+0
   \       0x70   0x4875             LDR.N    R0,??gcode_M109_1+0x8
   \       0x72   0x.... 0x....      BL       _Z16lcd_setstatuspgmPKch
   \       0x76   0xE001             B.N      ??gcode_M109_5
   7785                }
   7786                else
   7787                  print_job_timer.start();
   \                     ??gcode_M109_4: (+1)
   \       0x78   0x.... 0x....      BL       _ZN9Stopwatch5startEv
   7788              #endif
   7789          
   7790              //if (thermalManager.isHeatingHotend(target_extruder)) lcd_status_printf_P(0, PSTR("E%i %s"), target_extruder + 1, MSG_HEATING);
   7791              //if (thermalManager.isHeatingHotend(target_extruder))  LCD_MESSAGEPGM("E1 Heating...");        //mks
   7792          	if (code_value_temp_abs() > thermalManager.degHotend(target_extruder))
   \                     ??gcode_M109_5: (+1)
   \       0x7C   0x7968             LDRB     R0,[R5, #+5]
   \       0x7E   0x.... 0x....      BL       _ZN11Temperature9degHotendEh
   \       0x82   0x4606             MOV      R6,R0
   \       0x84   0x.... 0x....      BL       _Z19code_value_temp_absv
   \       0x88   0x.... 0x....      BL       __aeabi_i2f
   \       0x8C   0x4601             MOV      R1,R0
   \       0x8E   0x4630             MOV      R0,R6
   \       0x90   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x94   0xD21F             BCS.N    ??gcode_M109_6
   7793          		{
   7794          		switch(target_extruder)
   \       0x96   0x7968             LDRB     R0,[R5, #+5]
   \       0x98   0x2804             CMP      R0,#+4
   \       0x9A   0xD81C             BHI.N    ??gcode_M109_6
   \       0x9C   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??gcode_M109_0:
   \       0xA0   0x03 0x08          DC8      0x3,0x8,0xD,0x12
   \              0x0D 0x12    
   \       0xA4   0x17 0x00          DC8      0x17,0x0
   7795          			{
   7796          			case 0:
   7797          				//LCD_MESSAGEPGM("E1 Heating...");
   7798          				LCD_MESSAGEPGM(MSG_HEATING);
   \                     ??gcode_M109_7: (+1)
   \       0xA6   0x2100             MOVS     R1,#+0
   \       0xA8   0x4868             LDR.N    R0,??gcode_M109_1+0xC
   \       0xAA   0x.... 0x....      BL       _Z16lcd_setstatuspgmPKch
   7799          				break;
   \       0xAE   0xE012             B.N      ??gcode_M109_6
   7800          			case 1:
   7801          				LCD_MESSAGEPGM("E2 Heating...");
   \                     ??gcode_M109_8: (+1)
   \       0xB0   0x2100             MOVS     R1,#+0
   \       0xB2   0x4867             LDR.N    R0,??gcode_M109_1+0x10
   \       0xB4   0x.... 0x....      BL       _Z16lcd_setstatuspgmPKch
   7802          				break;
   \       0xB8   0xE00D             B.N      ??gcode_M109_6
   7803          			case 2:
   7804          				LCD_MESSAGEPGM("E3 Heating...");
   \                     ??gcode_M109_9: (+1)
   \       0xBA   0x2100             MOVS     R1,#+0
   \       0xBC   0x4865             LDR.N    R0,??gcode_M109_1+0x14
   \       0xBE   0x.... 0x....      BL       _Z16lcd_setstatuspgmPKch
   7805          				break;
   \       0xC2   0xE008             B.N      ??gcode_M109_6
   7806          			case 3:
   7807          				LCD_MESSAGEPGM("E4 Heating...");
   \                     ??gcode_M109_10: (+1)
   \       0xC4   0x2100             MOVS     R1,#+0
   \       0xC6   0x4864             LDR.N    R0,??gcode_M109_1+0x18
   \       0xC8   0x.... 0x....      BL       _Z16lcd_setstatuspgmPKch
   7808          				break;
   \       0xCC   0xE003             B.N      ??gcode_M109_6
   7809          			case 4:
   7810          				LCD_MESSAGEPGM("E5 Heating...");
   \                     ??gcode_M109_11: (+1)
   \       0xCE   0x2100             MOVS     R1,#+0
   \       0xD0   0x4862             LDR.N    R0,??gcode_M109_1+0x1C
   \       0xD2   0x.... 0x....      BL       _Z16lcd_setstatuspgmPKch
   7811          				break;
   7812          			default: break;
   7813          				
   7814          			}
   7815          		}
   7816            }
   7817            else return;
   7818          
   7819            #if ENABLED(AUTOTEMP)
   7820              planner.autotemp_M104_M109();
   \                     ??gcode_M109_6: (+1)
   \       0xD6   0x.... 0x....      BL       _ZN7Planner18autotemp_M104_M109Ev
   7821            #endif
   7822          
   7823            #if TEMP_RESIDENCY_TIME > 0
   7824              millis_t residency_start_ms = 0;
   \       0xDA   0x2000             MOVS     R0,#+0
   7825              // Loop until the temperature has stabilized
   7826              #define TEMP_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_RESIDENCY_TIME) * 1000UL))
   7827            #else
   7828              // Loop until the temperature is very close target
   7829              #define TEMP_CONDITIONS (wants_to_cool ? thermalManager.isCoolingHotend(target_extruder) : thermalManager.isHeatingHotend(target_extruder))
   7830            #endif
   7831          
   7832            float target_temp = -1.0, old_temp = 9999.0;
   \       0xDC   0x4F60             LDR.N    R7,??gcode_M109_1+0x20  ;; 0xbf800000
   \       0xDE   0xF8DF 0xA184      LDR.W    R10,??gcode_M109_1+0x24  ;; 0x461c3c00
   7833            bool wants_to_cool = false;
   \       0xE2   0x4605             MOV      R5,R0
   7834            wait_for_heatup = true;
   \       0xE4   0xF8DF 0x9158      LDR.W    R9,??gcode_M109_1
   \       0xE8   0x2101             MOVS     R1,#+1
   \       0xEA   0xF889 0x1003      STRB     R1,[R9, #+3]
   7835            millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
   \       0xEE   0x4601             MOV      R1,R0
   \       0xF0   0x4606             MOV      R6,R0
   7836          
   7837            KEEPALIVE_STATE(NOT_BUSY);
   \       0xF2   0x4602             MOV      R2,R0
   \       0xF4   0xF889 0x2006      STRB     R2,[R9, #+6]
   7838          
   7839            #if ENABLED(PRINTER_EVENT_LEDS)
   7840              const float start_temp = thermalManager.degHotend(target_extruder);
   7841              uint8_t old_blue = 0;
   7842            #endif
   7843          
   7844            mks_heating_busy = 1;
   \       0xF8   0x2201             MOVS     R2,#+1
   \       0xFA   0xF889 0x2000      STRB     R2,[R9, #+0]
   \       0xFE   0x9401             STR      R4,[SP, #+4]
   \      0x100   0x4604             MOV      R4,R0
   \      0x102   0x9100             STR      R1,[SP, #+0]
   7845          
   7846            do {
   7847              //cancel m109 waiting for narno print_pin 
   7848              //if(cancel_heatup) {
   7849               // cancel_heatup = false;
   7850               // break;
   7851              //}
   7852              // Target temperature might be changed during the loop
   7853              if (target_temp != thermalManager.degTargetHotend(target_extruder)) {
   \                     ??gcode_M109_12: (+1)
   \      0x104   0xF899 0x8005      LDRB     R8,[R9, #+5]
   \      0x108   0x4640             MOV      R0,R8
   \      0x10A   0x.... 0x....      BL       _ZN11Temperature15degTargetHotendEh
   \      0x10E   0x4601             MOV      R1,R0
   \      0x110   0x4638             MOV      R0,R7
   \      0x112   0x.... 0x....      BL       __aeabi_cfcmpeq
   \      0x116   0xD00C             BEQ.N    ??gcode_M109_13
   7854                wants_to_cool = thermalManager.isCoolingHotend(target_extruder);
   \      0x118   0x4640             MOV      R0,R8
   \      0x11A   0x.... 0x....      BL       _ZN11Temperature15isCoolingHotendEh
   \      0x11E   0x4605             MOV      R5,R0
   7855                target_temp = thermalManager.degTargetHotend(target_extruder);
   \      0x120   0x4640             MOV      R0,R8
   \      0x122   0x.... 0x....      BL       _ZN11Temperature15degTargetHotendEh
   \      0x126   0x4607             MOV      R7,R0
   7856          
   7857                // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
   7858                if (no_wait_for_cooling && wants_to_cool) break;
   \      0x128   0x9801             LDR      R0,[SP, #+4]
   \      0x12A   0x2800             CMP      R0,#+0
   \      0x12C   0xD001             BEQ.N    ??gcode_M109_13
   \      0x12E   0x2D00             CMP      R5,#+0
   \      0x130   0xD178             BNE.N    ??gcode_M109_14
   7859              }
   7860          
   7861              now = millis();
   \                     ??gcode_M109_13: (+1)
   \      0x132   0x.... 0x....      BL       HAL_GetTick
   \      0x136   0x4680             MOV      R8,R0
   7862              if (ELAPSED(now, next_temp_ms)) { //Print temp & remaining time every 1s while waiting
   \      0x138   0x9800             LDR      R0,[SP, #+0]
   \      0x13A   0xEBB8 0x0000      SUBS     R0,R8,R0
   \      0x13E   0xD431             BMI.N    ??gcode_M109_15
   7863                next_temp_ms = now + 1000UL;
   \      0x140   0xF508 0x707A      ADD      R0,R8,#+1000
   \      0x144   0x9000             STR      R0,[SP, #+0]
   7864                print_heaterstates();
   \      0x146   0x.... 0x....      BL       _Z18print_heaterstatesv
   7865                #if TEMP_RESIDENCY_TIME > 0
   7866                  SERIAL_PROTOCOLPGM(" W:");
   \      0x14A   0x4847             LDR.N    R0,??gcode_M109_1+0x28
   \      0x14C   0x.... 0x....      BL       _Z14serialprintPGMPKc
   7867                  if (residency_start_ms) {
   \      0x150   0x2C00             CMP      R4,#+0
   \      0x152   0xD024             BEQ.N    ??gcode_M109_16
   7868                    long rem = (((TEMP_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL;
   \      0x154   0xF242 0x7010      MOVW     R0,#+10000
   \      0x158   0xEBA0 0x0008      SUB      R0,R0,R8
   \      0x15C   0x1820             ADDS     R0,R4,R0
   \      0x15E   0xF44F 0x717A      MOV      R1,#+1000
   \      0x162   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   7869                    SERIAL_PROTOCOLLN(rem);
   \      0x166   0xF899 0x0007      LDRB     R0,[R9, #+7]
   \      0x16A   0x2800             CMP      R0,#+0
   \      0x16C   0xD104             BNE.N    ??gcode_M109_17
   \      0x16E   0x220A             MOVS     R2,#+10
   \      0x170   0x483E             LDR.N    R0,??gcode_M109_1+0x2C
   \      0x172   0x.... 0x....      BL       _ZN12MarlinSerial5printEli
   \      0x176   0xE003             B.N      ??gcode_M109_18
   \                     ??gcode_M109_17: (+1)
   \      0x178   0x220A             MOVS     R2,#+10
   \      0x17A   0x483D             LDR.N    R0,??gcode_M109_1+0x30
   \      0x17C   0x.... 0x....      BL       _ZN12MarlinSerial5printEli
   \                     ??gcode_M109_18: (+1)
   \      0x180   0xF899 0x0007      LDRB     R0,[R9, #+7]
   \      0x184   0x2800             CMP      R0,#+0
   \      0x186   0xD104             BNE.N    ??gcode_M109_19
   \      0x188   0x210A             MOVS     R1,#+10
   \      0x18A   0x4838             LDR.N    R0,??gcode_M109_1+0x2C
   \      0x18C   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \      0x190   0xE008             B.N      ??gcode_M109_15
   \                     ??gcode_M109_19: (+1)
   \      0x192   0x2200             MOVS     R2,#+0
   \      0x194   0x210A             MOVS     R1,#+10
   \      0x196   0x4836             LDR.N    R0,??gcode_M109_1+0x30
   \      0x198   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   \      0x19C   0xE002             B.N      ??gcode_M109_15
   7870                  }
   7871                  else {
   7872                    SERIAL_PROTOCOLLNPGM("?");
   \                     ??gcode_M109_16: (+1)
   \      0x19E   0x4835             LDR.N    R0,??gcode_M109_1+0x34
   \      0x1A0   0x.... 0x....      BL       _Z14serialprintPGMPKc
   7873                  }
   7874                #else
   7875                  SERIAL_EOL;
   7876                #endif
   7877              }
   7878          
   7879              idle();
   \                     ??gcode_M109_15: (+1)
   \      0x1A4   0x2000             MOVS     R0,#+0
   \      0x1A6   0x.... 0x....      BL       _Z4idleb
   7880              refresh_cmd_timeout(); // to prevent stepper_inactive_time from running out
   \      0x1AA   0x.... 0x....      BL       _Z19refresh_cmd_timeoutv
   7881          
   7882              const float temp = thermalManager.degHotend(target_extruder);
   \      0x1AE   0xF899 0x0005      LDRB     R0,[R9, #+5]
   \      0x1B2   0x.... 0x....      BL       _ZN11Temperature9degHotendEh
   \      0x1B6   0x4683             MOV      R11,R0
   7883          
   7884              #if ENABLED(PRINTER_EVENT_LEDS)
   7885                // Gradually change LED strip from violet to red as nozzle heats up
   7886                if (!wants_to_cool) {
   7887                  const uint8_t blue = map(constrain(temp, start_temp, target_temp), start_temp, target_temp, 255, 0);
   7888                  if (blue != old_blue) set_led_color(255, 0, (old_blue = blue));
   7889                }
   7890              #endif
   7891          
   7892              #if TEMP_RESIDENCY_TIME > 0
   7893          
   7894                const float temp_diff = fabs(target_temp - temp);
   \      0x1B8   0x4638             MOV      R0,R7
   \      0x1BA   0x4659             MOV      R1,R11
   \      0x1BC   0x.... 0x....      BL       __aeabi_fsub
   \      0x1C0   0xF020 0x4000      BIC      R0,R0,#0x80000000
   7895          
   7896                if (!residency_start_ms) {
   \      0x1C4   0x2C00             CMP      R4,#+0
   \      0x1C6   0xD106             BNE.N    ??gcode_M109_20
   7897                  // Start the TEMP_RESIDENCY_TIME timer when we reach target temp for the first time.
   7898                  if (temp_diff < TEMP_WINDOW) residency_start_ms = now;
   \      0x1C8   0xF04F 0x517E      MOV      R1,#+1065353216
   \      0x1CC   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x1D0   0xD206             BCS.N    ??gcode_M109_21
   \      0x1D2   0x4644             MOV      R4,R8
   \      0x1D4   0xE004             B.N      ??gcode_M109_21
   7899                }
   7900                else if (temp_diff > TEMP_HYSTERESIS) {
   \                     ??gcode_M109_20: (+1)
   \      0x1D6   0x4928             LDR.N    R1,??gcode_M109_1+0x38  ;; 0x40000001
   \      0x1D8   0x.... 0x....      BL       __aeabi_cfrcmple
   \      0x1DC   0xD800             BHI.N    ??gcode_M109_21
   7901                  // Restart the timer whenever the temperature falls outside the hysteresis.
   7902                  residency_start_ms = now;
   \      0x1DE   0x4644             MOV      R4,R8
   7903                }
   7904          
   7905              #endif
   7906          
   7907              // Prevent a wait-forever situation if R is misused i.e. M109 R0
   7908              if (wants_to_cool) {
   \                     ??gcode_M109_21: (+1)
   \      0x1E0   0x2D00             CMP      R5,#+0
   \      0x1E2   0xD011             BEQ.N    ??gcode_M109_22
   7909                // break after MIN_COOLING_SLOPE_TIME seconds
   7910                // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG
   7911                if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
   \      0x1E4   0x2E00             CMP      R6,#+0
   \      0x1E6   0xD002             BEQ.N    ??gcode_M109_23
   \      0x1E8   0xEBB8 0x0006      SUBS     R0,R8,R6
   \      0x1EC   0xD40C             BMI.N    ??gcode_M109_22
   7912                  if (old_temp - temp < MIN_COOLING_SLOPE_DEG) break;
   \                     ??gcode_M109_23: (+1)
   \      0x1EE   0x4650             MOV      R0,R10
   \      0x1F0   0x4659             MOV      R1,R11
   \      0x1F2   0x.... 0x....      BL       __aeabi_fsub
   \      0x1F6   0xF04F 0x517F      MOV      R1,#+1069547520
   \      0x1FA   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x1FE   0xD311             BCC.N    ??gcode_M109_14
   7913                  next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME;
   \      0x200   0xF508 0x466A      ADD      R6,R8,#+59904
   \      0x204   0x3660             ADDS     R6,R6,#+96
   7914                  old_temp = temp;
   \      0x206   0x46DA             MOV      R10,R11
   7915                }
   7916              }
   7917          
   7918            } while (wait_for_heatup && TEMP_CONDITIONS);
   \                     ??gcode_M109_22: (+1)
   \      0x208   0xF899 0x0003      LDRB     R0,[R9, #+3]
   \      0x20C   0x2800             CMP      R0,#+0
   \      0x20E   0xD009             BEQ.N    ??gcode_M109_14
   \      0x210   0x2C00             CMP      R4,#+0
   \      0x212   0xF43F 0xAF77      BEQ.W    ??gcode_M109_12
   \      0x216   0xEBA8 0x0804      SUB      R8,R8,R4
   \      0x21A   0x4818             LDR.N    R0,??gcode_M109_1+0x3C  ;; 0xffffd8f0
   \      0x21C   0xEB10 0x0808      ADDS     R8,R0,R8
   \      0x220   0xF53F 0xAF70      BMI.W    ??gcode_M109_12
   7919          
   7920            mks_heating_busy = 0;
   \                     ??gcode_M109_14: (+1)
   \      0x224   0x464C             MOV      R4,R9
   \      0x226   0x2000             MOVS     R0,#+0
   \      0x228   0x7020             STRB     R0,[R4, #+0]
   7921          
   7922            if (wait_for_heatup) {
   \      0x22A   0x78E0             LDRB     R0,[R4, #+3]
   \      0x22C   0x2800             CMP      R0,#+0
   \      0x22E   0xD003             BEQ.N    ??gcode_M109_24
   7923              LCD_MESSAGEPGM(MSG_HEATING_COMPLETE);
   \      0x230   0x2100             MOVS     R1,#+0
   \      0x232   0x4813             LDR.N    R0,??gcode_M109_1+0x40
   \      0x234   0x.... 0x....      BL       _Z16lcd_setstatuspgmPKch
   7924              #if ENABLED(PRINTER_EVENT_LEDS)
   7925                #if ENABLED(RGBW_LED)
   7926                  set_led_color(0, 0, 0, 255);  // Turn on the WHITE LED
   7927                #else
   7928                  set_led_color(255, 255, 255); // Set LEDs All On
   7929                #endif
   7930              #endif
   7931            }
   7932          
   7933            KEEPALIVE_STATE(IN_HANDLER);
   \                     ??gcode_M109_24: (+1)
   \      0x238   0x2001             MOVS     R0,#+1
   \      0x23A   0x71A0             STRB     R0,[R4, #+6]
   7934          }
   \                     ??gcode_M109_2: (+1)
   \      0x23C   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
   \                     ??gcode_M109_1:
   \      0x240   0x....'....        DC32     mks_heating_busy
   \      0x244   0x....'....        DC32     mksCfg
   \      0x248   0x....'....        DC32     WELCOME_MSG
   \      0x24C   0x....'....        DC32     MSG_HEATING
   \      0x250   0x....'....        DC32     _ZZ10gcode_M109vEs
   \      0x254   0x....'....        DC32     _ZZ10gcode_M109vEs_0
   \      0x258   0x....'....        DC32     _ZZ10gcode_M109vEs_1
   \      0x25C   0x....'....        DC32     _ZZ10gcode_M109vEs_2
   \      0x260   0xBF80'0000        DC32     0xbf800000
   \      0x264   0x461C'3C00        DC32     0x461c3c00
   \      0x268   0x....'....        DC32     _ZZ10gcode_M109vEs_3
   \      0x26C   0x....'....        DC32     customizedSerial
   \      0x270   0x....'....        DC32     serial2
   \      0x274   0x....'....        DC32     _ZZ10gcode_M109vEs_4
   \      0x278   0x4000'0001        DC32     0x40000001
   \      0x27C   0xFFFF'D8F0        DC32     0xffffd8f0
   \      0x280   0x....'....        DC32     MSG_HEATING_COMPLETE
   7935          
   7936          /*--mks cfg-- HAS_TEMP_BED --*/
   7937          //#if HAS_TEMP_BED
   7938          #if 1
   7939            #ifndef MIN_COOLING_SLOPE_DEG_BED
   7940              #define MIN_COOLING_SLOPE_DEG_BED 1.50
   7941            #endif
   7942            #ifndef MIN_COOLING_SLOPE_TIME_BED
   7943              #define MIN_COOLING_SLOPE_TIME_BED 60
   7944            #endif
   7945          
   7946            /**
   7947             * M190: Sxxx Wait for bed current temp to reach target temp. Waits only when heating
   7948             *       Rxxx Wait for bed current temp to reach target temp. Waits when heating and cooling
   7949             */

   \                                 In section .text, align 4
   7950            inline void gcode_M190() {
   \                     _Z10gcode_M190v: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   7951              if (DEBUGGING(DRYRUN)) return;
   \        0x4   0x4D69             LDR.N    R5,??gcode_M190_0
   \        0x6   0x7868             LDRB     R0,[R5, #+1]
   \        0x8   0x0700             LSLS     R0,R0,#+28
   \        0xA   0xF100 0x80CC      BMI.W    ??gcode_M190_1
   7952          
   7953              LCD_MESSAGEPGM(MSG_BED_HEATING);
   \        0xE   0x2100             MOVS     R1,#+0
   \       0x10   0x4867             LDR.N    R0,??gcode_M190_0+0x4
   \       0x12   0x.... 0x....      BL       _Z16lcd_setstatuspgmPKch
   7954              const bool no_wait_for_cooling = code_seen('S');
   \       0x16   0x2053             MOVS     R0,#+83
   \       0x18   0x.... 0x....      BL       _Z9code_seenc
   \       0x1C   0x0004             MOVS     R4,R0
   7955              if (no_wait_for_cooling || code_seen('R')) {
   \       0x1E   0xD105             BNE.N    ??gcode_M190_2
   \       0x20   0x2052             MOVS     R0,#+82
   \       0x22   0x.... 0x....      BL       _Z9code_seenc
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xF000 0x80BD      BEQ.W    ??gcode_M190_1
   7956                thermalManager.setTargetBed(code_value_temp_abs());
   \                     ??gcode_M190_2: (+1)
   \       0x2C   0x.... 0x....      BL       _Z19code_value_temp_absv
   \       0x30   0x.... 0x....      BL       __aeabi_i2f
   \       0x34   0x.... 0x....      BL       _ZN11Temperature12setTargetBedEf
   7957                #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
   7958                  if (code_value_temp_abs() > BED_MINTEMP)
   \       0x38   0x.... 0x....      BL       _Z19code_value_temp_absv
   \       0x3C   0xF110 0x0F04      CMN      R0,#+4
   \       0x40   0xDB03             BLT.N    ??gcode_M190_3
   7959                    print_job_timer.start();
   \       0x42   0xF505 0x7062      ADD      R0,R5,#+904
   \       0x46   0x.... 0x....      BL       _ZN9Stopwatch5startEv
   7960                #endif
   7961              }
   7962              else return;
   7963          
   7964              #if TEMP_BED_RESIDENCY_TIME > 0
   7965                millis_t residency_start_ms = 0;
   \                     ??gcode_M190_3: (+1)
   \       0x4A   0x2000             MOVS     R0,#+0
   7966                // Loop until the temperature has stabilized
   7967                #define  TEMP_BED_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_BED_RESIDENCY_TIME) * 1000UL))
   7968              #else
   7969                // Loop until the temperature is very close target
   7970                #define TEMP_BED_CONDITIONS (wants_to_cool ? thermalManager.isCoolingBed() : thermalManager.isHeatingBed())
   7971              #endif
   7972          
   7973              float target_temp = -1.0, old_temp = 9999.0;
   \       0x4C   0x4F59             LDR.N    R7,??gcode_M190_0+0x8  ;; 0xbf800000
   \       0x4E   0xF8DF 0xA168      LDR.W    R10,??gcode_M190_0+0xC  ;; 0x461c3c00
   7974              bool wants_to_cool = false;
   \       0x52   0x4605             MOV      R5,R0
   7975              wait_for_heatup = true;
   \       0x54   0xF8DF 0x9154      LDR.W    R9,??gcode_M190_0
   \       0x58   0x2101             MOVS     R1,#+1
   \       0x5A   0xF889 0x1003      STRB     R1,[R9, #+3]
   7976              millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
   \       0x5E   0x4601             MOV      R1,R0
   \       0x60   0x4606             MOV      R6,R0
   7977          
   7978              KEEPALIVE_STATE(NOT_BUSY);
   \       0x62   0x4602             MOV      R2,R0
   \       0x64   0xF889 0x2006      STRB     R2,[R9, #+6]
   7979          
   7980              target_extruder = active_extruder; // for print_heaterstates
   \       0x68   0xF899 0x2002      LDRB     R2,[R9, #+2]
   \       0x6C   0xF889 0x2005      STRB     R2,[R9, #+5]
   7981          
   7982              #if ENABLED(PRINTER_EVENT_LEDS)
   7983                const float start_temp = thermalManager.degBed();
   7984                uint8_t old_red = 255;
   7985              #endif
   7986          	
   7987          	mks_heating_busy = 1;
   \       0x70   0x2201             MOVS     R2,#+1
   \       0x72   0xF889 0x2000      STRB     R2,[R9, #+0]
   \       0x76   0x9401             STR      R4,[SP, #+4]
   \       0x78   0x4604             MOV      R4,R0
   \       0x7A   0x9100             STR      R1,[SP, #+0]
   7988          
   7989              do {
   7990                // Target temperature might be changed during the loop
   7991                if (target_temp != thermalManager.degTargetBed()) {
   \                     ??gcode_M190_4: (+1)
   \       0x7C   0x.... 0x....      BL       _ZN11Temperature12degTargetBedEv
   \       0x80   0x4601             MOV      R1,R0
   \       0x82   0x4638             MOV      R0,R7
   \       0x84   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0x88   0xD00A             BEQ.N    ??gcode_M190_5
   7992                  wants_to_cool = thermalManager.isCoolingBed();
   \       0x8A   0x.... 0x....      BL       _ZN11Temperature12isCoolingBedEv
   \       0x8E   0x4605             MOV      R5,R0
   7993                  target_temp = thermalManager.degTargetBed();
   \       0x90   0x.... 0x....      BL       _ZN11Temperature12degTargetBedEv
   \       0x94   0x4607             MOV      R7,R0
   7994          
   7995                  // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
   7996                  if (no_wait_for_cooling && wants_to_cool) break;
   \       0x96   0x9801             LDR      R0,[SP, #+4]
   \       0x98   0x2800             CMP      R0,#+0
   \       0x9A   0xD001             BEQ.N    ??gcode_M190_5
   \       0x9C   0x2D00             CMP      R5,#+0
   \       0x9E   0xD176             BNE.N    ??gcode_M190_6
   7997                }
   7998          
   7999                now = millis();
   \                     ??gcode_M190_5: (+1)
   \       0xA0   0x.... 0x....      BL       HAL_GetTick
   \       0xA4   0x4680             MOV      R8,R0
   8000                if (ELAPSED(now, next_temp_ms)) { //Print Temp Reading every 1 second while heating up.
   \       0xA6   0x9800             LDR      R0,[SP, #+0]
   \       0xA8   0xEBB8 0x0000      SUBS     R0,R8,R0
   \       0xAC   0xD431             BMI.N    ??gcode_M190_7
   8001                  next_temp_ms = now + 1000UL;
   \       0xAE   0xF508 0x707A      ADD      R0,R8,#+1000
   \       0xB2   0x9000             STR      R0,[SP, #+0]
   8002                  print_heaterstates();
   \       0xB4   0x.... 0x....      BL       _Z18print_heaterstatesv
   8003                  #if TEMP_BED_RESIDENCY_TIME > 0
   8004                    SERIAL_PROTOCOLPGM(" W:");
   \       0xB8   0x4840             LDR.N    R0,??gcode_M190_0+0x10
   \       0xBA   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8005                    if (residency_start_ms) {
   \       0xBE   0x2C00             CMP      R4,#+0
   \       0xC0   0xD024             BEQ.N    ??gcode_M190_8
   8006                      long rem = (((TEMP_BED_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL;
   \       0xC2   0xF242 0x7010      MOVW     R0,#+10000
   \       0xC6   0xEBA0 0x0008      SUB      R0,R0,R8
   \       0xCA   0x1820             ADDS     R0,R4,R0
   \       0xCC   0xF44F 0x717A      MOV      R1,#+1000
   \       0xD0   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   8007                      SERIAL_PROTOCOLLN(rem);
   \       0xD4   0xF899 0x0007      LDRB     R0,[R9, #+7]
   \       0xD8   0x2800             CMP      R0,#+0
   \       0xDA   0xD104             BNE.N    ??gcode_M190_9
   \       0xDC   0x220A             MOVS     R2,#+10
   \       0xDE   0x4838             LDR.N    R0,??gcode_M190_0+0x14
   \       0xE0   0x.... 0x....      BL       _ZN12MarlinSerial5printEli
   \       0xE4   0xE003             B.N      ??gcode_M190_10
   \                     ??gcode_M190_9: (+1)
   \       0xE6   0x220A             MOVS     R2,#+10
   \       0xE8   0x4836             LDR.N    R0,??gcode_M190_0+0x18
   \       0xEA   0x.... 0x....      BL       _ZN12MarlinSerial5printEli
   \                     ??gcode_M190_10: (+1)
   \       0xEE   0xF899 0x0007      LDRB     R0,[R9, #+7]
   \       0xF2   0x2800             CMP      R0,#+0
   \       0xF4   0xD104             BNE.N    ??gcode_M190_11
   \       0xF6   0x210A             MOVS     R1,#+10
   \       0xF8   0x4831             LDR.N    R0,??gcode_M190_0+0x14
   \       0xFA   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \       0xFE   0xE008             B.N      ??gcode_M190_7
   \                     ??gcode_M190_11: (+1)
   \      0x100   0x2200             MOVS     R2,#+0
   \      0x102   0x210A             MOVS     R1,#+10
   \      0x104   0x482F             LDR.N    R0,??gcode_M190_0+0x18
   \      0x106   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   \      0x10A   0xE002             B.N      ??gcode_M190_7
   8008                    }
   8009                    else {
   8010                      SERIAL_PROTOCOLLNPGM("?");
   \                     ??gcode_M190_8: (+1)
   \      0x10C   0x482E             LDR.N    R0,??gcode_M190_0+0x1C
   \      0x10E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8011                    }
   8012                  #else
   8013                    SERIAL_EOL;
   8014                  #endif
   8015                }
   8016          
   8017                idle();
   \                     ??gcode_M190_7: (+1)
   \      0x112   0x2000             MOVS     R0,#+0
   \      0x114   0x.... 0x....      BL       _Z4idleb
   8018                refresh_cmd_timeout(); // to prevent stepper_inactive_time from running out
   \      0x118   0x.... 0x....      BL       _Z19refresh_cmd_timeoutv
   8019          
   8020                const float temp = thermalManager.degBed();
   \      0x11C   0x.... 0x....      BL       _ZN11Temperature6degBedEv
   \      0x120   0x4683             MOV      R11,R0
   8021          
   8022                #if ENABLED(PRINTER_EVENT_LEDS)
   8023                  // Gradually change LED strip from blue to violet as bed heats up
   8024                  if (!wants_to_cool) {
   8025                    const uint8_t red = map(constrain(temp, start_temp, target_temp), start_temp, target_temp, 0, 255);
   8026                    if (red != old_red) set_led_color((old_red = red), 0, 255);
   8027                  }
   8028                }
   8029                #endif
   8030          
   8031                #if TEMP_BED_RESIDENCY_TIME > 0
   8032          
   8033                  const float temp_diff = fabs(target_temp - temp);
   \      0x122   0x4638             MOV      R0,R7
   \      0x124   0x4659             MOV      R1,R11
   \      0x126   0x.... 0x....      BL       __aeabi_fsub
   \      0x12A   0xF020 0x4000      BIC      R0,R0,#0x80000000
   8034          
   8035                  if (!residency_start_ms) {
   \      0x12E   0x2C00             CMP      R4,#+0
   \      0x130   0xD106             BNE.N    ??gcode_M190_12
   8036                    // Start the TEMP_BED_RESIDENCY_TIME timer when we reach target temp for the first time.
   8037                    if (temp_diff < TEMP_BED_WINDOW) residency_start_ms = now;
   \      0x132   0xF04F 0x517E      MOV      R1,#+1065353216
   \      0x136   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x13A   0xD206             BCS.N    ??gcode_M190_13
   \      0x13C   0x4644             MOV      R4,R8
   \      0x13E   0xE004             B.N      ??gcode_M190_13
   8038                  }
   8039                  else if (temp_diff > TEMP_BED_HYSTERESIS) {
   \                     ??gcode_M190_12: (+1)
   \      0x140   0x4922             LDR.N    R1,??gcode_M190_0+0x20  ;; 0x40000001
   \      0x142   0x.... 0x....      BL       __aeabi_cfrcmple
   \      0x146   0xD800             BHI.N    ??gcode_M190_13
   8040                    // Restart the timer whenever the temperature falls outside the hysteresis.
   8041                    residency_start_ms = now;
   \      0x148   0x4644             MOV      R4,R8
   8042                  }
   8043          
   8044                #endif // TEMP_BED_RESIDENCY_TIME > 0
   8045          
   8046                // Prevent a wait-forever situation if R is misused i.e. M190 R0
   8047                if (wants_to_cool) {
   \                     ??gcode_M190_13: (+1)
   \      0x14A   0x2D00             CMP      R5,#+0
   \      0x14C   0xD011             BEQ.N    ??gcode_M190_14
   8048                  // Break after MIN_COOLING_SLOPE_TIME_BED seconds
   8049                  // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG_BED
   8050                  if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
   \      0x14E   0x2E00             CMP      R6,#+0
   \      0x150   0xD002             BEQ.N    ??gcode_M190_15
   \      0x152   0xEBB8 0x0006      SUBS     R0,R8,R6
   \      0x156   0xD40C             BMI.N    ??gcode_M190_14
   8051                    if (old_temp - temp < MIN_COOLING_SLOPE_DEG_BED) break;
   \                     ??gcode_M190_15: (+1)
   \      0x158   0x4650             MOV      R0,R10
   \      0x15A   0x4659             MOV      R1,R11
   \      0x15C   0x.... 0x....      BL       __aeabi_fsub
   \      0x160   0xF04F 0x517F      MOV      R1,#+1069547520
   \      0x164   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x168   0xD311             BCC.N    ??gcode_M190_6
   8052                    next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME_BED;
   \      0x16A   0xF508 0x466A      ADD      R6,R8,#+59904
   \      0x16E   0x3660             ADDS     R6,R6,#+96
   8053                    old_temp = temp;
   \      0x170   0x46DA             MOV      R10,R11
   8054                  }
   8055                }
   8056          
   8057              } while (wait_for_heatup && TEMP_BED_CONDITIONS);
   \                     ??gcode_M190_14: (+1)
   \      0x172   0xF899 0x0003      LDRB     R0,[R9, #+3]
   \      0x176   0x2800             CMP      R0,#+0
   \      0x178   0xD009             BEQ.N    ??gcode_M190_6
   \      0x17A   0x2C00             CMP      R4,#+0
   \      0x17C   0xF43F 0xAF7E      BEQ.W    ??gcode_M190_4
   \      0x180   0xEBA8 0x0804      SUB      R8,R8,R4
   \      0x184   0x4812             LDR.N    R0,??gcode_M190_0+0x24  ;; 0xffffd8f0
   \      0x186   0xEB10 0x0808      ADDS     R8,R0,R8
   \      0x18A   0xF53F 0xAF77      BMI.W    ??gcode_M190_4
   8058          	mks_heating_busy = 0;
   \                     ??gcode_M190_6: (+1)
   \      0x18E   0x464C             MOV      R4,R9
   \      0x190   0x2000             MOVS     R0,#+0
   \      0x192   0x7020             STRB     R0,[R4, #+0]
   8059          
   8060              if (wait_for_heatup) LCD_MESSAGEPGM(MSG_BED_DONE);
   \      0x194   0x78E0             LDRB     R0,[R4, #+3]
   \      0x196   0x2800             CMP      R0,#+0
   \      0x198   0xD003             BEQ.N    ??gcode_M190_16
   \      0x19A   0x2100             MOVS     R1,#+0
   \      0x19C   0x480D             LDR.N    R0,??gcode_M190_0+0x28
   \      0x19E   0x.... 0x....      BL       _Z16lcd_setstatuspgmPKch
   8061              KEEPALIVE_STATE(IN_HANDLER);
   \                     ??gcode_M190_16: (+1)
   \      0x1A2   0x2001             MOVS     R0,#+1
   \      0x1A4   0x71A0             STRB     R0,[R4, #+6]
   8062            }
   \                     ??gcode_M190_1: (+1)
   \      0x1A6   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
   \      0x1AA   0xBF00             Nop      
   \                     ??gcode_M190_0:
   \      0x1AC   0x....'....        DC32     mks_heating_busy
   \      0x1B0   0x....'....        DC32     MSG_BED_HEATING
   \      0x1B4   0xBF80'0000        DC32     0xbf800000
   \      0x1B8   0x461C'3C00        DC32     0x461c3c00
   \      0x1BC   0x....'....        DC32     _ZZ10gcode_M190vEs
   \      0x1C0   0x....'....        DC32     customizedSerial
   \      0x1C4   0x....'....        DC32     serial2
   \      0x1C8   0x....'....        DC32     _ZZ10gcode_M190vEs_0
   \      0x1CC   0x4000'0001        DC32     0x40000001
   \      0x1D0   0xFFFF'D8F0        DC32     0xffffd8f0
   \      0x1D4   0x....'....        DC32     MSG_BED_DONE
   8063          
   8064          #endif // HAS_TEMP_BED
   8065          
   8066          /**
   8067           * M110: Set Current Line Number
   8068           */

   \                                 In section .text, align 4
   8069          inline void gcode_M110() {
   \                     _Z10gcode_M110v: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   8070            if (code_seen('N')) gcode_LastN = code_value_long();
   \        0x2   0x204E             MOVS     R0,#+78
   \        0x4   0x.... 0x....      BL       _Z9code_seenc
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD003             BEQ.N    ??gcode_M110_1
   \        0xC   0x.... 0x....      BL       _Z15code_value_longv
   \       0x10   0x4901             LDR.N    R1,??gcode_M110_0
   \       0x12   0x6208             STR      R0,[R1, #+32]
   8071          }
   \                     ??gcode_M110_1: (+1)
   \       0x14   0xBD01             POP      {R0,PC}          ;; return
   \       0x16   0xBF00             Nop      
   \                     ??gcode_M110_0:
   \       0x18   0x....'....        DC32     axis_relative_modes
   8072          
   8073          /**
   8074           * M111: Set the debug level
   8075           */

   \                                 In section .text, align 4
   8076          inline void gcode_M111() {
   \                     _Z10gcode_M111v: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   8077            marlin_debug_flags = code_seen('S') ? code_value_byte() : (uint8_t)DEBUG_NONE;
   \        0x2   0x4C25             LDR.N    R4,??gcode_M111_0
   \        0x4   0x2053             MOVS     R0,#+83
   \        0x6   0x.... 0x....      BL       _Z9code_seenc
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD003             BEQ.N    ??gcode_M111_1
   \        0xE   0x.... 0x....      BL       _Z15code_value_bytev
   \       0x12   0x7060             STRB     R0,[R4, #+1]
   \       0x14   0xE001             B.N      ??gcode_M111_2
   \                     ??gcode_M111_1: (+1)
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x7060             STRB     R0,[R4, #+1]
   8078          
   8079            const static char str_debug_1[] PROGMEM = MSG_DEBUG_ECHO;
   8080            const static char str_debug_2[] PROGMEM = MSG_DEBUG_INFO;
   8081            const static char str_debug_4[] PROGMEM = MSG_DEBUG_ERRORS;
   8082            const static char str_debug_8[] PROGMEM = MSG_DEBUG_DRYRUN;
   8083            const static char str_debug_16[] PROGMEM = MSG_DEBUG_COMMUNICATION;
   8084            #if ENABLED(DEBUG_LEVELING_FEATURE)
   8085              const static char str_debug_32[] PROGMEM = MSG_DEBUG_LEVELING;
   8086            #endif
   8087          
   8088            const static char* const debug_strings[] PROGMEM = {
   8089              str_debug_1, str_debug_2, str_debug_4, str_debug_8, str_debug_16,
   8090              #if ENABLED(DEBUG_LEVELING_FEATURE)
   8091                str_debug_32
   8092              #endif
   8093            };
   8094          
   8095            SERIAL_ECHO_START;
   \                     ??gcode_M111_2: (+1)
   \       0x1A   0x4820             LDR.N    R0,??gcode_M111_0+0x4
   \       0x1C   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8096            SERIAL_ECHOPGM(MSG_DEBUG_PREFIX);
   \       0x20   0x481F             LDR.N    R0,??gcode_M111_0+0x8
   \       0x22   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8097            if (marlin_debug_flags) {
   \       0x26   0x7860             LDRB     R0,[R4, #+1]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD021             BEQ.N    ??gcode_M111_3
   8098              uint8_t comma = 0;
   \       0x2C   0x2500             MOVS     R5,#+0
   8099              for (uint8_t i = 0; i < COUNT(debug_strings); i++) {
   \       0x2E   0x462E             MOV      R6,R5
   \                     ??gcode_M111_4: (+1)
   \       0x30   0x2E05             CMP      R6,#+5
   \       0x32   0xD220             BCS.N    ??gcode_M111_5
   8100                if (TEST(marlin_debug_flags, i)) {
   \       0x34   0x7860             LDRB     R0,[R4, #+1]
   \       0x36   0x2101             MOVS     R1,#+1
   \       0x38   0x40B1             LSLS     R1,R1,R6
   \       0x3A   0x4208             TST      R0,R1
   \       0x3C   0xD016             BEQ.N    ??gcode_M111_6
   8101                  if (comma++) SERIAL_CHAR(',');
   \       0x3E   0x4628             MOV      R0,R5
   \       0x40   0x1C45             ADDS     R5,R0,#+1
   \       0x42   0xB2C0             UXTB     R0,R0
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD00C             BEQ.N    ??gcode_M111_7
   \       0x48   0x79E0             LDRB     R0,[R4, #+7]
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD005             BEQ.N    ??gcode_M111_8
   \       0x4E   0x2200             MOVS     R2,#+0
   \       0x50   0x212C             MOVS     R1,#+44
   \       0x52   0x4814             LDR.N    R0,??gcode_M111_0+0xC
   \       0x54   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   \       0x58   0xE003             B.N      ??gcode_M111_7
   \                     ??gcode_M111_8: (+1)
   \       0x5A   0x212C             MOVS     R1,#+44
   \       0x5C   0x4812             LDR.N    R0,??gcode_M111_0+0x10
   \       0x5E   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   8102                  //serialprintPGM((char*)pgm_read_word(&debug_strings[i]));
   8103                  serialprintPGM((char*)&(debug_strings[i]));
   \                     ??gcode_M111_7: (+1)
   \       0x62   0x4812             LDR.N    R0,??gcode_M111_0+0x14
   \       0x64   0xEB00 0x0086      ADD      R0,R0,R6, LSL #+2
   \       0x68   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8104          		
   8105                }
   8106              }
   \                     ??gcode_M111_6: (+1)
   \       0x6C   0x1C76             ADDS     R6,R6,#+1
   \       0x6E   0xE7DF             B.N      ??gcode_M111_4
   8107            }
   8108            else {
   8109              SERIAL_ECHOPGM(MSG_DEBUG_OFF);
   \                     ??gcode_M111_3: (+1)
   \       0x70   0x480F             LDR.N    R0,??gcode_M111_0+0x18
   \       0x72   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8110            }
   8111            SERIAL_EOL;
   \                     ??gcode_M111_5: (+1)
   \       0x76   0x79E0             LDRB     R0,[R4, #+7]
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD105             BNE.N    ??gcode_M111_9
   \       0x7C   0x210A             MOVS     R1,#+10
   \       0x7E   0x480A             LDR.N    R0,??gcode_M111_0+0x10
   \       0x80   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x84   0x.... 0x....      B.W      _ZN12MarlinSerial5writeEh
   \                     ??gcode_M111_9: (+1)
   \       0x88   0x2200             MOVS     R2,#+0
   \       0x8A   0x210A             MOVS     R1,#+10
   \       0x8C   0x4805             LDR.N    R0,??gcode_M111_0+0xC
   \       0x8E   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x92   0x.... 0x....      B.W      _ZN12MarlinSerial5printEci
   \       0x96   0xBF00             Nop      
   \                     ??gcode_M111_0:
   \       0x98   0x....'....        DC32     mks_heating_busy
   \       0x9C   0x....'....        DC32     echomagic
   \       0xA0   0x....'....        DC32     _ZZ10gcode_M111vEs_4
   \       0xA4   0x....'....        DC32     serial2
   \       0xA8   0x....'....        DC32     customizedSerial
   \       0xAC   0x....'....        DC32     _ZZ10gcode_M111vE13debug_strings
   \       0xB0   0x....'....        DC32     _ZZ10gcode_M111vEs_5
   8112          }

   \                                 In section .rodata, align 4
   \                     _ZZ10gcode_M111vE11str_debug_1:
   \        0x0   0x45 0x43          DC8 "ECHO"
   \              0x48 0x4F    
   \              0x00         
   \        0x5   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     _ZZ10gcode_M111vE11str_debug_2:
   \        0x0   0x49 0x4E          DC8 "INFO"
   \              0x46 0x4F    
   \              0x00         
   \        0x5   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     _ZZ10gcode_M111vE11str_debug_4:
   \        0x0   0x45 0x52          DC8 "ERRORS"
   \              0x52 0x4F    
   \              0x52 0x53    
   \              0x00         
   \        0x7   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     _ZZ10gcode_M111vE11str_debug_8:
   \        0x0   0x44 0x52          DC8 "DRYRUN"
   \              0x59 0x52    
   \              0x55 0x4E    
   \              0x00         
   \        0x7   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     _ZZ10gcode_M111vE12str_debug_16:
   \        0x0   0x43 0x4F          DC8 "COMMUNICATION"
   \              0x4D 0x4D    
   \              0x55 0x4E    
   \              0x49 0x43    
   \              0x41 0x54    
   \              0x49 0x4F    
   \              0x4E 0x00    
   \        0xE   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     _ZZ10gcode_M111vE13debug_strings:
   \        0x0   0x....'....        DC32 _ZZ10gcode_M111vE11str_debug_1, _ZZ10gcode_M111vE11str_debug_2
   \              0x....'....  
   \        0x8   0x....'....        DC32 _ZZ10gcode_M111vE11str_debug_4, _ZZ10gcode_M111vE11str_debug_8
   \              0x....'....  
   \       0x10   0x....'....        DC32 _ZZ10gcode_M111vE12str_debug_16
   8113          
   8114          #if ENABLED(HOST_KEEPALIVE_FEATURE)
   8115          
   8116            /**
   8117             * M113: Get or set Host Keepalive interval (0 to disable)
   8118             *
   8119             *   S<seconds> Optional. Set the keepalive interval.
   8120             */

   \                                 In section .text, align 4
   8121            inline void gcode_M113() {
   \                     _Z10gcode_M113v: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   8122              if (code_seen('S')) {
   \        0x2   0x4C13             LDR.N    R4,??gcode_M113_0
   \        0x4   0x2053             MOVS     R0,#+83
   \        0x6   0x.... 0x....      BL       _Z9code_seenc
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD007             BEQ.N    ??gcode_M113_1
   8123                host_keepalive_interval = code_value_byte();
   \        0xE   0x.... 0x....      BL       _Z15code_value_bytev
   \       0x12   0x7020             STRB     R0,[R4, #+0]
   8124                NOMORE(host_keepalive_interval, 60);
   \       0x14   0x283D             CMP      R0,#+61
   \       0x16   0xDB1A             BLT.N    ??gcode_M113_2
   \       0x18   0x203C             MOVS     R0,#+60
   \       0x1A   0x7020             STRB     R0,[R4, #+0]
   \       0x1C   0xBD10             POP      {R4,PC}
   8125              }
   8126              else {
   8127                SERIAL_ECHO_START;
   \                     ??gcode_M113_1: (+1)
   \       0x1E   0x480D             LDR.N    R0,??gcode_M113_0+0x4
   \       0x20   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8128                SERIAL_ECHOLNPAIR("M113 S", (unsigned long)host_keepalive_interval);
   \       0x24   0x7821             LDRB     R1,[R4, #+0]
   \       0x26   0x480C             LDR.N    R0,??gcode_M113_0+0x8
   \       0x28   0x.... 0x....      BL       _Z17serial_echopair_PPKcm
   \       0x2C   0x480B             LDR.N    R0,??gcode_M113_0+0xC
   \       0x2E   0x79C0             LDRB     R0,[R0, #+7]
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD105             BNE.N    ??gcode_M113_3
   \       0x34   0x210A             MOVS     R1,#+10
   \       0x36   0x480A             LDR.N    R0,??gcode_M113_0+0x10
   \       0x38   0xE8BD 0x4010      POP      {R4,LR}
   \       0x3C   0x.... 0x....      B.W      _ZN12MarlinSerial5writeEh
   \                     ??gcode_M113_3: (+1)
   \       0x40   0x2200             MOVS     R2,#+0
   \       0x42   0x210A             MOVS     R1,#+10
   \       0x44   0x4807             LDR.N    R0,??gcode_M113_0+0x14
   \       0x46   0xE8BD 0x4010      POP      {R4,LR}
   \       0x4A   0x.... 0x....      B.W      _ZN12MarlinSerial5printEci
   8129              }
   8130            }
   \                     ??gcode_M113_2: (+1)
   \       0x4E   0xBD10             POP      {R4,PC}          ;; return
   \                     ??gcode_M113_0:
   \       0x50   0x....'....        DC32     host_keepalive_interval
   \       0x54   0x....'....        DC32     echomagic
   \       0x58   0x....'....        DC32     _ZZ10gcode_M113vEs
   \       0x5C   0x....'....        DC32     mks_heating_busy
   \       0x60   0x....'....        DC32     customizedSerial
   \       0x64   0x....'....        DC32     serial2
   8131          
   8132          #endif
   8133          
   8134          #if ENABLED(BARICUDA)
   8135          
   8136            #if HAS_HEATER_1
   8137              /**
   8138               * M126: Heater 1 valve open
   8139               */
   8140              inline void gcode_M126() { baricuda_valve_pressure = code_seen('S') ? code_value_byte() : 255; }
   8141              /**
   8142               * M127: Heater 1 valve close
   8143               */
   8144              inline void gcode_M127() { baricuda_valve_pressure = 0; }
   8145            #endif
   8146          
   8147            #if HAS_HEATER_2
   8148              /**
   8149               * M128: Heater 2 valve open
   8150               */
   8151              inline void gcode_M128() { baricuda_e_to_p_pressure = code_seen('S') ? code_value_byte() : 255; }
   8152              /**
   8153               * M129: Heater 2 valve close
   8154               */
   8155              inline void gcode_M129() { baricuda_e_to_p_pressure = 0; }
   8156            #endif
   8157          
   8158          #endif //BARICUDA
   8159          
   8160          /**
   8161           * M140: Set bed temperature
   8162           */

   \                                 In section .text, align 4
   8163          inline void gcode_M140() {
   \                     _Z10gcode_M140v: (+1)
   \        0x0   0x4809             LDR.N    R0,??gcode_M140_0
   \        0x2   0x7840             LDRB     R0,[R0, #+1]
   \        0x4   0x0700             LSLS     R0,R0,#+28
   \        0x6   0xD500             BPL.N    ??gcode_M140_1
   \        0x8   0x4770             BX       LR
   \                     ??gcode_M140_1: (+1)
   \        0xA   0xB580             PUSH     {R7,LR}
   8164            if (DEBUGGING(DRYRUN)) return;
   8165            if (code_seen('S')) thermalManager.setTargetBed(code_value_temp_abs());
   \        0xC   0x2053             MOVS     R0,#+83
   \        0xE   0x.... 0x....      BL       _Z9code_seenc
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD007             BEQ.N    ??gcode_M140_2
   \       0x16   0x.... 0x....      BL       _Z19code_value_temp_absv
   \       0x1A   0x.... 0x....      BL       __aeabi_i2f
   \       0x1E   0xE8BD 0x4002      POP      {R1,LR}
   \       0x22   0x.... 0x....      B.W      _ZN11Temperature12setTargetBedEf
   8166          }
   \                     ??gcode_M140_2: (+1)
   \       0x26   0xBD01             POP      {R0,PC}          ;; return
   \                     ??gcode_M140_0:
   \       0x28   0x....'....        DC32     mks_heating_busy
   8167          
   8168          #if ENABLED(ULTIPANEL)
   8169          
   8170            /**
   8171             * M145: Set the heatup state for a material in the LCD menu
   8172             *
   8173             *   S<material> (0=PLA, 1=ABS)
   8174             *   H<hotend temp>
   8175             *   B<bed temp>
   8176             *   F<fan speed>
   8177             */

   \                                 In section .text, align 4
   8178            inline void gcode_M145() {
   \                     _Z10gcode_M145v: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   8179              uint8_t material = code_seen('S') ? (uint8_t)code_value_int() : 0;
   \        0x2   0x2053             MOVS     R0,#+83
   \        0x4   0x.... 0x....      BL       _Z9code_seenc
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD004             BEQ.N    ??gcode_M145_1
   \        0xC   0x.... 0x....      BL       _Z14code_value_intv
   \       0x10   0x4604             MOV      R4,R0
   \       0x12   0xB2E4             UXTB     R4,R4
   \       0x14   0xE000             B.N      ??gcode_M145_2
   \                     ??gcode_M145_1: (+1)
   \       0x16   0x2400             MOVS     R4,#+0
   8180              if (material >= COUNT(lcd_preheat_hotend_temp)) {
   \                     ??gcode_M145_2: (+1)
   \       0x18   0x2C02             CMP      R4,#+2
   \       0x1A   0xD307             BCC.N    ??gcode_M145_3
   8181                SERIAL_ERROR_START;
   \       0x1C   0x4823             LDR.N    R0,??gcode_M145_0
   \       0x1E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8182                SERIAL_ERRORLNPGM(MSG_ERR_MATERIAL_INDEX);
   \       0x22   0x4823             LDR.N    R0,??gcode_M145_0+0x4
   \       0x24   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \       0x28   0x.... 0x....      B.W      _Z14serialprintPGMPKc
   8183              }
   8184              else {
   8185                int v;
   8186                if (code_seen('H')) {
   \                     ??gcode_M145_3: (+1)
   \       0x2C   0x2048             MOVS     R0,#+72
   \       0x2E   0x.... 0x....      BL       _Z9code_seenc
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD018             BEQ.N    ??gcode_M145_4
   8187                  v = code_value_int();
   \       0x36   0x.... 0x....      BL       _Z14code_value_intv
   \       0x3A   0x4605             MOV      R5,R0
   8188                  lcd_preheat_hotend_temp[material] = constrain(v, EXTRUDE_MINTEMP, HEATER_0_MAXTEMP - 15);
                                                           ^
Warning[Pa093]: implicit conversion from floating point to integer
   \       0x3C   0x4E1D             LDR.N    R6,??gcode_M145_0+0x8
   \       0x3E   0x6AF7             LDR      R7,[R6, #+44]
   \       0x40   0x.... 0x....      BL       __aeabi_i2f
   \       0x44   0x4639             MOV      R1,R7
   \       0x46   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x4A   0xD203             BCS.N    ??gcode_M145_5
   \       0x4C   0x4638             MOV      R0,R7
   \       0x4E   0x.... 0x....      BL       __aeabi_f2iz
   \       0x52   0xE006             B.N      ??gcode_M145_6
   \                     ??gcode_M145_5: (+1)
   \       0x54   0x4630             MOV      R0,R6
   \       0x56   0xF9B0 0x0030      LDRSH    R0,[R0, #+48]
   \       0x5A   0x380F             SUBS     R0,R0,#+15
   \       0x5C   0x42A8             CMP      R0,R5
   \       0x5E   0xDD00             BLE.N    ??gcode_M145_6
   \       0x60   0x4628             MOV      R0,R5
   \                     ??gcode_M145_6: (+1)
   \       0x62   0x4915             LDR.N    R1,??gcode_M145_0+0xC
   \       0x64   0xF841 0x0024      STR      R0,[R1, R4, LSL #+2]
   8189                }
   8190                if (code_seen('F')) {
   \                     ??gcode_M145_4: (+1)
   \       0x68   0x2046             MOVS     R0,#+70
   \       0x6A   0x.... 0x....      BL       _Z9code_seenc
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD006             BEQ.N    ??gcode_M145_7
   8191                  v = code_value_int();
   \       0x72   0x.... 0x....      BL       _Z14code_value_intv
   8192                  lcd_preheat_fan_speed[material] = constrain(v, 0, 255);
   \       0x76   0xF380 0x0008      USAT     R0,#+8,R0
   \       0x7A   0x4910             LDR.N    R1,??gcode_M145_0+0x10
   \       0x7C   0xF841 0x0024      STR      R0,[R1, R4, LSL #+2]
   8193                }
   8194                #if TEMP_SENSOR_BED != 0
   8195                  if (code_seen('B')) {
   \                     ??gcode_M145_7: (+1)
   \       0x80   0x2042             MOVS     R0,#+66
   \       0x82   0x.... 0x....      BL       _Z9code_seenc
   \       0x86   0x2800             CMP      R0,#+0
   \       0x88   0xD00F             BEQ.N    ??gcode_M145_8
   8196                    v = code_value_int();
   \       0x8A   0x.... 0x....      BL       _Z14code_value_intv
   8197                    lcd_preheat_bed_temp[material] = constrain(v, BED_MINTEMP, BED_MAXTEMP - 15);
   \       0x8E   0xF06F 0x0104      MVN      R1,#+4
   \       0x92   0x4288             CMP      R0,R1
   \       0x94   0xDB06             BLT.N    ??gcode_M145_9
   \       0x96   0x4907             LDR.N    R1,??gcode_M145_0+0x8
   \       0x98   0xF9B1 0x1032      LDRSH    R1,[R1, #+50]
   \       0x9C   0x390F             SUBS     R1,R1,#+15
   \       0x9E   0x4281             CMP      R1,R0
   \       0xA0   0xDD00             BLE.N    ??gcode_M145_9
   \       0xA2   0x4601             MOV      R1,R0
   \                     ??gcode_M145_9: (+1)
   \       0xA4   0x4806             LDR.N    R0,??gcode_M145_0+0x14
   \       0xA6   0xF840 0x1024      STR      R1,[R0, R4, LSL #+2]
   8198                  }
   8199                #endif
   8200              }
   8201            }
   \                     ??gcode_M145_8: (+1)
   \       0xAA   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   \                     ??gcode_M145_0:
   \       0xAC   0x....'....        DC32     errormagic
   \       0xB0   0x....'....        DC32     _ZZ10gcode_M145vEs
   \       0xB4   0x....'....        DC32     mksCfg
   \       0xB8   0x....'....        DC32     lcd_preheat_hotend_temp
   \       0xBC   0x....'....        DC32     lcd_preheat_fan_speed
   \       0xC0   0x....'....        DC32     lcd_preheat_bed_temp
   8202          
   8203          #endif // ULTIPANEL
   8204          
   8205          #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
   8206            /**
   8207             * M149: Set temperature units
   8208             */
   8209            inline void gcode_M149() {
   8210                   if (code_seen('C')) set_input_temp_units(TEMPUNIT_C);
   8211              else if (code_seen('K')) set_input_temp_units(TEMPUNIT_K);
   8212              else if (code_seen('F')) set_input_temp_units(TEMPUNIT_F);
   8213            }
   8214          #endif
   8215          
   8216          #if HAS_POWER_SWITCH
   8217          
   8218            /**
   8219             * M80: Turn on Power Supply
   8220             */
   8221            inline void gcode_M80() {
   8222              OUT_WRITE(PS_ON_PIN, PS_ON_AWAKE); //GND
   8223          
   8224              /**
   8225               * If you have a switch on suicide pin, this is useful
   8226               * if you want to start another print with suicide feature after
   8227               * a print without suicide...
   8228               */
   8229              #if HAS_SUICIDE
   8230                OUT_WRITE(SUICIDE_PIN, HIGH);
   8231              #endif
   8232          
   8233              #if ENABLED(HAVE_TMC2130)
   8234                delay(100);
   8235                tmc2130_init(); // Settings only stick when the driver has power
   8236              #endif
   8237          
   8238              #if ENABLED(ULTIPANEL)
   8239                powersupply = true;
   8240                LCD_MESSAGEPGM(WELCOME_MSG);
   8241              #endif
   8242            }
   8243          
   8244          #endif // HAS_POWER_SWITCH
   8245          
   8246          /**
   8247           * M81: Turn off Power, including Power Supply, if there is one.
   8248           *
   8249           *      This code should ALWAYS be available for EMERGENCY SHUTDOWN!
   8250           */

   \                                 In section .text, align 4
   8251          inline void gcode_M81() {
   \                     _Z9gcode_M81v: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   8252            thermalManager.disable_all_heaters();
   \        0x2   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
   8253            stepper.finish_and_disable();
   \        0x6   0x.... 0x....      BL       _ZN7Stepper18finish_and_disableEv
   8254            #if FAN_COUNT > 0
   8255            for (uint8_t i = 0; i < FAN_COUNT; i++) fanSpeeds[i] = 0;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x490D             LDR.N    R1,??gcode_M81_0
   \        0xE   0xE002             B.N      ??gcode_M81_1
   \                     ??gcode_M81_2: (+1)
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x6008             STR      R0,[R1, #+0]
   \       0x14   0x2001             MOVS     R0,#+1
   \                     ??gcode_M81_1: (+1)
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD0FA             BEQ.N    ??gcode_M81_2
   8256          	#if ENABLED(PROBING_FANS_OFF)
   8257          	fans_paused = false;
   8258          	ZERO(paused_fanSpeeds);
   8259            #endif
   8260          #endif  
   8261            safe_delay(1000); // Wait 1 second before switching off
   \       0x1A   0xF44F 0x707A      MOV      R0,#+1000
   \       0x1E   0x.... 0x....      BL       _Z10safe_delaym
   8262            #if HAS_SUICIDE
   8263              stepper.synchronize();
   8264              suicide();
   8265            #elif HAS_POWER_SWITCH
   8266              OUT_WRITE(PS_ON_PIN, PS_ON_ASLEEP);
   8267            #endif
   8268            #if ENABLED(ULTIPANEL)
   8269              #if HAS_POWER_SWITCH
   8270                powersupply = false;
   8271              #endif
   8272                /*--mks cfg-- LCD_LANGUAGE*/
   8273              //LCD_MESSAGEPGM(MACHINE_NAME " " MSG_OFF ".");
   8274                if(LCD_LANGUAGE)
   \       0x22   0x4809             LDR.N    R0,??gcode_M81_0+0x4
   \       0x24   0xF890 0x003E      LDRB     R0,[R0, #+62]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD005             BEQ.N    ??gcode_M81_3
   8275                  LCD_MESSAGEPGM(MACHINE_NAME " " "\xb5 " ".");
   \       0x2C   0x2100             MOVS     R1,#+0
   \       0x2E   0x4807             LDR.N    R0,??gcode_M81_0+0x8
   \       0x30   0xE8BD 0x4004      POP      {R2,LR}
   \       0x34   0x.... 0x....      B.W      _Z16lcd_setstatuspgmPKch
   8276                else
   8277                  LCD_MESSAGEPGM(MACHINE_NAME " " "Off" ".");
   \                     ??gcode_M81_3: (+1)
   \       0x38   0x2100             MOVS     R1,#+0
   \       0x3A   0x4805             LDR.N    R0,??gcode_M81_0+0xC
   \       0x3C   0xE8BD 0x4004      POP      {R2,LR}
   \       0x40   0x.... 0x....      B.W      _Z16lcd_setstatuspgmPKch
   \                     ??gcode_M81_0:
   \       0x44   0x....'....        DC32     fanSpeeds
   \       0x48   0x....'....        DC32     mksCfg
   \       0x4C   0x....'....        DC32     _ZZ9gcode_M81vEs
   \       0x50   0x....'....        DC32     _ZZ9gcode_M81vEs_0
   8278                
   8279            #endif
   8280          }
   8281          
   8282          /**
   8283           * M82: Set E codes absolute (default)
   8284           */

   \                                 In section .text, align 4
   8285          inline void gcode_M82() { axis_relative_modes[E_AXIS] = false; }
   \                     _Z9gcode_M82v: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x4901             LDR.N    R1,??gcode_M82_0
   \        0x4   0x70C8             STRB     R0,[R1, #+3]
   \        0x6   0x4770             BX       LR               ;; return
   \                     ??gcode_M82_0:
   \        0x8   0x....'....        DC32     axis_relative_modes
   8286          
   8287          /**
   8288           * M83: Set E codes relative while in Absolute Coordinates (G90) mode
   8289           */

   \                                 In section .text, align 4
   8290          inline void gcode_M83() { axis_relative_modes[E_AXIS] = true; }
   \                     _Z9gcode_M83v: (+1)
   \        0x0   0x2001             MOVS     R0,#+1
   \        0x2   0x4901             LDR.N    R1,??gcode_M83_0
   \        0x4   0x70C8             STRB     R0,[R1, #+3]
   \        0x6   0x4770             BX       LR               ;; return
   \                     ??gcode_M83_0:
   \        0x8   0x....'....        DC32     axis_relative_modes
   8291          
   8292          /**
   8293           * M18, M84: Disable all stepper motors
   8294           */

   \                                 In section .text, align 4
   8295          inline void gcode_M18_M84() {
   \                     _Z13gcode_M18_M84v: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   8296            if (code_seen('S')) {
   \        0x2   0x2053             MOVS     R0,#+83
   \        0x4   0x.... 0x....      BL       _Z9code_seenc
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD004             BEQ.N    ??gcode_M18_M84_1
   8297              stepper_inactive_time = code_value_millis_from_seconds();
   \        0xC   0x.... 0x....      BL       _Z30code_value_millis_from_secondsv
   \       0x10   0x492C             LDR.N    R1,??gcode_M18_M84_0
   \       0x12   0x6408             STR      R0,[R1, #+64]
   \       0x14   0xBD01             POP      {R0,PC}
   8298            }
   8299            else {
   8300              bool all_axis = !((code_seen('X')) || (code_seen('Y')) || (code_seen('Z')) || (code_seen('E')));
   \                     ??gcode_M18_M84_1: (+1)
   \       0x16   0x2058             MOVS     R0,#+88
   \       0x18   0x.... 0x....      BL       _Z9code_seenc
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD110             BNE.N    ??gcode_M18_M84_2
   \       0x20   0x2059             MOVS     R0,#+89
   \       0x22   0x.... 0x....      BL       _Z9code_seenc
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD10B             BNE.N    ??gcode_M18_M84_2
   \       0x2A   0x205A             MOVS     R0,#+90
   \       0x2C   0x.... 0x....      BL       _Z9code_seenc
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD106             BNE.N    ??gcode_M18_M84_2
   \       0x34   0x2045             MOVS     R0,#+69
   \       0x36   0x.... 0x....      BL       _Z9code_seenc
   \       0x3A   0x1E40             SUBS     R0,R0,#+1
   \       0x3C   0x4180             SBCS     R0,R0,R0
   \       0x3E   0x0FC0             LSRS     R0,R0,#+31
   \       0x40   0xE000             B.N      ??gcode_M18_M84_3
   \                     ??gcode_M18_M84_2: (+1)
   \       0x42   0x2000             MOVS     R0,#+0
   8301              if (all_axis) {
   \                     ??gcode_M18_M84_3: (+1)
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD003             BEQ.N    ??gcode_M18_M84_4
   8302                stepper.finish_and_disable();
   \       0x48   0xE8BD 0x4001      POP      {R0,LR}
   \       0x4C   0x.... 0x....      B.W      _ZN7Stepper18finish_and_disableEv
   8303              }
   8304              else {
   8305                stepper.synchronize();
   \                     ??gcode_M18_M84_4: (+1)
   \       0x50   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   8306                if (code_seen('X')) disable_X();
   \       0x54   0x2058             MOVS     R0,#+88
   \       0x56   0x.... 0x....      BL       _Z9code_seenc
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD009             BEQ.N    ??gcode_M18_M84_5
   \       0x5E   0x2201             MOVS     R2,#+1
   \       0x60   0x4819             LDR.N    R0,??gcode_M18_M84_0+0x4
   \       0x62   0x8B81             LDRH     R1,[R0, #+28]
   \       0x64   0x4819             LDR.N    R0,??gcode_M18_M84_0+0x8
   \       0x66   0x6B80             LDR      R0,[R0, #+56]
   \       0x68   0x.... 0x....      BL       HAL_GPIO_WritePin
   \       0x6C   0x2000             MOVS     R0,#+0
   \       0x6E   0x4915             LDR.N    R1,??gcode_M18_M84_0
   \       0x70   0x7108             STRB     R0,[R1, #+4]
   8307                if (code_seen('Y')) disable_Y();
   \                     ??gcode_M18_M84_5: (+1)
   \       0x72   0x2059             MOVS     R0,#+89
   \       0x74   0x.... 0x....      BL       _Z9code_seenc
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD009             BEQ.N    ??gcode_M18_M84_6
   \       0x7C   0x2201             MOVS     R2,#+1
   \       0x7E   0x4812             LDR.N    R0,??gcode_M18_M84_0+0x4
   \       0x80   0x8B81             LDRH     R1,[R0, #+28]
   \       0x82   0x4812             LDR.N    R0,??gcode_M18_M84_0+0x8
   \       0x84   0x6B80             LDR      R0,[R0, #+56]
   \       0x86   0x.... 0x....      BL       HAL_GPIO_WritePin
   \       0x8A   0x2000             MOVS     R0,#+0
   \       0x8C   0x490D             LDR.N    R1,??gcode_M18_M84_0
   \       0x8E   0x7148             STRB     R0,[R1, #+5]
   8308                if (code_seen('Z')) disable_Z();
   \                     ??gcode_M18_M84_6: (+1)
   \       0x90   0x205A             MOVS     R0,#+90
   \       0x92   0x.... 0x....      BL       _Z9code_seenc
   \       0x96   0x2800             CMP      R0,#+0
   \       0x98   0xD009             BEQ.N    ??gcode_M18_M84_7
   \       0x9A   0x2201             MOVS     R2,#+1
   \       0x9C   0x480A             LDR.N    R0,??gcode_M18_M84_0+0x4
   \       0x9E   0x8B81             LDRH     R1,[R0, #+28]
   \       0xA0   0x480A             LDR.N    R0,??gcode_M18_M84_0+0x8
   \       0xA2   0x6B80             LDR      R0,[R0, #+56]
   \       0xA4   0x.... 0x....      BL       HAL_GPIO_WritePin
   \       0xA8   0x2000             MOVS     R0,#+0
   \       0xAA   0x4906             LDR.N    R1,??gcode_M18_M84_0
   \       0xAC   0x7188             STRB     R0,[R1, #+6]
   8309                #if ((E0_ENABLE_PIN != X_ENABLE_PIN) && (E1_ENABLE_PIN != Y_ENABLE_PIN)) // Only enable on boards that have seperate ENABLE_PINS
   8310                  if (code_seen('E')) disable_e_steppers();
   \                     ??gcode_M18_M84_7: (+1)
   \       0xAE   0x2045             MOVS     R0,#+69
   \       0xB0   0x.... 0x....      BL       _Z9code_seenc
   \       0xB4   0x2800             CMP      R0,#+0
   \       0xB6   0xD003             BEQ.N    ??gcode_M18_M84_8
   \       0xB8   0xE8BD 0x4001      POP      {R0,LR}
   \       0xBC   0x.... 0x....      B.W      _Z18disable_e_steppersv
   8311                #endif
   8312              }
   8313            }
   8314          }
   \                     ??gcode_M18_M84_8: (+1)
   \       0xC0   0xBD01             POP      {R0,PC}          ;; return
   \       0xC2   0xBF00             Nop      
   \                     ??gcode_M18_M84_0:
   \       0xC4   0x....'....        DC32     axis_relative_modes
   \       0xC8   0x....'....        DC32     gArrayGpioPin
   \       0xCC   0x....'....        DC32     gArrayGpioPort
   8315          
   8316          /**
   8317           * M85: Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
   8318           */

   \                                 In section .text, align 4
   8319          inline void gcode_M85() {
   \                     _Z9gcode_M85v: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   8320            if (code_seen('S')) max_inactive_time = code_value_millis_from_seconds();
   \        0x2   0x2053             MOVS     R0,#+83
   \        0x4   0x.... 0x....      BL       _Z9code_seenc
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD003             BEQ.N    ??gcode_M85_1
   \        0xC   0x.... 0x....      BL       _Z30code_value_millis_from_secondsv
   \       0x10   0x4901             LDR.N    R1,??gcode_M85_0
   \       0x12   0x63C8             STR      R0,[R1, #+60]
   8321          }
   \                     ??gcode_M85_1: (+1)
   \       0x14   0xBD01             POP      {R0,PC}          ;; return
   \       0x16   0xBF00             Nop      
   \                     ??gcode_M85_0:
   \       0x18   0x....'....        DC32     axis_relative_modes
   8322          
   8323          /**
   8324           * Multi-stepper support for M92, M201, M203
   8325           */
   8326          #if ENABLED(DISTINCT_E_FACTORS)
   8327            #define GET_TARGET_EXTRUDER(CMD) if (get_target_extruder_from_command(CMD)) return
   8328            #define TARGET_EXTRUDER target_extruder
   8329          #else
   8330            #define GET_TARGET_EXTRUDER(CMD) NOOP
   8331            #define TARGET_EXTRUDER 0
   8332          #endif
   8333          
   8334          /**
   8335           * M92: Set axis steps-per-unit for one or more axes, X, Y, Z, and E.
   8336           *      (Follows the same syntax as G92)
   8337           *
   8338           *      With multiple extruders use T to specify which one.
   8339           */

   \                                 In section .text, align 4
   8340          inline void gcode_M92() {
   \                     _Z9gcode_M92v: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   8341          
   8342            GET_TARGET_EXTRUDER(92);
   8343          
   8344            LOOP_XYZE(i) {
   \        0x4   0x2400             MOVS     R4,#+0
   \        0x6   0x4D21             LDR.N    R5,??gcode_M92_0
   \                     ??gcode_M92_1: (+1)
   \        0x8   0x2C03             CMP      R4,#+3
   \        0xA   0xDC3A             BGT.N    ??gcode_M92_2
   8345              if (code_seen(axis_codes[i])) {
   \        0xC   0x4820             LDR.N    R0,??gcode_M92_0+0x4
   \        0xE   0x5700             LDRSB    R0,[R0, R4]
   \       0x10   0x.... 0x....      BL       _Z9code_seenc
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD032             BEQ.N    ??gcode_M92_3
   8346                if (i == E_AXIS) {
   \       0x18   0x2C03             CMP      R4,#+3
   \       0x1A   0xD004             BEQ.N    ??gcode_M92_4
   8347                  const float value = code_value_per_axis_unit((AxisEnum)(E_AXIS + TARGET_EXTRUDER));
   8348                  if (value < 20.0) {
   8349                    float factor = planner.axis_steps_per_mm[E_AXIS + TARGET_EXTRUDER] / value; // increase e constants if M92 E14 is given for netfab.
   8350                    planner.max_jerk[E_AXIS] *= factor;
   8351                    planner.max_feedrate_mm_s[E_AXIS + TARGET_EXTRUDER] *= factor;
   8352                    planner.max_acceleration_steps_per_s2[E_AXIS + TARGET_EXTRUDER] *= factor;
   8353                  }
   8354                  planner.axis_steps_per_mm[E_AXIS + TARGET_EXTRUDER] = value;
   8355                }
   8356                else {
   8357                  planner.axis_steps_per_mm[i] = code_value_per_axis_unit((AxisEnum)i);
   \       0x1C   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x20   0xF845 0x0024      STR      R0,[R5, R4, LSL #+2]
   \       0x24   0xE02B             B.N      ??gcode_M92_3
   8358                }
   \                     ??gcode_M92_4: (+1)
   \       0x26   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x2A   0x4606             MOV      R6,R0
   \       0x2C   0x4919             LDR.N    R1,??gcode_M92_0+0x8  ;; 0x41a00000
   \       0x2E   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x32   0xD223             BCS.N    ??gcode_M92_5
   \       0x34   0x68E8             LDR      R0,[R5, #+12]
   \       0x36   0x4631             MOV      R1,R6
   \       0x38   0x.... 0x....      BL       __aeabi_fdiv
   \       0x3C   0x4607             MOV      R7,R0
   \       0x3E   0xF8DF 0x8058      LDR.W    R8,??gcode_M92_0+0xC
   \       0x42   0xF8D8 0x000C      LDR      R0,[R8, #+12]
   \       0x46   0x4639             MOV      R1,R7
   \       0x48   0x.... 0x....      BL       __aeabi_fmul
   \       0x4C   0xF8C8 0x000C      STR      R0,[R8, #+12]
   \       0x50   0xF8DF 0x8048      LDR.W    R8,??gcode_M92_0+0x10
   \       0x54   0xF8D8 0x000C      LDR      R0,[R8, #+12]
   \       0x58   0x4639             MOV      R1,R7
   \       0x5A   0x.... 0x....      BL       __aeabi_fmul
   \       0x5E   0xF8C8 0x000C      STR      R0,[R8, #+12]
   \       0x62   0xF8DF 0x803C      LDR.W    R8,??gcode_M92_0+0x14
   \       0x66   0xF8D8 0x000C      LDR      R0,[R8, #+12]
   \       0x6A   0x.... 0x....      BL       __aeabi_ui2f
   \       0x6E   0x4639             MOV      R1,R7
   \       0x70   0x.... 0x....      BL       __aeabi_fmul
   \       0x74   0x.... 0x....      BL       __aeabi_f2uiz
   \       0x78   0xF8C8 0x000C      STR      R0,[R8, #+12]
   \                     ??gcode_M92_5: (+1)
   \       0x7C   0x60EE             STR      R6,[R5, #+12]
   8359              }
   8360            }
   \                     ??gcode_M92_3: (+1)
   \       0x7E   0x1C64             ADDS     R4,R4,#+1
   \       0x80   0xE7C2             B.N      ??gcode_M92_1
   8361            planner.refresh_positioning();
   \                     ??gcode_M92_2: (+1)
   \       0x82   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \       0x86   0x.... 0x....      B.W      _ZN7Planner19refresh_positioningEv
   \       0x8A   0xBF00             Nop      
   \                     ??gcode_M92_0:
   \       0x8C   0x....'....        DC32     _ZN7Planner17axis_steps_per_mmE
   \       0x90   0x....'....        DC32     axis_codes
   \       0x94   0x41A0'0000        DC32     0x41a00000
   \       0x98   0x....'....        DC32     _ZN7Planner8max_jerkE
   \       0x9C   0x....'....        DC32     _ZN7Planner17max_feedrate_mm_sE
   \       0xA0   0x....'....        DC32     _ZN7Planner29max_acceleration_steps_per_s2E
   8362          }
   8363          
   8364          /**
   8365           * Output the current position to serial
   8366           */

   \                                 In section .text, align 2, keep-with-next
   8367          static void report_current_position() {
   \                     _ZN37_INTERNAL_15_Marlin_main_cpp_3178531923report_current_positionEv: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   8368            SERIAL_PROTOCOLPGM("X:");
   \        0x2   0x....             ADR.N    R0,??DataTable135  ;; 0x58, 0x3A, 0x00, 0x00
   \        0x4   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8369            SERIAL_PROTOCOL(current_position[X_AXIS]);
   \        0x8   0x....             LDR.N    R4,??DataTable136_2
   \        0xA   0x68A0             LDR      R0,[R4, #+8]
   \        0xC   0x.... 0x....      BL       __aeabi_f2d
   \       0x10   0x4602             MOV      R2,R0
   \       0x12   0x460B             MOV      R3,R1
   \       0x14   0x....             LDR.N    R5,??DataTable136_6
   \       0x16   0x....             LDR.N    R6,??DataTable136_17
   \       0x18   0x79E0             LDRB     R0,[R4, #+7]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD105             BNE.N    ??report_current_position_0
   \       0x1E   0x2002             MOVS     R0,#+2
   \       0x20   0x9000             STR      R0,[SP, #+0]
   \       0x22   0x4630             MOV      R0,R6
   \       0x24   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   \       0x28   0xE004             B.N      ??report_current_position_1
   \                     ??report_current_position_0: (+1)
   \       0x2A   0x2002             MOVS     R0,#+2
   \       0x2C   0x9000             STR      R0,[SP, #+0]
   \       0x2E   0x4628             MOV      R0,R5
   \       0x30   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   8370            SERIAL_PROTOCOLPGM(" Y:");
   \                     ??report_current_position_1: (+1)
   \       0x34   0x....             ADR.N    R0,??DataTable135_1  ;; " Y:"
   \       0x36   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8371            SERIAL_PROTOCOL(current_position[Y_AXIS]);
   \       0x3A   0x68E0             LDR      R0,[R4, #+12]
   \       0x3C   0x.... 0x....      BL       __aeabi_f2d
   \       0x40   0x4602             MOV      R2,R0
   \       0x42   0x460B             MOV      R3,R1
   \       0x44   0x79E0             LDRB     R0,[R4, #+7]
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD105             BNE.N    ??report_current_position_2
   \       0x4A   0x2002             MOVS     R0,#+2
   \       0x4C   0x9000             STR      R0,[SP, #+0]
   \       0x4E   0x4630             MOV      R0,R6
   \       0x50   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   \       0x54   0xE004             B.N      ??report_current_position_3
   \                     ??report_current_position_2: (+1)
   \       0x56   0x2002             MOVS     R0,#+2
   \       0x58   0x9000             STR      R0,[SP, #+0]
   \       0x5A   0x4628             MOV      R0,R5
   \       0x5C   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   8372            SERIAL_PROTOCOLPGM(" Z:");
   \                     ??report_current_position_3: (+1)
   \       0x60   0x....             ADR.N    R0,??DataTable136  ;; " Z:"
   \       0x62   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8373            SERIAL_PROTOCOL(current_position[Z_AXIS]);
   \       0x66   0x6920             LDR      R0,[R4, #+16]
   \       0x68   0x.... 0x....      BL       __aeabi_f2d
   \       0x6C   0x4602             MOV      R2,R0
   \       0x6E   0x460B             MOV      R3,R1
   \       0x70   0x79E0             LDRB     R0,[R4, #+7]
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD105             BNE.N    ??report_current_position_4
   \       0x76   0x2002             MOVS     R0,#+2
   \       0x78   0x9000             STR      R0,[SP, #+0]
   \       0x7A   0x4630             MOV      R0,R6
   \       0x7C   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   \       0x80   0xE004             B.N      ??report_current_position_5
   \                     ??report_current_position_4: (+1)
   \       0x82   0x2002             MOVS     R0,#+2
   \       0x84   0x9000             STR      R0,[SP, #+0]
   \       0x86   0x4628             MOV      R0,R5
   \       0x88   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   8374            SERIAL_PROTOCOLPGM(" E:");
   \                     ??report_current_position_5: (+1)
   \       0x8C   0x....             ADR.N    R0,??DataTable136_1  ;; " E:"
   \       0x8E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8375            SERIAL_PROTOCOL(current_position[E_AXIS]);
   \       0x92   0x6960             LDR      R0,[R4, #+20]
   \       0x94   0x.... 0x....      BL       __aeabi_f2d
   \       0x98   0x79E2             LDRB     R2,[R4, #+7]
   \       0x9A   0x2A00             CMP      R2,#+0
   \       0x9C   0xD107             BNE.N    ??report_current_position_6
   \       0x9E   0x2202             MOVS     R2,#+2
   \       0xA0   0x9200             STR      R2,[SP, #+0]
   \       0xA2   0x4602             MOV      R2,R0
   \       0xA4   0x460B             MOV      R3,R1
   \       0xA6   0x4630             MOV      R0,R6
   \       0xA8   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   \       0xAC   0xE006             B.N      ??report_current_position_7
   \                     ??report_current_position_6: (+1)
   \       0xAE   0x2202             MOVS     R2,#+2
   \       0xB0   0x9200             STR      R2,[SP, #+0]
   \       0xB2   0x4602             MOV      R2,R0
   \       0xB4   0x460B             MOV      R3,R1
   \       0xB6   0x4628             MOV      R0,R5
   \       0xB8   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   8376          
   8377            stepper.report_positions();
   \                     ??report_current_position_7: (+1)
   \       0xBC   0x.... 0x....      BL       _ZN7Stepper16report_positionsEv
   8378          
   8379          //  #if IS_SCARA
   8380          if(MACHINETPYE&IS_SCARA)  {
   \       0xC0   0x....             LDR.N    R0,??DataTable136_8
   \       0xC2   0xF8B0 0x0058      LDRH     R0,[R0, #+88]
   \       0xC6   0xF410 0x7F40      TST      R0,#0x300
   \       0xCA   0xD02D             BEQ.N    ??report_current_position_8
   8381              SERIAL_PROTOCOLPAIR("SCARA Theta:", stepper.get_axis_position_degrees(A_AXIS));
   \       0xCC   0x2000             MOVS     R0,#+0
   \       0xCE   0x.... 0x....      BL       _ZN7Stepper25get_axis_position_degreesE8AxisEnum
   \       0xD2   0x4601             MOV      R1,R0
   \       0xD4   0x.... 0x....      ADR.W    R0,?_33
   \       0xD8   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   8382              SERIAL_PROTOCOLLNPAIR("   Psi+Theta:", stepper.get_axis_position_degrees(B_AXIS));
   \       0xDC   0x2001             MOVS     R0,#+1
   \       0xDE   0x.... 0x....      BL       _ZN7Stepper25get_axis_position_degreesE8AxisEnum
   \       0xE2   0x4601             MOV      R1,R0
   \       0xE4   0x.... 0x....      ADR.W    R0,?_34
   \       0xE8   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \       0xEC   0x79E0             LDRB     R0,[R4, #+7]
   \       0xEE   0x2800             CMP      R0,#+0
   \       0xF0   0xD104             BNE.N    ??report_current_position_9
   \       0xF2   0x210A             MOVS     R1,#+10
   \       0xF4   0x4630             MOV      R0,R6
   \       0xF6   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \       0xFA   0xE004             B.N      ??report_current_position_10
   \                     ??report_current_position_9: (+1)
   \       0xFC   0x2200             MOVS     R2,#+0
   \       0xFE   0x210A             MOVS     R1,#+10
   \      0x100   0x4628             MOV      R0,R5
   \      0x102   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   8383              SERIAL_EOL; }
   \                     ??report_current_position_10: (+1)
   \      0x106   0x79E0             LDRB     R0,[R4, #+7]
   \      0x108   0x2800             CMP      R0,#+0
   \      0x10A   0xD105             BNE.N    ??report_current_position_11
   \      0x10C   0x210A             MOVS     R1,#+10
   \      0x10E   0x4630             MOV      R0,R6
   \      0x110   0xE8BD 0x407C      POP      {R2-R6,LR}
   \      0x114   0x.... 0x....      B.W      _ZN12MarlinSerial5writeEh
   \                     ??report_current_position_11: (+1)
   \      0x118   0x2200             MOVS     R2,#+0
   \      0x11A   0x210A             MOVS     R1,#+10
   \      0x11C   0x4628             MOV      R0,R5
   \      0x11E   0xB002             ADD      SP,SP,#+8
   \      0x120   0xE8BD 0x4070      POP      {R4-R6,LR}
   \      0x124   0x.... 0x....      B.W      _ZN12MarlinSerial5printEci
   8384           // #endif
   8385          }
   \                     ??report_current_position_8: (+1)
   \      0x128   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
   8386          
   8387          /**
   8388           * M114: Output current position to serial port
   8389           */

   \                                 In section .text, align 2
   8390          inline void gcode_M114() { stepper.synchronize(); report_current_position(); }
   \                     _Z10gcode_M114v: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   \        0x6   0xE8BD 0x4001      POP      {R0,LR}
   \        0xA   0x.... 0x....      B.W      _ZN37_INTERNAL_15_Marlin_main_cpp_3178531923report_current_positionEv
   8391          
   8392          /**
   8393           * M115: Capabilities string
   8394           */

   \                                 In section .text, align 4
   8395          inline void gcode_M115() {
   8396            SERIAL_PROTOCOLLNPGM(MSG_M115_REPORT);
   \                     _Z10gcode_M115v: (+1)
   \        0x0   0x4801             LDR.N    R0,??gcode_M115_0
   \        0x2   0x.... 0x....      B.W      _Z14serialprintPGMPKc
   \        0x6   0xBF00             Nop      
   \                     ??gcode_M115_0:
   \        0x8   0x....'....        DC32     _ZZ10gcode_M115vEs
   8397          
   8398            #if ENABLED(EXTENDED_CAPABILITIES_REPORT)
   8399          
   8400              // EEPROM (M500, M501)
   8401              #if ENABLED(EEPROM_SETTINGS)
   8402                SERIAL_PROTOCOLLNPGM("Cap:EEPROM:1");
   8403              #else
   8404                SERIAL_PROTOCOLLNPGM("Cap:EEPROM:0");
   8405              #endif
   8406          
   8407              // AUTOREPORT_TEMP (M155)
   8408              #if ENABLED(AUTO_REPORT_TEMPERATURES)
   8409                SERIAL_PROTOCOLLNPGM("Cap:AUTOREPORT_TEMP:1");
   8410              #else
   8411                SERIAL_PROTOCOLLNPGM("Cap:AUTOREPORT_TEMP:0");
   8412              #endif
   8413          
   8414              // PROGRESS (M530 S L, M531 <file>, M532 X L)
   8415              SERIAL_PROTOCOLLNPGM("Cap:PROGRESS:0");
   8416          
   8417              // AUTOLEVEL (G29)
   8418              //#if HAS_ABL
   8419          	if(BED_LEVELING_METHOD&HAS_ABL)
   8420                SERIAL_PROTOCOLLNPGM("Cap:AUTOLEVEL:1");
   8421              //#else
   8422              else
   8423                SERIAL_PROTOCOLLNPGM("Cap:AUTOLEVEL:0");
   8424              //#endif
   8425          
   8426              // Z_PROBE (G30)
   8427              #if HAS_BED_PROBE
   8428                SERIAL_PROTOCOLLNPGM("Cap:Z_PROBE:1");
   8429              #else
   8430                SERIAL_PROTOCOLLNPGM("Cap:Z_PROBE:0");
   8431              #endif
   8432          
   8433              // MESH_REPORT (M420 V)
   8434              //#if HAS_LEVELING
   8435          	if(BED_LEVELING_METHOD&HAS_LEVELING)
   8436                SERIAL_PROTOCOLLNPGM("Cap:LEVELING_DATA:1");
   8437          	else
   8438              //#else
   8439                SERIAL_PROTOCOLLNPGM("Cap:LEVELING_DATA:0");
   8440              //#endif
   8441          
   8442              // SOFTWARE_POWER (G30)
   8443              #if HAS_POWER_SWITCH
   8444                SERIAL_PROTOCOLLNPGM("Cap:SOFTWARE_POWER:1");
   8445              #else
   8446                SERIAL_PROTOCOLLNPGM("Cap:SOFTWARE_POWER:0");
   8447              #endif
   8448          
   8449              // TOGGLE_LIGHTS (M355)
   8450              #if HAS_CASE_LIGHT
   8451                SERIAL_PROTOCOLLNPGM("Cap:TOGGLE_LIGHTS:1");
   8452              #else
   8453                SERIAL_PROTOCOLLNPGM("Cap:TOGGLE_LIGHTS:0");
   8454              #endif
   8455          
   8456              // EMERGENCY_PARSER (M108, M112, M410)
   8457              #if ENABLED(EMERGENCY_PARSER)
   8458                SERIAL_PROTOCOLLNPGM("Cap:EMERGENCY_PARSER:1");
   8459              #else
   8460                SERIAL_PROTOCOLLNPGM("Cap:EMERGENCY_PARSER:0");
   8461              #endif
   8462          
   8463            #endif // EXTENDED_CAPABILITIES_REPORT
   8464          }
   8465          
   8466          /**
   8467           * M117: Set LCD Status Message
   8468           */

   \                                 In section .text, align 4
   8469          inline void gcode_M117() {
   8470            if(IS_SD_PRINTING){
   \                     _Z10gcode_M117v: (+1)
   \        0x0   0x4806             LDR.N    R0,??gcode_M117_0
   \        0x2   0x7880             LDRB     R0,[R0, #+2]
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD003             BEQ.N    ??gcode_M117_1
   8471               lcd_setstatus(MSG_MKSPRINTINTING);
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x4805             LDR.N    R0,??gcode_M117_0+0x4
   \        0xC   0x.... 0x....      B.W      _Z13lcd_setstatusPKcb
   8472            	}
   8473            else{
   8474               lcd_setstatus(current_command_args);
   \                     ??gcode_M117_1: (+1)
   \       0x10   0x2100             MOVS     R1,#+0
   \       0x12   0x4804             LDR.N    R0,??gcode_M117_0+0x8
   \       0x14   0x6A80             LDR      R0,[R0, #+40]
   \       0x16   0x.... 0x....      B.W      _Z13lcd_setstatusPKcb
   \       0x1A   0xBF00             Nop      
   \                     ??gcode_M117_0:
   \       0x1C   0x....'....        DC32     card
   \       0x20   0x....'....        DC32     MSG_MKSPRINTINTING
   \       0x24   0x....'....        DC32     axis_relative_modes
   8475            }
   8476          }
   8477          
   8478          /**
   8479           * M119: Output endstop states to serial output
   8480           */

   \                                 In section .text, align 2
   8481          inline void gcode_M119() { endstops.M119(); }
   \                     _Z10gcode_M119v: (+1)
   \        0x0   0x.... 0x....      B.W      _ZN8Endstops4M119Ev
   8482          
   8483          /**
   8484           * M120: Enable endstops and set non-homing endstop state to "enabled"
   8485           */

   \                                 In section .text, align 2
   8486          inline void gcode_M120() { endstops.enable_globally(true); }
   \                     _Z10gcode_M120v: (+1)
   \        0x0   0x2001             MOVS     R0,#+1
   \        0x2   0x.... 0x....      B.W      _ZN8Endstops15enable_globallyEb
   8487          
   8488          /**
   8489           * M121: Disable endstops and set non-homing endstop state to "disabled"
   8490           */

   \                                 In section .text, align 2
   8491          inline void gcode_M121() { endstops.enable_globally(false); }
   \                     _Z10gcode_M121v: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x.... 0x....      B.W      _ZN8Endstops15enable_globallyEb
   8492          
   8493          #if ENABLED(PARK_HEAD_ON_PAUSE)
   8494          
   8495            /**
   8496             * M125: Store current position and move to filament change position.
   8497             *       Called on pause (by M25) to prevent material leaking onto the
   8498             *       object. On resume (M24) the head will be moved back and the
   8499             *       print will resume.
   8500             *
   8501             *       If Marlin is compiled without SD Card support, M125 can be
   8502             *       used directly to pause the print and move to park position,
   8503             *       resuming with a button click or M108.
   8504             *
   8505             *    L = override retract length
   8506             *    X = override X
   8507             *    Y = override Y
   8508             *    Z = override Z raise
   8509             */
   8510            inline void gcode_M125() {
   8511              if (move_away_flag) return; // already paused
   8512          
   8513              const bool job_running = print_job_timer.isRunning();
   8514          
   8515              // there are blocks after this one, or sd printing
   8516              move_away_flag = job_running || planner.blocks_queued()
   8517                #if ENABLED(SDSUPPORT)
   8518                  || card.sdprinting
   8519                #endif
   8520              ;
   8521          
   8522              if (!move_away_flag) return; // nothing to pause
   8523          
   8524              // M125 can be used to pause a print too
   8525              #if ENABLED(SDSUPPORT)
   8526                card.pauseSDPrint();
   8527              #endif
   8528              print_job_timer.pause();
   8529          
   8530              // Save current position
   8531              COPY(resume_position, current_position);
   8532          
   8533              set_destination_to_current();
   8534          
   8535              // Initial retract before move to filament change position
   8536              destination[E_AXIS] += code_seen('L') ? code_value_axis_units(E_AXIS) : 0
   8537                #if defined(FILAMENT_CHANGE_RETRACT_LENGTH) && FILAMENT_CHANGE_RETRACT_LENGTH > 0
   8538                  - (FILAMENT_CHANGE_RETRACT_LENGTH)
   8539                #endif
   8540              ;
   8541              RUNPLAN(FILAMENT_CHANGE_RETRACT_FEEDRATE);
   8542          
   8543              // Lift Z axis
   8544              const float z_lift = code_seen('Z') ? code_value_linear_units() :
   8545                #if defined(FILAMENT_CHANGE_Z_ADD) && FILAMENT_CHANGE_Z_ADD > 0
   8546                  FILAMENT_CHANGE_Z_ADD
   8547                #else
   8548                  0
   8549                #endif
   8550              ;
   8551              if (z_lift > 0) {
   8552                destination[Z_AXIS] += z_lift;
   8553                NOMORE(destination[Z_AXIS], Z_MAX_POS);
   8554                RUNPLAN(FILAMENT_CHANGE_Z_FEEDRATE);
   8555              }
   8556          
   8557              // Move XY axes to filament change position or given position
   8558              destination[X_AXIS] = code_seen('X') ? code_value_linear_units() : 0
   8559                #ifdef FILAMENT_CHANGE_X_POS
   8560                  + FILAMENT_CHANGE_X_POS
   8561                #endif
   8562              ;
   8563              destination[Y_AXIS] = code_seen('Y') ? code_value_linear_units() : 0
   8564                #ifdef FILAMENT_CHANGE_Y_POS
   8565                  + FILAMENT_CHANGE_Y_POS
   8566                #endif
   8567              ;
   8568          
   8569              #if HOTENDS > 1 && DISABLED(DUAL_X_CARRIAGE)
   8570                if (active_extruder > 0) {
   8571                  if (!code_seen('X')) destination[X_AXIS] += hotend_offset[X_AXIS][active_extruder];
   8572                  if (!code_seen('Y')) destination[Y_AXIS] += hotend_offset[Y_AXIS][active_extruder];
   8573                }
   8574              #endif
   8575          
   8576              clamp_to_software_endstops(destination);
   8577              RUNPLAN(FILAMENT_CHANGE_XY_FEEDRATE);
   8578              set_current_to_destination();
   8579              stepper.synchronize();
   8580              disable_e_steppers();
   8581          
   8582              #if DISABLED(SDSUPPORT)
   8583                // Wait for lcd click or M108
   8584                KEEPALIVE_STATE(PAUSED_FOR_USER);
   8585                wait_for_user = true;
   8586                while (wait_for_user) idle();
   8587                KEEPALIVE_STATE(IN_HANDLER);
   8588          
   8589                // Return to print position and continue
   8590                move_back_on_resume();
   8591                if (job_running) print_job_timer.start();
   8592                move_away_flag = false;
   8593              #endif
   8594            }
   8595          
   8596          #endif // PARK_HEAD_ON_PAUSE
   8597          
   8598          #if HAS_COLOR_LEDS
   8599          
   8600            /**
   8601             * M150: Set Status LED Color - Use R-U-B-W for R-G-B-W
   8602             *
   8603             * Always sets all 3 or 4 components. If a component is left out, set to 0.
   8604             *
   8605             * Examples:
   8606             *
   8607             *   M150 R255       ; Turn LED red
   8608             *   M150 R255 U127  ; Turn LED orange (PWM only)
   8609             *   M150            ; Turn LED off
   8610             *   M150 R U B      ; Turn LED white
   8611             *   M150 W          ; Turn LED white using a white LED
   8612             *
   8613             */
   8614            inline void gcode_M150() {
   8615              set_led_color(
   8616                code_seen('R') ? (code_has_value() ? code_value_byte() : 255) : 0,
   8617                code_seen('U') ? (code_has_value() ? code_value_byte() : 255) : 0,
   8618                code_seen('B') ? (code_has_value() ? code_value_byte() : 255) : 0
   8619                #if ENABLED(RGBW_LED)
   8620                  , code_seen('W') ? (code_has_value() ? code_value_byte() : 255) : 0
   8621                #endif
   8622              );
   8623            }
   8624          
   8625          #endif // BLINKM || RGB_LED
   8626          
   8627          /**
   8628           * M200: Set filament diameter and set E axis units to cubic units
   8629           *
   8630           *    T<extruder> - Optional extruder number. Current extruder if omitted.
   8631           *    D<linear> - Diameter of the filament. Use "D0" to switch back to linear units on the E axis.
   8632           */

   \                                 In section .text, align 4
   8633          inline void gcode_M200() {
   \                     _Z10gcode_M200v: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   8634          
   8635            if (get_target_extruder_from_command(200)) return;
   \        0x2   0x20C8             MOVS     R0,#+200
   \        0x4   0x.... 0x....      BL       _Z32get_target_extruder_from_commandi
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD12A             BNE.N    ??gcode_M200_1
   8636          
   8637            if (code_seen('D')) {
   \        0xC   0x2044             MOVS     R0,#+68
   \        0xE   0x.... 0x....      BL       _Z9code_seenc
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD021             BEQ.N    ??gcode_M200_2
   8638              // setting any extruder filament size disables volumetric on the assumption that
   8639              // slicers either generate in extruder values as cubic mm or as as filament feeds
   8640              // for all extruders
   8641              volumetric_enabled = (code_value_linear_units() != 0.0);
   \       0x16   0x4C13             LDR.N    R4,??gcode_M200_0
   \       0x18   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x1C   0x2100             MOVS     R1,#+0
   \       0x1E   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0x22   0xD002             BEQ.N    ??gcode_M200_3
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0x7020             STRB     R0,[R4, #+0]
   \       0x28   0xE001             B.N      ??gcode_M200_4
   \                     ??gcode_M200_3: (+1)
   \       0x2A   0x4608             MOV      R0,R1
   \       0x2C   0x7020             STRB     R0,[R4, #+0]
   8642              if (volumetric_enabled) {
   \                     ??gcode_M200_4: (+1)
   \       0x2E   0x7820             LDRB     R0,[R4, #+0]
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD012             BEQ.N    ??gcode_M200_2
   8643                filament_size[target_extruder] = code_value_linear_units();
   \       0x34   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x38   0x1D21             ADDS     R1,R4,#+4
   \       0x3A   0x4A0B             LDR.N    R2,??gcode_M200_0+0x4
   \       0x3C   0x7952             LDRB     R2,[R2, #+5]
   \       0x3E   0xF841 0x0022      STR      R0,[R1, R2, LSL #+2]
   8644                // make sure all extruders have some sane value for the filament size
   8645                for (uint8_t i = 0; i < COUNT(filament_size); i++)
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0x4601             MOV      R1,R0
   \       0x46   0xE006             B.N      ??gcode_M200_5
   8646                  if (! filament_size[i]) filament_size[i] = DEFAULT_NOMINAL_FILAMENT_DIA;
   \                     ??gcode_M200_6: (+1)
   \       0x48   0x6860             LDR      R0,[R4, #+4]
   \       0x4A   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0x4E   0xD101             BNE.N    ??gcode_M200_7
   \       0x50   0x4806             LDR.N    R0,??gcode_M200_0+0x8  ;; 0x40400000
   \       0x52   0x6060             STR      R0,[R4, #+4]
   \                     ??gcode_M200_7: (+1)
   \       0x54   0x2001             MOVS     R0,#+1
   \                     ??gcode_M200_5: (+1)
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD0F6             BEQ.N    ??gcode_M200_6
   8647              }
   8648            }
   8649            calculate_volumetric_multipliers();
   \                     ??gcode_M200_2: (+1)
   \       0x5A   0xE8BD 0x4010      POP      {R4,LR}
   \       0x5E   0x.... 0x....      B.W      _Z32calculate_volumetric_multipliersv
   \                     ??gcode_M200_1: (+1)
   \       0x62   0xBD10             POP      {R4,PC}          ;; return
   \                     ??gcode_M200_0:
   \       0x64   0x....'....        DC32     volumetric_enabled
   \       0x68   0x....'....        DC32     mks_heating_busy
   \       0x6C   0x4040'0000        DC32     0x40400000
   8650          }
   8651          
   8652          /**
   8653           * M201: Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)
   8654           *
   8655           *       With multiple extruders use T to specify which one.
   8656           */

   \                                 In section .text, align 4
   8657          inline void gcode_M201() {
   \                     _Z10gcode_M201v: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   8658          
   8659            GET_TARGET_EXTRUDER(201);
   8660          
   8661            LOOP_XYZE(i) {
   \        0x2   0x2400             MOVS     R4,#+0
   \        0x4   0xE00E             B.N      ??gcode_M201_1
   8662              if (code_seen(axis_codes[i])) {
   \                     ??gcode_M201_2: (+1)
   \        0x6   0x480A             LDR.N    R0,??gcode_M201_0
   \        0x8   0x5700             LDRSB    R0,[R0, R4]
   \        0xA   0x.... 0x....      BL       _Z9code_seenc
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD007             BEQ.N    ??gcode_M201_3
   8663                const uint8_t a = i + (i == E_AXIS ? TARGET_EXTRUDER : 0);
   8664                planner.max_acceleration_mm_per_s2[a] = code_value_axis_units((AxisEnum)a);
                                                             ^
Warning[Pa093]: implicit conversion from floating point to integer
   \       0x12   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x16   0x.... 0x....      BL       __aeabi_f2uiz
   \       0x1A   0x4906             LDR.N    R1,??gcode_M201_0+0x4
   \       0x1C   0x4622             MOV      R2,R4
   \       0x1E   0xF841 0x0022      STR      R0,[R1, R2, LSL #+2]
   8665              }
   8666            }
   \                     ??gcode_M201_3: (+1)
   \       0x22   0x1C64             ADDS     R4,R4,#+1
   \                     ??gcode_M201_1: (+1)
   \       0x24   0x2C04             CMP      R4,#+4
   \       0x26   0xDBEE             BLT.N    ??gcode_M201_2
   8667            // steps per sq second need to be updated to agree with the units per sq second (as they are what is used in the planner)
   8668            planner.reset_acceleration_rates();
   \       0x28   0xE8BD 0x4010      POP      {R4,LR}
   \       0x2C   0x.... 0x....      B.W      _ZN7Planner24reset_acceleration_ratesEv
   \                     ??gcode_M201_0:
   \       0x30   0x....'....        DC32     axis_codes
   \       0x34   0x....'....        DC32     _ZN7Planner26max_acceleration_mm_per_s2E
   8669          }
   8670          
   8671          #if 0 // Not used for Sprinter/grbl gen6
   8672            inline void gcode_M202() {
   8673              LOOP_XYZE(i) {
   8674                if (code_seen(axis_codes[i])) axis_travel_steps_per_sqr_second[i] = code_value_axis_units((AxisEnum)i) * planner.axis_steps_per_mm[i];
   8675              }
   8676            }
   8677          #endif
   8678          
   8679          
   8680          /**
   8681           * M203: Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in units/sec
   8682           *
   8683           *       With multiple extruders use T to specify which one.
   8684           */

   \                                 In section .text, align 4
   8685          inline void gcode_M203() {
   \                     _Z10gcode_M203v: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   8686          
   8687            GET_TARGET_EXTRUDER(203);
   8688          
   8689            LOOP_XYZE(i)
   \        0x2   0x2400             MOVS     R4,#+0
   \        0x4   0xE00C             B.N      ??gcode_M203_1
   8690              if (code_seen(axis_codes[i])) {
   \                     ??gcode_M203_2: (+1)
   \        0x6   0x4808             LDR.N    R0,??gcode_M203_0
   \        0x8   0x5700             LDRSB    R0,[R0, R4]
   \        0xA   0x.... 0x....      BL       _Z9code_seenc
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD005             BEQ.N    ??gcode_M203_3
   8691                const uint8_t a = i + (i == E_AXIS ? TARGET_EXTRUDER : 0);
   8692                planner.max_feedrate_mm_s[a] = code_value_axis_units((AxisEnum)a);
   \       0x12   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x16   0x4905             LDR.N    R1,??gcode_M203_0+0x4
   \       0x18   0x4622             MOV      R2,R4
   \       0x1A   0xF841 0x0022      STR      R0,[R1, R2, LSL #+2]
   8693              }
   \                     ??gcode_M203_3: (+1)
   \       0x1E   0x1C64             ADDS     R4,R4,#+1
   \                     ??gcode_M203_1: (+1)
   \       0x20   0x2C04             CMP      R4,#+4
   \       0x22   0xDBF0             BLT.N    ??gcode_M203_2
   8694          }
   \       0x24   0xBD10             POP      {R4,PC}          ;; return
   \       0x26   0xBF00             Nop      
   \                     ??gcode_M203_0:
   \       0x28   0x....'....        DC32     axis_codes
   \       0x2C   0x....'....        DC32     _ZN7Planner17max_feedrate_mm_sE
   8695          
   8696          /**
   8697           * M204: Set Accelerations in units/sec^2 (M204 P1200 R3000 T3000)
   8698           *
   8699           *    P = Printing moves
   8700           *    R = Retract only (no X, Y, Z) moves
   8701           *    T = Travel (non printing) moves
   8702           *
   8703           *  Also sets minimum segment time in ms (B20000) to prevent buffer under-runs and M20 minimum feedrate
   8704           */

   \                                 In section .text, align 4
   8705          inline void gcode_M204() {
   \                     _Z10gcode_M204v: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   8706            if (code_seen('S')) {  // Kept for legacy compatibility. Should NOT BE USED for new developments.
   \        0x2   0x2053             MOVS     R0,#+83
   \        0x4   0x.... 0x....      BL       _Z9code_seenc
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD017             BEQ.N    ??gcode_M204_1
   8707              planner.travel_acceleration = planner.acceleration = code_value_linear_units();
   \        0xC   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x10   0x4935             LDR.N    R1,??gcode_M204_0
   \       0x12   0x6008             STR      R0,[R1, #+0]
   \       0x14   0x4935             LDR.N    R1,??gcode_M204_0+0x4
   \       0x16   0x6008             STR      R0,[R1, #+0]
   8708              SERIAL_ECHOLNPAIR("Setting Print and Travel Acceleration: ", planner.acceleration);
   \       0x18   0x4601             MOV      R1,R0
   \       0x1A   0x4835             LDR.N    R0,??gcode_M204_0+0x8
   \       0x1C   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \       0x20   0x4834             LDR.N    R0,??gcode_M204_0+0xC
   \       0x22   0x79C0             LDRB     R0,[R0, #+7]
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD104             BNE.N    ??gcode_M204_2
   \       0x28   0x210A             MOVS     R1,#+10
   \       0x2A   0x4833             LDR.N    R0,??gcode_M204_0+0x10
   \       0x2C   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \       0x30   0xE004             B.N      ??gcode_M204_1
   \                     ??gcode_M204_2: (+1)
   \       0x32   0x2200             MOVS     R2,#+0
   \       0x34   0x210A             MOVS     R1,#+10
   \       0x36   0x4831             LDR.N    R0,??gcode_M204_0+0x14
   \       0x38   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   8709            }
   8710            if (code_seen('P')) {
   \                     ??gcode_M204_1: (+1)
   \       0x3C   0x2050             MOVS     R0,#+80
   \       0x3E   0x.... 0x....      BL       _Z9code_seenc
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD015             BEQ.N    ??gcode_M204_3
   8711              planner.acceleration = code_value_linear_units();
   \       0x46   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x4A   0x4927             LDR.N    R1,??gcode_M204_0
   \       0x4C   0x6008             STR      R0,[R1, #+0]
   8712              SERIAL_ECHOLNPAIR("Setting Print Acceleration: ", planner.acceleration);
   \       0x4E   0x4601             MOV      R1,R0
   \       0x50   0x482B             LDR.N    R0,??gcode_M204_0+0x18
   \       0x52   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \       0x56   0x4827             LDR.N    R0,??gcode_M204_0+0xC
   \       0x58   0x79C0             LDRB     R0,[R0, #+7]
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD104             BNE.N    ??gcode_M204_4
   \       0x5E   0x210A             MOVS     R1,#+10
   \       0x60   0x4825             LDR.N    R0,??gcode_M204_0+0x10
   \       0x62   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \       0x66   0xE004             B.N      ??gcode_M204_3
   \                     ??gcode_M204_4: (+1)
   \       0x68   0x2200             MOVS     R2,#+0
   \       0x6A   0x210A             MOVS     R1,#+10
   \       0x6C   0x4823             LDR.N    R0,??gcode_M204_0+0x14
   \       0x6E   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   8713            }
   8714            if (code_seen('R')) {
   \                     ??gcode_M204_3: (+1)
   \       0x72   0x2052             MOVS     R0,#+82
   \       0x74   0x.... 0x....      BL       _Z9code_seenc
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD015             BEQ.N    ??gcode_M204_5
   8715              planner.retract_acceleration = code_value_linear_units();
   \       0x7C   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x80   0x4920             LDR.N    R1,??gcode_M204_0+0x1C
   \       0x82   0x6008             STR      R0,[R1, #+0]
   8716              SERIAL_ECHOLNPAIR("Setting Retract Acceleration: ", planner.retract_acceleration);
   \       0x84   0x4601             MOV      R1,R0
   \       0x86   0x4820             LDR.N    R0,??gcode_M204_0+0x20
   \       0x88   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \       0x8C   0x4819             LDR.N    R0,??gcode_M204_0+0xC
   \       0x8E   0x79C0             LDRB     R0,[R0, #+7]
   \       0x90   0x2800             CMP      R0,#+0
   \       0x92   0xD104             BNE.N    ??gcode_M204_6
   \       0x94   0x210A             MOVS     R1,#+10
   \       0x96   0x4818             LDR.N    R0,??gcode_M204_0+0x10
   \       0x98   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \       0x9C   0xE004             B.N      ??gcode_M204_5
   \                     ??gcode_M204_6: (+1)
   \       0x9E   0x2200             MOVS     R2,#+0
   \       0xA0   0x210A             MOVS     R1,#+10
   \       0xA2   0x4816             LDR.N    R0,??gcode_M204_0+0x14
   \       0xA4   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   8717            }
   8718            if (code_seen('T')) {
   \                     ??gcode_M204_5: (+1)
   \       0xA8   0x2054             MOVS     R0,#+84
   \       0xAA   0x.... 0x....      BL       _Z9code_seenc
   \       0xAE   0x2800             CMP      R0,#+0
   \       0xB0   0xD018             BEQ.N    ??gcode_M204_7
   8719              planner.travel_acceleration = code_value_linear_units();
   \       0xB2   0x.... 0x....      BL       _Z16code_value_floatv
   \       0xB6   0x490D             LDR.N    R1,??gcode_M204_0+0x4
   \       0xB8   0x6008             STR      R0,[R1, #+0]
   8720              SERIAL_ECHOLNPAIR("Setting Travel Acceleration: ", planner.travel_acceleration);
   \       0xBA   0x4601             MOV      R1,R0
   \       0xBC   0x4813             LDR.N    R0,??gcode_M204_0+0x24
   \       0xBE   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \       0xC2   0x480C             LDR.N    R0,??gcode_M204_0+0xC
   \       0xC4   0x79C0             LDRB     R0,[R0, #+7]
   \       0xC6   0x2800             CMP      R0,#+0
   \       0xC8   0xD105             BNE.N    ??gcode_M204_8
   \       0xCA   0x210A             MOVS     R1,#+10
   \       0xCC   0x480A             LDR.N    R0,??gcode_M204_0+0x10
   \       0xCE   0xE8BD 0x4004      POP      {R2,LR}
   \       0xD2   0x.... 0x....      B.W      _ZN12MarlinSerial5writeEh
   \                     ??gcode_M204_8: (+1)
   \       0xD6   0x2200             MOVS     R2,#+0
   \       0xD8   0x210A             MOVS     R1,#+10
   \       0xDA   0x4808             LDR.N    R0,??gcode_M204_0+0x14
   \       0xDC   0xE8BD 0x4008      POP      {R3,LR}
   \       0xE0   0x.... 0x....      B.W      _ZN12MarlinSerial5printEci
   8721            }
   8722          }
   \                     ??gcode_M204_7: (+1)
   \       0xE4   0xBD01             POP      {R0,PC}          ;; return
   \       0xE6   0xBF00             Nop      
   \                     ??gcode_M204_0:
   \       0xE8   0x....'....        DC32     _ZN7Planner12accelerationE
   \       0xEC   0x....'....        DC32     _ZN7Planner19travel_accelerationE
   \       0xF0   0x....'....        DC32     _ZZ10gcode_M204vEs
   \       0xF4   0x....'....        DC32     mks_heating_busy
   \       0xF8   0x....'....        DC32     customizedSerial
   \       0xFC   0x....'....        DC32     serial2
   \      0x100   0x....'....        DC32     _ZZ10gcode_M204vEs_0
   \      0x104   0x....'....        DC32     _ZN7Planner20retract_accelerationE
   \      0x108   0x....'....        DC32     _ZZ10gcode_M204vEs_1
   \      0x10C   0x....'....        DC32     _ZZ10gcode_M204vEs_2
   8723          
   8724          /**
   8725           * M205: Set Advanced Settings
   8726           *
   8727           *    S = Min Feed Rate (units/s)
   8728           *    T = Min Travel Feed Rate (units/s)
   8729           *    B = Min Segment Time (Âµs)
   8730           *    X = Max X Jerk (units/sec^2)
   8731           *    Y = Max Y Jerk (units/sec^2)
   8732           *    Z = Max Z Jerk (units/sec^2)
   8733           *    E = Max E Jerk (units/sec^2)
   8734           */

   \                                 In section .text, align 4
   8735          inline void gcode_M205() {
   \                     _Z10gcode_M205v: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   8736            if (code_seen('S')) planner.min_feedrate_mm_s = code_value_linear_units();
   \        0x2   0x2053             MOVS     R0,#+83
   \        0x4   0x.... 0x....      BL       _Z9code_seenc
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD003             BEQ.N    ??gcode_M205_1
   \        0xC   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x10   0x491C             LDR.N    R1,??gcode_M205_0
   \       0x12   0x6008             STR      R0,[R1, #+0]
   8737            if (code_seen('T')) planner.min_travel_feedrate_mm_s = code_value_linear_units();
   \                     ??gcode_M205_1: (+1)
   \       0x14   0x2054             MOVS     R0,#+84
   \       0x16   0x.... 0x....      BL       _Z9code_seenc
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD003             BEQ.N    ??gcode_M205_2
   \       0x1E   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x22   0x4919             LDR.N    R1,??gcode_M205_0+0x4
   \       0x24   0x6008             STR      R0,[R1, #+0]
   8738            if (code_seen('B')) planner.min_segment_time = code_value_millis();
   \                     ??gcode_M205_2: (+1)
   \       0x26   0x2042             MOVS     R0,#+66
   \       0x28   0x.... 0x....      BL       _Z9code_seenc
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD003             BEQ.N    ??gcode_M205_3
   \       0x30   0x.... 0x....      BL       _Z17code_value_millisv
   \       0x34   0x4915             LDR.N    R1,??gcode_M205_0+0x8
   \       0x36   0x6008             STR      R0,[R1, #+0]
   8739            if (code_seen('X')) planner.max_jerk[X_AXIS] = code_value_linear_units();
   \                     ??gcode_M205_3: (+1)
   \       0x38   0x2058             MOVS     R0,#+88
   \       0x3A   0x.... 0x....      BL       _Z9code_seenc
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD003             BEQ.N    ??gcode_M205_4
   \       0x42   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x46   0x4912             LDR.N    R1,??gcode_M205_0+0xC
   \       0x48   0x6008             STR      R0,[R1, #+0]
   8740            if (code_seen('Y')) planner.max_jerk[Y_AXIS] = code_value_linear_units();
   \                     ??gcode_M205_4: (+1)
   \       0x4A   0x2059             MOVS     R0,#+89
   \       0x4C   0x.... 0x....      BL       _Z9code_seenc
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD003             BEQ.N    ??gcode_M205_5
   \       0x54   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x58   0x490D             LDR.N    R1,??gcode_M205_0+0xC
   \       0x5A   0x6048             STR      R0,[R1, #+4]
   8741            if (code_seen('Z')) planner.max_jerk[Z_AXIS] = code_value_linear_units();
   \                     ??gcode_M205_5: (+1)
   \       0x5C   0x205A             MOVS     R0,#+90
   \       0x5E   0x.... 0x....      BL       _Z9code_seenc
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xD003             BEQ.N    ??gcode_M205_6
   \       0x66   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x6A   0x4909             LDR.N    R1,??gcode_M205_0+0xC
   \       0x6C   0x6088             STR      R0,[R1, #+8]
   8742            if (code_seen('E')) planner.max_jerk[E_AXIS] = code_value_linear_units();
   \                     ??gcode_M205_6: (+1)
   \       0x6E   0x2045             MOVS     R0,#+69
   \       0x70   0x.... 0x....      BL       _Z9code_seenc
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD003             BEQ.N    ??gcode_M205_7
   \       0x78   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x7C   0x4904             LDR.N    R1,??gcode_M205_0+0xC
   \       0x7E   0x60C8             STR      R0,[R1, #+12]
   8743          }
   \                     ??gcode_M205_7: (+1)
   \       0x80   0xBD01             POP      {R0,PC}          ;; return
   \       0x82   0xBF00             Nop      
   \                     ??gcode_M205_0:
   \       0x84   0x....'....        DC32     _ZN7Planner17min_feedrate_mm_sE
   \       0x88   0x....'....        DC32     _ZN7Planner24min_travel_feedrate_mm_sE
   \       0x8C   0x....'....        DC32     _ZN7Planner16min_segment_timeE
   \       0x90   0x....'....        DC32     _ZN7Planner8max_jerkE
   8744          
   8745          //#if HAS_M206_COMMAND	//mks_delta
   8746          #if 1
   8747            /**
   8748             * M206: Set Additional Homing Offset (X Y Z). SCARA aliases T=X, P=Y
   8749             */

   \                                 In section .text, align 4
   8750            inline void gcode_M206() {
   \                     _Z10gcode_M206v: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   8751            	if(MACHINETPYE == DELTA) return;
   \        0x2   0x4C1C             LDR.N    R4,??gcode_M206_0
   \        0x4   0xF9B4 0x0058      LDRSH    R0,[R4, #+88]
   \        0x8   0x2802             CMP      R0,#+2
   \        0xA   0xD032             BEQ.N    ??gcode_M206_1
   8752              LOOP_XYZ(i)
   \        0xC   0x2500             MOVS     R5,#+0
   \        0xE   0xE00D             B.N      ??gcode_M206_2
   8753                if (code_seen(axis_codes[i]))
   \                     ??gcode_M206_3: (+1)
   \       0x10   0x4819             LDR.N    R0,??gcode_M206_0+0x4
   \       0x12   0x5740             LDRSB    R0,[R0, R5]
   \       0x14   0x.... 0x....      BL       _Z9code_seenc
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD006             BEQ.N    ??gcode_M206_4
   8754                  set_home_offset((AxisEnum)i, code_value_linear_units());
   \       0x1C   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x20   0x4601             MOV      R1,R0
   \       0x22   0x4628             MOV      R0,R5
   \       0x24   0xB240             SXTB     R0,R0
   \       0x26   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531915set_home_offsetE8AxisEnumf
   \                     ??gcode_M206_4: (+1)
   \       0x2A   0x1C6D             ADDS     R5,R5,#+1
   \                     ??gcode_M206_2: (+1)
   \       0x2C   0x2D03             CMP      R5,#+3
   \       0x2E   0xDBEF             BLT.N    ??gcode_M206_3
   8755          
   8756              //#if ENABLED(MORGAN_SCARA)
   8757          	if(MACHINETPYE == MORGAN_SCARA)	{
   \       0x30   0xF9B4 0x0058      LDRSH    R0,[R4, #+88]
   \       0x34   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x38   0xD115             BNE.N    ??gcode_M206_5
   8758                if (code_seen('T')) set_home_offset(A_AXIS, code_value_linear_units()); // Theta
   \       0x3A   0x2054             MOVS     R0,#+84
   \       0x3C   0x.... 0x....      BL       _Z9code_seenc
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD005             BEQ.N    ??gcode_M206_6
   \       0x44   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x48   0x4601             MOV      R1,R0
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531915set_home_offsetE8AxisEnumf
   8759                if (code_seen('P')) set_home_offset(B_AXIS, code_value_linear_units()); // Psi
   \                     ??gcode_M206_6: (+1)
   \       0x50   0x2050             MOVS     R0,#+80
   \       0x52   0x.... 0x....      BL       _Z9code_seenc
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD005             BEQ.N    ??gcode_M206_5
   \       0x5A   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x5E   0x4601             MOV      R1,R0
   \       0x60   0x2001             MOVS     R0,#+1
   \       0x62   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531915set_home_offsetE8AxisEnumf
   8760              }//#endif
   8761          
   8762              SYNC_PLAN_POSITION_KINEMATIC();
   \                     ??gcode_M206_5: (+1)
   \       0x66   0x.... 0x....      BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
   8763              report_current_position();
   \       0x6A   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \       0x6E   0x.... 0x....      B.W      _ZN37_INTERNAL_15_Marlin_main_cpp_3178531923report_current_positionEv
   \                     ??gcode_M206_1: (+1)
   \       0x72   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \                     ??gcode_M206_0:
   \       0x74   0x....'....        DC32     mksCfg
   \       0x78   0x....'....        DC32     axis_codes
   8764            }
   8765          
   8766          #endif // HAS_M206_COMMAND
   8767          
   8768          //#if ENABLED(DELTA)	//mks_delta
   8769          #if 1
   8770            /**
   8771             * M665: Set delta configurations
   8772             *
   8773             *    H = diagonal rod // AC-version
   8774             *    L = diagonal rod
   8775             *    R = delta radius
   8776             *    S = segments per second
   8777             *    A = Alpha (Tower 1) diagonal rod trim
   8778             *    B = Beta (Tower 2) diagonal rod trim
   8779             *    C = Gamma (Tower 3) diagonal rod trim
   8780             */

   \                                 In section .text, align 4
   8781            inline void gcode_M665() {
   \                     _Z10gcode_M665v: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   8782              if (code_seen('H')) {
   \        0x2   0x2048             MOVS     R0,#+72
   \        0x4   0x.... 0x....      BL       _Z9code_seenc
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD01C             BEQ.N    ??gcode_M665_1
   8783                home_offset[Z_AXIS] = code_value_linear_units() - DELTA_HEIGHT;
   \        0xC   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x10   0x4C32             LDR.N    R4,??gcode_M665_0
   \       0x12   0x4D33             LDR.N    R5,??gcode_M665_0+0x4
   \       0x14   0x6D29             LDR      R1,[R5, #+80]
   \       0x16   0x.... 0x....      BL       __aeabi_fsub
   \       0x1A   0x6420             STR      R0,[R4, #+64]
   8784                current_position[Z_AXIS] += code_value_linear_units() - DELTA_HEIGHT - home_offset[Z_AXIS];
   \       0x1C   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x20   0x6D29             LDR      R1,[R5, #+80]
   \       0x22   0x.... 0x....      BL       __aeabi_fsub
   \       0x26   0x6C21             LDR      R1,[R4, #+64]
   \       0x28   0x.... 0x....      BL       __aeabi_fsub
   \       0x2C   0x6921             LDR      R1,[R4, #+16]
   \       0x2E   0x.... 0x....      BL       __aeabi_fadd
   \       0x32   0x6120             STR      R0,[R4, #+16]
   8785                home_offset[Z_AXIS] = code_value_linear_units() - DELTA_HEIGHT;
   \       0x34   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x38   0x6D29             LDR      R1,[R5, #+80]
   \       0x3A   0x.... 0x....      BL       __aeabi_fsub
   \       0x3E   0x6420             STR      R0,[R4, #+64]
   8786                update_software_endstops(Z_AXIS);
   \       0x40   0x2002             MOVS     R0,#+2
   \       0x42   0x.... 0x....      BL       _Z24update_software_endstops8AxisEnum
   8787              }
   8788              if (code_seen('L')) delta_diagonal_rod = code_value_linear_units();
   \                     ??gcode_M665_1: (+1)
   \       0x46   0x4C27             LDR.N    R4,??gcode_M665_0+0x8
   \       0x48   0x204C             MOVS     R0,#+76
   \       0x4A   0x.... 0x....      BL       _Z9code_seenc
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD002             BEQ.N    ??gcode_M665_2
   \       0x52   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x56   0x6520             STR      R0,[R4, #+80]
   8789              if (code_seen('R')) delta_radius = code_value_linear_units();
   \                     ??gcode_M665_2: (+1)
   \       0x58   0x2052             MOVS     R0,#+82
   \       0x5A   0x.... 0x....      BL       _Z9code_seenc
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD002             BEQ.N    ??gcode_M665_3
   \       0x62   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x66   0x64E0             STR      R0,[R4, #+76]
   8790              if (code_seen('S')) delta_segments_per_second = code_value_float();
   \                     ??gcode_M665_3: (+1)
   \       0x68   0x2053             MOVS     R0,#+83
   \       0x6A   0x.... 0x....      BL       _Z9code_seenc
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD002             BEQ.N    ??gcode_M665_4
   \       0x72   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x76   0x65A0             STR      R0,[R4, #+88]
   8791              if (code_seen('B')) delta_calibration_radius = code_value_float();
   \                     ??gcode_M665_4: (+1)
   \       0x78   0x2042             MOVS     R0,#+66
   \       0x7A   0x.... 0x....      BL       _Z9code_seenc
   \       0x7E   0x2800             CMP      R0,#+0
   \       0x80   0xD002             BEQ.N    ??gcode_M665_5
   \       0x82   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x86   0x6560             STR      R0,[R4, #+84]
   8792              if (code_seen('X')) delta_tower_angle_trim[A_AXIS] = code_value_linear_units();
   \                     ??gcode_M665_5: (+1)
   \       0x88   0x2058             MOVS     R0,#+88
   \       0x8A   0x.... 0x....      BL       _Z9code_seenc
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xD002             BEQ.N    ??gcode_M665_6
   \       0x92   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x96   0x6360             STR      R0,[R4, #+52]
   8793              if (code_seen('Y')) delta_tower_angle_trim[B_AXIS] = code_value_linear_units();
   \                     ??gcode_M665_6: (+1)
   \       0x98   0x2059             MOVS     R0,#+89
   \       0x9A   0x.... 0x....      BL       _Z9code_seenc
   \       0x9E   0x2800             CMP      R0,#+0
   \       0xA0   0xD002             BEQ.N    ??gcode_M665_7
   \       0xA2   0x.... 0x....      BL       _Z16code_value_floatv
   \       0xA6   0x63A0             STR      R0,[R4, #+56]
   8794              if (code_seen('Z')) { // rotate all 3 axis for Z = 0
   \                     ??gcode_M665_7: (+1)
   \       0xA8   0x205A             MOVS     R0,#+90
   \       0xAA   0x.... 0x....      BL       _Z9code_seenc
   \       0xAE   0x2800             CMP      R0,#+0
   \       0xB0   0xD00D             BEQ.N    ??gcode_M665_8
   8795                delta_tower_angle_trim[A_AXIS] -= code_value_linear_units();
   \       0xB2   0x.... 0x....      BL       _Z16code_value_floatv
   \       0xB6   0x4601             MOV      R1,R0
   \       0xB8   0x6B60             LDR      R0,[R4, #+52]
   \       0xBA   0x.... 0x....      BL       __aeabi_fsub
   \       0xBE   0x6360             STR      R0,[R4, #+52]
   8796                delta_tower_angle_trim[B_AXIS] -= code_value_linear_units();
   \       0xC0   0x.... 0x....      BL       _Z16code_value_floatv
   \       0xC4   0x4601             MOV      R1,R0
   \       0xC6   0x6BA0             LDR      R0,[R4, #+56]
   \       0xC8   0x.... 0x....      BL       __aeabi_fsub
   \       0xCC   0x63A0             STR      R0,[R4, #+56]
   8797              }
   8798              recalc_delta_settings(delta_radius, delta_diagonal_rod);
   \                     ??gcode_M665_8: (+1)
   \       0xCE   0x6D21             LDR      R1,[R4, #+80]
   \       0xD0   0x6CE0             LDR      R0,[R4, #+76]
   \       0xD2   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \       0xD6   0x.... 0x....      B.W      _Z21recalc_delta_settingsff
   \       0xDA   0xBF00             Nop      
   \                     ??gcode_M665_0:
   \       0xDC   0x....'....        DC32     mks_heating_busy
   \       0xE0   0x....'....        DC32     mksCfg
   \       0xE4   0x....'....        DC32     axis_homed
   8799            }
   8800            /**
   8801             * M666: Set delta endstop adjustment
   8802             */

   \                                 In section .text, align 4
   8803            inline void gcode_M666() {
   \                     _Z10gcode_M666v: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   8804              #if ENABLED(DEBUG_LEVELING_FEATURE)
   8805                if (DEBUGGING(LEVELING)) {
   8806                  SERIAL_ECHOLNPGM(">>> gcode_M666");
   8807                }
   8808              #endif
   8809              LOOP_XYZ(i) {
   \        0x2   0x2400             MOVS     R4,#+0
   \        0x4   0x4D1A             LDR.N    R5,??gcode_M666_0
   \        0x6   0xE00A             B.N      ??gcode_M666_1
   8810                if (code_seen(axis_codes[i])) {
   \                     ??gcode_M666_2: (+1)
   \        0x8   0x481A             LDR.N    R0,??gcode_M666_0+0x4
   \        0xA   0x5700             LDRSB    R0,[R0, R4]
   \        0xC   0x.... 0x....      BL       _Z9code_seenc
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD003             BEQ.N    ??gcode_M666_3
   8811                  endstop_adj[i] = code_value_linear_units();
   \       0x14   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x18   0xF845 0x0024      STR      R0,[R5, R4, LSL #+2]
   8812                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   8813                    if (DEBUGGING(LEVELING)) {
   8814                      SERIAL_ECHOPAIR("endstop_adj[", axis_codes[i]);
   8815                      SERIAL_ECHOLNPAIR("] = ", endstop_adj[i]);
   8816                    }
   8817                  #endif
   8818                }
   8819              }
   \                     ??gcode_M666_3: (+1)
   \       0x1C   0x1C64             ADDS     R4,R4,#+1
   \                     ??gcode_M666_1: (+1)
   \       0x1E   0x2C03             CMP      R4,#+3
   \       0x20   0xDBF2             BLT.N    ??gcode_M666_2
   8820              #if ENABLED(DEBUG_LEVELING_FEATURE)
   8821                if (DEBUGGING(LEVELING)) {
   8822                  SERIAL_ECHOLNPGM("<<< gcode_M666");
   8823                }
   8824              #endif
   8825              // normalize endstops so all are <=0; set the residue to delta height
   8826              const float z_temp = MAX3(endstop_adj[A_AXIS], endstop_adj[B_AXIS], endstop_adj[C_AXIS]);
   \       0x22   0x686C             LDR      R4,[R5, #+4]
   \       0x24   0x682A             LDR      R2,[R5, #+0]
   \       0x26   0x4620             MOV      R0,R4
   \       0x28   0x4611             MOV      R1,R2
   \       0x2A   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x2E   0xD300             BCC.N    ??gcode_M666_4
   \       0x30   0x4621             MOV      R1,R4
   \                     ??gcode_M666_4: (+1)
   \       0x32   0x68A8             LDR      R0,[R5, #+8]
   \       0x34   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x38   0xD206             BCS.N    ??gcode_M666_5
   \       0x3A   0x4620             MOV      R0,R4
   \       0x3C   0x4611             MOV      R1,R2
   \       0x3E   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x42   0xD202             BCS.N    ??gcode_M666_6
   \       0x44   0x4614             MOV      R4,R2
   \       0x46   0xE000             B.N      ??gcode_M666_6
   \                     ??gcode_M666_5: (+1)
   \       0x48   0x4604             MOV      R4,R0
   8827              home_offset[Z_AXIS] -= z_temp;
   \                     ??gcode_M666_6: (+1)
   \       0x4A   0x4E0B             LDR.N    R6,??gcode_M666_0+0x8
   \       0x4C   0x6C30             LDR      R0,[R6, #+64]
   \       0x4E   0x4621             MOV      R1,R4
   \       0x50   0x.... 0x....      BL       __aeabi_fsub
   \       0x54   0x6430             STR      R0,[R6, #+64]
   8828              LOOP_XYZ(i) endstop_adj[i] -= z_temp;
   \       0x56   0x2600             MOVS     R6,#+0
   \       0x58   0xE007             B.N      ??gcode_M666_7
   \                     ??gcode_M666_8: (+1)
   \       0x5A   0xF855 0x0026      LDR      R0,[R5, R6, LSL #+2]
   \       0x5E   0x4621             MOV      R1,R4
   \       0x60   0x.... 0x....      BL       __aeabi_fsub
   \       0x64   0xF845 0x0026      STR      R0,[R5, R6, LSL #+2]
   \       0x68   0x1C76             ADDS     R6,R6,#+1
   \                     ??gcode_M666_7: (+1)
   \       0x6A   0x2E03             CMP      R6,#+3
   \       0x6C   0xDBF5             BLT.N    ??gcode_M666_8
   8829            }
   \       0x6E   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??gcode_M666_0:
   \       0x70   0x....'....        DC32     endstop_adj
   \       0x74   0x....'....        DC32     axis_codes
   \       0x78   0x....'....        DC32     mks_heating_busy
   8830          
   8831          #elif ENABLED(Z_DUAL_ENDSTOPS) // !DELTA && ENABLED(Z_DUAL_ENDSTOPS)
   8832          
   8833            /**
   8834             * M666: For Z Dual Endstop setup, set z axis offset to the z2 axis.
   8835             */
   8836            inline void gcode_M666() {
   8837              if (code_seen('Z')) z_endstop_adj = code_value_linear_units();
   8838              SERIAL_ECHOLNPAIR("Z Endstop Adjustment set to (mm):", z_endstop_adj);
   8839            }
   8840          
   8841          #endif // !DELTA && Z_DUAL_ENDSTOPS
   8842          
   8843          #if ENABLED(FWRETRACT)
   8844          
   8845            /**
   8846             * M207: Set firmware retraction values
   8847             *
   8848             *   S[+units]    retract_length
   8849             *   W[+units]    retract_length_swap (multi-extruder)
   8850             *   F[units/min] retract_feedrate_mm_s
   8851             *   Z[units]     retract_zlift
   8852             */
   8853            inline void gcode_M207() {
   8854              if (code_seen('S')) retract_length = code_value_axis_units(E_AXIS);
   8855              if (code_seen('F')) retract_feedrate_mm_s = MMM_TO_MMS(code_value_axis_units(E_AXIS));
   8856              if (code_seen('Z')) retract_zlift = code_value_linear_units();
   8857              #if EXTRUDERS > 1
   8858                if (code_seen('W')) retract_length_swap = code_value_axis_units(E_AXIS);
   8859              #endif
   8860            }
   8861          
   8862            /**
   8863             * M208: Set firmware un-retraction values
   8864             *
   8865             *   S[+units]    retract_recover_length (in addition to M207 S*)
   8866             *   W[+units]    retract_recover_length_swap (multi-extruder)
   8867             *   F[units/min] retract_recover_feedrate_mm_s
   8868             */
   8869            inline void gcode_M208() {
   8870              if (code_seen('S')) retract_recover_length = code_value_axis_units(E_AXIS);
   8871              if (code_seen('F')) retract_recover_feedrate_mm_s = MMM_TO_MMS(code_value_axis_units(E_AXIS));
   8872              #if EXTRUDERS > 1
   8873                if (code_seen('W')) retract_recover_length_swap = code_value_axis_units(E_AXIS);
   8874              #endif
   8875            }
   8876          
   8877            /**
   8878             * M209: Enable automatic retract (M209 S1)
   8879             *   For slicers that don't support G10/11, reversed extrude-only
   8880             *   moves will be classified as retraction.
   8881             */
   8882            inline void gcode_M209() {
   8883              if (code_seen('S')) {
   8884                autoretract_enabled = code_value_bool();
   8885                for (int i = 0; i < EXTRUDERS; i++) retracted[i] = false;
   8886              }
   8887            }
   8888          
   8889          #endif // FWRETRACT
   8890          
   8891          /**
   8892           * M211: Enable, Disable, and/or Report software endstops
   8893           *
   8894           * Usage: M211 S1 to enable, M211 S0 to disable, M211 alone for report
   8895           */

   \                                 In section .text, align 4
   8896          inline void gcode_M211() {
   \                     _Z10gcode_M211v: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   8897            SERIAL_ECHO_START;
   \        0x2   0x4824             LDR.N    R0,??gcode_M211_0
   \        0x4   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8898            #if HAS_SOFTWARE_ENDSTOPS
   8899              if (code_seen('S')) soft_endstops_enabled = code_value_bool();
   \        0x8   0x4C23             LDR.N    R4,??gcode_M211_0+0x4
   \        0xA   0x2053             MOVS     R0,#+83
   \        0xC   0x.... 0x....      BL       _Z9code_seenc
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD002             BEQ.N    ??gcode_M211_1
   \       0x14   0x.... 0x....      BL       _Z15code_value_boolv
   \       0x18   0x7020             STRB     R0,[R4, #+0]
   8900              SERIAL_ECHOPGM(MSG_SOFT_ENDSTOPS);
   \                     ??gcode_M211_1: (+1)
   \       0x1A   0x4820             LDR.N    R0,??gcode_M211_0+0x8
   \       0x1C   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8901              serialprintPGM(soft_endstops_enabled ? PSTR(MSG_ON) : PSTR(MSG_OFF));
   \       0x20   0x7820             LDRB     R0,[R4, #+0]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD001             BEQ.N    ??gcode_M211_2
   \       0x26   0x481E             LDR.N    R0,??gcode_M211_0+0xC
   \       0x28   0xE000             B.N      ??gcode_M211_3
   \                     ??gcode_M211_2: (+1)
   \       0x2A   0x481E             LDR.N    R0,??gcode_M211_0+0x10
   \                     ??gcode_M211_3: (+1)
   \       0x2C   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8902            #else
   8903              SERIAL_ECHOPGM(MSG_SOFT_ENDSTOPS);
   8904              SERIAL_ECHOPGM(MSG_OFF);
   8905            #endif
   8906            SERIAL_ECHOPGM(MSG_SOFT_MIN);
   \       0x30   0x481D             LDR.N    R0,??gcode_M211_0+0x14
   \       0x32   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8907            SERIAL_ECHOPAIR(    MSG_X, soft_endstop_min[X_AXIS]);
   \       0x36   0x4C1D             LDR.N    R4,??gcode_M211_0+0x18
   \       0x38   0x4D1D             LDR.N    R5,??gcode_M211_0+0x1C
   \       0x3A   0x6D29             LDR      R1,[R5, #+80]
   \       0x3C   0x4620             MOV      R0,R4
   \       0x3E   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   8908            SERIAL_ECHOPAIR(" " MSG_Y, soft_endstop_min[Y_AXIS]);
   \       0x42   0x4E1C             LDR.N    R6,??gcode_M211_0+0x20
   \       0x44   0x6D69             LDR      R1,[R5, #+84]
   \       0x46   0x4630             MOV      R0,R6
   \       0x48   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   8909            SERIAL_ECHOPAIR(" " MSG_Z, soft_endstop_min[Z_AXIS]);
   \       0x4C   0x4F1A             LDR.N    R7,??gcode_M211_0+0x24
   \       0x4E   0x6DA9             LDR      R1,[R5, #+88]
   \       0x50   0x4638             MOV      R0,R7
   \       0x52   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   8910            SERIAL_ECHOPGM(MSG_SOFT_MAX);
   \       0x56   0x4819             LDR.N    R0,??gcode_M211_0+0x28
   \       0x58   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8911            SERIAL_ECHOPAIR(    MSG_X, soft_endstop_max[X_AXIS]);
   \       0x5C   0x6DE9             LDR      R1,[R5, #+92]
   \       0x5E   0x4620             MOV      R0,R4
   \       0x60   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   8912            SERIAL_ECHOPAIR(" " MSG_Y, soft_endstop_max[Y_AXIS]);
   \       0x64   0x6E29             LDR      R1,[R5, #+96]
   \       0x66   0x4630             MOV      R0,R6
   \       0x68   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   8913            SERIAL_ECHOLNPAIR(" " MSG_Z, soft_endstop_max[Z_AXIS]);
   \       0x6C   0x6E69             LDR      R1,[R5, #+100]
   \       0x6E   0x4638             MOV      R0,R7
   \       0x70   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \       0x74   0x79E8             LDRB     R0,[R5, #+7]
   \       0x76   0x2800             CMP      R0,#+0
   \       0x78   0xD105             BNE.N    ??gcode_M211_4
   \       0x7A   0x210A             MOVS     R1,#+10
   \       0x7C   0x4810             LDR.N    R0,??gcode_M211_0+0x2C
   \       0x7E   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \       0x82   0x.... 0x....      B.W      _ZN12MarlinSerial5writeEh
   \                     ??gcode_M211_4: (+1)
   \       0x86   0x2200             MOVS     R2,#+0
   \       0x88   0x210A             MOVS     R1,#+10
   \       0x8A   0x480E             LDR.N    R0,??gcode_M211_0+0x30
   \       0x8C   0xE8BD 0x40F8      POP      {R3-R7,LR}
   \       0x90   0x.... 0x....      B.W      _ZN12MarlinSerial5printEci
   \                     ??gcode_M211_0:
   \       0x94   0x....'....        DC32     echomagic
   \       0x98   0x....'....        DC32     soft_endstops_enabled
   \       0x9C   0x....'....        DC32     _ZZ10gcode_M211vEs
   \       0xA0   0x....'....        DC32     MSG_ON
   \       0xA4   0x....'....        DC32     MSG_OFF
   \       0xA8   0x....'....        DC32     _ZZ10gcode_M211vEs_0
   \       0xAC   0x....'....        DC32     _ZZ10gcode_M211vEs_1
   \       0xB0   0x....'....        DC32     mks_heating_busy
   \       0xB4   0x....'....        DC32     _ZZ10gcode_M211vEs_2
   \       0xB8   0x....'....        DC32     _ZZ10gcode_M211vEs_3
   \       0xBC   0x....'....        DC32     _ZZ10gcode_M211vEs_4
   \       0xC0   0x....'....        DC32     customizedSerial
   \       0xC4   0x....'....        DC32     serial2
   8914          }
   8915          
   8916          #if HOTENDS > 1
   8917          
   8918            /**
   8919             * M218 - set hotend offset (in linear units)
   8920             *
   8921             *   T<tool>
   8922             *   X<xoffset>
   8923             *   Y<yoffset>
   8924             *   Z<zoffset> - Available with DUAL_X_CARRIAGE and SWITCHING_EXTRUDER
   8925             */
   8926            inline void gcode_M218() {
   8927              if (get_target_extruder_from_command(218) || target_extruder == 0) return;
   8928          
   8929              if (code_seen('X')) hotend_offset[X_AXIS][target_extruder] = code_value_linear_units();
   8930              if (code_seen('Y')) hotend_offset[Y_AXIS][target_extruder] = code_value_linear_units();
   8931          
   8932              #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(SWITCHING_EXTRUDER)
   8933                if (code_seen('Z')) hotend_offset[Z_AXIS][target_extruder] = code_value_linear_units();
   8934              #endif
   8935          
   8936              SERIAL_ECHO_START;
   8937              SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
   8938              HOTEND_LOOP() {
   8939                SERIAL_CHAR(' ');
   8940                SERIAL_ECHO(hotend_offset[X_AXIS][e]);
   8941                SERIAL_CHAR(',');
   8942                SERIAL_ECHO(hotend_offset[Y_AXIS][e]);
   8943                #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(SWITCHING_EXTRUDER)
   8944                  SERIAL_CHAR(',');
   8945                  SERIAL_ECHO(hotend_offset[Z_AXIS][e]);
   8946                #endif
   8947              }
   8948              SERIAL_EOL;
   8949            }
   8950          
   8951          #endif // HOTENDS > 1
   8952          
   8953          /**
   8954           * M220: Set speed percentage factor, aka "Feed Rate" (M220 S95)
   8955           */

   \                                 In section .text, align 4
   8956          inline void gcode_M220() {
   \                     _Z10gcode_M220v: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   8957            if (code_seen('S')) feedrate_percentage = code_value_int();
   \        0x2   0x2053             MOVS     R0,#+83
   \        0x4   0x.... 0x....      BL       _Z9code_seenc
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD003             BEQ.N    ??gcode_M220_1
   \        0xC   0x.... 0x....      BL       _Z14code_value_intv
   \       0x10   0x4901             LDR.N    R1,??gcode_M220_0
   \       0x12   0x6788             STR      R0,[R1, #+120]
   8958          }
   \                     ??gcode_M220_1: (+1)
   \       0x14   0xBD01             POP      {R0,PC}          ;; return
   \       0x16   0xBF00             Nop      
   \                     ??gcode_M220_0:
   \       0x18   0x....'....        DC32     mks_heating_busy
   8959          
   8960          /**
   8961           * M221: Set extrusion percentage (M221 T0 S95)
   8962           */

   \                                 In section .text, align 4
   8963          inline void gcode_M221() {
   \                     _Z10gcode_M221v: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   8964            if (get_target_extruder_from_command(221)) return;
   \        0x2   0x20DD             MOVS     R0,#+221
   \        0x4   0x.... 0x....      BL       _Z32get_target_extruder_from_commandi
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD10B             BNE.N    ??gcode_M221_1
   8965            if (code_seen('S'))
   \        0xC   0x2053             MOVS     R0,#+83
   \        0xE   0x.... 0x....      BL       _Z9code_seenc
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD006             BEQ.N    ??gcode_M221_1
   8966              flow_percentage[target_extruder] = code_value_int();
   \       0x16   0x.... 0x....      BL       _Z14code_value_intv
   \       0x1A   0x4903             LDR.N    R1,??gcode_M221_0
   \       0x1C   0x4A03             LDR.N    R2,??gcode_M221_0+0x4
   \       0x1E   0x7952             LDRB     R2,[R2, #+5]
   \       0x20   0xF841 0x0022      STR      R0,[R1, R2, LSL #+2]
   8967          }
   \                     ??gcode_M221_1: (+1)
   \       0x24   0xBD01             POP      {R0,PC}          ;; return
   \       0x26   0xBF00             Nop      
   \                     ??gcode_M221_0:
   \       0x28   0x....'....        DC32     flow_percentage
   \       0x2C   0x....'....        DC32     mks_heating_busy
   8968          
   8969          /**
   8970           * M226: Wait until the specified pin reaches the state required (M226 P<pin> S<state>)
   8971           */

   \                                 In section .text, align 4
   8972          inline void gcode_M226() {
   \                     _Z10gcode_M226v: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   8973            if (code_seen('P')) {
   \        0x2   0x2050             MOVS     R0,#+80
   \        0x4   0x.... 0x....      BL       _Z9code_seenc
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD044             BEQ.N    ??gcode_M226_1
   8974              int pin_number = code_value_int(),
   \        0xC   0x.... 0x....      BL       _Z14code_value_intv
   \       0x10   0x4604             MOV      R4,R0
   8975                  pin_state = code_seen('S') ? code_value_int() : -1; // required pin state - default is inverted
   \       0x12   0x2053             MOVS     R0,#+83
   \       0x14   0x.... 0x....      BL       _Z9code_seenc
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD003             BEQ.N    ??gcode_M226_2
   \       0x1C   0x.... 0x....      BL       _Z14code_value_intv
   \       0x20   0x4605             MOV      R5,R0
   \       0x22   0xE001             B.N      ??gcode_M226_3
   \                     ??gcode_M226_2: (+1)
   \       0x24   0xF04F 0x35FF      MOV      R5,#-1
   8976          
   8977              if (pin_state >= -1 && pin_state <= 1 && pin_number > -1 && !pin_is_protected(pin_number)) {
   \                     ??gcode_M226_3: (+1)
   \       0x28   0x1C68             ADDS     R0,R5,#+1
   \       0x2A   0x2803             CMP      R0,#+3
   \       0x2C   0xD233             BCS.N    ??gcode_M226_1
   \       0x2E   0x2C00             CMP      R4,#+0
   \       0x30   0xD431             BMI.N    ??gcode_M226_1
   \       0x32   0x4620             MOV      R0,R4
   \       0x34   0xB2C0             UXTB     R0,R0
   \       0x36   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531916pin_is_protectedEh
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD12B             BNE.N    ??gcode_M226_1
   8978          
   8979                int target = LOW;
   \       0x3E   0x2600             MOVS     R6,#+0
   8980          
   8981                stepper.synchronize();
   \       0x40   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   8982          
   8983                pinMode(pin_number, INPUT);
   8984                switch (pin_state) {
   \       0x44   0x2D01             CMP      R5,#+1
   \       0x46   0xD003             BEQ.N    ??gcode_M226_4
   \       0x48   0xF1B5 0x3FFF      CMP      R5,#-1
   \       0x4C   0xD002             BEQ.N    ??gcode_M226_5
   \       0x4E   0xE010             B.N      ??gcode_M226_6
   8985                  case 1:
   8986                    target = HIGH;
   \                     ??gcode_M226_4: (+1)
   \       0x50   0x2601             MOVS     R6,#+1
   8987                    break;
   \       0x52   0xE00E             B.N      ??gcode_M226_6
   8988                  case 0:
   8989                    target = LOW;
   8990                    break;
   8991                  case -1:
   8992                    target = !digitalRead(pin_number);
   \                     ??gcode_M226_5: (+1)
   \       0x54   0x2C00             CMP      R4,#+0
   \       0x56   0xD50C             BPL.N    ??gcode_M226_6
   \       0x58   0x480F             LDR.N    R0,??gcode_M226_0
   \       0x5A   0xF830 0x1014      LDRH     R1,[R0, R4, LSL #+1]
   \       0x5E   0x480F             LDR.N    R0,??gcode_M226_0+0x4
   \       0x60   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \       0x64   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \       0x68   0x4606             MOV      R6,R0
   \       0x6A   0xE002             B.N      ??gcode_M226_6
   8993                    break;
   8994                }
   8995          
   8996                while (digitalRead(pin_number) != target) idle();
   \                     ??gcode_M226_7: (+1)
   \       0x6C   0x2000             MOVS     R0,#+0
   \       0x6E   0x.... 0x....      BL       _Z4idleb
   \                     ??gcode_M226_6: (+1)
   \       0x72   0x2C00             CMP      R4,#+0
   \       0x74   0xD408             BMI.N    ??gcode_M226_8
   \       0x76   0x4808             LDR.N    R0,??gcode_M226_0
   \       0x78   0xF830 0x1014      LDRH     R1,[R0, R4, LSL #+1]
   \       0x7C   0x4807             LDR.N    R0,??gcode_M226_0+0x4
   \       0x7E   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \       0x82   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \       0x86   0xE004             B.N      ??gcode_M226_9
   \                     ??gcode_M226_8: (+1)
   \       0x88   0x4630             MOV      R0,R6
   \       0x8A   0x1E40             SUBS     R0,R0,#+1
   \       0x8C   0x4180             SBCS     R0,R0,R0
   \       0x8E   0x43C0             MVNS     R0,R0
   \       0x90   0x0FC0             LSRS     R0,R0,#+31
   \                     ??gcode_M226_9: (+1)
   \       0x92   0x2800             CMP      R0,#+0
   \       0x94   0xD1EA             BNE.N    ??gcode_M226_7
   8997          
   8998              } // pin_state -1 0 1 && pin_number > -1
   8999            } // code_seen('P')
   9000          }
   \                     ??gcode_M226_1: (+1)
   \       0x96   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??gcode_M226_0:
   \       0x98   0x....'....        DC32     gArrayGpioPin
   \       0x9C   0x....'....        DC32     gArrayGpioPort
   9001          
   9002          #if ENABLED(EXPERIMENTAL_I2CBUS)
   9003          
   9004            /**
   9005             * M260: Send data to a I2C slave device
   9006             *
   9007             * This is a PoC, the formating and arguments for the GCODE will
   9008             * change to be more compatible, the current proposal is:
   9009             *
   9010             *  M260 A<slave device address base 10> ; Sets the I2C slave address the data will be sent to
   9011             *
   9012             *  M260 B<byte-1 value in base 10>
   9013             *  M260 B<byte-2 value in base 10>
   9014             *  M260 B<byte-3 value in base 10>
   9015             *
   9016             *  M260 S1 ; Send the buffered data and reset the buffer
   9017             *  M260 R1 ; Reset the buffer without sending data
   9018             *
   9019             */
   9020            inline void gcode_M260() {
   9021              // Set the target address
   9022              if (code_seen('A')) i2c.address(code_value_byte());
   9023          
   9024              // Add a new byte to the buffer
   9025              if (code_seen('B')) i2c.addbyte(code_value_byte());
   9026          
   9027              // Flush the buffer to the bus
   9028              if (code_seen('S')) i2c.send();
   9029          
   9030              // Reset and rewind the buffer
   9031              else if (code_seen('R')) i2c.reset();
   9032            }
   9033          
   9034            /**
   9035             * M261: Request X bytes from I2C slave device
   9036             *
   9037             * Usage: M261 A<slave device address base 10> B<number of bytes>
   9038             */
   9039            inline void gcode_M261() {
   9040              if (code_seen('A')) i2c.address(code_value_byte());
   9041          
   9042              uint8_t bytes = code_seen('B') ? code_value_byte() : 1;
   9043          
   9044              if (i2c.addr && bytes && bytes <= TWIBUS_BUFFER_SIZE) {
   9045                i2c.relay(bytes);
   9046              }
   9047              else {
   9048                SERIAL_ERROR_START;
   9049                SERIAL_ERRORLN("Bad i2c request");
   9050              }
   9051            }
   9052          
   9053          #endif // EXPERIMENTAL_I2CBUS
   9054          
   9055          #if HAS_SERVOS
   9056          
   9057            /**
   9058             * M280: Get or set servo position. P<index> [S<angle>]
   9059             */
   9060            inline void gcode_M280() {
   9061              if (!code_seen('P')) return;
   9062              int servo_index = code_value_int();
   9063              if (WITHIN(servo_index, 0, NUM_SERVOS - 1)) {
   9064                if (code_seen('S'))
   9065                  MOVE_SERVO(servo_index, code_value_int());
   9066                else {
   9067                  SERIAL_ECHO_START;
   9068                  SERIAL_ECHOPAIR(" Servo ", servo_index);
   9069                  SERIAL_ECHOLNPAIR(": ", servo[servo_index].read());
   9070                }
   9071              }
   9072              else {
   9073                SERIAL_ERROR_START;
   9074                SERIAL_ECHOPAIR("Servo ", servo_index);
   9075                SERIAL_ECHOLNPGM(" out of range");
   9076              }
   9077            }
   9078          
   9079          #endif // HAS_SERVOS
   9080          
   9081          #if HAS_BUZZER
   9082          //abc
   9083            /**
   9084             * M300: Play beep sound S<frequency Hz> P<duration ms>
   9085             */

   \                                 In section .text, align 4
   9086            inline void gcode_M300() {
   \                     _Z10gcode_M300v: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   9087              uint16_t const frequency = code_seen('S') ? code_value_ushort() : 260;
   \        0x2   0x2053             MOVS     R0,#+83
   \        0x4   0x.... 0x....      BL       _Z9code_seenc
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD002             BEQ.N    ??gcode_M300_1
   \        0xC   0x.... 0x....      BL       _Z17code_value_ushortv
   \       0x10   0xE001             B.N      ??gcode_M300_2
   \                     ??gcode_M300_1: (+1)
   \       0x12   0xF44F 0x7082      MOV      R0,#+260
   \                     ??gcode_M300_2: (+1)
   \       0x16   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   9088              uint16_t duration = code_seen('P') ? code_value_ushort() : 1000;
   \       0x1A   0x2050             MOVS     R0,#+80
   \       0x1C   0x.... 0x....      BL       _Z9code_seenc
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD002             BEQ.N    ??gcode_M300_3
   \       0x24   0x.... 0x....      BL       _Z17code_value_ushortv
   \       0x28   0xE001             B.N      ??gcode_M300_4
   \                     ??gcode_M300_3: (+1)
   \       0x2A   0xF44F 0x707A      MOV      R0,#+1000
   \                     ??gcode_M300_4: (+1)
   \       0x2E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   9089          
   9090              // Limits the tone duration to 0-5 seconds.
   9091              NOMORE(duration, 5000);
   \       0x32   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \       0x36   0xF241 0x3189      MOVW     R1,#+5001
   \       0x3A   0x4288             CMP      R0,R1
   \       0x3C   0xDB03             BLT.N    ??gcode_M300_5
   \       0x3E   0xF241 0x3088      MOVW     R0,#+5000
   \       0x42   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   9092          
   9093              BUZZ(duration, frequency);
   \                     ??gcode_M300_5: (+1)
   \       0x46   0xF10D 0x0202      ADD      R2,SP,#+2
   \       0x4A   0x4669             MOV      R1,SP
   \       0x4C   0x4801             LDR.N    R0,??gcode_M300_0
   \       0x4E   0x.... 0x....      BL       _ZN6Buzzer4toneERKtS1_
   9094          	
   9095            }
   \       0x52   0xBD01             POP      {R0,PC}          ;; return
   \                     ??gcode_M300_0:
   \       0x54   0x....'....        DC32     mks_heating_busy+0x398
   9096          
   9097          #endif // HAS_BUZZER
   9098          
   9099          //#if ENABLED(PIDTEMP)	/*--mks cfg--*/
   9100          #if 1
   9101            /**
   9102             * M301: Set PID parameters P I D (and optionally C, L)
   9103             *
   9104             *   P[float] Kp term
   9105             *   I[float] Ki term (unscaled)
   9106             *   D[float] Kd term (unscaled)
   9107             *
   9108             * With PID_EXTRUSION_SCALING:
   9109             *
   9110             *   C[float] Kc term
   9111             *   L[float] LPQ length
   9112             */

   \                                 In section .text, align 4
   9113            inline void gcode_M301() {
   \                     _Z10gcode_M301v: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   9114          
   9115              // multi-extruder PID patch: M301 updates or prints a single extruder's PID values
   9116              // default behaviour (omitting E parameter) is to update for extruder 0 only
   9117              int e = code_seen('E') ? code_value_int() : 0; // extruder being updated
   \        0x2   0x2045             MOVS     R0,#+69
   \        0x4   0x.... 0x....      BL       _Z9code_seenc
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD002             BEQ.N    ??gcode_M301_1
   \        0xC   0x.... 0x....      BL       _Z14code_value_intv
   \       0x10   0xE000             B.N      ??gcode_M301_2
   \                     ??gcode_M301_1: (+1)
   \       0x12   0x2000             MOVS     R0,#+0
   9118          
   9119              if (e < HOTENDS) { // catch bad input value
   \                     ??gcode_M301_2: (+1)
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xDC5E             BGT.N    ??gcode_M301_3
   9120                if (code_seen('P')) PID_PARAM(Kp, e) = code_value_float();
   \       0x18   0x2050             MOVS     R0,#+80
   \       0x1A   0x.... 0x....      BL       _Z9code_seenc
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD003             BEQ.N    ??gcode_M301_4
   \       0x22   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x26   0x493B             LDR.N    R1,??gcode_M301_0
   \       0x28   0x6008             STR      R0,[R1, #+0]
   9121                if (code_seen('I')) PID_PARAM(Ki, e) = scalePID_i(code_value_float());
   \                     ??gcode_M301_4: (+1)
   \       0x2A   0x2049             MOVS     R0,#+73
   \       0x2C   0x.... 0x....      BL       _Z9code_seenc
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD00B             BEQ.N    ??gcode_M301_5
   \       0x34   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x38   0x.... 0x....      BL       __aeabi_f2d
   \       0x3C   0x4A36             LDR.N    R2,??gcode_M301_0+0x4  ;; 0x88e368f1
   \       0x3E   0x4B37             LDR.N    R3,??gcode_M301_0+0x8  ;; 0x3fc4f8b5
   \       0x40   0x.... 0x....      BL       __aeabi_dmul
   \       0x44   0x.... 0x....      BL       __aeabi_d2f
   \       0x48   0x4935             LDR.N    R1,??gcode_M301_0+0xC
   \       0x4A   0x6008             STR      R0,[R1, #+0]
   9122                if (code_seen('D')) PID_PARAM(Kd, e) = scalePID_d(code_value_float());
   \                     ??gcode_M301_5: (+1)
   \       0x4C   0x4C35             LDR.N    R4,??gcode_M301_0+0x10
   \       0x4E   0x2044             MOVS     R0,#+68
   \       0x50   0x.... 0x....      BL       _Z9code_seenc
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD00A             BEQ.N    ??gcode_M301_6
   \       0x58   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x5C   0x.... 0x....      BL       __aeabi_f2d
   \       0x60   0x4A2D             LDR.N    R2,??gcode_M301_0+0x4  ;; 0x88e368f1
   \       0x62   0x4B2E             LDR.N    R3,??gcode_M301_0+0x8  ;; 0x3fc4f8b5
   \       0x64   0x.... 0x....      BL       __aeabi_ddiv
   \       0x68   0x.... 0x....      BL       __aeabi_d2f
   \       0x6C   0x6020             STR      R0,[R4, #+0]
   9123                #if ENABLED(PID_EXTRUSION_SCALING)
   9124                  if (code_seen('C')) PID_PARAM(Kc, e) = code_value_float();
   9125                  if (code_seen('L')) lpq_len = code_value_float();
   9126                  NOMORE(lpq_len, LPQ_MAX_LEN);
   9127                #endif
   9128          
   9129                thermalManager.updatePID();
   \                     ??gcode_M301_6: (+1)
   \       0x6E   0x.... 0x....      BL       _ZN11Temperature9updatePIDEv
   9130                SERIAL_ECHO_START;
   \       0x72   0x482D             LDR.N    R0,??gcode_M301_0+0x14
   \       0x74   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9131                #if ENABLED(PID_PARAMS_PER_HOTEND)
   9132                  SERIAL_ECHOPAIR(" e:", e); // specify extruder in serial output
   9133                #endif // PID_PARAMS_PER_HOTEND
   9134                SERIAL_ECHOPAIR(" p:", PID_PARAM(Kp, e));
   \       0x78   0x4826             LDR.N    R0,??gcode_M301_0
   \       0x7A   0x6801             LDR      R1,[R0, #+0]
   \       0x7C   0x482B             LDR.N    R0,??gcode_M301_0+0x18
   \       0x7E   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   9135                SERIAL_ECHOPAIR(" i:", unscalePID_i(PID_PARAM(Ki, e)));
   \       0x82   0x4827             LDR.N    R0,??gcode_M301_0+0xC
   \       0x84   0x6800             LDR      R0,[R0, #+0]
   \       0x86   0x.... 0x....      BL       __aeabi_f2d
   \       0x8A   0x4A23             LDR.N    R2,??gcode_M301_0+0x4  ;; 0x88e368f1
   \       0x8C   0x4B23             LDR.N    R3,??gcode_M301_0+0x8  ;; 0x3fc4f8b5
   \       0x8E   0x.... 0x....      BL       __aeabi_ddiv
   \       0x92   0x4602             MOV      R2,R0
   \       0x94   0x460B             MOV      R3,R1
   \       0x96   0x4826             LDR.N    R0,??gcode_M301_0+0x1C
   \       0x98   0x.... 0x....      BL       _Z17serial_echopair_PPKcd
   9136                SERIAL_ECHOPAIR(" d:", unscalePID_d(PID_PARAM(Kd, e)));
   \       0x9C   0x6820             LDR      R0,[R4, #+0]
   \       0x9E   0x.... 0x....      BL       __aeabi_f2d
   \       0xA2   0x4A1D             LDR.N    R2,??gcode_M301_0+0x4  ;; 0x88e368f1
   \       0xA4   0x4B1D             LDR.N    R3,??gcode_M301_0+0x8  ;; 0x3fc4f8b5
   \       0xA6   0x.... 0x....      BL       __aeabi_dmul
   \       0xAA   0x4602             MOV      R2,R0
   \       0xAC   0x460B             MOV      R3,R1
   \       0xAE   0x4821             LDR.N    R0,??gcode_M301_0+0x20
   \       0xB0   0x.... 0x....      BL       _Z17serial_echopair_PPKcd
   9137                #if ENABLED(PID_EXTRUSION_SCALING)
   9138                  //Kc does not have scaling applied above, or in resetting defaults
   9139                  SERIAL_ECHOPAIR(" c:", PID_PARAM(Kc, e));
   9140                #endif
   9141                SERIAL_EOL;
   \       0xB4   0x4820             LDR.N    R0,??gcode_M301_0+0x24
   \       0xB6   0x79C0             LDRB     R0,[R0, #+7]
   \       0xB8   0x2800             CMP      R0,#+0
   \       0xBA   0xD105             BNE.N    ??gcode_M301_7
   \       0xBC   0x210A             MOVS     R1,#+10
   \       0xBE   0x481F             LDR.N    R0,??gcode_M301_0+0x28
   \       0xC0   0xE8BD 0x4010      POP      {R4,LR}
   \       0xC4   0x.... 0x....      B.W      _ZN12MarlinSerial5writeEh
   \                     ??gcode_M301_7: (+1)
   \       0xC8   0x2200             MOVS     R2,#+0
   \       0xCA   0x210A             MOVS     R1,#+10
   \       0xCC   0x481C             LDR.N    R0,??gcode_M301_0+0x2C
   \       0xCE   0xE8BD 0x4010      POP      {R4,LR}
   \       0xD2   0x.... 0x....      B.W      _ZN12MarlinSerial5printEci
   9142              }
   9143              else {
   9144                SERIAL_ERROR_START;
   \                     ??gcode_M301_3: (+1)
   \       0xD6   0x481B             LDR.N    R0,??gcode_M301_0+0x30
   \       0xD8   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9145                SERIAL_ERRORLN(MSG_INVALID_EXTRUDER);
   \       0xDC   0x491A             LDR.N    R1,??gcode_M301_0+0x34
   \       0xDE   0x4C16             LDR.N    R4,??gcode_M301_0+0x24
   \       0xE0   0x79E0             LDRB     R0,[R4, #+7]
   \       0xE2   0x2800             CMP      R0,#+0
   \       0xE4   0xD103             BNE.N    ??gcode_M301_8
   \       0xE6   0x4815             LDR.N    R0,??gcode_M301_0+0x28
   \       0xE8   0x.... 0x....      BL       _ZN12MarlinSerial5printEPKc
   \       0xEC   0xE002             B.N      ??gcode_M301_9
   \                     ??gcode_M301_8: (+1)
   \       0xEE   0x4814             LDR.N    R0,??gcode_M301_0+0x2C
   \       0xF0   0x.... 0x....      BL       _ZN12MarlinSerial5printEPKc
   \                     ??gcode_M301_9: (+1)
   \       0xF4   0x79E0             LDRB     R0,[R4, #+7]
   \       0xF6   0x2800             CMP      R0,#+0
   \       0xF8   0xD105             BNE.N    ??gcode_M301_10
   \       0xFA   0x210A             MOVS     R1,#+10
   \       0xFC   0x480F             LDR.N    R0,??gcode_M301_0+0x28
   \       0xFE   0xE8BD 0x4010      POP      {R4,LR}
   \      0x102   0x.... 0x....      B.W      _ZN12MarlinSerial5writeEh
   \                     ??gcode_M301_10: (+1)
   \      0x106   0x2200             MOVS     R2,#+0
   \      0x108   0x210A             MOVS     R1,#+10
   \      0x10A   0x480D             LDR.N    R0,??gcode_M301_0+0x2C
   \      0x10C   0xE8BD 0x4010      POP      {R4,LR}
   \      0x110   0x.... 0x....      B.W      _ZN12MarlinSerial5printEci
   \                     ??gcode_M301_0:
   \      0x114   0x....'....        DC32     _ZN11Temperature2KpE
   \      0x118   0x88E3'68F1        DC32     0x88e368f1
   \      0x11C   0x3FC4'F8B5        DC32     0x3fc4f8b5
   \      0x120   0x....'....        DC32     _ZN11Temperature2KiE
   \      0x124   0x....'....        DC32     _ZN11Temperature2KdE
   \      0x128   0x....'....        DC32     echomagic
   \      0x12C   0x....'....        DC32     _ZZ10gcode_M301vEs
   \      0x130   0x....'....        DC32     _ZZ10gcode_M301vEs_0
   \      0x134   0x....'....        DC32     _ZZ10gcode_M301vEs_1
   \      0x138   0x....'....        DC32     mks_heating_busy
   \      0x13C   0x....'....        DC32     customizedSerial
   \      0x140   0x....'....        DC32     serial2
   \      0x144   0x....'....        DC32     errormagic
   \      0x148   0x....'....        DC32     _ZZ10gcode_M301vEs_2
   9146              }
   9147            }
   9148          
   9149          #endif // PIDTEMP
   9150          
   9151          //#if ENABLED(PIDTEMPBED)	/*--mks cfg--*/
   9152          #if 1

   \                                 In section .text, align 4
   9153            inline void gcode_M304() {
   \                     _Z10gcode_M304v: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   9154              if (code_seen('P')) thermalManager.bedKp = code_value_float();
   \        0x2   0x2050             MOVS     R0,#+80
   \        0x4   0x.... 0x....      BL       _Z9code_seenc
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD003             BEQ.N    ??gcode_M304_1
   \        0xC   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x10   0x492B             LDR.N    R1,??gcode_M304_0
   \       0x12   0x6008             STR      R0,[R1, #+0]
   9155              if (code_seen('I')) thermalManager.bedKi = scalePID_i(code_value_float());
   \                     ??gcode_M304_1: (+1)
   \       0x14   0x2049             MOVS     R0,#+73
   \       0x16   0x.... 0x....      BL       _Z9code_seenc
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD00B             BEQ.N    ??gcode_M304_2
   \       0x1E   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x22   0x.... 0x....      BL       __aeabi_f2d
   \       0x26   0x4A27             LDR.N    R2,??gcode_M304_0+0x4  ;; 0x88e368f1
   \       0x28   0x4B27             LDR.N    R3,??gcode_M304_0+0x8  ;; 0x3fc4f8b5
   \       0x2A   0x.... 0x....      BL       __aeabi_dmul
   \       0x2E   0x.... 0x....      BL       __aeabi_d2f
   \       0x32   0x4926             LDR.N    R1,??gcode_M304_0+0xC
   \       0x34   0x6008             STR      R0,[R1, #+0]
   9156              if (code_seen('D')) thermalManager.bedKd = scalePID_d(code_value_float());
   \                     ??gcode_M304_2: (+1)
   \       0x36   0x4C26             LDR.N    R4,??gcode_M304_0+0x10
   \       0x38   0x2044             MOVS     R0,#+68
   \       0x3A   0x.... 0x....      BL       _Z9code_seenc
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD00A             BEQ.N    ??gcode_M304_3
   \       0x42   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x46   0x.... 0x....      BL       __aeabi_f2d
   \       0x4A   0x4A1E             LDR.N    R2,??gcode_M304_0+0x4  ;; 0x88e368f1
   \       0x4C   0x4B1E             LDR.N    R3,??gcode_M304_0+0x8  ;; 0x3fc4f8b5
   \       0x4E   0x.... 0x....      BL       __aeabi_ddiv
   \       0x52   0x.... 0x....      BL       __aeabi_d2f
   \       0x56   0x6020             STR      R0,[R4, #+0]
   9157          
   9158              thermalManager.updatePID();
   \                     ??gcode_M304_3: (+1)
   \       0x58   0x.... 0x....      BL       _ZN11Temperature9updatePIDEv
   9159          
   9160              SERIAL_ECHO_START;
   \       0x5C   0x481D             LDR.N    R0,??gcode_M304_0+0x14
   \       0x5E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9161              SERIAL_ECHOPAIR(" p:", thermalManager.bedKp);
   \       0x62   0x4817             LDR.N    R0,??gcode_M304_0
   \       0x64   0x6801             LDR      R1,[R0, #+0]
   \       0x66   0x481C             LDR.N    R0,??gcode_M304_0+0x18
   \       0x68   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   9162              SERIAL_ECHOPAIR(" i:", unscalePID_i(thermalManager.bedKi));
   \       0x6C   0x4817             LDR.N    R0,??gcode_M304_0+0xC
   \       0x6E   0x6800             LDR      R0,[R0, #+0]
   \       0x70   0x.... 0x....      BL       __aeabi_f2d
   \       0x74   0x4A13             LDR.N    R2,??gcode_M304_0+0x4  ;; 0x88e368f1
   \       0x76   0x4B14             LDR.N    R3,??gcode_M304_0+0x8  ;; 0x3fc4f8b5
   \       0x78   0x.... 0x....      BL       __aeabi_ddiv
   \       0x7C   0x4602             MOV      R2,R0
   \       0x7E   0x460B             MOV      R3,R1
   \       0x80   0x4816             LDR.N    R0,??gcode_M304_0+0x1C
   \       0x82   0x.... 0x....      BL       _Z17serial_echopair_PPKcd
   9163              SERIAL_ECHOLNPAIR(" d:", unscalePID_d(thermalManager.bedKd));
   \       0x86   0x6820             LDR      R0,[R4, #+0]
   \       0x88   0x.... 0x....      BL       __aeabi_f2d
   \       0x8C   0x4A0D             LDR.N    R2,??gcode_M304_0+0x4  ;; 0x88e368f1
   \       0x8E   0x4B0E             LDR.N    R3,??gcode_M304_0+0x8  ;; 0x3fc4f8b5
   \       0x90   0x.... 0x....      BL       __aeabi_dmul
   \       0x94   0x4602             MOV      R2,R0
   \       0x96   0x460B             MOV      R3,R1
   \       0x98   0x4811             LDR.N    R0,??gcode_M304_0+0x20
   \       0x9A   0x.... 0x....      BL       _Z17serial_echopair_PPKcd
   \       0x9E   0x4811             LDR.N    R0,??gcode_M304_0+0x24
   \       0xA0   0x79C0             LDRB     R0,[R0, #+7]
   \       0xA2   0x2800             CMP      R0,#+0
   \       0xA4   0xD105             BNE.N    ??gcode_M304_4
   \       0xA6   0x210A             MOVS     R1,#+10
   \       0xA8   0x480F             LDR.N    R0,??gcode_M304_0+0x28
   \       0xAA   0xE8BD 0x4010      POP      {R4,LR}
   \       0xAE   0x.... 0x....      B.W      _ZN12MarlinSerial5writeEh
   \                     ??gcode_M304_4: (+1)
   \       0xB2   0x2200             MOVS     R2,#+0
   \       0xB4   0x210A             MOVS     R1,#+10
   \       0xB6   0x480D             LDR.N    R0,??gcode_M304_0+0x2C
   \       0xB8   0xE8BD 0x4010      POP      {R4,LR}
   \       0xBC   0x.... 0x....      B.W      _ZN12MarlinSerial5printEci
   \                     ??gcode_M304_0:
   \       0xC0   0x....'....        DC32     _ZN11Temperature5bedKpE
   \       0xC4   0x88E3'68F1        DC32     0x88e368f1
   \       0xC8   0x3FC4'F8B5        DC32     0x3fc4f8b5
   \       0xCC   0x....'....        DC32     _ZN11Temperature5bedKiE
   \       0xD0   0x....'....        DC32     _ZN11Temperature5bedKdE
   \       0xD4   0x....'....        DC32     echomagic
   \       0xD8   0x....'....        DC32     _ZZ10gcode_M304vEs
   \       0xDC   0x....'....        DC32     _ZZ10gcode_M304vEs_0
   \       0xE0   0x....'....        DC32     _ZZ10gcode_M304vEs_1
   \       0xE4   0x....'....        DC32     mks_heating_busy
   \       0xE8   0x....'....        DC32     customizedSerial
   \       0xEC   0x....'....        DC32     serial2
   9164            }
   9165          
   9166          #endif // PIDTEMPBED
   9167          
   9168          #if defined(CHDK) || HAS_PHOTOGRAPH
   9169          
   9170            /**
   9171             * M240: Trigger a camera by emulating a Canon RC-1
   9172             *       See http://www.doc-diy.net/photo/rc-1_hacked/
   9173             */
   9174            inline void gcode_M240() {
   9175              #ifdef CHDK
   9176          
   9177                OUT_WRITE(CHDK, HIGH);
   9178                chdkHigh = millis();
   9179                chdkActive = true;
   9180          
   9181              #elif HAS_PHOTOGRAPH
   9182          
   9183                const uint8_t NUM_PULSES = 16;
   9184                const float PULSE_LENGTH = 0.01524;
   9185                for (int i = 0; i < NUM_PULSES; i++) {
   9186                  WRITE(PHOTOGRAPH_PIN, HIGH);
   9187                  _delay_ms(PULSE_LENGTH);
   9188                  WRITE(PHOTOGRAPH_PIN, LOW);
   9189                  _delay_ms(PULSE_LENGTH);
   9190                }
   9191                delay(7.33);
   9192                for (int i = 0; i < NUM_PULSES; i++) {
   9193                  WRITE(PHOTOGRAPH_PIN, HIGH);
   9194                  _delay_ms(PULSE_LENGTH);
   9195                  WRITE(PHOTOGRAPH_PIN, LOW);
   9196                  _delay_ms(PULSE_LENGTH);
   9197                }
   9198          
   9199              #endif // !CHDK && HAS_PHOTOGRAPH
   9200            }
   9201          
   9202          #endif // CHDK || PHOTOGRAPH_PIN
   9203          
   9204          #if HAS_LCD_CONTRAST
   9205          
   9206            /**
   9207             * M250: Read and optionally set the LCD contrast
   9208             */
   9209            inline void gcode_M250() {
   9210              if (code_seen('C')) set_lcd_contrast(code_value_int());
   9211              SERIAL_PROTOCOLPGM("lcd contrast value: ");
   9212              SERIAL_PROTOCOL(lcd_contrast);
   9213              SERIAL_EOL;
   9214            }
   9215          
   9216          #endif // HAS_LCD_CONTRAST
   9217          
   9218          #if ENABLED(PREVENT_COLD_EXTRUSION)
   9219          
   9220            /**
   9221             * M302: Allow cold extrudes, or set the minimum extrude temperature
   9222             *
   9223             *       S<temperature> sets the minimum extrude temperature
   9224             *       P<bool> enables (1) or disables (0) cold extrusion
   9225             *
   9226             *  Examples:
   9227             *
   9228             *       M302         ; report current cold extrusion state
   9229             *       M302 P0      ; enable cold extrusion checking
   9230             *       M302 P1      ; disables cold extrusion checking
   9231             *       M302 S0      ; always allow extrusion (disables checking)
   9232             *       M302 S170    ; only allow extrusion above 170
   9233             *       M302 S170 P1 ; set min extrude temp to 170 but leave disabled
   9234             */

   \                                 In section .text, align 4
   9235            inline void gcode_M302() {
   \                     _Z10gcode_M302v: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   9236              bool seen_S = code_seen('S');
   \        0x2   0x2053             MOVS     R0,#+83
   \        0x4   0x.... 0x....      BL       _Z9code_seenc
   \        0x8   0x0004             MOVS     R4,R0
   9237              if (seen_S) {
   \        0xA   0x4D24             LDR.N    R5,??gcode_M302_0
   \        0xC   0xD00E             BEQ.N    ??gcode_M302_1
   9238                thermalManager.extrude_min_temp = code_value_temp_abs();
   \        0xE   0x4E24             LDR.N    R6,??gcode_M302_0+0x4
   \       0x10   0x.... 0x....      BL       _Z19code_value_temp_absv
   \       0x14   0x.... 0x....      BL       __aeabi_i2f
   \       0x18   0x6030             STR      R0,[R6, #+0]
   9239                thermalManager.allow_cold_extrude = (thermalManager.extrude_min_temp == 0);
   \       0x1A   0x2100             MOVS     R1,#+0
   \       0x1C   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0x20   0xD102             BNE.N    ??gcode_M302_2
   \       0x22   0x2001             MOVS     R0,#+1
   \       0x24   0x7028             STRB     R0,[R5, #+0]
   \       0x26   0xE001             B.N      ??gcode_M302_1
   \                     ??gcode_M302_2: (+1)
   \       0x28   0x4608             MOV      R0,R1
   \       0x2A   0x7028             STRB     R0,[R5, #+0]
   9240              }
   9241          
   9242              if (code_seen('P'))
   \                     ??gcode_M302_1: (+1)
   \       0x2C   0x2050             MOVS     R0,#+80
   \       0x2E   0x.... 0x....      BL       _Z9code_seenc
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD010             BEQ.N    ??gcode_M302_3
   9243                thermalManager.allow_cold_extrude = (thermalManager.extrude_min_temp == 0) || code_value_bool();
   \       0x36   0x481A             LDR.N    R0,??gcode_M302_0+0x4
   \       0x38   0x6800             LDR      R0,[R0, #+0]
   \       0x3A   0x2100             MOVS     R1,#+0
   \       0x3C   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0x40   0xD007             BEQ.N    ??gcode_M302_4
   \       0x42   0x.... 0x....      BL       _Z15code_value_boolv
   \       0x46   0x1E40             SUBS     R0,R0,#+1
   \       0x48   0x4180             SBCS     R0,R0,R0
   \       0x4A   0x43C0             MVNS     R0,R0
   \       0x4C   0x0FC0             LSRS     R0,R0,#+31
   \       0x4E   0x7028             STRB     R0,[R5, #+0]
   \       0x50   0xBD70             POP      {R4-R6,PC}
   \                     ??gcode_M302_4: (+1)
   \       0x52   0x2001             MOVS     R0,#+1
   \       0x54   0x7028             STRB     R0,[R5, #+0]
   \       0x56   0xBD70             POP      {R4-R6,PC}
   9244              else if (!seen_S) {
   \                     ??gcode_M302_3: (+1)
   \       0x58   0x2C00             CMP      R4,#+0
   \       0x5A   0xD11E             BNE.N    ??gcode_M302_5
   9245                // Report current state
   9246                SERIAL_ECHO_START;
   \       0x5C   0x4811             LDR.N    R0,??gcode_M302_0+0x8
   \       0x5E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9247                SERIAL_ECHOPAIR("Cold extrudes are ", (thermalManager.allow_cold_extrude ? "en" : "dis"));
   \       0x62   0x7828             LDRB     R0,[R5, #+0]
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD001             BEQ.N    ??gcode_M302_6
   \       0x68   0x490F             LDR.N    R1,??gcode_M302_0+0xC
   \       0x6A   0xE000             B.N      ??gcode_M302_7
   \                     ??gcode_M302_6: (+1)
   \       0x6C   0x490F             LDR.N    R1,??gcode_M302_0+0x10
   \                     ??gcode_M302_7: (+1)
   \       0x6E   0x4810             LDR.N    R0,??gcode_M302_0+0x14
   \       0x70   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
   9248                SERIAL_ECHOPAIR("abled (min temp ", int(thermalManager.extrude_min_temp + 0.5));
   \       0x74   0x480A             LDR.N    R0,??gcode_M302_0+0x4
   \       0x76   0x6800             LDR      R0,[R0, #+0]
   \       0x78   0x.... 0x....      BL       __aeabi_f2d
   \       0x7C   0x2200             MOVS     R2,#+0
   \       0x7E   0x4B0D             LDR.N    R3,??gcode_M302_0+0x18  ;; 0x3fe00000
   \       0x80   0x.... 0x....      BL       __aeabi_dadd
   \       0x84   0x.... 0x....      BL       __aeabi_d2iz
   \       0x88   0x4601             MOV      R1,R0
   \       0x8A   0x480B             LDR.N    R0,??gcode_M302_0+0x1C
   \       0x8C   0x.... 0x....      BL       _Z17serial_echopair_PPKci
   9249                SERIAL_ECHOLNPGM("C)");
   \       0x90   0x480A             LDR.N    R0,??gcode_M302_0+0x20
   \       0x92   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x96   0x.... 0x....      B.W      _Z14serialprintPGMPKc
   9250              }
   9251            }
   \                     ??gcode_M302_5: (+1)
   \       0x9A   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??gcode_M302_0:
   \       0x9C   0x....'....        DC32     _ZN11Temperature18allow_cold_extrudeE
   \       0xA0   0x....'....        DC32     _ZN11Temperature16extrude_min_tempE
   \       0xA4   0x....'....        DC32     echomagic
   \       0xA8   0x....'....        DC32     _ZZ10gcode_M302vEs_0
   \       0xAC   0x....'....        DC32     _ZZ10gcode_M302vEs_1
   \       0xB0   0x....'....        DC32     _ZZ10gcode_M302vEs
   \       0xB4   0x3FE0'0000        DC32     0x3fe00000
   \       0xB8   0x....'....        DC32     _ZZ10gcode_M302vEs_2
   \       0xBC   0x....'....        DC32     _ZZ10gcode_M302vEs_3
   9252          
   9253          #endif // PREVENT_COLD_EXTRUSION
   9254          
   9255          /**
   9256           * M303: PID relay autotune
   9257           *
   9258           *       S<temperature> sets the target temperature. (default 150C)
   9259           *       E<extruder> (-1 for the bed) (default 0)
   9260           *       C<cycles>
   9261           *       U<bool> with a non-zero value will apply the result to current settings
   9262           */

   \                                 In section .text, align 4
   9263          inline void gcode_M303() {
   \                     _Z10gcode_M303v: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   9264            //#if HAS_PID_HEATING
   9265            if(HAS_PID_HEATING) {
   \        0x2   0x4927             LDR.N    R1,??gcode_M303_0
   \        0x4   0x7808             LDRB     R0,[R1, #+0]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD102             BNE.N    ??gcode_M303_1
   \        0xA   0x7848             LDRB     R0,[R1, #+1]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD03E             BEQ.N    ??gcode_M303_2
   9266              const int e = code_seen('E') ? code_value_int() : 0,
   \                     ??gcode_M303_1: (+1)
   \       0x10   0x2045             MOVS     R0,#+69
   \       0x12   0x.... 0x....      BL       _Z9code_seenc
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD003             BEQ.N    ??gcode_M303_3
   \       0x1A   0x.... 0x....      BL       _Z14code_value_intv
   \       0x1E   0x4604             MOV      R4,R0
   \       0x20   0xE000             B.N      ??gcode_M303_4
   \                     ??gcode_M303_3: (+1)
   \       0x22   0x2400             MOVS     R4,#+0
   9267                        c = code_seen('C') ? code_value_int() : 5;
   \                     ??gcode_M303_4: (+1)
   \       0x24   0x2043             MOVS     R0,#+67
   \       0x26   0x.... 0x....      BL       _Z9code_seenc
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD003             BEQ.N    ??gcode_M303_5
   \       0x2E   0x.... 0x....      BL       _Z14code_value_intv
   \       0x32   0x4606             MOV      R6,R0
   \       0x34   0xE000             B.N      ??gcode_M303_6
   \                     ??gcode_M303_5: (+1)
   \       0x36   0x2605             MOVS     R6,#+5
   9268              const bool u = code_seen('U') && code_value_bool();
   \                     ??gcode_M303_6: (+1)
   \       0x38   0x2055             MOVS     R0,#+85
   \       0x3A   0x.... 0x....      BL       _Z9code_seenc
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD006             BEQ.N    ??gcode_M303_7
   \       0x42   0x.... 0x....      BL       _Z15code_value_boolv
   \       0x46   0x1E47             SUBS     R7,R0,#+1
   \       0x48   0x41BF             SBCS     R7,R7,R7
   \       0x4A   0x43FF             MVNS     R7,R7
   \       0x4C   0x0FFF             LSRS     R7,R7,#+31
   \       0x4E   0xE000             B.N      ??gcode_M303_8
   \                     ??gcode_M303_7: (+1)
   \       0x50   0x2700             MOVS     R7,#+0
   9269          
   9270              int16_t temp = code_seen('S') ? code_value_temp_abs() : (e < 0 ? 70 : 150);
   \                     ??gcode_M303_8: (+1)
   \       0x52   0x2053             MOVS     R0,#+83
   \       0x54   0x.... 0x....      BL       _Z9code_seenc
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD002             BEQ.N    ??gcode_M303_9
   \       0x5C   0x.... 0x....      BL       _Z19code_value_temp_absv
   \       0x60   0xE004             B.N      ??gcode_M303_10
   \                     ??gcode_M303_9: (+1)
   \       0x62   0x2C00             CMP      R4,#+0
   \       0x64   0xD501             BPL.N    ??gcode_M303_11
   \       0x66   0x2046             MOVS     R0,#+70
   \       0x68   0xE000             B.N      ??gcode_M303_10
   \                     ??gcode_M303_11: (+1)
   \       0x6A   0x2096             MOVS     R0,#+150
   9271          
   9272              if (WITHIN(e, 0, HOTENDS - 1))
   \                     ??gcode_M303_10: (+1)
   \       0x6C   0x4D0D             LDR.N    R5,??gcode_M303_0+0x4
   \       0x6E   0x2C00             CMP      R4,#+0
   \       0x70   0xD101             BNE.N    ??gcode_M303_12
   9273                target_extruder = e;
   \       0x72   0x2100             MOVS     R1,#+0
   \       0x74   0x7169             STRB     R1,[R5, #+5]
   9274          
   9275              KEEPALIVE_STATE(NOT_BUSY); // don't send "busy: processing" messages during autotune output
   \                     ??gcode_M303_12: (+1)
   \       0x76   0x2100             MOVS     R1,#+0
   \       0x78   0x71A9             STRB     R1,[R5, #+6]
   9276          
   9277              thermalManager.PID_autotune(temp, e, c, u);
   \       0x7A   0x.... 0x....      BL       __aeabi_i2f
   \       0x7E   0x463B             MOV      R3,R7
   \       0x80   0x4632             MOV      R2,R6
   \       0x82   0x4621             MOV      R1,R4
   \       0x84   0x.... 0x....      BL       _ZN11Temperature12PID_autotuneEfiib
   9278          
   9279              KEEPALIVE_STATE(IN_HANDLER);
   \       0x88   0x2001             MOVS     R0,#+1
   \       0x8A   0x71A8             STRB     R0,[R5, #+6]
   \       0x8C   0xBDF1             POP      {R0,R4-R7,PC}
   9280            }//#else
   9281            else {
   9282              SERIAL_ERROR_START;
   \                     ??gcode_M303_2: (+1)
   \       0x8E   0x4806             LDR.N    R0,??gcode_M303_0+0x8
   \       0x90   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9283              SERIAL_ERRORLNPGM(MSG_ERR_M303_DISABLED);
   \       0x94   0x4805             LDR.N    R0,??gcode_M303_0+0xC
   \       0x96   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \       0x9A   0x.... 0x....      B.W      _Z14serialprintPGMPKc
   \       0x9E   0xBF00             Nop      
   \                     ??gcode_M303_0:
   \       0xA0   0x....'....        DC32     mksCfg+0x34
   \       0xA4   0x....'....        DC32     mks_heating_busy
   \       0xA8   0x....'....        DC32     errormagic
   \       0xAC   0x....'....        DC32     _ZZ10gcode_M303vEs
   9284            }//#endif
   9285          }
   9286          
   9287          //#if ENABLED(MORGAN_SCARA)	//mks_delta
   9288          #if 1

   \                                 In section .text, align 2, keep-with-next
   9289            bool SCARA_move_to_cal(uint8_t delta_a, uint8_t delta_b) {
   \                     _Z17SCARA_move_to_calhh: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   9290              if (IsRunning()) {
   \        0x6   0x.... 0x....      BL       _Z9IsRunningv
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD01E             BEQ.N    ??SCARA_move_to_cal_0
   9291                forward_kinematics_SCARA(delta_a, delta_b);
   \        0xE   0x4620             MOV      R0,R4
   \       0x10   0x.... 0x....      BL       __aeabi_ui2f
   \       0x14   0x9001             STR      R0,[SP, #+4]
   \       0x16   0x4628             MOV      R0,R5
   \       0x18   0x.... 0x....      BL       __aeabi_ui2f
   \       0x1C   0x9000             STR      R0,[SP, #+0]
   \       0x1E   0x4669             MOV      R1,SP
   \       0x20   0xA801             ADD      R0,SP,#+4
   \       0x22   0x.... 0x....      BL       _Z24forward_kinematics_SCARARKfS0_
   9292                destination[X_AXIS] = LOGICAL_X_POSITION(cartes[X_AXIS]);
   \       0x26   0x....             LDR.N    R4,??DataTable136_2
   \       0x28   0x.... 0x....      LDR.W    R5,??DataTable139
   \       0x2C   0x6AA9             LDR      R1,[R5, #+40]
   \       0x2E   0x6C60             LDR      R0,[R4, #+68]
   \       0x30   0x.... 0x....      BL       __aeabi_fadd
   \       0x34   0x61A0             STR      R0,[R4, #+24]
   9293                destination[Y_AXIS] = LOGICAL_Y_POSITION(cartes[Y_AXIS]);
   \       0x36   0x6AE9             LDR      R1,[R5, #+44]
   \       0x38   0x6CA0             LDR      R0,[R4, #+72]
   \       0x3A   0x.... 0x....      BL       __aeabi_fadd
   \       0x3E   0x61E0             STR      R0,[R4, #+28]
   9294                destination[Z_AXIS] = current_position[Z_AXIS];
   \       0x40   0x6920             LDR      R0,[R4, #+16]
   \       0x42   0x6220             STR      R0,[R4, #+32]
   9295                prepare_move_to_destination();
   \       0x44   0x.... 0x....      BL       _Z27prepare_move_to_destinationv
   9296                return true;
   \       0x48   0x2001             MOVS     R0,#+1
   \       0x4A   0xBD3E             POP      {R1-R5,PC}
   9297              }
   9298              return false;
   \                     ??SCARA_move_to_cal_0: (+1)
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0xBD3E             POP      {R1-R5,PC}       ;; return
   9299            }
   9300          
   9301            /**
   9302             * M360: SCARA calibration: Move to cal-position ThetaA (0 deg calibration)
   9303             */

   \                                 In section .text, align 4
   9304            inline bool gcode_M360() {
   \                     _Z10gcode_M360v: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   9305              SERIAL_ECHOLNPGM(" Cal: Theta 0");
   \        0x2   0x4804             LDR.N    R0,??gcode_M360_0
   \        0x4   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9306              return SCARA_move_to_cal(0, 120);
   \        0x8   0x2178             MOVS     R1,#+120
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xE8BD 0x4004      POP      {R2,LR}
   \       0x10   0x.... 0x....      B.W      _Z17SCARA_move_to_calhh
   \                     ??gcode_M360_0:
   \       0x14   0x....'....        DC32     _ZZ10gcode_M360vEs
   9307            }
   9308          
   9309            /**
   9310             * M361: SCARA calibration: Move to cal-position ThetaB (90 deg calibration - steps per degree)
   9311             */

   \                                 In section .text, align 4
   9312            inline bool gcode_M361() {
   \                     _Z10gcode_M361v: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   9313              SERIAL_ECHOLNPGM(" Cal: Theta 90");
   \        0x2   0x4804             LDR.N    R0,??gcode_M361_0
   \        0x4   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9314              return SCARA_move_to_cal(90, 130);
   \        0x8   0x2182             MOVS     R1,#+130
   \        0xA   0x205A             MOVS     R0,#+90
   \        0xC   0xE8BD 0x4004      POP      {R2,LR}
   \       0x10   0x.... 0x....      B.W      _Z17SCARA_move_to_calhh
   \                     ??gcode_M361_0:
   \       0x14   0x....'....        DC32     _ZZ10gcode_M361vEs
   9315            }
   9316          
   9317            /**
   9318             * M362: SCARA calibration: Move to cal-position PsiA (0 deg calibration)
   9319             */

   \                                 In section .text, align 4
   9320            inline bool gcode_M362() {
   \                     _Z10gcode_M362v: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   9321              SERIAL_ECHOLNPGM(" Cal: Psi 0");
   \        0x2   0x4804             LDR.N    R0,??gcode_M362_0
   \        0x4   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9322              return SCARA_move_to_cal(60, 180);
   \        0x8   0x21B4             MOVS     R1,#+180
   \        0xA   0x203C             MOVS     R0,#+60
   \        0xC   0xE8BD 0x4004      POP      {R2,LR}
   \       0x10   0x.... 0x....      B.W      _Z17SCARA_move_to_calhh
   \                     ??gcode_M362_0:
   \       0x14   0x....'....        DC32     _ZZ10gcode_M362vEs
   9323            }
   9324          
   9325            /**
   9326             * M363: SCARA calibration: Move to cal-position PsiB (90 deg calibration - steps per degree)
   9327             */

   \                                 In section .text, align 4
   9328            inline bool gcode_M363() {
   \                     _Z10gcode_M363v: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   9329              SERIAL_ECHOLNPGM(" Cal: Psi 90");
   \        0x2   0x4804             LDR.N    R0,??gcode_M363_0
   \        0x4   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9330              return SCARA_move_to_cal(50, 90);
   \        0x8   0x215A             MOVS     R1,#+90
   \        0xA   0x2032             MOVS     R0,#+50
   \        0xC   0xE8BD 0x4004      POP      {R2,LR}
   \       0x10   0x.... 0x....      B.W      _Z17SCARA_move_to_calhh
   \                     ??gcode_M363_0:
   \       0x14   0x....'....        DC32     _ZZ10gcode_M363vEs
   9331            }
   9332          
   9333            /**
   9334             * M364: SCARA calibration: Move to cal-position PSIC (90 deg to Theta calibration position)
   9335             */

   \                                 In section .text, align 4
   9336            inline bool gcode_M364() {
   \                     _Z10gcode_M364v: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   9337              SERIAL_ECHOLNPGM(" Cal: Theta-Psi 90");
   \        0x2   0x4804             LDR.N    R0,??gcode_M364_0
   \        0x4   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9338              return SCARA_move_to_cal(45, 135);
   \        0x8   0x2187             MOVS     R1,#+135
   \        0xA   0x202D             MOVS     R0,#+45
   \        0xC   0xE8BD 0x4004      POP      {R2,LR}
   \       0x10   0x.... 0x....      B.W      _Z17SCARA_move_to_calhh
   \                     ??gcode_M364_0:
   \       0x14   0x....'....        DC32     _ZZ10gcode_M364vEs
   9339            }
   9340          
   9341          #endif // SCARA
   9342          
   9343          #if ENABLED(EXT_SOLENOID)
   9344          
   9345            void enable_solenoid(const uint8_t num) {
   9346              switch (num) {
   9347                case 0:
   9348                  OUT_WRITE(SOL0_PIN, HIGH);
   9349                  break;
   9350                  #if HAS_SOLENOID_1 && EXTRUDERS > 1
   9351                    case 1:
   9352                      OUT_WRITE(SOL1_PIN, HIGH);
   9353                      break;
   9354                  #endif
   9355                  #if HAS_SOLENOID_2 && EXTRUDERS > 2
   9356                    case 2:
   9357                      OUT_WRITE(SOL2_PIN, HIGH);
   9358                      break;
   9359                  #endif
   9360                  #if HAS_SOLENOID_3 && EXTRUDERS > 3
   9361                    case 3:
   9362                      OUT_WRITE(SOL3_PIN, HIGH);
   9363                      break;
   9364                  #endif
   9365                  #if HAS_SOLENOID_4 && EXTRUDERS > 4
   9366                    case 4:
   9367                      OUT_WRITE(SOL4_PIN, HIGH);
   9368                      break;
   9369                  #endif
   9370                default:
   9371                  SERIAL_ECHO_START;
   9372                  SERIAL_ECHOLNPGM(MSG_INVALID_SOLENOID);
   9373                  break;
   9374              }
   9375            }
   9376          
   9377            void enable_solenoid_on_active_extruder() { enable_solenoid(active_extruder); }
   9378          
   9379            void disable_all_solenoids() {
   9380              OUT_WRITE(SOL0_PIN, LOW);
   9381              #if HAS_SOLENOID_1 && EXTRUDERS > 1
   9382                OUT_WRITE(SOL1_PIN, LOW);
   9383              #endif
   9384              #if HAS_SOLENOID_2 && EXTRUDERS > 2
   9385                OUT_WRITE(SOL2_PIN, LOW);
   9386              #endif
   9387              #if HAS_SOLENOID_3 && EXTRUDERS > 3
   9388                OUT_WRITE(SOL3_PIN, LOW);
   9389              #endif
   9390              #if HAS_SOLENOID_4 && EXTRUDERS > 4
   9391                OUT_WRITE(SOL4_PIN, LOW);
   9392              #endif
   9393            }
   9394          
   9395            /**
   9396             * M380: Enable solenoid on the active extruder
   9397             */
   9398            inline void gcode_M380() { enable_solenoid_on_active_extruder(); }
   9399          
   9400            /**
   9401             * M381: Disable all solenoids
   9402             */
   9403            inline void gcode_M381() { disable_all_solenoids(); }
   9404          
   9405          #endif // EXT_SOLENOID
   9406          
   9407          /**
   9408           * M400: Finish all moves
   9409           */

   \                                 In section .text, align 2
   9410          inline void gcode_M400() { stepper.synchronize(); }
   \                     _Z10gcode_M400v: (+1)
   \        0x0   0x.... 0x....      B.W      _ZN7Stepper11synchronizeEv
   9411          
   9412          #if HAS_BED_PROBE
   9413          
   9414            /**
   9415             * M401: Engage Z Servo endstop if available
   9416             */

   \                                 In section .text, align 2
   9417            inline void gcode_M401() { DEPLOY_PROBE(); }
   \                     _Z10gcode_M401v: (+1)
   \        0x0   0x2001             MOVS     R0,#+1
   \        0x2   0x.... 0x....      B.W      _Z18set_probe_deployedb
   9418          
   9419            /**
   9420             * M402: Retract Z Servo endstop if enabled
   9421             */

   \                                 In section .text, align 2
   9422            inline void gcode_M402() { STOW_PROBE(); }
   \                     _Z10gcode_M402v: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x.... 0x....      B.W      _Z18set_probe_deployedb
   9423          
   9424          #endif // HAS_BED_PROBE
   9425          
   9426          #if ENABLED(FILAMENT_WIDTH_SENSOR)
   9427          
   9428            /**
   9429             * M404: Display or set (in current units) the nominal filament width (3mm, 1.75mm ) W<3.0>
   9430             */
   9431            inline void gcode_M404() {
   9432              if (code_seen('W')) {
   9433                filament_width_nominal = code_value_linear_units();
   9434              }
   9435              else {
   9436                SERIAL_PROTOCOLPGM("Filament dia (nominal mm):");
   9437                SERIAL_PROTOCOLLN(filament_width_nominal);
   9438              }
   9439            }
   9440          
   9441            /**
   9442             * M405: Turn on filament sensor for control
   9443             */
   9444            inline void gcode_M405() {
   9445              // This is technically a linear measurement, but since it's quantized to centimeters and is a different unit than
   9446              // everything else, it uses code_value_int() instead of code_value_linear_units().
   9447              if (code_seen('D')) meas_delay_cm = code_value_int();
   9448              NOMORE(meas_delay_cm, MAX_MEASUREMENT_DELAY);
   9449          
   9450              if (filwidth_delay_index[1] == -1) { // Initialize the ring buffer if not done since startup
   9451                const int temp_ratio = thermalManager.widthFil_to_size_ratio() - 100; // -100 to scale within a signed byte
   9452          
   9453                for (uint8_t i = 0; i < COUNT(measurement_delay); ++i)
   9454                  measurement_delay[i] = temp_ratio;
   9455          
   9456                filwidth_delay_index[0] = filwidth_delay_index[1] = 0;
   9457              }
   9458          
   9459              filament_sensor = true;
   9460          
   9461              //SERIAL_PROTOCOLPGM("Filament dia (measured mm):");
   9462              //SERIAL_PROTOCOL(filament_width_meas);
   9463              //SERIAL_PROTOCOLPGM("Extrusion ratio(%):");
   9464              //SERIAL_PROTOCOL(flow_percentage[active_extruder]);
   9465            }
   9466          
   9467            /**
   9468             * M406: Turn off filament sensor for control
   9469             */
   9470            inline void gcode_M406() { filament_sensor = false; }
   9471          
   9472            /**
   9473             * M407: Get measured filament diameter on serial output
   9474             */
   9475            inline void gcode_M407() {
   9476              SERIAL_PROTOCOLPGM("Filament dia (measured mm):");
   9477              SERIAL_PROTOCOLLN(filament_width_meas);
   9478            }
   9479          
   9480          #endif // FILAMENT_WIDTH_SENSOR
   9481          

   \                                 In section .text, align 2, keep-with-next
   9482          void quickstop_stepper() {
   \                     _Z17quickstop_stepperv: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   9483            stepper.quick_stop();
   \        0x2   0x.... 0x....      BL       _ZN7Stepper10quick_stopEv
   9484            stepper.synchronize();
   \        0x6   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   9485            set_current_from_steppers_for_axis(ALL_AXES);
   \        0xA   0x2064             MOVS     R0,#+100
   \        0xC   0x.... 0x....      BL       _Z34set_current_from_steppers_for_axis8AxisEnum
   9486            SYNC_PLAN_POSITION_KINEMATIC();
   \       0x10   0xE8BD 0x4001      POP      {R0,LR}
   \       0x14   0x.... 0x....      B.W      _Z28SYNC_PLAN_POSITION_KINEMATICv
   9487          }
   9488          
   9489          //#if HAS_LEVELING
   9490          #if 1
   9491            /**
   9492             * M420: Enable/Disable Bed Leveling and/or set the Z fade height.
   9493             *
   9494             *   S[bool]   Turns leveling on or off
   9495             *   Z[height] Sets the Z fade height (0 or none to disable)
   9496             *   V[bool]   Verbose - Print the leveling grid
   9497             *
   9498             * With AUTO_BED_LEVELING_UBL only:
   9499             *
   9500             *   L[index]  Load UBL mesh from index (0 is default)
   9501             */

   \                                 In section .text, align 4
   9502            inline void gcode_M420() {
   \                     _Z10gcode_M420v: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   9503          
   9504              //#if ENABLED(AUTO_BED_LEVELING_UBL)
   9505          	if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)	{
   \        0x4   0x4D88             LDR.N    R5,??gcode_M420_0
   \        0x6   0x4C89             LDR.N    R4,??gcode_M420_0+0x4
   \        0x8   0x7828             LDRB     R0,[R5, #+0]
   \        0xA   0x2810             CMP      R0,#+16
   \        0xC   0xD12B             BNE.N    ??gcode_M420_1
   9506                // L to load a mesh from the EEPROM
   9507                if (code_seen('L')) {
   \        0xE   0x204C             MOVS     R0,#+76
   \       0x10   0x.... 0x....      BL       _Z9code_seenc
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD026             BEQ.N    ??gcode_M420_1
   9508                  const int8_t storage_slot = code_has_value() ? code_value_int() : ubl.state.eeprom_storage_slot;
   \       0x18   0x.... 0x....      BL       _Z14code_has_valuev
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD004             BEQ.N    ??gcode_M420_2
   \       0x20   0x.... 0x....      BL       _Z14code_value_intv
   \       0x24   0x4606             MOV      R6,R0
   \       0x26   0xB276             SXTB     R6,R6
   \       0x28   0xE002             B.N      ??gcode_M420_3
   \                     ??gcode_M420_2: (+1)
   \       0x2A   0x4881             LDR.N    R0,??gcode_M420_0+0x8
   \       0x2C   0xF990 0x6008      LDRSB    R6,[R0, #+8]
   9509                  const int16_t j = (UBL_LAST_EEPROM_INDEX - ubl.eeprom_start) / sizeof(ubl.z_values);
   9510                  if (!WITHIN(storage_slot, 0, j - 1) || ubl.eeprom_start <= 0) {
   \                     ??gcode_M420_3: (+1)
   \       0x30   0x2E00             CMP      R6,#+0
   \       0x32   0xD40C             BMI.N    ??gcode_M420_4
   \       0x34   0x487F             LDR.N    R0,??gcode_M420_0+0xC
   \       0x36   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \       0x3A   0xF240 0x51FF      MOVW     R1,#+1535
   \       0x3E   0x1A09             SUBS     R1,R1,R0
   \       0x40   0x0A89             LSRS     R1,R1,#+10
   \       0x42   0xB209             SXTH     R1,R1
   \       0x44   0x1E49             SUBS     R1,R1,#+1
   \       0x46   0x42B1             CMP      R1,R6
   \       0x48   0xDB01             BLT.N    ??gcode_M420_4
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xDC04             BGT.N    ??gcode_M420_5
   9511                    SERIAL_PROTOCOLLNPGM("?EEPROM storage not available for use.\n");
   \                     ??gcode_M420_4: (+1)
   \       0x4E   0x487A             LDR.N    R0,??gcode_M420_0+0x10
   \       0x50   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \       0x54   0x.... 0x....      B.W      _Z14serialprintPGMPKc
   9512                    return;
   9513                  }
   9514          
   9515                  ubl.load_mesh(storage_slot);
   \                     ??gcode_M420_5: (+1)
   \       0x58   0x4631             MOV      R1,R6
   \       0x5A   0xF104 0x0084      ADD      R0,R4,#+132
   \       0x5E   0x.... 0x....      BL       _ZN20unified_bed_leveling9load_meshEs
   9516                  ubl.state.eeprom_storage_slot = storage_slot;
   \       0x62   0x4873             LDR.N    R0,??gcode_M420_0+0x8
   \       0x64   0x7206             STRB     R6,[R0, #+8]
   9517                }
   9518          	}
   9519              //#endif // AUTO_BED_LEVELING_UBL
   9520          
   9521              // V to print the matrix or mesh
   9522              if (code_seen('V')) {
   \                     ??gcode_M420_1: (+1)
   \       0x66   0x2056             MOVS     R0,#+86
   \       0x68   0x.... 0x....      BL       _Z9code_seenc
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0xD01C             BEQ.N    ??gcode_M420_6
   9523          /*--mks cfg--begin MESH_BED_LEVELING */		
   9524          /*
   9525          	  #if ABL_PLANAR
   9526                  planner.bed_level_matrix.debug(PSTR("Bed Level Correction Matrix:"));
   9527                #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
   9528                  if (bilinear_grid_spacing[X_AXIS]) {
   9529                    print_bilinear_leveling_grid();
   9530                    #if ENABLED(ABL_BILINEAR_SUBDIVISION)
   9531                      bed_level_virt_print();
   9532                    #endif
   9533                  }
   9534                #elif ENABLED(MESH_BED_LEVELING)
   9535                  if (mbl.has_mesh()) {
   9536                    SERIAL_ECHOLNPGM("Mesh Bed Level data:");
   9537                    mbl_mesh_report();
   9538                  }
   9539                #endif
   9540          */
   9541          	  if(BED_LEVELING_METHOD&ABL_PLANAR)
   \       0x70   0x7828             LDRB     R0,[R5, #+0]
   \       0x72   0xF010 0x0F06      TST      R0,#0x6
   \       0x76   0xD004             BEQ.N    ??gcode_M420_7
   9542          	  	{
   9543          	  	planner.bed_level_matrix.debug(PSTR("Bed Level Correction Matrix:"));
   \       0x78   0x4970             LDR.N    R1,??gcode_M420_0+0x14
   \       0x7A   0x4871             LDR.N    R0,??gcode_M420_0+0x18
   \       0x7C   0x.... 0x....      BL       _ZN10matrix_3x35debugEPKc
   \       0x80   0xE013             B.N      ??gcode_M420_6
   9544          	  	}
   9545          		else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
   \                     ??gcode_M420_7: (+1)
   \       0x82   0x2808             CMP      R0,#+8
   \       0x84   0xD106             BNE.N    ??gcode_M420_8
   9546          			{
   9547          				if (bilinear_grid_spacing[X_AXIS]) {
   \       0x86   0x486F             LDR.N    R0,??gcode_M420_0+0x1C
   \       0x88   0x6880             LDR      R0,[R0, #+8]
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0xD00D             BEQ.N    ??gcode_M420_6
   9548          				  print_bilinear_leveling_grid();
   \       0x8E   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531928print_bilinear_leveling_gridEv
   \       0x92   0xE00A             B.N      ??gcode_M420_6
   9549          				#if ENABLED(ABL_BILINEAR_SUBDIVISION)
   9550          					bed_level_virt_print();
   9551          				#endif
   9552          				}
   9553          			}
   9554          	  else if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
   \                     ??gcode_M420_8: (+1)
   \       0x94   0x2820             CMP      R0,#+32
   \       0x96   0xD108             BNE.N    ??gcode_M420_6
   9555          	  	{
   9556          		  if (mbl.has_mesh()) {
   \       0x98   0x.... 0x....      BL       _ZN17mesh_bed_leveling8has_meshEv
   \       0x9C   0x2800             CMP      R0,#+0
   \       0x9E   0xD004             BEQ.N    ??gcode_M420_6
   9557          			SERIAL_ECHOLNPGM("Mesh Bed Level data:");
   \       0xA0   0x4869             LDR.N    R0,??gcode_M420_0+0x20
   \       0xA2   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9558          			mbl_mesh_report();
   \       0xA6   0x.... 0x....      BL       _Z15mbl_mesh_reportv
   9559          		  }
   9560          	  	}
   9561          /*--mks cfg--end MESH_BED_LEVELING */	  
   9562              }
   9563          
   9564             // #if ENABLED(AUTO_BED_LEVELING_UBL)
   9565          	if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)	{
   \                     ??gcode_M420_6: (+1)
   \       0xAA   0x7828             LDRB     R0,[R5, #+0]
   \       0xAC   0x2810             CMP      R0,#+16
   \       0xAE   0xD16D             BNE.N    ??gcode_M420_9
   9566                // L to load a mesh from the EEPROM
   9567                if (code_seen('L') || code_seen('V')) {
   \       0xB0   0x204C             MOVS     R0,#+76
   \       0xB2   0x.... 0x....      BL       _Z9code_seenc
   \       0xB6   0x2800             CMP      R0,#+0
   \       0xB8   0xD104             BNE.N    ??gcode_M420_10
   \       0xBA   0x2056             MOVS     R0,#+86
   \       0xBC   0x.... 0x....      BL       _Z9code_seenc
   \       0xC0   0x2800             CMP      R0,#+0
   \       0xC2   0xD063             BEQ.N    ??gcode_M420_9
   9568                  ubl.display_map(0);  // Currently only supports one map type
   \                     ??gcode_M420_10: (+1)
   \       0xC4   0x2100             MOVS     R1,#+0
   \       0xC6   0xF104 0x0084      ADD      R0,R4,#+132
   \       0xCA   0x.... 0x....      BL       _ZN20unified_bed_leveling11display_mapEi
   9569                  SERIAL_ECHOLNPAIR("UBL_MESH_VALID = ", UBL_MESH_VALID);
   \       0xCE   0x4A5F             LDR.N    R2,??gcode_M420_0+0x24
   \       0xD0   0x6853             LDR      R3,[R2, #+4]
   \       0xD2   0x6816             LDR      R6,[R2, #+0]
   \       0xD4   0x4630             MOV      R0,R6
   \       0xD6   0x4619             MOV      R1,R3
   \       0xD8   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0xDC   0xD12D             BNE.N    ??gcode_M420_11
   \       0xDE   0x4618             MOV      R0,R3
   \       0xE0   0x6891             LDR      R1,[R2, #+8]
   \       0xE2   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0xE6   0xD128             BNE.N    ??gcode_M420_11
   \       0xE8   0x6C53             LDR      R3,[R2, #+68]
   \       0xEA   0x6C17             LDR      R7,[R2, #+64]
   \       0xEC   0x4638             MOV      R0,R7
   \       0xEE   0x4619             MOV      R1,R3
   \       0xF0   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0xF4   0xD121             BNE.N    ??gcode_M420_11
   \       0xF6   0x4618             MOV      R0,R3
   \       0xF8   0x6C91             LDR      R1,[R2, #+72]
   \       0xFA   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0xFE   0xD11C             BNE.N    ??gcode_M420_11
   \      0x100   0xF102 0x0384      ADD      R3,R2,#+132
   \      0x104   0xF8D3 0x8000      LDR      R8,[R3, #+0]
   \      0x108   0xF8D2 0x2080      LDR      R2,[R2, #+128]
   \      0x10C   0x4610             MOV      R0,R2
   \      0x10E   0x4641             MOV      R1,R8
   \      0x110   0x.... 0x....      BL       __aeabi_cfcmpeq
   \      0x114   0xD111             BNE.N    ??gcode_M420_11
   \      0x116   0x4640             MOV      R0,R8
   \      0x118   0x6859             LDR      R1,[R3, #+4]
   \      0x11A   0x.... 0x....      BL       __aeabi_cfcmpeq
   \      0x11E   0xD10C             BNE.N    ??gcode_M420_11
   \      0x120   0x4630             MOV      R0,R6
   \      0x122   0x2100             MOVS     R1,#+0
   \      0x124   0x.... 0x....      BL       __aeabi_cfcmpeq
   \      0x128   0xD107             BNE.N    ??gcode_M420_11
   \      0x12A   0x4638             MOV      R0,R7
   \      0x12C   0x.... 0x....      BL       __aeabi_cfcmpeq
   \      0x130   0xD103             BNE.N    ??gcode_M420_11
   \      0x132   0x4610             MOV      R0,R2
   \      0x134   0x.... 0x....      BL       __aeabi_cfcmpeq
   \      0x138   0xD005             BEQ.N    ??gcode_M420_12
   \                     ??gcode_M420_11: (+1)
   \      0x13A   0x4630             MOV      R0,R6
   \      0x13C   0x.... 0x....      BL       _Z5isnanf
   \      0x140   0x1E41             SUBS     R1,R0,#+1
   \      0x142   0x4189             SBCS     R1,R1,R1
   \      0x144   0x0FC9             LSRS     R1,R1,#+31
   \                     ??gcode_M420_12: (+1)
   \      0x146   0x4842             LDR.N    R0,??gcode_M420_0+0x28
   \      0x148   0x.... 0x....      BL       _Z17serial_echopair_PPKcb
   \      0x14C   0x79E0             LDRB     R0,[R4, #+7]
   \      0x14E   0x2800             CMP      R0,#+0
   \      0x150   0xD104             BNE.N    ??gcode_M420_13
   \      0x152   0x210A             MOVS     R1,#+10
   \      0x154   0x483F             LDR.N    R0,??gcode_M420_0+0x2C
   \      0x156   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \      0x15A   0xE004             B.N      ??gcode_M420_14
   \                     ??gcode_M420_13: (+1)
   \      0x15C   0x2200             MOVS     R2,#+0
   \      0x15E   0x210A             MOVS     R1,#+10
   \      0x160   0x483D             LDR.N    R0,??gcode_M420_0+0x30
   \      0x162   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   9570                  SERIAL_ECHOLNPAIR("eeprom_storage_slot = ", ubl.state.eeprom_storage_slot);
   \                     ??gcode_M420_14: (+1)
   \      0x166   0x4832             LDR.N    R0,??gcode_M420_0+0x8
   \      0x168   0xF990 0x1008      LDRSB    R1,[R0, #+8]
   \      0x16C   0x483B             LDR.N    R0,??gcode_M420_0+0x34
   \      0x16E   0x.... 0x....      BL       _Z17serial_echopair_PPKci
   \      0x172   0x79E0             LDRB     R0,[R4, #+7]
   \      0x174   0x2800             CMP      R0,#+0
   \      0x176   0xD104             BNE.N    ??gcode_M420_15
   \      0x178   0x210A             MOVS     R1,#+10
   \      0x17A   0x4836             LDR.N    R0,??gcode_M420_0+0x2C
   \      0x17C   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \      0x180   0xE004             B.N      ??gcode_M420_9
   \                     ??gcode_M420_15: (+1)
   \      0x182   0x2200             MOVS     R2,#+0
   \      0x184   0x210A             MOVS     R1,#+10
   \      0x186   0x4834             LDR.N    R0,??gcode_M420_0+0x30
   \      0x188   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   9571                }
   9572          		}
   9573              //#endif
   9574          
   9575              bool to_enable = false;
   \                     ??gcode_M420_9: (+1)
   \      0x18C   0x2600             MOVS     R6,#+0
   9576              if (code_seen('S')) {
   \      0x18E   0x2053             MOVS     R0,#+83
   \      0x190   0x.... 0x....      BL       _Z9code_seenc
   \      0x194   0x2800             CMP      R0,#+0
   \      0x196   0xD004             BEQ.N    ??gcode_M420_16
   9577                to_enable = code_value_bool();
   \      0x198   0x.... 0x....      BL       _Z15code_value_boolv
   \      0x19C   0x4606             MOV      R6,R0
   9578                set_bed_leveling_enabled(to_enable);
   \      0x19E   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   9579              }
   9580          
   9581              #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
   9582          	if((MACHINETPYE != DELTA) && (BED_LEVELING_METHOD&HAS_FADE))	//mks_delta
   \                     ??gcode_M420_16: (+1)
   \      0x1A2   0xF9B5 0x0018      LDRSH    R0,[R5, #+24]
   \      0x1A6   0x2802             CMP      R0,#+2
   \      0x1A8   0xD00B             BEQ.N    ??gcode_M420_17
   \      0x1AA   0x7828             LDRB     R0,[R5, #+0]
   \      0x1AC   0x06C0             LSLS     R0,R0,#+27
   \      0x1AE   0xD508             BPL.N    ??gcode_M420_17
   9583                {if (code_seen('Z')) set_z_fade_height(code_value_linear_units()); }
   \      0x1B0   0x205A             MOVS     R0,#+90
   \      0x1B2   0x.... 0x....      BL       _Z9code_seenc
   \      0x1B6   0x2800             CMP      R0,#+0
   \      0x1B8   0xD003             BEQ.N    ??gcode_M420_17
   \      0x1BA   0x.... 0x....      BL       _Z16code_value_floatv
   \      0x1BE   0x.... 0x....      BL       _Z17set_z_fade_heightf
   9584              #endif
   9585          
   9586          	/*--mks cfg--begin MESH_BED_LEVELING */
   9587          /*
   9588              const bool new_status =
   9589                #if ENABLED(MESH_BED_LEVELING)
   9590                  mbl.active()
   9591                #elif ENABLED(AUTO_BED_LEVELING_UBL)
   9592                  ubl.state.active
   9593                #else
   9594                  planner.abl_enabled
   9595                #endif
   9596              ;
   9597          */	  
   9598          	  bool new_status;
   9599          
   9600          	  if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
   \                     ??gcode_M420_17: (+1)
   \      0x1C2   0x7828             LDRB     R0,[R5, #+0]
   \      0x1C4   0x2820             CMP      R0,#+32
   \      0x1C6   0xD103             BNE.N    ??gcode_M420_18
   9601          	  	new_status = mbl.active();
   \      0x1C8   0x.... 0x....      BL       _ZN17mesh_bed_leveling6activeEv
   \      0x1CC   0x4605             MOV      R5,R0
   \      0x1CE   0xE006             B.N      ??gcode_M420_19
   9602          	  else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
   \                     ??gcode_M420_18: (+1)
   \      0x1D0   0x2810             CMP      R0,#+16
   \      0x1D2   0xD102             BNE.N    ??gcode_M420_20
   9603          	  	new_status = ubl.state.active;
   \      0x1D4   0x4816             LDR.N    R0,??gcode_M420_0+0x8
   \      0x1D6   0x7805             LDRB     R5,[R0, #+0]
   \      0x1D8   0xE001             B.N      ??gcode_M420_19
   9604          	  else
   9605          		new_status = planner.abl_enabled;
   \                     ??gcode_M420_20: (+1)
   \      0x1DA   0x4821             LDR.N    R0,??gcode_M420_0+0x38
   \      0x1DC   0x7805             LDRB     R5,[R0, #+0]
   9606          	  
   9607          	  /*--mks cfg--end MESH_BED_LEVELING */
   9608          
   9609              if (to_enable && !new_status) {
   \                     ??gcode_M420_19: (+1)
   \      0x1DE   0x2E00             CMP      R6,#+0
   \      0x1E0   0xD007             BEQ.N    ??gcode_M420_21
   \      0x1E2   0x0028             MOVS     R0,R5
   \      0x1E4   0xD105             BNE.N    ??gcode_M420_21
   9610                SERIAL_ERROR_START;
   \      0x1E6   0x481F             LDR.N    R0,??gcode_M420_0+0x3C
   \      0x1E8   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9611                SERIAL_ERRORLNPGM(MSG_ERR_M420_FAILED);
   \      0x1EC   0x481E             LDR.N    R0,??gcode_M420_0+0x40
   \      0x1EE   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9612              }
   9613          
   9614              SERIAL_ECHO_START;
   \                     ??gcode_M420_21: (+1)
   \      0x1F2   0x481E             LDR.N    R0,??gcode_M420_0+0x44
   \      0x1F4   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9615              SERIAL_ECHOLNPAIR("Bed Leveling ", new_status ? MSG_ON : MSG_OFF);
   \      0x1F8   0x2D00             CMP      R5,#+0
   \      0x1FA   0xD001             BEQ.N    ??gcode_M420_22
   \      0x1FC   0x491C             LDR.N    R1,??gcode_M420_0+0x48
   \      0x1FE   0xE000             B.N      ??gcode_M420_23
   \                     ??gcode_M420_22: (+1)
   \      0x200   0x491C             LDR.N    R1,??gcode_M420_0+0x4C
   \                     ??gcode_M420_23: (+1)
   \      0x202   0x481D             LDR.N    R0,??gcode_M420_0+0x50
   \      0x204   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
   \      0x208   0x79E0             LDRB     R0,[R4, #+7]
   \      0x20A   0x2800             CMP      R0,#+0
   \      0x20C   0xD105             BNE.N    ??gcode_M420_24
   \      0x20E   0x210A             MOVS     R1,#+10
   \      0x210   0x4810             LDR.N    R0,??gcode_M420_0+0x2C
   \      0x212   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \      0x216   0x.... 0x....      B.W      _ZN12MarlinSerial5writeEh
   \                     ??gcode_M420_24: (+1)
   \      0x21A   0x2200             MOVS     R2,#+0
   \      0x21C   0x210A             MOVS     R1,#+10
   \      0x21E   0x480E             LDR.N    R0,??gcode_M420_0+0x30
   \      0x220   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \      0x224   0x.... 0x....      B.W      _ZN12MarlinSerial5printEci
   \                     ??gcode_M420_0:
   \      0x228   0x....'....        DC32     mksCfg+0x40
   \      0x22C   0x....'....        DC32     mks_heating_busy
   \      0x230   0x....'....        DC32     _ZN20unified_bed_leveling5stateE
   \      0x234   0x....'....        DC32     _ZN20unified_bed_leveling12eeprom_startE
   \      0x238   0x....'....        DC32     _ZZ10gcode_M420vEs
   \      0x23C   0x....'....        DC32     _ZZ10gcode_M420vEs_0
   \      0x240   0x....'....        DC32     _ZN7Planner16bed_level_matrixE
   \      0x244   0x....'....        DC32     Running
   \      0x248   0x....'....        DC32     _ZZ10gcode_M420vEs_1
   \      0x24C   0x....'....        DC32     _ZN20unified_bed_leveling8z_valuesE
   \      0x250   0x....'....        DC32     _ZZ10gcode_M420vEs_2
   \      0x254   0x....'....        DC32     customizedSerial
   \      0x258   0x....'....        DC32     serial2
   \      0x25C   0x....'....        DC32     _ZZ10gcode_M420vEs_3
   \      0x260   0x....'....        DC32     _ZN7Planner11abl_enabledE
   \      0x264   0x....'....        DC32     errormagic
   \      0x268   0x....'....        DC32     _ZZ10gcode_M420vEs_4
   \      0x26C   0x....'....        DC32     echomagic
   \      0x270   0x....'....        DC32     MSG_ON
   \      0x274   0x....'....        DC32     MSG_OFF
   \      0x278   0x....'....        DC32     _ZZ10gcode_M420vEs_5
   9616            }
   9617          #endif
   9618          
   9619          //#if ENABLED(MESH_BED_LEVELING)
   9620          #if 1 /*--mks cfg-- MESH_BED_LEVELING */
   9621            /**
   9622             * M421: Set a single Mesh Bed Leveling Z coordinate
   9623             * Use either 'M421 X<linear> Y<linear> Z<linear>' or 'M421 I<xindex> J<yindex> Z<linear>'
   9624             */
   9625          //  inline void gcode_M421() {	/*--mks cfg-- MESH_BED_LEVELING */

   \                                 In section .text, align 4
   9626            inline void gcode_M421_MESH_BED_LEVELING() {
   \                     _Z28gcode_M421_MESH_BED_LEVELINGv: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   9627              int8_t px = 0, py = 0;
   \        0x4   0x2600             MOVS     R6,#+0
   \        0x6   0x4637             MOV      R7,R6
   9628              float z = 0;
   \        0x8   0x4630             MOV      R0,R6
   \        0xA   0x9001             STR      R0,[SP, #+4]
   9629              bool hasX, hasY, hasZ, hasI, hasJ;
   9630              if ((hasX = code_seen('X'))) px = mbl.probe_index_x(code_value_linear_units());
   \        0xC   0x2058             MOVS     R0,#+88
   \        0xE   0x.... 0x....      BL       _Z9code_seenc
   \       0x12   0x0005             MOVS     R5,R0
   \       0x14   0xD006             BEQ.N    ??gcode_M421_MESH_BED_LEVELING_1
   \       0x16   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x1A   0x9000             STR      R0,[SP, #+0]
   \       0x1C   0x4668             MOV      R0,SP
   \       0x1E   0x.... 0x....      BL       _ZN17mesh_bed_leveling13probe_index_xERKf
   \       0x22   0x4606             MOV      R6,R0
   9631              if ((hasY = code_seen('Y'))) py = mbl.probe_index_y(code_value_linear_units());
   \                     ??gcode_M421_MESH_BED_LEVELING_1: (+1)
   \       0x24   0x2059             MOVS     R0,#+89
   \       0x26   0x.... 0x....      BL       _Z9code_seenc
   \       0x2A   0x4680             MOV      R8,R0
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD006             BEQ.N    ??gcode_M421_MESH_BED_LEVELING_2
   \       0x30   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x34   0x9000             STR      R0,[SP, #+0]
   \       0x36   0x4668             MOV      R0,SP
   \       0x38   0x.... 0x....      BL       _ZN17mesh_bed_leveling13probe_index_yERKf
   \       0x3C   0x4607             MOV      R7,R0
   9632              if ((hasI = code_seen('I'))) px = code_value_linear_units();
                                                     ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??gcode_M421_MESH_BED_LEVELING_2: (+1)
   \       0x3E   0x2049             MOVS     R0,#+73
   \       0x40   0x.... 0x....      BL       _Z9code_seenc
   \       0x44   0x4681             MOV      R9,R0
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD004             BEQ.N    ??gcode_M421_MESH_BED_LEVELING_3
   \       0x4A   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x4E   0x.... 0x....      BL       __aeabi_f2iz
   \       0x52   0x4606             MOV      R6,R0
   9633              if ((hasJ = code_seen('J'))) py = code_value_linear_units();
                                                     ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??gcode_M421_MESH_BED_LEVELING_3: (+1)
   \       0x54   0x204A             MOVS     R0,#+74
   \       0x56   0x.... 0x....      BL       _Z9code_seenc
   \       0x5A   0x4682             MOV      R10,R0
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD004             BEQ.N    ??gcode_M421_MESH_BED_LEVELING_4
   \       0x60   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x64   0x.... 0x....      BL       __aeabi_f2iz
   \       0x68   0x4607             MOV      R7,R0
   9634              if ((hasZ = code_seen('Z'))) z = code_value_linear_units();
   \                     ??gcode_M421_MESH_BED_LEVELING_4: (+1)
   \       0x6A   0x205A             MOVS     R0,#+90
   \       0x6C   0x.... 0x....      BL       _Z9code_seenc
   \       0x70   0x0004             MOVS     R4,R0
   \       0x72   0xD002             BEQ.N    ??gcode_M421_MESH_BED_LEVELING_5
   \       0x74   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x78   0x9001             STR      R0,[SP, #+4]
   9635          
   9636              if (hasX && hasY && hasZ) {
   \                     ??gcode_M421_MESH_BED_LEVELING_5: (+1)
   \       0x7A   0x2D00             CMP      R5,#+0
   \       0x7C   0xD013             BEQ.N    ??gcode_M421_MESH_BED_LEVELING_6
   \       0x7E   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x82   0xD010             BEQ.N    ??gcode_M421_MESH_BED_LEVELING_6
   \       0x84   0x2C00             CMP      R4,#+0
   \       0x86   0xD00E             BEQ.N    ??gcode_M421_MESH_BED_LEVELING_6
   9637          
   9638                if (px >= 0 && py >= 0)
   \       0x88   0x4630             MOV      R0,R6
   \       0x8A   0xB240             SXTB     R0,R0
   \       0x8C   0x2800             CMP      R0,#+0
   \       0x8E   0xD403             BMI.N    ??gcode_M421_MESH_BED_LEVELING_7
   \       0x90   0x4638             MOV      R0,R7
   \       0x92   0xB240             SXTB     R0,R0
   \       0x94   0x2800             CMP      R0,#+0
   \       0x96   0xD51F             BPL.N    ??gcode_M421_MESH_BED_LEVELING_8
   9639                  mbl.set_z(px, py, z);
   9640                else {
   9641                  SERIAL_ERROR_START;
   9642                  SERIAL_ERRORLNPGM(MSG_ERR_MESH_XY);
   9643                }
   9644              }
   9645              else if (hasI && hasJ && hasZ) {
   9646                if (WITHIN(px, 0, GRID_MAX_POINTS_X - 1) && WITHIN(py, 0, GRID_MAX_POINTS_Y - 1))
   9647                  mbl.set_z(px, py, z);
   9648                else {
   9649                  SERIAL_ERROR_START;
   \                     ??gcode_M421_MESH_BED_LEVELING_7: (+1)
   \       0x98   0x4817             LDR.N    R0,??gcode_M421_MESH_BED_LEVELING_0
   \       0x9A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9650                  SERIAL_ERRORLNPGM(MSG_ERR_MESH_XY);
   \       0x9E   0x4817             LDR.N    R0,??gcode_M421_MESH_BED_LEVELING_0+0x4
   \       0xA0   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \       0xA4   0xE026             B.N      ??gcode_M421_MESH_BED_LEVELING_9
   9651                }
   \                     ??gcode_M421_MESH_BED_LEVELING_6: (+1)
   \       0xA6   0xF1B9 0x0F00      CMP      R9,#+0
   \       0xAA   0xD01D             BEQ.N    ??gcode_M421_MESH_BED_LEVELING_10
   \       0xAC   0xF1BA 0x0F00      CMP      R10,#+0
   \       0xB0   0xD01A             BEQ.N    ??gcode_M421_MESH_BED_LEVELING_10
   \       0xB2   0x2C00             CMP      R4,#+0
   \       0xB4   0xD018             BEQ.N    ??gcode_M421_MESH_BED_LEVELING_10
   \       0xB6   0x4630             MOV      R0,R6
   \       0xB8   0xB240             SXTB     R0,R0
   \       0xBA   0x2800             CMP      R0,#+0
   \       0xBC   0xD4EC             BMI.N    ??gcode_M421_MESH_BED_LEVELING_7
   \       0xBE   0x4910             LDR.N    R1,??gcode_M421_MESH_BED_LEVELING_0+0x8
   \       0xC0   0x780A             LDRB     R2,[R1, #+0]
   \       0xC2   0x1E52             SUBS     R2,R2,#+1
   \       0xC4   0x4282             CMP      R2,R0
   \       0xC6   0xDBE7             BLT.N    ??gcode_M421_MESH_BED_LEVELING_7
   \       0xC8   0x4638             MOV      R0,R7
   \       0xCA   0xB240             SXTB     R0,R0
   \       0xCC   0x2800             CMP      R0,#+0
   \       0xCE   0xD4E3             BMI.N    ??gcode_M421_MESH_BED_LEVELING_7
   \       0xD0   0x7849             LDRB     R1,[R1, #+1]
   \       0xD2   0x1E49             SUBS     R1,R1,#+1
   \       0xD4   0x4281             CMP      R1,R0
   \       0xD6   0xDBDF             BLT.N    ??gcode_M421_MESH_BED_LEVELING_7
   \                     ??gcode_M421_MESH_BED_LEVELING_8: (+1)
   \       0xD8   0xAA01             ADD      R2,SP,#+4
   \       0xDA   0x4639             MOV      R1,R7
   \       0xDC   0xB249             SXTB     R1,R1
   \       0xDE   0x4630             MOV      R0,R6
   \       0xE0   0xB240             SXTB     R0,R0
   \       0xE2   0x.... 0x....      BL       _ZN17mesh_bed_leveling5set_zEaaRKf
   \       0xE6   0xE005             B.N      ??gcode_M421_MESH_BED_LEVELING_9
   9652              }
   9653              else {
   9654                SERIAL_ERROR_START;
   \                     ??gcode_M421_MESH_BED_LEVELING_10: (+1)
   \       0xE8   0x4803             LDR.N    R0,??gcode_M421_MESH_BED_LEVELING_0
   \       0xEA   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9655                SERIAL_ERRORLNPGM(MSG_ERR_M421_PARAMETERS);
   \       0xEE   0x4805             LDR.N    R0,??gcode_M421_MESH_BED_LEVELING_0+0xC
   \       0xF0   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9656              }
   9657            }
   \                     ??gcode_M421_MESH_BED_LEVELING_9: (+1)
   \       0xF4   0xE8BD 0x87F3      POP      {R0,R1,R4-R10,PC}  ;; return
   \                     ??gcode_M421_MESH_BED_LEVELING_0:
   \       0xF8   0x....'....        DC32     errormagic
   \       0xFC   0x....'....        DC32     _ZZ28gcode_M421_MESH_BED_LEVELINGvEs
   \      0x100   0x....'....        DC32     mksCfg+0x60
   \      0x104   0x....'....        DC32     _ZZ28gcode_M421_MESH_BED_LEVELINGvEs_0
   9658          
   9659          /*--mks cfg-- AUTO_BED_LEVELING_BILINEAR */
   9660          #endif
   9661          //#elif ENABLED(AUTO_BED_LEVELING_BILINEAR) || ENABLED(AUTO_BED_LEVELING_UBL)
   9662          #if 1
   9663            /**
   9664             * M421: Set a single Mesh Bed Leveling Z coordinate
   9665             *
   9666             *   M421 I<xindex> J<yindex> Z<linear>
   9667             */

   \                                 In section .text, align 4
   9668            inline void gcode_M421() {
   \                     _Z10gcode_M421v: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   9669              int8_t px = 0, py = 0;
   \        0x4   0x2400             MOVS     R4,#+0
   \        0x6   0x4625             MOV      R5,R4
   9670              float z = 0;
   \        0x8   0x4626             MOV      R6,R4
   9671              bool hasI, hasJ, hasZ;
   9672              if ((hasI = code_seen('I'))) px = code_value_linear_units();
                                                     ^
Warning[Pa093]: implicit conversion from floating point to integer
   \        0xA   0x2049             MOVS     R0,#+73
   \        0xC   0x.... 0x....      BL       _Z9code_seenc
   \       0x10   0x0007             MOVS     R7,R0
   \       0x12   0xD005             BEQ.N    ??gcode_M421_1
   \       0x14   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x18   0x.... 0x....      BL       __aeabi_f2iz
   \       0x1C   0x4604             MOV      R4,R0
   \       0x1E   0xB264             SXTB     R4,R4
   9673              if ((hasJ = code_seen('J'))) py = code_value_linear_units();
                                                     ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??gcode_M421_1: (+1)
   \       0x20   0x204A             MOVS     R0,#+74
   \       0x22   0x.... 0x....      BL       _Z9code_seenc
   \       0x26   0x4680             MOV      R8,R0
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD005             BEQ.N    ??gcode_M421_2
   \       0x2C   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x30   0x.... 0x....      BL       __aeabi_f2iz
   \       0x34   0x4605             MOV      R5,R0
   \       0x36   0xB26D             SXTB     R5,R5
   9674              if ((hasZ = code_seen('Z'))) z = code_value_linear_units();
   \                     ??gcode_M421_2: (+1)
   \       0x38   0x205A             MOVS     R0,#+90
   \       0x3A   0x.... 0x....      BL       _Z9code_seenc
   \       0x3E   0x4681             MOV      R9,R0
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD002             BEQ.N    ??gcode_M421_3
   \       0x44   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x48   0x4606             MOV      R6,R0
   9675          
   9676              if (hasI && hasJ && hasZ) {
   \                     ??gcode_M421_3: (+1)
   \       0x4A   0x2F00             CMP      R7,#+0
   \       0x4C   0xD029             BEQ.N    ??gcode_M421_4
   \       0x4E   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x52   0xD026             BEQ.N    ??gcode_M421_4
   \       0x54   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x58   0xD023             BEQ.N    ??gcode_M421_4
   9677                if (WITHIN(px, 0, GRID_MAX_POINTS_X - 1) && WITHIN(py, 0, GRID_MAX_POINTS_X - 1)) {
   \       0x5A   0x2C00             CMP      R4,#+0
   \       0x5C   0xD419             BMI.N    ??gcode_M421_5
   \       0x5E   0x4816             LDR.N    R0,??gcode_M421_0
   \       0x60   0xF890 0x1060      LDRB     R1,[R0, #+96]
   \       0x64   0x1E49             SUBS     R1,R1,#+1
   \       0x66   0x42A1             CMP      R1,R4
   \       0x68   0xDB13             BLT.N    ??gcode_M421_5
   \       0x6A   0x2D00             CMP      R5,#+0
   \       0x6C   0xD411             BMI.N    ??gcode_M421_5
   \       0x6E   0x42A9             CMP      R1,R5
   \       0x70   0xDB0F             BLT.N    ??gcode_M421_5
   9678                  //#if ENABLED(AUTO_BED_LEVELING_UBL)
   9679          		if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
   \       0x72   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \       0x76   0x2810             CMP      R0,#+16
   \       0x78   0xD105             BNE.N    ??gcode_M421_6
   9680                    ubl.z_values[px][py] = z;
   \       0x7A   0x4810             LDR.N    R0,??gcode_M421_0+0x4
   \       0x7C   0xEB00 0x1084      ADD      R0,R0,R4, LSL #+6
   \       0x80   0xF840 0x6025      STR      R6,[R0, R5, LSL #+2]
   \       0x84   0xE015             B.N      ??gcode_M421_7
   9681                  //#else
   9682                  else {
   9683                    z_values[px][py] = z;
   \                     ??gcode_M421_6: (+1)
   \       0x86   0x480E             LDR.N    R0,??gcode_M421_0+0x8
   \       0x88   0xEB00 0x1084      ADD      R0,R0,R4, LSL #+6
   \       0x8C   0xF840 0x6025      STR      R6,[R0, R5, LSL #+2]
   \       0x90   0xE00F             B.N      ??gcode_M421_7
   9684                    #if ENABLED(ABL_BILINEAR_SUBDIVISION)
   9685                      bed_level_virt_interpolate();
   9686                    #endif
   9687                  }//#endif
   9688                }
   9689                else {
   9690                  SERIAL_ERROR_START;
   \                     ??gcode_M421_5: (+1)
   \       0x92   0x480C             LDR.N    R0,??gcode_M421_0+0xC
   \       0x94   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9691                  SERIAL_ERRORLNPGM(MSG_ERR_MESH_XY);
   \       0x98   0x480B             LDR.N    R0,??gcode_M421_0+0x10
   \       0x9A   0xE8BD 0x43F2      POP      {R1,R4-R9,LR}
   \       0x9E   0x.... 0x....      B.W      _Z14serialprintPGMPKc
   9692                }
   9693              }
   9694              else {
   9695                SERIAL_ERROR_START;
   \                     ??gcode_M421_4: (+1)
   \       0xA2   0x4808             LDR.N    R0,??gcode_M421_0+0xC
   \       0xA4   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9696                SERIAL_ERRORLNPGM(MSG_ERR_M421_PARAMETERS);
   \       0xA8   0x4808             LDR.N    R0,??gcode_M421_0+0x14
   \       0xAA   0xE8BD 0x43F2      POP      {R1,R4-R9,LR}
   \       0xAE   0x.... 0x....      B.W      _Z14serialprintPGMPKc
   9697              }
   9698            }
   \                     ??gcode_M421_7: (+1)
   \       0xB2   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
   \       0xB6   0xBF00             Nop      
   \                     ??gcode_M421_0:
   \       0xB8   0x....'....        DC32     mksCfg
   \       0xBC   0x....'....        DC32     _ZN20unified_bed_leveling8z_valuesE
   \       0xC0   0x....'....        DC32     z_values
   \       0xC4   0x....'....        DC32     errormagic
   \       0xC8   0x....'....        DC32     _ZZ10gcode_M421vEs
   \       0xCC   0x....'....        DC32     _ZZ10gcode_M421vEs_0
   9699          
   9700          #endif
   9701          
   9702          //#if HAS_M206_COMMAND	//mks_delta
   9703          #if 1
   9704            /**
   9705             * M428: Set home_offset based on the distance between the
   9706             *       current_position and the nearest "reference point."
   9707             *       If an axis is past center its endstop position
   9708             *       is the reference-point. Otherwise it uses 0. This allows
   9709             *       the Z offset to be set near the bed when using a max endstop.
   9710             *
   9711             *       M428 can't be used more than 2cm away from 0 or an endstop.
   9712             *
   9713             *       Use M206 to set these values directly.
   9714             */

   \                                 In section .text, align 4
   9715            inline void gcode_M428() {
   \                     _Z10gcode_M428v: (+1)
   \        0x0   0x4846             LDR.N    R0,??gcode_M428_0
   \        0x2   0xF9B0 0x0058      LDRSH    R0,[R0, #+88]
   \        0x6   0x2802             CMP      R0,#+2
   \        0x8   0xD100             BNE.N    ??gcode_M428_1
   \        0xA   0x4770             BX       LR
   \                     ??gcode_M428_1: (+1)
   \        0xC   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   9716            	if(MACHINETPYE == DELTA) return;
   9717              bool err = false;
   \       0x10   0xF04F 0x0A00      MOV      R10,#+0
   9718              LOOP_XYZ(i) {
   \       0x14   0x4654             MOV      R4,R10
   \       0x16   0x4F42             LDR.N    R7,??gcode_M428_0+0x4
   \                     ??gcode_M428_2: (+1)
   \       0x18   0x2C03             CMP      R4,#+3
   \       0x1A   0xDA56             BGE.N    ??gcode_M428_3
   9719                if (axis_homed[i]) {
   \       0x1C   0x4841             LDR.N    R0,??gcode_M428_0+0x8
   \       0x1E   0x5D00             LDRB     R0,[R0, R4]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD037             BEQ.N    ??gcode_M428_4
   9720                  float base = (current_position[i] > (soft_endstop_min[i] + soft_endstop_max[i]) * 0.5) ? base_home_pos((AxisEnum)i) : 0,
   \       0x24   0xEB07 0x0584      ADD      R5,R7,R4, LSL #+2
   \       0x28   0x68AE             LDR      R6,[R5, #+8]
   \       0x2A   0x4630             MOV      R0,R6
   \       0x2C   0x.... 0x....      BL       __aeabi_f2d
   \       0x30   0x4602             MOV      R2,R0
   \       0x32   0x460B             MOV      R3,R1
   \       0x34   0x4690             MOV      R8,R2
   \       0x36   0x4699             MOV      R9,R3
   \       0x38   0x6D28             LDR      R0,[R5, #+80]
   \       0x3A   0x6DE9             LDR      R1,[R5, #+92]
   \       0x3C   0x.... 0x....      BL       __aeabi_fadd
   \       0x40   0x.... 0x....      BL       __aeabi_f2d
   \       0x44   0x4652             MOV      R2,R10
   \       0x46   0x4B38             LDR.N    R3,??gcode_M428_0+0xC  ;; 0x3fe00000
   \       0x48   0x.... 0x....      BL       __aeabi_dmul
   \       0x4C   0x4642             MOV      R2,R8
   \       0x4E   0x464B             MOV      R3,R9
   \       0x50   0x.... 0x....      BL       __aeabi_cdcmple
   \       0x54   0xD301             BCC.N    ??gcode_M428_5
   \       0x56   0x4650             MOV      R0,R10
   \       0x58   0xE003             B.N      ??gcode_M428_6
   \                     ??gcode_M428_5: (+1)
   \       0x5A   0x4620             MOV      R0,R4
   \       0x5C   0xB240             SXTB     R0,R0
   \       0x5E   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531913base_home_posE8AxisEnum
   9721                        diff = current_position[i] - LOGICAL_POSITION(base, i);
   \                     ??gcode_M428_6: (+1)
   \       0x62   0x6C69             LDR      R1,[R5, #+68]
   \       0x64   0x.... 0x....      BL       __aeabi_fadd
   \       0x68   0x4601             MOV      R1,R0
   \       0x6A   0x4630             MOV      R0,R6
   \       0x6C   0x.... 0x....      BL       __aeabi_fsub
   \       0x70   0x4602             MOV      R2,R0
   9722                  if (WITHIN(diff, -20, 20)) {
   \       0x72   0x492E             LDR.N    R1,??gcode_M428_0+0x10  ;; 0xc1a00000
   \       0x74   0x.... 0x....      BL       __aeabi_cfrcmple
   \       0x78   0xD80F             BHI.N    ??gcode_M428_7
   \       0x7A   0x492D             LDR.N    R1,??gcode_M428_0+0x14  ;; 0x41a00001
   \       0x7C   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x80   0xD20B             BCS.N    ??gcode_M428_7
   9723                    set_home_offset((AxisEnum)i, home_offset[i] - diff);
   \       0x82   0x6BA8             LDR      R0,[R5, #+56]
   \       0x84   0x4611             MOV      R1,R2
   \       0x86   0x.... 0x....      BL       __aeabi_fsub
   \       0x8A   0x4601             MOV      R1,R0
   \       0x8C   0x4620             MOV      R0,R4
   \       0x8E   0xB240             SXTB     R0,R0
   \       0x90   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531915set_home_offsetE8AxisEnumf
   9724                  }
   \                     ??gcode_M428_4: (+1)
   \       0x94   0x1C64             ADDS     R4,R4,#+1
   \       0x96   0xB2E4             UXTB     R4,R4
   \       0x98   0xE7BE             B.N      ??gcode_M428_2
   9725                  else {
   9726                    SERIAL_ERROR_START;
   \                     ??gcode_M428_7: (+1)
   \       0x9A   0x4826             LDR.N    R0,??gcode_M428_0+0x18
   \       0x9C   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9727                    SERIAL_ERRORLNPGM(MSG_ERR_M428_TOO_FAR);
   \       0xA0   0x4825             LDR.N    R0,??gcode_M428_0+0x1C
   \       0xA2   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9728                    LCD_ALERTMESSAGEPGM("Err: Too far!");
   \       0xA6   0x4825             LDR.N    R0,??gcode_M428_0+0x20
   \       0xA8   0x.... 0x....      BL       _Z21lcd_setalertstatuspgmPKc
   9729          		  BUZZ(200, 40);
   \       0xAC   0x20C8             MOVS     R0,#+200
   \       0xAE   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   \       0xB2   0x2028             MOVS     R0,#+40
   \       0xB4   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \       0xB8   0x466A             MOV      R2,SP
   \       0xBA   0xF10D 0x0102      ADD      R1,SP,#+2
   \       0xBE   0xF507 0x7066      ADD      R0,R7,#+920
   \       0xC2   0x.... 0x....      BL       _ZN6Buzzer4toneERKtS1_
   9730                    err = true;
   \       0xC6   0xF04F 0x0A01      MOV      R10,#+1
   9731                    break;
   9732                  }
   9733                }
   9734              }
   9735          
   9736              if (!err) {
   \                     ??gcode_M428_3: (+1)
   \       0xCA   0xF1BA 0x0F00      CMP      R10,#+0
   \       0xCE   0xD122             BNE.N    ??gcode_M428_8
   9737                SYNC_PLAN_POSITION_KINEMATIC();
   \       0xD0   0x.... 0x....      BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
   9738                report_current_position();
   \       0xD4   0x.... 0x....      BL       _ZN37_INTERNAL_15_Marlin_main_cpp_3178531923report_current_positionEv
   9739                LCD_MESSAGEPGM(MSG_HOME_OFFSETS_APPLIED);
   \       0xD8   0x2100             MOVS     R1,#+0
   \       0xDA   0x4819             LDR.N    R0,??gcode_M428_0+0x24
   \       0xDC   0x.... 0x....      BL       _Z16lcd_setstatuspgmPKch
   9740          	  BUZZ(100, 659);
   \       0xE0   0x2064             MOVS     R0,#+100
   \       0xE2   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   \       0xE6   0xF240 0x2093      MOVW     R0,#+659
   \       0xEA   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \       0xEE   0x4C15             LDR.N    R4,??gcode_M428_0+0x28
   \       0xF0   0x466A             MOV      R2,SP
   \       0xF2   0xF10D 0x0102      ADD      R1,SP,#+2
   \       0xF6   0x4620             MOV      R0,R4
   \       0xF8   0x.... 0x....      BL       _ZN6Buzzer4toneERKtS1_
   9741          	  BUZZ(100, 698);
   \       0xFC   0x2064             MOVS     R0,#+100
   \       0xFE   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   \      0x102   0xF240 0x20BA      MOVW     R0,#+698
   \      0x106   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \      0x10A   0x466A             MOV      R2,SP
   \      0x10C   0xF10D 0x0102      ADD      R1,SP,#+2
   \      0x110   0x4620             MOV      R0,R4
   \      0x112   0x.... 0x....      BL       _ZN6Buzzer4toneERKtS1_
   9742              }
   9743            }
   \                     ??gcode_M428_8: (+1)
   \      0x116   0xE8BD 0x87F3      POP      {R0,R1,R4-R10,PC}  ;; return
   \      0x11A   0xBF00             Nop      
   \                     ??gcode_M428_0:
   \      0x11C   0x....'....        DC32     mksCfg
   \      0x120   0x....'....        DC32     mks_heating_busy
   \      0x124   0x....'....        DC32     axis_homed
   \      0x128   0x3FE0'0000        DC32     0x3fe00000
   \      0x12C   0xC1A0'0000        DC32     0xc1a00000
   \      0x130   0x41A0'0001        DC32     0x41a00001
   \      0x134   0x....'....        DC32     errormagic
   \      0x138   0x....'....        DC32     _ZZ10gcode_M428vEs
   \      0x13C   0x....'....        DC32     _ZZ10gcode_M428vEs_0
   \      0x140   0x....'....        DC32     MSG_HOME_OFFSETS_APPLIED
   \      0x144   0x....'....        DC32     mks_heating_busy+0x398
   9744          
   9745          #endif // HAS_M206_COMMAND
   9746          
   9747          /**
   9748           * M500: Store settings in EEPROM
   9749           */

   \                                 In section .text, align 2
   9750          inline void gcode_M500() {
   9751            (void)settings.save();
   \                     _Z10gcode_M500v: (+1)
   \        0x0   0x.... 0x....      B.W      _ZN14MarlinSettings4saveEv
   9752          }
   9753          
   9754          /**
   9755           * M501: Read settings from EEPROM
   9756           */

   \                                 In section .text, align 2
   9757          inline void gcode_M501() {
   9758            (void)settings.load();
   \                     _Z10gcode_M501v: (+1)
   \        0x0   0x.... 0x....      B.W      _ZN14MarlinSettings4loadEv
   9759          }
   9760          
   9761          /**
   9762           * M502: Revert to default settings
   9763           */

   \                                 In section .text, align 2
   9764          inline void gcode_M502() {
   9765            (void)settings.reset();
   \                     _Z10gcode_M502v: (+1)
   \        0x0   0x.... 0x....      B.W      _ZN14MarlinSettings5resetEv
   9766          }
   9767          
   9768          /**
   9769           * M503: print settings currently in memory
   9770           */

   \                                 In section .text, align 2
   9771          inline void gcode_M503() {
   \                     _Z10gcode_M503v: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   9772            (void)settings.report(code_seen('S') && !code_value_bool());
   \        0x2   0x2053             MOVS     R0,#+83
   \        0x4   0x.... 0x....      BL       _Z9code_seenc
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD005             BEQ.N    ??gcode_M503_0
   \        0xC   0x.... 0x....      BL       _Z15code_value_boolv
   \       0x10   0x1E40             SUBS     R0,R0,#+1
   \       0x12   0x4180             SBCS     R0,R0,R0
   \       0x14   0x0FC0             LSRS     R0,R0,#+31
   \       0x16   0xE000             B.N      ??gcode_M503_1
   \                     ??gcode_M503_0: (+1)
   \       0x18   0x2000             MOVS     R0,#+0
   \                     ??gcode_M503_1: (+1)
   \       0x1A   0xE8BD 0x4002      POP      {R1,LR}
   \       0x1E   0x.... 0x....      B.W      _ZN14MarlinSettings6reportEb
   9773          }
   9774          
   9775          #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
   9776          
   9777            /**
   9778             * M540: Set whether SD card print should abort on endstop hit (M540 S<0|1>)
   9779             */
   9780            inline void gcode_M540() {
   9781              if (code_seen('S')) stepper.abort_on_endstop_hit = code_value_bool();
   9782            }
   9783          
   9784          #endif // ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
   9785          
   9786          #if HAS_BED_PROBE
   9787          

   \                                 In section .text, align 2, keep-with-next
   9788            void refresh_zprobe_zoffset(const bool no_babystep/*=false*/) {
   \                     _Z22refresh_zprobe_zoffsetb: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   9789              static float last_zoffset = NAN;
   9790          
   9791              if (!isnan(last_zoffset)) {
   \        0x4   0x.... 0x....      LDR.W    R4,??DataTable139
   \        0x8   0x6DE0             LDR      R0,[R4, #+92]
   \        0xA   0x.... 0x....      BL       _Z5isnanf
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD147             BNE.N    ??refresh_zprobe_zoffset_0
   9792          
   9793          	  /*--mks cfg--begin AUTO_BED_LEVELING_BILINEAR */
   9794          /*
   9795                #if ENABLED(AUTO_BED_LEVELING_BILINEAR) || ENABLED(BABYSTEP_ZPROBE_OFFSET) || ENABLED(DELTA)
   9796                  const float diff = zprobe_zoffset - last_zoffset;
   9797                #endif
   9798          */			  
   9799          	  float diff;
   9800          //#if  ENABLED(BABYSTEP_ZPROBE_OFFSET) || ENABLED(DELTA)
   9801          	if(MACHINETPYE == DELTA)
   \       0x12   0x....             LDR.N    R5,??DataTable136_8
   \       0x14   0xF105 0x0840      ADD      R8,R5,#+64
   \       0x18   0xF9B8 0x6018      LDRSH    R6,[R8, #+24]
   \       0x1C   0x2E02             CMP      R6,#+2
   \       0x1E   0xD104             BNE.N    ??refresh_zprobe_zoffset_1
   9802          		diff = zprobe_zoffset - last_zoffset;
   \       0x20   0x6CA0             LDR      R0,[R4, #+72]
   \       0x22   0x6DE1             LDR      R1,[R4, #+92]
   \       0x24   0x.... 0x....      BL       __aeabi_fsub
   \       0x28   0x4607             MOV      R7,R0
   9803          //#endif	  
   9804          	if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
   \                     ??refresh_zprobe_zoffset_1: (+1)
   \       0x2A   0xF898 0x8000      LDRB     R8,[R8, #+0]
   \       0x2E   0xF1B8 0x0F08      CMP      R8,#+8
   \       0x32   0xD104             BNE.N    ??refresh_zprobe_zoffset_2
   9805          		diff = zprobe_zoffset - last_zoffset;
   \       0x34   0x6CA0             LDR      R0,[R4, #+72]
   \       0x36   0x6DE1             LDR      R1,[R4, #+92]
   \       0x38   0x.... 0x....      BL       __aeabi_fsub
   \       0x3C   0x4607             MOV      R7,R0
   9806          	  /*--mks cfg--end AUTO_BED_LEVELING_BILINEAR */
   9807          
   9808          	  /*--mks cfg--begin AUTO_BED_LEVELING_BILINEAR */
   9809          /*
   9810                #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
   9811                  // Correct bilinear grid for new probe offset
   9812                  if (diff) {
   9813                    for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
   9814                      for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
   9815                        z_values[x][y] -= diff;
   9816                  }
   9817                  #if ENABLED(ABL_BILINEAR_SUBDIVISION)
   9818                    bed_level_virt_interpolate();
   9819                  #endif
   9820                #endif
   9821          */
   9822          	if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
   \                     ??refresh_zprobe_zoffset_2: (+1)
   \       0x3E   0xF1B8 0x0F08      CMP      R8,#+8
   \       0x42   0xD126             BNE.N    ??refresh_zprobe_zoffset_3
   9823          		{
   9824                  // Correct bilinear grid for new probe offset
   9825                  if (diff) {
   \       0x44   0x4638             MOV      R0,R7
   \       0x46   0x2100             MOVS     R1,#+0
   \       0x48   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0x4C   0xD021             BEQ.N    ??refresh_zprobe_zoffset_3
   9826                    for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
   \       0x4E   0x4689             MOV      R9,R1
   \       0x50   0xF105 0x0860      ADD      R8,R5,#+96
   \       0x54   0xE016             B.N      ??refresh_zprobe_zoffset_4
   9827                      for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
   9828                        z_values[x][y] -= diff;
   \                     ??refresh_zprobe_zoffset_5: (+1)
   \       0x56   0x.... 0x....      LDR.W    R0,??DataTable139_1
   \       0x5A   0xEB00 0x1B89      ADD      R11,R0,R9, LSL #+6
   \       0x5E   0xF85B 0x002A      LDR      R0,[R11, R10, LSL #+2]
   \       0x62   0x4639             MOV      R1,R7
   \       0x64   0x.... 0x....      BL       __aeabi_fsub
   \       0x68   0xF84B 0x002A      STR      R0,[R11, R10, LSL #+2]
   \       0x6C   0xF10A 0x0A01      ADD      R10,R10,#+1
   \       0x70   0xFA5F 0xFA8A      UXTB     R10,R10
   \                     ??refresh_zprobe_zoffset_6: (+1)
   \       0x74   0xF898 0x0001      LDRB     R0,[R8, #+1]
   \       0x78   0x4582             CMP      R10,R0
   \       0x7A   0xDBEC             BLT.N    ??refresh_zprobe_zoffset_5
   \       0x7C   0xF109 0x0901      ADD      R9,R9,#+1
   \       0x80   0xFA5F 0xF989      UXTB     R9,R9
   \                     ??refresh_zprobe_zoffset_4: (+1)
   \       0x84   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \       0x88   0x4581             CMP      R9,R0
   \       0x8A   0xDA02             BGE.N    ??refresh_zprobe_zoffset_3
   \       0x8C   0xF04F 0x0A00      MOV      R10,#+0
   \       0x90   0xE7F0             B.N      ??refresh_zprobe_zoffset_6
   9829                  }
   9830            #if ENABLED(ABL_BILINEAR_SUBDIVISION)
   9831                    bed_level_virt_interpolate();
   9832            #endif
   9833          		}
   9834          	  /*--mks cfg--end AUTO_BED_LEVELING_BILINEAR */
   9835          
   9836                #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
   9837                  if (!no_babystep && planner.abl_enabled)
   9838                    thermalManager.babystep_axis(Z_AXIS, -lround(diff * planner.axis_steps_per_mm[Z_AXIS]));
   9839                #else
   9840                  UNUSED(no_babystep);
   9841                #endif
   9842          
   9843                //#if ENABLED(DELTA) // correct the delta_height
   9844          	  if(MACHINETPYE == DELTA)
   \                     ??refresh_zprobe_zoffset_3: (+1)
   \       0x92   0x2E02             CMP      R6,#+2
   \       0x94   0xD105             BNE.N    ??refresh_zprobe_zoffset_0
   9845                  home_offset[Z_AXIS] -= diff;
   \       0x96   0x....             LDR.N    R5,??DataTable136_2
   \       0x98   0x6C28             LDR      R0,[R5, #+64]
   \       0x9A   0x4639             MOV      R1,R7
   \       0x9C   0x.... 0x....      BL       __aeabi_fsub
   \       0xA0   0x6428             STR      R0,[R5, #+64]
   9846               // #endif
   9847              }
   9848          
   9849              last_zoffset = zprobe_zoffset;
   \                     ??refresh_zprobe_zoffset_0: (+1)
   \       0xA2   0x6CA0             LDR      R0,[R4, #+72]
   \       0xA4   0x65E0             STR      R0,[R4, #+92]
   9850            }
   \       0xA6   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
   9851          

   \                                 In section .text, align 4
   9852            inline void gcode_M851() {
   \                     _Z10gcode_M851v: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   9853              SERIAL_ECHO_START;
   \        0x2   0x4826             LDR.N    R0,??gcode_M851_0
   \        0x4   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9854              SERIAL_ECHOPGM(MSG_ZPROBE_ZOFFSET " ");
   \        0x8   0x4825             LDR.N    R0,??gcode_M851_0+0x4
   \        0xA   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9855              if (code_seen('Z')) {
   \        0xE   0x205A             MOVS     R0,#+90
   \       0x10   0x.... 0x....      BL       _Z9code_seenc
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD029             BEQ.N    ??gcode_M851_1
   9856                const float value = code_value_linear_units();
   \       0x18   0x.... 0x....      BL       _Z16code_value_floatv
   9857                if (WITHIN(value, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
   \       0x1C   0x4921             LDR.N    R1,??gcode_M851_0+0x8  ;; 0xc1a00000
   \       0x1E   0x.... 0x....      BL       __aeabi_cfrcmple
   \       0x22   0xD81F             BHI.N    ??gcode_M851_2
   \       0x24   0x4920             LDR.N    R1,??gcode_M851_0+0xC  ;; 0x41a00001
   \       0x26   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x2A   0xD21B             BCS.N    ??gcode_M851_2
   9858                  zprobe_zoffset = value;
   \       0x2C   0x4C1F             LDR.N    R4,??gcode_M851_0+0x10
   \       0x2E   0x64A0             STR      R0,[R4, #+72]
   9859                  refresh_zprobe_zoffset();
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x.... 0x....      BL       _Z22refresh_zprobe_zoffsetb
   9860                  SERIAL_ECHO(zprobe_zoffset);
   \       0x36   0x6CA0             LDR      R0,[R4, #+72]
   \       0x38   0x.... 0x....      BL       __aeabi_f2d
   \       0x3C   0x4A1C             LDR.N    R2,??gcode_M851_0+0x14
   \       0x3E   0x79D2             LDRB     R2,[R2, #+7]
   \       0x40   0x2A00             CMP      R2,#+0
   \       0x42   0xD107             BNE.N    ??gcode_M851_3
   \       0x44   0x2202             MOVS     R2,#+2
   \       0x46   0x9200             STR      R2,[SP, #+0]
   \       0x48   0x4602             MOV      R2,R0
   \       0x4A   0x460B             MOV      R3,R1
   \       0x4C   0x4819             LDR.N    R0,??gcode_M851_0+0x18
   \       0x4E   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   \       0x52   0xE010             B.N      ??gcode_M851_4
   \                     ??gcode_M851_3: (+1)
   \       0x54   0x2202             MOVS     R2,#+2
   \       0x56   0x9200             STR      R2,[SP, #+0]
   \       0x58   0x4602             MOV      R2,R0
   \       0x5A   0x460B             MOV      R3,R1
   \       0x5C   0x4816             LDR.N    R0,??gcode_M851_0+0x1C
   \       0x5E   0x.... 0x....      BL       _ZN12MarlinSerial5printEdi
   \       0x62   0xE008             B.N      ??gcode_M851_4
   9861                }
   9862                else
   9863                  SERIAL_ECHOPGM(MSG_Z_MIN " " STRINGIFY(Z_PROBE_OFFSET_RANGE_MIN) " " MSG_Z_MAX " " STRINGIFY(Z_PROBE_OFFSET_RANGE_MAX));
   \                     ??gcode_M851_2: (+1)
   \       0x64   0x4815             LDR.N    R0,??gcode_M851_0+0x20
   \       0x66   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \       0x6A   0xE004             B.N      ??gcode_M851_4
   9864              }
   9865              else
   9866                SERIAL_ECHOPAIR(": ", zprobe_zoffset);
   \                     ??gcode_M851_1: (+1)
   \       0x6C   0x480F             LDR.N    R0,??gcode_M851_0+0x10
   \       0x6E   0x6C81             LDR      R1,[R0, #+72]
   \       0x70   0x4813             LDR.N    R0,??gcode_M851_0+0x24
   \       0x72   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   9867          
   9868              SERIAL_EOL;
   \                     ??gcode_M851_4: (+1)
   \       0x76   0x480E             LDR.N    R0,??gcode_M851_0+0x14
   \       0x78   0x79C0             LDRB     R0,[R0, #+7]
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD105             BNE.N    ??gcode_M851_5
   \       0x7E   0x210A             MOVS     R1,#+10
   \       0x80   0x480C             LDR.N    R0,??gcode_M851_0+0x18
   \       0x82   0xE8BD 0x401C      POP      {R2-R4,LR}
   \       0x86   0x.... 0x....      B.W      _ZN12MarlinSerial5writeEh
   \                     ??gcode_M851_5: (+1)
   \       0x8A   0x2200             MOVS     R2,#+0
   \       0x8C   0x210A             MOVS     R1,#+10
   \       0x8E   0x480A             LDR.N    R0,??gcode_M851_0+0x1C
   \       0x90   0xB002             ADD      SP,SP,#+8
   \       0x92   0xE8BD 0x4010      POP      {R4,LR}
   \       0x96   0x.... 0x....      B.W      _ZN12MarlinSerial5printEci
   \       0x9A   0xBF00             Nop      
   \                     ??gcode_M851_0:
   \       0x9C   0x....'....        DC32     echomagic
   \       0xA0   0x....'....        DC32     _ZZ10gcode_M851vEs
   \       0xA4   0xC1A0'0000        DC32     0xc1a00000
   \       0xA8   0x41A0'0001        DC32     0x41a00001
   \       0xAC   0x....'....        DC32     axis_homed
   \       0xB0   0x....'....        DC32     mks_heating_busy
   \       0xB4   0x....'....        DC32     customizedSerial
   \       0xB8   0x....'....        DC32     serial2
   \       0xBC   0x....'....        DC32     _ZZ10gcode_M851vEs_0
   \       0xC0   0x....'....        DC32     _ZZ10gcode_M851vEs_1
   9869            }
   9870          
   9871          #endif // HAS_BED_PROBE
   9872          
   9873          #if ENABLED(FILAMENT_CHANGE_FEATURE)
   9874          

   \                                 In section .text, align 2, keep-with-next
   9875            void filament_change_beep(const bool init=false) {
   \                     _Z20filament_change_beepb: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   9876              static millis_t next_buzz = 0;
   9877              static uint16_t runout_beep = 0;
   9878          
   9879              if (init) next_buzz = runout_beep = 0;
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable139_2
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD002             BEQ.N    ??filament_change_beep_0
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x8020             STRH     R0,[R4, #+0]
   \        0xE   0x6060             STR      R0,[R4, #+4]
   9880          
   9881              const millis_t ms = millis();
   \                     ??filament_change_beep_0: (+1)
   \       0x10   0x.... 0x....      BL       HAL_GetTick
   9882              if (ELAPSED(ms, next_buzz)) {
   \       0x14   0x6861             LDR      R1,[R4, #+4]
   \       0x16   0x1A41             SUBS     R1,R0,R1
   \       0x18   0xD41D             BMI.N    ??filament_change_beep_1
   9883                if (runout_beep <= FILAMENT_CHANGE_NUMBER_OF_ALERT_BEEPS + 5) { // Only beep as long as we're supposed to
   \       0x1A   0x8821             LDRH     R1,[R4, #+0]
   \       0x1C   0x290B             CMP      R1,#+11
   \       0x1E   0xDA1A             BGE.N    ??filament_change_beep_1
   9884                  next_buzz = ms + (runout_beep <= FILAMENT_CHANGE_NUMBER_OF_ALERT_BEEPS ? 2500 : 400);
   \       0x20   0x2906             CMP      R1,#+6
   \       0x22   0xDA02             BGE.N    ??filament_change_beep_2
   \       0x24   0xF640 0x11C4      MOVW     R1,#+2500
   \       0x28   0xE001             B.N      ??filament_change_beep_3
   \                     ??filament_change_beep_2: (+1)
   \       0x2A   0xF44F 0x71C8      MOV      R1,#+400
   \                     ??filament_change_beep_3: (+1)
   \       0x2E   0x1808             ADDS     R0,R1,R0
   \       0x30   0x6060             STR      R0,[R4, #+4]
   9885          		BUZZ(300, 2000);
   \       0x32   0xF44F 0x7096      MOV      R0,#+300
   \       0x36   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   \       0x3A   0xF44F 0x60FA      MOV      R0,#+2000
   \       0x3E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \       0x42   0x466A             MOV      R2,SP
   \       0x44   0xF10D 0x0102      ADD      R1,SP,#+2
   \       0x48   0x.... 0x....      LDR.W    R0,??DataTable139_3
   \       0x4C   0x.... 0x....      BL       _ZN6Buzzer4toneERKtS1_
   9886                  runout_beep++;
   \       0x50   0x8820             LDRH     R0,[R4, #+0]
   \       0x52   0x1C40             ADDS     R0,R0,#+1
   \       0x54   0x8020             STRH     R0,[R4, #+0]
   9887                }
   9888              }
   9889            }
   \                     ??filament_change_beep_1: (+1)
   \       0x56   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   9890          
   9891            static bool busy_doing_M600 = false;
   9892          
   9893            /**
   9894             * M600: Pause for filament change
   9895             *
   9896             *  E[distance] - Retract the filament this far (negative value)
   9897             *  Z[distance] - Move the Z axis by this distance
   9898             *  X[position] - Move to this X position, with Y
   9899             *  Y[position] - Move to this Y position, with X
   9900             *  L[distance] - Retract distance for removal (manual reload)
   9901             *
   9902             *  Default values are used for omitted arguments.
   9903             *
   9904             */

   \                                 In section .text, align 4
   9905            inline void gcode_M600() {
   \                     _Z10gcode_M600v: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB086             SUB      SP,SP,#+24
   9906          
   9907              if (!DEBUGGING(DRYRUN) && thermalManager.tooColdToExtrude(active_extruder)) {
   \        0x6   0xF8DF 0x5388      LDR.W    R5,??gcode_M600_0
   \        0xA   0x7868             LDRB     R0,[R5, #+1]
   \        0xC   0x0700             LSLS     R0,R0,#+28
   \        0xE   0xD40D             BMI.N    ??gcode_M600_1
   \       0x10   0x78A8             LDRB     R0,[R5, #+2]
   \       0x12   0x.... 0x....      BL       _ZN11Temperature16tooColdToExtrudeEh
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD008             BEQ.N    ??gcode_M600_1
   9908                SERIAL_ERROR_START;
   \       0x1A   0xF8DF 0x0378      LDR.W    R0,??gcode_M600_0+0x4
   \       0x1E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9909                SERIAL_ERRORLNPGM(MSG_TOO_COLD_FOR_M600);
   \       0x22   0xF8DF 0x0374      LDR.W    R0,??gcode_M600_0+0x8
   \       0x26   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9910                return;
   \       0x2A   0xE19E             B.N      ??gcode_M600_2
   9911              }
   9912          
   9913              busy_doing_M600 = true;  // Stepper Motors can't timeout when this is set
   \                     ??gcode_M600_1: (+1)
   \       0x2C   0xF8DF 0x636C      LDR.W    R6,??gcode_M600_0+0xC
   \       0x30   0x2001             MOVS     R0,#+1
   \       0x32   0x73F0             STRB     R0,[R6, #+15]
   9914          	
   9915          
   9916              // Pause the print job timer
   9917              const bool job_running = print_job_timer.isRunning();
   \       0x34   0xF505 0x7762      ADD      R7,R5,#+904
   \       0x38   0x4638             MOV      R0,R7
   \       0x3A   0x.... 0x....      BL       _ZN9Stopwatch9isRunningEv
   \       0x3E   0x4680             MOV      R8,R0
   9918          
   9919              print_job_timer.pause();
   \       0x40   0x4638             MOV      R0,R7
   \       0x42   0x.... 0x....      BL       _ZN9Stopwatch5pauseEv
   9920          
   9921              // Show initial message and wait for synchronize steppers
   9922              lcd_filament_change_show_message(FILAMENT_CHANGE_MESSAGE_INIT);
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0x.... 0x....      BL       _Z32lcd_filament_change_show_message21FilamentChangeMessage
   9923              stepper.synchronize();
   \       0x4C   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   9924          
   9925              // Save current position of all axes
   9926              float lastpos[XYZE];
   9927              COPY(lastpos, current_position);
   \       0x50   0x2210             MOVS     R2,#+16
   \       0x52   0xF105 0x0108      ADD      R1,R5,#+8
   \       0x56   0xA801             ADD      R0,SP,#+4
   \       0x58   0x.... 0x....      BL       __aeabi_memcpy
   9928              set_destination_to_current();
   \       0x5C   0x.... 0x....      BL       _Z26set_destination_to_currentv
   9929          
   9930              // Initial retract before move to filament change position
   9931              destination[E_AXIS] += code_seen('E') ? code_value_axis_units(E_AXIS) : 0
   9932                #if defined(FILAMENT_CHANGE_RETRACT_LENGTH) && FILAMENT_CHANGE_RETRACT_LENGTH > 0
   9933                  - (FILAMENT_CHANGE_RETRACT_LENGTH)
   9934                #endif
   9935              ;
   \       0x60   0x2045             MOVS     R0,#+69
   \       0x62   0x.... 0x....      BL       _Z9code_seenc
   \       0x66   0x2800             CMP      R0,#+0
   \       0x68   0xD003             BEQ.N    ??gcode_M600_3
   \       0x6A   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x6E   0x4601             MOV      R1,R0
   \       0x70   0xE001             B.N      ??gcode_M600_4
   \                     ??gcode_M600_3: (+1)
   \       0x72   0xF04F 0x4140      MOV      R1,#-1073741824
   \                     ??gcode_M600_4: (+1)
   \       0x76   0x6A68             LDR      R0,[R5, #+36]
   \       0x78   0x.... 0x....      BL       __aeabi_fadd
   \       0x7C   0x6268             STR      R0,[R5, #+36]
   9936          
   9937              RUNPLAN(FILAMENT_CHANGE_RETRACT_FEEDRATE);
   \       0x7E   0x48C8             LDR.N    R0,??gcode_M600_0+0x10  ;; 0x42700000
   \       0x80   0x.... 0x....      BL       _Z7RUNPLANf
   9938          
   9939              // Lift Z axis
   9940          /*    
   9941              float z_lift = code_seen('Z') ? code_value_linear_units() :
   9942                #if defined(FILAMENT_CHANGE_Z_ADD) && FILAMENT_CHANGE_Z_ADD > 0
   9943                  FILAMENT_CHANGE_Z_ADD
   9944                #else
   9945                  0
   9946                #endif
   9947              ;
   9948          */
   9949              float z_lift = code_seen('Z') ? code_value_linear_units() :FILAMENT_CHANGE_Z_ADD;
   \       0x84   0xF8DF 0x931C      LDR.W    R9,??gcode_M600_0+0x14
   \       0x88   0x205A             MOVS     R0,#+90
   \       0x8A   0x.... 0x....      BL       _Z9code_seenc
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xD003             BEQ.N    ??gcode_M600_5
   \       0x92   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x96   0x4604             MOV      R4,R0
   \       0x98   0xE002             B.N      ??gcode_M600_6
   \                     ??gcode_M600_5: (+1)
   \       0x9A   0xF109 0x00D4      ADD      R0,R9,#+212
   \       0x9E   0x6884             LDR      R4,[R0, #+8]
   9950              
   9951              if (z_lift > 0) {
   \                     ??gcode_M600_6: (+1)
   \       0xA0   0x4620             MOV      R0,R4
   \       0xA2   0x2100             MOVS     R1,#+0
   \       0xA4   0x.... 0x....      BL       __aeabi_cfrcmple
   \       0xA8   0xD212             BCS.N    ??gcode_M600_7
   9952                destination[Z_AXIS] += z_lift;
   \       0xAA   0x6A28             LDR      R0,[R5, #+32]
   \       0xAC   0x4621             MOV      R1,R4
   \       0xAE   0x.... 0x....      BL       __aeabi_fadd
   \       0xB2   0x4601             MOV      R1,R0
   \       0xB4   0x6229             STR      R1,[R5, #+32]
   9953                NOMORE(destination[Z_AXIS], Z_MAX_POS);
   \       0xB6   0xF8D9 0x001C      LDR      R0,[R9, #+28]
   \       0xBA   0x.... 0x....      BL       __aeabi_cfcmple
   \       0xBE   0xD200             BCS.N    ??gcode_M600_8
   \       0xC0   0x6228             STR      R0,[R5, #+32]
   9954                RUNPLAN(FILAMENT_CHANGE_Z_FEEDRATE);
   \                     ??gcode_M600_8: (+1)
   \       0xC2   0xF8D9 0x0028      LDR      R0,[R9, #+40]
   \       0xC6   0x49B6             LDR.N    R1,??gcode_M600_0+0x10  ;; 0x42700000
   \       0xC8   0x.... 0x....      BL       __aeabi_fdiv
   \       0xCC   0x.... 0x....      BL       _Z7RUNPLANf
   9955              }
   9956          
   9957              // Move XY axes to filament exchange position
   9958              if (code_seen('X')) destination[X_AXIS] = code_value_linear_units();
   \                     ??gcode_M600_7: (+1)
   \       0xD0   0x2058             MOVS     R0,#+88
   \       0xD2   0x.... 0x....      BL       _Z9code_seenc
   \       0xD6   0x2800             CMP      R0,#+0
   \       0xD8   0xD003             BEQ.N    ??gcode_M600_9
   \       0xDA   0x.... 0x....      BL       _Z16code_value_floatv
   \       0xDE   0x61A8             STR      R0,[R5, #+24]
   \       0xE0   0xE002             B.N      ??gcode_M600_10
   9959              #ifdef FILAMENT_CHANGE_X_POS
   9960                else destination[X_AXIS] = FILAMENT_CHANGE_X_POS;
   \                     ??gcode_M600_9: (+1)
   \       0xE2   0xF8D9 0x00D4      LDR      R0,[R9, #+212]
   \       0xE6   0x61A8             STR      R0,[R5, #+24]
   9961              #endif
   9962          
   9963              if (code_seen('Y')) destination[Y_AXIS] = code_value_linear_units();
   \                     ??gcode_M600_10: (+1)
   \       0xE8   0x2059             MOVS     R0,#+89
   \       0xEA   0x.... 0x....      BL       _Z9code_seenc
   \       0xEE   0x2800             CMP      R0,#+0
   \       0xF0   0xD003             BEQ.N    ??gcode_M600_11
   \       0xF2   0x.... 0x....      BL       _Z16code_value_floatv
   \       0xF6   0x61E8             STR      R0,[R5, #+28]
   \       0xF8   0xE003             B.N      ??gcode_M600_12
   9964              #ifdef FILAMENT_CHANGE_Y_POS
   9965                else destination[Y_AXIS] = FILAMENT_CHANGE_Y_POS;
   \                     ??gcode_M600_11: (+1)
   \       0xFA   0xF109 0x00D4      ADD      R0,R9,#+212
   \       0xFE   0x6840             LDR      R0,[R0, #+4]
   \      0x100   0x61E8             STR      R0,[R5, #+28]
   9966              #endif
   9967          
   9968              RUNPLAN(FILAMENT_CHANGE_XY_FEEDRATE);
   \                     ??gcode_M600_12: (+1)
   \      0x102   0xF8D9 0x0024      LDR      R0,[R9, #+36]
   \      0x106   0x49A6             LDR.N    R1,??gcode_M600_0+0x10  ;; 0x42700000
   \      0x108   0x.... 0x....      BL       __aeabi_fdiv
   \      0x10C   0x.... 0x....      BL       _Z7RUNPLANf
   9969          
   9970              stepper.synchronize();
   \      0x110   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   9971              lcd_filament_change_show_message(FILAMENT_CHANGE_MESSAGE_UNLOAD);
   \      0x114   0x2001             MOVS     R0,#+1
   \      0x116   0x.... 0x....      BL       _Z32lcd_filament_change_show_message21FilamentChangeMessage
   9972              idle();
   \      0x11A   0x2000             MOVS     R0,#+0
   \      0x11C   0x.... 0x....      BL       _Z4idleb
   9973          
   9974              // Unload filament
   9975              destination[E_AXIS] += code_seen('L') ? code_value_axis_units(E_AXIS) : 0
   9976                #if FILAMENT_CHANGE_UNLOAD_LENGTH > 0
   9977                  - (FILAMENT_CHANGE_UNLOAD_LENGTH)
   9978                #endif
   9979              ;
   \      0x120   0x204C             MOVS     R0,#+76
   \      0x122   0x.... 0x....      BL       _Z9code_seenc
   \      0x126   0x2800             CMP      R0,#+0
   \      0x128   0xD003             BEQ.N    ??gcode_M600_13
   \      0x12A   0x.... 0x....      BL       _Z16code_value_floatv
   \      0x12E   0x4601             MOV      R1,R0
   \      0x130   0xE000             B.N      ??gcode_M600_14
   \                     ??gcode_M600_13: (+1)
   \      0x132   0x499D             LDR.N    R1,??gcode_M600_0+0x18  ;; 0xc2c80000
   \                     ??gcode_M600_14: (+1)
   \      0x134   0x6A68             LDR      R0,[R5, #+36]
   \      0x136   0x.... 0x....      BL       __aeabi_fadd
   \      0x13A   0x6268             STR      R0,[R5, #+36]
   9980          
   9981              RUNPLAN(FILAMENT_CHANGE_UNLOAD_FEEDRATE);
   \      0x13C   0x489B             LDR.N    R0,??gcode_M600_0+0x1C  ;; 0x41200000
   \      0x13E   0x.... 0x....      BL       _Z7RUNPLANf
   9982          
   9983              // Synchronize steppers and then disable extruders steppers for manual filament changing
   9984              stepper.synchronize();
   \      0x142   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   9985              disable_e_steppers();
   \      0x146   0x.... 0x....      BL       _Z18disable_e_steppersv
   9986              safe_delay(100);
   \      0x14A   0x2064             MOVS     R0,#+100
   \      0x14C   0x.... 0x....      BL       _Z10safe_delaym
   9987          
   9988              const millis_t nozzle_timeout = millis() + (millis_t)(FILAMENT_CHANGE_NOZZLE_TIMEOUT) * 1000UL;
   \      0x150   0x.... 0x....      BL       HAL_GetTick
   \      0x154   0x4682             MOV      R10,R0
   \      0x156   0xF50A 0x4A2F      ADD      R10,R10,#+44800
   \      0x15A   0xF10A 0x0AC8      ADD      R10,R10,#+200
   9989              bool nozzle_timed_out = false;
   \      0x15E   0x2400             MOVS     R4,#+0
   9990          
   9991              // Wait for filament insert by user and press button
   9992              lcd_filament_change_show_message(FILAMENT_CHANGE_MESSAGE_INSERT);
   \      0x160   0x2002             MOVS     R0,#+2
   \      0x162   0x.... 0x....      BL       _Z32lcd_filament_change_show_message21FilamentChangeMessage
   9993          
   9994              #if HAS_BUZZER
   9995                filament_change_beep(true);
   \      0x166   0x2001             MOVS     R0,#+1
   \      0x168   0x.... 0x....      BL       _Z20filament_change_beepb
   9996              #endif
   9997          
   9998              idle();
   \      0x16C   0x4620             MOV      R0,R4
   \      0x16E   0x.... 0x....      BL       _Z4idleb
   9999          
  10000              int16_t temps[HOTENDS];
  10001              HOTEND_LOOP() temps[e] = thermalManager.target_temperature[e]; // Save nozzle temps
   \      0x172   0x4620             MOV      R0,R4
   \      0x174   0x466A             MOV      R2,SP
   \      0x176   0xE006             B.N      ??gcode_M600_15
   \                     ??gcode_M600_16: (+1)
   \      0x178   0x498D             LDR.N    R1,??gcode_M600_0+0x20
   \      0x17A   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \      0x17E   0xF822 0x1010      STRH     R1,[R2, R0, LSL #+1]
   \      0x182   0x1C40             ADDS     R0,R0,#+1
   \      0x184   0xB240             SXTB     R0,R0
   \                     ??gcode_M600_15: (+1)
   \      0x186   0x2800             CMP      R0,#+0
   \      0x188   0xDDF6             BLE.N    ??gcode_M600_16
  10002          
  10003              KEEPALIVE_STATE(PAUSED_FOR_USER);
   \      0x18A   0x2003             MOVS     R0,#+3
   \      0x18C   0x71A8             STRB     R0,[R5, #+6]
  10004              wait_for_user = true;    // LCD click or M108 will clear this
   \      0x18E   0x2001             MOVS     R0,#+1
   \      0x190   0x7128             STRB     R0,[R5, #+4]
   \      0x192   0xE010             B.N      ??gcode_M600_17
  10005              while (wait_for_user) {
  10006          
  10007                if (nozzle_timed_out)
  10008                  lcd_filament_change_show_message(FILAMENT_CHANGE_MESSAGE_CLICK_TO_HEAT_NOZZLE);
  10009          
  10010                #if HAS_BUZZER
  10011                  filament_change_beep();
  10012                #endif
  10013          
  10014                if (!nozzle_timed_out && ELAPSED(millis(), nozzle_timeout)) {
  10015                  nozzle_timed_out = true; // on nozzle timeout remember the nozzles need to be reheated
  10016                  HOTEND_LOOP() thermalManager.setTargetHotend(0, e); // Turn off all the nozzles
   \                     ??gcode_M600_18: (+1)
   \      0x194   0x4659             MOV      R1,R11
   \      0x196   0xB2C9             UXTB     R1,R1
   \      0x198   0x2000             MOVS     R0,#+0
   \      0x19A   0x.... 0x....      BL       _ZN11Temperature15setTargetHotendEfh
   \      0x19E   0xF10B 0x0B01      ADD      R11,R11,#+1
   \                     ??gcode_M600_19: (+1)
   \      0x1A2   0x4658             MOV      R0,R11
   \      0x1A4   0xB240             SXTB     R0,R0
   \      0x1A6   0x2800             CMP      R0,#+0
   \      0x1A8   0xDDF4             BLE.N    ??gcode_M600_18
  10017                  lcd_filament_change_show_message(FILAMENT_CHANGE_MESSAGE_CLICK_TO_HEAT_NOZZLE);
   \      0x1AA   0x2008             MOVS     R0,#+8
   \      0x1AC   0x.... 0x....      BL       _Z32lcd_filament_change_show_message21FilamentChangeMessage
  10018                }
  10019                idle(true);
   \                     ??gcode_M600_20: (+1)
   \      0x1B0   0x2001             MOVS     R0,#+1
   \      0x1B2   0x.... 0x....      BL       _Z4idleb
   \                     ??gcode_M600_17: (+1)
   \      0x1B6   0x7928             LDRB     R0,[R5, #+4]
   \      0x1B8   0x2800             CMP      R0,#+0
   \      0x1BA   0xD012             BEQ.N    ??gcode_M600_21
   \      0x1BC   0x2C00             CMP      R4,#+0
   \      0x1BE   0xD002             BEQ.N    ??gcode_M600_22
   \      0x1C0   0x2008             MOVS     R0,#+8
   \      0x1C2   0x.... 0x....      BL       _Z32lcd_filament_change_show_message21FilamentChangeMessage
   \                     ??gcode_M600_22: (+1)
   \      0x1C6   0x2000             MOVS     R0,#+0
   \      0x1C8   0x.... 0x....      BL       _Z20filament_change_beepb
   \      0x1CC   0x2C00             CMP      R4,#+0
   \      0x1CE   0xD1EF             BNE.N    ??gcode_M600_20
   \      0x1D0   0x.... 0x....      BL       HAL_GetTick
   \      0x1D4   0xEBB0 0x000A      SUBS     R0,R0,R10
   \      0x1D8   0xD4EA             BMI.N    ??gcode_M600_20
   \      0x1DA   0x2401             MOVS     R4,#+1
   \      0x1DC   0xF04F 0x0B00      MOV      R11,#+0
   \      0x1E0   0xE7DF             B.N      ??gcode_M600_19
  10020              }
  10021              KEEPALIVE_STATE(IN_HANDLER);
   \                     ??gcode_M600_21: (+1)
   \      0x1E2   0x2001             MOVS     R0,#+1
   \      0x1E4   0x71A8             STRB     R0,[R5, #+6]
  10022          
  10023              if (nozzle_timed_out)      // Turn nozzles back on if they were turned off
   \      0x1E6   0x2C00             CMP      R4,#+0
   \      0x1E8   0xD015             BEQ.N    ??gcode_M600_23
  10024                HOTEND_LOOP() thermalManager.setTargetHotend(temps[e], e);
   \      0x1EA   0xF04F 0x0B00      MOV      R11,#+0
   \      0x1EE   0xE00F             B.N      ??gcode_M600_24
   \                     ??gcode_M600_25: (+1)
   \      0x1F0   0x4658             MOV      R0,R11
   \      0x1F2   0x4601             MOV      R1,R0
   \      0x1F4   0xB2C9             UXTB     R1,R1
   \      0x1F6   0x468A             MOV      R10,R1
   \      0x1F8   0x4668             MOV      R0,SP
   \      0x1FA   0xF930 0x001B      LDRSH    R0,[R0, R11, LSL #+1]
   \      0x1FE   0x.... 0x....      BL       __aeabi_i2f
   \      0x202   0x4651             MOV      R1,R10
   \      0x204   0x.... 0x....      BL       _ZN11Temperature15setTargetHotendEfh
   \      0x208   0xF10B 0x0B01      ADD      R11,R11,#+1
   \      0x20C   0xFA4F 0xFB8B      SXTB     R11,R11
   \                     ??gcode_M600_24: (+1)
   \      0x210   0xF1BB 0x0F00      CMP      R11,#+0
   \      0x214   0xDDEC             BLE.N    ??gcode_M600_25
  10025          
  10026              // Show "wait for heating"
  10027              lcd_filament_change_show_message(FILAMENT_CHANGE_MESSAGE_WAIT_FOR_NOZZLES_TO_HEAT);
   \                     ??gcode_M600_23: (+1)
   \      0x216   0x2009             MOVS     R0,#+9
   \      0x218   0x.... 0x....      BL       _Z32lcd_filament_change_show_message21FilamentChangeMessage
  10028          
  10029              wait_for_heatup = true;
   \      0x21C   0x2001             MOVS     R0,#+1
   \      0x21E   0x70E8             STRB     R0,[R5, #+3]
   \      0x220   0xE01C             B.N      ??gcode_M600_26
  10030              while (wait_for_heatup) {
  10031                idle();
  10032                wait_for_heatup = false;
  10033                HOTEND_LOOP() {
   \                     ??gcode_M600_27: (+1)
   \      0x222   0xF10B 0x0B01      ADD      R11,R11,#+1
   \      0x226   0xFA4F 0xFB8B      SXTB     R11,R11
   \                     ??gcode_M600_28: (+1)
   \      0x22A   0xF1BB 0x0F00      CMP      R11,#+0
   \      0x22E   0xDC15             BGT.N    ??gcode_M600_26
  10034          	  	
  10035                  if (abs(thermalManager.degHotend(e) - temps[e]) > 3) {
   \      0x230   0x4658             MOV      R0,R11
   \      0x232   0xB2C0             UXTB     R0,R0
   \      0x234   0x.... 0x....      BL       _ZN11Temperature9degHotendEh
   \      0x238   0x4682             MOV      R10,R0
   \      0x23A   0x4668             MOV      R0,SP
   \      0x23C   0xF930 0x001B      LDRSH    R0,[R0, R11, LSL #+1]
   \      0x240   0x.... 0x....      BL       __aeabi_i2f
   \      0x244   0x4601             MOV      R1,R0
   \      0x246   0x4650             MOV      R0,R10
   \      0x248   0x.... 0x....      BL       __aeabi_fsub
   \      0x24C   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \      0x250   0x4958             LDR.N    R1,??gcode_M600_0+0x24  ;; 0x40400001
   \      0x252   0x.... 0x....      BL       __aeabi_cfrcmple
   \      0x256   0xD8E4             BHI.N    ??gcode_M600_27
  10036                    wait_for_heatup = true;
   \      0x258   0x2001             MOVS     R0,#+1
   \      0x25A   0x70E8             STRB     R0,[R5, #+3]
  10037                    break;
  10038                  }
  10039                }
   \                     ??gcode_M600_26: (+1)
   \      0x25C   0x78E8             LDRB     R0,[R5, #+3]
   \      0x25E   0x2800             CMP      R0,#+0
   \      0x260   0xD006             BEQ.N    ??gcode_M600_29
   \      0x262   0x2000             MOVS     R0,#+0
   \      0x264   0x.... 0x....      BL       _Z4idleb
   \      0x268   0x2000             MOVS     R0,#+0
   \      0x26A   0x70E8             STRB     R0,[R5, #+3]
   \      0x26C   0x4683             MOV      R11,R0
   \      0x26E   0xE7DC             B.N      ??gcode_M600_28
  10040              }
  10041          
  10042              // Show "insert filament"
  10043              if (nozzle_timed_out)
   \                     ??gcode_M600_29: (+1)
   \      0x270   0x2C00             CMP      R4,#+0
   \      0x272   0xD002             BEQ.N    ??gcode_M600_30
  10044                lcd_filament_change_show_message(FILAMENT_CHANGE_MESSAGE_INSERT);
   \      0x274   0x2002             MOVS     R0,#+2
   \      0x276   0x.... 0x....      BL       _Z32lcd_filament_change_show_message21FilamentChangeMessage
  10045          
  10046              #if HAS_BUZZER
  10047                filament_change_beep(true);
   \                     ??gcode_M600_30: (+1)
   \      0x27A   0x2001             MOVS     R0,#+1
   \      0x27C   0x.... 0x....      BL       _Z20filament_change_beepb
  10048              #endif
  10049          
  10050              KEEPALIVE_STATE(PAUSED_FOR_USER);
   \      0x280   0x2003             MOVS     R0,#+3
   \      0x282   0x71A8             STRB     R0,[R5, #+6]
  10051              wait_for_user = true;    // LCD click or M108 will clear this
   \      0x284   0x2001             MOVS     R0,#+1
   \      0x286   0x7128             STRB     R0,[R5, #+4]
  10052              while (wait_for_user && nozzle_timed_out) {
   \                     ??gcode_M600_31: (+1)
   \      0x288   0x7928             LDRB     R0,[R5, #+4]
   \      0x28A   0x2800             CMP      R0,#+0
   \      0x28C   0xD070             BEQ.N    ??gcode_M600_32
   \      0x28E   0x2C00             CMP      R4,#+0
   \      0x290   0xD06E             BEQ.N    ??gcode_M600_32
  10053                #if HAS_BUZZER
  10054                  filament_change_beep();
   \      0x292   0x2000             MOVS     R0,#+0
   \      0x294   0x.... 0x....      BL       _Z20filament_change_beepb
  10055                #endif
  10056                idle(true);
   \      0x298   0x2001             MOVS     R0,#+1
   \      0x29A   0x.... 0x....      BL       _Z4idleb
   \      0x29E   0xE7F3             B.N      ??gcode_M600_31
  10057              }
  10058              KEEPALIVE_STATE(IN_HANDLER);
  10059          
  10060              // Show "load" message
  10061              lcd_filament_change_show_message(FILAMENT_CHANGE_MESSAGE_LOAD);
  10062          
  10063              // Load filament
  10064              destination[E_AXIS] += code_seen('L') ? -code_value_axis_units(E_AXIS) : 0
  10065                #if FILAMENT_CHANGE_LOAD_LENGTH > 0
  10066                  + FILAMENT_CHANGE_LOAD_LENGTH
  10067                #endif
  10068              ;
   \                     ??gcode_M600_33: (+1)
   \      0x2A0   0x2100             MOVS     R1,#+0
   \                     ??gcode_M600_34: (+1)
   \      0x2A2   0x6A68             LDR      R0,[R5, #+36]
   \      0x2A4   0x.... 0x....      BL       __aeabi_fadd
   \      0x2A8   0x6268             STR      R0,[R5, #+36]
  10069          
  10070              RUNPLAN(FILAMENT_CHANGE_LOAD_FEEDRATE);
   \      0x2AA   0x4843             LDR.N    R0,??gcode_M600_0+0x28  ;; 0x40c00000
   \      0x2AC   0x.... 0x....      BL       _Z7RUNPLANf
  10071              stepper.synchronize();
   \      0x2B0   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
  10072          
  10073              #if defined(FILAMENT_CHANGE_EXTRUDE_LENGTH) && FILAMENT_CHANGE_EXTRUDE_LENGTH > 0
  10074          
  10075                do {
  10076                  // "Wait for filament extrude"
  10077                  lcd_filament_change_show_message(FILAMENT_CHANGE_MESSAGE_EXTRUDE);
   \                     ??gcode_M600_35: (+1)
   \      0x2B4   0x2004             MOVS     R0,#+4
   \      0x2B6   0x.... 0x....      BL       _Z32lcd_filament_change_show_message21FilamentChangeMessage
  10078          
  10079                  // Extrude filament to get into hotend
  10080                  destination[E_AXIS] += FILAMENT_CHANGE_EXTRUDE_LENGTH;
   \      0x2BA   0x6A68             LDR      R0,[R5, #+36]
   \      0x2BC   0x493F             LDR.N    R1,??gcode_M600_0+0x2C  ;; 0x42480000
   \      0x2BE   0x.... 0x....      BL       __aeabi_fadd
   \      0x2C2   0x6268             STR      R0,[R5, #+36]
  10081                  RUNPLAN(FILAMENT_CHANGE_EXTRUDE_FEEDRATE);
   \      0x2C4   0x483E             LDR.N    R0,??gcode_M600_0+0x30  ;; 0x40400000
   \      0x2C6   0x.... 0x....      BL       _Z7RUNPLANf
  10082                  stepper.synchronize();
   \      0x2CA   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
  10083          
  10084                  // Show "Extrude More" / "Resume" menu and wait for reply
  10085                  KEEPALIVE_STATE(PAUSED_FOR_USER);
   \      0x2CE   0x2003             MOVS     R0,#+3
   \      0x2D0   0x71A8             STRB     R0,[R5, #+6]
  10086                  wait_for_user = false;
   \      0x2D2   0x2000             MOVS     R0,#+0
   \      0x2D4   0x7128             STRB     R0,[R5, #+4]
  10087                  lcd_filament_change_show_message(FILAMENT_CHANGE_MESSAGE_OPTION);
   \      0x2D6   0x2005             MOVS     R0,#+5
   \      0x2D8   0x.... 0x....      BL       _Z32lcd_filament_change_show_message21FilamentChangeMessage
   \      0x2DC   0xE002             B.N      ??gcode_M600_36
  10088                  while (filament_change_menu_response == FILAMENT_CHANGE_RESPONSE_WAIT_FOR) idle(true);
   \                     ??gcode_M600_37: (+1)
   \      0x2DE   0x2001             MOVS     R0,#+1
   \      0x2E0   0x.... 0x....      BL       _Z4idleb
   \                     ??gcode_M600_36: (+1)
   \      0x2E4   0xF996 0x001A      LDRSB    R0,[R6, #+26]
   \      0x2E8   0x2800             CMP      R0,#+0
   \      0x2EA   0xD0F8             BEQ.N    ??gcode_M600_37
  10089                  KEEPALIVE_STATE(IN_HANDLER);
   \      0x2EC   0x2101             MOVS     R1,#+1
   \      0x2EE   0x71A9             STRB     R1,[R5, #+6]
  10090          
  10091                  // Keep looping if "Extrude More" was selected
  10092                } while (filament_change_menu_response == FILAMENT_CHANGE_RESPONSE_EXTRUDE_MORE);
   \      0x2F0   0x2801             CMP      R0,#+1
   \      0x2F2   0xD0DF             BEQ.N    ??gcode_M600_35
  10093          
  10094              #endif
  10095          
  10096              // "Wait for print to resume"
  10097              lcd_filament_change_show_message(FILAMENT_CHANGE_MESSAGE_RESUME);
   \      0x2F4   0x2006             MOVS     R0,#+6
   \      0x2F6   0x.... 0x....      BL       _Z32lcd_filament_change_show_message21FilamentChangeMessage
  10098          
  10099              // Set extruder to saved position
  10100              destination[E_AXIS] = current_position[E_AXIS] = lastpos[E_AXIS];
   \      0x2FA   0x9804             LDR      R0,[SP, #+16]
   \      0x2FC   0x6168             STR      R0,[R5, #+20]
   \      0x2FE   0x6268             STR      R0,[R5, #+36]
  10101              planner.set_e_position_mm(current_position[E_AXIS]);
   \      0x300   0xF105 0x0014      ADD      R0,R5,#+20
   \      0x304   0x.... 0x....      BL       _ZN7Planner17set_e_position_mmERKf
  10102          
  10103             //if IS_KINEMATIC	//mks_delta
  10104          	if(MACHINETPYE & IS_KINEMATIC)
   \      0x308   0xF8D9 0x0024      LDR      R0,[R9, #+36]
   \      0x30C   0x4924             LDR.N    R1,??gcode_M600_0+0x10  ;; 0x42700000
   \      0x30E   0x.... 0x....      BL       __aeabi_fdiv
   \      0x312   0xF8B9 0x1058      LDRH     R1,[R9, #+88]
   \      0x316   0xF240 0x3202      MOVW     R2,#+770
   \      0x31A   0x4211             TST      R1,R2
   \      0x31C   0xD006             BEQ.N    ??gcode_M600_38
  10105                // Move XYZ to starting position
  10106                planner.buffer_line_kinematic(lastpos, FILAMENT_CHANGE_XY_FEEDRATE, active_extruder);
   \      0x31E   0x9005             STR      R0,[SP, #+20]
   \      0x320   0x78AA             LDRB     R2,[R5, #+2]
   \      0x322   0xA905             ADD      R1,SP,#+20
   \      0x324   0xA801             ADD      R0,SP,#+4
   \      0x326   0x.... 0x....      BL       _ZN7Planner21buffer_line_kinematicEPKfRS0_h
   \      0x32A   0xE00F             B.N      ??gcode_M600_39
  10107              //#else
  10108              else{
  10109                // Move XY to starting position, then Z
  10110                destination[X_AXIS] = lastpos[X_AXIS];
   \                     ??gcode_M600_38: (+1)
   \      0x32C   0x9901             LDR      R1,[SP, #+4]
   \      0x32E   0x61A9             STR      R1,[R5, #+24]
  10111                destination[Y_AXIS] = lastpos[Y_AXIS];
   \      0x330   0xAC01             ADD      R4,SP,#+4
   \      0x332   0x6861             LDR      R1,[R4, #+4]
   \      0x334   0x61E9             STR      R1,[R5, #+28]
  10112                RUNPLAN(FILAMENT_CHANGE_XY_FEEDRATE);
   \      0x336   0x.... 0x....      BL       _Z7RUNPLANf
  10113                destination[Z_AXIS] = lastpos[Z_AXIS];
   \      0x33A   0x68A0             LDR      R0,[R4, #+8]
   \      0x33C   0x6228             STR      R0,[R5, #+32]
  10114                RUNPLAN(FILAMENT_CHANGE_Z_FEEDRATE);}
   \      0x33E   0xF8D9 0x0028      LDR      R0,[R9, #+40]
   \      0x342   0x4917             LDR.N    R1,??gcode_M600_0+0x10  ;; 0x42700000
   \      0x344   0x.... 0x....      BL       __aeabi_fdiv
   \      0x348   0x.... 0x....      BL       _Z7RUNPLANf
  10115              //#endif
  10116              stepper.synchronize();
   \                     ??gcode_M600_39: (+1)
   \      0x34C   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
  10117          
  10118              #if ENABLED(FILAMENT_RUNOUT_SENSOR)
  10119                filament_ran_out = false;
   \      0x350   0x2000             MOVS     R0,#+0
   \      0x352   0x7370             STRB     R0,[R6, #+13]
  10120              #endif
  10121          
  10122              // Show status screen
  10123              lcd_filament_change_show_message(FILAMENT_CHANGE_MESSAGE_STATUS);
   \      0x354   0x2007             MOVS     R0,#+7
   \      0x356   0x.... 0x....      BL       _Z32lcd_filament_change_show_message21FilamentChangeMessage
  10124          
  10125              // Resume the print job timer if it was running
  10126              if (job_running) print_job_timer.start();
   \      0x35A   0xF1B8 0x0F00      CMP      R8,#+0
   \      0x35E   0xD002             BEQ.N    ??gcode_M600_40
   \      0x360   0x4638             MOV      R0,R7
   \      0x362   0x.... 0x....      BL       _ZN9Stopwatch5startEv
  10127          
  10128              busy_doing_M600 = false;  // Allow Stepper Motors to be turned off during inactivity
   \                     ??gcode_M600_40: (+1)
   \      0x366   0x2000             MOVS     R0,#+0
   \      0x368   0x73F0             STRB     R0,[R6, #+15]
  10129            }
   \                     ??gcode_M600_2: (+1)
   \      0x36A   0xB007             ADD      SP,SP,#+28
   \      0x36C   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \                     ??gcode_M600_32: (+1)
   \      0x370   0x2001             MOVS     R0,#+1
   \      0x372   0x71A8             STRB     R0,[R5, #+6]
   \      0x374   0x2003             MOVS     R0,#+3
   \      0x376   0x.... 0x....      BL       _Z32lcd_filament_change_show_message21FilamentChangeMessage
   \      0x37A   0x204C             MOVS     R0,#+76
   \      0x37C   0x.... 0x....      BL       _Z9code_seenc
   \      0x380   0x2800             CMP      R0,#+0
   \      0x382   0xD08D             BEQ.N    ??gcode_M600_33
   \      0x384   0x.... 0x....      BL       _Z16code_value_floatv
   \      0x388   0x4601             MOV      R1,R0
   \      0x38A   0xF081 0x4100      EOR      R1,R1,#0x80000000
   \      0x38E   0xE788             B.N      ??gcode_M600_34
   \                     ??gcode_M600_0:
   \      0x390   0x....'....        DC32     mks_heating_busy
   \      0x394   0x....'....        DC32     errormagic
   \      0x398   0x....'....        DC32     _ZZ10gcode_M600vEs
   \      0x39C   0x....'....        DC32     axis_relative_modes
   \      0x3A0   0x4270'0000        DC32     0x42700000
   \      0x3A4   0x....'....        DC32     mksCfg
   \      0x3A8   0xC2C8'0000        DC32     0xc2c80000
   \      0x3AC   0x4120'0000        DC32     0x41200000
   \      0x3B0   0x....'....        DC32     _ZN11Temperature18target_temperatureE
   \      0x3B4   0x4040'0001        DC32     0x40400001
   \      0x3B8   0x40C0'0000        DC32     0x40c00000
   \      0x3BC   0x4248'0000        DC32     0x42480000
   \      0x3C0   0x4040'0000        DC32     0x40400000
  10130          
  10131          #endif // FILAMENT_CHANGE_FEATURE
  10132          
  10133          #if ENABLED(DUAL_X_CARRIAGE)
  10134          
  10135            /**
  10136             * M605: Set dual x-carriage movement mode
  10137             *
  10138             *    M605 S0: Full control mode. The slicer has full control over x-carriage movement
  10139             *    M605 S1: Auto-park mode. The inactive head will auto park/unpark without slicer involvement
  10140             *    M605 S2 [Xnnn] [Rmmm]: Duplication mode. The second extruder will duplicate the first with nnn
  10141             *                         units x-offset and an optional differential hotend temperature of
  10142             *                         mmm degrees. E.g., with "M605 S2 X100 R2" the second extruder will duplicate
  10143             *                         the first with a spacing of 100mm in the x direction and 2 degrees hotter.
  10144             *
  10145             *    Note: the X axis should be homed after changing dual x-carriage mode.
  10146             */
  10147            inline void gcode_M605() {
  10148              stepper.synchronize();
  10149              if (code_seen('S')) dual_x_carriage_mode = (DualXMode)code_value_byte();
  10150              switch (dual_x_carriage_mode) {
  10151                case DXC_FULL_CONTROL_MODE:
  10152                case DXC_AUTO_PARK_MODE:
  10153                  break;
  10154                case DXC_DUPLICATION_MODE:
  10155                  if (code_seen('X')) duplicate_extruder_x_offset = max(code_value_linear_units(), X2_MIN_POS - x_home_pos(0));
  10156                  if (code_seen('R')) duplicate_extruder_temp_offset = code_value_temp_diff();
  10157                  SERIAL_ECHO_START;
  10158                  SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
  10159                  SERIAL_CHAR(' ');
  10160                  SERIAL_ECHO(hotend_offset[X_AXIS][0]);
  10161                  SERIAL_CHAR(',');
  10162                  SERIAL_ECHO(hotend_offset[Y_AXIS][0]);
  10163                  SERIAL_CHAR(' ');
  10164                  SERIAL_ECHO(duplicate_extruder_x_offset);
  10165                  SERIAL_CHAR(',');
  10166                  SERIAL_ECHOLN(hotend_offset[Y_AXIS][1]);
  10167                  break;
  10168                default:
  10169                  dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
  10170                  break;
  10171              }
  10172              active_extruder_parked = false;
  10173              extruder_duplication_enabled = false;
  10174              delayed_move_time = 0;
  10175            }
  10176          
  10177          #elif ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
  10178          
  10179            inline void gcode_M605() {
  10180              stepper.synchronize();
  10181              extruder_duplication_enabled = code_seen('S') && code_value_int() == (int)DXC_DUPLICATION_MODE;
  10182              SERIAL_ECHO_START;
  10183              SERIAL_ECHOLNPAIR(MSG_DUPLICATION_MODE, extruder_duplication_enabled ? MSG_ON : MSG_OFF);
  10184            }
  10185          
  10186          #endif // DUAL_NOZZLE_DUPLICATION_MODE
  10187          
  10188          #if ENABLED(LIN_ADVANCE)
  10189            /**
  10190             * M900: Set and/or Get advance K factor and WH/D ratio
  10191             *
  10192             *  K<factor>                  Set advance K factor
  10193             *  R<ratio>                   Set ratio directly (overrides WH/D)
  10194             *  W<width> H<height> D<diam> Set ratio from WH/D
  10195             */
  10196            inline void gcode_M900() {
  10197              stepper.synchronize();
  10198          
  10199              const float newK = code_seen('K') ? code_value_float() : -1;
  10200              if (newK >= 0) planner.extruder_advance_k = newK;
  10201          
  10202              float newR = code_seen('R') ? code_value_float() : -1;
  10203              if (newR < 0) {
  10204                const float newD = code_seen('D') ? code_value_float() : -1,
  10205                            newW = code_seen('W') ? code_value_float() : -1,
  10206                            newH = code_seen('H') ? code_value_float() : -1;
  10207                if (newD >= 0 && newW >= 0 && newH >= 0)
  10208                  newR = newD ? (newW * newH) / (sq(newD * 0.5) * M_PI) : 0;
  10209              }
  10210              if (newR >= 0) planner.advance_ed_ratio = newR;
  10211          
  10212              SERIAL_ECHO_START;
  10213              SERIAL_ECHOPAIR("Advance K=", planner.extruder_advance_k);
  10214              SERIAL_ECHOPGM(" E/D=");
  10215              const float ratio = planner.advance_ed_ratio;
  10216              if (ratio) SERIAL_ECHO(ratio); else SERIAL_ECHOPGM("Auto");
  10217              SERIAL_EOL;
  10218            }
  10219          #endif // LIN_ADVANCE
  10220          
  10221          #if ENABLED(HAVE_TMC2130)
  10222          
  10223            static void tmc2130_get_current(TMC2130Stepper &st, const char name) {
  10224              SERIAL_CHAR(name);
  10225              SERIAL_ECHOPGM(" axis driver current: ");
  10226              SERIAL_ECHOLN(st.getCurrent());
  10227            }
  10228            static void tmc2130_set_current(TMC2130Stepper &st, const char name, const int mA) {
  10229              st.setCurrent(mA, R_SENSE, HOLD_MULTIPLIER);
  10230              tmc2130_get_current(st, name);
  10231            }
  10232          
  10233            static void tmc2130_report_otpw(TMC2130Stepper &st, const char name) {
  10234              SERIAL_CHAR(name);
  10235              SERIAL_ECHOPGM(" axis temperature prewarn triggered: ");
  10236              serialprintPGM(st.getOTPW() ? PSTR("true") : PSTR("false"));
  10237              SERIAL_EOL;
  10238            }
  10239            static void tmc2130_clear_otpw(TMC2130Stepper &st, const char name) {
  10240              st.clear_otpw();
  10241              SERIAL_CHAR(name);
  10242              SERIAL_ECHOLNPGM(" prewarn flag cleared");
  10243            }
  10244          
  10245            static void tmc2130_get_pwmthrs(TMC2130Stepper &st, const char name, const uint16_t spmm) {
  10246              SERIAL_CHAR(name);
  10247              SERIAL_ECHOPGM(" stealthChop max speed set to ");
  10248              SERIAL_ECHOLN(12650000UL * st.microsteps() / (256 * st.stealth_max_speed() * spmm));
  10249            }
  10250            static void tmc2130_set_pwmthrs(TMC2130Stepper &st, const char name, const int32_t thrs, const uint32_t spmm) {
  10251              st.stealth_max_speed(12650000UL * st.microsteps() / (256 * thrs * spmm));
  10252              tmc2130_get_pwmthrs(st, name, spmm);
  10253            }
  10254          
  10255            static void tmc2130_get_sgt(TMC2130Stepper &st, const char name) {
  10256              SERIAL_CHAR(name);
  10257              SERIAL_ECHOPGM(" driver homing sensitivity set to ");
  10258              SERIAL_ECHOLN(st.sgt());
  10259            }
  10260            static void tmc2130_set_sgt(TMC2130Stepper &st, const char name, const int8_t sgt_val) {
  10261              st.sgt(sgt_val);
  10262              tmc2130_get_sgt(st, name);
  10263            }
  10264          
  10265            /**
  10266             * M906: Set motor current in milliamps using axis codes X, Y, Z, E
  10267             * Report driver currents when no axis specified
  10268             *
  10269             * S1: Enable automatic current control
  10270             * S0: Disable
  10271             */
  10272            inline void gcode_M906() {
  10273              uint16_t values[XYZE];
  10274              LOOP_XYZE(i)
  10275                values[i] = code_seen(axis_codes[i]) ? code_value_int() : 0;
  10276          
  10277              #if ENABLED(X_IS_TMC2130)
  10278                if (values[X_AXIS]) tmc2130_set_current(stepperX, 'X', values[X_AXIS]);
  10279                else tmc2130_get_current(stepperX, 'X');
  10280              #endif
  10281              #if ENABLED(Y_IS_TMC2130)
  10282                if (values[Y_AXIS]) tmc2130_set_current(stepperY, 'Y', values[Y_AXIS]);
  10283                else tmc2130_get_current(stepperY, 'Y');
  10284              #endif
  10285              #if ENABLED(Z_IS_TMC2130)
  10286                if (values[Z_AXIS]) tmc2130_set_current(stepperZ, 'Z', values[Z_AXIS]);
  10287                else tmc2130_get_current(stepperZ, 'Z');
  10288              #endif
  10289              #if ENABLED(E0_IS_TMC2130)
  10290                if (values[E_AXIS]) tmc2130_set_current(stepperE0, 'E', values[E_AXIS]);
  10291                else tmc2130_get_current(stepperE0, 'E');
  10292              #endif
  10293          
  10294              #if ENABLED(AUTOMATIC_CURRENT_CONTROL)
  10295                if (code_seen('S')) auto_current_control = code_value_bool();
  10296              #endif
  10297            }
  10298          
  10299            /**
  10300             * M911: Report TMC2130 stepper driver overtemperature pre-warn flag
  10301             * The flag is held by the library and persist until manually cleared by M912
  10302             */
  10303            inline void gcode_M911() {
  10304              const bool reportX = code_seen('X'), reportY = code_seen('Y'), reportZ = code_seen('Z'), reportE = code_seen('E'),
  10305                       reportAll = (!reportX && !reportY && !reportZ && !reportE) || (reportX && reportY && reportZ && reportE);
  10306              #if ENABLED(X_IS_TMC2130)
  10307                if (reportX || reportAll) tmc2130_report_otpw(stepperX, 'X');
  10308              #endif
  10309              #if ENABLED(Y_IS_TMC2130)
  10310                if (reportY || reportAll) tmc2130_report_otpw(stepperY, 'Y');
  10311              #endif
  10312              #if ENABLED(Z_IS_TMC2130)
  10313                if (reportZ || reportAll) tmc2130_report_otpw(stepperZ, 'Z');
  10314              #endif
  10315              #if ENABLED(E0_IS_TMC2130)
  10316                if (reportE || reportAll) tmc2130_report_otpw(stepperE0, 'E');
  10317              #endif
  10318            }
  10319          
  10320            /**
  10321             * M912: Clear TMC2130 stepper driver overtemperature pre-warn flag held by the library
  10322             */
  10323            inline void gcode_M912() {
  10324              const bool clearX = code_seen('X'), clearY = code_seen('Y'), clearZ = code_seen('Z'), clearE = code_seen('E'),
  10325                       clearAll = (!clearX && !clearY && !clearZ && !clearE) || (clearX && clearY && clearZ && clearE);
  10326              #if ENABLED(X_IS_TMC2130)
  10327                if (clearX || clearAll) tmc2130_clear_otpw(stepperX, 'X');
  10328              #endif
  10329              #if ENABLED(Y_IS_TMC2130)
  10330                if (clearY || clearAll) tmc2130_clear_otpw(stepperY, 'Y');
  10331              #endif
  10332              #if ENABLED(Z_IS_TMC2130)
  10333                if (clearZ || clearAll) tmc2130_clear_otpw(stepperZ, 'Z');
  10334              #endif
  10335              #if ENABLED(E0_IS_TMC2130)
  10336                if (clearE || clearAll) tmc2130_clear_otpw(stepperE0, 'E');
  10337              #endif
  10338            }
  10339          
  10340            /**
  10341             * M913: Set HYBRID_THRESHOLD speed.
  10342             */
  10343            #if ENABLED(HYBRID_THRESHOLD)
  10344              inline void gcode_M913() {
  10345                uint16_t values[XYZE];
  10346                LOOP_XYZE(i)
  10347                  values[i] = code_seen(axis_codes[i]) ? code_value_int() : 0;
  10348          
  10349                #if ENABLED(X_IS_TMC2130)
  10350                  if (values[X_AXIS]) tmc2130_set_pwmthrs(stepperX, 'X', values[X_AXIS], planner.axis_steps_per_mm[X_AXIS]);
  10351                  else tmc2130_get_pwmthrs(stepperX, 'X', planner.axis_steps_per_mm[X_AXIS]);
  10352                #endif
  10353                #if ENABLED(Y_IS_TMC2130)
  10354                  if (values[Y_AXIS]) tmc2130_set_pwmthrs(stepperY, 'Y', values[Y_AXIS], planner.axis_steps_per_mm[Y_AXIS]);
  10355                  else tmc2130_get_pwmthrs(stepperY, 'Y', planner.axis_steps_per_mm[Y_AXIS]);
  10356                #endif
  10357                #if ENABLED(Z_IS_TMC2130)
  10358                  if (values[Z_AXIS]) tmc2130_set_pwmthrs(stepperZ, 'Z', values[Z_AXIS], planner.axis_steps_per_mm[Z_AXIS]);
  10359                  else tmc2130_get_pwmthrs(stepperZ, 'Z', planner.axis_steps_per_mm[Z_AXIS]);
  10360                #endif
  10361                #if ENABLED(E0_IS_TMC2130)
  10362                  if (values[E_AXIS]) tmc2130_set_pwmthrs(stepperE0, 'E', values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
  10363                  else tmc2130_get_pwmthrs(stepperE0, 'E', planner.axis_steps_per_mm[E_AXIS]);
  10364                #endif
  10365              }
  10366            #endif // HYBRID_THRESHOLD
  10367          
  10368            /**
  10369             * M914: Set SENSORLESS_HOMING sensitivity.
  10370             */
  10371            #if ENABLED(SENSORLESS_HOMING)
  10372              inline void gcode_M914() {
  10373                #if ENABLED(X_IS_TMC2130)
  10374                  if (code_seen(axis_codes[X_AXIS])) tmc2130_set_sgt(stepperX, 'X', code_value_int());
  10375                  else tmc2130_get_sgt(stepperX, 'X');
  10376                #endif
  10377                #if ENABLED(Y_IS_TMC2130)
  10378                  if (code_seen(axis_codes[Y_AXIS])) tmc2130_set_sgt(stepperY, 'Y', code_value_int());
  10379                  else tmc2130_get_sgt(stepperY, 'Y');
  10380                #endif
  10381              }
  10382            #endif // SENSORLESS_HOMING
  10383          
  10384          #endif // HAVE_TMC2130
  10385          
  10386          /**
  10387           * M907: Set digital trimpot motor current using axis codes X, Y, Z, E, B, S
  10388           */

   \                                 In section .text, align 2
  10389          inline void gcode_M907() {
  10390            #if HAS_DIGIPOTSS
  10391              LOOP_XYZE(i) if (code_seen(axis_codes[i])) stepper.digipot_current(i, code_value_int());
  10392              if (code_seen('B')) stepper.digipot_current(4, code_value_int());
  10393              if (code_seen('S')) for (uint8_t i = 0; i <= 4; i++) stepper.digipot_current(i, code_value_int());
  10394            #elif HAS_MOTOR_CURRENT_PWM
  10395              #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
  10396                if (code_seen('X')) stepper.digipot_current(0, code_value_int());
  10397              #endif
  10398              #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
  10399                if (code_seen('Z')) stepper.digipot_current(1, code_value_int());
  10400              #endif
  10401              #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
  10402                if (code_seen('E')) stepper.digipot_current(2, code_value_int());
  10403              #endif
  10404            #endif
  10405            #if ENABLED(DIGIPOT_I2C)
  10406              // this one uses actual amps in floating point
  10407              LOOP_XYZE(i) if (code_seen(axis_codes[i])) digipot_i2c_set_current(i, code_value_float());
  10408              // for each additional extruder (named B,C,D,E..., channels 4,5,6,7...)
  10409              for (uint8_t i = NUM_AXIS; i < DIGIPOT_I2C_NUM_CHANNELS; i++) if (code_seen('B' + i - (NUM_AXIS))) digipot_i2c_set_current(i, code_value_float());
  10410            #endif
  10411            #if ENABLED(DAC_STEPPER_CURRENT)
  10412              if (code_seen('S')) {
  10413                const float dac_percent = code_value_float();
  10414                for (uint8_t i = 0; i <= 4; i++) dac_current_percent(i, dac_percent);
  10415              }
  10416              LOOP_XYZE(i) if (code_seen(axis_codes[i])) dac_current_percent(i, code_value_float());
  10417            #endif
  10418          }
   \                     _Z10gcode_M907v: (+1)
   \        0x0   0x4770             BX       LR               ;; return
  10419          
  10420          #if HAS_DIGIPOTSS || ENABLED(DAC_STEPPER_CURRENT)
  10421          
  10422            /**
  10423             * M908: Control digital trimpot directly (M908 P<pin> S<current>)
  10424             */
  10425            inline void gcode_M908() {
  10426              #if HAS_DIGIPOTSS
  10427                stepper.digitalPotWrite(
  10428                  code_seen('P') ? code_value_int() : 0,
  10429                  code_seen('S') ? code_value_int() : 0
  10430                );
  10431              #endif
  10432              #ifdef DAC_STEPPER_CURRENT
  10433                dac_current_raw(
  10434                  code_seen('P') ? code_value_byte() : -1,
  10435                  code_seen('S') ? code_value_ushort() : 0
  10436                );
  10437              #endif
  10438            }
  10439          
  10440            #if ENABLED(DAC_STEPPER_CURRENT) // As with Printrbot RevF
  10441          
  10442              inline void gcode_M909() { dac_print_values(); }
  10443          
  10444              inline void gcode_M910() { dac_commit_eeprom(); }
  10445          
  10446            #endif
  10447          
  10448          #endif // HAS_DIGIPOTSS || DAC_STEPPER_CURRENT
  10449          
  10450          #if HAS_MICROSTEPS
  10451          
  10452            // M350 Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.
  10453            inline void gcode_M350() {
  10454              if (code_seen('S')) for (int i = 0; i <= 4; i++) stepper.microstep_mode(i, code_value_byte());
  10455              LOOP_XYZE(i) if (code_seen(axis_codes[i])) stepper.microstep_mode(i, code_value_byte());
  10456              if (code_seen('B')) stepper.microstep_mode(4, code_value_byte());
  10457              stepper.microstep_readings();
  10458            }
  10459          
  10460            /**
  10461             * M351: Toggle MS1 MS2 pins directly with axis codes X Y Z E B
  10462             *       S# determines MS1 or MS2, X# sets the pin high/low.
  10463             */
  10464            inline void gcode_M351() {
  10465              if (code_seen('S')) switch (code_value_byte()) {
  10466                case 1:
  10467                  LOOP_XYZE(i) if (code_seen(axis_codes[i])) stepper.microstep_ms(i, code_value_byte(), -1);
  10468                  if (code_seen('B')) stepper.microstep_ms(4, code_value_byte(), -1);
  10469                  break;
  10470                case 2:
  10471                  LOOP_XYZE(i) if (code_seen(axis_codes[i])) stepper.microstep_ms(i, -1, code_value_byte());
  10472                  if (code_seen('B')) stepper.microstep_ms(4, -1, code_value_byte());
  10473                  break;
  10474              }
  10475              stepper.microstep_readings();
  10476            }
  10477          
  10478          #endif // HAS_MICROSTEPS
  10479          
  10480          #if HAS_CASE_LIGHT
  10481          
  10482            uint8_t case_light_brightness = 255;
  10483          
  10484            void update_case_light() {
  10485              WRITE(CASE_LIGHT_PIN, case_light_on != INVERT_CASE_LIGHT ? HIGH : LOW);
  10486              analogWrite(CASE_LIGHT_PIN, case_light_on != INVERT_CASE_LIGHT ? case_light_brightness : 0);
  10487            }
  10488          
  10489          #endif // HAS_CASE_LIGHT
  10490          
  10491          /**
  10492           * M355: Turn case lights on/off and set brightness
  10493           *
  10494           *   S<bool>  Turn case light on or off
  10495           *   P<byte>  Set case light brightness (PWM pin required)
  10496           */

   \                                 In section .text, align 4
  10497          inline void gcode_M355() {
   \                     _Z10gcode_M355v: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
  10498            #if HAS_CASE_LIGHT
  10499              if (code_seen('P')) case_light_brightness = code_value_byte();
  10500              if (code_seen('S')) case_light_on = code_value_bool();
  10501              update_case_light();
  10502              SERIAL_ECHO_START;
  10503              SERIAL_ECHOPGM("Case lights ");
  10504              case_light_on ? SERIAL_ECHOLNPGM("on") : SERIAL_ECHOLNPGM("off");
  10505            #else
  10506              SERIAL_ERROR_START;
   \        0x2   0x4804             LDR.N    R0,??gcode_M355_0
   \        0x4   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10507              SERIAL_ERRORLNPGM(MSG_ERR_M355_NONE);
   \        0x8   0x4803             LDR.N    R0,??gcode_M355_0+0x4
   \        0xA   0xE8BD 0x4002      POP      {R1,LR}
   \        0xE   0x.... 0x....      B.W      _Z14serialprintPGMPKc
   \       0x12   0xBF00             Nop      
   \                     ??gcode_M355_0:
   \       0x14   0x....'....        DC32     errormagic
   \       0x18   0x....'....        DC32     _ZZ10gcode_M355vEs
  10508            #endif // HAS_CASE_LIGHT
  10509          }
  10510          
  10511          #if ENABLED(MIXING_EXTRUDER)
  10512          
  10513            /**
  10514             * M163: Set a single mix factor for a mixing extruder
  10515             *       This is called "weight" by some systems.
  10516             *
  10517             *   S[index]   The channel index to set
  10518             *   P[float]   The mix value
  10519             *
  10520             */
  10521            inline void gcode_M163() {
  10522              const int mix_index = code_seen('S') ? code_value_int() : 0;
  10523              if (mix_index < MIXING_STEPPERS) {
  10524                float mix_value = code_seen('P') ? code_value_float() : 0.0;
  10525                NOLESS(mix_value, 0.0);
  10526                mixing_factor[mix_index] = RECIPROCAL(mix_value);
  10527              }
  10528            }
  10529          
  10530            #if MIXING_VIRTUAL_TOOLS > 1
  10531          
  10532              /**
  10533               * M164: Store the current mix factors as a virtual tool.
  10534               *
  10535               *   S[index]   The virtual tool to store
  10536               *
  10537               */
  10538              inline void gcode_M164() {
  10539                const int tool_index = code_seen('S') ? code_value_int() : 0;
  10540                if (tool_index < MIXING_VIRTUAL_TOOLS) {
  10541                  normalize_mix();
  10542                  for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
  10543                    mixing_virtual_tool_mix[tool_index][i] = mixing_factor[i];
  10544                }
  10545              }
  10546          
  10547            #endif
  10548          
  10549            #if ENABLED(DIRECT_MIXING_IN_G1)
  10550              /**
  10551               * M165: Set multiple mix factors for a mixing extruder.
  10552               *       Factors that are left out will be set to 0.
  10553               *       All factors together must add up to 1.0.
  10554               *
  10555               *   A[factor] Mix factor for extruder stepper 1
  10556               *   B[factor] Mix factor for extruder stepper 2
  10557               *   C[factor] Mix factor for extruder stepper 3
  10558               *   D[factor] Mix factor for extruder stepper 4
  10559               *   H[factor] Mix factor for extruder stepper 5
  10560               *   I[factor] Mix factor for extruder stepper 6
  10561               *
  10562               */
  10563              inline void gcode_M165() { gcode_get_mix(); }
  10564            #endif
  10565          
  10566          #endif // MIXING_EXTRUDER
  10567          
  10568          /**
  10569           * M999: Restart after being stopped
  10570           *
  10571           * Default behaviour is to flush the serial buffer and request
  10572           * a resend to the host starting on the last N line received.
  10573           *
  10574           * Sending "M999 S1" will resume printing without flushing the
  10575           * existing command buffer.
  10576           *
  10577           */

   \                                 In section .text, align 4
  10578          inline void gcode_M999() {
   \                     _Z10gcode_M999v: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
  10579            Running = true;
   \        0x2   0x2001             MOVS     R0,#+1
   \        0x4   0x4908             LDR.N    R1,??gcode_M999_0
   \        0x6   0x7008             STRB     R0,[R1, #+0]
  10580            lcd_reset_alert_level();
   \        0x8   0x.... 0x....      BL       _Z21lcd_reset_alert_levelv
  10581          
  10582            if (code_seen('S') && code_value_bool()) return;
   \        0xC   0x2053             MOVS     R0,#+83
   \        0xE   0x.... 0x....      BL       _Z9code_seenc
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD003             BEQ.N    ??gcode_M999_1
   \       0x16   0x.... 0x....      BL       _Z15code_value_boolv
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD103             BNE.N    ??gcode_M999_2
  10583          
  10584            // gcode_LastN = Stopped_gcode_LastN;
  10585            FlushSerialRequestResend();
   \                     ??gcode_M999_1: (+1)
   \       0x1E   0xE8BD 0x4001      POP      {R0,LR}
   \       0x22   0x.... 0x....      B.W      _Z24FlushSerialRequestResendv
   \                     ??gcode_M999_2: (+1)
   \       0x26   0xBD01             POP      {R0,PC}          ;; return
   \                     ??gcode_M999_0:
   \       0x28   0x....'....        DC32     Running
  10586          }
  10587          
  10588          #if ENABLED(SWITCHING_EXTRUDER)
  10589            inline void move_extruder_servo(uint8_t e) {
  10590              const int angles[2] = SWITCHING_EXTRUDER_SERVO_ANGLES;
  10591              MOVE_SERVO(SWITCHING_EXTRUDER_SERVO_NR, angles[e]);
  10592              safe_delay(500);
  10593            }
  10594          #endif
  10595          
  10596          inline void invalid_extruder_error(const uint8_t &e) {
  10597            SERIAL_ECHO_START;
  10598            SERIAL_CHAR('T');
  10599            SERIAL_ECHO_F(e, DEC);
  10600            SERIAL_ECHOLN(MSG_INVALID_EXTRUDER);
  10601          }
  10602          
  10603          /**
  10604           * Perform a tool-change, which may result in moving the
  10605           * previous tool out of the way and the new tool into place.
  10606           */

   \                                 In section .text, align 2, keep-with-next
  10607          void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
   \                     _Z11tool_changehfb: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
  10608            #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
  10609          
  10610              if (tmp_extruder >= MIXING_VIRTUAL_TOOLS)
  10611                return invalid_extruder_error(tmp_extruder);
  10612          
  10613              // T0-Tnnn: Switch virtual tool by changing the mix
  10614              for (uint8_t j = 0; j < MIXING_STEPPERS; j++)
  10615                mixing_factor[j] = mixing_virtual_tool_mix[tmp_extruder][j];
  10616          
  10617            #else //!MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
  10618          
  10619              #if HOTENDS > 1
  10620          
  10621                if (tmp_extruder >= EXTRUDERS)
  10622                  return invalid_extruder_error(tmp_extruder);
  10623          
  10624                const float old_feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : feedrate_mm_s;
  10625          
  10626                feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
  10627          
  10628                if (tmp_extruder != active_extruder) {
  10629                  if (!no_move && axis_unhomed_error(true, true, true)) {
  10630                    SERIAL_ECHOLNPGM("No move on toolchange");
  10631                    no_move = true;
  10632                  }
  10633          
  10634                  // Save current position to destination, for use later
  10635                  set_destination_to_current();
  10636          
  10637                  #if ENABLED(DUAL_X_CARRIAGE)
  10638          
  10639                    #if ENABLED(DEBUG_LEVELING_FEATURE)
  10640                      if (DEBUGGING(LEVELING)) {
  10641                        SERIAL_ECHOPGM("Dual X Carriage Mode ");
  10642                        switch (dual_x_carriage_mode) {
  10643                          case DXC_FULL_CONTROL_MODE: SERIAL_ECHOLNPGM("DXC_FULL_CONTROL_MODE"); break;
  10644                          case DXC_AUTO_PARK_MODE: SERIAL_ECHOLNPGM("DXC_AUTO_PARK_MODE"); break;
  10645                          case DXC_DUPLICATION_MODE: SERIAL_ECHOLNPGM("DXC_DUPLICATION_MODE"); break;
  10646                        }
  10647                      }
  10648                    #endif
  10649          
  10650                    const float xhome = x_home_pos(active_extruder);
  10651                    if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE
  10652                        && IsRunning()
  10653                        && (delayed_move_time || current_position[X_AXIS] != xhome)
  10654                    ) {
  10655                      float raised_z = current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT;
  10656                      //#if ENABLED(MAX_SOFTWARE_ENDSTOPS)	/*--mks cfg--*/
  10657          			if(mksCfg.max_software_endstops){
  10658                        NOMORE(raised_z, soft_endstop_max[Z_AXIS]);
  10659                      }//#endif
  10660                      #if ENABLED(DEBUG_LEVELING_FEATURE)
  10661                        if (DEBUGGING(LEVELING)) {
  10662                          SERIAL_ECHOLNPAIR("Raise to ", raised_z);
  10663                          SERIAL_ECHOLNPAIR("MoveX to ", xhome);
  10664                          SERIAL_ECHOLNPAIR("Lower to ", current_position[Z_AXIS]);
  10665                        }
  10666                      #endif
  10667                      // Park old head: 1) raise 2) move to park position 3) lower
  10668                      for (uint8_t i = 0; i < 3; i++)
  10669                        planner.buffer_line(
  10670                          i == 0 ? current_position[X_AXIS] : xhome,
  10671                          current_position[Y_AXIS],
  10672                          i == 2 ? current_position[Z_AXIS] : raised_z,
  10673                          current_position[E_AXIS],
  10674                          planner.max_feedrate_mm_s[i == 1 ? X_AXIS : Z_AXIS],
  10675                          active_extruder
  10676                        );
  10677                      stepper.synchronize();
  10678                    }
  10679          
  10680                    // Apply Y & Z extruder offset (X offset is used as home pos with Dual X)
  10681                    current_position[Y_AXIS] -= hotend_offset[Y_AXIS][active_extruder] - hotend_offset[Y_AXIS][tmp_extruder];
  10682                    current_position[Z_AXIS] -= hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
  10683          
  10684                    // Activate the new extruder
  10685                    active_extruder = tmp_extruder;
  10686          
  10687                    // This function resets the max/min values - the current position may be overwritten below.
  10688                    set_axis_is_at_home(X_AXIS);
  10689          
  10690                    #if ENABLED(DEBUG_LEVELING_FEATURE)
  10691                      if (DEBUGGING(LEVELING)) DEBUG_POS("New Extruder", current_position);
  10692                    #endif
  10693          
  10694                    // Only when auto-parking are carriages safe to move
  10695                    if (dual_x_carriage_mode != DXC_AUTO_PARK_MODE) no_move = true;
  10696          
  10697                    switch (dual_x_carriage_mode) {
  10698                      case DXC_FULL_CONTROL_MODE:
  10699                        // New current position is the position of the activated extruder
  10700                        current_position[X_AXIS] = LOGICAL_X_POSITION(inactive_extruder_x_pos);
  10701                        // Save the inactive extruder's position (from the old current_position)
  10702                        inactive_extruder_x_pos = RAW_X_POSITION(destination[X_AXIS]);
  10703                        break;
  10704                      case DXC_AUTO_PARK_MODE:
  10705                        // record raised toolhead position for use by unpark
  10706                        COPY(raised_parked_position, current_position);
  10707                        raised_parked_position[Z_AXIS] += TOOLCHANGE_UNPARK_ZLIFT;
  10708          			  //#if ENABLED(MAX_SOFTWARE_ENDSTOPS)	  /*--mks cfg--*/
  10709          			  if(mksCfg.max_software_endstops){
  10710                          NOMORE(raised_parked_position[Z_AXIS], soft_endstop_max[Z_AXIS]);
  10711                        }//#endif
  10712                        active_extruder_parked = true;
  10713                        delayed_move_time = 0;
  10714                        break;
  10715                      case DXC_DUPLICATION_MODE:
  10716                        // If the new extruder is the left one, set it "parked"
  10717                        // This triggers the second extruder to move into the duplication position
  10718                        active_extruder_parked = (active_extruder == 0);
  10719          
  10720                        if (active_extruder_parked)
  10721                          current_position[X_AXIS] = LOGICAL_X_POSITION(inactive_extruder_x_pos);
  10722                        else
  10723                          current_position[X_AXIS] = destination[X_AXIS] + duplicate_extruder_x_offset;
  10724                        inactive_extruder_x_pos = RAW_X_POSITION(destination[X_AXIS]);
  10725                        extruder_duplication_enabled = false;
  10726                        #if ENABLED(DEBUG_LEVELING_FEATURE)
  10727                          if (DEBUGGING(LEVELING)) {
  10728                            SERIAL_ECHOLNPAIR("Set inactive_extruder_x_pos=", inactive_extruder_x_pos);
  10729                            SERIAL_ECHOLNPGM("Clear extruder_duplication_enabled");
  10730                          }
  10731                        #endif
  10732                        break;
  10733                    }
  10734          
  10735                    #if ENABLED(DEBUG_LEVELING_FEATURE)
  10736                      if (DEBUGGING(LEVELING)) {
  10737                        SERIAL_ECHOLNPAIR("Active extruder parked: ", active_extruder_parked ? "yes" : "no");
  10738                        DEBUG_POS("New extruder (parked)", current_position);
  10739                      }
  10740                    #endif
  10741          
  10742                    // No extra case for HAS_ABL in DUAL_X_CARRIAGE. Does that mean they don't work together?
  10743                  #else // !DUAL_X_CARRIAGE
  10744          
  10745                    #if ENABLED(SWITCHING_EXTRUDER)
  10746                      // <0 if the new nozzle is higher, >0 if lower. A bigger raise when lower.
  10747                      const float z_diff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder],
  10748                                  z_raise = 0.3 + (z_diff > 0.0 ? z_diff : 0.0);
  10749          
  10750                      // Always raise by some amount (destination copied from current_position earlier)
  10751                      current_position[Z_AXIS] += z_raise;
  10752                      planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
  10753                      stepper.synchronize();
  10754          
  10755                      move_extruder_servo(active_extruder);
  10756                    #endif
  10757          
  10758                    /**
  10759                     * Set current_position to the position of the new nozzle.
  10760                     * Offsets are based on linear distance, so we need to get
  10761                     * the resulting position in coordinate space.
  10762                     *
  10763                     * - With grid or 3-point leveling, offset XYZ by a tilted vector
  10764                     * - With mesh leveling, update Z for the new position
  10765                     * - Otherwise, just use the raw linear distance
  10766                     *
  10767                     * Software endstops are altered here too. Consider a case where:
  10768                     *   E0 at X=0 ... E1 at X=10
  10769                     * When we switch to E1 now X=10, but E1 can't move left.
  10770                     * To express this we apply the change in XY to the software endstops.
  10771                     * E1 can move farther right than E0, so the right limit is extended.
  10772                     *
  10773                     * Note that we don't adjust the Z software endstops. Why not?
  10774                     * Consider a case where Z=0 (here) and switching to E1 makes Z=1
  10775                     * because the bed is 1mm lower at the new position. As long as
  10776                     * the first nozzle is out of the way, the carriage should be
  10777                     * allowed to move 1mm lower. This technically "breaks" the
  10778                     * Z software endstop. But this is technically correct (and
  10779                     * there is no viable alternative).
  10780                     */
  10781          
  10782          /*--mks cfg--begin MESH_BED_LEVELING */		
  10783          /*		  
  10784                    #if ABL_PLANAR
  10785                      // Offset extruder, make sure to apply the bed level rotation matrix
  10786                      vector_3 tmp_offset_vec = vector_3(hotend_offset[X_AXIS][tmp_extruder],
  10787                                                         hotend_offset[Y_AXIS][tmp_extruder],
  10788                                                         0),
  10789                               act_offset_vec = vector_3(hotend_offset[X_AXIS][active_extruder],
  10790                                                         hotend_offset[Y_AXIS][active_extruder],
  10791                                                         0),
  10792                               offset_vec = tmp_offset_vec - act_offset_vec;
  10793          
  10794                      #if ENABLED(DEBUG_LEVELING_FEATURE)
  10795                        if (DEBUGGING(LEVELING)) {
  10796                          tmp_offset_vec.debug(PSTR("tmp_offset_vec"));
  10797                          act_offset_vec.debug(PSTR("act_offset_vec"));
  10798                          offset_vec.debug(PSTR("offset_vec (BEFORE)"));
  10799                        }
  10800                      #endif
  10801          
  10802                      offset_vec.apply_rotation(planner.bed_level_matrix.transpose(planner.bed_level_matrix));
  10803          
  10804                      #if ENABLED(DEBUG_LEVELING_FEATURE)
  10805                        if (DEBUGGING(LEVELING)) offset_vec.debug(PSTR("offset_vec (AFTER)"));
  10806                      #endif
  10807          
  10808                      // Adjustments to the current position
  10809                      const float xydiff[2] = { offset_vec.x, offset_vec.y };
  10810                      current_position[Z_AXIS] += offset_vec.z;
  10811          
  10812                    #else // !ABL_PLANAR
  10813          
  10814                      const float xydiff[2] = {
  10815                        hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder],
  10816                        hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder]
  10817                      };
  10818          
  10819                      #if ENABLED(MESH_BED_LEVELING)
  10820          
  10821                        if (mbl.active()) {
  10822                          #if ENABLED(DEBUG_LEVELING_FEATURE)
  10823                            if (DEBUGGING(LEVELING)) SERIAL_ECHOPAIR("Z before MBL: ", current_position[Z_AXIS]);
  10824                          #endif
  10825                          float x2 = current_position[X_AXIS] + xydiff[X_AXIS],
  10826                                y2 = current_position[Y_AXIS] + xydiff[Y_AXIS],
  10827                                z1 = current_position[Z_AXIS], z2 = z1;
  10828                          planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], z1);
  10829                          planner.apply_leveling(x2, y2, z2);
  10830                          current_position[Z_AXIS] += z2 - z1;
  10831                          #if ENABLED(DEBUG_LEVELING_FEATURE)
  10832                            if (DEBUGGING(LEVELING))
  10833                              SERIAL_ECHOLNPAIR(" after: ", current_position[Z_AXIS]);
  10834                          #endif
  10835                        }
  10836          
  10837                      #endif // MESH_BED_LEVELING
  10838          
  10839                    #endif // !HAS_ABL
  10840          */
  10841          //#if ABL_PLANAR
  10842          if(BED_LEVELING_METHOD&ABL_PLANAR)
  10843          {
  10844          		  // Offset extruder, make sure to apply the bed level rotation matrix
  10845          		  vector_3 tmp_offset_vec = vector_3(hotend_offset[X_AXIS][tmp_extruder],
  10846          											 hotend_offset[Y_AXIS][tmp_extruder],
  10847          											 0),
  10848          				   act_offset_vec = vector_3(hotend_offset[X_AXIS][active_extruder],
  10849          											 hotend_offset[Y_AXIS][active_extruder],
  10850          											 0),
  10851          				   offset_vec = tmp_offset_vec - act_offset_vec;
  10852          		  
  10853          		#if ENABLED(DEBUG_LEVELING_FEATURE)
  10854          			if (DEBUGGING(LEVELING)) {
  10855          			  tmp_offset_vec.debug(PSTR("tmp_offset_vec"));
  10856          			  act_offset_vec.debug(PSTR("act_offset_vec"));
  10857          			  offset_vec.debug(PSTR("offset_vec (BEFORE)"));
  10858          			}
  10859          		#endif
  10860          		 	 offset_vec.apply_rotation(planner.bed_level_matrix.transpose(planner.bed_level_matrix));
  10861          		  
  10862          		#if ENABLED(DEBUG_LEVELING_FEATURE)
  10863          			if (DEBUGGING(LEVELING)) offset_vec.debug(PSTR("offset_vec (AFTER)"));
  10864          		#endif
  10865          		  
  10866          		  // Adjustments to the current position
  10867          		  const float xydiff[2] = { offset_vec.x, offset_vec.y };
  10868          
  10869          			  current_position[Z_AXIS] += offset_vec.z;
  10870          //#else
  10871          }	
  10872          else
  10873          {
  10874          		  const float xydiff[2] = {
  10875          			hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder],
  10876          			hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder]
  10877          		  };
  10878          		  if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
  10879          		  	{
  10880                        if (mbl.active()) {
  10881            				#if ENABLED(DEBUG_LEVELING_FEATURE)
  10882                            if (DEBUGGING(LEVELING)) SERIAL_ECHOPAIR("Z before MBL: ", current_position[Z_AXIS]);
  10883            				#endif
  10884                          float x2 = current_position[X_AXIS] + xydiff[X_AXIS],
  10885                                y2 = current_position[Y_AXIS] + xydiff[Y_AXIS],
  10886                                z1 = current_position[Z_AXIS], z2 = z1;
  10887                          planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], z1);
  10888                          planner.apply_leveling(x2, y2, z2);
  10889                          current_position[Z_AXIS] += z2 - z1;
  10890           			 	#if ENABLED(DEBUG_LEVELING_FEATURE)
  10891                            if (DEBUGGING(LEVELING))
  10892                              SERIAL_ECHOLNPAIR(" after: ", current_position[Z_AXIS]);
  10893            				#endif
  10894                        }
  10895          
  10896          		  	}
  10897          }		  
  10898          		  /*--mks cfg--end MESH_BED_LEVELING */
  10899          
  10900                    #if ENABLED(DEBUG_LEVELING_FEATURE)
  10901                      if (DEBUGGING(LEVELING)) {
  10902                        SERIAL_ECHOPAIR("Offset Tool XY by { ", xydiff[X_AXIS]);
  10903                        SERIAL_ECHOPAIR(", ", xydiff[Y_AXIS]);
  10904                        SERIAL_ECHOLNPGM(" }");
  10905                      }
  10906                    #endif
  10907          
  10908                    // The newly-selected extruder XY is actually at...
  10909                    current_position[X_AXIS] += xydiff[X_AXIS];
  10910                    current_position[Y_AXIS] += xydiff[Y_AXIS];
  10911                    #if HAS_WORKSPACE_OFFSET || ENABLED(DUAL_X_CARRIAGE)
  10912                      for (uint8_t i = X_AXIS; i <= Y_AXIS; i++) {
  10913                        #if HAS_POSITION_SHIFT
  10914                          position_shift[i] += xydiff[i];
  10915                        #endif
  10916                        update_software_endstops((AxisEnum)i);
  10917                      }
  10918                    #endif
  10919          
  10920                    // Set the new active extruder
  10921                    active_extruder = tmp_extruder;
  10922          
  10923                  #endif // !DUAL_X_CARRIAGE
  10924          
  10925                  #if ENABLED(DEBUG_LEVELING_FEATURE)
  10926                    if (DEBUGGING(LEVELING)) DEBUG_POS("Sync After Toolchange", current_position);
  10927                  #endif
  10928          
  10929                  // Tell the planner the new "current position"
  10930                  SYNC_PLAN_POSITION_KINEMATIC();
  10931          
  10932                  // Move to the "old position" (move the extruder into place)
  10933                  if (!no_move && IsRunning()) {
  10934                    #if ENABLED(DEBUG_LEVELING_FEATURE)
  10935                      if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
  10936                    #endif
  10937                    prepare_move_to_destination();
  10938                  }
  10939          
  10940                  #if ENABLED(SWITCHING_EXTRUDER)
  10941                    // Move back down, if needed. (Including when the new tool is higher.)
  10942                    if (z_raise != z_diff) {
  10943                      destination[Z_AXIS] += z_diff;
  10944                      feedrate_mm_s = planner.max_feedrate_mm_s[Z_AXIS];
  10945                      prepare_move_to_destination();
  10946                    }
  10947                  #endif
  10948          
  10949                } // (tmp_extruder != active_extruder)
  10950          
  10951                stepper.synchronize();
  10952          
  10953                #if ENABLED(EXT_SOLENOID)
  10954                  disable_all_solenoids();
  10955                  enable_solenoid_on_active_extruder();
  10956                #endif // EXT_SOLENOID
  10957          
  10958                feedrate_mm_s = old_feedrate_mm_s;
  10959          
  10960              #else // HOTENDS <= 1
  10961          
  10962                // Set the new active extruder
  10963                active_extruder = tmp_extruder;
   \        0x2   0x....             LDR.N    R4,??DataTable136_2
   \        0x4   0x70A0             STRB     R0,[R4, #+2]
  10964          
  10965                UNUSED(fr_mm_s);
  10966                UNUSED(no_move);
  10967          
  10968              #endif // HOTENDS <= 1
  10969          
  10970              SERIAL_ECHO_START;
   \        0x6   0x....             LDR.N    R0,??DataTable136_5
   \        0x8   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10971              SERIAL_ECHOLNPAIR(MSG_ACTIVE_EXTRUDER, (int)active_extruder);
   \        0xC   0x78A1             LDRB     R1,[R4, #+2]
   \        0xE   0x.... 0x....      ADR.W    R0,?_35
   \       0x12   0x.... 0x....      BL       _Z17serial_echopair_PPKci
   \       0x16   0x79E0             LDRB     R0,[R4, #+7]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD105             BNE.N    ??tool_change_0
   \       0x1C   0x210A             MOVS     R1,#+10
   \       0x1E   0x....             LDR.N    R0,??DataTable136_17
   \       0x20   0xE8BD 0x4010      POP      {R4,LR}
   \       0x24   0x.... 0x....      B.W      _ZN12MarlinSerial5writeEh
   \                     ??tool_change_0: (+1)
   \       0x28   0x2200             MOVS     R2,#+0
   \       0x2A   0x210A             MOVS     R1,#+10
   \       0x2C   0x....             LDR.N    R0,??DataTable136_6
   \       0x2E   0xE8BD 0x4010      POP      {R4,LR}
   \       0x32   0x.... 0x....      B.W      _ZN12MarlinSerial5printEci
  10972          
  10973            #endif //!MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
  10974          }
  10975          
  10976          /**
  10977           * T0-T3: Switch tool, usually switching extruders
  10978           *
  10979           *   F[units/min] Set the movement feedrate
  10980           *   S1           Don't move the tool in XY after change
  10981           */

   \                                 In section .text, align 2
  10982          inline void gcode_T(uint8_t tmp_extruder) {
  10983          
  10984            #if ENABLED(DEBUG_LEVELING_FEATURE)
  10985              if (DEBUGGING(LEVELING)) {
  10986                SERIAL_ECHOPAIR(">>> gcode_T(", tmp_extruder);
  10987                SERIAL_CHAR(')');
  10988                SERIAL_EOL;
  10989                DEBUG_POS("BEFORE", current_position);
  10990              }
  10991            #endif
  10992          
  10993            #if HOTENDS == 1 || (ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1)
  10994          
  10995              tool_change(tmp_extruder);
   \                     _Z7gcode_Th: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   \        0x2   0x4611             MOV      R1,R2
   \        0x4   0x.... 0x....      B.W      _Z11tool_changehfb
  10996          
  10997            #elif HOTENDS > 1
  10998          
  10999              tool_change(
  11000                tmp_extruder,
  11001                code_seen('F') ? MMM_TO_MMS(code_value_linear_units()) : 0.0,
  11002                (tmp_extruder == active_extruder) || (code_seen('S') && code_value_bool())
  11003              );
  11004          
  11005            #endif
  11006          
  11007            #if ENABLED(DEBUG_LEVELING_FEATURE)
  11008              if (DEBUGGING(LEVELING)) {
  11009                DEBUG_POS("AFTER", current_position);
  11010                SERIAL_ECHOLNPGM("<<< gcode_T");
  11011              }
  11012            #endif
  11013          }
  11014          
  11015          /**
  11016           * Process a single command and dispatch it to its handler
  11017           * This is called from the main loop()
  11018           */

   \                                 In section .text, align 4, keep-with-next
  11019          void process_next_command() {
   \                     _Z20process_next_commandv: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
  11020            current_command = command_queue[cmd_queue_index_r];
   \        0x4   0x2560             MOVS     R5,#+96
   \        0x6   0x.... 0x....      LDR.W    R7,??DataTable140
   \        0xA   0x.... 0x....      LDR.W    R0,??DataTable140_1
   \        0xE   0x7A79             LDRB     R1,[R7, #+9]
   \       0x10   0x4369             MULS     R1,R5,R1
   \       0x12   0x4408             ADD      R0,R0,R1
   \       0x14   0x6278             STR      R0,[R7, #+36]
  11021          
  11022            if (DEBUGGING(ECHO)) {
   \       0x16   0x.... 0x....      LDR.W    R4,??DataTable140_2
   \       0x1A   0x7860             LDRB     R0,[R4, #+1]
   \       0x1C   0x07C0             LSLS     R0,R0,#+31
   \       0x1E   0xD51F             BPL.N    ??process_next_command_1
  11023              SERIAL_ECHO_START;
   \       0x20   0x.... 0x....      LDR.W    R0,??DataTable140_4
   \       0x24   0x.... 0x....      BL       _Z14serialprintPGMPKc
  11024              SERIAL_ECHOLN(current_command);
   \       0x28   0x6A79             LDR      R1,[R7, #+36]
   \       0x2A   0x79E0             LDRB     R0,[R4, #+7]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD104             BNE.N    ??process_next_command_2
   \       0x30   0x.... 0x....      LDR.W    R0,??DataTable140_5
   \       0x34   0x.... 0x....      BL       _ZN12MarlinSerial5printEPKc
   \       0x38   0xE003             B.N      ??process_next_command_3
   \                     ??process_next_command_2: (+1)
   \       0x3A   0x.... 0x....      LDR.W    R0,??DataTable140_6
   \       0x3E   0x.... 0x....      BL       _ZN12MarlinSerial5printEPKc
   \                     ??process_next_command_3: (+1)
   \       0x42   0x79E0             LDRB     R0,[R4, #+7]
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD105             BNE.N    ??process_next_command_4
   \       0x48   0x210A             MOVS     R1,#+10
   \       0x4A   0x.... 0x....      LDR.W    R0,??DataTable140_5
   \       0x4E   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \       0x52   0xE005             B.N      ??process_next_command_1
   \                     ??process_next_command_4: (+1)
   \       0x54   0x2200             MOVS     R2,#+0
   \       0x56   0x210A             MOVS     R1,#+10
   \       0x58   0x.... 0x....      LDR.W    R0,??DataTable140_6
   \       0x5C   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
  11025              #if ENABLED(M100_FREE_MEMORY_WATCHER)
  11026                SERIAL_ECHOPAIR("slot:", cmd_queue_index_r);
  11027                M100_dump_routine("   Command Queue:", &command_queue[0][0], &command_queue[BUFSIZE][MAX_CMD_SIZE]);
  11028              #endif
  11029            }
  11030            
  11031            if((mksReprint.mks_printer_state == MKS_WORKING))
   \                     ??process_next_command_1: (+1)
   \       0x60   0x.... 0x....      LDR.W    R6,??DataTable140_7
   \       0x64   0xF896 0x0068      LDRB     R0,[R6, #+104]
   \       0x68   0x28A7             CMP      R0,#+167
   \       0x6A   0xD11D             BNE.N    ??process_next_command_5
  11032            {
  11033                  memset(command_queue_bak[cmd_queue_index_r_bak],0,96);
   \       0x6C   0xF897 0x800B      LDRB     R8,[R7, #+11]
   \       0x70   0x4640             MOV      R0,R8
   \       0x72   0x4345             MULS     R5,R5,R0
   \       0x74   0x1960             ADDS     R0,R4,R5
   \       0x76   0xF100 0x0588      ADD      R5,R0,#+136
   \       0x7A   0x2200             MOVS     R2,#+0
   \       0x7C   0x2160             MOVS     R1,#+96
   \       0x7E   0x4628             MOV      R0,R5
   \       0x80   0x.... 0x....      BL       __aeabi_memset
  11034                  strcpy((char*)&command_queue_bak[cmd_queue_index_r_bak],current_command);
   \       0x84   0x6A79             LDR      R1,[R7, #+36]
   \       0x86   0x4628             MOV      R0,R5
   \       0x88   0x.... 0x....      BL       strcpy
  11035                  cmd_queue_index_r_bak++;
   \       0x8C   0xF108 0x0801      ADD      R8,R8,#+1
   \       0x90   0xF887 0x800B      STRB     R8,[R7, #+11]
  11036                  if(cmd_queue_index_r_bak>=(4+4))
   \       0x94   0xFA5F 0xF888      UXTB     R8,R8
   \       0x98   0xF1B8 0x0F07      CMP      R8,#+7
   \       0x9C   0xDD04             BLE.N    ??process_next_command_5
  11037                      cmd_queue_index_r_bak=0;
   \       0x9E   0x2000             MOVS     R0,#+0
   \       0xA0   0x72F8             STRB     R0,[R7, #+11]
   \       0xA2   0xE001             B.N      ??process_next_command_5
  11038            }
  11039          
  11040            // Sanitize the current command:
  11041            //  - Skip leading spaces
  11042            //  - Bypass N[-0-9][0-9]*[ ]*
  11043            //  - Overwrite * with nul to mark the end
  11044            while (*current_command == ' ') ++current_command;
   \                     ??process_next_command_6: (+1)
   \       0xA4   0x1C40             ADDS     R0,R0,#+1
   \       0xA6   0x6278             STR      R0,[R7, #+36]
   \                     ??process_next_command_5: (+1)
   \       0xA8   0x6A78             LDR      R0,[R7, #+36]
   \       0xAA   0xF990 0x1000      LDRSB    R1,[R0, #+0]
   \       0xAE   0x2920             CMP      R1,#+32
   \       0xB0   0xD0F8             BEQ.N    ??process_next_command_6
  11045            if (*current_command == 'N' && NUMERIC_SIGNED(current_command[1])) {
   \       0xB2   0x294E             CMP      R1,#+78
   \       0xB4   0xF040 0x83AF      BNE.W    ??process_next_command_7
   \       0xB8   0xF990 0x1001      LDRSB    R1,[R0, #+1]
   \       0xBC   0x460A             MOV      R2,R1
   \       0xBE   0x3A30             SUBS     R2,R2,#+48
   \       0xC0   0x2A0A             CMP      R2,#+10
   \       0xC2   0xD302             BCC.N    ??process_next_command_8
   \       0xC4   0x292D             CMP      R1,#+45
   \       0xC6   0xF040 0x83A6      BNE.W    ??process_next_command_7
  11046              current_command += 2; // skip N[-0-9]
   \                     ??process_next_command_8: (+1)
   \       0xCA   0x1C80             ADDS     R0,R0,#+2
   \       0xCC   0x6278             STR      R0,[R7, #+36]
   \       0xCE   0xE001             B.N      ??process_next_command_9
  11047              while (NUMERIC(*current_command)) ++current_command; // skip [0-9]*
   \                     ??process_next_command_10: (+1)
   \       0xD0   0x1C40             ADDS     R0,R0,#+1
   \       0xD2   0x6278             STR      R0,[R7, #+36]
   \                     ??process_next_command_9: (+1)
   \       0xD4   0x6A78             LDR      R0,[R7, #+36]
   \       0xD6   0xF990 0x1000      LDRSB    R1,[R0, #+0]
   \       0xDA   0x3930             SUBS     R1,R1,#+48
   \       0xDC   0x290A             CMP      R1,#+10
   \       0xDE   0xD3F7             BCC.N    ??process_next_command_10
  11048              while (*current_command == ' ') ++current_command; // skip [ ]*
   \                     ??process_next_command_11: (+1)
   \       0xE0   0x6A78             LDR      R0,[R7, #+36]
   \       0xE2   0xF990 0x1000      LDRSB    R1,[R0, #+0]
   \       0xE6   0x2920             CMP      R1,#+32
   \       0xE8   0xF040 0x8395      BNE.W    ??process_next_command_7
   \       0xEC   0x1C40             ADDS     R0,R0,#+1
   \       0xEE   0x6278             STR      R0,[R7, #+36]
   \       0xF0   0xE7F6             B.N      ??process_next_command_11
  11049            }
  11050            char* starpos = strchr(current_command, '*');  // * should always be the last parameter
  11051            if (starpos) while (*starpos == ' ' || *starpos == '*') *starpos-- = '\0'; // nullify '*' and ' '
   \                     ??process_next_command_12: (+1)
   \       0xF2   0x2100             MOVS     R1,#+0
   \       0xF4   0xF800 0x1901      STRB     R1,[R0], #-1
   \                     ??process_next_command_13: (+1)
   \       0xF8   0xF990 0x1000      LDRSB    R1,[R0, #+0]
   \       0xFC   0x2920             CMP      R1,#+32
   \       0xFE   0xD0F8             BEQ.N    ??process_next_command_12
   \      0x100   0x292A             CMP      R1,#+42
   \      0x102   0xD0F6             BEQ.N    ??process_next_command_12
  11052          
  11053            char *cmd_ptr = current_command;
  11054          
  11055            // Get the command code, which must be G, M, or T
  11056            char command_code = *cmd_ptr++;
   \                     ??process_next_command_14: (+1)
   \      0x104   0xF918 0x1B01      LDRSB    R1,[R8], #+1
   \      0x108   0xE001             B.N      ??process_next_command_15
  11057          
  11058            // Skip spaces to get the numeric part
  11059            while (*cmd_ptr == ' ') cmd_ptr++;
   \                     ??process_next_command_16: (+1)
   \      0x10A   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??process_next_command_15: (+1)
   \      0x10E   0xF998 0x2000      LDRSB    R2,[R8, #+0]
   \      0x112   0x2A20             CMP      R2,#+32
   \      0x114   0xD0F9             BEQ.N    ??process_next_command_16
  11060          
  11061            // Allow for decimal point in command
  11062            #if ENABLED(G38_PROBE_TARGET)
  11063              uint8_t subcode = 0;
  11064            #endif
  11065          
  11066            uint16_t codenum = 0; // define ahead of goto
   \      0x116   0x2000             MOVS     R0,#+0
  11067          
  11068            // Bail early if there's no code
  11069            bool code_is_good = NUMERIC(*cmd_ptr);
   \      0x118   0x3A30             SUBS     R2,R2,#+48
   \      0x11A   0x2A0A             CMP      R2,#+10
   \      0x11C   0x41AD             SBCS     R5,R5,R5
   \      0x11E   0x0FED             LSRS     R5,R5,#+31
  11070            if (!code_is_good) goto ExitUnknownCommand;
   \      0x120   0xF000 0x8370      BEQ.W    ??process_next_command_17
  11071          
  11072            // Get and skip the code number
  11073            do {
  11074              codenum = (codenum * 10) + (*cmd_ptr - '0');
   \                     ??process_next_command_18: (+1)
   \      0x124   0xEB00 0x0280      ADD      R2,R0,R0, LSL #+2
   \      0x128   0xF998 0x0000      LDRSB    R0,[R8, #+0]
   \      0x12C   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \      0x130   0x3830             SUBS     R0,R0,#+48
  11075              cmd_ptr++;
  11076            } while (NUMERIC(*cmd_ptr));
   \      0x132   0xF918 0x2F01      LDRSB    R2,[R8, #+1]!
   \      0x136   0x3A30             SUBS     R2,R2,#+48
   \      0x138   0x2A0A             CMP      R2,#+10
   \      0x13A   0xD3F3             BCC.N    ??process_next_command_18
  11077          
  11078            // Allow for decimal point in command
  11079            #if ENABLED(G38_PROBE_TARGET)
  11080              if (*cmd_ptr == '.') {
  11081                cmd_ptr++;
  11082                while (NUMERIC(*cmd_ptr))
  11083                  subcode = (subcode * 10) + (*cmd_ptr++ - '0');
  11084              }
  11085            #endif
  11086          
  11087            // Skip all spaces to get to the first argument, or nul
  11088            while (*cmd_ptr == ' ') cmd_ptr++;
   \                     ??process_next_command_19: (+1)
   \      0x13C   0xF998 0x2000      LDRSB    R2,[R8, #+0]
   \      0x140   0x2A20             CMP      R2,#+32
   \      0x142   0xF040 0x8372      BNE.W    ??process_next_command_20
   \      0x146   0xF108 0x0801      ADD      R8,R8,#+1
   \      0x14A   0xE7F7             B.N      ??process_next_command_19
  11089          
  11090            // The command's arguments (if any) start here, for sure!
  11091            current_command_args = cmd_ptr;
  11092          
  11093            KEEPALIVE_STATE(IN_HANDLER);
  11094          
  11095            // Handle a known G, M, or T
  11096            switch (command_code) {
  11097              case 'G': switch (codenum) {
  11098          
  11099                // G0, G1
  11100                case 0:
  11101                case 1:
  11102                //  #if IS_SCARA
  11103          		if(MACHINETPYE&IS_SCARA)
  11104                    gcode_G0_G1_SCARA(codenum == 0);
  11105                  //#else
  11106                  else
  11107                    gcode_G0_G1();
   \                     ??process_next_command_21: (+1)
   \      0x14C   0x.... 0x....      BL       _Z11gcode_G0_G1v
   \      0x150   0xE356             B.N      ??process_next_command_22
  11108                  //#endif
  11109                  break;
  11110          
  11111                // G2, G3
  11112                #if ENABLED(ARC_SUPPORT) && DISABLED(SCARA)
  11113                  case 2: // G2  - CW ARC
  11114                  case 3: // G3  - CCW ARC
  11115                    gcode_G2_G3(codenum == 2);
   \                     ??process_next_command_23: (+1)
   \      0x152   0xB280             UXTH     R0,R0
   \      0x154   0x2802             CMP      R0,#+2
   \      0x156   0xD101             BNE.N    ??process_next_command_24
   \      0x158   0x4610             MOV      R0,R2
   \      0x15A   0xE000             B.N      ??process_next_command_25
   \                     ??process_next_command_24: (+1)
   \      0x15C   0x2000             MOVS     R0,#+0
   \                     ??process_next_command_25: (+1)
   \      0x15E   0x.... 0x....      BL       _Z11gcode_G2_G3b
  11116                    break;
   \      0x162   0xE34D             B.N      ??process_next_command_22
  11117                #endif
  11118          
  11119                // G4 Dwell
  11120                case 4:
  11121                  gcode_G4();
   \                     ??process_next_command_26: (+1)
   \      0x164   0x.... 0x....      BL       _Z8gcode_G4v
  11122                  break;
   \      0x168   0xE34A             B.N      ??process_next_command_22
  11123          
  11124                #if ENABLED(BEZIER_CURVE_SUPPORT)
  11125                  // G5
  11126                  case 5: // G5  - Cubic B_spline
  11127                    gcode_G5();
  11128                    break;
  11129                #endif // BEZIER_CURVE_SUPPORT
  11130          
  11131                #if ENABLED(FWRETRACT)
  11132                  case 10: // G10: retract
  11133                  case 11: // G11: retract_recover
  11134                    gcode_G10_G11(codenum == 10);
  11135                    break;
  11136                #endif // FWRETRACT
  11137          
  11138                #if ENABLED(NOZZLE_CLEAN_FEATURE)
  11139                  case 12:
  11140                    gcode_G12(); // G12: Nozzle Clean
  11141                    break;
  11142                #endif // NOZZLE_CLEAN_FEATURE
  11143          
  11144                #if ENABLED(INCH_MODE_SUPPORT)
  11145                  case 20: //G20: Inch Mode
  11146                    gcode_G20();
  11147                    break;
  11148          
  11149                  case 21: //G21: MM Mode
  11150                    gcode_G21();
  11151                    break;
  11152                #endif // INCH_MODE_SUPPORT
  11153          
  11154          //      #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(UBL_G26_MESH_EDITING)
  11155          	  #if 1
  11156                  case 26: // G26: Mesh Validation Pattern generation
  11157          		if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_UBL)
   \                     ??process_next_command_27: (+1)
   \      0x16A   0x.... 0x....      LDR.W    R0,??DataTable141
   \      0x16E   0x7B00             LDRB     R0,[R0, #+12]
   \      0x170   0x06C0             LSLS     R0,R0,#+27
   \      0x172   0xF140 0x8345      BPL.W    ??process_next_command_22
  11158          	          gcode_G26();
   \      0x176   0x.... 0x....      BL       _Z9gcode_G26v
   \      0x17A   0xE341             B.N      ??process_next_command_22
  11159                    break;
  11160                #endif // AUTO_BED_LEVELING_UBL
  11161          
  11162                #if ENABLED(NOZZLE_PARK_FEATURE)
  11163                  case 27: // G27: Nozzle Park
  11164                    gcode_G27();
  11165                    break;
  11166                #endif // NOZZLE_PARK_FEATURE
  11167          
  11168                case 28: // G28: Home all axes, one at a time
  11169                  gcode_G28();
   \                     ??process_next_command_28: (+1)
   \      0x17C   0x.... 0x....      BL       _Z9gcode_G28v
  11170          
  11171          		if((BED_LEVELING_METHOD & HAS_LEVELING) && (BED_LEVELING_METHOD != AUTO_BED_LEVELING_UBL))
   \      0x180   0x.... 0x....      LDR.W    R6,??DataTable141
   \      0x184   0x7B30             LDRB     R0,[R6, #+12]
   \      0x186   0xF010 0x0F3E      TST      R0,#0x3E
   \      0x18A   0xF000 0x8339      BEQ.W    ??process_next_command_22
   \      0x18E   0x2810             CMP      R0,#+16
   \      0x190   0xF000 0x8336      BEQ.W    ??process_next_command_22
  11172          			{
  11173          			  set_bed_leveling_enabled(true);
   \      0x194   0x2001             MOVS     R0,#+1
   \      0x196   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
  11174          		#if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
  11175          			if((MACHINETPYE != DELTA) && (BED_LEVELING_METHOD&HAS_FADE))	//mks_delta
   \      0x19A   0xF9B6 0x0024      LDRSH    R0,[R6, #+36]
   \      0x19E   0x2802             CMP      R0,#+2
   \      0x1A0   0xF000 0x832E      BEQ.W    ??process_next_command_22
   \      0x1A4   0x7B30             LDRB     R0,[R6, #+12]
   \      0x1A6   0x06C0             LSLS     R0,R0,#+27
   \      0x1A8   0xF140 0x832A      BPL.W    ??process_next_command_22
  11176          			 { if (code_seen('Z')) set_z_fade_height(code_value_linear_units());}
   \      0x1AC   0x205A             MOVS     R0,#+90
   \      0x1AE   0x.... 0x....      BL       _Z9code_seenc
   \      0x1B2   0x2800             CMP      R0,#+0
   \      0x1B4   0xF000 0x8324      BEQ.W    ??process_next_command_22
   \      0x1B8   0x.... 0x....      BL       _Z16code_value_floatv
   \      0x1BC   0x.... 0x....      BL       _Z17set_z_fade_heightf
   \      0x1C0   0xE31E             B.N      ??process_next_command_22
  11177          		#endif
  11178          
  11179          
  11180          			}
  11181                  break;
  11182          
  11183                //#if HAS_LEVELING
  11184                  case 29: // G29 Detailed Z probe, probes the bed at 3 or more points,
  11185                           // or provides access to the UBL System if enabled.
  11186          		if(BED_LEVELING_METHOD&HAS_LEVELING)	
   \                     ??process_next_command_29: (+1)
   \      0x1C2   0x.... 0x....      LDR.W    R0,??DataTable141
   \      0x1C6   0x7B00             LDRB     R0,[R0, #+12]
   \      0x1C8   0xF010 0x0F3E      TST      R0,#0x3E
   \      0x1CC   0xD034             BEQ.N    ??process_next_command_30
  11187          			{
  11188          			switch(BED_LEVELING_METHOD)		/*--mks cfg-- MESH_BED_LEVELING */ 
   \      0x1CE   0x2802             CMP      R0,#+2
   \      0x1D0   0xD00C             BEQ.N    ??process_next_command_31
   \      0x1D2   0x2804             CMP      R0,#+4
   \      0x1D4   0xD00A             BEQ.N    ??process_next_command_31
   \      0x1D6   0x2808             CMP      R0,#+8
   \      0x1D8   0xD008             BEQ.N    ??process_next_command_31
   \      0x1DA   0x2810             CMP      R0,#+16
   \      0x1DC   0xD00B             BEQ.N    ??process_next_command_32
   \      0x1DE   0x2820             CMP      R0,#+32
   \      0x1E0   0xD10C             BNE.N    ??process_next_command_33
  11189          				{
  11190          				case MESH_BED_LEVELING:
  11191          					gcode_G29_MESH_BED_LEVELING();
   \      0x1E2   0x.... 0x....      BL       _Z27gcode_G29_MESH_BED_LEVELINGv
  11192          					(void)settings.save();
   \      0x1E6   0x.... 0x....      BL       _ZN14MarlinSettings4saveEv
  11193          					break;
   \      0x1EA   0xE309             B.N      ??process_next_command_22
  11194          				case AUTO_BED_LEVELING_3POINT:
  11195          				case AUTO_BED_LEVELING_LINEAR:
  11196          				case AUTO_BED_LEVELING_BILINEAR:
  11197          					gcode_G29();
   \                     ??process_next_command_31: (+1)
   \      0x1EC   0x.... 0x....      BL       _Z9gcode_G29v
  11198          					(void)settings.save();
   \      0x1F0   0x.... 0x....      BL       _ZN14MarlinSettings4saveEv
  11199          					break;
   \      0x1F4   0xE304             B.N      ??process_next_command_22
  11200          				case AUTO_BED_LEVELING_UBL:
  11201          					gcode_G29_UBL();
   \                     ??process_next_command_32: (+1)
   \      0x1F6   0x.... 0x....      BL       _Z13gcode_G29_UBLv
  11202          					break;
   \      0x1FA   0xE301             B.N      ??process_next_command_22
  11203          				default:
  11204          					SERIAL_PROTOCOL("bed leveling hasn't defined!");
   \                     ??process_next_command_33: (+1)
   \      0x1FC   0x.... 0x....      LDR.W    R1,??DataTable141_1
   \      0x200   0x79E0             LDRB     R0,[R4, #+7]
   \      0x202   0x2800             CMP      R0,#+0
   \      0x204   0xD104             BNE.N    ??process_next_command_34
   \      0x206   0x.... 0x....      LDR.W    R0,??DataTable140_5
   \      0x20A   0x.... 0x....      BL       _ZN12MarlinSerial5printEPKc
   \      0x20E   0xE003             B.N      ??process_next_command_35
   \                     ??process_next_command_34: (+1)
   \      0x210   0x.... 0x....      LDR.W    R0,??DataTable140_6
   \      0x214   0x.... 0x....      BL       _ZN12MarlinSerial5printEPKc
  11205          					SERIAL_EOL;
   \                     ??process_next_command_35: (+1)
   \      0x218   0x79E0             LDRB     R0,[R4, #+7]
   \      0x21A   0x2800             CMP      R0,#+0
   \      0x21C   0xD105             BNE.N    ??process_next_command_36
   \      0x21E   0x210A             MOVS     R1,#+10
   \      0x220   0x.... 0x....      LDR.W    R0,??DataTable140_5
   \      0x224   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \      0x228   0xE2EA             B.N      ??process_next_command_22
   \                     ??process_next_command_36: (+1)
   \      0x22A   0x2200             MOVS     R2,#+0
   \      0x22C   0x210A             MOVS     R1,#+10
   \      0x22E   0x.... 0x....      LDR.W    R0,??DataTable140_6
   \      0x232   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   \      0x236   0xE2E3             B.N      ??process_next_command_22
  11206          					break;
  11207          				}
  11208          			}
  11209                          else
  11210                          {
  11211          		SERIAL_PROTOCOL("bed leveling hasn't defined!");
   \                     ??process_next_command_30: (+1)
   \      0x238   0x.... 0x....      LDR.W    R1,??DataTable141_1
   \      0x23C   0x79E0             LDRB     R0,[R4, #+7]
   \      0x23E   0x2800             CMP      R0,#+0
   \      0x240   0xD104             BNE.N    ??process_next_command_37
   \      0x242   0x.... 0x....      LDR.W    R0,??DataTable140_5
   \      0x246   0x.... 0x....      BL       _ZN12MarlinSerial5printEPKc
   \      0x24A   0xE003             B.N      ??process_next_command_38
   \                     ??process_next_command_37: (+1)
   \      0x24C   0x.... 0x....      LDR.W    R0,??DataTable140_6
   \      0x250   0x.... 0x....      BL       _ZN12MarlinSerial5printEPKc
  11212          		SERIAL_EOL;
   \                     ??process_next_command_38: (+1)
   \      0x254   0x79E0             LDRB     R0,[R4, #+7]
   \      0x256   0x2800             CMP      R0,#+0
   \      0x258   0xD105             BNE.N    ??process_next_command_39
   \      0x25A   0x210A             MOVS     R1,#+10
   \      0x25C   0x.... 0x....      LDR.W    R0,??DataTable140_5
   \      0x260   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \      0x264   0xE2CC             B.N      ??process_next_command_22
   \                     ??process_next_command_39: (+1)
   \      0x266   0x2200             MOVS     R2,#+0
   \      0x268   0x210A             MOVS     R1,#+10
   \      0x26A   0x.... 0x....      LDR.W    R0,??DataTable140_6
   \      0x26E   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
   \      0x272   0xE2C5             B.N      ??process_next_command_22
  11213                          }
  11214          		
  11215                    break;
  11216                //#endif // HAS_LEVELING
  11217          
  11218                #if HAS_BED_PROBE
  11219          
  11220                  case 30: // G30 Single Z probe
  11221                    gcode_G30();
   \                     ??process_next_command_40: (+1)
   \      0x274   0x.... 0x....      BL       _Z9gcode_G30v
  11222                    break;
   \      0x278   0xE2C2             B.N      ??process_next_command_22
  11223          
  11224                  #if ENABLED(Z_PROBE_SLED)
  11225          
  11226                      case 31: // G31: dock the sled
  11227                        gcode_G31();
  11228                        break;
  11229          
  11230                      case 32: // G32: undock the sled
  11231                        gcode_G32();
  11232                        break;
  11233          
  11234                  #endif // Z_PROBE_SLED
  11235          
  11236                  #if ENABLED(DELTA_AUTO_CALIBRATION)
  11237          
  11238                    case 33: // G33: Delta Auto-Calibration
  11239                      gcode_G33();
  11240                      break;
  11241          
  11242                  #endif // DELTA_AUTO_CALIBRATION
  11243          
  11244                #endif // HAS_BED_PROBE
  11245          
  11246                #if ENABLED(G38_PROBE_TARGET)
  11247                  case 38: // G38.2 & G38.3
  11248                    if (subcode == 2 || subcode == 3)
  11249                      gcode_G38(subcode == 2);
  11250                    break;
  11251                #endif
  11252          
  11253                case 90: // G90
  11254                  relative_mode = false;
   \                     ??process_next_command_41: (+1)
   \      0x27A   0x2000             MOVS     R0,#+0
   \      0x27C   0x7338             STRB     R0,[R7, #+12]
  11255                  break;
   \      0x27E   0xE2BF             B.N      ??process_next_command_22
  11256                case 91: // G91
  11257                  relative_mode = true;
   \                     ??process_next_command_42: (+1)
   \      0x280   0x4610             MOV      R0,R2
   \      0x282   0x7338             STRB     R0,[R7, #+12]
  11258                  break;
   \      0x284   0xE2BC             B.N      ??process_next_command_22
  11259          
  11260                case 92: // G92
  11261                  gcode_G92();
   \                     ??process_next_command_43: (+1)
   \      0x286   0x.... 0x....      BL       _Z9gcode_G92v
  11262                  break;
   \      0x28A   0xE2B9             B.N      ??process_next_command_22
  11263              }
  11264              break;
  11265          
  11266              case 'M': switch (codenum) {
                               ^
Warning[Pe546]: transfer of control bypasses initialization of:
            variable "tmp_index" (declared at line 11287)
   \                     ??process_next_command_44: (+1)
   \      0x28C   0xB280             UXTH     R0,R0
   \      0x28E   0x2801             CMP      R0,#+1
   \      0x290   0xF240 0x80FC      BLS.W    ??process_next_command_45
   \      0x294   0x3811             SUBS     R0,R0,#+17
   \      0x296   0xF000 0x80FC      BEQ.W    ??process_next_command_46
   \      0x29A   0x1E40             SUBS     R0,R0,#+1
   \      0x29C   0xF000 0x81BB      BEQ.W    ??process_next_command_47
   \      0x2A0   0x1E80             SUBS     R0,R0,#+2
   \      0x2A2   0xF000 0x80F9      BEQ.W    ??process_next_command_48
   \      0x2A6   0x1E40             SUBS     R0,R0,#+1
   \      0x2A8   0xF000 0x80F9      BEQ.W    ??process_next_command_49
   \      0x2AC   0x1E40             SUBS     R0,R0,#+1
   \      0x2AE   0xF000 0x80F9      BEQ.W    ??process_next_command_50
   \      0x2B2   0x1E40             SUBS     R0,R0,#+1
   \      0x2B4   0xF000 0x80F9      BEQ.W    ??process_next_command_51
   \      0x2B8   0x1E40             SUBS     R0,R0,#+1
   \      0x2BA   0xF000 0x8133      BEQ.W    ??process_next_command_52
   \      0x2BE   0x1E40             SUBS     R0,R0,#+1
   \      0x2C0   0xF000 0x8133      BEQ.W    ??process_next_command_53
   \      0x2C4   0x1E40             SUBS     R0,R0,#+1
   \      0x2C6   0xF000 0x8133      BEQ.W    ??process_next_command_54
   \      0x2CA   0x1E40             SUBS     R0,R0,#+1
   \      0x2CC   0xF000 0x8133      BEQ.W    ??process_next_command_55
   \      0x2D0   0x1E40             SUBS     R0,R0,#+1
   \      0x2D2   0xF000 0x8133      BEQ.W    ??process_next_command_56
   \      0x2D6   0x1E40             SUBS     R0,R0,#+1
   \      0x2D8   0xF000 0x8133      BEQ.W    ??process_next_command_57
   \      0x2DC   0x1E40             SUBS     R0,R0,#+1
   \      0x2DE   0xF000 0x8133      BEQ.W    ??process_next_command_58
   \      0x2E2   0x1E40             SUBS     R0,R0,#+1
   \      0x2E4   0xF000 0x8139      BEQ.W    ??process_next_command_59
   \      0x2E8   0x1E40             SUBS     R0,R0,#+1
   \      0x2EA   0xF000 0x8130      BEQ.W    ??process_next_command_60
   \      0x2EE   0x380A             SUBS     R0,R0,#+10
   \      0x2F0   0xF000 0x8136      BEQ.W    ??process_next_command_61
   \      0x2F4   0x1FC0             SUBS     R0,R0,#+7
   \      0x2F6   0xF000 0x8136      BEQ.W    ??process_next_command_62
   \      0x2FA   0x381A             SUBS     R0,R0,#+26
   \      0x2FC   0xF000 0x813C      BEQ.W    ??process_next_command_63
   \      0x300   0x1E40             SUBS     R0,R0,#+1
   \      0x302   0xF000 0x813C      BEQ.W    ??process_next_command_64
   \      0x306   0x1E40             SUBS     R0,R0,#+1
   \      0x308   0xF000 0x813C      BEQ.W    ??process_next_command_65
   \      0x30C   0x1F00             SUBS     R0,R0,#+4
   \      0x30E   0xF000 0x8179      BEQ.W    ??process_next_command_66
   \      0x312   0x1E40             SUBS     R0,R0,#+1
   \      0x314   0xF000 0x8179      BEQ.W    ??process_next_command_67
   \      0x318   0x1E40             SUBS     R0,R0,#+1
   \      0x31A   0xF000 0x8179      BEQ.W    ??process_next_command_68
   \      0x31E   0x1E40             SUBS     R0,R0,#+1
   \      0x320   0xF000 0x8179      BEQ.W    ??process_next_command_47
   \      0x324   0x1E40             SUBS     R0,R0,#+1
   \      0x326   0xF000 0x8179      BEQ.W    ??process_next_command_69
   \      0x32A   0x1FC0             SUBS     R0,R0,#+7
   \      0x32C   0xF000 0x8179      BEQ.W    ??process_next_command_70
   \      0x330   0x380C             SUBS     R0,R0,#+12
   \      0x332   0xF000 0x812A      BEQ.W    ??process_next_command_71
   \      0x336   0x1E40             SUBS     R0,R0,#+1
   \      0x338   0xF000 0x8149      BEQ.W    ??process_next_command_72
   \      0x33C   0x1E40             SUBS     R0,R0,#+1
   \      0x33E   0xF000 0x815B      BEQ.W    ??process_next_command_73
   \      0x342   0x1E40             SUBS     R0,R0,#+1
   \      0x344   0xF000 0x815B      BEQ.W    ??process_next_command_74
   \      0x348   0x1E40             SUBS     R0,R0,#+1
   \      0x34A   0xF000 0x8127      BEQ.W    ??process_next_command_75
   \      0x34E   0x1E40             SUBS     R0,R0,#+1
   \      0x350   0xF000 0x8142      BEQ.W    ??process_next_command_76
   \      0x354   0x1E40             SUBS     R0,R0,#+1
   \      0x356   0xF000 0x811B      BEQ.W    ??process_next_command_77
   \      0x35A   0x1E40             SUBS     R0,R0,#+1
   \      0x35C   0xF000 0x811B      BEQ.W    ??process_next_command_78
   \      0x360   0x1E40             SUBS     R0,R0,#+1
   \      0x362   0xF000 0x811E      BEQ.W    ??process_next_command_79
   \      0x366   0x1E40             SUBS     R0,R0,#+1
   \      0x368   0xF000 0x8121      BEQ.W    ??process_next_command_80
   \      0x36C   0x1E40             SUBS     R0,R0,#+1
   \      0x36E   0xF000 0x815B      BEQ.W    ??process_next_command_81
   \      0x372   0x1E40             SUBS     R0,R0,#+1
   \      0x374   0xF000 0x815B      BEQ.W    ??process_next_command_82
   \      0x378   0x1E80             SUBS     R0,R0,#+2
   \      0x37A   0xF000 0x815B      BEQ.W    ??process_next_command_83
   \      0x37E   0x1E80             SUBS     R0,R0,#+2
   \      0x380   0xF000 0x815B      BEQ.W    ??process_next_command_84
   \      0x384   0x1E40             SUBS     R0,R0,#+1
   \      0x386   0xF000 0x815B      BEQ.W    ??process_next_command_85
   \      0x38A   0x1E40             SUBS     R0,R0,#+1
   \      0x38C   0xF000 0x815B      BEQ.W    ??process_next_command_86
   \      0x390   0x3813             SUBS     R0,R0,#+19
   \      0x392   0xF000 0x810F      BEQ.W    ??process_next_command_87
   \      0x396   0x1F40             SUBS     R0,R0,#+5
   \      0x398   0xF000 0x8158      BEQ.W    ??process_next_command_88
   \      0x39C   0x382D             SUBS     R0,R0,#+45
   \      0x39E   0xF000 0x811E      BEQ.W    ??process_next_command_89
   \      0x3A2   0x380A             SUBS     R0,R0,#+10
   \      0x3A4   0xF000 0x8155      BEQ.W    ??process_next_command_90
   \      0x3A8   0x1E40             SUBS     R0,R0,#+1
   \      0x3AA   0xF000 0x8155      BEQ.W    ??process_next_command_91
   \      0x3AE   0x1E80             SUBS     R0,R0,#+2
   \      0x3B0   0xF000 0x8155      BEQ.W    ??process_next_command_92
   \      0x3B4   0x1E40             SUBS     R0,R0,#+1
   \      0x3B6   0xF000 0x8155      BEQ.W    ??process_next_command_93
   \      0x3BA   0x1E40             SUBS     R0,R0,#+1
   \      0x3BC   0xF000 0x8155      BEQ.W    ??process_next_command_94
   \      0x3C0   0x1E40             SUBS     R0,R0,#+1
   \      0x3C2   0xF000 0x8155      BEQ.W    ??process_next_command_95
   \      0x3C6   0x1F40             SUBS     R0,R0,#+5
   \      0x3C8   0xF000 0x8170      BEQ.W    ??process_next_command_96
   \      0x3CC   0x3809             SUBS     R0,R0,#+9
   \      0x3CE   0xF000 0x8170      BEQ.W    ??process_next_command_97
   \      0x3D2   0x1E40             SUBS     R0,R0,#+1
   \      0x3D4   0xF000 0x8170      BEQ.W    ??process_next_command_98
   \      0x3D8   0x1F40             SUBS     R0,R0,#+5
   \      0x3DA   0xF000 0x8170      BEQ.W    ??process_next_command_99
   \      0x3DE   0x384A             SUBS     R0,R0,#+74
   \      0x3E0   0xF000 0x8170      BEQ.W    ??process_next_command_100
   \      0x3E4   0x1E40             SUBS     R0,R0,#+1
   \      0x3E6   0xF000 0x8170      BEQ.W    ??process_next_command_101
   \      0x3EA   0x1E40             SUBS     R0,R0,#+1
   \      0x3EC   0xF000 0x8180      BEQ.W    ??process_next_command_102
   \      0x3F0   0x1E40             SUBS     R0,R0,#+1
   \      0x3F2   0xF000 0x8180      BEQ.W    ??process_next_command_103
   \      0x3F6   0x1E40             SUBS     R0,R0,#+1
   \      0x3F8   0xF000 0x8171      BEQ.W    ??process_next_command_104
   \      0x3FC   0x3833             SUBS     R0,R0,#+51
   \      0x3FE   0xF000 0x81F4      BEQ.W    ??process_next_command_105
   \      0x402   0x1F40             SUBS     R0,R0,#+5
   \      0x404   0xF000 0x817A      BEQ.W    ??process_next_command_106
   \      0x408   0x1E40             SUBS     R0,R0,#+1
   \      0x40A   0xF000 0x8183      BEQ.W    ??process_next_command_107
   \      0x40E   0x1E40             SUBS     R0,R0,#+1
   \      0x410   0xF000 0x818C      BEQ.W    ??process_next_command_108
   \      0x414   0x1E40             SUBS     R0,R0,#+1
   \      0x416   0xF000 0x8195      BEQ.W    ??process_next_command_109
   \      0x41A   0x1E40             SUBS     R0,R0,#+1
   \      0x41C   0xF000 0x819E      BEQ.W    ??process_next_command_110
   \      0x420   0x3824             SUBS     R0,R0,#+36
   \      0x422   0xF000 0x81A7      BEQ.W    ??process_next_command_111
   \      0x426   0x1E40             SUBS     R0,R0,#+1
   \      0x428   0xF000 0x81A7      BEQ.W    ??process_next_command_112
   \      0x42C   0x1E40             SUBS     R0,R0,#+1
   \      0x42E   0xF000 0x81A7      BEQ.W    ??process_next_command_113
   \      0x432   0x3808             SUBS     R0,R0,#+8
   \      0x434   0xF000 0x80B8      BEQ.W    ??process_next_command_114
   \      0x438   0x380A             SUBS     R0,R0,#+10
   \      0x43A   0xF000 0x81A4      BEQ.W    ??process_next_command_115
   \      0x43E   0x1E40             SUBS     R0,R0,#+1
   \      0x440   0xF000 0x81AA      BEQ.W    ??process_next_command_116
   \      0x444   0x1FC0             SUBS     R0,R0,#+7
   \      0x446   0xF000 0x81B2      BEQ.W    ??process_next_command_117
   \      0x44A   0x3848             SUBS     R0,R0,#+72
   \      0x44C   0xF000 0x81B8      BEQ.W    ??process_next_command_118
   \      0x450   0x1E40             SUBS     R0,R0,#+1
   \      0x452   0xF000 0x81B8      BEQ.W    ??process_next_command_119
   \      0x456   0x1E40             SUBS     R0,R0,#+1
   \      0x458   0xF000 0x81B8      BEQ.W    ??process_next_command_120
   \      0x45C   0x1E40             SUBS     R0,R0,#+1
   \      0x45E   0xF000 0x81B8      BEQ.W    ??process_next_command_121
   \      0x462   0x3861             SUBS     R0,R0,#+97
   \      0x464   0xF000 0x81BB      BEQ.W    ??process_next_command_122
   \      0x468   0x3841             SUBS     R0,R0,#+65
   \      0x46A   0xF000 0x810B      BEQ.W    ??process_next_command_123
   \      0x46E   0x1E40             SUBS     R0,R0,#+1
   \      0x470   0xF000 0x8112      BEQ.W    ??process_next_command_124
   \      0x474   0x38B9             SUBS     R0,R0,#+185
   \      0x476   0xF000 0x81AF      BEQ.W    ??process_next_command_125
   \      0x47A   0x3838             SUBS     R0,R0,#+56
   \      0x47C   0xF000 0x81B2      BEQ.W    ??process_next_command_126
   \      0x480   0x3815             SUBS     R0,R0,#+21
   \      0x482   0xD067             BEQ.N    ??process_next_command_127
   \      0x484   0x3847             SUBS     R0,R0,#+71
   \      0x486   0xF000 0x81B3      BEQ.W    ??process_next_command_128
   \      0x48A   0xE1B9             B.N      ??process_next_command_22
  11267                #if HAS_RESUME_CONTINUE
  11268                  case 0: // M0: Unconditional stop - Wait for user button press on LCD
  11269                  case 1: // M1: Conditional stop - Wait for user button press on LCD
  11270                    gcode_M0_M1();
   \                     ??process_next_command_45: (+1)
   \      0x48C   0x.... 0x....      BL       _Z11gcode_M0_M1v
  11271                    break;
   \      0x490   0xE1B6             B.N      ??process_next_command_22
  11272                #endif // ULTIPANEL
  11273          
  11274                case 17: // M17: Enable all stepper motors
  11275                  gcode_M17();
   \                     ??process_next_command_46: (+1)
   \      0x492   0x.... 0x....      BL       _Z9gcode_M17v
  11276                  break;
   \      0x496   0xE1B3             B.N      ??process_next_command_22
  11277          
  11278                #if ENABLED(SDSUPPORT)
  11279                  case 20: // M20: list SD card
  11280                    gcode_M20(); break;
   \                     ??process_next_command_48: (+1)
   \      0x498   0x.... 0x....      BL       _Z9gcode_M20v
   \      0x49C   0xE1B0             B.N      ??process_next_command_22
  11281                  case 21: // M21: init SD card
  11282                    gcode_M21(); break;
   \                     ??process_next_command_49: (+1)
   \      0x49E   0x.... 0x....      BL       _Z9gcode_M21v
   \      0x4A2   0xE1AD             B.N      ??process_next_command_22
  11283                  case 22: // M22: release SD card
  11284                    gcode_M22(); break;
   \                     ??process_next_command_50: (+1)
   \      0x4A4   0x.... 0x....      BL       _Z9gcode_M22v
   \      0x4A8   0xE1AA             B.N      ??process_next_command_22
  11285                  case 23: // M23: Select file
  11286                    memset(mksReprint.filename,0,sizeof(mksReprint.filename));
   \                     ??process_next_command_51: (+1)
   \      0x4AA   0x2200             MOVS     R2,#+0
   \      0x4AC   0x211E             MOVS     R1,#+30
   \      0x4AE   0xF106 0x0014      ADD      R0,R6,#+20
   \      0x4B2   0x.... 0x....      BL       __aeabi_memset4
  11287                    char *tmp_index = NULL;
  11288          /*		  
  11289                    tmp_index = (char *)strstr(current_command_args, ",");
  11290                    if(tmp_index) *tmp_index = 0;
  11291          		  
  11292          		 if(mksReprint.dirname[0] == 0 || tmp_index != NULL)
  11293          	  		{
  11294          	  		strcpy(mksReprint.filename,current_command_args);
  11295          	  		}
  11296          	  	else
  11297          	  		{
  11298          	  		strcpy(mksReprint.filename,mksReprint.dirname);
  11299          		  	strcat(mksReprint.filename,"/");
  11300                      strcat(mksReprint.filename,current_command_args);
  11301          	  		}
  11302          */
  11303          	  tmp_index = (char *)strstr(current_command_args, "/");
   \      0x4B6   0x6ABF             LDR      R7,[R7, #+40]
   \      0x4B8   0xF20F 0x0818      ADR.W    R8,??process_next_command_0  ;; "/"
   \      0x4BC   0x4641             MOV      R1,R8
   \      0x4BE   0x4638             MOV      R0,R7
   \      0x4C0   0x.... 0x....      BL       __iar_Strstr
  11304          	  if(tmp_index)
   \      0x4C4   0x2800             CMP      R0,#+0
   \      0x4C6   0xD007             BEQ.N    ??process_next_command_129
  11305          	  	{
  11306          		  	strcpy(mksReprint.filename,current_command_args);
   \      0x4C8   0x4639             MOV      R1,R7
   \      0x4CA   0xF106 0x0014      ADD      R0,R6,#+20
   \      0x4CE   0x.... 0x....      BL       strcpy
   \      0x4D2   0xE014             B.N      ??process_next_command_130
   \                     ??process_next_command_0:
   \      0x4D4   0x2F 0x00          DC8      "/",0x0,0x0
   \              0x00 0x00    
  11307          	  	}
  11308          	  else
  11309          	  	{
  11310          	  	if(mksReprint.dirname[0] != 0)
   \                     ??process_next_command_129: (+1)
   \      0x4D8   0xF996 0x0000      LDRSB    R0,[R6, #+0]
   \      0x4DC   0x2800             CMP      R0,#+0
   \      0x4DE   0xD009             BEQ.N    ??process_next_command_131
  11311          	  		{
  11312          			  strcpy(mksReprint.filename,mksReprint.dirname);
   \      0x4E0   0x4631             MOV      R1,R6
   \      0x4E2   0xF106 0x0014      ADD      R0,R6,#+20
   \      0x4E6   0x.... 0x....      BL       strcpy
  11313          			  strcat(mksReprint.filename,"/");
   \      0x4EA   0x4641             MOV      R1,R8
   \      0x4EC   0xF106 0x0014      ADD      R0,R6,#+20
   \      0x4F0   0x.... 0x....      BL       strcat
  11314          	  		}
  11315          		  strcat(mksReprint.filename,current_command_args);
   \                     ??process_next_command_131: (+1)
   \      0x4F4   0x4639             MOV      R1,R7
   \      0x4F6   0xF106 0x0014      ADD      R0,R6,#+20
   \      0x4FA   0x.... 0x....      BL       strcat
  11316          	  	
  11317          	  	}
  11318          		memset(mksReprint.dirname,0,sizeof(mksReprint.dirname));	//Ä¿Â¼ÃûÇåÁã
   \                     ??process_next_command_130: (+1)
   \      0x4FE   0x2200             MOVS     R2,#+0
   \      0x500   0x2114             MOVS     R1,#+20
   \      0x502   0x4630             MOV      R0,R6
   \      0x504   0x.... 0x....      BL       __aeabi_memset4
  11319          		
  11320          	  //±£´æÎÄ¼þÃû
  11321                    epr_write_data(EPR_SAV_FILENAME, (uint8_t *)&mksReprint.filename[0],sizeof(mksReprint.filename));	
   \      0x508   0x221E             MOVS     R2,#+30
   \      0x50A   0xF106 0x0114      ADD      R1,R6,#+20
   \      0x50E   0xF240 0x50B6      MOVW     R0,#+1462
   \      0x512   0x.... 0x....      BL       epr_write_data
  11322          		  mks_clearDir();	
   \      0x516   0x.... 0x....      BL       mks_clearDir
  11323          	  //Çå³ý ±£´æ¼ÇÂ¼
  11324           	  	  mks_clearFile();
   \      0x51A   0x.... 0x....      BL       mks_clearFile
  11325                    gcode_M23(); 
   \      0x51E   0x.... 0x....      BL       _Z9gcode_M23v
  11326                    break;
   \      0x522   0xE16D             B.N      ??process_next_command_22
  11327                  case 24: // M24: Start SD print
  11328                    gcode_M24(); break;
   \                     ??process_next_command_52: (+1)
   \      0x524   0x.... 0x....      BL       _Z9gcode_M24v
   \      0x528   0xE16A             B.N      ??process_next_command_22
  11329                  case 25: // M25: Pause SD print
  11330                    gcode_M25(); break;
   \                     ??process_next_command_53: (+1)
   \      0x52A   0x.... 0x....      BL       _Z9gcode_M25v
   \      0x52E   0xE167             B.N      ??process_next_command_22
  11331                  case 26: // M26: Set SD index
  11332                    gcode_M26(); break;
   \                     ??process_next_command_54: (+1)
   \      0x530   0x.... 0x....      BL       _Z9gcode_M26v
   \      0x534   0xE164             B.N      ??process_next_command_22
  11333                  case 27: // M27: Get SD status
  11334                    gcode_M27(); break;
   \                     ??process_next_command_55: (+1)
   \      0x536   0x.... 0x....      BL       _Z9gcode_M27v
   \      0x53A   0xE161             B.N      ??process_next_command_22
  11335                  case 28: // M28: Start SD write
  11336                    gcode_M28(); break;
   \                     ??process_next_command_56: (+1)
   \      0x53C   0x.... 0x....      BL       _Z9gcode_M28v
   \      0x540   0xE15E             B.N      ??process_next_command_22
  11337                  case 29: // M29: Stop SD write
  11338                    gcode_M29(); break;
   \                     ??process_next_command_57: (+1)
   \      0x542   0x.... 0x....      BL       _Z9gcode_M29v
   \      0x546   0xE15B             B.N      ??process_next_command_22
  11339                  case 30: // M30 <filename> Delete File
  11340                    gcode_M30(); break;
   \                     ??process_next_command_58: (+1)
   \      0x548   0x.... 0x....      BL       _Z9gcode_M30v
   \      0x54C   0xE158             B.N      ??process_next_command_22
  11341                  case 32: // M32: Select file and start SD print
  11342                    gcode_M32(); break;
   \                     ??process_next_command_60: (+1)
   \      0x54E   0x.... 0x....      BL       _Z9gcode_M32v
   \      0x552   0xE155             B.N      ??process_next_command_22
  11343          
  11344                  #if ENABLED(LONG_FILENAME_HOST_SUPPORT)
  11345                    case 33: // M33: Get the long full path to a file or folder
  11346                      gcode_M33(); break;
  11347                  #endif
  11348          
  11349                  #if ENABLED(SDCARD_SORT_ALPHA) && ENABLED(SDSORT_GCODE)
  11350                    case 34: //M34 - Set SD card sorting options
  11351                      gcode_M34(); break;
  11352                  #endif // SDCARD_SORT_ALPHA && SDSORT_GCODE
  11353          
  11354                  case 928: // M928: Start SD write
  11355                    gcode_M928(); break;
   \                     ??process_next_command_127: (+1)
   \      0x554   0x.... 0x....      BL       _Z10gcode_M928v
   \      0x558   0xE152             B.N      ??process_next_command_22
  11356                #endif //SDSUPPORT
  11357          
  11358                case 31: // M31: Report time since the start of SD print or last M109
  11359                  gcode_M31(); break;
   \                     ??process_next_command_59: (+1)
   \      0x55A   0x.... 0x....      BL       _Z9gcode_M31v
   \      0x55E   0xE14F             B.N      ??process_next_command_22
  11360          
  11361                case 42: // M42: Change pin state
  11362                  gcode_M42(); break;
   \                     ??process_next_command_61: (+1)
   \      0x560   0x.... 0x....      BL       _Z9gcode_M42v
   \      0x564   0xE14C             B.N      ??process_next_command_22
  11363          
  11364                #if ENABLED(PINS_DEBUGGING)
  11365                  case 43: // M43: Read pin state
  11366                    gcode_M43(); break;
  11367                #endif
  11368          
  11369          
  11370                #if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
  11371                  case 48: // M48: Z probe repeatability test
  11372                    gcode_M48();
  11373                    break;
  11374                #endif // Z_MIN_PROBE_REPEATABILITY_TEST
  11375          
  11376                //#if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(UBL_G26_MESH_EDITING)
  11377          	  	#if 1
  11378                  case 49: // M49: Turn on or off G26 debug flag for verbose output
  11379                    if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_UBL)
   \                     ??process_next_command_62: (+1)
   \      0x566   0x.... 0x....      LDR.W    R0,??DataTable141
   \      0x56A   0x7B00             LDRB     R0,[R0, #+12]
   \      0x56C   0x06C0             LSLS     R0,R0,#+27
   \      0x56E   0xF140 0x8147      BPL.W    ??process_next_command_22
  11380                    	gcode_M49();
   \      0x572   0x.... 0x....      BL       _Z9gcode_M49v
   \      0x576   0xE143             B.N      ??process_next_command_22
  11381                    break;
  11382                #endif // AUTO_BED_LEVELING_UBL && UBL_G26_MESH_EDITING
  11383          
  11384                case 75: // M75: Start print timer
  11385                  gcode_M75(); break;
   \                     ??process_next_command_63: (+1)
   \      0x578   0x.... 0x....      BL       _Z9gcode_M75v
   \      0x57C   0xE140             B.N      ??process_next_command_22
  11386                case 76: // M76: Pause print timer
  11387                  gcode_M76(); break;
   \                     ??process_next_command_64: (+1)
   \      0x57E   0x.... 0x....      BL       _Z9gcode_M76v
   \      0x582   0xE13D             B.N      ??process_next_command_22
  11388                case 77: // M77: Stop print timer
  11389                  gcode_M77(); break;
   \                     ??process_next_command_65: (+1)
   \      0x584   0x.... 0x....      BL       _Z9gcode_M77v
   \      0x588   0xE13A             B.N      ??process_next_command_22
  11390          
  11391                #if ENABLED(PRINTCOUNTER)
  11392                  case 78: // M78: Show print statistics
  11393                    gcode_M78(); break;
  11394                #endif
  11395          
  11396                #if ENABLED(M100_FREE_MEMORY_WATCHER)
  11397                  case 100: // M100: Free Memory Report
  11398                    gcode_M100();
  11399                    break;
  11400                #endif
  11401          
  11402                case 104: // M104: Set hot end temperature
  11403                  gcode_M104();
   \                     ??process_next_command_71: (+1)
   \      0x58A   0x.... 0x....      BL       _Z10gcode_M104v
  11404                  break;
   \      0x58E   0xE137             B.N      ??process_next_command_22
  11405          
  11406                case 110: // M110: Set Current Line Number
  11407                  gcode_M110();
   \                     ??process_next_command_77: (+1)
   \      0x590   0x.... 0x....      BL       _Z10gcode_M110v
  11408                  break;
   \      0x594   0xE134             B.N      ??process_next_command_22
  11409          
  11410                case 111: // M111: Set debug level
  11411                  gcode_M111();
   \                     ??process_next_command_78: (+1)
   \      0x596   0x.... 0x....      BL       _Z10gcode_M111v
  11412                  break;
   \      0x59A   0xE131             B.N      ??process_next_command_22
  11413          
  11414                #if DISABLED(EMERGENCY_PARSER)
  11415          
  11416                  case 108: // M108: Cancel Waiting
  11417                    gcode_M108();
   \                     ??process_next_command_75: (+1)
   \      0x59C   0x.... 0x....      BL       _Z10gcode_M108v
  11418                    break;
   \      0x5A0   0xE12E             B.N      ??process_next_command_22
  11419          
  11420                  case 112: // M112: Emergency Stop
  11421                    gcode_M112();
   \                     ??process_next_command_79: (+1)
   \      0x5A2   0x.... 0x....      BL       _Z10gcode_M112v
  11422                    break;
   \      0x5A6   0xE12B             B.N      ??process_next_command_22
  11423          
  11424                  case 410: // M410 quickstop - Abort all the planned moves.
  11425                    gcode_M410();
   \                     ??process_next_command_114: (+1)
   \      0x5A8   0x.... 0x....      BL       _Z10gcode_M410v
  11426                    break;
   \      0x5AC   0xE128             B.N      ??process_next_command_22
  11427          
  11428                #endif
  11429          
  11430                #if ENABLED(HOST_KEEPALIVE_FEATURE)
  11431                  case 113: // M113: Set Host Keepalive interval
  11432                    gcode_M113();
   \                     ??process_next_command_80: (+1)
   \      0x5AE   0x.... 0x....      BL       _Z10gcode_M113v
  11433                    break;
   \      0x5B2   0xE125             B.N      ??process_next_command_22
  11434                #endif
  11435                case 140: // M140: Set bed temperature
  11436          	if(HAS_TEMP_BED)	/*--mks cfg-- HAS_TEMP_BED --*/
   \                     ??process_next_command_87: (+1)
   \      0x5B4   0x.... 0x....      LDR.W    R0,??DataTable141
   \      0x5B8   0x7880             LDRB     R0,[R0, #+2]
   \      0x5BA   0x2800             CMP      R0,#+0
   \      0x5BC   0xD002             BEQ.N    ??process_next_command_132
  11437                    gcode_M140();
   \      0x5BE   0x.... 0x....      BL       _Z10gcode_M140v
   \      0x5C2   0xE11D             B.N      ??process_next_command_22
  11438                  else
  11439                    SERIAL_PROTOCOLLNPGM("HAS_NO_TEMP_BED!"); 
   \                     ??process_next_command_132: (+1)
   \      0x5C4   0x.... 0x....      ADR.W    R0,?_38
   \      0x5C8   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \      0x5CC   0xE118             B.N      ??process_next_command_22
  11440                  break;
  11441                case 105: // M105: Report current temperature
  11442                  gcode_M105();
   \                     ??process_next_command_72: (+1)
   \      0x5CE   0x.... 0x....      BL       _Z10gcode_M105v
  11443                  KEEPALIVE_STATE(NOT_BUSY);
   \      0x5D2   0x2000             MOVS     R0,#+0
   \      0x5D4   0x71A0             STRB     R0,[R4, #+6]
  11444                  return; // "ok" already printed
   \      0x5D6   0xE11C             B.N      ??process_next_command_133
  11445                  
  11446          		/*--mks cfg-- HAS_TEMP_BED --*/
  11447                //#if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
  11448          		#if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND)
  11449                  case 155: // M155: Set temperature auto-report interval
  11450                    gcode_M155();
  11451                    break;
  11452                #endif
  11453          
  11454                case 109: // M109: Wait for hotend temperature to reach target
  11455                  gcode_M109();
   \                     ??process_next_command_76: (+1)
   \      0x5D8   0x.... 0x....      BL       _Z10gcode_M109v
  11456                  break;
   \      0x5DC   0xE110             B.N      ??process_next_command_22
  11457          
  11458               // #if HAS_TEMP_BED	/*--mks cfg-- HAS_TEMP_BED --*/
  11459                  case 190: // M190: Wait for bed temperature to reach target
  11460                   if(HAS_TEMP_BED) 
   \                     ??process_next_command_89: (+1)
   \      0x5DE   0x.... 0x....      LDR.W    R0,??DataTable141
   \      0x5E2   0x7880             LDRB     R0,[R0, #+2]
   \      0x5E4   0x2800             CMP      R0,#+0
   \      0x5E6   0xD002             BEQ.N    ??process_next_command_134
  11461                    gcode_M190();
   \      0x5E8   0x.... 0x....      BL       _Z10gcode_M190v
   \      0x5EC   0xE108             B.N      ??process_next_command_22
  11462                   else
  11463                     SERIAL_PROTOCOLLNPGM("HAS_NO_TEMP_BED!");
   \                     ??process_next_command_134: (+1)
   \      0x5EE   0x.... 0x....      ADR.W    R0,?_38
   \      0x5F2   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \      0x5F6   0xE103             B.N      ??process_next_command_22
  11464                    break;
  11465                //#endif // HAS_TEMP_BED
  11466          
  11467                #if FAN_COUNT > 0
  11468                  case 106: // M106: Fan On
  11469                    gcode_M106();
   \                     ??process_next_command_73: (+1)
   \      0x5F8   0x.... 0x....      BL       _Z10gcode_M106v
  11470                    break;
   \      0x5FC   0xE100             B.N      ??process_next_command_22
  11471                  case 107: // M107: Fan Off
  11472                    gcode_M107();
   \                     ??process_next_command_74: (+1)
   \      0x5FE   0x.... 0x....      BL       _Z10gcode_M107v
  11473                    break;
   \      0x602   0xE0FD             B.N      ??process_next_command_22
  11474                #endif // FAN_COUNT > 0
  11475          
  11476                #if ENABLED(PARK_HEAD_ON_PAUSE)
  11477                  case 125: // M125: Store current position and move to filament change position
  11478                    gcode_M125(); break;
  11479                #endif
  11480          
  11481                #if ENABLED(BARICUDA)
  11482                  // PWM for HEATER_1_PIN
  11483                  #if HAS_HEATER_1
  11484                    case 126: // M126: valve open
  11485                      gcode_M126();
  11486                      break;
  11487                    case 127: // M127: valve closed
  11488                      gcode_M127();
  11489                      break;
  11490                  #endif // HAS_HEATER_1
  11491          
  11492                  // PWM for HEATER_2_PIN
  11493                  #if HAS_HEATER_2
  11494                    case 128: // M128: valve open
  11495                      gcode_M128();
  11496                      break;
  11497                    case 129: // M129: valve closed
  11498                      gcode_M129();
  11499                      break;
  11500                  #endif // HAS_HEATER_2
  11501                #endif // BARICUDA
  11502          
  11503                #if HAS_POWER_SWITCH
  11504          
  11505                  case 80: // M80: Turn on Power Supply
  11506                    gcode_M80();
  11507                    break;
  11508          
  11509                #endif // HAS_POWER_SWITCH
  11510          
  11511                case 81: // M81: Turn off Power, including Power Supply, if possible
  11512                  gcode_M81();
   \                     ??process_next_command_66: (+1)
   \      0x604   0x.... 0x....      BL       _Z9gcode_M81v
  11513                  break;
   \      0x608   0xE0FA             B.N      ??process_next_command_22
  11514          
  11515                case 82: // M83: Set E axis normal mode (same as other axes)
  11516                  gcode_M82();
   \                     ??process_next_command_67: (+1)
   \      0x60A   0x.... 0x....      BL       _Z9gcode_M82v
  11517                  break;
   \      0x60E   0xE0F7             B.N      ??process_next_command_22
  11518                case 83: // M83: Set E axis relative mode
  11519                  gcode_M83();
   \                     ??process_next_command_68: (+1)
   \      0x610   0x.... 0x....      BL       _Z9gcode_M83v
  11520                  break;
   \      0x614   0xE0F4             B.N      ??process_next_command_22
  11521                case 18: // M18 => M84
  11522                case 84: // M84: Disable all steppers or set timeout
  11523                  gcode_M18_M84();
   \                     ??process_next_command_47: (+1)
   \      0x616   0x.... 0x....      BL       _Z13gcode_M18_M84v
  11524                  break;
   \      0x61A   0xE0F1             B.N      ??process_next_command_22
  11525                case 85: // M85: Set inactivity stepper shutdown timeout
  11526                  gcode_M85();
   \                     ??process_next_command_69: (+1)
   \      0x61C   0x.... 0x....      BL       _Z9gcode_M85v
  11527                  break;
   \      0x620   0xE0EE             B.N      ??process_next_command_22
  11528                case 92: // M92: Set the steps-per-unit for one or more axes
  11529                  gcode_M92();
   \                     ??process_next_command_70: (+1)
   \      0x622   0x.... 0x....      BL       _Z9gcode_M92v
  11530                  break;
   \      0x626   0xE0EB             B.N      ??process_next_command_22
  11531                case 114: // M114: Report current position
  11532                  gcode_M114();
   \                     ??process_next_command_81: (+1)
   \      0x628   0x.... 0x....      BL       _Z10gcode_M114v
  11533                  break;
   \      0x62C   0xE0E8             B.N      ??process_next_command_22
  11534                case 115: // M115: Report capabilities
  11535                  gcode_M115();
   \                     ??process_next_command_82: (+1)
   \      0x62E   0x.... 0x....      BL       _Z10gcode_M115v
  11536                  break;
   \      0x632   0xE0E5             B.N      ??process_next_command_22
  11537                case 117: // M117: Set LCD message text, if possible
  11538                  gcode_M117();
   \                     ??process_next_command_83: (+1)
   \      0x634   0x.... 0x....      BL       _Z10gcode_M117v
  11539                  break;
   \      0x638   0xE0E2             B.N      ??process_next_command_22
  11540                case 119: // M119: Report endstop states
  11541                  gcode_M119();
   \                     ??process_next_command_84: (+1)
   \      0x63A   0x.... 0x....      BL       _Z10gcode_M119v
  11542                  break;
   \      0x63E   0xE0DF             B.N      ??process_next_command_22
  11543                case 120: // M120: Enable endstops
  11544                  gcode_M120();
   \                     ??process_next_command_85: (+1)
   \      0x640   0x.... 0x....      BL       _Z10gcode_M120v
  11545                  break;
   \      0x644   0xE0DC             B.N      ??process_next_command_22
  11546                case 121: // M121: Disable endstops
  11547                  gcode_M121();
   \                     ??process_next_command_86: (+1)
   \      0x646   0x.... 0x....      BL       _Z10gcode_M121v
  11548                  break;
   \      0x64A   0xE0D9             B.N      ??process_next_command_22
  11549          
  11550                #if ENABLED(ULTIPANEL)
  11551          
  11552                  case 145: // M145: Set material heatup parameters
  11553                    gcode_M145();
   \                     ??process_next_command_88: (+1)
   \      0x64C   0x.... 0x....      BL       _Z10gcode_M145v
  11554                    break;
   \      0x650   0xE0D6             B.N      ??process_next_command_22
  11555          
  11556                #endif
  11557          
  11558                #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
  11559                  case 149: // M149: Set temperature units
  11560                    gcode_M149();
  11561                    break;
  11562                #endif
  11563          
  11564                #if HAS_COLOR_LEDS
  11565          
  11566                  case 150: // M150: Set Status LED Color
  11567                    gcode_M150();
  11568                    break;
  11569          
  11570                #endif // BLINKM
  11571          
  11572                #if ENABLED(MIXING_EXTRUDER)
  11573                  case 163: // M163: Set a component weight for mixing extruder
  11574                    gcode_M163();
  11575                    break;
  11576                  #if MIXING_VIRTUAL_TOOLS > 1
  11577                    case 164: // M164: Save current mix as a virtual extruder
  11578                      gcode_M164();
  11579                      break;
  11580                  #endif
  11581                  #if ENABLED(DIRECT_MIXING_IN_G1)
  11582                    case 165: // M165: Set multiple mix weights
  11583                      gcode_M165();
  11584                      break;
  11585                  #endif
  11586                #endif
  11587          
  11588                case 200: // M200: Set filament diameter, E to cubic units
  11589                  gcode_M200();
   \                     ??process_next_command_90: (+1)
   \      0x652   0x.... 0x....      BL       _Z10gcode_M200v
  11590                  break;
   \      0x656   0xE0D3             B.N      ??process_next_command_22
  11591                case 201: // M201: Set max acceleration for print moves (units/s^2)
  11592                  gcode_M201();
   \                     ??process_next_command_91: (+1)
   \      0x658   0x.... 0x....      BL       _Z10gcode_M201v
  11593                  break;
   \      0x65C   0xE0D0             B.N      ??process_next_command_22
  11594                #if 0 // Not used for Sprinter/grbl gen6
  11595                  case 202: // M202
  11596                    gcode_M202();
  11597                    break;
  11598                #endif
  11599                case 203: // M203: Set max feedrate (units/sec)
  11600                  gcode_M203();
   \                     ??process_next_command_92: (+1)
   \      0x65E   0x.... 0x....      BL       _Z10gcode_M203v
  11601                  break;
   \      0x662   0xE0CD             B.N      ??process_next_command_22
  11602                case 204: // M204: Set acceleration
  11603                  gcode_M204();
   \                     ??process_next_command_93: (+1)
   \      0x664   0x.... 0x....      BL       _Z10gcode_M204v
  11604                  break;
   \      0x668   0xE0CA             B.N      ??process_next_command_22
  11605                case 205: //M205: Set advanced settings
  11606                  gcode_M205();
   \                     ??process_next_command_94: (+1)
   \      0x66A   0x.... 0x....      BL       _Z10gcode_M205v
  11607                  break;
   \      0x66E   0xE0C7             B.N      ??process_next_command_22
  11608          
  11609                //#if HAS_M206_COMMAND	//mks_delta
  11610                  case 206: // M206: Set home offsets
  11611                  if(MACHINETPYE != DELTA)
   \                     ??process_next_command_95: (+1)
   \      0x670   0x.... 0x....      LDR.W    R0,??DataTable141
   \      0x674   0xF9B0 0x0024      LDRSH    R0,[R0, #+36]
   \      0x678   0x2802             CMP      R0,#+2
   \      0x67A   0xF000 0x80C1      BEQ.W    ??process_next_command_22
  11612                    gcode_M206();
   \      0x67E   0x.... 0x....      BL       _Z10gcode_M206v
   \      0x682   0xE0BD             B.N      ??process_next_command_22
  11613                    break;
  11614                //#endif
  11615          
  11616                //#if ENABLED(DELTA)
  11617                  case 665: // M665: Set delta configurations
  11618                  	if(MACHINETPYE == DELTA)
   \                     ??process_next_command_123: (+1)
   \      0x684   0x.... 0x....      LDR.W    R0,??DataTable141
   \      0x688   0xF9B0 0x0024      LDRSH    R0,[R0, #+36]
   \      0x68C   0x2802             CMP      R0,#+2
   \      0x68E   0xF040 0x80B7      BNE.W    ??process_next_command_22
  11619                    gcode_M665();
   \      0x692   0x.... 0x....      BL       _Z10gcode_M665v
   \      0x696   0xE0B3             B.N      ??process_next_command_22
  11620                    break;
  11621                //#endif
  11622          
  11623                //#if ENABLED(DELTA) || ENABLED(Z_DUAL_ENDSTOPS)
  11624                  case 666: // M666: Set delta or dual endstop adjustment
  11625                  if(MACHINETPYE == DELTA)
   \                     ??process_next_command_124: (+1)
   \      0x698   0x.... 0x....      LDR.W    R0,??DataTable141
   \      0x69C   0xF9B0 0x0024      LDRSH    R0,[R0, #+36]
   \      0x6A0   0x2802             CMP      R0,#+2
   \      0x6A2   0xF040 0x80AD      BNE.W    ??process_next_command_22
  11626                    gcode_M666();
   \      0x6A6   0x.... 0x....      BL       _Z10gcode_M666v
   \      0x6AA   0xE0A9             B.N      ??process_next_command_22
  11627                    break;
  11628                //#endif
  11629          
  11630                #if ENABLED(FWRETRACT)
  11631                  case 207: // M207: Set Retract Length, Feedrate, and Z lift
  11632                    gcode_M207();
  11633                    break;
  11634                  case 208: // M208: Set Recover (unretract) Additional Length and Feedrate
  11635                    gcode_M208();
  11636                    break;
  11637                  case 209: // M209: Turn Automatic Retract Detection on/off
  11638                    gcode_M209();
  11639                    break;
  11640                #endif // FWRETRACT
  11641          
  11642                case 211: // M211: Enable, Disable, and/or Report software endstops
  11643                  gcode_M211();
   \                     ??process_next_command_96: (+1)
   \      0x6AC   0x.... 0x....      BL       _Z10gcode_M211v
  11644                  break;
   \      0x6B0   0xE0A6             B.N      ??process_next_command_22
  11645          
  11646                #if HOTENDS > 1
  11647                  case 218: // M218: Set a tool offset
  11648                    gcode_M218();
  11649                    break;
  11650                #endif
  11651          
  11652                case 220: // M220: Set Feedrate Percentage: S<percent> ("FR" on your LCD)
  11653                  gcode_M220();
   \                     ??process_next_command_97: (+1)
   \      0x6B2   0x.... 0x....      BL       _Z10gcode_M220v
  11654                  break;
   \      0x6B6   0xE0A3             B.N      ??process_next_command_22
  11655          
  11656                case 221: // M221: Set Flow Percentage
  11657                  gcode_M221();
   \                     ??process_next_command_98: (+1)
   \      0x6B8   0x.... 0x....      BL       _Z10gcode_M221v
  11658                  break;
   \      0x6BC   0xE0A0             B.N      ??process_next_command_22
  11659          
  11660                case 226: // M226: Wait until a pin reaches a state
  11661                  gcode_M226();
   \                     ??process_next_command_99: (+1)
   \      0x6BE   0x.... 0x....      BL       _Z10gcode_M226v
  11662                  break;
   \      0x6C2   0xE09D             B.N      ??process_next_command_22
  11663          
  11664                #if HAS_SERVOS
  11665                  case 280: // M280: Set servo position absolute
  11666                    gcode_M280();
  11667                    break;
  11668                #endif // HAS_SERVOS
  11669          
  11670                #if HAS_BUZZER
  11671                  case 300: // M300: Play beep tone
  11672                    gcode_M300();
   \                     ??process_next_command_100: (+1)
   \      0x6C4   0x.... 0x....      BL       _Z10gcode_M300v
  11673                    break;
   \      0x6C8   0xE09A             B.N      ??process_next_command_22
  11674                #endif // HAS_BUZZER
  11675          
  11676                //#if ENABLED(PIDTEMP)	/*--mks cfg--*/
  11677                  case 301: // M301: Set hotend PID parameters
  11678          		if(PIDTEMP) 
   \                     ??process_next_command_101: (+1)
   \      0x6CA   0x.... 0x....      LDR.W    R0,??DataTable145
   \      0x6CE   0xF890 0x0034      LDRB     R0,[R0, #+52]
   \      0x6D2   0x2800             CMP      R0,#+0
   \      0x6D4   0xF000 0x8094      BEQ.W    ??process_next_command_22
  11679                    gcode_M301();
   \      0x6D8   0x.... 0x....      BL       _Z10gcode_M301v
   \      0x6DC   0xE090             B.N      ??process_next_command_22
  11680                    break;
  11681                //#endif // PIDTEMP
  11682          
  11683                //#if ENABLED(PIDTEMPBED)	/*--mks cfg--*/
  11684                  case 304: // M304: Set bed PID parameters
  11685          		if(PIDTEMPBED) 
   \                     ??process_next_command_104: (+1)
   \      0x6DE   0x.... 0x....      LDR.W    R0,??DataTable141
   \      0x6E2   0x7840             LDRB     R0,[R0, #+1]
   \      0x6E4   0x2800             CMP      R0,#+0
   \      0x6E6   0xF000 0x808B      BEQ.W    ??process_next_command_22
  11686                    gcode_M304();
   \      0x6EA   0x.... 0x....      BL       _Z10gcode_M304v
   \      0x6EE   0xE087             B.N      ??process_next_command_22
  11687                    break;
  11688                //#endif // PIDTEMPBED
  11689          
  11690                #if defined(CHDK) || HAS_PHOTOGRAPH
  11691                  case 240: // M240: Trigger a camera by emulating a Canon RC-1 : http://www.doc-diy.net/photo/rc-1_hacked/
  11692                    gcode_M240();
  11693                    break;
  11694                #endif // CHDK || PHOTOGRAPH_PIN
  11695          
  11696                #if HAS_LCD_CONTRAST
  11697                  case 250: // M250: Set LCD contrast
  11698                    gcode_M250();
  11699                    break;
  11700                #endif // HAS_LCD_CONTRAST
  11701          
  11702                #if ENABLED(EXPERIMENTAL_I2CBUS)
  11703          
  11704                  case 260: // M260: Send data to an i2c slave
  11705                    gcode_M260();
  11706                    break;
  11707          
  11708                  case 261: // M261: Request data from an i2c slave
  11709                    gcode_M261();
  11710                    break;
  11711          
  11712                #endif // EXPERIMENTAL_I2CBUS
  11713          
  11714                #if ENABLED(PREVENT_COLD_EXTRUSION)
  11715                  case 302: // M302: Allow cold extrudes (set the minimum extrude temperature)
  11716                    gcode_M302();
   \                     ??process_next_command_102: (+1)
   \      0x6F0   0x.... 0x....      BL       _Z10gcode_M302v
  11717                    break;
   \      0x6F4   0xE084             B.N      ??process_next_command_22
  11718                #endif // PREVENT_COLD_EXTRUSION
  11719          
  11720                case 303: // M303: PID autotune
  11721                  gcode_M303();
   \                     ??process_next_command_103: (+1)
   \      0x6F6   0x.... 0x....      BL       _Z10gcode_M303v
  11722                  break;
   \      0x6FA   0xE081             B.N      ??process_next_command_22
  11723          
  11724                //#if ENABLED(MORGAN_SCARA)
  11725                  case 360:  // M360: SCARA Theta pos1
  11726                  	if(MACHINETPYE == MORGAN_SCARA)
   \                     ??process_next_command_106: (+1)
   \      0x6FC   0x.... 0x....      LDR.W    R0,??DataTable141
   \      0x700   0xF9B0 0x0024      LDRSH    R0,[R0, #+36]
   \      0x704   0xF5B0 0x7F80      CMP      R0,#+256
   \      0x708   0xD17A             BNE.N    ??process_next_command_22
  11727                    if (gcode_M360()) return;
   \      0x70A   0x.... 0x....      BL       _Z10gcode_M360v
   \      0x70E   0x2800             CMP      R0,#+0
   \      0x710   0xD076             BEQ.N    ??process_next_command_22
   \      0x712   0xE07E             B.N      ??process_next_command_133
  11728                    break;
  11729                  case 361:  // M361: SCARA Theta pos2
  11730                  	if(MACHINETPYE == MORGAN_SCARA)
   \                     ??process_next_command_107: (+1)
   \      0x714   0x.... 0x....      LDR.W    R0,??DataTable141
   \      0x718   0xF9B0 0x0024      LDRSH    R0,[R0, #+36]
   \      0x71C   0xF5B0 0x7F80      CMP      R0,#+256
   \      0x720   0xD16E             BNE.N    ??process_next_command_22
  11731                    if (gcode_M361()) return;
   \      0x722   0x.... 0x....      BL       _Z10gcode_M361v
   \      0x726   0x2800             CMP      R0,#+0
   \      0x728   0xD06A             BEQ.N    ??process_next_command_22
   \      0x72A   0xE072             B.N      ??process_next_command_133
  11732                    break;
  11733                  case 362:  // M362: SCARA Psi pos1
  11734                 	 if(MACHINETPYE == MORGAN_SCARA)
   \                     ??process_next_command_108: (+1)
   \      0x72C   0x.... 0x....      LDR.W    R0,??DataTable141
   \      0x730   0xF9B0 0x0024      LDRSH    R0,[R0, #+36]
   \      0x734   0xF5B0 0x7F80      CMP      R0,#+256
   \      0x738   0xD162             BNE.N    ??process_next_command_22
  11735                    if (gcode_M362()) return;
   \      0x73A   0x.... 0x....      BL       _Z10gcode_M362v
   \      0x73E   0x2800             CMP      R0,#+0
   \      0x740   0xD05E             BEQ.N    ??process_next_command_22
   \      0x742   0xE066             B.N      ??process_next_command_133
  11736                    break;
  11737                  case 363:  // M363: SCARA Psi pos2
  11738                  	if(MACHINETPYE == MORGAN_SCARA)
   \                     ??process_next_command_109: (+1)
   \      0x744   0x.... 0x....      LDR.W    R0,??DataTable141
   \      0x748   0xF9B0 0x0024      LDRSH    R0,[R0, #+36]
   \      0x74C   0xF5B0 0x7F80      CMP      R0,#+256
   \      0x750   0xD156             BNE.N    ??process_next_command_22
  11739                    if (gcode_M363()) return;
   \      0x752   0x.... 0x....      BL       _Z10gcode_M363v
   \      0x756   0x2800             CMP      R0,#+0
   \      0x758   0xD052             BEQ.N    ??process_next_command_22
   \      0x75A   0xE05A             B.N      ??process_next_command_133
  11740                    break;
  11741                  case 364:  // M364: SCARA Psi pos3 (90 deg to Theta)
  11742                  	if(MACHINETPYE == MORGAN_SCARA)
   \                     ??process_next_command_110: (+1)
   \      0x75C   0x.... 0x....      LDR.W    R0,??DataTable141
   \      0x760   0xF9B0 0x0024      LDRSH    R0,[R0, #+36]
   \      0x764   0xF5B0 0x7F80      CMP      R0,#+256
   \      0x768   0xD14A             BNE.N    ??process_next_command_22
  11743                    if (gcode_M364()) return;
   \      0x76A   0x.... 0x....      BL       _Z10gcode_M364v
   \      0x76E   0x2800             CMP      R0,#+0
   \      0x770   0xD046             BEQ.N    ??process_next_command_22
   \      0x772   0xE04E             B.N      ??process_next_command_133
  11744                    break;
  11745                //#endif // SCARA
  11746          
  11747                case 400: // M400: Finish all moves
  11748                  gcode_M400();
   \                     ??process_next_command_111: (+1)
   \      0x774   0x.... 0x....      BL       _Z10gcode_M400v
  11749                  break;
   \      0x778   0xE042             B.N      ??process_next_command_22
  11750          
  11751                #if HAS_BED_PROBE
  11752                  case 401: // M401: Deploy probe
  11753                    gcode_M401();
   \                     ??process_next_command_112: (+1)
   \      0x77A   0x.... 0x....      BL       _Z10gcode_M401v
  11754                    break;
   \      0x77E   0xE03F             B.N      ??process_next_command_22
  11755                  case 402: // M402: Stow probe
  11756                    gcode_M402();
   \                     ??process_next_command_113: (+1)
   \      0x780   0x.... 0x....      BL       _Z10gcode_M402v
  11757                    break;
   \      0x784   0xE03C             B.N      ??process_next_command_22
  11758                #endif // HAS_BED_PROBE
  11759          
  11760                #if ENABLED(FILAMENT_WIDTH_SENSOR)
  11761                  case 404:  // M404: Enter the nominal filament width (3mm, 1.75mm ) N<3.0> or display nominal filament width
  11762                    gcode_M404();
  11763                    break;
  11764                  case 405:  // M405: Turn on filament sensor for control
  11765                    gcode_M405();
  11766                    break;
  11767                  case 406:  // M406: Turn off filament sensor for control
  11768                    gcode_M406();
  11769                    break;
  11770                  case 407:   // M407: Display measured filament diameter
  11771                    gcode_M407();
  11772                    break;
  11773                #endif // FILAMENT_WIDTH_SENSOR
  11774          
  11775                //#if HAS_LEVELING
  11776                  case 420: // M420: Enable/Disable Bed Leveling
  11777                  if(BED_LEVELING_METHOD&HAS_LEVELING)
   \                     ??process_next_command_115: (+1)
   \      0x786   0x.... 0x....      LDR.W    R0,??DataTable141
   \      0x78A   0x7B00             LDRB     R0,[R0, #+12]
   \      0x78C   0xF010 0x0F3E      TST      R0,#0x3E
   \      0x790   0xD036             BEQ.N    ??process_next_command_22
  11778                    gcode_M420();
   \      0x792   0x.... 0x....      BL       _Z10gcode_M420v
   \      0x796   0xE033             B.N      ??process_next_command_22
  11779                    break;
  11780                //#endif
  11781          
  11782          	  /*--mks cfg-- MESH_BED_LEVELING */
  11783          //      #if ENABLED(MESH_BED_LEVELING) || ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(AUTO_BED_LEVELING_BILINEAR)
  11784          		#if 1
  11785                  case 421: // M421: Set a Mesh Bed Leveling Z coordinate
  11786                  if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
   \                     ??process_next_command_116: (+1)
   \      0x798   0x.... 0x....      LDR.W    R0,??DataTable141
   \      0x79C   0x7B00             LDRB     R0,[R0, #+12]
   \      0x79E   0x2820             CMP      R0,#+32
   \      0x7A0   0xD102             BNE.N    ??process_next_command_135
  11787                    gcode_M421_MESH_BED_LEVELING();
   \      0x7A2   0x.... 0x....      BL       _Z28gcode_M421_MESH_BED_LEVELINGv
   \      0x7A6   0xE02B             B.N      ??process_next_command_22
  11788          		else
  11789          		  gcode_M421();
   \                     ??process_next_command_135: (+1)
   \      0x7A8   0x.... 0x....      BL       _Z10gcode_M421v
   \      0x7AC   0xE028             B.N      ??process_next_command_22
  11790                    break;
  11791                #endif
  11792          
  11793                //#if HAS_M206_COMMAND	//mks_delta
  11794                  case 428: // M428: Apply current_position to home_offset
  11795                  if(MACHINETPYE != DELTA)
   \                     ??process_next_command_117: (+1)
   \      0x7AE   0x.... 0x....      LDR.W    R0,??DataTable141
   \      0x7B2   0xF9B0 0x0024      LDRSH    R0,[R0, #+36]
   \      0x7B6   0x2802             CMP      R0,#+2
   \      0x7B8   0xD022             BEQ.N    ??process_next_command_22
  11796                    gcode_M428();
   \      0x7BA   0x.... 0x....      BL       _Z10gcode_M428v
   \      0x7BE   0xE01F             B.N      ??process_next_command_22
  11797                    break;
  11798                //#endif
  11799          
  11800                case 500: // M500: Store settings in EEPROM
  11801                  gcode_M500();
   \                     ??process_next_command_118: (+1)
   \      0x7C0   0x.... 0x....      BL       _Z10gcode_M500v
  11802                  break;
   \      0x7C4   0xE01C             B.N      ??process_next_command_22
  11803                case 501: // M501: Read settings from EEPROM
  11804                  gcode_M501();
   \                     ??process_next_command_119: (+1)
   \      0x7C6   0x.... 0x....      BL       _Z10gcode_M501v
  11805                  break;
   \      0x7CA   0xE019             B.N      ??process_next_command_22
  11806                case 502: // M502: Revert to default settings
  11807                  gcode_M502();
   \                     ??process_next_command_120: (+1)
   \      0x7CC   0x.... 0x....      BL       _Z10gcode_M502v
  11808                  break;
   \      0x7D0   0xE016             B.N      ??process_next_command_22
  11809                case 503: // M503: print settings currently in memory
  11810                  gcode_M503();
   \                     ??process_next_command_121: (+1)
   \      0x7D2   0x.... 0x....      BL       _Z10gcode_M503v
  11811                  break;
   \      0x7D6   0xE013             B.N      ??process_next_command_22
  11812          
  11813                #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
  11814                  case 540: // M540: Set abort on endstop hit for SD printing
  11815                    gcode_M540();
  11816                    break;
  11817                #endif
  11818          
  11819                #if HAS_BED_PROBE
  11820                  case 851: // M851: Set Z Probe Z Offset
  11821                    gcode_M851();
   \                     ??process_next_command_125: (+1)
   \      0x7D8   0x.... 0x....      BL       _Z10gcode_M851v
  11822                    break;
   \      0x7DC   0xE010             B.N      ??process_next_command_22
  11823                #endif // HAS_BED_PROBE
  11824          
  11825                #if ENABLED(FILAMENT_CHANGE_FEATURE)
  11826                  case 600: // M600: Pause for filament change
  11827                    gcode_M600();
   \                     ??process_next_command_122: (+1)
   \      0x7DE   0x.... 0x....      BL       _Z10gcode_M600v
  11828                    break;
   \      0x7E2   0xE00D             B.N      ??process_next_command_22
  11829                #endif // FILAMENT_CHANGE_FEATURE
  11830          
  11831                #if ENABLED(DUAL_X_CARRIAGE)
  11832                  case 605: // M605: Set Dual X Carriage movement mode
  11833                    gcode_M605();
  11834                    break;
  11835                #endif // DUAL_X_CARRIAGE
  11836          
  11837                #if ENABLED(LIN_ADVANCE)
  11838                  case 900: // M900: Set advance K factor.
  11839                    gcode_M900();
  11840                    break;
  11841                #endif
  11842          
  11843                #if ENABLED(HAVE_TMC2130)
  11844                  case 906: // M906: Set motor current in milliamps using axis codes X, Y, Z, E
  11845                    gcode_M906();
  11846                    break;
  11847                #endif
  11848          
  11849                case 907: // M907: Set digital trimpot motor current using axis codes.
  11850                  gcode_M907();
   \                     ??process_next_command_126: (+1)
   \      0x7E4   0x.... 0x....      BL       _Z10gcode_M907v
  11851                  break;
   \      0x7E8   0xE00A             B.N      ??process_next_command_22
  11852          
  11853                #if HAS_DIGIPOTSS || ENABLED(DAC_STEPPER_CURRENT)
  11854          
  11855                  case 908: // M908: Control digital trimpot directly.
  11856                    gcode_M908();
  11857                    break;
  11858          
  11859                  #if ENABLED(DAC_STEPPER_CURRENT) // As with Printrbot RevF
  11860          
  11861                    case 909: // M909: Print digipot/DAC current value
  11862                      gcode_M909();
  11863                      break;
  11864          
  11865                    case 910: // M910: Commit digipot/DAC value to external EEPROM
  11866                      gcode_M910();
  11867                      break;
  11868          
  11869                  #endif
  11870          
  11871                #endif // HAS_DIGIPOTSS || DAC_STEPPER_CURRENT
  11872          
  11873                #if ENABLED(HAVE_TMC2130)
  11874                  case 911: // M911: Report TMC2130 prewarn triggered flags
  11875                    gcode_M911();
  11876                    break;
  11877          
  11878                  case 912: // M911: Clear TMC2130 prewarn triggered flags
  11879                    gcode_M912();
  11880                    break;
  11881          
  11882                  #if ENABLED(HYBRID_THRESHOLD)
  11883                    case 913: // M913: Set HYBRID_THRESHOLD speed.
  11884                      gcode_M913();
  11885                      break;
  11886                  #endif
  11887          
  11888                  #if ENABLED(SENSORLESS_HOMING)
  11889                    case 914: // M914: Set SENSORLESS_HOMING sensitivity.
  11890                      gcode_M914();
  11891                      break;
  11892                  #endif
  11893                #endif
  11894          
  11895                #if HAS_MICROSTEPS
  11896          
  11897                  case 350: // M350: Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.
  11898                    gcode_M350();
  11899                    break;
  11900          
  11901                  case 351: // M351: Toggle MS1 MS2 pins directly, S# determines MS1 or MS2, X# sets the pin high/low.
  11902                    gcode_M351();
  11903                    break;
  11904          
  11905                #endif // HAS_MICROSTEPS
  11906          
  11907                case 355: // M355 Turn case lights on/off
  11908                  gcode_M355();
   \                     ??process_next_command_105: (+1)
   \      0x7EA   0x.... 0x....      BL       _Z10gcode_M355v
  11909                  break;
   \      0x7EE   0xE007             B.N      ??process_next_command_22
  11910          
  11911                case 999: // M999: Restart after being Stopped
  11912                  gcode_M999();
   \                     ??process_next_command_128: (+1)
   \      0x7F0   0x.... 0x....      BL       _Z10gcode_M999v
  11913                  break;
   \      0x7F4   0xE004             B.N      ??process_next_command_22
  11914              }
  11915              break;
  11916          
  11917              case 'T':
  11918                gcode_T(codenum);
   \                     ??process_next_command_136: (+1)
   \      0x7F6   0xB2C0             UXTB     R0,R0
   \      0x7F8   0x.... 0x....      BL       _Z7gcode_Th
  11919                break;
   \      0x7FC   0xE000             B.N      ??process_next_command_22
  11920          
  11921              default: code_is_good = false;
   \                     ??process_next_command_137: (+1)
   \      0x7FE   0x2500             MOVS     R5,#+0
  11922            }
  11923          
  11924            KEEPALIVE_STATE(NOT_BUSY);
   \                     ??process_next_command_22: (+1)
   \      0x800   0x2000             MOVS     R0,#+0
   \      0x802   0x71A0             STRB     R0,[R4, #+6]
  11925          
  11926          ExitUnknownCommand:
  11927          
  11928            // Still unknown command? Throw an error
  11929            if (!code_is_good) unknown_command_error();
   \                     ??process_next_command_17: (+1)
   \      0x804   0x2D00             CMP      R5,#+0
   \      0x806   0xD101             BNE.N    ??process_next_command_138
   \      0x808   0x.... 0x....      BL       _Z21unknown_command_errorv
  11930          
  11931            ok_to_send();
   \                     ??process_next_command_138: (+1)
   \      0x80C   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \      0x810   0x....             B.N      _Z10ok_to_sendv
   \                     ??process_next_command_133: (+1)
   \      0x812   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   \                     ??process_next_command_7: (+1)
   \      0x816   0xF8D7 0x8024      LDR      R8,[R7, #+36]
   \      0x81A   0x212A             MOVS     R1,#+42
   \      0x81C   0x4640             MOV      R0,R8
   \      0x81E   0x.... 0x....      BL       __iar_Strchr
   \      0x822   0x2800             CMP      R0,#+0
   \      0x824   0xF43F 0xAC6E      BEQ.W    ??process_next_command_14
   \      0x828   0xE466             B.N      ??process_next_command_13
   \                     ??process_next_command_20: (+1)
   \      0x82A   0xF8C7 0x8028      STR      R8,[R7, #+40]
   \      0x82E   0x2201             MOVS     R2,#+1
   \      0x830   0x71A2             STRB     R2,[R4, #+6]
   \      0x832   0x2947             CMP      R1,#+71
   \      0x834   0xD005             BEQ.N    ??process_next_command_139
   \      0x836   0x294D             CMP      R1,#+77
   \      0x838   0xF43F 0xAD28      BEQ.W    ??process_next_command_44
   \      0x83C   0x2954             CMP      R1,#+84
   \      0x83E   0xD0DA             BEQ.N    ??process_next_command_136
   \      0x840   0xE7DD             B.N      ??process_next_command_137
   \                     ??process_next_command_139: (+1)
   \      0x842   0x4601             MOV      R1,R0
   \      0x844   0xB289             UXTH     R1,R1
   \      0x846   0x2900             CMP      R1,#+0
   \      0x848   0xD020             BEQ.N    ??process_next_command_140
   \      0x84A   0x2901             CMP      R1,#+1
   \      0x84C   0xD01E             BEQ.N    ??process_next_command_140
   \      0x84E   0x2902             CMP      R1,#+2
   \      0x850   0xF43F 0xAC7F      BEQ.W    ??process_next_command_23
   \      0x854   0x2903             CMP      R1,#+3
   \      0x856   0xF43F 0xAC7C      BEQ.W    ??process_next_command_23
   \      0x85A   0x2904             CMP      R1,#+4
   \      0x85C   0xF43F 0xAC82      BEQ.W    ??process_next_command_26
   \      0x860   0x291A             CMP      R1,#+26
   \      0x862   0xF43F 0xAC82      BEQ.W    ??process_next_command_27
   \      0x866   0x291C             CMP      R1,#+28
   \      0x868   0xF43F 0xAC88      BEQ.W    ??process_next_command_28
   \      0x86C   0x291D             CMP      R1,#+29
   \      0x86E   0xF43F 0xACA8      BEQ.W    ??process_next_command_29
   \      0x872   0x291E             CMP      R1,#+30
   \      0x874   0xF43F 0xACFE      BEQ.W    ??process_next_command_40
   \      0x878   0x295A             CMP      R1,#+90
   \      0x87A   0xF43F 0xACFE      BEQ.W    ??process_next_command_41
   \      0x87E   0x295B             CMP      R1,#+91
   \      0x880   0xF43F 0xACFE      BEQ.W    ??process_next_command_42
   \      0x884   0x295C             CMP      R1,#+92
   \      0x886   0xF43F 0xACFE      BEQ.W    ??process_next_command_43
   \      0x88A   0xE7B9             B.N      ??process_next_command_22
   \                     ??process_next_command_140: (+1)
   \      0x88C   0x.... 0x....      LDR.W    R1,??DataTable141
   \      0x890   0x8C89             LDRH     R1,[R1, #+36]
   \      0x892   0xF411 0x7F40      TST      R1,#0x300
   \      0x896   0xF43F 0xAC59      BEQ.W    ??process_next_command_21
   \      0x89A   0x4601             MOV      R1,R0
   \      0x89C   0xB289             UXTH     R1,R1
   \      0x89E   0x1E49             SUBS     R1,R1,#+1
   \      0x8A0   0x4189             SBCS     R1,R1,R1
   \      0x8A2   0x0FC9             LSRS     R1,R1,#+31
   \      0x8A4   0x4608             MOV      R0,R1
   \      0x8A6   0x.... 0x....      BL       _Z17gcode_G0_G1_SCARAb
   \      0x8AA   0xE7A9             B.N      ??process_next_command_22
  11932          }
  11933          
  11934          /**
  11935           * Send a "Resend: nnn" message to the host to
  11936           * indicate that a command needs to be re-sent.
  11937           */

   \                                 In section .text, align 2, keep-with-next
  11938          void FlushSerialRequestResend() {
   \                     _Z24FlushSerialRequestResendv: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
  11939            //char command_queue[cmd_queue_index_r][100]="Resend:";
  11940            MYSERIAL.flush();
   \        0x2   0x....             LDR.N    R4,??DataTable140_5
   \        0x4   0x4620             MOV      R0,R4
   \        0x6   0x.... 0x....      BL       _ZN12MarlinSerial5flushEv
  11941            SERIAL_PROTOCOLPGM(MSG_RESEND);
   \        0xA   0x.... 0x....      ADR.W    R0,?_39
   \        0xE   0x.... 0x....      BL       _Z14serialprintPGMPKc
  11942            SERIAL_PROTOCOLLN(gcode_LastN + 1);
   \       0x12   0x....             LDR.N    R0,??DataTable140
   \       0x14   0x6A01             LDR      R1,[R0, #+32]
   \       0x16   0x1C49             ADDS     R1,R1,#+1
   \       0x18   0x....             LDR.N    R5,??DataTable140_2
   \       0x1A   0x79E8             LDRB     R0,[R5, #+7]
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD104             BNE.N    ??FlushSerialRequestResend_0
   \       0x20   0x220A             MOVS     R2,#+10
   \       0x22   0x4620             MOV      R0,R4
   \       0x24   0x.... 0x....      BL       _ZN12MarlinSerial5printEli
   \       0x28   0xE003             B.N      ??FlushSerialRequestResend_1
   \                     ??FlushSerialRequestResend_0: (+1)
   \       0x2A   0x220A             MOVS     R2,#+10
   \       0x2C   0x....             LDR.N    R0,??DataTable140_6
   \       0x2E   0x.... 0x....      BL       _ZN12MarlinSerial5printEli
   \                     ??FlushSerialRequestResend_1: (+1)
   \       0x32   0x79E8             LDRB     R0,[R5, #+7]
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD104             BNE.N    ??FlushSerialRequestResend_2
   \       0x38   0x210A             MOVS     R1,#+10
   \       0x3A   0x4620             MOV      R0,R4
   \       0x3C   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \       0x40   0xE004             B.N      ??FlushSerialRequestResend_3
   \                     ??FlushSerialRequestResend_2: (+1)
   \       0x42   0x2200             MOVS     R2,#+0
   \       0x44   0x210A             MOVS     R1,#+10
   \       0x46   0x....             LDR.N    R0,??DataTable140_6
   \       0x48   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
  11943            ok_to_send();
   \                     ??FlushSerialRequestResend_3: (+1)
   \       0x4C   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \       0x50                      REQUIRE _Z10ok_to_sendv
   \       0x50                      ;; // Fall through to label ok_to_send()
  11944          }
  11945          
  11946          /**
  11947           * Send an "ok" message to the host, indicating
  11948           * that a command was successfully processed.
  11949           *
  11950           * If ADVANCED_OK is enabled also include:
  11951           *   N<int>  Line number of the command, if any
  11952           *   P<int>  Planner space remaining
  11953           *   B<int>  Block queue space remaining
  11954           */

   \                                 In section .text, align 2, keep-with-next
  11955          void ok_to_send() {
   \                     _Z10ok_to_sendv: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
  11956            refresh_cmd_timeout();
   \        0x2   0x.... 0x....      BL       _Z19refresh_cmd_timeoutv
  11957            if (!send_ok[cmd_queue_index_r]) return;
   \        0x6   0x....             LDR.N    R0,??DataTable140
   \        0x8   0x7A41             LDRB     R1,[R0, #+9]
   \        0xA   0x4408             ADD      R0,R0,R1
   \        0xC   0x7D00             LDRB     R0,[R0, #+20]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD013             BEQ.N    ??ok_to_send_0
  11958            SERIAL_PROTOCOLPGM(MSG_OK);
   \       0x12   0x....             ADR.N    R0,??DataTable140_3  ;; 0x6F, 0x6B, 0x00, 0x00
   \       0x14   0x.... 0x....      BL       _Z14serialprintPGMPKc
  11959            #if ENABLED(ADVANCED_OK)
  11960              char* p = command_queue[cmd_queue_index_r];
  11961              if (*p == 'N') {
  11962                SERIAL_PROTOCOL(' ');
  11963                SERIAL_ECHO(*p++);
  11964                while (NUMERIC_SIGNED(*p))
  11965                  SERIAL_ECHO(*p++);
  11966              }
  11967              SERIAL_PROTOCOLPGM(" P"); SERIAL_PROTOCOL(int(BLOCK_BUFFER_SIZE - planner.movesplanned() - 1));
  11968              SERIAL_PROTOCOLPGM(" B"); SERIAL_PROTOCOL(BUFSIZE - commands_in_queue);
  11969            #endif
  11970            SERIAL_EOL;
   \       0x18   0x....             LDR.N    R0,??DataTable140_2
   \       0x1A   0x79C0             LDRB     R0,[R0, #+7]
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD105             BNE.N    ??ok_to_send_1
   \       0x20   0x210A             MOVS     R1,#+10
   \       0x22   0x....             LDR.N    R0,??DataTable140_5
   \       0x24   0xE8BD 0x4004      POP      {R2,LR}
   \       0x28   0x.... 0x....      B.W      _ZN12MarlinSerial5writeEh
   \                     ??ok_to_send_1: (+1)
   \       0x2C   0x2200             MOVS     R2,#+0
   \       0x2E   0x210A             MOVS     R1,#+10
   \       0x30   0x....             LDR.N    R0,??DataTable140_6
   \       0x32   0xE8BD 0x4008      POP      {R3,LR}
   \       0x36   0x.... 0x....      B.W      _ZN12MarlinSerial5printEci
  11971          }
   \                     ??ok_to_send_0: (+1)
   \       0x3A   0xBD01             POP      {R0,PC}          ;; return
  11972          
  11973          #if HAS_SOFTWARE_ENDSTOPS
  11974          
  11975            /**
  11976             * Constrain the given coordinates to the software endstops.
  11977             */

   \                                 In section .text, align 2, keep-with-next
  11978            void clamp_to_software_endstops(float target[XYZ]) {
   \                     _Z26clamp_to_software_endstopsPf: (+1)
   \        0x0   0x4602             MOV      R2,R0
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable147
   \        0x6   0x7800             LDRB     R0,[R0, #+0]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD100             BNE.N    ??clamp_to_software_endstops_0
   \        0xC   0x4770             BX       LR
   \                     ??clamp_to_software_endstops_0: (+1)
   \        0xE   0xB510             PUSH     {R4,LR}
  11979              if (!soft_endstops_enabled) return;
  11980              //#if ENABLED(MIN_SOFTWARE_ENDSTOPS)	/*--mks cfg--*/
  11981              if(mksCfg.min_software_endstops){
   \       0x10   0x.... 0x....      LDR.W    R3,??DataTable147_1
   \       0x14   0x....             LDR.N    R4,??DataTable140_2
   \       0x16   0x7818             LDRB     R0,[R3, #+0]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD011             BEQ.N    ??clamp_to_software_endstops_1
  11982                NOLESS(target[X_AXIS], soft_endstop_min[X_AXIS]);
   \       0x1C   0x6D21             LDR      R1,[R4, #+80]
   \       0x1E   0x6810             LDR      R0,[R2, #+0]
   \       0x20   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x24   0xD200             BCS.N    ??clamp_to_software_endstops_2
   \       0x26   0x6011             STR      R1,[R2, #+0]
  11983                NOLESS(target[Y_AXIS], soft_endstop_min[Y_AXIS]);
   \                     ??clamp_to_software_endstops_2: (+1)
   \       0x28   0x6D61             LDR      R1,[R4, #+84]
   \       0x2A   0x6850             LDR      R0,[R2, #+4]
   \       0x2C   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x30   0xD200             BCS.N    ??clamp_to_software_endstops_3
   \       0x32   0x6051             STR      R1,[R2, #+4]
  11984                NOLESS(target[Z_AXIS], soft_endstop_min[Z_AXIS]);
   \                     ??clamp_to_software_endstops_3: (+1)
   \       0x34   0x6DA1             LDR      R1,[R4, #+88]
   \       0x36   0x6890             LDR      R0,[R2, #+8]
   \       0x38   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x3C   0xD200             BCS.N    ??clamp_to_software_endstops_1
   \       0x3E   0x6091             STR      R1,[R2, #+8]
  11985              }//#endif
  11986              //#if ENABLED(MAX_SOFTWARE_ENDSTOPS)	/*--mks cfg--*/
  11987              if(mksCfg.max_software_endstops){
   \                     ??clamp_to_software_endstops_1: (+1)
   \       0x40   0x7858             LDRB     R0,[R3, #+1]
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD011             BEQ.N    ??clamp_to_software_endstops_4
  11988                NOMORE(target[X_AXIS], soft_endstop_max[X_AXIS]);
   \       0x46   0x6DE0             LDR      R0,[R4, #+92]
   \       0x48   0x6811             LDR      R1,[R2, #+0]
   \       0x4A   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x4E   0xD200             BCS.N    ??clamp_to_software_endstops_5
   \       0x50   0x6010             STR      R0,[R2, #+0]
  11989                NOMORE(target[Y_AXIS], soft_endstop_max[Y_AXIS]);
   \                     ??clamp_to_software_endstops_5: (+1)
   \       0x52   0x6E20             LDR      R0,[R4, #+96]
   \       0x54   0x6851             LDR      R1,[R2, #+4]
   \       0x56   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x5A   0xD200             BCS.N    ??clamp_to_software_endstops_6
   \       0x5C   0x6050             STR      R0,[R2, #+4]
  11990                NOMORE(target[Z_AXIS], soft_endstop_max[Z_AXIS]);
   \                     ??clamp_to_software_endstops_6: (+1)
   \       0x5E   0x6E60             LDR      R0,[R4, #+100]
   \       0x60   0x6891             LDR      R1,[R2, #+8]
   \       0x62   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x66   0xD200             BCS.N    ??clamp_to_software_endstops_4
   \       0x68   0x6090             STR      R0,[R2, #+8]
  11991              }//#endif
  11992            }
   \                     ??clamp_to_software_endstops_4: (+1)
   \       0x6A   0xBD10             POP      {R4,PC}          ;; return
  11993          
  11994          #endif
  11995          
  11996          //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
  11997          #if 1 /*--mks cfg-- AUTO_BED_LEVELING_BILINEAR */
  11998            #if ENABLED(ABL_BILINEAR_SUBDIVISION)
  11999              #define ABL_BG_SPACING(A) bilinear_grid_spacing_virt[A]
  12000              #define ABL_BG_FACTOR(A)  bilinear_grid_factor_virt[A]
  12001              #define ABL_BG_POINTS_X   ABL_GRID_POINTS_VIRT_X
  12002              #define ABL_BG_POINTS_Y   ABL_GRID_POINTS_VIRT_Y
  12003              #define ABL_BG_GRID(X,Y)  z_values_virt[X][Y]
  12004            #else
  12005              #define ABL_BG_SPACING(A) bilinear_grid_spacing[A]
  12006              #define ABL_BG_FACTOR(A)  bilinear_grid_factor[A]
  12007              #define ABL_BG_POINTS_X   GRID_MAX_POINTS_X
  12008              #define ABL_BG_POINTS_Y   GRID_MAX_POINTS_Y
  12009              #define ABL_BG_GRID(X,Y)  z_values[X][Y]
  12010            #endif
  12011          
  12012            // Get the Z adjustment for non-linear bed leveling

   \                                 In section .text, align 2, keep-with-next
  12013            float bilinear_z_offset(const float logical[XYZ]) {
   \                     _Z17bilinear_z_offsetPKf: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4605             MOV      R5,R0
  12014          
  12015              static float z1, d2, z3, d4, L, D, ratio_x, ratio_y,
  12016                           last_x = -999.999, last_y = -999.999;
  12017          
  12018              // Whole units for the grid line indices. Constrained within bounds.
  12019              static int8_t gridx, gridy, nextx, nexty,
  12020                            last_gridx = -99, last_gridy = -99;
  12021          
  12022              // XY relative to the probed area
  12023              const float x = RAW_X_POSITION(logical[X_AXIS]) - bilinear_start[X_AXIS],
   \        0x6   0x.... 0x....      LDR.W    R4,??DataTable147_2
   \        0xA   0x....             LDR.N    R6,??DataTable140_2
   \        0xC   0x6828             LDR      R0,[R5, #+0]
   \        0xE   0x6C71             LDR      R1,[R6, #+68]
   \       0x10   0x.... 0x....      BL       __aeabi_fsub
   \       0x14   0x4607             MOV      R7,R0
   \       0x16   0x6920             LDR      R0,[R4, #+16]
   \       0x18   0x.... 0x....      BL       __aeabi_i2f
   \       0x1C   0x4601             MOV      R1,R0
   \       0x1E   0x4638             MOV      R0,R7
   \       0x20   0x.... 0x....      BL       __aeabi_fsub
   \       0x24   0x4607             MOV      R7,R0
  12024                          y = RAW_Y_POSITION(logical[Y_AXIS]) - bilinear_start[Y_AXIS];
   \       0x26   0x6868             LDR      R0,[R5, #+4]
   \       0x28   0x6CB1             LDR      R1,[R6, #+72]
   \       0x2A   0x.... 0x....      BL       __aeabi_fsub
   \       0x2E   0x4605             MOV      R5,R0
   \       0x30   0x6960             LDR      R0,[R4, #+20]
   \       0x32   0x.... 0x....      BL       __aeabi_i2f
   \       0x36   0x4601             MOV      R1,R0
   \       0x38   0x4628             MOV      R0,R5
   \       0x3A   0x.... 0x....      BL       __aeabi_fsub
   \       0x3E   0x4606             MOV      R6,R0
  12025          
  12026              #if ENABLED(EXTRAPOLATE_BEYOND_GRID)
  12027                // Keep using the last grid box
  12028                #define FAR_EDGE_OR_BOX 2
  12029              #else
  12030                // Just use the grid far edge
  12031                #define FAR_EDGE_OR_BOX 1
  12032              #endif
  12033          
  12034              if (last_x != x) {
   \       0x40   0x.... 0x....      LDR.W    R5,??DataTable147_3
   \       0x44   0x6C60             LDR      R0,[R4, #+68]
   \       0x46   0x4639             MOV      R1,R7
   \       0x48   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0x4C   0xD03A             BEQ.N    ??bilinear_z_offset_0
  12035                last_x = x;
   \       0x4E   0x6467             STR      R7,[R4, #+68]
  12036                ratio_x = x * ABL_BG_FACTOR(X_AXIS);
   \       0x50   0x69A0             LDR      R0,[R4, #+24]
   \       0x52   0x.... 0x....      BL       __aeabi_fmul
   \       0x56   0x4607             MOV      R7,R0
   \       0x58   0x63E7             STR      R7,[R4, #+60]
  12037                const float gx = constrain(floor(ratio_x), 0, ABL_BG_POINTS_X - FAR_EDGE_OR_BOX);
   \       0x5A   0x.... 0x....      BL       floorf
   \       0x5E   0x2100             MOVS     R1,#+0
   \       0x60   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x64   0xD201             BCS.N    ??bilinear_z_offset_1
   \       0x66   0x4688             MOV      R8,R1
   \       0x68   0xE010             B.N      ??bilinear_z_offset_2
   \                     ??bilinear_z_offset_1: (+1)
   \       0x6A   0x7828             LDRB     R0,[R5, #+0]
   \       0x6C   0x1E40             SUBS     R0,R0,#+1
   \       0x6E   0x.... 0x....      BL       __aeabi_i2f
   \       0x72   0x4680             MOV      R8,R0
   \       0x74   0x4638             MOV      R0,R7
   \       0x76   0x.... 0x....      BL       floorf
   \       0x7A   0x4601             MOV      R1,R0
   \       0x7C   0x4640             MOV      R0,R8
   \       0x7E   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x82   0xD303             BCC.N    ??bilinear_z_offset_2
   \       0x84   0x4638             MOV      R0,R7
   \       0x86   0x.... 0x....      BL       floorf
   \       0x8A   0x4680             MOV      R8,R0
  12038                ratio_x -= gx;      // Subtract whole to get the ratio within the grid box
   \                     ??bilinear_z_offset_2: (+1)
   \       0x8C   0x4638             MOV      R0,R7
   \       0x8E   0x4641             MOV      R1,R8
   \       0x90   0x.... 0x....      BL       __aeabi_fsub
   \       0x94   0x63E0             STR      R0,[R4, #+60]
  12039          
  12040                #if DISABLED(EXTRAPOLATE_BEYOND_GRID)
  12041                  // Beyond the grid maintain height at grid edges
  12042                  NOLESS(ratio_x, 0); // Never < 0.0. (> 1.0 is ok when nextx==gridx.)
   \       0x96   0x2100             MOVS     R1,#+0
   \       0x98   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x9C   0xD201             BCS.N    ??bilinear_z_offset_3
   \       0x9E   0x4608             MOV      R0,R1
   \       0xA0   0x63E0             STR      R0,[R4, #+60]
  12043                #endif
  12044          
  12045                gridx = gx;
                             ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??bilinear_z_offset_3: (+1)
   \       0xA2   0x4640             MOV      R0,R8
   \       0xA4   0x.... 0x....      BL       __aeabi_f2iz
   \       0xA8   0x7060             STRB     R0,[R4, #+1]
  12046                nextx = min(gridx + 1, ABL_BG_POINTS_X - 1);
   \       0xAA   0x7829             LDRB     R1,[R5, #+0]
   \       0xAC   0x4602             MOV      R2,R0
   \       0xAE   0xB252             SXTB     R2,R2
   \       0xB0   0x1C52             ADDS     R2,R2,#+1
   \       0xB2   0x460B             MOV      R3,R1
   \       0xB4   0x1E5B             SUBS     R3,R3,#+1
   \       0xB6   0x429A             CMP      R2,R3
   \       0xB8   0xDA02             BGE.N    ??bilinear_z_offset_4
   \       0xBA   0x1C40             ADDS     R0,R0,#+1
   \       0xBC   0x70E0             STRB     R0,[R4, #+3]
   \       0xBE   0xE001             B.N      ??bilinear_z_offset_0
   \                     ??bilinear_z_offset_4: (+1)
   \       0xC0   0x1E48             SUBS     R0,R1,#+1
   \       0xC2   0x70E0             STRB     R0,[R4, #+3]
  12047              }
  12048          
  12049              if (last_y != y || last_gridx != gridx) {
   \                     ??bilinear_z_offset_0: (+1)
   \       0xC4   0x6CA2             LDR      R2,[R4, #+72]
   \       0xC6   0x4610             MOV      R0,R2
   \       0xC8   0x4631             MOV      R1,R6
   \       0xCA   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0xCE   0xD105             BNE.N    ??bilinear_z_offset_5
   \       0xD0   0xF994 0x0005      LDRSB    R0,[R4, #+5]
   \       0xD4   0xF994 0x1001      LDRSB    R1,[R4, #+1]
   \       0xD8   0x4288             CMP      R0,R1
   \       0xDA   0xD07C             BEQ.N    ??bilinear_z_offset_6
  12050          
  12051                if (last_y != y) {
   \                     ??bilinear_z_offset_5: (+1)
   \       0xDC   0x4610             MOV      R0,R2
   \       0xDE   0x4631             MOV      R1,R6
   \       0xE0   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0xE4   0xD03A             BEQ.N    ??bilinear_z_offset_7
  12052                  last_y = y;
   \       0xE6   0x64A6             STR      R6,[R4, #+72]
  12053                  ratio_y = y * ABL_BG_FACTOR(Y_AXIS);
   \       0xE8   0x69E0             LDR      R0,[R4, #+28]
   \       0xEA   0x.... 0x....      BL       __aeabi_fmul
   \       0xEE   0x4606             MOV      R6,R0
   \       0xF0   0x6426             STR      R6,[R4, #+64]
  12054                  const float gy = constrain(floor(ratio_y), 0, ABL_BG_POINTS_Y - FAR_EDGE_OR_BOX);
   \       0xF2   0x.... 0x....      BL       floorf
   \       0xF6   0x2100             MOVS     R1,#+0
   \       0xF8   0x.... 0x....      BL       __aeabi_cfcmple
   \       0xFC   0xD201             BCS.N    ??bilinear_z_offset_8
   \       0xFE   0x460F             MOV      R7,R1
   \      0x100   0xE010             B.N      ??bilinear_z_offset_9
   \                     ??bilinear_z_offset_8: (+1)
   \      0x102   0x7868             LDRB     R0,[R5, #+1]
   \      0x104   0x1E40             SUBS     R0,R0,#+1
   \      0x106   0x.... 0x....      BL       __aeabi_i2f
   \      0x10A   0x4607             MOV      R7,R0
   \      0x10C   0x4630             MOV      R0,R6
   \      0x10E   0x.... 0x....      BL       floorf
   \      0x112   0x4601             MOV      R1,R0
   \      0x114   0x4638             MOV      R0,R7
   \      0x116   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x11A   0xD303             BCC.N    ??bilinear_z_offset_9
   \      0x11C   0x4630             MOV      R0,R6
   \      0x11E   0x.... 0x....      BL       floorf
   \      0x122   0x4607             MOV      R7,R0
  12055                  ratio_y -= gy;
   \                     ??bilinear_z_offset_9: (+1)
   \      0x124   0x4630             MOV      R0,R6
   \      0x126   0x4639             MOV      R1,R7
   \      0x128   0x.... 0x....      BL       __aeabi_fsub
   \      0x12C   0x6420             STR      R0,[R4, #+64]
  12056          
  12057                  #if DISABLED(EXTRAPOLATE_BEYOND_GRID)
  12058                    // Beyond the grid maintain height at grid edges
  12059                    NOLESS(ratio_y, 0); // Never < 0.0. (> 1.0 is ok when nexty==gridy.)
   \      0x12E   0x2100             MOVS     R1,#+0
   \      0x130   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x134   0xD201             BCS.N    ??bilinear_z_offset_10
   \      0x136   0x4608             MOV      R0,R1
   \      0x138   0x6420             STR      R0,[R4, #+64]
  12060                  #endif
  12061          
  12062                  gridy = gy;
                               ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??bilinear_z_offset_10: (+1)
   \      0x13A   0x4638             MOV      R0,R7
   \      0x13C   0x.... 0x....      BL       __aeabi_f2iz
   \      0x140   0x70A0             STRB     R0,[R4, #+2]
  12063                  nexty = min(gridy + 1, ABL_BG_POINTS_Y - 1);
   \      0x142   0x7869             LDRB     R1,[R5, #+1]
   \      0x144   0x4602             MOV      R2,R0
   \      0x146   0xB252             SXTB     R2,R2
   \      0x148   0x1C52             ADDS     R2,R2,#+1
   \      0x14A   0x460B             MOV      R3,R1
   \      0x14C   0x1E5B             SUBS     R3,R3,#+1
   \      0x14E   0x429A             CMP      R2,R3
   \      0x150   0xDA02             BGE.N    ??bilinear_z_offset_11
   \      0x152   0x1C40             ADDS     R0,R0,#+1
   \      0x154   0x7120             STRB     R0,[R4, #+4]
   \      0x156   0xE001             B.N      ??bilinear_z_offset_7
   \                     ??bilinear_z_offset_11: (+1)
   \      0x158   0x1E48             SUBS     R0,R1,#+1
   \      0x15A   0x7120             STRB     R0,[R4, #+4]
  12064                }
  12065          
  12066                if (last_gridx != gridx || last_gridy != gridy) {
   \                     ??bilinear_z_offset_7: (+1)
   \      0x15C   0xF994 0x5002      LDRSB    R5,[R4, #+2]
   \      0x160   0xF994 0x0001      LDRSB    R0,[R4, #+1]
   \      0x164   0xF994 0x1005      LDRSB    R1,[R4, #+5]
   \      0x168   0x4281             CMP      R1,R0
   \      0x16A   0xD103             BNE.N    ??bilinear_z_offset_12
   \      0x16C   0xF994 0x1006      LDRSB    R1,[R4, #+6]
   \      0x170   0x42A9             CMP      R1,R5
   \      0x172   0xD01B             BEQ.N    ??bilinear_z_offset_13
  12067                  last_gridx = gridx;
   \                     ??bilinear_z_offset_12: (+1)
   \      0x174   0x7160             STRB     R0,[R4, #+5]
  12068                  last_gridy = gridy;
   \      0x176   0x71A5             STRB     R5,[R4, #+6]
  12069                  // Z at the box corners
  12070                  z1 = ABL_BG_GRID(gridx, gridy);       // left-front
   \      0x178   0x.... 0x....      LDR.W    R6,??DataTable148
   \      0x17C   0xEB06 0x1080      ADD      R0,R6,R0, LSL #+6
   \      0x180   0xF850 0x1025      LDR      R1,[R0, R5, LSL #+2]
   \      0x184   0x6261             STR      R1,[R4, #+36]
  12071                  d2 = ABL_BG_GRID(gridx, nexty) - z1;  // left-back (delta)
   \      0x186   0xF994 0x7004      LDRSB    R7,[R4, #+4]
   \      0x18A   0xF850 0x0027      LDR      R0,[R0, R7, LSL #+2]
   \      0x18E   0x.... 0x....      BL       __aeabi_fsub
   \      0x192   0x62A0             STR      R0,[R4, #+40]
  12072                  z3 = ABL_BG_GRID(nextx, gridy);       // right-front
   \      0x194   0xF994 0x0003      LDRSB    R0,[R4, #+3]
   \      0x198   0xEB06 0x1080      ADD      R0,R6,R0, LSL #+6
   \      0x19C   0xF850 0x1025      LDR      R1,[R0, R5, LSL #+2]
   \      0x1A0   0x62E1             STR      R1,[R4, #+44]
  12073                  d4 = ABL_BG_GRID(nextx, nexty) - z3;  // right-back (delta)
   \      0x1A2   0xF850 0x0027      LDR      R0,[R0, R7, LSL #+2]
   \      0x1A6   0x.... 0x....      BL       __aeabi_fsub
   \      0x1AA   0x6320             STR      R0,[R4, #+48]
  12074                }
  12075          
  12076                // Bilinear interpolate. Needed since y or gridx has changed.
  12077                            L = z1 + d2 * ratio_y;   // Linear interp. LF -> LB
   \                     ??bilinear_z_offset_13: (+1)
   \      0x1AC   0x6C25             LDR      R5,[R4, #+64]
   \      0x1AE   0x6AA0             LDR      R0,[R4, #+40]
   \      0x1B0   0x4629             MOV      R1,R5
   \      0x1B2   0x.... 0x....      BL       __aeabi_fmul
   \      0x1B6   0x6A61             LDR      R1,[R4, #+36]
   \      0x1B8   0x.... 0x....      BL       __aeabi_fadd
   \      0x1BC   0x4606             MOV      R6,R0
   \      0x1BE   0x6366             STR      R6,[R4, #+52]
  12078                const float R = z3 + d4 * ratio_y;   // Linear interp. RF -> RB
  12079          
  12080                D = R - L;
   \      0x1C0   0x6B20             LDR      R0,[R4, #+48]
   \      0x1C2   0x4629             MOV      R1,R5
   \      0x1C4   0x.... 0x....      BL       __aeabi_fmul
   \      0x1C8   0x6AE1             LDR      R1,[R4, #+44]
   \      0x1CA   0x.... 0x....      BL       __aeabi_fadd
   \      0x1CE   0x4631             MOV      R1,R6
   \      0x1D0   0x.... 0x....      BL       __aeabi_fsub
   \      0x1D4   0x63A0             STR      R0,[R4, #+56]
  12081              }
  12082          
  12083              const float offset = L + ratio_x * D;   // the offset almost always changes
  12084          
  12085              /*
  12086              static float last_offset = 0;
  12087              if (fabs(last_offset - offset) > 0.2) {
  12088                SERIAL_ECHOPGM("Sudden Shift at ");
  12089                SERIAL_ECHOPAIR("x=", x);
  12090                SERIAL_ECHOPAIR(" / ", bilinear_grid_spacing[X_AXIS]);
  12091                SERIAL_ECHOLNPAIR(" -> gridx=", gridx);
  12092                SERIAL_ECHOPAIR(" y=", y);
  12093                SERIAL_ECHOPAIR(" / ", bilinear_grid_spacing[Y_AXIS]);
  12094                SERIAL_ECHOLNPAIR(" -> gridy=", gridy);
  12095                SERIAL_ECHOPAIR(" ratio_x=", ratio_x);
  12096                SERIAL_ECHOLNPAIR(" ratio_y=", ratio_y);
  12097                SERIAL_ECHOPAIR(" z1=", z1);
  12098                SERIAL_ECHOPAIR(" z2=", z2);
  12099                SERIAL_ECHOPAIR(" z3=", z3);
  12100                SERIAL_ECHOLNPAIR(" z4=", z4);
  12101                SERIAL_ECHOPAIR(" L=", L);
  12102                SERIAL_ECHOPAIR(" R=", R);
  12103                SERIAL_ECHOLNPAIR(" offset=", offset);
  12104              }
  12105              last_offset = offset;
  12106              //*/
                      ^
Warning[Pe009]: nested comment is not allowed
  12107          
  12108              return offset;
   \                     ??bilinear_z_offset_6: (+1)
   \      0x1D6   0x6BE1             LDR      R1,[R4, #+60]
   \      0x1D8   0x6BA0             LDR      R0,[R4, #+56]
   \      0x1DA   0x.... 0x....      BL       __aeabi_fmul
   \      0x1DE   0x6B61             LDR      R1,[R4, #+52]
   \      0x1E0   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \      0x1E4   0x.... 0x....      B.W      __aeabi_fadd
  12109            }

   \                                 In section .data, align 4
   \                     Running:
   \        0x0   0x01               DC8 1
   \        0x1   0x00               DC8 0
   \        0x2   0x00               DC8 0
   \        0x3   0x00               DC8 0
   \        0x4   0x00               DC8 0
   \        0x5   0x9D               DC8 -99
   \        0x6   0x9D               DC8 -99
   \        0x7   0x00               DC8 0
   \                     bilinear_grid_spacing:
   \        0x8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     bilinear_start:
   \       0x10   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     bilinear_grid_factor:
   \       0x18   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \       0x20   0x0000'0000        DC32 0
   \       0x24   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \       0x28   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \       0x2C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \       0x30   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \       0x34   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \       0x38   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \       0x3C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \       0x40   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \       0x44   0xC479'FFF0        DC32 0C479FFF0H
   \       0x48   0xC479'FFF0        DC32 0C479FFF0H

   \                                 In section .data, align 4
   \                     axis_homed:
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     delta_tower:
   \        0x4   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \       0x14   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     delta_diagonal_rod_2_tower:
   \       0x1C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     cartes:
   \       0x28   0x0000'0000        DC32 0H
   \       0x2C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     delta_tower_angle_trim:
   \       0x34   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     position_shift:
   \       0x3C   0x0000'0000        DC32 0H
   \       0x40   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     zprobe_zoffset:
   \       0x48   0x3F4C'CCCD        DC32 3F4CCCCDH
   \                     delta_radius:
   \       0x4C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     delta_diagonal_rod:
   \       0x50   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     delta_calibration_radius:
   \       0x54   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     delta_segments_per_second:
   \       0x58   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \       0x5C   0x7FFF'FFFF        DC32 7FFFFFFFH
  12110          
  12111          #endif // AUTO_BED_LEVELING_BILINEAR
  12112          
  12113          //#if ENABLED(DELTA)	//mks-delta
  12114          #if 1
  12115            /**
  12116             * Recalculate factors used for delta kinematics whenever
  12117             * settings have been changed (e.g., by M665).
  12118             */

   \                                 In section .text, align 2, keep-with-next
  12119            void recalc_delta_settings(float radius, float diagonal_rod) {
   \                     _Z21recalc_delta_settingsff: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x4607             MOV      R7,R0
   \        0x6   0x468A             MOV      R10,R1
  12120              const float trt[ABC] = DELTA_RADIUS_TRIM_TOWER,
  12121                          drt[ABC] = DELTA_DIAGONAL_ROD_TRIM_TOWER;
  12122              delta_tower[A_AXIS][X_AXIS] = cos(RADIANS(210 + delta_tower_angle_trim[A_AXIS])) * (radius + trt[A_AXIS]); // front left tower
   \        0x8   0x.... 0x....      LDR.W    R6,??DataTable148_1
   \        0xC   0x.... 0x....      LDR.W    R8,??DataTable148_2  ;; 0x54442d18
   \       0x10   0x.... 0x....      LDR.W    R9,??DataTable149  ;; 0x400921fb
   \       0x14   0x6B71             LDR      R1,[R6, #+52]
   \       0x16   0x.... 0x....      LDR.W    R0,??DataTable149_1  ;; 0x43520000
   \       0x1A   0x.... 0x....      BL       __aeabi_fadd
   \       0x1E   0x.... 0x....      BL       __aeabi_f2d
   \       0x22   0x4642             MOV      R2,R8
   \       0x24   0x464B             MOV      R3,R9
   \       0x26   0x.... 0x....      BL       __aeabi_dmul
   \       0x2A   0x2200             MOVS     R2,#+0
   \       0x2C   0x.... 0x....      LDR.W    R3,??DataTable149_2  ;; 0x40668000
   \       0x30   0x.... 0x....      BL       __aeabi_ddiv
   \       0x34   0x4604             MOV      R4,R0
   \       0x36   0x460D             MOV      R5,R1
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0x4639             MOV      R1,R7
   \       0x3C   0x.... 0x....      BL       __aeabi_fadd
   \       0x40   0x4607             MOV      R7,R0
   \       0x42   0x.... 0x....      BL       __aeabi_f2d
   \       0x46   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \       0x4A   0x4620             MOV      R0,R4
   \       0x4C   0x4629             MOV      R1,R5
   \       0x4E   0x.... 0x....      BL       cos
   \       0x52   0xE9DD 0x2300      LDRD     R2,R3,[SP, #+0]
   \       0x56   0x.... 0x....      BL       __aeabi_dmul
   \       0x5A   0x.... 0x....      BL       __aeabi_d2f
   \       0x5E   0x6070             STR      R0,[R6, #+4]
  12123              delta_tower[A_AXIS][Y_AXIS] = sin(RADIANS(210 + delta_tower_angle_trim[A_AXIS])) * (radius + trt[A_AXIS]);
   \       0x60   0x4638             MOV      R0,R7
   \       0x62   0x.... 0x....      BL       __aeabi_f2d
   \       0x66   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \       0x6A   0x4620             MOV      R0,R4
   \       0x6C   0x4629             MOV      R1,R5
   \       0x6E   0x.... 0x....      BL       sin
   \       0x72   0xE9DD 0x2300      LDRD     R2,R3,[SP, #+0]
   \       0x76   0x.... 0x....      BL       __aeabi_dmul
   \       0x7A   0x.... 0x....      BL       __aeabi_d2f
   \       0x7E   0x60B0             STR      R0,[R6, #+8]
  12124              delta_tower[B_AXIS][X_AXIS] = cos(RADIANS(330 + delta_tower_angle_trim[B_AXIS])) * (radius + trt[B_AXIS]); // front right tower
   \       0x80   0x6BB1             LDR      R1,[R6, #+56]
   \       0x82   0x.... 0x....      LDR.W    R0,??DataTable149_3  ;; 0x43a50000
   \       0x86   0x.... 0x....      BL       __aeabi_fadd
   \       0x8A   0x.... 0x....      BL       __aeabi_f2d
   \       0x8E   0x4642             MOV      R2,R8
   \       0x90   0x464B             MOV      R3,R9
   \       0x92   0x.... 0x....      BL       __aeabi_dmul
   \       0x96   0x2200             MOVS     R2,#+0
   \       0x98   0x.... 0x....      LDR.W    R3,??DataTable149_2  ;; 0x40668000
   \       0x9C   0x.... 0x....      BL       __aeabi_ddiv
   \       0xA0   0x4604             MOV      R4,R0
   \       0xA2   0x460D             MOV      R5,R1
   \       0xA4   0x4638             MOV      R0,R7
   \       0xA6   0x.... 0x....      BL       __aeabi_f2d
   \       0xAA   0x4680             MOV      R8,R0
   \       0xAC   0x4689             MOV      R9,R1
   \       0xAE   0x4620             MOV      R0,R4
   \       0xB0   0x4629             MOV      R1,R5
   \       0xB2   0x.... 0x....      BL       cos
   \       0xB6   0x4642             MOV      R2,R8
   \       0xB8   0x464B             MOV      R3,R9
   \       0xBA   0x.... 0x....      BL       __aeabi_dmul
   \       0xBE   0x.... 0x....      BL       __aeabi_d2f
   \       0xC2   0x60F0             STR      R0,[R6, #+12]
  12125              delta_tower[B_AXIS][Y_AXIS] = sin(RADIANS(330 + delta_tower_angle_trim[B_AXIS])) * (radius + trt[B_AXIS]);
   \       0xC4   0x4638             MOV      R0,R7
   \       0xC6   0x.... 0x....      BL       __aeabi_f2d
   \       0xCA   0x4680             MOV      R8,R0
   \       0xCC   0x4689             MOV      R9,R1
   \       0xCE   0x4620             MOV      R0,R4
   \       0xD0   0x4629             MOV      R1,R5
   \       0xD2   0x.... 0x....      BL       sin
   \       0xD6   0x4642             MOV      R2,R8
   \       0xD8   0x464B             MOV      R3,R9
   \       0xDA   0x.... 0x....      BL       __aeabi_dmul
   \       0xDE   0x.... 0x....      BL       __aeabi_d2f
   \       0xE2   0x6130             STR      R0,[R6, #+16]
  12126              delta_tower[C_AXIS][X_AXIS] = 0.0; // back middle tower
   \       0xE4   0x2000             MOVS     R0,#+0
   \       0xE6   0x6170             STR      R0,[R6, #+20]
  12127              delta_tower[C_AXIS][Y_AXIS] = (radius + trt[C_AXIS]);
   \       0xE8   0x61B7             STR      R7,[R6, #+24]
  12128              delta_diagonal_rod_2_tower[A_AXIS] = sq(diagonal_rod + drt[A_AXIS]);
   \       0xEA   0x4651             MOV      R1,R10
   \       0xEC   0x.... 0x....      BL       __aeabi_fadd
   \       0xF0   0x4607             MOV      R7,R0
   \       0xF2   0x46B8             MOV      R8,R7
   \       0xF4   0x2402             MOVS     R4,#+2
   \       0xF6   0xF04F 0x557E      MOV      R5,#+1065353216
   \       0xFA   0x46A9             MOV      R9,R5
   \       0xFC   0xE004             B.N      ??recalc_delta_settings_0
   \                     ??recalc_delta_settings_1: (+1)
   \       0xFE   0x4640             MOV      R0,R8
   \      0x100   0x4641             MOV      R1,R8
   \      0x102   0x.... 0x....      BL       __aeabi_fmul
   \      0x106   0x4680             MOV      R8,R0
   \                     ??recalc_delta_settings_0: (+1)
   \      0x108   0x07E0             LSLS     R0,R4,#+31
   \      0x10A   0xD504             BPL.N    ??recalc_delta_settings_2
   \      0x10C   0x4648             MOV      R0,R9
   \      0x10E   0x4641             MOV      R1,R8
   \      0x110   0x.... 0x....      BL       __aeabi_fmul
   \      0x114   0x4681             MOV      R9,R0
   \                     ??recalc_delta_settings_2: (+1)
   \      0x116   0x0864             LSRS     R4,R4,#+1
   \      0x118   0xD1F1             BNE.N    ??recalc_delta_settings_1
   \      0x11A   0xF8C6 0x901C      STR      R9,[R6, #+28]
  12129              delta_diagonal_rod_2_tower[B_AXIS] = sq(diagonal_rod + drt[B_AXIS]);
   \      0x11E   0x46B8             MOV      R8,R7
   \      0x120   0x2402             MOVS     R4,#+2
   \      0x122   0x46A9             MOV      R9,R5
   \      0x124   0xE004             B.N      ??recalc_delta_settings_3
   \                     ??recalc_delta_settings_4: (+1)
   \      0x126   0x4640             MOV      R0,R8
   \      0x128   0x4641             MOV      R1,R8
   \      0x12A   0x.... 0x....      BL       __aeabi_fmul
   \      0x12E   0x4680             MOV      R8,R0
   \                     ??recalc_delta_settings_3: (+1)
   \      0x130   0x07E0             LSLS     R0,R4,#+31
   \      0x132   0xD504             BPL.N    ??recalc_delta_settings_5
   \      0x134   0x4648             MOV      R0,R9
   \      0x136   0x4641             MOV      R1,R8
   \      0x138   0x.... 0x....      BL       __aeabi_fmul
   \      0x13C   0x4681             MOV      R9,R0
   \                     ??recalc_delta_settings_5: (+1)
   \      0x13E   0x0864             LSRS     R4,R4,#+1
   \      0x140   0xD1F1             BNE.N    ??recalc_delta_settings_4
   \      0x142   0xF8C6 0x9020      STR      R9,[R6, #+32]
  12130              delta_diagonal_rod_2_tower[C_AXIS] = sq(diagonal_rod + drt[C_AXIS]);
   \      0x146   0x2402             MOVS     R4,#+2
   \      0x148   0xE004             B.N      ??recalc_delta_settings_6
   \                     ??recalc_delta_settings_7: (+1)
   \      0x14A   0x4638             MOV      R0,R7
   \      0x14C   0x4639             MOV      R1,R7
   \      0x14E   0x.... 0x....      BL       __aeabi_fmul
   \      0x152   0x4607             MOV      R7,R0
   \                     ??recalc_delta_settings_6: (+1)
   \      0x154   0x07E0             LSLS     R0,R4,#+31
   \      0x156   0xD504             BPL.N    ??recalc_delta_settings_8
   \      0x158   0x4628             MOV      R0,R5
   \      0x15A   0x4639             MOV      R1,R7
   \      0x15C   0x.... 0x....      BL       __aeabi_fmul
   \      0x160   0x4605             MOV      R5,R0
   \                     ??recalc_delta_settings_8: (+1)
   \      0x162   0x0864             LSRS     R4,R4,#+1
   \      0x164   0xD1F1             BNE.N    ??recalc_delta_settings_7
   \      0x166   0x6275             STR      R5,[R6, #+36]
  12131            }
   \      0x168   0xE8BD 0x87F3      POP      {R0,R1,R4-R10,PC}  ;; return
  12132          
  12133            #if ENABLED(DELTA_FAST_SQRT)
  12134              /**
  12135               * Fast inverse sqrt from Quake III Arena
  12136               * See: https://en.wikipedia.org/wiki/Fast_inverse_square_root
  12137               */
  12138              float Q_rsqrt(float number) {
  12139                long i;
  12140                float x2, y;
  12141                const float threehalfs = 1.5f;
  12142                x2 = number * 0.5f;
  12143                y  = number;
  12144                i  = * ( long * ) &y;                       // evil floating point bit level hacking
  12145                i  = 0x5F3759DF - ( i >> 1 );               // what the f***?
  12146                y  = * ( float * ) &i;
  12147                y  = y * ( threehalfs - ( x2 * y * y ) );   // 1st iteration
  12148                // y  = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, this can be removed
  12149                return y;
  12150              }
  12151          
  12152              #define _SQRT(n) (1.0f / Q_rsqrt(n))
  12153          
  12154            #else
  12155          
  12156              #define _SQRT(n) sqrt(n)
  12157          
  12158            #endif
  12159          
  12160            /**
  12161             * Delta Inverse Kinematics
  12162             *
  12163             * Calculate the tower positions for a given logical
  12164             * position, storing the result in the delta[] array.
  12165             *
  12166             * This is an expensive calculation, requiring 3 square
  12167             * roots per segmented linear move, and strains the limits
  12168             * of a Mega2560 with a Graphical Display.
  12169             *
  12170             * Suggested optimizations include:
  12171             *
  12172             * - Disable the home_offset (M206) and/or position_shift (G92)
  12173             *   features to remove up to 12 float additions.
  12174             *
  12175             * - Use a fast-inverse-sqrt function and add the reciprocal.
  12176             *   (see above)
  12177             */
  12178          
  12179            // Macro to obtain the Z position of an individual tower
  12180            #define DELTA_Z(T) raw[Z_AXIS] + _SQRT(     \
  12181              delta_diagonal_rod_2_tower[T] - HYPOT2(   \
  12182                  delta_tower[T][X_AXIS] - raw[X_AXIS], \
  12183                  delta_tower[T][Y_AXIS] - raw[Y_AXIS]  \
  12184                )                                       \
  12185              )
  12186          
  12187            #define DELTA_RAW_IK() do {        \
  12188              delta[A_AXIS] = DELTA_Z(A_AXIS); \
  12189              delta[B_AXIS] = DELTA_Z(B_AXIS); \
  12190              delta[C_AXIS] = DELTA_Z(C_AXIS); \
  12191            } while(0)
  12192          
  12193            #define DELTA_LOGICAL_IK() do {      \
  12194              const float raw[XYZ] = {           \
  12195                RAW_X_POSITION(logical[X_AXIS]), \
  12196                RAW_Y_POSITION(logical[Y_AXIS]), \
  12197                RAW_Z_POSITION(logical[Z_AXIS])  \
  12198              };                                 \
  12199              DELTA_RAW_IK();                    \
  12200            } while(0)
  12201          
  12202            #define DELTA_DEBUG() do { \
  12203                SERIAL_ECHOPAIR("cartesian X:", raw[X_AXIS]); \
  12204                SERIAL_ECHOPAIR(" Y:", raw[Y_AXIS]);          \
  12205                SERIAL_ECHOLNPAIR(" Z:", raw[Z_AXIS]);        \
  12206                SERIAL_ECHOPAIR("delta A:", delta[A_AXIS]);   \
  12207                SERIAL_ECHOPAIR(" B:", delta[B_AXIS]);        \
  12208                SERIAL_ECHOLNPAIR(" C:", delta[C_AXIS]);      \
  12209              } while(0)
  12210          

   \                                 In section .text, align 2, keep-with-next
  12211            void inverse_kinematics(const float logical[XYZ]) {
   \                     _Z18inverse_kinematicsPKf: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x4604             MOV      R4,R0
  12212              DELTA_LOGICAL_IK();
   \        0x6   0x.... 0x....      LDR.W    R5,??DataTable146
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x6C69             LDR      R1,[R5, #+68]
   \        0xE   0x.... 0x....      BL       __aeabi_fsub
   \       0x12   0x9001             STR      R0,[SP, #+4]
   \       0x14   0x6860             LDR      R0,[R4, #+4]
   \       0x16   0x6CA9             LDR      R1,[R5, #+72]
   \       0x18   0x.... 0x....      BL       __aeabi_fsub
   \       0x1C   0x9000             STR      R0,[SP, #+0]
   \       0x1E   0x68A0             LDR      R0,[R4, #+8]
   \       0x20   0x6CE9             LDR      R1,[R5, #+76]
   \       0x22   0x.... 0x....      BL       __aeabi_fsub
   \       0x26   0x4606             MOV      R6,R0
   \       0x28   0x.... 0x....      LDR.W    R7,??DataTable148_1
   \       0x2C   0x6878             LDR      R0,[R7, #+4]
   \       0x2E   0x9901             LDR      R1,[SP, #+4]
   \       0x30   0x.... 0x....      BL       __aeabi_fsub
   \       0x34   0x4682             MOV      R10,R0
   \       0x36   0x2402             MOVS     R4,#+2
   \       0x38   0xF04F 0x587E      MOV      R8,#+1065353216
   \       0x3C   0x46C1             MOV      R9,R8
   \       0x3E   0xE004             B.N      ??inverse_kinematics_0
   \                     ??inverse_kinematics_1: (+1)
   \       0x40   0x4650             MOV      R0,R10
   \       0x42   0x4651             MOV      R1,R10
   \       0x44   0x.... 0x....      BL       __aeabi_fmul
   \       0x48   0x4682             MOV      R10,R0
   \                     ??inverse_kinematics_0: (+1)
   \       0x4A   0x07E0             LSLS     R0,R4,#+31
   \       0x4C   0xD504             BPL.N    ??inverse_kinematics_2
   \       0x4E   0x4648             MOV      R0,R9
   \       0x50   0x4651             MOV      R1,R10
   \       0x52   0x.... 0x....      BL       __aeabi_fmul
   \       0x56   0x4681             MOV      R9,R0
   \                     ??inverse_kinematics_2: (+1)
   \       0x58   0x0864             LSRS     R4,R4,#+1
   \       0x5A   0xD1F1             BNE.N    ??inverse_kinematics_1
   \       0x5C   0x68B8             LDR      R0,[R7, #+8]
   \       0x5E   0x9900             LDR      R1,[SP, #+0]
   \       0x60   0x.... 0x....      BL       __aeabi_fsub
   \       0x64   0x4682             MOV      R10,R0
   \       0x66   0x2402             MOVS     R4,#+2
   \       0x68   0x46C3             MOV      R11,R8
   \       0x6A   0xE004             B.N      ??inverse_kinematics_3
   \                     ??inverse_kinematics_4: (+1)
   \       0x6C   0x4650             MOV      R0,R10
   \       0x6E   0x4651             MOV      R1,R10
   \       0x70   0x.... 0x....      BL       __aeabi_fmul
   \       0x74   0x4682             MOV      R10,R0
   \                     ??inverse_kinematics_3: (+1)
   \       0x76   0x07E0             LSLS     R0,R4,#+31
   \       0x78   0xD504             BPL.N    ??inverse_kinematics_5
   \       0x7A   0x4658             MOV      R0,R11
   \       0x7C   0x4651             MOV      R1,R10
   \       0x7E   0x.... 0x....      BL       __aeabi_fmul
   \       0x82   0x4683             MOV      R11,R0
   \                     ??inverse_kinematics_5: (+1)
   \       0x84   0x0864             LSRS     R4,R4,#+1
   \       0x86   0xD1F1             BNE.N    ??inverse_kinematics_4
   \       0x88   0x4648             MOV      R0,R9
   \       0x8A   0x4659             MOV      R1,R11
   \       0x8C   0x.... 0x....      BL       __aeabi_fadd
   \       0x90   0x4601             MOV      R1,R0
   \       0x92   0x69F8             LDR      R0,[R7, #+28]
   \       0x94   0x.... 0x....      BL       __aeabi_fsub
   \       0x98   0x.... 0x....      BL       sqrtf
   \       0x9C   0x4631             MOV      R1,R6
   \       0x9E   0x.... 0x....      BL       __aeabi_fadd
   \       0xA2   0x66A8             STR      R0,[R5, #+104]
   \       0xA4   0x68F8             LDR      R0,[R7, #+12]
   \       0xA6   0x9901             LDR      R1,[SP, #+4]
   \       0xA8   0x.... 0x....      BL       __aeabi_fsub
   \       0xAC   0x4682             MOV      R10,R0
   \       0xAE   0x2402             MOVS     R4,#+2
   \       0xB0   0x46C1             MOV      R9,R8
   \       0xB2   0xE004             B.N      ??inverse_kinematics_6
   \                     ??inverse_kinematics_7: (+1)
   \       0xB4   0x4650             MOV      R0,R10
   \       0xB6   0x4651             MOV      R1,R10
   \       0xB8   0x.... 0x....      BL       __aeabi_fmul
   \       0xBC   0x4682             MOV      R10,R0
   \                     ??inverse_kinematics_6: (+1)
   \       0xBE   0x07E0             LSLS     R0,R4,#+31
   \       0xC0   0xD504             BPL.N    ??inverse_kinematics_8
   \       0xC2   0x4648             MOV      R0,R9
   \       0xC4   0x4651             MOV      R1,R10
   \       0xC6   0x.... 0x....      BL       __aeabi_fmul
   \       0xCA   0x4681             MOV      R9,R0
   \                     ??inverse_kinematics_8: (+1)
   \       0xCC   0x0864             LSRS     R4,R4,#+1
   \       0xCE   0xD1F1             BNE.N    ??inverse_kinematics_7
   \       0xD0   0x6938             LDR      R0,[R7, #+16]
   \       0xD2   0x9900             LDR      R1,[SP, #+0]
   \       0xD4   0x.... 0x....      BL       __aeabi_fsub
   \       0xD8   0x4682             MOV      R10,R0
   \       0xDA   0x2402             MOVS     R4,#+2
   \       0xDC   0x46C3             MOV      R11,R8
   \       0xDE   0xE004             B.N      ??inverse_kinematics_9
   \                     ??inverse_kinematics_10: (+1)
   \       0xE0   0x4650             MOV      R0,R10
   \       0xE2   0x4651             MOV      R1,R10
   \       0xE4   0x.... 0x....      BL       __aeabi_fmul
   \       0xE8   0x4682             MOV      R10,R0
   \                     ??inverse_kinematics_9: (+1)
   \       0xEA   0x07E0             LSLS     R0,R4,#+31
   \       0xEC   0xD504             BPL.N    ??inverse_kinematics_11
   \       0xEE   0x4658             MOV      R0,R11
   \       0xF0   0x4651             MOV      R1,R10
   \       0xF2   0x.... 0x....      BL       __aeabi_fmul
   \       0xF6   0x4683             MOV      R11,R0
   \                     ??inverse_kinematics_11: (+1)
   \       0xF8   0x0864             LSRS     R4,R4,#+1
   \       0xFA   0xD1F1             BNE.N    ??inverse_kinematics_10
   \       0xFC   0x4648             MOV      R0,R9
   \       0xFE   0x4659             MOV      R1,R11
   \      0x100   0x.... 0x....      BL       __aeabi_fadd
   \      0x104   0x4601             MOV      R1,R0
   \      0x106   0x6A38             LDR      R0,[R7, #+32]
   \      0x108   0x.... 0x....      BL       __aeabi_fsub
   \      0x10C   0x.... 0x....      BL       sqrtf
   \      0x110   0x4631             MOV      R1,R6
   \      0x112   0x.... 0x....      BL       __aeabi_fadd
   \      0x116   0x66E8             STR      R0,[R5, #+108]
   \      0x118   0x6978             LDR      R0,[R7, #+20]
   \      0x11A   0x9901             LDR      R1,[SP, #+4]
   \      0x11C   0x.... 0x....      BL       __aeabi_fsub
   \      0x120   0x4682             MOV      R10,R0
   \      0x122   0x2402             MOVS     R4,#+2
   \      0x124   0x46C1             MOV      R9,R8
   \      0x126   0xE004             B.N      ??inverse_kinematics_12
   \                     ??inverse_kinematics_13: (+1)
   \      0x128   0x4650             MOV      R0,R10
   \      0x12A   0x4651             MOV      R1,R10
   \      0x12C   0x.... 0x....      BL       __aeabi_fmul
   \      0x130   0x4682             MOV      R10,R0
   \                     ??inverse_kinematics_12: (+1)
   \      0x132   0x07E0             LSLS     R0,R4,#+31
   \      0x134   0xD504             BPL.N    ??inverse_kinematics_14
   \      0x136   0x4648             MOV      R0,R9
   \      0x138   0x4651             MOV      R1,R10
   \      0x13A   0x.... 0x....      BL       __aeabi_fmul
   \      0x13E   0x4681             MOV      R9,R0
   \                     ??inverse_kinematics_14: (+1)
   \      0x140   0x0864             LSRS     R4,R4,#+1
   \      0x142   0xD1F1             BNE.N    ??inverse_kinematics_13
   \      0x144   0x69B8             LDR      R0,[R7, #+24]
   \      0x146   0x9900             LDR      R1,[SP, #+0]
   \      0x148   0x.... 0x....      BL       __aeabi_fsub
   \      0x14C   0x4682             MOV      R10,R0
   \      0x14E   0x2402             MOVS     R4,#+2
   \      0x150   0xE004             B.N      ??inverse_kinematics_15
   \                     ??inverse_kinematics_16: (+1)
   \      0x152   0x4650             MOV      R0,R10
   \      0x154   0x4651             MOV      R1,R10
   \      0x156   0x.... 0x....      BL       __aeabi_fmul
   \      0x15A   0x4682             MOV      R10,R0
   \                     ??inverse_kinematics_15: (+1)
   \      0x15C   0x07E0             LSLS     R0,R4,#+31
   \      0x15E   0xD504             BPL.N    ??inverse_kinematics_17
   \      0x160   0x4640             MOV      R0,R8
   \      0x162   0x4651             MOV      R1,R10
   \      0x164   0x.... 0x....      BL       __aeabi_fmul
   \      0x168   0x4680             MOV      R8,R0
   \                     ??inverse_kinematics_17: (+1)
   \      0x16A   0x0864             LSRS     R4,R4,#+1
   \      0x16C   0xD1F1             BNE.N    ??inverse_kinematics_16
   \      0x16E   0x4648             MOV      R0,R9
   \      0x170   0x4641             MOV      R1,R8
   \      0x172   0x.... 0x....      BL       __aeabi_fadd
   \      0x176   0x4601             MOV      R1,R0
   \      0x178   0x6A78             LDR      R0,[R7, #+36]
   \      0x17A   0x.... 0x....      BL       __aeabi_fsub
   \      0x17E   0x.... 0x....      BL       sqrtf
   \      0x182   0x4631             MOV      R1,R6
   \      0x184   0x.... 0x....      BL       __aeabi_fadd
   \      0x188   0x6728             STR      R0,[R5, #+112]
  12213              // DELTA_DEBUG();
  12214            }
   \      0x18A   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
  12215          
  12216            /**
  12217             * Calculate the highest Z position where the
  12218             * effector has the full range of XY motion.
  12219             */

   \                                 In section .text, align 2, keep-with-next
  12220            float delta_safe_distance_from_top() {
   \                     _Z28delta_safe_distance_from_topv: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
  12221              float cartesian[XYZ] = {
  12222                LOGICAL_X_POSITION(0),
  12223                LOGICAL_Y_POSITION(0),
  12224                LOGICAL_Z_POSITION(0)
  12225              };
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable146
   \        0x6   0x6C60             LDR      R0,[R4, #+68]
   \        0x8   0x9000             STR      R0,[SP, #+0]
   \        0xA   0x466D             MOV      R5,SP
   \        0xC   0x6CA0             LDR      R0,[R4, #+72]
   \        0xE   0x6068             STR      R0,[R5, #+4]
   \       0x10   0x6CE0             LDR      R0,[R4, #+76]
   \       0x12   0x9002             STR      R0,[SP, #+8]
  12226          	if(MACHINETPYE == MORGAN_SCARA)
   \       0x14   0x.... 0x....      LDR.W    R6,??DataTable145
   \       0x18   0xF9B6 0x0058      LDRSH    R0,[R6, #+88]
   \       0x1C   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x20   0x4668             MOV      R0,SP
   \       0x22   0xD102             BNE.N    ??delta_safe_distance_from_top_0
  12227          		inverse_kinematics_MORGAN_SCARA(cartesian);
   \       0x24   0x.... 0x....      BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
   \       0x28   0xE001             B.N      ??delta_safe_distance_from_top_1
  12228          	else
  12229          	    inverse_kinematics(cartesian);
   \                     ??delta_safe_distance_from_top_0: (+1)
   \       0x2A   0x.... 0x....      BL       _Z18inverse_kinematicsPKf
  12230          	
  12231              float distance = delta[A_AXIS];
   \                     ??delta_safe_distance_from_top_1: (+1)
   \       0x2E   0x6EA7             LDR      R7,[R4, #+104]
  12232              cartesian[Y_AXIS] = LOGICAL_Y_POSITION(DELTA_PRINTABLE_RADIUS);
   \       0x30   0x6D71             LDR      R1,[R6, #+84]
   \       0x32   0x6CA0             LDR      R0,[R4, #+72]
   \       0x34   0x.... 0x....      BL       __aeabi_fadd
   \       0x38   0x6068             STR      R0,[R5, #+4]
  12233          	
  12234          	if(MACHINETPYE == MORGAN_SCARA)
   \       0x3A   0xF9B6 0x0058      LDRSH    R0,[R6, #+88]
   \       0x3E   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x42   0x4668             MOV      R0,SP
   \       0x44   0xD102             BNE.N    ??delta_safe_distance_from_top_2
  12235          		inverse_kinematics_MORGAN_SCARA(cartesian);
   \       0x46   0x.... 0x....      BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
   \       0x4A   0xE001             B.N      ??delta_safe_distance_from_top_3
  12236          	else
  12237          	    inverse_kinematics(cartesian);
   \                     ??delta_safe_distance_from_top_2: (+1)
   \       0x4C   0x.... 0x....      BL       _Z18inverse_kinematicsPKf
  12238          	
  12239              return abs(distance - delta[A_AXIS]);
   \                     ??delta_safe_distance_from_top_3: (+1)
   \       0x50   0x4638             MOV      R0,R7
   \       0x52   0x6EA1             LDR      R1,[R4, #+104]
   \       0x54   0x.... 0x....      BL       __aeabi_fsub
   \       0x58   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \       0x5C   0xBDFE             POP      {R1-R7,PC}       ;; return
  12240            }
  12241          
  12242            /**
  12243             * Delta Forward Kinematics
  12244             *
  12245             * See the Wikipedia article "Trilateration"
  12246             * https://en.wikipedia.org/wiki/Trilateration
  12247             *
  12248             * Establish a new coordinate system in the plane of the
  12249             * three carriage points. This system has its origin at
  12250             * tower1, with tower2 on the X axis. Tower3 is in the X-Y
  12251             * plane with a Z component of zero.
  12252             * We will define unit vectors in this coordinate system
  12253             * in our original coordinate system. Then when we calculate
  12254             * the Xnew, Ynew and Znew values, we can translate back into
  12255             * the original system by moving along those unit vectors
  12256             * by the corresponding values.
  12257             *
  12258             * Variable names matched to Marlin, c-version, and avoid the
  12259             * use of any vector library.
  12260             *
  12261             * by Andreas Hardtung 2016-06-07
  12262             * based on a Java function from "Delta Robot Kinematics V3"
  12263             * by Steve Graves
  12264             *
  12265             * The result is stored in the cartes[] array.
  12266             */

   \                                 In section .text, align 2, keep-with-next
  12267            void forward_kinematics_DELTA(float z1, float z2, float z3) {
   \                     _Z24forward_kinematics_DELTAfff: (+1)
   \        0x0   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \        0x4   0xB08A             SUB      SP,SP,#+40
   \        0x6   0x460C             MOV      R4,R1
   \        0x8   0x4617             MOV      R7,R2
  12268              // Create a vector in old coordinates along x axis of new coordinate
  12269              float p12[3] = { delta_tower[B_AXIS][X_AXIS] - delta_tower[A_AXIS][X_AXIS], delta_tower[B_AXIS][Y_AXIS] - delta_tower[A_AXIS][Y_AXIS], z2 - z1 };
   \        0xA   0x.... 0x....      LDR.W    R5,??DataTable148_1
   \        0xE   0x68E8             LDR      R0,[R5, #+12]
   \       0x10   0x6869             LDR      R1,[R5, #+4]
   \       0x12   0x.... 0x....      BL       __aeabi_fsub
   \       0x16   0x9001             STR      R0,[SP, #+4]
   \       0x18   0x6928             LDR      R0,[R5, #+16]
   \       0x1A   0x68A9             LDR      R1,[R5, #+8]
   \       0x1C   0x.... 0x....      BL       __aeabi_fsub
   \       0x20   0x4680             MOV      R8,R0
   \       0x22   0x4620             MOV      R0,R4
   \       0x24   0x990A             LDR      R1,[SP, #+40]
   \       0x26   0x.... 0x....      BL       __aeabi_fsub
   \       0x2A   0x4681             MOV      R9,R0
  12270          
  12271              // Get the Magnitude of vector.
  12272              float d = sqrt( sq(p12[0]) + sq(p12[1]) + sq(p12[2]) );
   \       0x2C   0x9E01             LDR      R6,[SP, #+4]
   \       0x2E   0x2502             MOVS     R5,#+2
   \       0x30   0xF04F 0x547E      MOV      R4,#+1065353216
   \       0x34   0xE004             B.N      ??forward_kinematics_DELTA_0
   \                     ??forward_kinematics_DELTA_1: (+1)
   \       0x36   0x4630             MOV      R0,R6
   \       0x38   0x4631             MOV      R1,R6
   \       0x3A   0x.... 0x....      BL       __aeabi_fmul
   \       0x3E   0x4606             MOV      R6,R0
   \                     ??forward_kinematics_DELTA_0: (+1)
   \       0x40   0x07E8             LSLS     R0,R5,#+31
   \       0x42   0xD504             BPL.N    ??forward_kinematics_DELTA_2
   \       0x44   0x4620             MOV      R0,R4
   \       0x46   0x4631             MOV      R1,R6
   \       0x48   0x.... 0x....      BL       __aeabi_fmul
   \       0x4C   0x4604             MOV      R4,R0
   \                     ??forward_kinematics_DELTA_2: (+1)
   \       0x4E   0x086D             LSRS     R5,R5,#+1
   \       0x50   0xD1F1             BNE.N    ??forward_kinematics_DELTA_1
   \       0x52   0x46C2             MOV      R10,R8
   \       0x54   0x2602             MOVS     R6,#+2
   \       0x56   0xF04F 0x557E      MOV      R5,#+1065353216
   \       0x5A   0xE004             B.N      ??forward_kinematics_DELTA_3
   \                     ??forward_kinematics_DELTA_4: (+1)
   \       0x5C   0x4650             MOV      R0,R10
   \       0x5E   0x4651             MOV      R1,R10
   \       0x60   0x.... 0x....      BL       __aeabi_fmul
   \       0x64   0x4682             MOV      R10,R0
   \                     ??forward_kinematics_DELTA_3: (+1)
   \       0x66   0x07F0             LSLS     R0,R6,#+31
   \       0x68   0xD504             BPL.N    ??forward_kinematics_DELTA_5
   \       0x6A   0x4628             MOV      R0,R5
   \       0x6C   0x4651             MOV      R1,R10
   \       0x6E   0x.... 0x....      BL       __aeabi_fmul
   \       0x72   0x4605             MOV      R5,R0
   \                     ??forward_kinematics_DELTA_5: (+1)
   \       0x74   0x0876             LSRS     R6,R6,#+1
   \       0x76   0xD1F1             BNE.N    ??forward_kinematics_DELTA_4
   \       0x78   0x46CA             MOV      R10,R9
   \       0x7A   0x2602             MOVS     R6,#+2
   \       0x7C   0xF04F 0x5B7E      MOV      R11,#+1065353216
   \       0x80   0xE004             B.N      ??forward_kinematics_DELTA_6
   \                     ??forward_kinematics_DELTA_7: (+1)
   \       0x82   0x4650             MOV      R0,R10
   \       0x84   0x4651             MOV      R1,R10
   \       0x86   0x.... 0x....      BL       __aeabi_fmul
   \       0x8A   0x4682             MOV      R10,R0
   \                     ??forward_kinematics_DELTA_6: (+1)
   \       0x8C   0x07F0             LSLS     R0,R6,#+31
   \       0x8E   0xD504             BPL.N    ??forward_kinematics_DELTA_8
   \       0x90   0x4658             MOV      R0,R11
   \       0x92   0x4651             MOV      R1,R10
   \       0x94   0x.... 0x....      BL       __aeabi_fmul
   \       0x98   0x4683             MOV      R11,R0
   \                     ??forward_kinematics_DELTA_8: (+1)
   \       0x9A   0x0876             LSRS     R6,R6,#+1
   \       0x9C   0xD1F1             BNE.N    ??forward_kinematics_DELTA_7
   \       0x9E   0x463E             MOV      R6,R7
   \       0xA0   0x4620             MOV      R0,R4
   \       0xA2   0x4629             MOV      R1,R5
   \       0xA4   0x.... 0x....      BL       __aeabi_fadd
   \       0xA8   0x4659             MOV      R1,R11
   \       0xAA   0x.... 0x....      BL       __aeabi_fadd
   \       0xAE   0x.... 0x....      BL       sqrtf
   \       0xB2   0x9000             STR      R0,[SP, #+0]
  12273          
  12274              // Create unit vector by dividing by magnitude.
  12275              float ex[3] = { p12[0] / d, p12[1] / d, p12[2] / d };
   \       0xB4   0x9801             LDR      R0,[SP, #+4]
   \       0xB6   0x9900             LDR      R1,[SP, #+0]
   \       0xB8   0x.... 0x....      BL       __aeabi_fdiv
   \       0xBC   0x9004             STR      R0,[SP, #+16]
   \       0xBE   0x4640             MOV      R0,R8
   \       0xC0   0x9900             LDR      R1,[SP, #+0]
   \       0xC2   0x.... 0x....      BL       __aeabi_fdiv
   \       0xC6   0x9003             STR      R0,[SP, #+12]
   \       0xC8   0x4648             MOV      R0,R9
   \       0xCA   0x9900             LDR      R1,[SP, #+0]
   \       0xCC   0x.... 0x....      BL       __aeabi_fdiv
   \       0xD0   0x9002             STR      R0,[SP, #+8]
  12276          
  12277              // Get the vector from the origin of the new system to the third point.
  12278              float p13[3] = { delta_tower[C_AXIS][X_AXIS] - delta_tower[A_AXIS][X_AXIS], delta_tower[C_AXIS][Y_AXIS] - delta_tower[A_AXIS][Y_AXIS], z3 - z1 };
   \       0xD2   0x.... 0x....      LDR.W    R7,??DataTable148_1
   \       0xD6   0x6978             LDR      R0,[R7, #+20]
   \       0xD8   0x6879             LDR      R1,[R7, #+4]
   \       0xDA   0x.... 0x....      BL       __aeabi_fsub
   \       0xDE   0x4680             MOV      R8,R0
   \       0xE0   0x69B8             LDR      R0,[R7, #+24]
   \       0xE2   0x68B9             LDR      R1,[R7, #+8]
   \       0xE4   0x.... 0x....      BL       __aeabi_fsub
   \       0xE8   0x4604             MOV      R4,R0
   \       0xEA   0x4630             MOV      R0,R6
   \       0xEC   0x990A             LDR      R1,[SP, #+40]
   \       0xEE   0x.... 0x....      BL       __aeabi_fsub
   \       0xF2   0x4606             MOV      R6,R0
  12279          
  12280              // Use the dot product to find the component of this vector on the X axis.
  12281              float i = ex[0] * p13[0] + ex[1] * p13[1] + ex[2] * p13[2];
   \       0xF4   0x9804             LDR      R0,[SP, #+16]
   \       0xF6   0x4641             MOV      R1,R8
   \       0xF8   0x.... 0x....      BL       __aeabi_fmul
   \       0xFC   0x4605             MOV      R5,R0
   \       0xFE   0x9803             LDR      R0,[SP, #+12]
   \      0x100   0x4621             MOV      R1,R4
   \      0x102   0x.... 0x....      BL       __aeabi_fmul
   \      0x106   0x4629             MOV      R1,R5
   \      0x108   0x.... 0x....      BL       __aeabi_fadd
   \      0x10C   0x4605             MOV      R5,R0
   \      0x10E   0x9802             LDR      R0,[SP, #+8]
   \      0x110   0x4631             MOV      R1,R6
   \      0x112   0x.... 0x....      BL       __aeabi_fmul
   \      0x116   0x4629             MOV      R1,R5
   \      0x118   0x.... 0x....      BL       __aeabi_fadd
   \      0x11C   0x4605             MOV      R5,R0
  12282          
  12283              // Create a vector along the x axis that represents the x component of p13.
  12284              float iex[3] = { ex[0] * i, ex[1] * i, ex[2] * i };
  12285          
  12286              // Subtract the X component from the original vector leaving only Y. We use the
  12287              // variable that will be the unit vector after we scale it.
  12288              float ey[3] = { p13[0] - iex[0], p13[1] - iex[1], p13[2] - iex[2] };
   \      0x11E   0x9804             LDR      R0,[SP, #+16]
   \      0x120   0x4629             MOV      R1,R5
   \      0x122   0x.... 0x....      BL       __aeabi_fmul
   \      0x126   0x4601             MOV      R1,R0
   \      0x128   0x4640             MOV      R0,R8
   \      0x12A   0x.... 0x....      BL       __aeabi_fsub
   \      0x12E   0x4680             MOV      R8,R0
   \      0x130   0x9803             LDR      R0,[SP, #+12]
   \      0x132   0x4629             MOV      R1,R5
   \      0x134   0x.... 0x....      BL       __aeabi_fmul
   \      0x138   0x4601             MOV      R1,R0
   \      0x13A   0x4620             MOV      R0,R4
   \      0x13C   0x.... 0x....      BL       __aeabi_fsub
   \      0x140   0x9007             STR      R0,[SP, #+28]
   \      0x142   0x9802             LDR      R0,[SP, #+8]
   \      0x144   0x4629             MOV      R1,R5
   \      0x146   0x.... 0x....      BL       __aeabi_fmul
   \      0x14A   0x4601             MOV      R1,R0
   \      0x14C   0x4630             MOV      R0,R6
   \      0x14E   0x.... 0x....      BL       __aeabi_fsub
   \      0x152   0x9006             STR      R0,[SP, #+24]
  12289          
  12290              // The magnitude of Y component
  12291              float j = sqrt( sq(ey[0]) + sq(ey[1]) + sq(ey[2]) );
   \      0x154   0x46C1             MOV      R9,R8
   \      0x156   0x2602             MOVS     R6,#+2
   \      0x158   0xF04F 0x547E      MOV      R4,#+1065353216
   \      0x15C   0xE004             B.N      ??forward_kinematics_DELTA_9
   \                     ??forward_kinematics_DELTA_10: (+1)
   \      0x15E   0x4648             MOV      R0,R9
   \      0x160   0x4649             MOV      R1,R9
   \      0x162   0x.... 0x....      BL       __aeabi_fmul
   \      0x166   0x4681             MOV      R9,R0
   \                     ??forward_kinematics_DELTA_9: (+1)
   \      0x168   0x07F0             LSLS     R0,R6,#+31
   \      0x16A   0xD504             BPL.N    ??forward_kinematics_DELTA_11
   \      0x16C   0x4620             MOV      R0,R4
   \      0x16E   0x4649             MOV      R1,R9
   \      0x170   0x.... 0x....      BL       __aeabi_fmul
   \      0x174   0x4604             MOV      R4,R0
   \                     ??forward_kinematics_DELTA_11: (+1)
   \      0x176   0x0876             LSRS     R6,R6,#+1
   \      0x178   0xD1F1             BNE.N    ??forward_kinematics_DELTA_10
   \      0x17A   0xF8DD 0xA01C      LDR      R10,[SP, #+28]
   \      0x17E   0x2602             MOVS     R6,#+2
   \      0x180   0xF04F 0x597E      MOV      R9,#+1065353216
   \      0x184   0xE004             B.N      ??forward_kinematics_DELTA_12
   \                     ??forward_kinematics_DELTA_13: (+1)
   \      0x186   0x4650             MOV      R0,R10
   \      0x188   0x4651             MOV      R1,R10
   \      0x18A   0x.... 0x....      BL       __aeabi_fmul
   \      0x18E   0x4682             MOV      R10,R0
   \                     ??forward_kinematics_DELTA_12: (+1)
   \      0x190   0x07F0             LSLS     R0,R6,#+31
   \      0x192   0xD504             BPL.N    ??forward_kinematics_DELTA_14
   \      0x194   0x4648             MOV      R0,R9
   \      0x196   0x4651             MOV      R1,R10
   \      0x198   0x.... 0x....      BL       __aeabi_fmul
   \      0x19C   0x4681             MOV      R9,R0
   \                     ??forward_kinematics_DELTA_14: (+1)
   \      0x19E   0x0876             LSRS     R6,R6,#+1
   \      0x1A0   0xD1F1             BNE.N    ??forward_kinematics_DELTA_13
   \      0x1A2   0xF8DD 0xA018      LDR      R10,[SP, #+24]
   \      0x1A6   0x2602             MOVS     R6,#+2
   \      0x1A8   0xF04F 0x5B7E      MOV      R11,#+1065353216
   \      0x1AC   0xE004             B.N      ??forward_kinematics_DELTA_15
   \                     ??forward_kinematics_DELTA_16: (+1)
   \      0x1AE   0x4650             MOV      R0,R10
   \      0x1B0   0x4651             MOV      R1,R10
   \      0x1B2   0x.... 0x....      BL       __aeabi_fmul
   \      0x1B6   0x4682             MOV      R10,R0
   \                     ??forward_kinematics_DELTA_15: (+1)
   \      0x1B8   0x07F0             LSLS     R0,R6,#+31
   \      0x1BA   0xD504             BPL.N    ??forward_kinematics_DELTA_17
   \      0x1BC   0x4658             MOV      R0,R11
   \      0x1BE   0x4651             MOV      R1,R10
   \      0x1C0   0x.... 0x....      BL       __aeabi_fmul
   \      0x1C4   0x4683             MOV      R11,R0
   \                     ??forward_kinematics_DELTA_17: (+1)
   \      0x1C6   0x0876             LSRS     R6,R6,#+1
   \      0x1C8   0xD1F1             BNE.N    ??forward_kinematics_DELTA_16
   \      0x1CA   0x4620             MOV      R0,R4
   \      0x1CC   0x4649             MOV      R1,R9
   \      0x1CE   0x.... 0x....      BL       __aeabi_fadd
   \      0x1D2   0x4659             MOV      R1,R11
   \      0x1D4   0x.... 0x....      BL       __aeabi_fadd
   \      0x1D8   0x.... 0x....      BL       sqrtf
   \      0x1DC   0x9001             STR      R0,[SP, #+4]
  12292          
  12293              // Convert to a unit vector
  12294              ey[0] /= j; ey[1] /= j;  ey[2] /= j;
   \      0x1DE   0x4640             MOV      R0,R8
   \      0x1E0   0x9901             LDR      R1,[SP, #+4]
   \      0x1E2   0x.... 0x....      BL       __aeabi_fdiv
   \      0x1E6   0x9005             STR      R0,[SP, #+20]
   \      0x1E8   0x9807             LDR      R0,[SP, #+28]
   \      0x1EA   0x9901             LDR      R1,[SP, #+4]
   \      0x1EC   0x.... 0x....      BL       __aeabi_fdiv
   \      0x1F0   0x4680             MOV      R8,R0
   \      0x1F2   0x9806             LDR      R0,[SP, #+24]
   \      0x1F4   0x9901             LDR      R1,[SP, #+4]
   \      0x1F6   0x.... 0x....      BL       __aeabi_fdiv
   \      0x1FA   0x4681             MOV      R9,R0
  12295          
  12296              // The cross product of the unit x and y is the unit z
  12297              // float[] ez = vectorCrossProd(ex, ey);
  12298              float ez[3] = {
  12299                ex[1] * ey[2] - ex[2] * ey[1],
  12300                ex[2] * ey[0] - ex[0] * ey[2],
  12301                ex[0] * ey[1] - ex[1] * ey[0]
  12302              };
   \      0x1FC   0x9803             LDR      R0,[SP, #+12]
   \      0x1FE   0x4649             MOV      R1,R9
   \      0x200   0x.... 0x....      BL       __aeabi_fmul
   \      0x204   0x4604             MOV      R4,R0
   \      0x206   0x9802             LDR      R0,[SP, #+8]
   \      0x208   0x4641             MOV      R1,R8
   \      0x20A   0x.... 0x....      BL       __aeabi_fmul
   \      0x20E   0x4601             MOV      R1,R0
   \      0x210   0x4620             MOV      R0,R4
   \      0x212   0x.... 0x....      BL       __aeabi_fsub
   \      0x216   0x9008             STR      R0,[SP, #+32]
   \      0x218   0x9902             LDR      R1,[SP, #+8]
   \      0x21A   0x9805             LDR      R0,[SP, #+20]
   \      0x21C   0x.... 0x....      BL       __aeabi_fmul
   \      0x220   0x4604             MOV      R4,R0
   \      0x222   0x9804             LDR      R0,[SP, #+16]
   \      0x224   0x4649             MOV      R1,R9
   \      0x226   0x.... 0x....      BL       __aeabi_fmul
   \      0x22A   0x4601             MOV      R1,R0
   \      0x22C   0x4620             MOV      R0,R4
   \      0x22E   0x.... 0x....      BL       __aeabi_fsub
   \      0x232   0x9007             STR      R0,[SP, #+28]
   \      0x234   0x9804             LDR      R0,[SP, #+16]
   \      0x236   0x4641             MOV      R1,R8
   \      0x238   0x.... 0x....      BL       __aeabi_fmul
   \      0x23C   0x4604             MOV      R4,R0
   \      0x23E   0x9903             LDR      R1,[SP, #+12]
   \      0x240   0x9805             LDR      R0,[SP, #+20]
   \      0x242   0x.... 0x....      BL       __aeabi_fmul
   \      0x246   0x4601             MOV      R1,R0
   \      0x248   0x4620             MOV      R0,R4
   \      0x24A   0x.... 0x....      BL       __aeabi_fsub
   \      0x24E   0x9006             STR      R0,[SP, #+24]
  12303          
  12304              // We now have the d, i and j values defined in Wikipedia.
  12305              // Plug them into the equations defined in Wikipedia for Xnew, Ynew and Znew
  12306              float Xnew = (delta_diagonal_rod_2_tower[A_AXIS] - delta_diagonal_rod_2_tower[B_AXIS] + sq(d)) / (d * 2),
   \      0x250   0x9E00             LDR      R6,[SP, #+0]
   \      0x252   0x2402             MOVS     R4,#+2
   \      0x254   0xF04F 0x5A7E      MOV      R10,#+1065353216
   \      0x258   0xE004             B.N      ??forward_kinematics_DELTA_18
   \                     ??forward_kinematics_DELTA_19: (+1)
   \      0x25A   0x4630             MOV      R0,R6
   \      0x25C   0x4631             MOV      R1,R6
   \      0x25E   0x.... 0x....      BL       __aeabi_fmul
   \      0x262   0x4606             MOV      R6,R0
   \                     ??forward_kinematics_DELTA_18: (+1)
   \      0x264   0x07E0             LSLS     R0,R4,#+31
   \      0x266   0xD504             BPL.N    ??forward_kinematics_DELTA_20
   \      0x268   0x4650             MOV      R0,R10
   \      0x26A   0x4631             MOV      R1,R6
   \      0x26C   0x.... 0x....      BL       __aeabi_fmul
   \      0x270   0x4682             MOV      R10,R0
   \                     ??forward_kinematics_DELTA_20: (+1)
   \      0x272   0x0864             LSRS     R4,R4,#+1
   \      0x274   0xD1F1             BNE.N    ??forward_kinematics_DELTA_19
   \      0x276   0x69F8             LDR      R0,[R7, #+28]
   \      0x278   0x6A39             LDR      R1,[R7, #+32]
   \      0x27A   0x.... 0x....      BL       __aeabi_fsub
   \      0x27E   0x4651             MOV      R1,R10
   \      0x280   0x.... 0x....      BL       __aeabi_fadd
   \      0x284   0x4604             MOV      R4,R0
   \      0x286   0x9900             LDR      R1,[SP, #+0]
   \      0x288   0xF04F 0x4080      MOV      R0,#+1073741824
   \      0x28C   0x.... 0x....      BL       __aeabi_fmul
   \      0x290   0x4601             MOV      R1,R0
   \      0x292   0x4620             MOV      R0,R4
   \      0x294   0x.... 0x....      BL       __aeabi_fdiv
   \      0x298   0x9000             STR      R0,[SP, #+0]
  12307                    Ynew = ((delta_diagonal_rod_2_tower[A_AXIS] - delta_diagonal_rod_2_tower[C_AXIS] + HYPOT2(i, j)) / 2 - i * Xnew) / j,
   \      0x29A   0x46AA             MOV      R10,R5
   \      0x29C   0x2402             MOVS     R4,#+2
   \      0x29E   0xF04F 0x567E      MOV      R6,#+1065353216
   \      0x2A2   0xE004             B.N      ??forward_kinematics_DELTA_21
   \                     ??forward_kinematics_DELTA_22: (+1)
   \      0x2A4   0x4650             MOV      R0,R10
   \      0x2A6   0x4651             MOV      R1,R10
   \      0x2A8   0x.... 0x....      BL       __aeabi_fmul
   \      0x2AC   0x4682             MOV      R10,R0
   \                     ??forward_kinematics_DELTA_21: (+1)
   \      0x2AE   0x07E0             LSLS     R0,R4,#+31
   \      0x2B0   0xD504             BPL.N    ??forward_kinematics_DELTA_23
   \      0x2B2   0x4630             MOV      R0,R6
   \      0x2B4   0x4651             MOV      R1,R10
   \      0x2B6   0x.... 0x....      BL       __aeabi_fmul
   \      0x2BA   0x4606             MOV      R6,R0
   \                     ??forward_kinematics_DELTA_23: (+1)
   \      0x2BC   0x0864             LSRS     R4,R4,#+1
   \      0x2BE   0xD1F1             BNE.N    ??forward_kinematics_DELTA_22
   \      0x2C0   0xF8DD 0xA004      LDR      R10,[SP, #+4]
   \      0x2C4   0x2402             MOVS     R4,#+2
   \      0x2C6   0xF04F 0x5B7E      MOV      R11,#+1065353216
   \      0x2CA   0xE004             B.N      ??forward_kinematics_DELTA_24
   \                     ??forward_kinematics_DELTA_25: (+1)
   \      0x2CC   0x4650             MOV      R0,R10
   \      0x2CE   0x4651             MOV      R1,R10
   \      0x2D0   0x.... 0x....      BL       __aeabi_fmul
   \      0x2D4   0x4682             MOV      R10,R0
   \                     ??forward_kinematics_DELTA_24: (+1)
   \      0x2D6   0x07E0             LSLS     R0,R4,#+31
   \      0x2D8   0xD504             BPL.N    ??forward_kinematics_DELTA_26
   \      0x2DA   0x4658             MOV      R0,R11
   \      0x2DC   0x4651             MOV      R1,R10
   \      0x2DE   0x.... 0x....      BL       __aeabi_fmul
   \      0x2E2   0x4683             MOV      R11,R0
   \                     ??forward_kinematics_DELTA_26: (+1)
   \      0x2E4   0x0864             LSRS     R4,R4,#+1
   \      0x2E6   0xD1F1             BNE.N    ??forward_kinematics_DELTA_25
   \      0x2E8   0x69F8             LDR      R0,[R7, #+28]
   \      0x2EA   0x6A79             LDR      R1,[R7, #+36]
   \      0x2EC   0x.... 0x....      BL       __aeabi_fsub
   \      0x2F0   0x4604             MOV      R4,R0
   \      0x2F2   0x4630             MOV      R0,R6
   \      0x2F4   0x4659             MOV      R1,R11
   \      0x2F6   0x.... 0x....      BL       __aeabi_fadd
   \      0x2FA   0x4621             MOV      R1,R4
   \      0x2FC   0x.... 0x....      BL       __aeabi_fadd
   \      0x300   0xF04F 0x517C      MOV      R1,#+1056964608
   \      0x304   0x.... 0x....      BL       __aeabi_fmul
   \      0x308   0x4604             MOV      R4,R0
   \      0x30A   0x9800             LDR      R0,[SP, #+0]
   \      0x30C   0x4629             MOV      R1,R5
   \      0x30E   0x.... 0x....      BL       __aeabi_fmul
   \      0x312   0x4601             MOV      R1,R0
   \      0x314   0x4620             MOV      R0,R4
   \      0x316   0x.... 0x....      BL       __aeabi_fsub
   \      0x31A   0x9901             LDR      R1,[SP, #+4]
   \      0x31C   0x.... 0x....      BL       __aeabi_fdiv
   \      0x320   0x4682             MOV      R10,R0
  12308                    Znew = sqrt(delta_diagonal_rod_2_tower[A_AXIS] - HYPOT2(Xnew, Ynew));
   \      0x322   0x9E00             LDR      R6,[SP, #+0]
   \      0x324   0x2402             MOVS     R4,#+2
   \      0x326   0xF04F 0x5B7E      MOV      R11,#+1065353216
   \      0x32A   0x465D             MOV      R5,R11
   \      0x32C   0xE004             B.N      ??forward_kinematics_DELTA_27
   \                     ??forward_kinematics_DELTA_28: (+1)
   \      0x32E   0x4630             MOV      R0,R6
   \      0x330   0x4631             MOV      R1,R6
   \      0x332   0x.... 0x....      BL       __aeabi_fmul
   \      0x336   0x4606             MOV      R6,R0
   \                     ??forward_kinematics_DELTA_27: (+1)
   \      0x338   0x07E0             LSLS     R0,R4,#+31
   \      0x33A   0xD504             BPL.N    ??forward_kinematics_DELTA_29
   \      0x33C   0x4628             MOV      R0,R5
   \      0x33E   0x4631             MOV      R1,R6
   \      0x340   0x.... 0x....      BL       __aeabi_fmul
   \      0x344   0x4605             MOV      R5,R0
   \                     ??forward_kinematics_DELTA_29: (+1)
   \      0x346   0x0864             LSRS     R4,R4,#+1
   \      0x348   0xD1F1             BNE.N    ??forward_kinematics_DELTA_28
   \      0x34A   0x4656             MOV      R6,R10
   \      0x34C   0x2402             MOVS     R4,#+2
   \      0x34E   0xE004             B.N      ??forward_kinematics_DELTA_30
   \                     ??forward_kinematics_DELTA_31: (+1)
   \      0x350   0x4630             MOV      R0,R6
   \      0x352   0x4631             MOV      R1,R6
   \      0x354   0x.... 0x....      BL       __aeabi_fmul
   \      0x358   0x4606             MOV      R6,R0
   \                     ??forward_kinematics_DELTA_30: (+1)
   \      0x35A   0x07E0             LSLS     R0,R4,#+31
   \      0x35C   0xD504             BPL.N    ??forward_kinematics_DELTA_32
   \      0x35E   0x4658             MOV      R0,R11
   \      0x360   0x4631             MOV      R1,R6
   \      0x362   0x.... 0x....      BL       __aeabi_fmul
   \      0x366   0x4683             MOV      R11,R0
   \                     ??forward_kinematics_DELTA_32: (+1)
   \      0x368   0x0864             LSRS     R4,R4,#+1
   \      0x36A   0xD1F1             BNE.N    ??forward_kinematics_DELTA_31
   \      0x36C   0x4628             MOV      R0,R5
   \      0x36E   0x4659             MOV      R1,R11
   \      0x370   0x.... 0x....      BL       __aeabi_fadd
   \      0x374   0x4601             MOV      R1,R0
   \      0x376   0x69F8             LDR      R0,[R7, #+28]
   \      0x378   0x.... 0x....      BL       __aeabi_fsub
   \      0x37C   0x.... 0x....      BL       sqrtf
   \      0x380   0x4604             MOV      R4,R0
  12309          
  12310              // Start from the origin of the old coordinates and add vectors in the
  12311              // old coords that represent the Xnew, Ynew and Znew to find the point
  12312              // in the old system.
  12313              cartes[X_AXIS] = delta_tower[A_AXIS][X_AXIS] + ex[0] * Xnew + ey[0] * Ynew - ez[0] * Znew;
   \      0x382   0x9904             LDR      R1,[SP, #+16]
   \      0x384   0x9800             LDR      R0,[SP, #+0]
   \      0x386   0x.... 0x....      BL       __aeabi_fmul
   \      0x38A   0x6879             LDR      R1,[R7, #+4]
   \      0x38C   0x.... 0x....      BL       __aeabi_fadd
   \      0x390   0x4605             MOV      R5,R0
   \      0x392   0x9805             LDR      R0,[SP, #+20]
   \      0x394   0x4651             MOV      R1,R10
   \      0x396   0x.... 0x....      BL       __aeabi_fmul
   \      0x39A   0x4629             MOV      R1,R5
   \      0x39C   0x.... 0x....      BL       __aeabi_fadd
   \      0x3A0   0x4605             MOV      R5,R0
   \      0x3A2   0x9808             LDR      R0,[SP, #+32]
   \      0x3A4   0x4621             MOV      R1,R4
   \      0x3A6   0x.... 0x....      BL       __aeabi_fmul
   \      0x3AA   0x4601             MOV      R1,R0
   \      0x3AC   0x4628             MOV      R0,R5
   \      0x3AE   0x.... 0x....      BL       __aeabi_fsub
   \      0x3B2   0x62B8             STR      R0,[R7, #+40]
  12314              cartes[Y_AXIS] = delta_tower[A_AXIS][Y_AXIS] + ex[1] * Xnew + ey[1] * Ynew - ez[1] * Znew;
   \      0x3B4   0x9903             LDR      R1,[SP, #+12]
   \      0x3B6   0x9800             LDR      R0,[SP, #+0]
   \      0x3B8   0x.... 0x....      BL       __aeabi_fmul
   \      0x3BC   0x68B9             LDR      R1,[R7, #+8]
   \      0x3BE   0x.... 0x....      BL       __aeabi_fadd
   \      0x3C2   0x4605             MOV      R5,R0
   \      0x3C4   0x4640             MOV      R0,R8
   \      0x3C6   0x4651             MOV      R1,R10
   \      0x3C8   0x.... 0x....      BL       __aeabi_fmul
   \      0x3CC   0x4629             MOV      R1,R5
   \      0x3CE   0x.... 0x....      BL       __aeabi_fadd
   \      0x3D2   0x4605             MOV      R5,R0
   \      0x3D4   0x9807             LDR      R0,[SP, #+28]
   \      0x3D6   0x4621             MOV      R1,R4
   \      0x3D8   0x.... 0x....      BL       __aeabi_fmul
   \      0x3DC   0x4601             MOV      R1,R0
   \      0x3DE   0x4628             MOV      R0,R5
   \      0x3E0   0x.... 0x....      BL       __aeabi_fsub
   \      0x3E4   0x62F8             STR      R0,[R7, #+44]
  12315              cartes[Z_AXIS] =             z1 + ex[2] * Xnew + ey[2] * Ynew - ez[2] * Znew;
   \      0x3E6   0x9902             LDR      R1,[SP, #+8]
   \      0x3E8   0x9800             LDR      R0,[SP, #+0]
   \      0x3EA   0x.... 0x....      BL       __aeabi_fmul
   \      0x3EE   0x990A             LDR      R1,[SP, #+40]
   \      0x3F0   0x.... 0x....      BL       __aeabi_fadd
   \      0x3F4   0x4605             MOV      R5,R0
   \      0x3F6   0x4648             MOV      R0,R9
   \      0x3F8   0x4651             MOV      R1,R10
   \      0x3FA   0x.... 0x....      BL       __aeabi_fmul
   \      0x3FE   0x4629             MOV      R1,R5
   \      0x400   0x.... 0x....      BL       __aeabi_fadd
   \      0x404   0x4605             MOV      R5,R0
   \      0x406   0x9806             LDR      R0,[SP, #+24]
   \      0x408   0x4621             MOV      R1,R4
   \      0x40A   0x.... 0x....      BL       __aeabi_fmul
   \      0x40E   0x4601             MOV      R1,R0
   \      0x410   0x4628             MOV      R0,R5
   \      0x412   0x.... 0x....      BL       __aeabi_fsub
   \      0x416   0x6338             STR      R0,[R7, #+48]
  12316            }
   \      0x418   0xB00B             ADD      SP,SP,#+44
   \      0x41A   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
  12317          

   \                                 In section .text, align 2, keep-with-next
  12318            void forward_kinematics_DELTA(float point[ABC]) {
  12319              forward_kinematics_DELTA(point[A_AXIS], point[B_AXIS], point[C_AXIS]);
   \                     _Z24forward_kinematics_DELTAPf: (+1)
   \        0x0   0x6882             LDR      R2,[R0, #+8]
   \        0x2   0x6841             LDR      R1,[R0, #+4]
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x....             B.N      _Z24forward_kinematics_DELTAfff
  12320            }
  12321          
  12322          #endif // DELTA
  12323          
  12324          /**
  12325           * Get the stepper positions in the cartes[] array.
  12326           * Forward kinematics are applied for DELTA and SCARA.
  12327           *
  12328           * The result is in the current coordinate space with
  12329           * leveling applied. The coordinates need to be run through
  12330           * unapply_leveling to obtain the "ideal" coordinates
  12331           * suitable for current_position, etc.
  12332           */

   \                                 In section .text, align 2, keep-with-next
  12333          void get_cartesian_from_steppers() {
   \                     _Z27get_cartesian_from_steppersv: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
  12334           // #if ENABLED(DELTA)
  12335            if(MACHINETPYE == DELTA)  {
   \        0x2   0x....             LDR.N    R0,??DataTable145
   \        0x4   0xF9B0 0x0058      LDRSH    R0,[R0, #+88]
   \        0x8   0x.... 0x....      LDR.W    R4,??DataTable148_1
   \        0xC   0x2802             CMP      R0,#+2
   \        0xE   0xD120             BNE.N    ??get_cartesian_from_steppers_0
  12336              forward_kinematics_DELTA(
  12337                stepper.get_axis_position_mm(A_AXIS),
  12338                stepper.get_axis_position_mm(B_AXIS),
  12339                stepper.get_axis_position_mm(C_AXIS)
  12340              );
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0x.... 0x....      BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
   \       0x16   0x4605             MOV      R5,R0
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0x.... 0x....      BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
   \       0x1E   0x4606             MOV      R6,R0
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x.... 0x....      BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
   \       0x26   0x462A             MOV      R2,R5
   \       0x28   0x4631             MOV      R1,R6
   \       0x2A   0x.... 0x....      BL       _Z24forward_kinematics_DELTAfff
  12341              cartes[X_AXIS] += LOGICAL_X_POSITION(0);
   \       0x2E   0x.... 0x....      LDR.W    R5,??DataTable157
   \       0x32   0x6AA1             LDR      R1,[R4, #+40]
   \       0x34   0x6C68             LDR      R0,[R5, #+68]
   \       0x36   0x.... 0x....      BL       __aeabi_fadd
   \       0x3A   0x62A0             STR      R0,[R4, #+40]
  12342              cartes[Y_AXIS] += LOGICAL_Y_POSITION(0);
   \       0x3C   0x6AE1             LDR      R1,[R4, #+44]
   \       0x3E   0x6CA8             LDR      R0,[R5, #+72]
   \       0x40   0x.... 0x....      BL       __aeabi_fadd
   \       0x44   0x62E0             STR      R0,[R4, #+44]
  12343              cartes[Z_AXIS] += LOGICAL_Z_POSITION(0); }
   \       0x46   0x6B21             LDR      R1,[R4, #+48]
   \       0x48   0x6CE8             LDR      R0,[R5, #+76]
   \       0x4A   0x.... 0x....      BL       __aeabi_fadd
   \       0x4E   0x6320             STR      R0,[R4, #+48]
   \       0x50   0xBD73             POP      {R0,R1,R4-R6,PC}
  12344          //  #elif IS_SCARA
  12345            else if(MACHINETPYE&IS_SCARA) {
   \                     ??get_cartesian_from_steppers_0: (+1)
   \       0x52   0xF410 0x7F40      TST      R0,#0x300
   \       0x56   0xD01C             BEQ.N    ??get_cartesian_from_steppers_1
  12346              forward_kinematics_SCARA(
  12347                stepper.get_axis_position_degrees(A_AXIS),
  12348                stepper.get_axis_position_degrees(B_AXIS)
  12349              );
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0x.... 0x....      BL       _ZN7Stepper25get_axis_position_degreesE8AxisEnum
   \       0x5E   0x9000             STR      R0,[SP, #+0]
   \       0x60   0x2001             MOVS     R0,#+1
   \       0x62   0x.... 0x....      BL       _ZN7Stepper25get_axis_position_degreesE8AxisEnum
   \       0x66   0x9001             STR      R0,[SP, #+4]
   \       0x68   0xA901             ADD      R1,SP,#+4
   \       0x6A   0x4668             MOV      R0,SP
   \       0x6C   0x.... 0x....      BL       _Z24forward_kinematics_SCARARKfS0_
  12350              cartes[X_AXIS] += LOGICAL_X_POSITION(0);
   \       0x70   0x.... 0x....      LDR.W    R5,??DataTable157
   \       0x74   0x6AA1             LDR      R1,[R4, #+40]
   \       0x76   0x6C68             LDR      R0,[R5, #+68]
   \       0x78   0x.... 0x....      BL       __aeabi_fadd
   \       0x7C   0x62A0             STR      R0,[R4, #+40]
  12351              cartes[Y_AXIS] += LOGICAL_Y_POSITION(0);
   \       0x7E   0x6AE1             LDR      R1,[R4, #+44]
   \       0x80   0x6CA8             LDR      R0,[R5, #+72]
   \       0x82   0x.... 0x....      BL       __aeabi_fadd
   \       0x86   0x62E0             STR      R0,[R4, #+44]
  12352              cartes[Z_AXIS] = stepper.get_axis_position_mm(Z_AXIS);  }
   \       0x88   0x2002             MOVS     R0,#+2
   \       0x8A   0x.... 0x....      BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
   \       0x8E   0x6320             STR      R0,[R4, #+48]
   \       0x90   0xBD73             POP      {R0,R1,R4-R6,PC}
  12353            //#else
  12354            else {
  12355              cartes[X_AXIS] = stepper.get_axis_position_mm(X_AXIS);
   \                     ??get_cartesian_from_steppers_1: (+1)
   \       0x92   0x2000             MOVS     R0,#+0
   \       0x94   0x.... 0x....      BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
   \       0x98   0x62A0             STR      R0,[R4, #+40]
  12356              cartes[Y_AXIS] = stepper.get_axis_position_mm(Y_AXIS);
   \       0x9A   0x2001             MOVS     R0,#+1
   \       0x9C   0x.... 0x....      BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
   \       0xA0   0x62E0             STR      R0,[R4, #+44]
  12357              cartes[Z_AXIS] = stepper.get_axis_position_mm(Z_AXIS);  }
   \       0xA2   0x2002             MOVS     R0,#+2
   \       0xA4   0x.... 0x....      BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
   \       0xA8   0x6320             STR      R0,[R4, #+48]
  12358           // #endif
  12359          }
   \       0xAA   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
  12360          
  12361          /**
  12362           * Set the current_position for an axis based on
  12363           * the stepper positions, removing any leveling that
  12364           * may have been applied.
  12365           */

   \                                 In section .text, align 2, keep-with-next
  12366          void set_current_from_steppers_for_axis(const AxisEnum axis) {
   \                     _Z34set_current_from_steppers_for_axis8AxisEnum: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
  12367            get_cartesian_from_steppers();
   \        0x4   0x.... 0x....      BL       _Z27get_cartesian_from_steppersv
  12368            //#if PLANNER_LEVELING
  12369            if(BED_LEVELING_METHOD&PLANNER_LEVELING)
   \        0x8   0x.... 0x....      LDR.W    R5,??DataTable148_1
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable153
   \       0x10   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \       0x14   0xF010 0x0F2E      TST      R0,#0x2E
   \       0x18   0xD003             BEQ.N    ??set_current_from_steppers_for_axis_0
  12370              planner.unapply_leveling(cartes);
   \       0x1A   0xF105 0x0028      ADD      R0,R5,#+40
   \       0x1E   0x.... 0x....      BL       _ZN7Planner16unapply_levelingEPf
  12371            //#endif
  12372            if (axis == ALL_AXES)
   \                     ??set_current_from_steppers_for_axis_0: (+1)
   \       0x22   0x.... 0x....      LDR.W    R0,??DataTable157
   \       0x26   0x4621             MOV      R1,R4
   \       0x28   0x2964             CMP      R1,#+100
   \       0x2A   0xD107             BNE.N    ??set_current_from_steppers_for_axis_1
  12373              COPY(current_position, cartes);
   \       0x2C   0x220C             MOVS     R2,#+12
   \       0x2E   0xF105 0x0128      ADD      R1,R5,#+40
   \       0x32   0x3008             ADDS     R0,R0,#+8
   \       0x34   0xE8BD 0x4038      POP      {R3-R5,LR}
   \       0x38   0x.... 0x....      B.W      __aeabi_memcpy
  12374            else
  12375              current_position[axis] = cartes[axis];
   \                     ??set_current_from_steppers_for_axis_1: (+1)
   \       0x3C   0xF105 0x0128      ADD      R1,R5,#+40
   \       0x40   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \       0x44   0x3008             ADDS     R0,R0,#+8
   \       0x46   0xF840 0x1024      STR      R1,[R0, R4, LSL #+2]
  12376          }
   \       0x4A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
  12377          
  12378          //#if ENABLED(MESH_BED_LEVELING)
  12379          #if 1	/*--mks cfg-- MESH_BED_LEVELING */
  12380            /**
  12381             * Prepare a mesh-leveled linear move in a Cartesian setup,
  12382             * splitting the move where it crosses mesh borders.
  12383             */

   \                                 In section .text, align 2, keep-with-next
  12384            void mesh_line_to_destination(float fr_mm_s, uint8_t x_splits = 0xFF, uint8_t y_splits = 0xFF) {
   \                     _Z24mesh_line_to_destinationfhh: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB085             SUB      SP,SP,#+20
   \        0x6   0x4682             MOV      R10,R0
   \        0x8   0x460D             MOV      R5,R1
   \        0xA   0x4616             MOV      R6,R2
  12385              int cx1 = mbl.cell_index_x(RAW_CURRENT_POSITION(X)),
   \        0xC   0x.... 0x....      LDR.W    R4,??DataTable157
   \       0x10   0x68A0             LDR      R0,[R4, #+8]
   \       0x12   0x6C61             LDR      R1,[R4, #+68]
   \       0x14   0x.... 0x....      BL       __aeabi_fsub
   \       0x18   0x9000             STR      R0,[SP, #+0]
   \       0x1A   0x4668             MOV      R0,SP
   \       0x1C   0x.... 0x....      BL       _ZN17mesh_bed_leveling12cell_index_xERKf
   \       0x20   0x4607             MOV      R7,R0
  12386                  cy1 = mbl.cell_index_y(RAW_CURRENT_POSITION(Y)),
   \       0x22   0x68E0             LDR      R0,[R4, #+12]
   \       0x24   0x6CA1             LDR      R1,[R4, #+72]
   \       0x26   0x.... 0x....      BL       __aeabi_fsub
   \       0x2A   0x9000             STR      R0,[SP, #+0]
   \       0x2C   0x4668             MOV      R0,SP
   \       0x2E   0x.... 0x....      BL       _ZN17mesh_bed_leveling12cell_index_yERKf
   \       0x32   0x4680             MOV      R8,R0
  12387                  cx2 = mbl.cell_index_x(RAW_X_POSITION(destination[X_AXIS])),
   \       0x34   0x69A0             LDR      R0,[R4, #+24]
   \       0x36   0x6C61             LDR      R1,[R4, #+68]
   \       0x38   0x.... 0x....      BL       __aeabi_fsub
   \       0x3C   0x9000             STR      R0,[SP, #+0]
   \       0x3E   0x4668             MOV      R0,SP
   \       0x40   0x.... 0x....      BL       _ZN17mesh_bed_leveling12cell_index_xERKf
   \       0x44   0x4681             MOV      R9,R0
  12388                  cy2 = mbl.cell_index_y(RAW_Y_POSITION(destination[Y_AXIS]));
   \       0x46   0x69E0             LDR      R0,[R4, #+28]
   \       0x48   0x6CA1             LDR      R1,[R4, #+72]
   \       0x4A   0x.... 0x....      BL       __aeabi_fsub
   \       0x4E   0x9000             STR      R0,[SP, #+0]
   \       0x50   0x4668             MOV      R0,SP
   \       0x52   0x.... 0x....      BL       _ZN17mesh_bed_leveling12cell_index_yERKf
   \       0x56   0x4601             MOV      R1,R0
  12389              NOMORE(cx1, GRID_MAX_POINTS_X - 2);
   \       0x58   0x....             LDR.N    R0,??DataTable147_3
   \       0x5A   0x7802             LDRB     R2,[R0, #+0]
   \       0x5C   0x1E92             SUBS     R2,R2,#+2
   \       0x5E   0x42BA             CMP      R2,R7
   \       0x60   0xDA00             BGE.N    ??mesh_line_to_destination_0
   \       0x62   0x4617             MOV      R7,R2
  12390              NOMORE(cy1, GRID_MAX_POINTS_Y - 2);
   \                     ??mesh_line_to_destination_0: (+1)
   \       0x64   0x7840             LDRB     R0,[R0, #+1]
   \       0x66   0x1E80             SUBS     R0,R0,#+2
   \       0x68   0x4540             CMP      R0,R8
   \       0x6A   0xDA00             BGE.N    ??mesh_line_to_destination_1
   \       0x6C   0x4680             MOV      R8,R0
  12391              NOMORE(cx2, GRID_MAX_POINTS_X - 2);
   \                     ??mesh_line_to_destination_1: (+1)
   \       0x6E   0x454A             CMP      R2,R9
   \       0x70   0xDA00             BGE.N    ??mesh_line_to_destination_2
   \       0x72   0x4691             MOV      R9,R2
  12392              NOMORE(cy2, GRID_MAX_POINTS_Y - 2);
   \                     ??mesh_line_to_destination_2: (+1)
   \       0x74   0x4288             CMP      R0,R1
   \       0x76   0xDA00             BGE.N    ??mesh_line_to_destination_3
   \       0x78   0x4601             MOV      R1,R0
   \                     ??mesh_line_to_destination_3: (+1)
   \       0x7A   0xF8CD 0xA000      STR      R10,[SP, #+0]
  12393          
  12394              if (cx1 == cx2 && cy1 == cy2) {
   \       0x7E   0x454F             CMP      R7,R9
   \       0x80   0xD102             BNE.N    ??mesh_line_to_destination_4
   \       0x82   0x4588             CMP      R8,R1
   \       0x84   0xF000 0x80A2      BEQ.W    ??mesh_line_to_destination_5
  12395                // Start and end on same mesh square
  12396                line_to_destination(fr_mm_s);
  12397                set_current_to_destination();
  12398                return;
  12399              }
  12400          
  12401              #define MBL_SEGMENT_END(A) (current_position[A ##_AXIS] + (destination[A ##_AXIS] - current_position[A ##_AXIS]) * normalized_dist)
  12402          
  12403              float normalized_dist, end[XYZE];
  12404          
  12405              // Split at the left/front border of the right/top square
  12406              const int8_t gcx = max(cx1, cx2), gcy = max(cy1, cy2);
   \                     ??mesh_line_to_destination_4: (+1)
   \       0x88   0x46BA             MOV      R10,R7
   \       0x8A   0x454F             CMP      R7,R9
   \       0x8C   0xDA00             BGE.N    ??mesh_line_to_destination_6
   \       0x8E   0x46CA             MOV      R10,R9
   \                     ??mesh_line_to_destination_6: (+1)
   \       0x90   0x46C3             MOV      R11,R8
   \       0x92   0x4588             CMP      R8,R1
   \       0x94   0xDA00             BGE.N    ??mesh_line_to_destination_7
   \       0x96   0x468B             MOV      R11,R1
  12407              if (cx2 != cx1 && TEST(x_splits, gcx)) {
   \                     ??mesh_line_to_destination_7: (+1)
   \       0x98   0x45B9             CMP      R9,R7
   \       0x9A   0xD05F             BEQ.N    ??mesh_line_to_destination_8
   \       0x9C   0x2701             MOVS     R7,#+1
   \       0x9E   0xFA07 0xF70A      LSL      R7,R7,R10
   \       0xA2   0x4628             MOV      R0,R5
   \       0xA4   0x4238             TST      R0,R7
   \       0xA6   0xD059             BEQ.N    ??mesh_line_to_destination_8
  12408                COPY(end, destination);
   \       0xA8   0x2210             MOVS     R2,#+16
   \       0xAA   0xF104 0x0118      ADD      R1,R4,#+24
   \       0xAE   0xA801             ADD      R0,SP,#+4
   \       0xB0   0x.... 0x....      BL       __aeabi_memcpy
  12409                destination[X_AXIS] = LOGICAL_X_POSITION(mbl.index_to_xpos[gcx]);
   \       0xB4   0x.... 0x....      LDR.W    R0,??DataTable158
   \       0xB8   0xFA4F 0xFA8A      SXTB     R10,R10
   \       0xBC   0xF850 0x102A      LDR      R1,[R0, R10, LSL #+2]
   \       0xC0   0x6C60             LDR      R0,[R4, #+68]
   \       0xC2   0x.... 0x....      BL       __aeabi_fadd
   \       0xC6   0x61A0             STR      R0,[R4, #+24]
  12410                normalized_dist = (destination[X_AXIS] - current_position[X_AXIS]) / (end[X_AXIS] - current_position[X_AXIS]);
   \       0xC8   0x4621             MOV      R1,R4
   \       0xCA   0xF8D1 0x8008      LDR      R8,[R1, #+8]
   \       0xCE   0x4641             MOV      R1,R8
   \       0xD0   0x.... 0x....      BL       __aeabi_fsub
   \       0xD4   0x4681             MOV      R9,R0
   \       0xD6   0x9801             LDR      R0,[SP, #+4]
   \       0xD8   0x4641             MOV      R1,R8
   \       0xDA   0x.... 0x....      BL       __aeabi_fsub
   \       0xDE   0x4601             MOV      R1,R0
   \       0xE0   0x4648             MOV      R0,R9
   \       0xE2   0x.... 0x....      BL       __aeabi_fdiv
   \       0xE6   0x4680             MOV      R8,R0
  12411                destination[Y_AXIS] = MBL_SEGMENT_END(Y);
   \       0xE8   0x4620             MOV      R0,R4
   \       0xEA   0xF8D0 0x900C      LDR      R9,[R0, #+12]
   \       0xEE   0x69E0             LDR      R0,[R4, #+28]
   \       0xF0   0x4649             MOV      R1,R9
   \       0xF2   0x.... 0x....      BL       __aeabi_fsub
   \       0xF6   0x4641             MOV      R1,R8
   \       0xF8   0x.... 0x....      BL       __aeabi_fmul
   \       0xFC   0x4649             MOV      R1,R9
   \       0xFE   0x.... 0x....      BL       __aeabi_fadd
   \      0x102   0x61E0             STR      R0,[R4, #+28]
  12412                CBI(x_splits, gcx);
   \      0x104   0x43BD             BICS     R5,R5,R7
  12413              }
  12414              else if (cy2 != cy1 && TEST(y_splits, gcy)) {
  12415                COPY(end, destination);
  12416                destination[Y_AXIS] = LOGICAL_Y_POSITION(mbl.index_to_ypos[gcy]);
  12417                normalized_dist = (destination[Y_AXIS] - current_position[Y_AXIS]) / (end[Y_AXIS] - current_position[Y_AXIS]);
  12418                destination[X_AXIS] = MBL_SEGMENT_END(X);
  12419                CBI(y_splits, gcy);
  12420              }
  12421              else {
  12422                // Already split on a border
  12423                line_to_destination(fr_mm_s);
  12424                set_current_to_destination();
  12425                return;
  12426              }
  12427          
  12428              destination[Z_AXIS] = MBL_SEGMENT_END(Z);
   \                     ??mesh_line_to_destination_9: (+1)
   \      0x106   0x6927             LDR      R7,[R4, #+16]
   \      0x108   0x6A20             LDR      R0,[R4, #+32]
   \      0x10A   0x4639             MOV      R1,R7
   \      0x10C   0x.... 0x....      BL       __aeabi_fsub
   \      0x110   0x4641             MOV      R1,R8
   \      0x112   0x.... 0x....      BL       __aeabi_fmul
   \      0x116   0x4639             MOV      R1,R7
   \      0x118   0x.... 0x....      BL       __aeabi_fadd
   \      0x11C   0x6220             STR      R0,[R4, #+32]
  12429              destination[E_AXIS] = MBL_SEGMENT_END(E);
   \      0x11E   0x6967             LDR      R7,[R4, #+20]
   \      0x120   0x6A60             LDR      R0,[R4, #+36]
   \      0x122   0x4639             MOV      R1,R7
   \      0x124   0x.... 0x....      BL       __aeabi_fsub
   \      0x128   0x4641             MOV      R1,R8
   \      0x12A   0x.... 0x....      BL       __aeabi_fmul
   \      0x12E   0x4639             MOV      R1,R7
   \      0x130   0x.... 0x....      BL       __aeabi_fadd
   \      0x134   0x6260             STR      R0,[R4, #+36]
  12430          
  12431              // Do the split and look for more borders
  12432              mesh_line_to_destination(fr_mm_s, x_splits, y_splits);
   \      0x136   0x4632             MOV      R2,R6
   \      0x138   0x4629             MOV      R1,R5
   \      0x13A   0x9800             LDR      R0,[SP, #+0]
   \      0x13C   0xF7FF 0xFF60      BL       _Z24mesh_line_to_destinationfhh
  12433          
  12434              // Restore destination from stack
  12435              COPY(destination, end);
   \      0x140   0x2210             MOVS     R2,#+16
   \      0x142   0xA901             ADD      R1,SP,#+4
   \      0x144   0xF104 0x0018      ADD      R0,R4,#+24
   \      0x148   0x.... 0x....      BL       __aeabi_memcpy
  12436              mesh_line_to_destination(fr_mm_s, x_splits, y_splits);
   \      0x14C   0x4632             MOV      R2,R6
   \      0x14E   0x4629             MOV      R1,R5
   \      0x150   0x9800             LDR      R0,[SP, #+0]
   \      0x152   0xF7FF 0xFF55      BL       _Z24mesh_line_to_destinationfhh
  12437            }
   \                     ??mesh_line_to_destination_10: (+1)
   \      0x156   0xB005             ADD      SP,SP,#+20
   \      0x158   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \                     ??mesh_line_to_destination_8: (+1)
   \      0x15C   0x4541             CMP      R1,R8
   \      0x15E   0xD035             BEQ.N    ??mesh_line_to_destination_5
   \      0x160   0x2701             MOVS     R7,#+1
   \      0x162   0xFA07 0xF70B      LSL      R7,R7,R11
   \      0x166   0x4630             MOV      R0,R6
   \      0x168   0x4238             TST      R0,R7
   \      0x16A   0xD02F             BEQ.N    ??mesh_line_to_destination_5
   \      0x16C   0x2210             MOVS     R2,#+16
   \      0x16E   0xF104 0x0118      ADD      R1,R4,#+24
   \      0x172   0xA801             ADD      R0,SP,#+4
   \      0x174   0x.... 0x....      BL       __aeabi_memcpy
   \      0x178   0x.... 0x....      LDR.W    R0,??DataTable163
   \      0x17C   0xFA4F 0xFB8B      SXTB     R11,R11
   \      0x180   0xF850 0x102B      LDR      R1,[R0, R11, LSL #+2]
   \      0x184   0x6CA0             LDR      R0,[R4, #+72]
   \      0x186   0x.... 0x....      BL       __aeabi_fadd
   \      0x18A   0x61E0             STR      R0,[R4, #+28]
   \      0x18C   0x4621             MOV      R1,R4
   \      0x18E   0xF8D1 0x800C      LDR      R8,[R1, #+12]
   \      0x192   0x4641             MOV      R1,R8
   \      0x194   0x.... 0x....      BL       __aeabi_fsub
   \      0x198   0x4681             MOV      R9,R0
   \      0x19A   0x9802             LDR      R0,[SP, #+8]
   \      0x19C   0x4641             MOV      R1,R8
   \      0x19E   0x.... 0x....      BL       __aeabi_fsub
   \      0x1A2   0x4601             MOV      R1,R0
   \      0x1A4   0x4648             MOV      R0,R9
   \      0x1A6   0x.... 0x....      BL       __aeabi_fdiv
   \      0x1AA   0x4680             MOV      R8,R0
   \      0x1AC   0x4620             MOV      R0,R4
   \      0x1AE   0xF8D0 0x9008      LDR      R9,[R0, #+8]
   \      0x1B2   0x69A0             LDR      R0,[R4, #+24]
   \      0x1B4   0x4649             MOV      R1,R9
   \      0x1B6   0x.... 0x....      BL       __aeabi_fsub
   \      0x1BA   0x4641             MOV      R1,R8
   \      0x1BC   0x.... 0x....      BL       __aeabi_fmul
   \      0x1C0   0x4649             MOV      R1,R9
   \      0x1C2   0x.... 0x....      BL       __aeabi_fadd
   \      0x1C6   0x61A0             STR      R0,[R4, #+24]
   \      0x1C8   0x43BE             BICS     R6,R6,R7
   \      0x1CA   0xE79C             B.N      ??mesh_line_to_destination_9
   \                     ??mesh_line_to_destination_5: (+1)
   \      0x1CC   0x9800             LDR      R0,[SP, #+0]
   \      0x1CE   0x.... 0x....      BL       _Z19line_to_destinationf
   \      0x1D2   0x.... 0x....      BL       _Z26set_current_to_destinationv
   \      0x1D6   0xE7BE             B.N      ??mesh_line_to_destination_10
  12438          
  12439          /*--mks cfg-- AUTO_BED_LEVELING_BILINEAR */
  12440          #endif
  12441          //#elif ENABLED(AUTO_BED_LEVELING_BILINEAR) && !IS_KINEMATIC
  12442          //#if(!IS_KINEMATIC)	//mks_delta
  12443          #if 1
  12444            #define CELL_INDEX(A,V) ((RAW_##A##_POSITION(V) - bilinear_start[A##_AXIS]) * ABL_BG_FACTOR(A##_AXIS))
  12445          
  12446            /**
  12447             * Prepare a bilinear-leveled linear move on Cartesian,
  12448             * splitting the move where it crosses grid borders.
  12449             */

   \                                 In section .text, align 2, keep-with-next
  12450            void bilinear_line_to_destination(float fr_mm_s, uint16_t x_splits = 0xFFFF, uint16_t y_splits = 0xFFFF) {
   \                     _Z28bilinear_line_to_destinationftt: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB086             SUB      SP,SP,#+24
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x460D             MOV      R5,R1
   \        0xA   0x4616             MOV      R6,R2
  12451              int cx1 = CELL_INDEX(X, current_position[X_AXIS]),
                               ^
Warning[Pa093]: implicit conversion from floating point to integer
   \        0xC   0x.... 0x....      LDR.W    R7,??DataTable160
   \       0x10   0x6938             LDR      R0,[R7, #+16]
   \       0x12   0x.... 0x....      BL       __aeabi_i2f
   \       0x16   0x4682             MOV      R10,R0
   \       0x18   0x.... 0x....      LDR.W    R4,??DataTable157
   \       0x1C   0x68A0             LDR      R0,[R4, #+8]
   \       0x1E   0x6C61             LDR      R1,[R4, #+68]
   \       0x20   0x.... 0x....      BL       __aeabi_fsub
   \       0x24   0x4651             MOV      R1,R10
   \       0x26   0x.... 0x....      BL       __aeabi_fsub
   \       0x2A   0x69B9             LDR      R1,[R7, #+24]
   \       0x2C   0x.... 0x....      BL       __aeabi_fmul
   \       0x30   0x.... 0x....      BL       __aeabi_f2iz
   \       0x34   0x4680             MOV      R8,R0
  12452                  cy1 = CELL_INDEX(Y, current_position[Y_AXIS]),
                               ^
Warning[Pa093]: implicit conversion from floating point to integer
   \       0x36   0x6978             LDR      R0,[R7, #+20]
   \       0x38   0x.... 0x....      BL       __aeabi_i2f
   \       0x3C   0x9000             STR      R0,[SP, #+0]
   \       0x3E   0x68E0             LDR      R0,[R4, #+12]
   \       0x40   0x6CA1             LDR      R1,[R4, #+72]
   \       0x42   0x.... 0x....      BL       __aeabi_fsub
   \       0x46   0x9900             LDR      R1,[SP, #+0]
   \       0x48   0x.... 0x....      BL       __aeabi_fsub
   \       0x4C   0x69F9             LDR      R1,[R7, #+28]
   \       0x4E   0x.... 0x....      BL       __aeabi_fmul
   \       0x52   0x.... 0x....      BL       __aeabi_f2iz
   \       0x56   0x4681             MOV      R9,R0
  12453                  cx2 = CELL_INDEX(X, destination[X_AXIS]),
                               ^
Warning[Pa093]: implicit conversion from floating point to integer
   \       0x58   0x69A0             LDR      R0,[R4, #+24]
   \       0x5A   0x6C61             LDR      R1,[R4, #+68]
   \       0x5C   0x.... 0x....      BL       __aeabi_fsub
   \       0x60   0x4651             MOV      R1,R10
   \       0x62   0x.... 0x....      BL       __aeabi_fsub
   \       0x66   0x69B9             LDR      R1,[R7, #+24]
   \       0x68   0x.... 0x....      BL       __aeabi_fmul
   \       0x6C   0x.... 0x....      BL       __aeabi_f2iz
   \       0x70   0x4682             MOV      R10,R0
  12454                  cy2 = CELL_INDEX(Y, destination[Y_AXIS]);
                               ^
Warning[Pa093]: implicit conversion from floating point to integer
   \       0x72   0x69E0             LDR      R0,[R4, #+28]
   \       0x74   0x6CA1             LDR      R1,[R4, #+72]
   \       0x76   0x.... 0x....      BL       __aeabi_fsub
   \       0x7A   0x9900             LDR      R1,[SP, #+0]
   \       0x7C   0x.... 0x....      BL       __aeabi_fsub
   \       0x80   0x69F9             LDR      R1,[R7, #+28]
   \       0x82   0x.... 0x....      BL       __aeabi_fmul
   \       0x86   0x.... 0x....      BL       __aeabi_f2iz
   \       0x8A   0x4601             MOV      R1,R0
  12455              cx1 = constrain(cx1, 0, ABL_BG_POINTS_X - 2);
   \       0x8C   0x.... 0x....      LDR.W    R0,??DataTable163_1
   \       0x90   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x94   0xD502             BPL.N    ??bilinear_line_to_destination_0
   \       0x96   0xF04F 0x0800      MOV      R8,#+0
   \       0x9A   0xE004             B.N      ??bilinear_line_to_destination_1
   \                     ??bilinear_line_to_destination_0: (+1)
   \       0x9C   0x7802             LDRB     R2,[R0, #+0]
   \       0x9E   0x1E92             SUBS     R2,R2,#+2
   \       0xA0   0x4542             CMP      R2,R8
   \       0xA2   0xDA00             BGE.N    ??bilinear_line_to_destination_1
   \       0xA4   0x4690             MOV      R8,R2
  12456              cy1 = constrain(cy1, 0, ABL_BG_POINTS_Y - 2);
   \                     ??bilinear_line_to_destination_1: (+1)
   \       0xA6   0xF1B9 0x0F00      CMP      R9,#+0
   \       0xAA   0xD502             BPL.N    ??bilinear_line_to_destination_2
   \       0xAC   0xF04F 0x0900      MOV      R9,#+0
   \       0xB0   0xE004             B.N      ??bilinear_line_to_destination_3
   \                     ??bilinear_line_to_destination_2: (+1)
   \       0xB2   0x7842             LDRB     R2,[R0, #+1]
   \       0xB4   0x1E92             SUBS     R2,R2,#+2
   \       0xB6   0x454A             CMP      R2,R9
   \       0xB8   0xDA00             BGE.N    ??bilinear_line_to_destination_3
   \       0xBA   0x4691             MOV      R9,R2
  12457              cx2 = constrain(cx2, 0, ABL_BG_POINTS_X - 2);
   \                     ??bilinear_line_to_destination_3: (+1)
   \       0xBC   0xF1BA 0x0F00      CMP      R10,#+0
   \       0xC0   0xD502             BPL.N    ??bilinear_line_to_destination_4
   \       0xC2   0xF04F 0x0A00      MOV      R10,#+0
   \       0xC6   0xE004             B.N      ??bilinear_line_to_destination_5
   \                     ??bilinear_line_to_destination_4: (+1)
   \       0xC8   0x7802             LDRB     R2,[R0, #+0]
   \       0xCA   0x1E92             SUBS     R2,R2,#+2
   \       0xCC   0x4552             CMP      R2,R10
   \       0xCE   0xDA00             BGE.N    ??bilinear_line_to_destination_5
   \       0xD0   0x4692             MOV      R10,R2
  12458              cy2 = constrain(cy2, 0, ABL_BG_POINTS_Y - 2);
   \                     ??bilinear_line_to_destination_5: (+1)
   \       0xD2   0x2900             CMP      R1,#+0
   \       0xD4   0xD501             BPL.N    ??bilinear_line_to_destination_6
   \       0xD6   0x2100             MOVS     R1,#+0
   \       0xD8   0xE004             B.N      ??bilinear_line_to_destination_7
   \                     ??bilinear_line_to_destination_6: (+1)
   \       0xDA   0x7840             LDRB     R0,[R0, #+1]
   \       0xDC   0x1E80             SUBS     R0,R0,#+2
   \       0xDE   0x4288             CMP      R0,R1
   \       0xE0   0xDA00             BGE.N    ??bilinear_line_to_destination_7
   \       0xE2   0x4601             MOV      R1,R0
   \                     ??bilinear_line_to_destination_7: (+1)
   \       0xE4   0xF8CD 0xB000      STR      R11,[SP, #+0]
  12459          
  12460              if (cx1 == cx2 && cy1 == cy2) {
   \       0xE8   0x45D0             CMP      R8,R10
   \       0xEA   0xD102             BNE.N    ??bilinear_line_to_destination_8
   \       0xEC   0x4589             CMP      R9,R1
   \       0xEE   0xF000 0x80B0      BEQ.W    ??bilinear_line_to_destination_9
  12461                // Start and end on same mesh square
  12462                line_to_destination(fr_mm_s);
  12463                set_current_to_destination();
  12464                return;
  12465              }
  12466          
  12467              #define LINE_SEGMENT_END(A) (current_position[A ##_AXIS] + (destination[A ##_AXIS] - current_position[A ##_AXIS]) * normalized_dist)
  12468          
  12469              float normalized_dist, end[XYZE];
  12470          
  12471              // Split at the left/front border of the right/top square
  12472              const int8_t gcx = max(cx1, cx2), gcy = max(cy1, cy2);
   \                     ??bilinear_line_to_destination_8: (+1)
   \       0xF2   0x4640             MOV      R0,R8
   \       0xF4   0x45D0             CMP      R8,R10
   \       0xF6   0xDA00             BGE.N    ??bilinear_line_to_destination_10
   \       0xF8   0x4650             MOV      R0,R10
   \                     ??bilinear_line_to_destination_10: (+1)
   \       0xFA   0x9001             STR      R0,[SP, #+4]
   \       0xFC   0x46CB             MOV      R11,R9
   \       0xFE   0x4589             CMP      R9,R1
   \      0x100   0xDA00             BGE.N    ??bilinear_line_to_destination_11
   \      0x102   0x468B             MOV      R11,R1
  12473              if (cx2 != cx1 && TEST(x_splits, gcx)) {
   \                     ??bilinear_line_to_destination_11: (+1)
   \      0x104   0x45C2             CMP      R10,R8
   \      0x106   0xD067             BEQ.N    ??bilinear_line_to_destination_12
   \      0x108   0x2001             MOVS     R0,#+1
   \      0x10A   0xF8DD 0x8004      LDR      R8,[SP, #+4]
   \      0x10E   0xFA00 0xF808      LSL      R8,R0,R8
   \      0x112   0x4628             MOV      R0,R5
   \      0x114   0xEA10 0x0F08      TST      R0,R8
   \      0x118   0xD05E             BEQ.N    ??bilinear_line_to_destination_12
  12474                COPY(end, destination);
   \      0x11A   0x2210             MOVS     R2,#+16
   \      0x11C   0xF104 0x0118      ADD      R1,R4,#+24
   \      0x120   0xA802             ADD      R0,SP,#+8
   \      0x122   0x.... 0x....      BL       __aeabi_memcpy
  12475                destination[X_AXIS] = LOGICAL_X_POSITION(bilinear_start[X_AXIS] + ABL_BG_SPACING(X_AXIS) * gcx);
   \      0x126   0x6938             LDR      R0,[R7, #+16]
   \      0x128   0x68BA             LDR      R2,[R7, #+8]
   \      0x12A   0xA901             ADD      R1,SP,#+4
   \      0x12C   0xF991 0x1000      LDRSB    R1,[R1, #+0]
   \      0x130   0xFB01 0x0002      MLA      R0,R1,R2,R0
   \      0x134   0x.... 0x....      BL       __aeabi_i2f
   \      0x138   0x6C61             LDR      R1,[R4, #+68]
   \      0x13A   0x.... 0x....      BL       __aeabi_fadd
   \      0x13E   0x61A0             STR      R0,[R4, #+24]
  12476                normalized_dist = (destination[X_AXIS] - current_position[X_AXIS]) / (end[X_AXIS] - current_position[X_AXIS]);
   \      0x140   0x4621             MOV      R1,R4
   \      0x142   0x688F             LDR      R7,[R1, #+8]
   \      0x144   0x4639             MOV      R1,R7
   \      0x146   0x.... 0x....      BL       __aeabi_fsub
   \      0x14A   0x4681             MOV      R9,R0
   \      0x14C   0x9802             LDR      R0,[SP, #+8]
   \      0x14E   0x4639             MOV      R1,R7
   \      0x150   0x.... 0x....      BL       __aeabi_fsub
   \      0x154   0x4601             MOV      R1,R0
   \      0x156   0x4648             MOV      R0,R9
   \      0x158   0x.... 0x....      BL       __aeabi_fdiv
   \      0x15C   0x4607             MOV      R7,R0
  12477                destination[Y_AXIS] = LINE_SEGMENT_END(Y);
   \      0x15E   0x4620             MOV      R0,R4
   \      0x160   0xF8D0 0x900C      LDR      R9,[R0, #+12]
   \      0x164   0x69E0             LDR      R0,[R4, #+28]
   \      0x166   0x4649             MOV      R1,R9
   \      0x168   0x.... 0x....      BL       __aeabi_fsub
   \      0x16C   0x4639             MOV      R1,R7
   \      0x16E   0x.... 0x....      BL       __aeabi_fmul
   \      0x172   0x4649             MOV      R1,R9
   \      0x174   0x.... 0x....      BL       __aeabi_fadd
   \      0x178   0x61E0             STR      R0,[R4, #+28]
  12478                CBI(x_splits, gcx);
   \      0x17A   0xEA25 0x0508      BIC      R5,R5,R8
  12479              }
  12480              else if (cy2 != cy1 && TEST(y_splits, gcy)) {
  12481                COPY(end, destination);
  12482                destination[Y_AXIS] = LOGICAL_Y_POSITION(bilinear_start[Y_AXIS] + ABL_BG_SPACING(Y_AXIS) * gcy);
  12483                normalized_dist = (destination[Y_AXIS] - current_position[Y_AXIS]) / (end[Y_AXIS] - current_position[Y_AXIS]);
  12484                destination[X_AXIS] = LINE_SEGMENT_END(X);
  12485                CBI(y_splits, gcy);
  12486              }
  12487              else {
  12488                // Already split on a border
  12489                line_to_destination(fr_mm_s);
  12490                set_current_to_destination();
  12491                return;
  12492              }
  12493          
  12494              destination[Z_AXIS] = LINE_SEGMENT_END(Z);
   \                     ??bilinear_line_to_destination_13: (+1)
   \      0x17E   0xF8D4 0x8010      LDR      R8,[R4, #+16]
   \      0x182   0x6A20             LDR      R0,[R4, #+32]
   \      0x184   0x4641             MOV      R1,R8
   \      0x186   0x.... 0x....      BL       __aeabi_fsub
   \      0x18A   0x4639             MOV      R1,R7
   \      0x18C   0x.... 0x....      BL       __aeabi_fmul
   \      0x190   0x4641             MOV      R1,R8
   \      0x192   0x.... 0x....      BL       __aeabi_fadd
   \      0x196   0x6220             STR      R0,[R4, #+32]
  12495              destination[E_AXIS] = LINE_SEGMENT_END(E);
   \      0x198   0xF8D4 0x8014      LDR      R8,[R4, #+20]
   \      0x19C   0x6A60             LDR      R0,[R4, #+36]
   \      0x19E   0x4641             MOV      R1,R8
   \      0x1A0   0x.... 0x....      BL       __aeabi_fsub
   \      0x1A4   0x4639             MOV      R1,R7
   \      0x1A6   0x.... 0x....      BL       __aeabi_fmul
   \      0x1AA   0x4641             MOV      R1,R8
   \      0x1AC   0x.... 0x....      BL       __aeabi_fadd
   \      0x1B0   0x6260             STR      R0,[R4, #+36]
  12496          
  12497              // Do the split and look for more borders
  12498              bilinear_line_to_destination(fr_mm_s, x_splits, y_splits);
   \      0x1B2   0x4632             MOV      R2,R6
   \      0x1B4   0x4629             MOV      R1,R5
   \      0x1B6   0x9800             LDR      R0,[SP, #+0]
   \      0x1B8   0xF7FF 0xFF22      BL       _Z28bilinear_line_to_destinationftt
  12499          
  12500              // Restore destination from stack
  12501              COPY(destination, end);
   \      0x1BC   0x2210             MOVS     R2,#+16
   \      0x1BE   0xA902             ADD      R1,SP,#+8
   \      0x1C0   0xF104 0x0018      ADD      R0,R4,#+24
   \      0x1C4   0x.... 0x....      BL       __aeabi_memcpy
  12502              bilinear_line_to_destination(fr_mm_s, x_splits, y_splits);
   \      0x1C8   0x4632             MOV      R2,R6
   \      0x1CA   0x4629             MOV      R1,R5
   \      0x1CC   0x9800             LDR      R0,[SP, #+0]
   \      0x1CE   0xF7FF 0xFF17      BL       _Z28bilinear_line_to_destinationftt
  12503            }
   \                     ??bilinear_line_to_destination_14: (+1)
   \      0x1D2   0xB007             ADD      SP,SP,#+28
   \      0x1D4   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \                     ??bilinear_line_to_destination_12: (+1)
   \      0x1D8   0x4549             CMP      R1,R9
   \      0x1DA   0xD03A             BEQ.N    ??bilinear_line_to_destination_9
   \      0x1DC   0xF04F 0x0801      MOV      R8,#+1
   \      0x1E0   0xFA08 0xF80B      LSL      R8,R8,R11
   \      0x1E4   0x4630             MOV      R0,R6
   \      0x1E6   0xEA10 0x0F08      TST      R0,R8
   \      0x1EA   0xD032             BEQ.N    ??bilinear_line_to_destination_9
   \      0x1EC   0x2210             MOVS     R2,#+16
   \      0x1EE   0xF104 0x0118      ADD      R1,R4,#+24
   \      0x1F2   0xA802             ADD      R0,SP,#+8
   \      0x1F4   0x.... 0x....      BL       __aeabi_memcpy
   \      0x1F8   0x6978             LDR      R0,[R7, #+20]
   \      0x1FA   0x68F9             LDR      R1,[R7, #+12]
   \      0x1FC   0xFA4F 0xFB8B      SXTB     R11,R11
   \      0x200   0xFB0B 0x0B01      MLA      R11,R11,R1,R0
   \      0x204   0x4658             MOV      R0,R11
   \      0x206   0x.... 0x....      BL       __aeabi_i2f
   \      0x20A   0x6CA1             LDR      R1,[R4, #+72]
   \      0x20C   0x.... 0x....      BL       __aeabi_fadd
   \      0x210   0x61E0             STR      R0,[R4, #+28]
   \      0x212   0x4621             MOV      R1,R4
   \      0x214   0x68CF             LDR      R7,[R1, #+12]
   \      0x216   0x4639             MOV      R1,R7
   \      0x218   0x.... 0x....      BL       __aeabi_fsub
   \      0x21C   0x4681             MOV      R9,R0
   \      0x21E   0x9803             LDR      R0,[SP, #+12]
   \      0x220   0x4639             MOV      R1,R7
   \      0x222   0x.... 0x....      BL       __aeabi_fsub
   \      0x226   0x4601             MOV      R1,R0
   \      0x228   0x4648             MOV      R0,R9
   \      0x22A   0x.... 0x....      BL       __aeabi_fdiv
   \      0x22E   0x4607             MOV      R7,R0
   \      0x230   0x4620             MOV      R0,R4
   \      0x232   0xF8D0 0x9008      LDR      R9,[R0, #+8]
   \      0x236   0x69A0             LDR      R0,[R4, #+24]
   \      0x238   0x4649             MOV      R1,R9
   \      0x23A   0x.... 0x....      BL       __aeabi_fsub
   \      0x23E   0x4639             MOV      R1,R7
   \      0x240   0x.... 0x....      BL       __aeabi_fmul
   \      0x244   0x4649             MOV      R1,R9
   \      0x246   0x.... 0x....      BL       __aeabi_fadd
   \      0x24A   0x61A0             STR      R0,[R4, #+24]
   \      0x24C   0xEA26 0x0608      BIC      R6,R6,R8
   \      0x250   0xE795             B.N      ??bilinear_line_to_destination_13
   \                     ??bilinear_line_to_destination_9: (+1)
   \      0x252   0x9800             LDR      R0,[SP, #+0]
   \      0x254   0x.... 0x....      BL       _Z19line_to_destinationf
   \      0x258   0x.... 0x....      BL       _Z26set_current_to_destinationv
   \      0x25C   0xE7B9             B.N      ??bilinear_line_to_destination_14
  12504          
  12505          #endif // AUTO_BED_LEVELING_BILINEAR
  12506          
  12507          //#if IS_KINEMATIC	//mks_delta
  12508          #if 1
  12509            /**
  12510             * Prepare a linear move in a DELTA or SCARA setup.
  12511             *
  12512             * This calls planner.buffer_line several times, adding
  12513             * small incremental moves for DELTA or SCARA.
  12514             */

   \                                 In section .text, align 4
  12515            inline bool prepare_kinematic_move_to(float ltarget[XYZE]) {
   \                     _Z25prepare_kinematic_move_toPf: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB095             SUB      SP,SP,#+84
   \        0x6   0x4604             MOV      R4,R0
  12516          
  12517              // Get the top feedrate of the move in the XY plane
  12518              float _feedrate_mm_s = MMS_SCALED(feedrate_mm_s);
   \        0x8   0xF8DF 0x54B0      LDR.W    R5,??prepare_kinematic_move_to_0
   \        0xC   0x6FA8             LDR      R0,[R5, #+120]
   \        0xE   0x.... 0x....      BL       __aeabi_i2f
   \       0x12   0x6F69             LDR      R1,[R5, #+116]
   \       0x14   0x.... 0x....      BL       __aeabi_fmul
   \       0x18   0x.... 0x....      BL       __aeabi_f2d
   \       0x1C   0xF8DF 0x24A0      LDR.W    R2,??prepare_kinematic_move_to_0+0x4  ;; 0x47ae147b
   \       0x20   0xF8DF 0x34A0      LDR.W    R3,??prepare_kinematic_move_to_0+0x8  ;; 0x3f847ae1
   \       0x24   0x.... 0x....      BL       __aeabi_dmul
   \       0x28   0x.... 0x....      BL       __aeabi_d2f
   \       0x2C   0x9002             STR      R0,[SP, #+8]
  12519          
  12520              // If the move is only in Z/E don't split up the move
  12521              if (ltarget[X_AXIS] == current_position[X_AXIS] && ltarget[Y_AXIS] == current_position[Y_AXIS]) {
   \       0x2E   0x6820             LDR      R0,[R4, #+0]
   \       0x30   0x68A9             LDR      R1,[R5, #+8]
   \       0x32   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0x36   0xD10B             BNE.N    ??prepare_kinematic_move_to_1
   \       0x38   0x6860             LDR      R0,[R4, #+4]
   \       0x3A   0x68E9             LDR      R1,[R5, #+12]
   \       0x3C   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0x40   0xD106             BNE.N    ??prepare_kinematic_move_to_1
  12522                planner.buffer_line_kinematic(ltarget, _feedrate_mm_s, active_extruder);
   \       0x42   0x78AA             LDRB     R2,[R5, #+2]
   \       0x44   0xA902             ADD      R1,SP,#+8
   \       0x46   0x4620             MOV      R0,R4
   \       0x48   0x.... 0x....      BL       _ZN7Planner21buffer_line_kinematicEPKfRS0_h
  12523                return false;
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0xE231             B.N      ??prepare_kinematic_move_to_2
  12524              }
  12525          
  12526              // Get the cartesian distances moved in XYZE
  12527              float difference[XYZE];
  12528              LOOP_XYZE(i) difference[i] = ltarget[i] - current_position[i];
   \                     ??prepare_kinematic_move_to_1: (+1)
   \       0x50   0x2600             MOVS     R6,#+0
   \       0x52   0xE00B             B.N      ??prepare_kinematic_move_to_3
   \                     ??prepare_kinematic_move_to_4: (+1)
   \       0x54   0xF854 0x0026      LDR      R0,[R4, R6, LSL #+2]
   \       0x58   0xF105 0x0108      ADD      R1,R5,#+8
   \       0x5C   0xF851 0x1026      LDR      R1,[R1, R6, LSL #+2]
   \       0x60   0x.... 0x....      BL       __aeabi_fsub
   \       0x64   0xA911             ADD      R1,SP,#+68
   \       0x66   0xF841 0x0026      STR      R0,[R1, R6, LSL #+2]
   \       0x6A   0x1C76             ADDS     R6,R6,#+1
   \                     ??prepare_kinematic_move_to_3: (+1)
   \       0x6C   0x2E04             CMP      R6,#+4
   \       0x6E   0xDBF1             BLT.N    ??prepare_kinematic_move_to_4
   \       0x70   0x940B             STR      R4,[SP, #+44]
  12529          
  12530              // Get the linear distance in XYZ
  12531              float cartesian_mm = sqrt(sq(difference[X_AXIS]) + sq(difference[Y_AXIS]) + sq(difference[Z_AXIS]));
   \       0x72   0x9F11             LDR      R7,[SP, #+68]
   \       0x74   0x2602             MOVS     R6,#+2
   \       0x76   0xF04F 0x547E      MOV      R4,#+1065353216
   \       0x7A   0xE004             B.N      ??prepare_kinematic_move_to_5
   \                     ??prepare_kinematic_move_to_6: (+1)
   \       0x7C   0x4638             MOV      R0,R7
   \       0x7E   0x4639             MOV      R1,R7
   \       0x80   0x.... 0x....      BL       __aeabi_fmul
   \       0x84   0x4607             MOV      R7,R0
   \                     ??prepare_kinematic_move_to_5: (+1)
   \       0x86   0x07F0             LSLS     R0,R6,#+31
   \       0x88   0xD504             BPL.N    ??prepare_kinematic_move_to_7
   \       0x8A   0x4620             MOV      R0,R4
   \       0x8C   0x4639             MOV      R1,R7
   \       0x8E   0x.... 0x....      BL       __aeabi_fmul
   \       0x92   0x4604             MOV      R4,R0
   \                     ??prepare_kinematic_move_to_7: (+1)
   \       0x94   0x0876             LSRS     R6,R6,#+1
   \       0x96   0xD1F1             BNE.N    ??prepare_kinematic_move_to_6
   \       0x98   0xF8DD 0x8048      LDR      R8,[SP, #+72]
   \       0x9C   0x2702             MOVS     R7,#+2
   \       0x9E   0xF04F 0x567E      MOV      R6,#+1065353216
   \       0xA2   0xE004             B.N      ??prepare_kinematic_move_to_8
   \                     ??prepare_kinematic_move_to_9: (+1)
   \       0xA4   0x4640             MOV      R0,R8
   \       0xA6   0x4641             MOV      R1,R8
   \       0xA8   0x.... 0x....      BL       __aeabi_fmul
   \       0xAC   0x4680             MOV      R8,R0
   \                     ??prepare_kinematic_move_to_8: (+1)
   \       0xAE   0x07F8             LSLS     R0,R7,#+31
   \       0xB0   0xD504             BPL.N    ??prepare_kinematic_move_to_10
   \       0xB2   0x4630             MOV      R0,R6
   \       0xB4   0x4641             MOV      R1,R8
   \       0xB6   0x.... 0x....      BL       __aeabi_fmul
   \       0xBA   0x4606             MOV      R6,R0
   \                     ??prepare_kinematic_move_to_10: (+1)
   \       0xBC   0x087F             LSRS     R7,R7,#+1
   \       0xBE   0xD1F1             BNE.N    ??prepare_kinematic_move_to_9
   \       0xC0   0xF10D 0x0844      ADD      R8,SP,#+68
   \       0xC4   0xF8D8 0x9008      LDR      R9,[R8, #+8]
   \       0xC8   0x46CA             MOV      R10,R9
   \       0xCA   0x2702             MOVS     R7,#+2
   \       0xCC   0xF04F 0x5B7E      MOV      R11,#+1065353216
   \       0xD0   0xE004             B.N      ??prepare_kinematic_move_to_11
   \                     ??prepare_kinematic_move_to_12: (+1)
   \       0xD2   0x4650             MOV      R0,R10
   \       0xD4   0x4651             MOV      R1,R10
   \       0xD6   0x.... 0x....      BL       __aeabi_fmul
   \       0xDA   0x4682             MOV      R10,R0
   \                     ??prepare_kinematic_move_to_11: (+1)
   \       0xDC   0x07F8             LSLS     R0,R7,#+31
   \       0xDE   0xD504             BPL.N    ??prepare_kinematic_move_to_13
   \       0xE0   0x4658             MOV      R0,R11
   \       0xE2   0x4651             MOV      R1,R10
   \       0xE4   0x.... 0x....      BL       __aeabi_fmul
   \       0xE8   0x4683             MOV      R11,R0
   \                     ??prepare_kinematic_move_to_13: (+1)
   \       0xEA   0x087F             LSRS     R7,R7,#+1
   \       0xEC   0xD1F1             BNE.N    ??prepare_kinematic_move_to_12
   \       0xEE   0x4620             MOV      R0,R4
   \       0xF0   0x4631             MOV      R1,R6
   \       0xF2   0x.... 0x....      BL       __aeabi_fadd
   \       0xF6   0x4659             MOV      R1,R11
   \       0xF8   0x.... 0x....      BL       __aeabi_fadd
   \       0xFC   0x.... 0x....      BL       sqrtf
   \      0x100   0x4604             MOV      R4,R0
  12532          
  12533              // If the move is very short, check the E move distance
  12534              if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = abs(difference[E_AXIS]);
   \      0x102   0xF8DF 0x13C4      LDR.W    R1,??prepare_kinematic_move_to_0+0xC  ;; 0x358637be
   \      0x106   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x10A   0xD203             BCS.N    ??prepare_kinematic_move_to_14
   \      0x10C   0xF8D8 0x000C      LDR      R0,[R8, #+12]
   \      0x110   0xF020 0x4400      BIC      R4,R0,#0x80000000
  12535          
  12536              // No E move either? Game over.
  12537              if (UNEAR_ZERO(cartesian_mm)) return true;
   \                     ??prepare_kinematic_move_to_14: (+1)
   \      0x114   0x4620             MOV      R0,R4
   \      0x116   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x11A   0xD201             BCS.N    ??prepare_kinematic_move_to_15
   \      0x11C   0x2001             MOVS     R0,#+1
   \      0x11E   0xE1C9             B.N      ??prepare_kinematic_move_to_2
  12538          
  12539              // Minimum number of seconds to move the given distance
  12540              float seconds = cartesian_mm / _feedrate_mm_s;
  12541          
  12542              // The number of segments-per-second times the duration
  12543              // gives the number of segments
  12544              uint16_t segments = delta_segments_per_second * seconds;
                                         ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??prepare_kinematic_move_to_15: (+1)
   \      0x120   0xF8DF 0x63A8      LDR.W    R6,??prepare_kinematic_move_to_0+0x10
   \      0x124   0x9902             LDR      R1,[SP, #+8]
   \      0x126   0x.... 0x....      BL       __aeabi_fdiv
   \      0x12A   0x6DB1             LDR      R1,[R6, #+88]
   \      0x12C   0x.... 0x....      BL       __aeabi_fmul
   \      0x130   0x.... 0x....      BL       __aeabi_f2iz
   \      0x134   0x4607             MOV      R7,R0
   \      0x136   0xB2BF             UXTH     R7,R7
  12545          
  12546              // For SCARA minimum segment size is 0.25mm
  12547              //#if IS_SCARA
  12548          	if(MACHINETPYE&IS_SCARA)
   \      0x138   0xF8DF 0x0394      LDR.W    R0,??prepare_kinematic_move_to_0+0x14
   \      0x13C   0xF8B0 0x0058      LDRH     R0,[R0, #+88]
   \      0x140   0xF410 0x7F40      TST      R0,#0x300
   \      0x144   0xD011             BEQ.N    ??prepare_kinematic_move_to_16
  12549                NOMORE(segments, cartesian_mm * 4);
                       ^
Warning[Pa093]: implicit conversion from floating point to integer
   \      0x146   0xF04F 0x4081      MOV      R0,#+1082130432
   \      0x14A   0x4621             MOV      R1,R4
   \      0x14C   0x.... 0x....      BL       __aeabi_fmul
   \      0x150   0x4682             MOV      R10,R0
   \      0x152   0x4638             MOV      R0,R7
   \      0x154   0x.... 0x....      BL       __aeabi_ui2f
   \      0x158   0x4601             MOV      R1,R0
   \      0x15A   0x4650             MOV      R0,R10
   \      0x15C   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x160   0xD203             BCS.N    ??prepare_kinematic_move_to_16
   \      0x162   0x.... 0x....      BL       __aeabi_f2iz
   \      0x166   0x4607             MOV      R7,R0
   \      0x168   0xB2BF             UXTH     R7,R7
  12550              //#endif
  12551          
  12552              // At least one segment is required
  12553              NOLESS(segments, 1);
   \                     ??prepare_kinematic_move_to_16: (+1)
   \      0x16A   0x2F00             CMP      R7,#+0
   \      0x16C   0xD100             BNE.N    ??prepare_kinematic_move_to_17
   \      0x16E   0x2701             MOVS     R7,#+1
  12554          
  12555              // The approximate length of each segment
  12556              const float inv_segments = 1.0 / float(segments),
   \                     ??prepare_kinematic_move_to_17: (+1)
   \      0x170   0x4638             MOV      R0,R7
   \      0x172   0x.... 0x....      BL       __aeabi_ui2f
   \      0x176   0x4682             MOV      R10,R0
   \      0x178   0xF04F 0x507E      MOV      R0,#+1065353216
   \      0x17C   0x4651             MOV      R1,R10
   \      0x17E   0x.... 0x....      BL       __aeabi_fdiv
   \      0x182   0x4683             MOV      R11,R0
  12557                          segment_distance[XYZE] = {
  12558                            difference[X_AXIS] * inv_segments,
  12559                            difference[Y_AXIS] * inv_segments,
  12560                            difference[Z_AXIS] * inv_segments,
  12561                            difference[E_AXIS] * inv_segments
  12562                          };
   \      0x184   0x9811             LDR      R0,[SP, #+68]
   \      0x186   0x4659             MOV      R1,R11
   \      0x188   0x.... 0x....      BL       __aeabi_fmul
   \      0x18C   0x900D             STR      R0,[SP, #+52]
   \      0x18E   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \      0x192   0x4659             MOV      R1,R11
   \      0x194   0x.... 0x....      BL       __aeabi_fmul
   \      0x198   0x900E             STR      R0,[SP, #+56]
   \      0x19A   0x4648             MOV      R0,R9
   \      0x19C   0x4659             MOV      R1,R11
   \      0x19E   0x.... 0x....      BL       __aeabi_fmul
   \      0x1A2   0x900F             STR      R0,[SP, #+60]
   \      0x1A4   0xF8D8 0x000C      LDR      R0,[R8, #+12]
   \      0x1A8   0x4659             MOV      R1,R11
   \      0x1AA   0x.... 0x....      BL       __aeabi_fmul
   \      0x1AE   0x9010             STR      R0,[SP, #+64]
  12563          
  12564              // SERIAL_ECHOPAIR("mm=", cartesian_mm);
  12565              // SERIAL_ECHOPAIR(" seconds=", seconds);
  12566              // SERIAL_ECHOLNPAIR(" segments=", segments);
  12567          
  12568              //#if IS_SCARA	//mks_delta
  12569          	#if 1
  12570                // SCARA needs to scale the feed rate from mm/s to degrees/s
  12571                const float inv_segment_length = min(10.0, float(segments) / cartesian_mm), // 1/mm/segs
   \      0x1B0   0x4650             MOV      R0,R10
   \      0x1B2   0x4621             MOV      R1,R4
   \      0x1B4   0x.... 0x....      BL       __aeabi_fdiv
   \      0x1B8   0x4604             MOV      R4,R0
   \      0x1BA   0x49C6             LDR.N    R1,??prepare_kinematic_move_to_0+0x18  ;; 0x41200001
   \      0x1BC   0x.... 0x....      BL       __aeabi_cfrcmple
   \      0x1C0   0xD800             BHI.N    ??prepare_kinematic_move_to_18
   \      0x1C2   0x4CC5             LDR.N    R4,??prepare_kinematic_move_to_0+0x1C  ;; 0x41200000
  12572                            feed_factor = inv_segment_length * _feedrate_mm_s;
   \                     ??prepare_kinematic_move_to_18: (+1)
   \      0x1C4   0x9802             LDR      R0,[SP, #+8]
   \      0x1C6   0x4621             MOV      R1,R4
   \      0x1C8   0x.... 0x....      BL       __aeabi_fmul
   \      0x1CC   0x900C             STR      R0,[SP, #+48]
  12573                float oldA = stepper.get_axis_position_degrees(A_AXIS),
   \      0x1CE   0x2000             MOVS     R0,#+0
   \      0x1D0   0x.... 0x....      BL       _ZN7Stepper25get_axis_position_degreesE8AxisEnum
   \      0x1D4   0x900A             STR      R0,[SP, #+40]
  12574                      oldB = stepper.get_axis_position_degrees(B_AXIS);
   \      0x1D6   0x2001             MOVS     R0,#+1
   \      0x1D8   0x.... 0x....      BL       _ZN7Stepper25get_axis_position_degreesE8AxisEnum
   \      0x1DC   0x9009             STR      R0,[SP, #+36]
  12575              #endif
  12576          
  12577              // Get the logical current position as starting point
  12578              float logical[XYZE];
  12579              COPY(logical, current_position);
   \      0x1DE   0x2210             MOVS     R2,#+16
   \      0x1E0   0xF105 0x0108      ADD      R1,R5,#+8
   \      0x1E4   0xA805             ADD      R0,SP,#+20
   \      0x1E6   0x.... 0x....      BL       __aeabi_memcpy
  12580          
  12581              // Drop one segment so the last move is to the exact target.
  12582              // If there's only 1 segment, loops will be skipped entirely.
  12583              --segments;
  12584          
  12585              // Calculate and execute the segments
  12586              for (uint16_t s = segments + 1; --s;) {
   \      0x1EA   0xF8AD 0x700C      STRH     R7,[SP, #+12]
   \      0x1EE   0xE013             B.N      ??prepare_kinematic_move_to_19
  12587                LOOP_XYZE(i) logical[i] += segment_distance[i];
  12588          /*	  
  12589                #if ENABLED(DELTA)
  12590                  DELTA_LOGICAL_IK(); // Delta can inline its kinematics
  12591                #else
  12592                  inverse_kinematics(logical);
  12593                #endif
  12594          */
  12595          	  if(MACHINETPYE == DELTA)
  12596          	  	DELTA_LOGICAL_IK(); // Delta can inline its kinematics
  12597          	  else
  12598          	  	{
  12599          	  		if(MACHINETPYE == MORGAN_SCARA)
  12600          				inverse_kinematics_MORGAN_SCARA(logical);
  12601          			else
  12602          				inverse_kinematics(logical);
  12603          	  	}
  12604          
  12605          
  12606                ADJUST_DELTA(logical); // Adjust Z if bed leveling is enabled
  12607          
  12608          //mks_delta 	begin
  12609          /*
  12610                #if IS_SCARA
  12611                  // For SCARA scale the feed rate from mm/s to degrees/s
  12612                  // Use ratio between the length of the move and the larger angle change
  12613                  const float adiff = abs(delta[A_AXIS] - oldA),
  12614                              bdiff = abs(delta[B_AXIS] - oldB);
  12615                  planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], logical[E_AXIS], max(adiff, bdiff) * feed_factor, active_extruder);
  12616                  oldA = delta[A_AXIS];
  12617                  oldB = delta[B_AXIS];
  12618                #else
  12619                  planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], logical[E_AXIS], _feedrate_mm_s, active_extruder);
  12620                #endif
  12621          */      
  12622          ///////
  12623          	  float adiff,bdiff;
  12624          
  12625          	if(MACHINETPYE&IS_SCARA)
  12626          		{
  12627                   adiff = abs(delta[A_AXIS] - oldA);
  12628                   bdiff = abs(delta[B_AXIS] - oldB);
  12629                  planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], logical[E_AXIS], max(adiff, bdiff) * feed_factor, active_extruder);
   \                     ??prepare_kinematic_move_to_20: (+1)
   \      0x1F0   0x4607             MOV      R7,R0
   \                     ??prepare_kinematic_move_to_21: (+1)
   \      0x1F2   0x980C             LDR      R0,[SP, #+48]
   \      0x1F4   0x4639             MOV      R1,R7
   \      0x1F6   0x.... 0x....      BL       __aeabi_fmul
   \      0x1FA   0x9004             STR      R0,[SP, #+16]
   \      0x1FC   0x78A8             LDRB     R0,[R5, #+2]
   \      0x1FE   0x9001             STR      R0,[SP, #+4]
   \      0x200   0xA804             ADD      R0,SP,#+16
   \      0x202   0x9000             STR      R0,[SP, #+0]
   \      0x204   0xAB08             ADD      R3,SP,#+32
   \      0x206   0x6F2A             LDR      R2,[R5, #+112]
   \      0x208   0x4621             MOV      R1,R4
   \      0x20A   0x4640             MOV      R0,R8
   \      0x20C   0x.... 0x....      BL       _ZN7Planner11buffer_lineEfffRKfS1_h
  12630                  oldA = delta[A_AXIS];
   \      0x210   0x6EA8             LDR      R0,[R5, #+104]
   \      0x212   0x900A             STR      R0,[SP, #+40]
  12631                  oldB = delta[B_AXIS];
   \      0x214   0x6EE8             LDR      R0,[R5, #+108]
   \      0x216   0x9009             STR      R0,[SP, #+36]
   \                     ??prepare_kinematic_move_to_19: (+1)
   \      0x218   0xF8BD 0x000C      LDRH     R0,[SP, #+12]
   \      0x21C   0x1E40             SUBS     R0,R0,#+1
   \      0x21E   0xF8AD 0x000C      STRH     R0,[SP, #+12]
   \      0x222   0xF8BD 0x000C      LDRH     R0,[SP, #+12]
   \      0x226   0x2800             CMP      R0,#+0
   \      0x228   0xF000 0x8109      BEQ.W    ??prepare_kinematic_move_to_22
   \      0x22C   0x2400             MOVS     R4,#+0
   \      0x22E   0xAF05             ADD      R7,SP,#+20
   \      0x230   0xE009             B.N      ??prepare_kinematic_move_to_23
   \                     ??prepare_kinematic_move_to_24: (+1)
   \      0x232   0xF857 0x0024      LDR      R0,[R7, R4, LSL #+2]
   \      0x236   0xA90D             ADD      R1,SP,#+52
   \      0x238   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \      0x23C   0x.... 0x....      BL       __aeabi_fadd
   \      0x240   0xF847 0x0024      STR      R0,[R7, R4, LSL #+2]
   \      0x244   0x1C64             ADDS     R4,R4,#+1
   \                     ??prepare_kinematic_move_to_23: (+1)
   \      0x246   0x2C04             CMP      R4,#+4
   \      0x248   0xDBF3             BLT.N    ??prepare_kinematic_move_to_24
   \      0x24A   0x4FA1             LDR.N    R7,??prepare_kinematic_move_to_0+0x14
   \      0x24C   0xF9B7 0x0058      LDRSH    R0,[R7, #+88]
   \      0x250   0x2802             CMP      R0,#+2
   \      0x252   0xF040 0x80C3      BNE.W    ??prepare_kinematic_move_to_25
   \      0x256   0x9805             LDR      R0,[SP, #+20]
   \      0x258   0x6C69             LDR      R1,[R5, #+68]
   \      0x25A   0x.... 0x....      BL       __aeabi_fsub
   \      0x25E   0x9004             STR      R0,[SP, #+16]
   \      0x260   0xAC05             ADD      R4,SP,#+20
   \      0x262   0x6860             LDR      R0,[R4, #+4]
   \      0x264   0x6CA9             LDR      R1,[R5, #+72]
   \      0x266   0x.... 0x....      BL       __aeabi_fsub
   \      0x26A   0x9001             STR      R0,[SP, #+4]
   \      0x26C   0x68A0             LDR      R0,[R4, #+8]
   \      0x26E   0x6CE9             LDR      R1,[R5, #+76]
   \      0x270   0x.... 0x....      BL       __aeabi_fsub
   \      0x274   0x9000             STR      R0,[SP, #+0]
   \      0x276   0x6870             LDR      R0,[R6, #+4]
   \      0x278   0x9904             LDR      R1,[SP, #+16]
   \      0x27A   0x.... 0x....      BL       __aeabi_fsub
   \      0x27E   0x4682             MOV      R10,R0
   \      0x280   0x2402             MOVS     R4,#+2
   \      0x282   0xF04F 0x587E      MOV      R8,#+1065353216
   \      0x286   0x46C1             MOV      R9,R8
   \      0x288   0xE004             B.N      ??prepare_kinematic_move_to_26
   \                     ??prepare_kinematic_move_to_27: (+1)
   \      0x28A   0x4650             MOV      R0,R10
   \      0x28C   0x4651             MOV      R1,R10
   \      0x28E   0x.... 0x....      BL       __aeabi_fmul
   \      0x292   0x4682             MOV      R10,R0
   \                     ??prepare_kinematic_move_to_26: (+1)
   \      0x294   0x07E0             LSLS     R0,R4,#+31
   \      0x296   0xD504             BPL.N    ??prepare_kinematic_move_to_28
   \      0x298   0x4648             MOV      R0,R9
   \      0x29A   0x4651             MOV      R1,R10
   \      0x29C   0x.... 0x....      BL       __aeabi_fmul
   \      0x2A0   0x4681             MOV      R9,R0
   \                     ??prepare_kinematic_move_to_28: (+1)
   \      0x2A2   0x0864             LSRS     R4,R4,#+1
   \      0x2A4   0xD1F1             BNE.N    ??prepare_kinematic_move_to_27
   \      0x2A6   0x68B0             LDR      R0,[R6, #+8]
   \      0x2A8   0x9901             LDR      R1,[SP, #+4]
   \      0x2AA   0x.... 0x....      BL       __aeabi_fsub
   \      0x2AE   0x4682             MOV      R10,R0
   \      0x2B0   0x2402             MOVS     R4,#+2
   \      0x2B2   0x46C3             MOV      R11,R8
   \      0x2B4   0xE004             B.N      ??prepare_kinematic_move_to_29
   \                     ??prepare_kinematic_move_to_30: (+1)
   \      0x2B6   0x4650             MOV      R0,R10
   \      0x2B8   0x4651             MOV      R1,R10
   \      0x2BA   0x.... 0x....      BL       __aeabi_fmul
   \      0x2BE   0x4682             MOV      R10,R0
   \                     ??prepare_kinematic_move_to_29: (+1)
   \      0x2C0   0x07E0             LSLS     R0,R4,#+31
   \      0x2C2   0xD504             BPL.N    ??prepare_kinematic_move_to_31
   \      0x2C4   0x4658             MOV      R0,R11
   \      0x2C6   0x4651             MOV      R1,R10
   \      0x2C8   0x.... 0x....      BL       __aeabi_fmul
   \      0x2CC   0x4683             MOV      R11,R0
   \                     ??prepare_kinematic_move_to_31: (+1)
   \      0x2CE   0x0864             LSRS     R4,R4,#+1
   \      0x2D0   0xD1F1             BNE.N    ??prepare_kinematic_move_to_30
   \      0x2D2   0x4648             MOV      R0,R9
   \      0x2D4   0x4659             MOV      R1,R11
   \      0x2D6   0x.... 0x....      BL       __aeabi_fadd
   \      0x2DA   0x4601             MOV      R1,R0
   \      0x2DC   0x69F0             LDR      R0,[R6, #+28]
   \      0x2DE   0x.... 0x....      BL       __aeabi_fsub
   \      0x2E2   0x.... 0x....      BL       sqrtf
   \      0x2E6   0x4601             MOV      R1,R0
   \      0x2E8   0x9800             LDR      R0,[SP, #+0]
   \      0x2EA   0x.... 0x....      BL       __aeabi_fadd
   \      0x2EE   0x66A8             STR      R0,[R5, #+104]
   \      0x2F0   0x68F0             LDR      R0,[R6, #+12]
   \      0x2F2   0x9904             LDR      R1,[SP, #+16]
   \      0x2F4   0x.... 0x....      BL       __aeabi_fsub
   \      0x2F8   0x4682             MOV      R10,R0
   \      0x2FA   0x2402             MOVS     R4,#+2
   \      0x2FC   0x46C1             MOV      R9,R8
   \      0x2FE   0xE004             B.N      ??prepare_kinematic_move_to_32
   \                     ??prepare_kinematic_move_to_33: (+1)
   \      0x300   0x4650             MOV      R0,R10
   \      0x302   0x4651             MOV      R1,R10
   \      0x304   0x.... 0x....      BL       __aeabi_fmul
   \      0x308   0x4682             MOV      R10,R0
   \                     ??prepare_kinematic_move_to_32: (+1)
   \      0x30A   0x07E0             LSLS     R0,R4,#+31
   \      0x30C   0xD504             BPL.N    ??prepare_kinematic_move_to_34
   \      0x30E   0x4648             MOV      R0,R9
   \      0x310   0x4651             MOV      R1,R10
   \      0x312   0x.... 0x....      BL       __aeabi_fmul
   \      0x316   0x4681             MOV      R9,R0
   \                     ??prepare_kinematic_move_to_34: (+1)
   \      0x318   0x0864             LSRS     R4,R4,#+1
   \      0x31A   0xD1F1             BNE.N    ??prepare_kinematic_move_to_33
   \      0x31C   0x6930             LDR      R0,[R6, #+16]
   \      0x31E   0x9901             LDR      R1,[SP, #+4]
   \      0x320   0x.... 0x....      BL       __aeabi_fsub
   \      0x324   0x4682             MOV      R10,R0
   \      0x326   0x2402             MOVS     R4,#+2
   \      0x328   0x46C3             MOV      R11,R8
   \      0x32A   0xE004             B.N      ??prepare_kinematic_move_to_35
   \                     ??prepare_kinematic_move_to_36: (+1)
   \      0x32C   0x4650             MOV      R0,R10
   \      0x32E   0x4651             MOV      R1,R10
   \      0x330   0x.... 0x....      BL       __aeabi_fmul
   \      0x334   0x4682             MOV      R10,R0
   \                     ??prepare_kinematic_move_to_35: (+1)
   \      0x336   0x07E0             LSLS     R0,R4,#+31
   \      0x338   0xD504             BPL.N    ??prepare_kinematic_move_to_37
   \      0x33A   0x4658             MOV      R0,R11
   \      0x33C   0x4651             MOV      R1,R10
   \      0x33E   0x.... 0x....      BL       __aeabi_fmul
   \      0x342   0x4683             MOV      R11,R0
   \                     ??prepare_kinematic_move_to_37: (+1)
   \      0x344   0x0864             LSRS     R4,R4,#+1
   \      0x346   0xD1F1             BNE.N    ??prepare_kinematic_move_to_36
   \      0x348   0x4648             MOV      R0,R9
   \      0x34A   0x4659             MOV      R1,R11
   \      0x34C   0x.... 0x....      BL       __aeabi_fadd
   \      0x350   0x4601             MOV      R1,R0
   \      0x352   0x6A30             LDR      R0,[R6, #+32]
   \      0x354   0x.... 0x....      BL       __aeabi_fsub
   \      0x358   0x.... 0x....      BL       sqrtf
   \      0x35C   0x4601             MOV      R1,R0
   \      0x35E   0x9800             LDR      R0,[SP, #+0]
   \      0x360   0x.... 0x....      BL       __aeabi_fadd
   \      0x364   0x66E8             STR      R0,[R5, #+108]
   \      0x366   0x6970             LDR      R0,[R6, #+20]
   \      0x368   0x9904             LDR      R1,[SP, #+16]
   \      0x36A   0x.... 0x....      BL       __aeabi_fsub
   \      0x36E   0x4682             MOV      R10,R0
   \      0x370   0x2402             MOVS     R4,#+2
   \      0x372   0x46C1             MOV      R9,R8
   \      0x374   0xE004             B.N      ??prepare_kinematic_move_to_38
   \                     ??prepare_kinematic_move_to_39: (+1)
   \      0x376   0x4650             MOV      R0,R10
   \      0x378   0x4651             MOV      R1,R10
   \      0x37A   0x.... 0x....      BL       __aeabi_fmul
   \      0x37E   0x4682             MOV      R10,R0
   \                     ??prepare_kinematic_move_to_38: (+1)
   \      0x380   0x07E0             LSLS     R0,R4,#+31
   \      0x382   0xD504             BPL.N    ??prepare_kinematic_move_to_40
   \      0x384   0x4648             MOV      R0,R9
   \      0x386   0x4651             MOV      R1,R10
   \      0x388   0x.... 0x....      BL       __aeabi_fmul
   \      0x38C   0x4681             MOV      R9,R0
   \                     ??prepare_kinematic_move_to_40: (+1)
   \      0x38E   0x0864             LSRS     R4,R4,#+1
   \      0x390   0xD1F1             BNE.N    ??prepare_kinematic_move_to_39
   \      0x392   0x69B0             LDR      R0,[R6, #+24]
   \      0x394   0x9901             LDR      R1,[SP, #+4]
   \      0x396   0x.... 0x....      BL       __aeabi_fsub
   \      0x39A   0x4682             MOV      R10,R0
   \      0x39C   0x2402             MOVS     R4,#+2
   \      0x39E   0xE004             B.N      ??prepare_kinematic_move_to_41
   \                     ??prepare_kinematic_move_to_42: (+1)
   \      0x3A0   0x4650             MOV      R0,R10
   \      0x3A2   0x4651             MOV      R1,R10
   \      0x3A4   0x.... 0x....      BL       __aeabi_fmul
   \      0x3A8   0x4682             MOV      R10,R0
   \                     ??prepare_kinematic_move_to_41: (+1)
   \      0x3AA   0x07E0             LSLS     R0,R4,#+31
   \      0x3AC   0xD504             BPL.N    ??prepare_kinematic_move_to_43
   \      0x3AE   0x4640             MOV      R0,R8
   \      0x3B0   0x4651             MOV      R1,R10
   \      0x3B2   0x.... 0x....      BL       __aeabi_fmul
   \      0x3B6   0x4680             MOV      R8,R0
   \                     ??prepare_kinematic_move_to_43: (+1)
   \      0x3B8   0x0864             LSRS     R4,R4,#+1
   \      0x3BA   0xD1F1             BNE.N    ??prepare_kinematic_move_to_42
   \      0x3BC   0x4648             MOV      R0,R9
   \      0x3BE   0x4641             MOV      R1,R8
   \      0x3C0   0x.... 0x....      BL       __aeabi_fadd
   \      0x3C4   0x4601             MOV      R1,R0
   \      0x3C6   0x6A70             LDR      R0,[R6, #+36]
   \      0x3C8   0x.... 0x....      BL       __aeabi_fsub
   \      0x3CC   0x.... 0x....      BL       sqrtf
   \      0x3D0   0x4601             MOV      R1,R0
   \      0x3D2   0x9800             LDR      R0,[SP, #+0]
   \      0x3D4   0x.... 0x....      BL       __aeabi_fadd
   \      0x3D8   0x6728             STR      R0,[R5, #+112]
   \      0x3DA   0xE008             B.N      ??prepare_kinematic_move_to_44
   \                     ??prepare_kinematic_move_to_25: (+1)
   \      0x3DC   0xF5B0 0x7F80      CMP      R0,#+256
   \      0x3E0   0xA805             ADD      R0,SP,#+20
   \      0x3E2   0xD102             BNE.N    ??prepare_kinematic_move_to_45
   \      0x3E4   0x.... 0x....      BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
   \      0x3E8   0xE001             B.N      ??prepare_kinematic_move_to_44
   \                     ??prepare_kinematic_move_to_45: (+1)
   \      0x3EA   0x.... 0x....      BL       _Z18inverse_kinematicsPKf
   \                     ??prepare_kinematic_move_to_44: (+1)
   \      0x3EE   0xA805             ADD      R0,SP,#+20
   \      0x3F0   0x.... 0x....      BL       _Z12ADJUST_DELTAPKf
   \      0x3F4   0x6EEC             LDR      R4,[R5, #+108]
   \      0x3F6   0xF8D5 0x8068      LDR      R8,[R5, #+104]
   \      0x3FA   0xF8B7 0x0058      LDRH     R0,[R7, #+88]
   \      0x3FE   0xF410 0x7F40      TST      R0,#0x300
   \      0x402   0xD011             BEQ.N    ??prepare_kinematic_move_to_46
   \      0x404   0x4640             MOV      R0,R8
   \      0x406   0x990A             LDR      R1,[SP, #+40]
   \      0x408   0x.... 0x....      BL       __aeabi_fsub
   \      0x40C   0xF020 0x4700      BIC      R7,R0,#0x80000000
   \      0x410   0x4620             MOV      R0,R4
   \      0x412   0x9909             LDR      R1,[SP, #+36]
   \      0x414   0x.... 0x....      BL       __aeabi_fsub
   \      0x418   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \      0x41C   0x4639             MOV      R1,R7
   \      0x41E   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x422   0xF4BF 0xAEE5      BCS.W    ??prepare_kinematic_move_to_20
   \      0x426   0xE6E4             B.N      ??prepare_kinematic_move_to_21
  12632          		}
  12633          	else
  12634          		{
  12635          		planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], logical[E_AXIS], _feedrate_mm_s, active_extruder);		
   \                     ??prepare_kinematic_move_to_46: (+1)
   \      0x428   0x78A8             LDRB     R0,[R5, #+2]
   \      0x42A   0x9001             STR      R0,[SP, #+4]
   \      0x42C   0xA802             ADD      R0,SP,#+8
   \      0x42E   0x9000             STR      R0,[SP, #+0]
   \      0x430   0xAB08             ADD      R3,SP,#+32
   \      0x432   0x6F2A             LDR      R2,[R5, #+112]
   \      0x434   0x4621             MOV      R1,R4
   \      0x436   0x4640             MOV      R0,R8
   \      0x438   0x.... 0x....      BL       _ZN7Planner11buffer_lineEfffRKfS1_h
   \      0x43C   0xE6EC             B.N      ??prepare_kinematic_move_to_19
  12636          		}
  12637          	  
  12638           //mks_delta	  end
  12639          
  12640              }
  12641          
  12642              // Since segment_distance is only approximate,
  12643              // the final move must be to the exact destination.
  12644          /*
  12645              #if IS_SCARA
  12646                // For SCARA scale the feed rate from mm/s to degrees/s
  12647                // With segments > 1 length is 1 segment, otherwise total length
  12648                inverse_kinematics(ltarget);
  12649                ADJUST_DELTA(logical);
  12650                const float adiff = abs(delta[A_AXIS] - oldA),
  12651                            bdiff = abs(delta[B_AXIS] - oldB);
  12652                planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], logical[E_AXIS], max(adiff, bdiff) * feed_factor, active_extruder);
  12653              #else
  12654                planner.buffer_line_kinematic(ltarget, _feedrate_mm_s, active_extruder);
  12655              #endif
  12656          */    
  12657          /////////
  12658          	float adiff,bdiff;
  12659          	if(MACHINETPYE&IS_SCARA)
   \                     ??prepare_kinematic_move_to_22: (+1)
   \      0x43E   0x4824             LDR.N    R0,??prepare_kinematic_move_to_0+0x14
   \      0x440   0xF9B0 0x0058      LDRSH    R0,[R0, #+88]
   \      0x444   0xF410 0x7F40      TST      R0,#0x300
   \      0x448   0xD02E             BEQ.N    ??prepare_kinematic_move_to_47
  12660          		{
  12661          		
  12662          		if(MACHINETPYE == MORGAN_SCARA)
   \      0x44A   0xF5B0 0x7F80      CMP      R0,#+256
   \      0x44E   0x980B             LDR      R0,[SP, #+44]
   \      0x450   0xD102             BNE.N    ??prepare_kinematic_move_to_48
  12663          			inverse_kinematics_MORGAN_SCARA(ltarget);
   \      0x452   0x.... 0x....      BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
   \      0x456   0xE001             B.N      ??prepare_kinematic_move_to_49
  12664          		else
  12665          			inverse_kinematics(ltarget);
   \                     ??prepare_kinematic_move_to_48: (+1)
   \      0x458   0x.... 0x....      BL       _Z18inverse_kinematicsPKf
  12666          		ADJUST_DELTA(logical);
   \                     ??prepare_kinematic_move_to_49: (+1)
   \      0x45C   0xA805             ADD      R0,SP,#+20
   \      0x45E   0x.... 0x....      BL       _Z12ADJUST_DELTAPKf
  12667          		adiff = abs(delta[A_AXIS] - oldA);
   \      0x462   0x6EAC             LDR      R4,[R5, #+104]
   \      0x464   0x4620             MOV      R0,R4
   \      0x466   0x990A             LDR      R1,[SP, #+40]
   \      0x468   0x.... 0x....      BL       __aeabi_fsub
   \      0x46C   0xF020 0x4600      BIC      R6,R0,#0x80000000
  12668          		bdiff = abs(delta[B_AXIS] - oldB);
   \      0x470   0x6EEF             LDR      R7,[R5, #+108]
   \      0x472   0x4638             MOV      R0,R7
   \      0x474   0x9909             LDR      R1,[SP, #+36]
   \      0x476   0x.... 0x....      BL       __aeabi_fsub
   \      0x47A   0xF020 0x4000      BIC      R0,R0,#0x80000000
  12669          		planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], logical[E_AXIS], max(adiff, bdiff) * feed_factor, active_extruder);
   \      0x47E   0x4631             MOV      R1,R6
   \      0x480   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x484   0xD300             BCC.N    ??prepare_kinematic_move_to_50
   \      0x486   0x4606             MOV      R6,R0
   \                     ??prepare_kinematic_move_to_50: (+1)
   \      0x488   0x980C             LDR      R0,[SP, #+48]
   \      0x48A   0x4631             MOV      R1,R6
   \      0x48C   0x.... 0x....      BL       __aeabi_fmul
   \      0x490   0x9003             STR      R0,[SP, #+12]
   \      0x492   0x78A8             LDRB     R0,[R5, #+2]
   \      0x494   0x9001             STR      R0,[SP, #+4]
   \      0x496   0xA803             ADD      R0,SP,#+12
   \      0x498   0x9000             STR      R0,[SP, #+0]
   \      0x49A   0xAB08             ADD      R3,SP,#+32
   \      0x49C   0x6F2A             LDR      R2,[R5, #+112]
   \      0x49E   0x4639             MOV      R1,R7
   \      0x4A0   0x4620             MOV      R0,R4
   \      0x4A2   0x.... 0x....      BL       _ZN7Planner11buffer_lineEfffRKfS1_h
   \      0x4A6   0xE004             B.N      ??prepare_kinematic_move_to_51
  12670          		}
  12671          	else
  12672          		{
  12673          		planner.buffer_line_kinematic(ltarget, _feedrate_mm_s, active_extruder);
   \                     ??prepare_kinematic_move_to_47: (+1)
   \      0x4A8   0x78AA             LDRB     R2,[R5, #+2]
   \      0x4AA   0xA902             ADD      R1,SP,#+8
   \      0x4AC   0x980B             LDR      R0,[SP, #+44]
   \      0x4AE   0x.... 0x....      BL       _ZN7Planner21buffer_line_kinematicEPKfRS0_h
  12674          		}
  12675          
  12676          	
  12677              return false;
   \                     ??prepare_kinematic_move_to_51: (+1)
   \      0x4B2   0x2000             MOVS     R0,#+0
   \                     ??prepare_kinematic_move_to_2: (+1)
   \      0x4B4   0xB015             ADD      SP,SP,#+84
   \      0x4B6   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \      0x4BA   0xBF00             Nop      
   \                     ??prepare_kinematic_move_to_0:
   \      0x4BC   0x....'....        DC32     mks_heating_busy
   \      0x4C0   0x47AE'147B        DC32     0x47ae147b
   \      0x4C4   0x3F84'7AE1        DC32     0x3f847ae1
   \      0x4C8   0x3586'37BE        DC32     0x358637be
   \      0x4CC   0x....'....        DC32     axis_homed
   \      0x4D0   0x....'....        DC32     mksCfg
   \      0x4D4   0x4120'0001        DC32     0x41200001
   \      0x4D8   0x4120'0000        DC32     0x41200000
  12678            }
  12679          
  12680          #endif
  12681          //#else // !IS_KINEMATIC
  12682          #if 1
  12683            /**
  12684             * Prepare a linear move in a Cartesian setup.
  12685             * If Mesh Bed Leveling is enabled, perform a mesh move.
  12686             *
  12687             * Returns true if the caller didn't update current_position.
  12688             */

   \                                 In section .text, align 4
  12689            inline bool prepare_move_to_destination_cartesian() {
   \                     _Z37prepare_move_to_destination_cartesianv: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
  12690              // Do not use feedrate_percentage for E or Z only moves
  12691              if (current_position[X_AXIS] == destination[X_AXIS] && current_position[Y_AXIS] == destination[Y_AXIS]) 
   \        0x2   0x4C3D             LDR.N    R4,??prepare_move_to_destination_cartesian_0
   \        0x4   0x68A0             LDR      R0,[R4, #+8]
   \        0x6   0x69A1             LDR      R1,[R4, #+24]
   \        0x8   0x.... 0x....      BL       __aeabi_cfcmpeq
   \        0xC   0xD107             BNE.N    ??prepare_move_to_destination_cartesian_1
   \        0xE   0x68E0             LDR      R0,[R4, #+12]
   \       0x10   0x69E1             LDR      R1,[R4, #+28]
   \       0x12   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0x16   0xD102             BNE.N    ??prepare_move_to_destination_cartesian_1
  12692          	{
  12693                line_to_destination();
   \       0x18   0x.... 0x....      BL       _Z19line_to_destinationv
   \       0x1C   0xE069             B.N      ??prepare_move_to_destination_cartesian_2
  12694              }
  12695              else {
  12696          /*--mks cfg--begin MESH_BED_LEVELING */	
  12697          /*
  12698                #if ENABLED(MESH_BED_LEVELING)
  12699                  if (mbl.active()) {
  12700                    mesh_line_to_destination(MMS_SCALED(feedrate_mm_s));
  12701                    return true;
  12702                  }
  12703                  else
  12704                #elif ENABLED(AUTO_BED_LEVELING_UBL)
  12705                  if (ubl.state.active) {
  12706                    ubl_line_to_destination(MMS_SCALED(feedrate_mm_s), active_extruder);
  12707                    return true;
  12708                  }
  12709                  else
  12710                #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
  12711                  if (planner.abl_enabled) {
  12712                    bilinear_line_to_destination(MMS_SCALED(feedrate_mm_s));
  12713                    return true;
  12714                  }
  12715                  else
  12716                #endif
  12717                    line_to_destination(MMS_SCALED(feedrate_mm_s));
  12718          */
  12719          	if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
   \                     ??prepare_move_to_destination_cartesian_1: (+1)
   \       0x1E   0x4837             LDR.N    R0,??prepare_move_to_destination_cartesian_0+0x4
   \       0x20   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \       0x24   0x2820             CMP      R0,#+32
   \       0x26   0xD11B             BNE.N    ??prepare_move_to_destination_cartesian_3
  12720          		{
  12721                  if (mbl.active()) {
   \       0x28   0x.... 0x....      BL       _ZN17mesh_bed_leveling6activeEv
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD050             BEQ.N    ??prepare_move_to_destination_cartesian_4
  12722                    mesh_line_to_destination(MMS_SCALED(feedrate_mm_s));
   \       0x30   0x22FF             MOVS     R2,#+255
   \       0x32   0x4611             MOV      R1,R2
   \       0x34   0x460D             MOV      R5,R1
   \       0x36   0x4616             MOV      R6,R2
   \       0x38   0x6FA0             LDR      R0,[R4, #+120]
   \       0x3A   0x.... 0x....      BL       __aeabi_i2f
   \       0x3E   0x6F61             LDR      R1,[R4, #+116]
   \       0x40   0x.... 0x....      BL       __aeabi_fmul
   \       0x44   0x.... 0x....      BL       __aeabi_f2d
   \       0x48   0x4A2D             LDR.N    R2,??prepare_move_to_destination_cartesian_0+0x8  ;; 0x47ae147b
   \       0x4A   0x4B2E             LDR.N    R3,??prepare_move_to_destination_cartesian_0+0xC  ;; 0x3f847ae1
   \       0x4C   0x.... 0x....      BL       __aeabi_dmul
   \       0x50   0x.... 0x....      BL       __aeabi_d2f
   \       0x54   0x4632             MOV      R2,R6
   \       0x56   0x4629             MOV      R1,R5
   \       0x58   0x.... 0x....      BL       _Z24mesh_line_to_destinationfhh
  12723                    return true;
   \       0x5C   0x2001             MOVS     R0,#+1
   \       0x5E   0xBD76             POP      {R1,R2,R4-R6,PC}
  12724                  }
  12725                  else
  12726          			line_to_destination(MMS_SCALED(feedrate_mm_s));
  12727          		}
  12728          	else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
   \                     ??prepare_move_to_destination_cartesian_3: (+1)
   \       0x60   0x2810             CMP      R0,#+16
   \       0x62   0xD118             BNE.N    ??prepare_move_to_destination_cartesian_5
  12729          		{
  12730                  if (ubl.state.active) {
   \       0x64   0x4828             LDR.N    R0,??prepare_move_to_destination_cartesian_0+0x10
   \       0x66   0x7800             LDRB     R0,[R0, #+0]
   \       0x68   0x2800             CMP      R0,#+0
   \       0x6A   0xD032             BEQ.N    ??prepare_move_to_destination_cartesian_4
  12731                    ubl_line_to_destination(MMS_SCALED(feedrate_mm_s), active_extruder);
   \       0x6C   0x6FA0             LDR      R0,[R4, #+120]
   \       0x6E   0x.... 0x....      BL       __aeabi_i2f
   \       0x72   0x6F61             LDR      R1,[R4, #+116]
   \       0x74   0x.... 0x....      BL       __aeabi_fmul
   \       0x78   0x.... 0x....      BL       __aeabi_f2d
   \       0x7C   0x4A20             LDR.N    R2,??prepare_move_to_destination_cartesian_0+0x8  ;; 0x47ae147b
   \       0x7E   0x4B21             LDR.N    R3,??prepare_move_to_destination_cartesian_0+0xC  ;; 0x3f847ae1
   \       0x80   0x.... 0x....      BL       __aeabi_dmul
   \       0x84   0x.... 0x....      BL       __aeabi_d2f
   \       0x88   0x9000             STR      R0,[SP, #+0]
   \       0x8A   0x78A1             LDRB     R1,[R4, #+2]
   \       0x8C   0x4668             MOV      R0,SP
   \       0x8E   0x.... 0x....      BL       _Z23ubl_line_to_destinationRKfh
  12732                    return true;
   \       0x92   0x2001             MOVS     R0,#+1
   \       0x94   0xBD76             POP      {R1,R2,R4-R6,PC}
  12733                  }
  12734                  else
  12735          			line_to_destination(MMS_SCALED(feedrate_mm_s));
  12736          		}
  12737          
  12738          	else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
   \                     ??prepare_move_to_destination_cartesian_5: (+1)
   \       0x96   0x2808             CMP      R0,#+8
   \       0x98   0xD11B             BNE.N    ??prepare_move_to_destination_cartesian_4
  12739          		{
  12740                  if (planner.abl_enabled) {
   \       0x9A   0x481C             LDR.N    R0,??prepare_move_to_destination_cartesian_0+0x14
   \       0x9C   0x7800             LDRB     R0,[R0, #+0]
   \       0x9E   0x2800             CMP      R0,#+0
   \       0xA0   0xD017             BEQ.N    ??prepare_move_to_destination_cartesian_4
  12741                    bilinear_line_to_destination(MMS_SCALED(feedrate_mm_s));
   \       0xA2   0xF64F 0x71FF      MOVW     R1,#+65535
   \       0xA6   0x460A             MOV      R2,R1
   \       0xA8   0x4615             MOV      R5,R2
   \       0xAA   0x6FA0             LDR      R0,[R4, #+120]
   \       0xAC   0x.... 0x....      BL       __aeabi_i2f
   \       0xB0   0x6F61             LDR      R1,[R4, #+116]
   \       0xB2   0x.... 0x....      BL       __aeabi_fmul
   \       0xB6   0x.... 0x....      BL       __aeabi_f2d
   \       0xBA   0x4A11             LDR.N    R2,??prepare_move_to_destination_cartesian_0+0x8  ;; 0x47ae147b
   \       0xBC   0x4B11             LDR.N    R3,??prepare_move_to_destination_cartesian_0+0xC  ;; 0x3f847ae1
   \       0xBE   0x.... 0x....      BL       __aeabi_dmul
   \       0xC2   0x.... 0x....      BL       __aeabi_d2f
   \       0xC6   0x462A             MOV      R2,R5
   \       0xC8   0x4629             MOV      R1,R5
   \       0xCA   0x.... 0x....      BL       _Z28bilinear_line_to_destinationftt
  12742                    return true;
   \       0xCE   0x2001             MOVS     R0,#+1
   \       0xD0   0xBD76             POP      {R1,R2,R4-R6,PC}
  12743                  }
  12744                  else
  12745          			line_to_destination(MMS_SCALED(feedrate_mm_s));
  12746          		}
  12747          	else
  12748          		{
  12749          		line_to_destination(MMS_SCALED(feedrate_mm_s));
   \                     ??prepare_move_to_destination_cartesian_4: (+1)
   \       0xD2   0x6FA0             LDR      R0,[R4, #+120]
   \       0xD4   0x.... 0x....      BL       __aeabi_i2f
   \       0xD8   0x6F61             LDR      R1,[R4, #+116]
   \       0xDA   0x.... 0x....      BL       __aeabi_fmul
   \       0xDE   0x.... 0x....      BL       __aeabi_f2d
   \       0xE2   0x4A07             LDR.N    R2,??prepare_move_to_destination_cartesian_0+0x8  ;; 0x47ae147b
   \       0xE4   0x4B07             LDR.N    R3,??prepare_move_to_destination_cartesian_0+0xC  ;; 0x3f847ae1
   \       0xE6   0x.... 0x....      BL       __aeabi_dmul
   \       0xEA   0x.... 0x....      BL       __aeabi_d2f
   \       0xEE   0x.... 0x....      BL       _Z19line_to_destinationf
  12750          		}
  12751          	/*--mks cfg--end MESH_BED_LEVELING */
  12752          
  12753          	}
  12754              return false;
   \                     ??prepare_move_to_destination_cartesian_2: (+1)
   \       0xF2   0x2000             MOVS     R0,#+0
   \       0xF4   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   \       0xF6   0xBF00             Nop      
   \                     ??prepare_move_to_destination_cartesian_0:
   \       0xF8   0x....'....        DC32     mks_heating_busy
   \       0xFC   0x....'....        DC32     mksCfg
   \      0x100   0x47AE'147B        DC32     0x47ae147b
   \      0x104   0x3F84'7AE1        DC32     0x3f847ae1
   \      0x108   0x....'....        DC32     _ZN20unified_bed_leveling5stateE
   \      0x10C   0x....'....        DC32     _ZN7Planner11abl_enabledE
  12755            }
  12756          
  12757          #endif // !IS_KINEMATIC
  12758          
  12759          #if ENABLED(DUAL_X_CARRIAGE)
  12760          
  12761            /**
  12762             * Prepare a linear move in a dual X axis setup
  12763             */
  12764            inline bool prepare_move_to_destination_dualx() {
  12765              if (active_extruder_parked) {
  12766                switch (dual_x_carriage_mode) {
  12767                  case DXC_FULL_CONTROL_MODE:
  12768                    break;
  12769                  case DXC_AUTO_PARK_MODE:
  12770                    if (current_position[E_AXIS] == destination[E_AXIS]) {
  12771                      // This is a travel move (with no extrusion)
  12772                      // Skip it, but keep track of the current position
  12773                      // (so it can be used as the start of the next non-travel move)
  12774                      if (delayed_move_time != 0xFFFFFFFFUL) {
  12775                        set_current_to_destination();
  12776                        NOLESS(raised_parked_position[Z_AXIS], destination[Z_AXIS]);
  12777                        delayed_move_time = millis();
  12778                        return true;
  12779                      }
  12780                    }
  12781                    // unpark extruder: 1) raise, 2) move into starting XY position, 3) lower
  12782                    for (uint8_t i = 0; i < 3; i++)
  12783                      planner.buffer_line(
  12784                        i == 0 ? raised_parked_position[X_AXIS] : current_position[X_AXIS],
  12785                        i == 0 ? raised_parked_position[Y_AXIS] : current_position[Y_AXIS],
  12786                        i == 2 ? current_position[Z_AXIS] : raised_parked_position[Z_AXIS],
  12787                        current_position[E_AXIS],
  12788                        i == 1 ? PLANNER_XY_FEEDRATE() : planner.max_feedrate_mm_s[Z_AXIS],
  12789                        active_extruder
  12790                      );
  12791                    delayed_move_time = 0;
  12792                    active_extruder_parked = false;
  12793                    #if ENABLED(DEBUG_LEVELING_FEATURE)
  12794                      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Clear active_extruder_parked");
  12795                    #endif
  12796                    break;
  12797                  case DXC_DUPLICATION_MODE:
  12798                    if (active_extruder == 0) {
  12799                      #if ENABLED(DEBUG_LEVELING_FEATURE)
  12800                        if (DEBUGGING(LEVELING)) {
  12801                          SERIAL_ECHOPAIR("Set planner X", LOGICAL_X_POSITION(inactive_extruder_x_pos));
  12802                          SERIAL_ECHOLNPAIR(" ... Line to X", current_position[X_AXIS] + duplicate_extruder_x_offset);
  12803                        }
  12804                      #endif
  12805                      // move duplicate extruder into correct duplication position.
  12806                      planner.set_position_mm(
  12807                        LOGICAL_X_POSITION(inactive_extruder_x_pos),
  12808                        current_position[Y_AXIS],
  12809                        current_position[Z_AXIS],
  12810                        current_position[E_AXIS]
  12811                      );
  12812                      planner.buffer_line(
  12813                        current_position[X_AXIS] + duplicate_extruder_x_offset,
  12814                        current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS],
  12815                        planner.max_feedrate_mm_s[X_AXIS], 1
  12816                      );
  12817                      SYNC_PLAN_POSITION_KINEMATIC();
  12818                      stepper.synchronize();
  12819                      extruder_duplication_enabled = true;
  12820                      active_extruder_parked = false;
  12821                      #if ENABLED(DEBUG_LEVELING_FEATURE)
  12822                        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Set extruder_duplication_enabled\nClear active_extruder_parked");
  12823                      #endif
  12824                    }
  12825                    else {
  12826                      #if ENABLED(DEBUG_LEVELING_FEATURE)
  12827                        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Active extruder not 0");
  12828                      #endif
  12829                    }
  12830                    break;
  12831                }
  12832              }
  12833              return false;
  12834            }
  12835          
  12836          #endif // DUAL_X_CARRIAGE
  12837          
  12838          /**
  12839           * Prepare a single move and get ready for the next one
  12840           *
  12841           * This may result in several calls to planner.buffer_line to
  12842           * do smaller moves for DELTA, SCARA, mesh moves, etc.
  12843           */

   \                                 In section .text, align 2, keep-with-next
  12844          void prepare_move_to_destination() {
   \                     _Z27prepare_move_to_destinationv: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
  12845            clamp_to_software_endstops(destination);
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable157
   \        0x6   0xF104 0x0018      ADD      R0,R4,#+24
   \        0xA   0x.... 0x....      BL       _Z26clamp_to_software_endstopsPf
  12846            refresh_cmd_timeout();
   \        0xE   0x.... 0x....      BL       _Z19refresh_cmd_timeoutv
  12847          
  12848            #if ENABLED(PREVENT_COLD_EXTRUSION)
  12849          
  12850              if (!DEBUGGING(DRYRUN)) {
   \       0x12   0x7860             LDRB     R0,[R4, #+1]
   \       0x14   0x0700             LSLS     R0,R0,#+28
   \       0x16   0xD429             BMI.N    ??prepare_move_to_destination_0
  12851                if (destination[E_AXIS] != current_position[E_AXIS]) {
   \       0x18   0x6A65             LDR      R5,[R4, #+36]
   \       0x1A   0x4628             MOV      R0,R5
   \       0x1C   0x6961             LDR      R1,[R4, #+20]
   \       0x1E   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0x22   0xD023             BEQ.N    ??prepare_move_to_destination_0
  12852                  if (thermalManager.tooColdToExtrude(active_extruder)) {
   \       0x24   0x78A0             LDRB     R0,[R4, #+2]
   \       0x26   0x.... 0x....      BL       _ZN11Temperature16tooColdToExtrudeEh
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD008             BEQ.N    ??prepare_move_to_destination_1
  12853                    current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
   \       0x2E   0x6165             STR      R5,[R4, #+20]
  12854                    SERIAL_ECHO_START;
   \       0x30   0x.... 0x....      LDR.W    R0,??DataTable163_2
   \       0x34   0x.... 0x....      BL       _Z14serialprintPGMPKc
  12855                    SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
   \       0x38   0x.... 0x....      ADR.W    R0,?_41
   \       0x3C   0x.... 0x....      BL       _Z14serialprintPGMPKc
  12856                  }
  12857                  #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
  12858                    if (labs(destination[E_AXIS] - current_position[E_AXIS]) > EXTRUDE_MAXLENGTH) {
                                    ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??prepare_move_to_destination_1: (+1)
   \       0x40   0x6A65             LDR      R5,[R4, #+36]
   \       0x42   0x4628             MOV      R0,R5
   \       0x44   0x6961             LDR      R1,[R4, #+20]
   \       0x46   0x.... 0x....      BL       __aeabi_fsub
   \       0x4A   0x.... 0x....      BL       __aeabi_f2iz
   \       0x4E   0x.... 0x....      BL       labs
   \       0x52   0xF240 0x112D      MOVW     R1,#+301
   \       0x56   0x4288             CMP      R0,R1
   \       0x58   0xDB08             BLT.N    ??prepare_move_to_destination_0
  12859                      current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
   \       0x5A   0x6165             STR      R5,[R4, #+20]
  12860                      SERIAL_ECHO_START;
   \       0x5C   0x.... 0x....      LDR.W    R0,??DataTable163_2
   \       0x60   0x.... 0x....      BL       _Z14serialprintPGMPKc
  12861                      SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
   \       0x64   0x.... 0x....      ADR.W    R0,?_42
   \       0x68   0x.... 0x....      BL       _Z14serialprintPGMPKc
  12862                    }
  12863                  #endif
  12864                }
  12865              }
  12866          
  12867            #endif
  12868          
  12869          //mks_delta    begin
  12870          /*
  12871            #if IS_KINEMATIC
  12872              if (prepare_kinematic_move_to(destination)) return;
  12873            #else
  12874              #if ENABLED(DUAL_X_CARRIAGE)
  12875                if (prepare_move_to_destination_dualx()) return;
  12876              #endif
  12877              if (prepare_move_to_destination_cartesian()) return;
  12878            #endif
  12879          */
  12880          	if(MACHINETPYE & IS_KINEMATIC)
   \                     ??prepare_move_to_destination_0: (+1)
   \       0x6C   0x.... 0x....      LDR.W    R0,??DataTable153
   \       0x70   0xF8B0 0x0058      LDRH     R0,[R0, #+88]
   \       0x74   0xF240 0x3102      MOVW     R1,#+770
   \       0x78   0x4208             TST      R0,R1
   \       0x7A   0xD006             BEQ.N    ??prepare_move_to_destination_2
  12881                  {
  12882            		if (prepare_kinematic_move_to(destination)) return;
   \       0x7C   0xF104 0x0018      ADD      R0,R4,#+24
   \       0x80   0x.... 0x....      BL       _Z25prepare_kinematic_move_toPf
   \       0x84   0x2800             CMP      R0,#+0
   \       0x86   0xD004             BEQ.N    ??prepare_move_to_destination_3
   \       0x88   0xBD31             POP      {R0,R4,R5,PC}
  12883                  }
  12884          	else
  12885          	{
  12886          		#if ENABLED(DUAL_X_CARRIAGE)
  12887          		  	if (prepare_move_to_destination_dualx()) return;
  12888          		#endif
  12889          			if (prepare_move_to_destination_cartesian()) return;
   \                     ??prepare_move_to_destination_2: (+1)
   \       0x8A   0x.... 0x....      BL       _Z37prepare_move_to_destination_cartesianv
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xD103             BNE.N    ??prepare_move_to_destination_4
  12890          	}
  12891            //mks_delta	 end
  12892          
  12893            set_current_to_destination();
   \                     ??prepare_move_to_destination_3: (+1)
   \       0x92   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \       0x96   0x.... 0x....      B.W      _Z26set_current_to_destinationv
   \                     ??prepare_move_to_destination_4: (+1)
   \       0x9A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
  12894          }
  12895          
  12896          #if ENABLED(ARC_SUPPORT)
  12897            /**
  12898             * Plan an arc in 2 dimensions
  12899             *
  12900             * The arc is approximated by generating many small linear segments.
  12901             * The length of each segment is configured in MM_PER_ARC_SEGMENT (Default 1mm)
  12902             * Arcs should only be made relatively large (over 5mm), as larger arcs with
  12903             * larger segments will tend to be more efficient. Your slicer should have
  12904             * options for G2/G3 arc generation. In future these options may be GCode tunable.
  12905             */

   \                                 In section .text, align 2, keep-with-next
  12906            void plan_arc(
  12907              float logical[XYZE], // Destination position
  12908              float *offset,       // Center of rotation relative to current_position
  12909              uint8_t clockwise    // Clockwise?
  12910            ) {
   \                     _Z8plan_arcPfS_h: (+1)
   \        0x0   0xE92D 0x4FF3      PUSH     {R0,R1,R4-R11,LR}
   \        0x4   0xB08D             SUB      SP,SP,#+52
   \        0x6   0x4607             MOV      R7,R0
   \        0x8   0x4614             MOV      R4,R2
  12911          
  12912              float r_X = -offset[X_AXIS],  // Radius vector from center to current location
   \        0xA   0x4608             MOV      R0,R1
   \        0xC   0x6800             LDR      R0,[R0, #+0]
   \        0xE   0xF080 0x4000      EOR      R0,R0,#0x80000000
   \       0x12   0x9003             STR      R0,[SP, #+12]
  12913                    r_Y = -offset[Y_AXIS];
   \       0x14   0x980E             LDR      R0,[SP, #+56]
   \       0x16   0x6840             LDR      R0,[R0, #+4]
   \       0x18   0xF080 0x4000      EOR      R0,R0,#0x80000000
   \       0x1C   0x9002             STR      R0,[SP, #+8]
  12914          
  12915              const float radius = HYPOT(r_X, r_Y),
   \       0x1E   0xF8DD 0x900C      LDR      R9,[SP, #+12]
   \       0x22   0x2602             MOVS     R6,#+2
   \       0x24   0xF04F 0x557E      MOV      R5,#+1065353216
   \       0x28   0x46A8             MOV      R8,R5
   \       0x2A   0xE004             B.N      ??plan_arc_0
   \                     ??plan_arc_1: (+1)
   \       0x2C   0x4648             MOV      R0,R9
   \       0x2E   0x4649             MOV      R1,R9
   \       0x30   0x.... 0x....      BL       __aeabi_fmul
   \       0x34   0x4681             MOV      R9,R0
   \                     ??plan_arc_0: (+1)
   \       0x36   0x07F0             LSLS     R0,R6,#+31
   \       0x38   0xD504             BPL.N    ??plan_arc_2
   \       0x3A   0x4640             MOV      R0,R8
   \       0x3C   0x4649             MOV      R1,R9
   \       0x3E   0x.... 0x....      BL       __aeabi_fmul
   \       0x42   0x4680             MOV      R8,R0
   \                     ??plan_arc_2: (+1)
   \       0x44   0x0876             LSRS     R6,R6,#+1
   \       0x46   0xD1F1             BNE.N    ??plan_arc_1
   \       0x48   0xF8DD 0xA008      LDR      R10,[SP, #+8]
   \       0x4C   0x2602             MOVS     R6,#+2
   \       0x4E   0x46A9             MOV      R9,R5
   \       0x50   0xE004             B.N      ??plan_arc_3
   \                     ??plan_arc_4: (+1)
   \       0x52   0x4650             MOV      R0,R10
   \       0x54   0x4651             MOV      R1,R10
   \       0x56   0x.... 0x....      BL       __aeabi_fmul
   \       0x5A   0x4682             MOV      R10,R0
   \                     ??plan_arc_3: (+1)
   \       0x5C   0x07F0             LSLS     R0,R6,#+31
   \       0x5E   0xD504             BPL.N    ??plan_arc_5
   \       0x60   0x4648             MOV      R0,R9
   \       0x62   0x4651             MOV      R1,R10
   \       0x64   0x.... 0x....      BL       __aeabi_fmul
   \       0x68   0x4681             MOV      R9,R0
   \                     ??plan_arc_5: (+1)
   \       0x6A   0x0876             LSRS     R6,R6,#+1
   \       0x6C   0xD1F1             BNE.N    ??plan_arc_4
   \       0x6E   0x9701             STR      R7,[SP, #+4]
   \       0x70   0x4640             MOV      R0,R8
   \       0x72   0x4649             MOV      R1,R9
   \       0x74   0x.... 0x....      BL       __aeabi_fadd
   \       0x78   0x.... 0x....      BL       sqrtf
   \       0x7C   0x4680             MOV      R8,R0
  12916                          center_X = current_position[X_AXIS] - r_X,
   \       0x7E   0x.... 0x....      LDR.W    R0,??DataTable157
   \       0x82   0x6880             LDR      R0,[R0, #+8]
   \       0x84   0x9006             STR      R0,[SP, #+24]
   \       0x86   0x9903             LDR      R1,[SP, #+12]
   \       0x88   0x.... 0x....      BL       __aeabi_fsub
   \       0x8C   0x9005             STR      R0,[SP, #+20]
  12917                          center_Y = current_position[Y_AXIS] - r_Y,
   \       0x8E   0x.... 0x....      LDR.W    R0,??DataTable157
   \       0x92   0x68C6             LDR      R6,[R0, #+12]
   \       0x94   0x4630             MOV      R0,R6
   \       0x96   0x9902             LDR      R1,[SP, #+8]
   \       0x98   0x.... 0x....      BL       __aeabi_fsub
   \       0x9C   0x9004             STR      R0,[SP, #+16]
  12918                          rt_X = logical[X_AXIS] - center_X,
   \       0x9E   0x9801             LDR      R0,[SP, #+4]
   \       0xA0   0x6800             LDR      R0,[R0, #+0]
   \       0xA2   0x9905             LDR      R1,[SP, #+20]
   \       0xA4   0x.... 0x....      BL       __aeabi_fsub
   \       0xA8   0x4682             MOV      R10,R0
  12919                          rt_Y = logical[Y_AXIS] - center_Y,
   \       0xAA   0x9801             LDR      R0,[SP, #+4]
   \       0xAC   0x6840             LDR      R0,[R0, #+4]
   \       0xAE   0x9904             LDR      R1,[SP, #+16]
   \       0xB0   0x.... 0x....      BL       __aeabi_fsub
   \       0xB4   0x4683             MOV      R11,R0
  12920                          linear_travel = logical[Z_AXIS] - current_position[Z_AXIS],
   \       0xB6   0x.... 0x....      LDR.W    R0,??DataTable157
   \       0xBA   0x6900             LDR      R0,[R0, #+16]
   \       0xBC   0x9007             STR      R0,[SP, #+28]
   \       0xBE   0x9801             LDR      R0,[SP, #+4]
   \       0xC0   0x6880             LDR      R0,[R0, #+8]
   \       0xC2   0x9907             LDR      R1,[SP, #+28]
   \       0xC4   0x.... 0x....      BL       __aeabi_fsub
   \       0xC8   0x4681             MOV      R9,R0
  12921                          extruder_travel = logical[E_AXIS] - current_position[E_AXIS];
   \       0xCA   0x.... 0x....      LDR.W    R0,??DataTable157
   \       0xCE   0x6947             LDR      R7,[R0, #+20]
   \       0xD0   0x9801             LDR      R0,[SP, #+4]
   \       0xD2   0x68C0             LDR      R0,[R0, #+12]
   \       0xD4   0x4639             MOV      R1,R7
   \       0xD6   0x.... 0x....      BL       __aeabi_fsub
   \       0xDA   0x900C             STR      R0,[SP, #+48]
  12922          
  12923              // CCW angle of rotation between position and target from the circle center. Only one atan2() trig computation required.
  12924              float angular_travel = atan2(r_X * rt_Y - r_Y * rt_X, r_X * rt_X + r_Y * rt_Y);
   \       0xDC   0x9803             LDR      R0,[SP, #+12]
   \       0xDE   0x4651             MOV      R1,R10
   \       0xE0   0x.... 0x....      BL       __aeabi_fmul
   \       0xE4   0x9000             STR      R0,[SP, #+0]
   \       0xE6   0x9802             LDR      R0,[SP, #+8]
   \       0xE8   0x4659             MOV      R1,R11
   \       0xEA   0x.... 0x....      BL       __aeabi_fmul
   \       0xEE   0x9900             LDR      R1,[SP, #+0]
   \       0xF0   0x.... 0x....      BL       __aeabi_fadd
   \       0xF4   0x4601             MOV      R1,R0
   \       0xF6   0x9100             STR      R1,[SP, #+0]
   \       0xF8   0x9803             LDR      R0,[SP, #+12]
   \       0xFA   0x4659             MOV      R1,R11
   \       0xFC   0x.... 0x....      BL       __aeabi_fmul
   \      0x100   0x4683             MOV      R11,R0
   \      0x102   0x9802             LDR      R0,[SP, #+8]
   \      0x104   0x4651             MOV      R1,R10
   \      0x106   0x.... 0x....      BL       __aeabi_fmul
   \      0x10A   0x4601             MOV      R1,R0
   \      0x10C   0x4658             MOV      R0,R11
   \      0x10E   0x.... 0x....      BL       __aeabi_fsub
   \      0x112   0x9900             LDR      R1,[SP, #+0]
   \      0x114   0x.... 0x....      BL       atan2f
   \      0x118   0x4682             MOV      R10,R0
  12925              if (angular_travel < 0) angular_travel += RADIANS(360);
   \      0x11A   0x2100             MOVS     R1,#+0
   \      0x11C   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x120   0xD20A             BCS.N    ??plan_arc_6
   \      0x122   0x.... 0x....      BL       __aeabi_f2d
   \      0x126   0x.... 0x....      LDR.W    R2,??DataTable166_1  ;; 0x54442d18
   \      0x12A   0x.... 0x....      LDR.W    R3,??DataTable166_2  ;; 0x401921fb
   \      0x12E   0x.... 0x....      BL       __aeabi_dadd
   \      0x132   0x.... 0x....      BL       __aeabi_d2f
   \      0x136   0x4682             MOV      R10,R0
  12926              if (clockwise) angular_travel -= RADIANS(360);
   \                     ??plan_arc_6: (+1)
   \      0x138   0x2C00             CMP      R4,#+0
   \      0x13A   0xD00B             BEQ.N    ??plan_arc_7
   \      0x13C   0x4650             MOV      R0,R10
   \      0x13E   0x.... 0x....      BL       __aeabi_f2d
   \      0x142   0x.... 0x....      LDR.W    R2,??DataTable166_1  ;; 0x54442d18
   \      0x146   0x.... 0x....      LDR.W    R3,??DataTable166_3  ;; 0xc01921fb
   \      0x14A   0x.... 0x....      BL       __aeabi_dadd
   \      0x14E   0x.... 0x....      BL       __aeabi_d2f
   \      0x152   0x4682             MOV      R10,R0
  12927          
  12928              // Make a circle if the angular rotation is 0
  12929              if (angular_travel == 0 && current_position[X_AXIS] == logical[X_AXIS] && current_position[Y_AXIS] == logical[Y_AXIS])
   \                     ??plan_arc_7: (+1)
   \      0x154   0x4650             MOV      R0,R10
   \      0x156   0x2100             MOVS     R1,#+0
   \      0x158   0x.... 0x....      BL       __aeabi_cfcmpeq
   \      0x15C   0xD10D             BNE.N    ??plan_arc_8
   \      0x15E   0x9806             LDR      R0,[SP, #+24]
   \      0x160   0x9901             LDR      R1,[SP, #+4]
   \      0x162   0x6809             LDR      R1,[R1, #+0]
   \      0x164   0x.... 0x....      BL       __aeabi_cfcmpeq
   \      0x168   0xD107             BNE.N    ??plan_arc_8
   \      0x16A   0x4630             MOV      R0,R6
   \      0x16C   0x9901             LDR      R1,[SP, #+4]
   \      0x16E   0x6849             LDR      R1,[R1, #+4]
   \      0x170   0x.... 0x....      BL       __aeabi_cfcmpeq
   \      0x174   0xD101             BNE.N    ??plan_arc_8
  12930                angular_travel += RADIANS(360);
   \      0x176   0x.... 0x....      LDR.W    R10,??DataTable166_4  ;; 0x40c90fdb
  12931          
  12932              float mm_of_travel = HYPOT(angular_travel * radius, fabs(linear_travel));
   \                     ??plan_arc_8: (+1)
   \      0x17A   0x4650             MOV      R0,R10
   \      0x17C   0x4641             MOV      R1,R8
   \      0x17E   0x.... 0x....      BL       __aeabi_fmul
   \      0x182   0x4680             MOV      R8,R0
   \      0x184   0x2402             MOVS     R4,#+2
   \      0x186   0x462E             MOV      R6,R5
   \      0x188   0xE004             B.N      ??plan_arc_9
   \                     ??plan_arc_10: (+1)
   \      0x18A   0x4640             MOV      R0,R8
   \      0x18C   0x4641             MOV      R1,R8
   \      0x18E   0x.... 0x....      BL       __aeabi_fmul
   \      0x192   0x4680             MOV      R8,R0
   \                     ??plan_arc_9: (+1)
   \      0x194   0x07E0             LSLS     R0,R4,#+31
   \      0x196   0xD504             BPL.N    ??plan_arc_11
   \      0x198   0x4630             MOV      R0,R6
   \      0x19A   0x4641             MOV      R1,R8
   \      0x19C   0x.... 0x....      BL       __aeabi_fmul
   \      0x1A0   0x4606             MOV      R6,R0
   \                     ??plan_arc_11: (+1)
   \      0x1A2   0x0864             LSRS     R4,R4,#+1
   \      0x1A4   0xD1F1             BNE.N    ??plan_arc_10
   \      0x1A6   0xF029 0x4800      BIC      R8,R9,#0x80000000
   \      0x1AA   0x2402             MOVS     R4,#+2
   \      0x1AC   0x46AB             MOV      R11,R5
   \      0x1AE   0xE004             B.N      ??plan_arc_12
   \                     ??plan_arc_13: (+1)
   \      0x1B0   0x4640             MOV      R0,R8
   \      0x1B2   0x4641             MOV      R1,R8
   \      0x1B4   0x.... 0x....      BL       __aeabi_fmul
   \      0x1B8   0x4680             MOV      R8,R0
   \                     ??plan_arc_12: (+1)
   \      0x1BA   0x07E0             LSLS     R0,R4,#+31
   \      0x1BC   0xD504             BPL.N    ??plan_arc_14
   \      0x1BE   0x4658             MOV      R0,R11
   \      0x1C0   0x4641             MOV      R1,R8
   \      0x1C2   0x.... 0x....      BL       __aeabi_fmul
   \      0x1C6   0x4683             MOV      R11,R0
   \                     ??plan_arc_14: (+1)
   \      0x1C8   0x0864             LSRS     R4,R4,#+1
   \      0x1CA   0xD1F1             BNE.N    ??plan_arc_13
   \      0x1CC   0x4630             MOV      R0,R6
   \      0x1CE   0x4659             MOV      R1,R11
   \      0x1D0   0x.... 0x....      BL       __aeabi_fadd
   \      0x1D4   0x.... 0x....      BL       sqrtf
  12933              if (mm_of_travel < 0.001) return;
   \      0x1D8   0x.... 0x....      LDR.W    R1,??DataTable166_5  ;; 0x3a83126f
   \      0x1DC   0x.... 0x....      BL       __aeabi_cfcmple
   \      0x1E0   0xF0C0 0x80FD      BCC.W    ??plan_arc_15
  12934          
  12935              uint16_t segments = floor(mm_of_travel / (MM_PER_ARC_SEGMENT));
                                         ^
Warning[Pa093]: implicit conversion from floating point to integer
   \      0x1E4   0x.... 0x....      BL       floorf
   \      0x1E8   0x.... 0x....      BL       __aeabi_f2iz
   \      0x1EC   0x4604             MOV      R4,R0
   \      0x1EE   0xB2A4             UXTH     R4,R4
  12936              if (segments == 0) segments = 1;
   \      0x1F0   0x2C00             CMP      R4,#+0
   \      0x1F2   0xD100             BNE.N    ??plan_arc_16
   \      0x1F4   0x2401             MOVS     R4,#+1
  12937          
  12938              /**
  12939               * Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,
  12940               * and phi is the angle of rotation. Based on the solution approach by Jens Geisler.
  12941               *     r_T = [cos(phi) -sin(phi);
  12942               *            sin(phi)  cos(phi)] * r ;
  12943               *
  12944               * For arc generation, the center of the circle is the axis of rotation and the radius vector is
  12945               * defined from the circle center to the initial position. Each line segment is formed by successive
  12946               * vector rotations. This requires only two cos() and sin() computations to form the rotation
  12947               * matrix for the duration of the entire arc. Error may accumulate from numerical round-off, since
  12948               * all double numbers are single precision on the Arduino. (True double precision will not have
  12949               * round off issues for CNC applications.) Single precision error can accumulate to be greater than
  12950               * tool precision in some cases. Therefore, arc path correction is implemented.
  12951               *
  12952               * Small angle approximation may be used to reduce computation overhead further. This approximation
  12953               * holds for everything, but very small circles and large MM_PER_ARC_SEGMENT values. In other words,
  12954               * theta_per_segment would need to be greater than 0.1 rad and N_ARC_CORRECTION would need to be large
  12955               * to cause an appreciable drift error. N_ARC_CORRECTION~=25 is more than small enough to correct for
  12956               * numerical drift error. N_ARC_CORRECTION may be on the order a hundred(s) before error becomes an
  12957               * issue for CNC machines with the single precision Arduino calculations.
  12958               *
  12959               * This approximation also allows plan_arc to immediately insert a line segment into the planner
  12960               * without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
  12961               * a correction, the planner should have caught up to the lag caused by the initial plan_arc overhead.
  12962               * This is important when there are successive arc motions.
  12963               */
  12964              // Vector rotation matrix values
  12965              float arc_target[XYZE];
  12966              const float theta_per_segment = angular_travel / segments,
   \                     ??plan_arc_16: (+1)
   \      0x1F6   0x4620             MOV      R0,R4
   \      0x1F8   0x.... 0x....      BL       __aeabi_ui2f
   \      0x1FC   0x4606             MOV      R6,R0
   \      0x1FE   0x4650             MOV      R0,R10
   \      0x200   0x4631             MOV      R1,R6
   \      0x202   0x.... 0x....      BL       __aeabi_fdiv
   \      0x206   0x4680             MOV      R8,R0
  12967                          linear_per_segment = linear_travel / segments,
   \      0x208   0x4648             MOV      R0,R9
   \      0x20A   0x4631             MOV      R1,R6
   \      0x20C   0x.... 0x....      BL       __aeabi_fdiv
   \      0x210   0x9006             STR      R0,[SP, #+24]
  12968                          extruder_per_segment = extruder_travel / segments,
   \      0x212   0x980C             LDR      R0,[SP, #+48]
   \      0x214   0x4631             MOV      R1,R6
   \      0x216   0x.... 0x....      BL       __aeabi_fdiv
   \      0x21A   0x4606             MOV      R6,R0
  12969                          sin_T = theta_per_segment,
  12970                          cos_T = 1 - 0.5 * sq(theta_per_segment); // Small angle approximation
   \      0x21C   0x46C2             MOV      R10,R8
   \      0x21E   0xF04F 0x0902      MOV      R9,#+2
   \      0x222   0xE004             B.N      ??plan_arc_17
   \                     ??plan_arc_18: (+1)
   \      0x224   0x4650             MOV      R0,R10
   \      0x226   0x4651             MOV      R1,R10
   \      0x228   0x.... 0x....      BL       __aeabi_fmul
   \      0x22C   0x4682             MOV      R10,R0
   \                     ??plan_arc_17: (+1)
   \      0x22E   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \      0x232   0xD504             BPL.N    ??plan_arc_19
   \      0x234   0x4628             MOV      R0,R5
   \      0x236   0x4651             MOV      R1,R10
   \      0x238   0x.... 0x....      BL       __aeabi_fmul
   \      0x23C   0x4605             MOV      R5,R0
   \                     ??plan_arc_19: (+1)
   \      0x23E   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \      0x242   0xD1EF             BNE.N    ??plan_arc_18
   \      0x244   0x4628             MOV      R0,R5
   \      0x246   0x.... 0x....      BL       __aeabi_f2d
   \      0x24A   0x2200             MOVS     R2,#+0
   \      0x24C   0x.... 0x....      LDR.W    R3,??DataTable166_6  ;; 0x3fe00000
   \      0x250   0x.... 0x....      BL       __aeabi_dmul
   \      0x254   0x4602             MOV      R2,R0
   \      0x256   0x460B             MOV      R3,R1
   \      0x258   0x2000             MOVS     R0,#+0
   \      0x25A   0x.... 0x....      LDR.W    R1,??DataTable167  ;; 0x3ff00000
   \      0x25E   0x.... 0x....      BL       __aeabi_dsub
   \      0x262   0x.... 0x....      BL       __aeabi_d2f
   \      0x266   0x4605             MOV      R5,R0
  12971          
  12972              // Initialize the linear axis
  12973              arc_target[Z_AXIS] = current_position[Z_AXIS];
   \      0x268   0x9807             LDR      R0,[SP, #+28]
   \      0x26A   0x900A             STR      R0,[SP, #+40]
  12974          
  12975              // Initialize the extruder axis
  12976              arc_target[E_AXIS] = current_position[E_AXIS];
   \      0x26C   0x970B             STR      R7,[SP, #+44]
  12977          
  12978              const float fr_mm_s = MMS_SCALED(feedrate_mm_s);
   \      0x26E   0x.... 0x....      LDR.W    R0,??DataTable157
   \      0x272   0x6F80             LDR      R0,[R0, #+120]
   \      0x274   0x.... 0x....      BL       __aeabi_i2f
   \      0x278   0x.... 0x....      LDR.W    R1,??DataTable157
   \      0x27C   0x6F49             LDR      R1,[R1, #+116]
   \      0x27E   0x.... 0x....      BL       __aeabi_fmul
   \      0x282   0x.... 0x....      BL       __aeabi_f2d
   \      0x286   0x.... 0x....      LDR.W    R2,??DataTable167_1  ;; 0x47ae147b
   \      0x28A   0x.... 0x....      LDR.W    R3,??DataTable167_2  ;; 0x3f847ae1
   \      0x28E   0x.... 0x....      BL       __aeabi_dmul
   \      0x292   0x.... 0x....      BL       __aeabi_d2f
   \      0x296   0x9000             STR      R0,[SP, #+0]
  12979          
  12980              millis_t next_idle_ms = millis() + 200UL;
   \      0x298   0x.... 0x....      BL       HAL_GetTick
   \      0x29C   0x30C8             ADDS     R0,R0,#+200
  12981          
  12982              int8_t count = 0;
   \      0x29E   0x2200             MOVS     R2,#+0
  12983              for (uint16_t i = 1; i < segments; i++) { // Iterate (segments-1) times
   \      0x2A0   0x2101             MOVS     R1,#+1
   \      0x2A2   0x9F03             LDR      R7,[SP, #+12]
   \      0x2A4   0xF8DD 0x9008      LDR      R9,[SP, #+8]
   \      0x2A8   0x9407             STR      R4,[SP, #+28]
   \      0x2AA   0x9603             STR      R6,[SP, #+12]
   \      0x2AC   0x9502             STR      R5,[SP, #+8]
   \      0x2AE   0x4605             MOV      R5,R0
   \      0x2B0   0x4616             MOV      R6,R2
   \      0x2B2   0x460C             MOV      R4,R1
   \                     ??plan_arc_20: (+1)
   \      0x2B4   0x9807             LDR      R0,[SP, #+28]
   \      0x2B6   0x4284             CMP      R4,R0
   \      0x2B8   0xF280 0x8089      BGE.W    ??plan_arc_21
  12984          
  12985                thermalManager.manage_heater();
   \      0x2BC   0x.... 0x....      BL       _ZN11Temperature13manage_heaterEv
  12986                if (ELAPSED(millis(), next_idle_ms)) {
   \      0x2C0   0x.... 0x....      BL       HAL_GetTick
   \      0x2C4   0x1B40             SUBS     R0,R0,R5
   \      0x2C6   0xD406             BMI.N    ??plan_arc_22
  12987                  next_idle_ms = millis() + 200UL;
   \      0x2C8   0x.... 0x....      BL       HAL_GetTick
   \      0x2CC   0x4605             MOV      R5,R0
   \      0x2CE   0x35C8             ADDS     R5,R5,#+200
  12988                  idle();
   \      0x2D0   0x2000             MOVS     R0,#+0
   \      0x2D2   0x.... 0x....      BL       _Z4idleb
  12989                }
  12990          
  12991                if (++count < N_ARC_CORRECTION) {
   \                     ??plan_arc_22: (+1)
   \      0x2D6   0x1C76             ADDS     R6,R6,#+1
   \      0x2D8   0x4630             MOV      R0,R6
   \      0x2DA   0xB240             SXTB     R0,R0
   \      0x2DC   0x2819             CMP      R0,#+25
   \      0x2DE   0xDB32             BLT.N    ??plan_arc_23
  12992                  // Apply vector rotation matrix to previous r_X / 1
  12993                  const float r_new_Y = r_X * sin_T + r_Y * cos_T;
  12994                  r_X = r_X * cos_T - r_Y * sin_T;
  12995                  r_Y = r_new_Y;
  12996                }
  12997                else {
  12998                  // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments.
  12999                  // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
  13000                  // To reduce stuttering, the sin and cos could be computed at different times.
  13001                  // For now, compute both at the same time.
  13002                  const float cos_Ti = cos(i * theta_per_segment),
   \      0x2E0   0x4620             MOV      R0,R4
   \      0x2E2   0x.... 0x....      BL       __aeabi_ui2f
   \      0x2E6   0x4641             MOV      R1,R8
   \      0x2E8   0x.... 0x....      BL       __aeabi_fmul
   \      0x2EC   0x4607             MOV      R7,R0
   \      0x2EE   0x.... 0x....      BL       cosf
   \      0x2F2   0x4606             MOV      R6,R0
  13003                              sin_Ti = sin(i * theta_per_segment);
   \      0x2F4   0x4638             MOV      R0,R7
   \      0x2F6   0x.... 0x....      BL       sinf
   \      0x2FA   0x4681             MOV      R9,R0
  13004                  r_X = -offset[X_AXIS] * cos_Ti + offset[Y_AXIS] * sin_Ti;
   \      0x2FC   0x980E             LDR      R0,[SP, #+56]
   \      0x2FE   0xF8D0 0xA004      LDR      R10,[R0, #+4]
   \      0x302   0xF8D0 0xB000      LDR      R11,[R0, #+0]
   \      0x306   0x4650             MOV      R0,R10
   \      0x308   0x4649             MOV      R1,R9
   \      0x30A   0x.... 0x....      BL       __aeabi_fmul
   \      0x30E   0x4607             MOV      R7,R0
   \      0x310   0x4658             MOV      R0,R11
   \      0x312   0x4631             MOV      R1,R6
   \      0x314   0x.... 0x....      BL       __aeabi_fmul
   \      0x318   0x4601             MOV      R1,R0
   \      0x31A   0x4638             MOV      R0,R7
   \      0x31C   0x.... 0x....      BL       __aeabi_fsub
   \      0x320   0x4607             MOV      R7,R0
  13005                  r_Y = -offset[X_AXIS] * sin_Ti - offset[Y_AXIS] * cos_Ti;
   \      0x322   0x4658             MOV      R0,R11
   \      0x324   0x4649             MOV      R1,R9
   \      0x326   0x.... 0x....      BL       __aeabi_fmul
   \      0x32A   0xF080 0x4000      EOR      R0,R0,#0x80000000
   \      0x32E   0x4681             MOV      R9,R0
   \      0x330   0x4650             MOV      R0,R10
   \      0x332   0x4631             MOV      R1,R6
   \      0x334   0x.... 0x....      BL       __aeabi_fmul
   \      0x338   0x4601             MOV      R1,R0
   \      0x33A   0x4648             MOV      R0,R9
   \      0x33C   0x.... 0x....      BL       __aeabi_fsub
   \      0x340   0x4681             MOV      R9,R0
  13006                  count = 0;
   \      0x342   0x2600             MOVS     R6,#+0
   \      0x344   0xE01B             B.N      ??plan_arc_24
  13007                }
   \                     ??plan_arc_23: (+1)
   \      0x346   0x4638             MOV      R0,R7
   \      0x348   0x4641             MOV      R1,R8
   \      0x34A   0x.... 0x....      BL       __aeabi_fmul
   \      0x34E   0x4682             MOV      R10,R0
   \      0x350   0x9802             LDR      R0,[SP, #+8]
   \      0x352   0x4649             MOV      R1,R9
   \      0x354   0x.... 0x....      BL       __aeabi_fmul
   \      0x358   0x4651             MOV      R1,R10
   \      0x35A   0x.... 0x....      BL       __aeabi_fadd
   \      0x35E   0x4682             MOV      R10,R0
   \      0x360   0x9802             LDR      R0,[SP, #+8]
   \      0x362   0x4639             MOV      R1,R7
   \      0x364   0x.... 0x....      BL       __aeabi_fmul
   \      0x368   0x4607             MOV      R7,R0
   \      0x36A   0x4648             MOV      R0,R9
   \      0x36C   0x4641             MOV      R1,R8
   \      0x36E   0x.... 0x....      BL       __aeabi_fmul
   \      0x372   0x4601             MOV      R1,R0
   \      0x374   0x4638             MOV      R0,R7
   \      0x376   0x.... 0x....      BL       __aeabi_fsub
   \      0x37A   0x4607             MOV      R7,R0
   \      0x37C   0x46D1             MOV      R9,R10
  13008          
  13009                // Update arc_target location
  13010                arc_target[X_AXIS] = center_X + r_X;
   \                     ??plan_arc_24: (+1)
   \      0x37E   0x9805             LDR      R0,[SP, #+20]
   \      0x380   0x4639             MOV      R1,R7
   \      0x382   0x.... 0x....      BL       __aeabi_fadd
   \      0x386   0x9008             STR      R0,[SP, #+32]
  13011                arc_target[Y_AXIS] = center_Y + r_Y;
   \      0x388   0xF10D 0x0A20      ADD      R10,SP,#+32
   \      0x38C   0x9804             LDR      R0,[SP, #+16]
   \      0x38E   0x4649             MOV      R1,R9
   \      0x390   0x.... 0x....      BL       __aeabi_fadd
   \      0x394   0xF8CA 0x0004      STR      R0,[R10, #+4]
  13012                arc_target[Z_AXIS] += linear_per_segment;
   \      0x398   0xF8DA 0x0008      LDR      R0,[R10, #+8]
   \      0x39C   0x9906             LDR      R1,[SP, #+24]
   \      0x39E   0x.... 0x....      BL       __aeabi_fadd
   \      0x3A2   0xF8CA 0x0008      STR      R0,[R10, #+8]
  13013                arc_target[E_AXIS] += extruder_per_segment;
   \      0x3A6   0xF8DA 0x000C      LDR      R0,[R10, #+12]
   \      0x3AA   0x9903             LDR      R1,[SP, #+12]
   \      0x3AC   0x.... 0x....      BL       __aeabi_fadd
   \      0x3B0   0xF8CA 0x000C      STR      R0,[R10, #+12]
  13014          
  13015                clamp_to_software_endstops(arc_target);
   \      0x3B4   0xA808             ADD      R0,SP,#+32
   \      0x3B6   0x.... 0x....      BL       _Z26clamp_to_software_endstopsPf
  13016          
  13017                planner.buffer_line_kinematic(arc_target, fr_mm_s, active_extruder);
   \      0x3BA   0x.... 0x....      LDR.W    R0,??DataTable157
   \      0x3BE   0x7882             LDRB     R2,[R0, #+2]
   \      0x3C0   0x4669             MOV      R1,SP
   \      0x3C2   0xA808             ADD      R0,SP,#+32
   \      0x3C4   0x.... 0x....      BL       _ZN7Planner21buffer_line_kinematicEPKfRS0_h
  13018              }
   \      0x3C8   0x1C64             ADDS     R4,R4,#+1
   \      0x3CA   0xB2A4             UXTH     R4,R4
   \      0x3CC   0xE772             B.N      ??plan_arc_20
  13019          
  13020              // Ensure last segment arrives at target location.
  13021              planner.buffer_line_kinematic(logical, fr_mm_s, active_extruder);
   \                     ??plan_arc_21: (+1)
   \      0x3CE   0x....             LDR.N    R0,??DataTable157
   \      0x3D0   0x7882             LDRB     R2,[R0, #+2]
   \      0x3D2   0x4669             MOV      R1,SP
   \      0x3D4   0x9801             LDR      R0,[SP, #+4]
   \      0x3D6   0x.... 0x....      BL       _ZN7Planner21buffer_line_kinematicEPKfRS0_h
  13022          
  13023              // As far as the parser is concerned, the position is now == target. In reality the
  13024              // motion control system might still be processing the action and the real tool position
  13025              // in any intermediate location.
  13026              set_current_to_destination();
   \      0x3DA   0x.... 0x....      BL       _Z26set_current_to_destinationv
  13027            }
   \                     ??plan_arc_15: (+1)
   \      0x3DE   0xB00F             ADD      SP,SP,#+60
   \      0x3E0   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
  13028          #endif
  13029          
  13030          #if ENABLED(BEZIER_CURVE_SUPPORT)
  13031          
  13032            void plan_cubic_move(const float offset[4]) {
  13033              cubic_b_spline(current_position, destination, offset, MMS_SCALED(feedrate_mm_s), active_extruder);
  13034          
  13035              // As far as the parser is concerned, the position is now == destination. In reality the
  13036              // motion control system might still be processing the action and the real tool position
  13037              // in any intermediate location.
  13038              set_current_to_destination();
  13039            }
  13040          
  13041          #endif // BEZIER_CURVE_SUPPORT
  13042          
  13043          #if ENABLED(USE_CONTROLLER_FAN)
  13044          
  13045            void controllerFan() {
  13046              static millis_t lastMotorOn = 0, // Last time a motor was turned on
  13047                              nextMotorCheck = 0; // Last time the state was checked
  13048              const millis_t ms = millis();
  13049              if (ELAPSED(ms, nextMotorCheck)) {
  13050                nextMotorCheck = ms + 2500UL; // Not a time critical function, so only check every 2.5s
  13051                if (X_ENABLE_READ == X_ENABLE_ON || Y_ENABLE_READ == Y_ENABLE_ON || Z_ENABLE_READ == Z_ENABLE_ON || thermalManager.soft_pwm_bed > 0
  13052                    || E0_ENABLE_READ == E_ENABLE_ON // If any of the drivers are enabled...
  13053                    #if E_STEPPERS > 1
  13054                      || E1_ENABLE_READ == E_ENABLE_ON
  13055                      #if HAS_X2_ENABLE
  13056                        || X2_ENABLE_READ == X_ENABLE_ON
  13057                      #endif
  13058                      #if E_STEPPERS > 2
  13059                        || E2_ENABLE_READ == E_ENABLE_ON
  13060                        #if E_STEPPERS > 3
  13061                          || E3_ENABLE_READ == E_ENABLE_ON
  13062                          #if E_STEPPERS > 4
  13063                            || E4_ENABLE_READ == E_ENABLE_ON
  13064                          #endif // E_STEPPERS > 4
  13065                        #endif // E_STEPPERS > 3
  13066                      #endif // E_STEPPERS > 2
  13067                    #endif // E_STEPPERS > 1
  13068                ) {
  13069                  lastMotorOn = ms; //... set time to NOW so the fan will turn on
  13070                }
  13071          
  13072                // Fan off if no steppers have been enabled for CONTROLLERFAN_SECS seconds
  13073                uint8_t speed = (!lastMotorOn || ELAPSED(ms, lastMotorOn + (CONTROLLERFAN_SECS) * 1000UL)) ? 0 : CONTROLLERFAN_SPEED;
  13074          
  13075                // allows digital or PWM fan output to be used (see M42 handling)
  13076                WRITE(CONTROLLER_FAN_PIN, speed);
  13077                analogWrite(CONTROLLER_FAN_PIN, speed);
  13078              }
  13079            }
  13080          
  13081          #endif // USE_CONTROLLER_FAN
  13082          
  13083          //#if ENABLED(MORGAN_SCARA)	//mks_delta
  13084          #if 1
  13085            /**
  13086             * Morgan SCARA Forward Kinematics. Results in cartes[].
  13087             * Maths and first version by QHARLEY.
  13088             * Integrated into Marlin and slightly restructured by Joachim Cerny.
  13089             */

   \                                 In section .text, align 2, keep-with-next
  13090            void forward_kinematics_SCARA(const float &a, const float &b) {
   \                     _Z24forward_kinematics_SCARARKfS0_: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x4681             MOV      R9,R0
   \        0x6   0x468A             MOV      R10,R1
  13091          
  13092              float a_sin = sin(RADIANS(a)) * L1,
   \        0x8   0x2600             MOVS     R6,#+0
   \        0xA   0x.... 0x....      LDR.W    R7,??DataTable169  ;; 0x4062c000
   \        0xE   0x.... 0x....      LDR.W    R4,??DataTable166_1  ;; 0x54442d18
   \       0x12   0x.... 0x....      LDR.W    R5,??DataTable169_1  ;; 0x400921fb
   \       0x16   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x1A   0x.... 0x....      BL       __aeabi_f2d
   \       0x1E   0x4622             MOV      R2,R4
   \       0x20   0x462B             MOV      R3,R5
   \       0x22   0x.... 0x....      BL       __aeabi_dmul
   \       0x26   0x4632             MOV      R2,R6
   \       0x28   0x.... 0x....      LDR.W    R3,??DataTable169_2  ;; 0x40668000
   \       0x2C   0x.... 0x....      BL       __aeabi_ddiv
   \       0x30   0x.... 0x....      BL       sin
   \       0x34   0x4632             MOV      R2,R6
   \       0x36   0x463B             MOV      R3,R7
   \       0x38   0x.... 0x....      BL       __aeabi_dmul
   \       0x3C   0x.... 0x....      BL       __aeabi_d2f
   \       0x40   0x4680             MOV      R8,R0
  13093                    a_cos = cos(RADIANS(a)) * L1,
   \       0x42   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x46   0x.... 0x....      BL       __aeabi_f2d
   \       0x4A   0x4622             MOV      R2,R4
   \       0x4C   0x462B             MOV      R3,R5
   \       0x4E   0x.... 0x....      BL       __aeabi_dmul
   \       0x52   0x4632             MOV      R2,R6
   \       0x54   0x.... 0x....      LDR.W    R3,??DataTable169_2  ;; 0x40668000
   \       0x58   0x.... 0x....      BL       __aeabi_ddiv
   \       0x5C   0x.... 0x....      BL       cos
   \       0x60   0x4632             MOV      R2,R6
   \       0x62   0x463B             MOV      R3,R7
   \       0x64   0x.... 0x....      BL       __aeabi_dmul
   \       0x68   0x.... 0x....      BL       __aeabi_d2f
   \       0x6C   0x4681             MOV      R9,R0
  13094                    b_sin = sin(RADIANS(b)) * L2,
   \       0x6E   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0x72   0x.... 0x....      BL       __aeabi_f2d
   \       0x76   0x4622             MOV      R2,R4
   \       0x78   0x462B             MOV      R3,R5
   \       0x7A   0x.... 0x....      BL       __aeabi_dmul
   \       0x7E   0x4632             MOV      R2,R6
   \       0x80   0x.... 0x....      LDR.W    R3,??DataTable169_2  ;; 0x40668000
   \       0x84   0x.... 0x....      BL       __aeabi_ddiv
   \       0x88   0x.... 0x....      BL       sin
   \       0x8C   0x4632             MOV      R2,R6
   \       0x8E   0x463B             MOV      R3,R7
   \       0x90   0x.... 0x....      BL       __aeabi_dmul
   \       0x94   0x.... 0x....      BL       __aeabi_d2f
   \       0x98   0x4641             MOV      R1,R8
   \       0x9A   0x.... 0x....      BL       __aeabi_fadd
   \       0x9E   0x4680             MOV      R8,R0
  13095                    b_cos = cos(RADIANS(b)) * L2;
   \       0xA0   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0xA4   0x.... 0x....      BL       __aeabi_f2d
   \       0xA8   0x4622             MOV      R2,R4
   \       0xAA   0x462B             MOV      R3,R5
   \       0xAC   0x.... 0x....      BL       __aeabi_dmul
   \       0xB0   0x4632             MOV      R2,R6
   \       0xB2   0x.... 0x....      LDR.W    R3,??DataTable169_2  ;; 0x40668000
   \       0xB6   0x.... 0x....      BL       __aeabi_ddiv
   \       0xBA   0x.... 0x....      BL       cos
   \       0xBE   0x4632             MOV      R2,R6
   \       0xC0   0x463B             MOV      R3,R7
   \       0xC2   0x.... 0x....      BL       __aeabi_dmul
   \       0xC6   0x.... 0x....      BL       __aeabi_d2f
  13096          
  13097              cartes[X_AXIS] = a_cos + b_cos + SCARA_OFFSET_X;  //theta
   \       0xCA   0x.... 0x....      LDR.W    R4,??DataTable169_3
   \       0xCE   0x4649             MOV      R1,R9
   \       0xD0   0x.... 0x....      BL       __aeabi_fadd
   \       0xD4   0x.... 0x....      LDR.W    R1,??DataTable169_4  ;; 0x42c80000
   \       0xD8   0x.... 0x....      BL       __aeabi_fadd
   \       0xDC   0x62A0             STR      R0,[R4, #+40]
  13098              cartes[Y_AXIS] = a_sin + b_sin + SCARA_OFFSET_Y;  //theta+phi
   \       0xDE   0x.... 0x....      LDR.W    R0,??DataTable171  ;; 0xc2600000
   \       0xE2   0x4641             MOV      R1,R8
   \       0xE4   0x.... 0x....      BL       __aeabi_fadd
   \       0xE8   0x62E0             STR      R0,[R4, #+44]
  13099          
  13100              /*
  13101                SERIAL_ECHOPAIR("SCARA FK Angle a=", a);
  13102                SERIAL_ECHOPAIR(" b=", b);
  13103                SERIAL_ECHOPAIR(" a_sin=", a_sin);
  13104                SERIAL_ECHOPAIR(" a_cos=", a_cos);
  13105                SERIAL_ECHOPAIR(" b_sin=", b_sin);
  13106                SERIAL_ECHOLNPAIR(" b_cos=", b_cos);
  13107                SERIAL_ECHOPAIR(" cartes[X_AXIS]=", cartes[X_AXIS]);
  13108                SERIAL_ECHOLNPAIR(" cartes[Y_AXIS]=", cartes[Y_AXIS]);
  13109              //*/
                      ^
Warning[Pe009]: nested comment is not allowed
  13110            }
   \       0xEA   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
  13111          
  13112            /**
  13113             * Morgan SCARA Inverse Kinematics. Results in delta[].
  13114             *
  13115             * See http://forums.reprap.org/read.php?185,283327
  13116             *
  13117             * Maths and first version by QHARLEY.
  13118             * Integrated into Marlin and slightly restructured by Joachim Cerny.
  13119             */
  13120          //  void inverse_kinematics(const float logical[XYZ]) {		//mks_delta

   \                                 In section .text, align 2, keep-with-next
  13121            void inverse_kinematics_MORGAN_SCARA(const float logical[XYZ]) {
   \                     _Z31inverse_kinematics_MORGAN_SCARAPKf: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4606             MOV      R6,R0
  13122          
  13123          
  13124              static float C2, S2, SK1, SK2, THETA, PSI;
  13125          
  13126              float sx = RAW_X_POSITION(logical[X_AXIS]) - SCARA_OFFSET_X,  // Translate SCARA to standard X Y
   \        0x6   0x....             LDR.N    R7,??DataTable157
   \        0x8   0x6830             LDR      R0,[R6, #+0]
   \        0xA   0x6C79             LDR      R1,[R7, #+68]
   \        0xC   0x.... 0x....      BL       __aeabi_fsub
   \       0x10   0x.... 0x....      LDR.W    R1,??DataTable169_5  ;; 0xc2c80000
   \       0x14   0x.... 0x....      BL       __aeabi_fadd
   \       0x18   0x9000             STR      R0,[SP, #+0]
  13127                    sy = RAW_Y_POSITION(logical[Y_AXIS]) - SCARA_OFFSET_Y;  // With scaling factor.
   \       0x1A   0x6870             LDR      R0,[R6, #+4]
   \       0x1C   0x6CB9             LDR      R1,[R7, #+72]
   \       0x1E   0x.... 0x....      BL       __aeabi_fsub
   \       0x22   0x.... 0x....      LDR.W    R1,??DataTable169_6  ;; 0x42600000
   \       0x26   0x.... 0x....      BL       __aeabi_fadd
   \       0x2A   0x4605             MOV      R5,R0
  13128          
  13129              if (L1 == L2)
  13130                C2 = HYPOT2(sx, sy) / L1_2_2 - 1;
   \       0x2C   0xF8DD 0x8000      LDR      R8,[SP, #+0]
   \       0x30   0x2402             MOVS     R4,#+2
   \       0x32   0xF04F 0x597E      MOV      R9,#+1065353216
   \       0x36   0x46CA             MOV      R10,R9
   \       0x38   0xE004             B.N      ??inverse_kinematics_MORGAN_SCARA_0
   \                     ??inverse_kinematics_MORGAN_SCARA_1: (+1)
   \       0x3A   0x4640             MOV      R0,R8
   \       0x3C   0x4641             MOV      R1,R8
   \       0x3E   0x.... 0x....      BL       __aeabi_fmul
   \       0x42   0x4680             MOV      R8,R0
   \                     ??inverse_kinematics_MORGAN_SCARA_0: (+1)
   \       0x44   0x07E0             LSLS     R0,R4,#+31
   \       0x46   0xD504             BPL.N    ??inverse_kinematics_MORGAN_SCARA_2
   \       0x48   0x4650             MOV      R0,R10
   \       0x4A   0x4641             MOV      R1,R8
   \       0x4C   0x.... 0x....      BL       __aeabi_fmul
   \       0x50   0x4682             MOV      R10,R0
   \                     ??inverse_kinematics_MORGAN_SCARA_2: (+1)
   \       0x52   0x0864             LSRS     R4,R4,#+1
   \       0x54   0xD1F1             BNE.N    ??inverse_kinematics_MORGAN_SCARA_1
   \       0x56   0x46A8             MOV      R8,R5
   \       0x58   0x2402             MOVS     R4,#+2
   \       0x5A   0x46CB             MOV      R11,R9
   \       0x5C   0xE004             B.N      ??inverse_kinematics_MORGAN_SCARA_3
   \                     ??inverse_kinematics_MORGAN_SCARA_4: (+1)
   \       0x5E   0x4640             MOV      R0,R8
   \       0x60   0x4641             MOV      R1,R8
   \       0x62   0x.... 0x....      BL       __aeabi_fmul
   \       0x66   0x4680             MOV      R8,R0
   \                     ??inverse_kinematics_MORGAN_SCARA_3: (+1)
   \       0x68   0x07E0             LSLS     R0,R4,#+31
   \       0x6A   0xD504             BPL.N    ??inverse_kinematics_MORGAN_SCARA_5
   \       0x6C   0x4658             MOV      R0,R11
   \       0x6E   0x4641             MOV      R1,R8
   \       0x70   0x.... 0x....      BL       __aeabi_fmul
   \       0x74   0x4683             MOV      R11,R0
   \                     ??inverse_kinematics_MORGAN_SCARA_5: (+1)
   \       0x76   0x0864             LSRS     R4,R4,#+1
   \       0x78   0xD1F1             BNE.N    ??inverse_kinematics_MORGAN_SCARA_4
   \       0x7A   0x.... 0x....      LDR.W    R8,??DataTable170
   \       0x7E   0x4650             MOV      R0,R10
   \       0x80   0x4659             MOV      R1,R11
   \       0x82   0x.... 0x....      BL       __aeabi_fadd
   \       0x86   0xF8D8 0x1038      LDR      R1,[R8, #+56]
   \       0x8A   0x.... 0x....      BL       __aeabi_fdiv
   \       0x8E   0x.... 0x....      LDR.W    R1,??DataTable170_1  ;; 0xbf800000
   \       0x92   0x.... 0x....      BL       __aeabi_fadd
   \       0x96   0x4682             MOV      R10,R0
   \       0x98   0xF8C8 0xA040      STR      R10,[R8, #+64]
  13131              else
  13132                C2 = (HYPOT2(sx, sy) - (L1_2 + L2_2)) / (2.0 * L1 * L2);
  13133          
  13134              S2 = sqrt(sq(C2) - 1);
   \       0x9C   0x2402             MOVS     R4,#+2
   \       0x9E   0x46CB             MOV      R11,R9
   \       0xA0   0x4681             MOV      R9,R0
   \       0xA2   0xE004             B.N      ??inverse_kinematics_MORGAN_SCARA_6
   \                     ??inverse_kinematics_MORGAN_SCARA_7: (+1)
   \       0xA4   0x4648             MOV      R0,R9
   \       0xA6   0x4649             MOV      R1,R9
   \       0xA8   0x.... 0x....      BL       __aeabi_fmul
   \       0xAC   0x4681             MOV      R9,R0
   \                     ??inverse_kinematics_MORGAN_SCARA_6: (+1)
   \       0xAE   0x07E0             LSLS     R0,R4,#+31
   \       0xB0   0xD504             BPL.N    ??inverse_kinematics_MORGAN_SCARA_8
   \       0xB2   0x4658             MOV      R0,R11
   \       0xB4   0x4649             MOV      R1,R9
   \       0xB6   0x.... 0x....      BL       __aeabi_fmul
   \       0xBA   0x4683             MOV      R11,R0
   \                     ??inverse_kinematics_MORGAN_SCARA_8: (+1)
   \       0xBC   0x0864             LSRS     R4,R4,#+1
   \       0xBE   0xD1F1             BNE.N    ??inverse_kinematics_MORGAN_SCARA_7
   \       0xC0   0x.... 0x....      LDR.W    R0,??DataTable170_1  ;; 0xbf800000
   \       0xC4   0x4659             MOV      R1,R11
   \       0xC6   0x.... 0x....      BL       __aeabi_fadd
   \       0xCA   0x.... 0x....      BL       sqrtf
   \       0xCE   0x4604             MOV      R4,R0
   \       0xD0   0xF8C8 0x4044      STR      R4,[R8, #+68]
  13135          
  13136              // Unrotated Arm1 plus rotated Arm2 gives the distance from Center to End
  13137              SK1 = L1 + L2 * C2;
   \       0xD4   0x.... 0x....      LDR.W    R9,??DataTable171_1  ;; 0x43160000
   \       0xD8   0x4650             MOV      R0,R10
   \       0xDA   0x4649             MOV      R1,R9
   \       0xDC   0x.... 0x....      BL       __aeabi_fmul
   \       0xE0   0x4649             MOV      R1,R9
   \       0xE2   0x.... 0x....      BL       __aeabi_fadd
   \       0xE6   0x4683             MOV      R11,R0
   \       0xE8   0xF8C8 0xB048      STR      R11,[R8, #+72]
  13138          
  13139              // Rotated Arm2 gives the distance from Arm1 to Arm2
  13140              SK2 = L2 * S2;
   \       0xEC   0x4620             MOV      R0,R4
   \       0xEE   0x4649             MOV      R1,R9
   \       0xF0   0x.... 0x....      BL       __aeabi_fmul
   \       0xF4   0x4601             MOV      R1,R0
   \       0xF6   0xF8C8 0x104C      STR      R1,[R8, #+76]
  13141          
  13142              // Angle of Arm1 is the difference between Center-to-End angle and the Center-to-Elbow
  13143              THETA = atan2(SK1, SK2) - atan2(sx, sy);
   \       0xFA   0x4658             MOV      R0,R11
   \       0xFC   0x.... 0x....      BL       atan2f
   \      0x100   0x4681             MOV      R9,R0
   \      0x102   0x4629             MOV      R1,R5
   \      0x104   0x9800             LDR      R0,[SP, #+0]
   \      0x106   0x.... 0x....      BL       atan2f
   \      0x10A   0x4601             MOV      R1,R0
   \      0x10C   0x4648             MOV      R0,R9
   \      0x10E   0x.... 0x....      BL       __aeabi_fsub
   \      0x112   0xF8C8 0x0050      STR      R0,[R8, #+80]
  13144          
  13145              // Angle of Arm2
  13146              PSI = atan2(S2, C2);
   \      0x116   0x4651             MOV      R1,R10
   \      0x118   0x4620             MOV      R0,R4
   \      0x11A   0x.... 0x....      BL       atan2f
   \      0x11E   0x4681             MOV      R9,R0
   \      0x120   0xF8C8 0x9054      STR      R9,[R8, #+84]
  13147          
  13148              delta[A_AXIS] = DEGREES(THETA);        // theta is support arm angle
   \      0x124   0xF8D8 0x8050      LDR      R8,[R8, #+80]
   \      0x128   0x2400             MOVS     R4,#+0
   \      0x12A   0x.... 0x....      LDR.W    R5,??DataTable169_2  ;; 0x40668000
   \      0x12E   0x4640             MOV      R0,R8
   \      0x130   0x.... 0x....      BL       __aeabi_f2d
   \      0x134   0x4622             MOV      R2,R4
   \      0x136   0x462B             MOV      R3,R5
   \      0x138   0x.... 0x....      BL       __aeabi_dmul
   \      0x13C   0x.... 0x....      LDR.W    R2,??DataTable166_1  ;; 0x54442d18
   \      0x140   0x.... 0x....      LDR.W    R3,??DataTable169_1  ;; 0x400921fb
   \      0x144   0x.... 0x....      BL       __aeabi_ddiv
   \      0x148   0x.... 0x....      BL       __aeabi_d2f
   \      0x14C   0x66B8             STR      R0,[R7, #+104]
  13149              delta[B_AXIS] = DEGREES(THETA + PSI);  // equal to sub arm angle (inverted motor)
   \      0x14E   0x4640             MOV      R0,R8
   \      0x150   0x4649             MOV      R1,R9
   \      0x152   0x.... 0x....      BL       __aeabi_fadd
   \      0x156   0x.... 0x....      BL       __aeabi_f2d
   \      0x15A   0x4622             MOV      R2,R4
   \      0x15C   0x462B             MOV      R3,R5
   \      0x15E   0x.... 0x....      BL       __aeabi_dmul
   \      0x162   0x.... 0x....      LDR.W    R2,??DataTable166_1  ;; 0x54442d18
   \      0x166   0x.... 0x....      LDR.W    R3,??DataTable169_1  ;; 0x400921fb
   \      0x16A   0x.... 0x....      BL       __aeabi_ddiv
   \      0x16E   0x.... 0x....      BL       __aeabi_d2f
   \      0x172   0x66F8             STR      R0,[R7, #+108]
  13150              delta[C_AXIS] = logical[Z_AXIS];
   \      0x174   0x68B0             LDR      R0,[R6, #+8]
   \      0x176   0x6738             STR      R0,[R7, #+112]
  13151          
  13152              /*
  13153                DEBUG_POS("SCARA IK", logical);
  13154                DEBUG_POS("SCARA IK", delta);
  13155                SERIAL_ECHOPAIR("  SCARA (x,y) ", sx);
  13156                SERIAL_ECHOPAIR(",", sy);
  13157                SERIAL_ECHOPAIR(" C2=", C2);
  13158                SERIAL_ECHOPAIR(" S2=", S2);
  13159                SERIAL_ECHOPAIR(" Theta=", THETA);
  13160                SERIAL_ECHOLNPAIR(" Phi=", PHI);
  13161              //*/
                      ^
Warning[Pe009]: nested comment is not allowed
  13162            }
   \      0x178   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return

   \                                 In section .bss, align 4
   \                     home_dir_P:
   \        0x0                      DS8 4
   \                     base_min_pos_P:
   \        0x4                      DS8 12
   \                     base_max_pos_P:
   \       0x10                      DS8 12
   \                     base_home_pos_P:
   \       0x1C                      DS8 12
   \                     max_length_P:
   \       0x28                      DS8 12
   \       0x34                      DS8 4
   \       0x38                      DS8 4
   \       0x3C                      DS8 4
   \       0x40                      DS8 4
   \       0x44                      DS8 4
   \       0x48                      DS8 4
   \       0x4C                      DS8 4
   \       0x50                      DS8 4
   \       0x54                      DS8 4

   \                                 In section .bss, align 4
   \                     _ZZ19get_serial_commandsvE18serial_line_buffer:
   \        0x0                      DS8 96

   \                                 In section .bss, align 1
   \                     _ZZ19get_serial_commandsvE19serial_comment_mode:
   \        0x0                      DS8 1

   \                                 In section .bss, align 4
   \                     _ZZ19get_serial_commandsvE14last_wait_time:
   \        0x0                      DS8 4

   \                                 In section .bss, align 1
   \                     _ZZ19get_sdcard_commandsvE14stop_buffering:
   \        0x0                      DS8 1

   \                                 In section .bss, align 1
   \                     _ZZ19get_sdcard_commandsvE15sd_comment_mode:
   \        0x0                      DS8 1

   \                                 In section .bss, align 4
   \                     _ZZ17get_wifi_commandsvE16wifi_line_buffer:
   \        0x0                      DS8 96

   \                                 In section .bss, align 1
   \                     _ZZ17get_wifi_commandsvE17wifi_comment_mode:
   \        0x0                      DS8 1

   \                                 In section .bss, align 1
   \                     _ZZ27gcode_G29_MESH_BED_LEVELINGvE20enable_soft_endstops:
   \        0x0                      DS8 1

   \                                 In section .bss, align 4
   \                     `filament_change_beep(bool)::runout_beep`:
   \        0x0                      DS8 2
   \        0x2                      DS8 2
   \        0x4                      DS8 4
  13163          
  13164          #endif // MORGAN_SCARA
  13165          
  13166          #if ENABLED(TEMP_STAT_LEDS)
  13167          
  13168            static bool red_led = false;
  13169            static millis_t next_status_led_update_ms = 0;
  13170          
  13171            void handle_status_leds(void) {
  13172              if (ELAPSED(millis(), next_status_led_update_ms)) {
  13173                next_status_led_update_ms += 500; // Update every 0.5s
  13174                float max_temp = 0.0;
  13175                //#if HAS_TEMP_BED	/*--mks cfg-- HAS_TEMP_BED --*/
  13176          		if(HAS_TEMP_BED)
  13177          	  	max_temp = MAX3(max_temp, thermalManager.degTargetBed(), thermalManager.degBed());
  13178                //#endif
  13179                HOTEND_LOOP() {
  13180                  max_temp = MAX3(max_temp, thermalManager.degHotend(e), thermalManager.degTargetHotend(e));
  13181                }
  13182                bool new_led = (max_temp > 55.0) ? true : (max_temp < 54.0) ? false : red_led;
  13183                if (new_led != red_led) {
  13184                  red_led = new_led;
  13185                  #if PIN_EXISTS(STAT_LED_RED)
  13186                    WRITE(STAT_LED_RED_PIN, new_led ? HIGH : LOW);
  13187                    #if PIN_EXISTS(STAT_LED_BLUE)
  13188                      WRITE(STAT_LED_BLUE_PIN, new_led ? LOW : HIGH);
  13189                    #endif
  13190                  #else
  13191                    WRITE(STAT_LED_BLUE_PIN, new_led ? HIGH : LOW);
  13192                  #endif
  13193                }
  13194              }
  13195            }
  13196          
  13197          #endif
  13198          
  13199          #if ENABLED(FILAMENT_RUNOUT_SENSOR)
  13200          

   \                                 In section .text, align 2, keep-with-next
  13201            void handle_filament_runout() {
   \                     _Z22handle_filament_runoutv: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable173
   \        0x4   0x7B48             LDRB     R0,[R1, #+13]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD000             BEQ.N    ??handle_filament_runout_0
   \        0xA   0x4770             BX       LR
   \                     ??handle_filament_runout_0: (+1)
   \        0xC   0xB580             PUSH     {R7,LR}
  13202              if (!filament_ran_out) {
  13203                filament_ran_out = true;
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0x7348             STRB     R0,[R1, #+13]
  13204                enqueue_and_echo_commands_P(PSTR(FILAMENT_RUNOUT_SCRIPT));
   \       0x12   0x.... 0x....      ADR.W    R0,?_43
   \       0x16   0x.... 0x....      BL       _Z27enqueue_and_echo_commands_PPKc
  13205                stepper.synchronize();
   \       0x1A   0xE8BD 0x4001      POP      {R0,LR}
   \       0x1E   0x.... 0x....      B.W      _ZN7Stepper11synchronizeEv
  13206              }
  13207            }
  13208          
  13209          #endif // FILAMENT_RUNOUT_SENSOR
  13210          
  13211          #if ENABLED(FAST_PWM_FAN)
  13212          
  13213            void setPwmFrequency(uint8_t pin, int val) {
  13214              val &= 0x07;
  13215              switch (digitalPinToTimer(pin)) {
  13216                #ifdef TCCR0A
  13217                  case TIMER0A:
  13218                  case TIMER0B:
  13219                    //_SET_CS(0, val);
  13220                    break;
  13221                #endif
  13222                #ifdef TCCR1A
  13223                  case TIMER1A:
  13224                  case TIMER1B:
  13225                    //_SET_CS(1, val);
  13226                    break;
  13227                #endif
  13228                #ifdef TCCR2
  13229                  case TIMER2:
  13230                  case TIMER2:
  13231                    _SET_CS(2, val);
  13232                    break;
  13233                #endif
  13234                #ifdef TCCR2A
  13235                  case TIMER2A:
  13236                  case TIMER2B:
  13237                    _SET_CS(2, val);
  13238                    break;
  13239                #endif
  13240                #ifdef TCCR3A
  13241                  case TIMER3A:
  13242                  case TIMER3B:
  13243                  case TIMER3C:
  13244                    _SET_CS(3, val);
  13245                    break;
  13246                #endif
  13247                #ifdef TCCR4A
  13248                  case TIMER4A:
  13249                  case TIMER4B:
  13250                  case TIMER4C:
  13251                    _SET_CS(4, val);
  13252                    break;
  13253                #endif
  13254                #ifdef TCCR5A
  13255                  case TIMER5A:
  13256                  case TIMER5B:
  13257                  case TIMER5C:
  13258                    _SET_CS(5, val);
  13259                    break;
  13260                #endif
  13261              }
  13262            }
  13263          
  13264          #endif // FAST_PWM_FAN
  13265          

   \                                 In section .text, align 2, keep-with-next
  13266          float calculate_volumetric_multiplier(float diameter) {
   \                     _Z31calculate_volumetric_multiplierf: (+1)
   \        0x0   0xE92D 0x43D0      PUSH     {R4,R6-R9,LR}
   \        0x4   0x4602             MOV      R2,R0
  13267            if (!volumetric_enabled || diameter == 0) return 1.0;
   \        0x6   0x.... 0x....      LDR.W    R0,??DataTable172
   \        0xA   0x7800             LDRB     R0,[R0, #+0]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD004             BEQ.N    ??calculate_volumetric_multiplier_0
   \       0x10   0x4610             MOV      R0,R2
   \       0x12   0x2100             MOVS     R1,#+0
   \       0x14   0x.... 0x....      BL       __aeabi_cfcmpeq
   \       0x18   0xD102             BNE.N    ??calculate_volumetric_multiplier_1
   \                     ??calculate_volumetric_multiplier_0: (+1)
   \       0x1A   0xF04F 0x507E      MOV      R0,#+1065353216
   \       0x1E   0xE035             B.N      ??calculate_volumetric_multiplier_2
  13268            return 1.0 / (M_PI * sq(diameter * 0.5));
   \                     ??calculate_volumetric_multiplier_1: (+1)
   \       0x20   0x.... 0x....      BL       __aeabi_f2d
   \       0x24   0x2200             MOVS     R2,#+0
   \       0x26   0x.... 0x....      LDR.W    R3,??DataTable166_6  ;; 0x3fe00000
   \       0x2A   0x.... 0x....      BL       __aeabi_dmul
   \       0x2E   0x4606             MOV      R6,R0
   \       0x30   0x460F             MOV      R7,R1
   \       0x32   0x2402             MOVS     R4,#+2
   \       0x34   0xF04F 0x0800      MOV      R8,#+0
   \       0x38   0x.... 0x....      LDR.W    R9,??DataTable167  ;; 0x3ff00000
   \       0x3C   0xE007             B.N      ??calculate_volumetric_multiplier_3
   \                     ??calculate_volumetric_multiplier_4: (+1)
   \       0x3E   0x4630             MOV      R0,R6
   \       0x40   0x4639             MOV      R1,R7
   \       0x42   0x4632             MOV      R2,R6
   \       0x44   0x463B             MOV      R3,R7
   \       0x46   0x.... 0x....      BL       __aeabi_dmul
   \       0x4A   0x4606             MOV      R6,R0
   \       0x4C   0x460F             MOV      R7,R1
   \                     ??calculate_volumetric_multiplier_3: (+1)
   \       0x4E   0x07E0             LSLS     R0,R4,#+31
   \       0x50   0xD507             BPL.N    ??calculate_volumetric_multiplier_5
   \       0x52   0x4632             MOV      R2,R6
   \       0x54   0x463B             MOV      R3,R7
   \       0x56   0x4640             MOV      R0,R8
   \       0x58   0x4649             MOV      R1,R9
   \       0x5A   0x.... 0x....      BL       __aeabi_dmul
   \       0x5E   0x4680             MOV      R8,R0
   \       0x60   0x4689             MOV      R9,R1
   \                     ??calculate_volumetric_multiplier_5: (+1)
   \       0x62   0x0864             LSRS     R4,R4,#+1
   \       0x64   0xD1EB             BNE.N    ??calculate_volumetric_multiplier_4
   \       0x66   0x.... 0x....      LDR.W    R0,??DataTable169_7  ;; 0x54442d18
   \       0x6A   0x.... 0x....      LDR.W    R1,??DataTable169_1  ;; 0x400921fb
   \       0x6E   0x4642             MOV      R2,R8
   \       0x70   0x464B             MOV      R3,R9
   \       0x72   0x.... 0x....      BL       __aeabi_dmul
   \       0x76   0x4602             MOV      R2,R0
   \       0x78   0x460B             MOV      R3,R1
   \       0x7A   0x2000             MOVS     R0,#+0
   \       0x7C   0x.... 0x....      LDR.W    R1,??DataTable167  ;; 0x3ff00000
   \       0x80   0x.... 0x....      BL       __aeabi_ddiv
   \       0x84   0xE8BD 0x43D0      POP      {R4,R6-R9,LR}
   \       0x88   0x.... 0x....      B.W      __aeabi_d2f
   \                     ??calculate_volumetric_multiplier_2: (+1)
   \       0x8C   0xE8BD 0x83D0      POP      {R4,R6-R9,PC}    ;; return
  13269          }
  13270          

   \                                 In section .text, align 2, keep-with-next
  13271          void calculate_volumetric_multipliers() {
   \                     _Z32calculate_volumetric_multipliersv: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
  13272            for (uint8_t i = 0; i < COUNT(filament_size); i++)
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x.... 0x....      LDR.W    R4,??DataTable172
   \        0x8   0xE004             B.N      ??calculate_volumetric_multipliers_0
  13273              volumetric_multiplier[i] = calculate_volumetric_multiplier(filament_size[i]);
   \                     ??calculate_volumetric_multipliers_1: (+1)
   \        0xA   0x6860             LDR      R0,[R4, #+4]
   \        0xC   0x.... 0x....      BL       _Z31calculate_volumetric_multiplierf
   \       0x10   0x60A0             STR      R0,[R4, #+8]
   \       0x12   0x2001             MOVS     R0,#+1
   \                     ??calculate_volumetric_multipliers_0: (+1)
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD0F8             BEQ.N    ??calculate_volumetric_multipliers_1
  13274          }
   \       0x18   0xBD10             POP      {R4,PC}          ;; return
  13275          

   \                                 In section .text, align 2, keep-with-next
  13276          void enable_all_steppers() {
   \                     _Z19enable_all_steppersv: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
  13277            enable_X();
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable173_1
   \        0x6   0x.... 0x....      LDR.W    R5,??DataTable173_2
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x8BA9             LDRH     R1,[R5, #+28]
   \        0xE   0x6BA0             LDR      R0,[R4, #+56]
   \       0x10   0x.... 0x....      BL       HAL_GPIO_WritePin
  13278            enable_Y();
   \       0x14   0x2200             MOVS     R2,#+0
   \       0x16   0x8BA9             LDRH     R1,[R5, #+28]
   \       0x18   0x6BA0             LDR      R0,[R4, #+56]
   \       0x1A   0x.... 0x....      BL       HAL_GPIO_WritePin
  13279            enable_Z();
   \       0x1E   0x2200             MOVS     R2,#+0
   \       0x20   0x8BA9             LDRH     R1,[R5, #+28]
   \       0x22   0x6BA0             LDR      R0,[R4, #+56]
   \       0x24   0x.... 0x....      BL       HAL_GPIO_WritePin
  13280            enable_E0();
   \       0x28   0x2200             MOVS     R2,#+0
   \       0x2A   0x8FA9             LDRH     R1,[R5, #+60]
   \       0x2C   0x6FA0             LDR      R0,[R4, #+120]
   \       0x2E   0xE8BD 0x4038      POP      {R3-R5,LR}
   \       0x32   0x.... 0x....      B.W      HAL_GPIO_WritePin
  13281            enable_E1();
  13282            enable_E2();
  13283            enable_E3();
  13284            enable_E4();
  13285          }
  13286          

   \                                 In section .text, align 2, keep-with-next
  13287          void disable_e_steppers() {
  13288            disable_E0();
   \                     _Z18disable_e_steppersv: (+1)
   \        0x0   0x2201             MOVS     R2,#+1
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable173_2
   \        0x6   0x8F81             LDRH     R1,[R0, #+60]
   \        0x8   0x.... 0x....      LDR.W    R0,??DataTable173_1
   \        0xC   0x6F80             LDR      R0,[R0, #+120]
   \        0xE   0x.... 0x....      B.W      HAL_GPIO_WritePin
  13289            disable_E1();
  13290            disable_E2();
  13291            disable_E3();
  13292            disable_E4();
  13293          }
  13294          

   \                                 In section .text, align 2, keep-with-next
  13295          void disable_all_steppers() {
   \                     _Z20disable_all_steppersv: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
  13296            disable_X();
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable173_1
   \        0x6   0x.... 0x....      LDR.W    R5,??DataTable173_2
   \        0xA   0x2201             MOVS     R2,#+1
   \        0xC   0x8BA9             LDRH     R1,[R5, #+28]
   \        0xE   0x6BA0             LDR      R0,[R4, #+56]
   \       0x10   0x.... 0x....      BL       HAL_GPIO_WritePin
   \       0x14   0x.... 0x....      LDR.W    R6,??DataTable174
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x7130             STRB     R0,[R6, #+4]
  13297            disable_Y();
   \       0x1C   0x2201             MOVS     R2,#+1
   \       0x1E   0x8BA9             LDRH     R1,[R5, #+28]
   \       0x20   0x6BA0             LDR      R0,[R4, #+56]
   \       0x22   0x.... 0x....      BL       HAL_GPIO_WritePin
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x7170             STRB     R0,[R6, #+5]
  13298            disable_Z();
   \       0x2A   0x2201             MOVS     R2,#+1
   \       0x2C   0x8BA9             LDRH     R1,[R5, #+28]
   \       0x2E   0x6BA0             LDR      R0,[R4, #+56]
   \       0x30   0x.... 0x....      BL       HAL_GPIO_WritePin
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0x71B0             STRB     R0,[R6, #+6]
  13299            disable_e_steppers();
   \       0x38   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x3C   0x....             B.N      _Z18disable_e_steppersv
  13300          }
  13301          
  13302          #if ENABLED(HAVE_TMC2130)
  13303          
  13304            void automatic_current_control(TMC2130Stepper &st, String axisID) {
  13305              // Check otpw even if we don't use automatic control. Allows for flag inspection.
  13306              const bool is_otpw = st.checkOT();
  13307          
  13308              // Report if a warning was triggered
  13309              static bool previous_otpw = false;
  13310              if (is_otpw && !previous_otpw) {
  13311                char timestamp[10];
  13312                duration_t elapsed = print_job_timer.duration();
  13313                const bool has_days = (elapsed.value > 60*60*24L);
  13314                (void)elapsed.toDigital(timestamp, has_days);
  13315                SERIAL_ECHO(timestamp);
  13316                SERIAL_ECHO(": ");
  13317                SERIAL_ECHO(axisID);
  13318                SERIAL_ECHOLNPGM(" driver overtemperature warning!");
  13319              }
  13320              previous_otpw = is_otpw;
  13321          
  13322              #if CURRENT_STEP > 0 && ENABLED(AUTOMATIC_CURRENT_CONTROL)
  13323                // Return if user has not enabled current control start with M906 S1.
  13324                if (!auto_current_control) return;
  13325          
  13326                /**
  13327                 * Decrease current if is_otpw is true.
  13328                 * Bail out if driver is disabled.
  13329                 * Increase current if OTPW has not been triggered yet.
  13330                 */
  13331                uint16_t current = st.getCurrent();
  13332                if (is_otpw) {
  13333                  st.setCurrent(current - CURRENT_STEP, R_SENSE, HOLD_MULTIPLIER);
  13334                  #if ENABLED(REPORT_CURRENT_CHANGE)
  13335                    SERIAL_ECHO(axisID);
  13336                    SERIAL_ECHOPAIR(" current decreased to ", st.getCurrent());
  13337                  #endif
  13338                }
  13339          
  13340                else if (!st.isEnabled())
  13341                  return;
  13342          
  13343                else if (!is_otpw && !st.getOTPW()) {
  13344                  current += CURRENT_STEP;
  13345                  if (current <= AUTO_ADJUST_MAX) {
  13346                    st.setCurrent(current, R_SENSE, HOLD_MULTIPLIER);
  13347                    #if ENABLED(REPORT_CURRENT_CHANGE)
  13348                      SERIAL_ECHO(axisID);
  13349                      SERIAL_ECHOPAIR(" current increased to ", st.getCurrent());
  13350                    #endif
  13351                  }
  13352                }
  13353                SERIAL_EOL;
  13354              #endif
  13355            }
  13356          
  13357            void checkOverTemp() {
  13358              static millis_t next_cOT = 0;
  13359              if (ELAPSED(millis(), next_cOT)) {
  13360                next_cOT = millis() + 5000;
  13361                #if ENABLED(X_IS_TMC2130)
  13362                  automatic_current_control(stepperX, "X");
  13363                #endif
  13364                #if ENABLED(Y_IS_TMC2130)
  13365                  automatic_current_control(stepperY, "Y");
  13366                #endif
  13367                #if ENABLED(Z_IS_TMC2130)
  13368                  automatic_current_control(stepperZ, "Z");
  13369                #endif
  13370                #if ENABLED(X2_IS_TMC2130)
  13371                  automatic_current_control(stepperX2, "X2");
  13372                #endif
  13373                #if ENABLED(Y2_IS_TMC2130)
  13374                  automatic_current_control(stepperY2, "Y2");
  13375                #endif
  13376                #if ENABLED(Z2_IS_TMC2130)
  13377                  automatic_current_control(stepperZ2, "Z2");
  13378                #endif
  13379                #if ENABLED(E0_IS_TMC2130)
  13380                  automatic_current_control(stepperE0, "E0");
  13381                #endif
  13382                #if ENABLED(E1_IS_TMC2130)
  13383                  automatic_current_control(stepperE1, "E1");
  13384                #endif
  13385                #if ENABLED(E2_IS_TMC2130)
  13386                  automatic_current_control(stepperE2, "E2");
  13387                #endif
  13388                #if ENABLED(E3_IS_TMC2130)
  13389                  automatic_current_control(stepperE3, "E3");
  13390                #endif
  13391                #if ENABLED(E4_IS_TMC2130)
  13392                  automatic_current_control(stepperE4, "E4");
  13393                #endif
  13394                #if ENABLED(E4_IS_TMC2130)
  13395                  automatic_current_control(stepperE4);
  13396                #endif
  13397              }
  13398            }
  13399          
  13400          #endif // HAVE_TMC2130
  13401          
  13402          /**
  13403           * Manage several activities:
  13404           *  - Check for Filament Runout
  13405           *  - Keep the command buffer full
  13406           *  - Check for maximum inactive time between commands
  13407           *  - Check for maximum inactive time between stepper commands
  13408           *  - Check if pin CHDK needs to go LOW
  13409           *  - Check for KILL button held down
  13410           *  - Check for HOME button held down
  13411           *  - Check if cooling fan needs to be switched on
  13412           *  - Check if an idle but hot extruder needs filament extruded (EXTRUDER_RUNOUT_PREVENT)
  13413           */

   \                                 In section .text, align 2, keep-with-next
  13414          void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
   \                     _Z17manage_inactivityb: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
  13415          
  13416            #if ENABLED(FILAMENT_RUNOUT_SENSOR)
  13417              if ((IS_SD_PRINTING || print_job_timer.isRunning()) && (READ(FIL_RUNOUT_PIN) == FIL_RUNOUT_INVERTING))
   \        0x4   0x.... 0x....      LDR.W    R0,??DataTable173_3
   \        0x8   0x7880             LDRB     R0,[R0, #+2]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD105             BNE.N    ??manage_inactivity_0
   \        0xE   0x.... 0x....      LDR.W    R0,??DataTable173_4
   \       0x12   0x.... 0x....      BL       _ZN9Stopwatch9isRunningEv
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD00F             BEQ.N    ??manage_inactivity_1
   \                     ??manage_inactivity_0: (+1)
   \       0x1A   0x.... 0x....      LDR.W    R0,??DataTable175
   \       0x1E   0x8CC1             LDRH     R1,[R0, #+38]
   \       0x20   0x.... 0x....      LDR.W    R0,??DataTable174_1
   \       0x24   0x6CC0             LDR      R0,[R0, #+76]
   \       0x26   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \       0x2A   0x.... 0x....      LDR.W    R1,??DataTable174_2
   \       0x2E   0xF891 0x10D0      LDRB     R1,[R1, #+208]
   \       0x32   0x4288             CMP      R0,R1
   \       0x34   0xD101             BNE.N    ??manage_inactivity_1
  13418                handle_filament_runout();
   \       0x36   0x.... 0x....      BL       _Z22handle_filament_runoutv
  13419            #endif
  13420          
  13421            if (commands_in_queue < BUFSIZE) get_available_commands();
   \                     ??manage_inactivity_1: (+1)
   \       0x3A   0x.... 0x....      LDR.W    R5,??DataTable173
   \       0x3E   0x7A28             LDRB     R0,[R5, #+8]
   \       0x40   0x2804             CMP      R0,#+4
   \       0x42   0xDA01             BGE.N    ??manage_inactivity_2
   \       0x44   0x.... 0x....      BL       _Z22get_available_commandsv
  13422          
  13423            const millis_t ms = millis();
   \                     ??manage_inactivity_2: (+1)
   \       0x48   0x.... 0x....      BL       HAL_GetTick
   \       0x4C   0x4606             MOV      R6,R0
  13424          
  13425            if (max_inactive_time && ELAPSED(ms, previous_cmd_ms + max_inactive_time)) {
   \       0x4E   0x6BE8             LDR      R0,[R5, #+60]
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD021             BEQ.N    ??manage_inactivity_3
   \       0x54   0x6BA9             LDR      R1,[R5, #+56]
   \       0x56   0x1A71             SUBS     R1,R6,R1
   \       0x58   0x1A08             SUBS     R0,R1,R0
   \       0x5A   0xD41D             BMI.N    ??manage_inactivity_3
  13426              SERIAL_ERROR_START;
   \       0x5C   0x.... 0x....      LDR.W    R0,??DataTable175_1
   \       0x60   0x.... 0x....      BL       _Z14serialprintPGMPKc
  13427              SERIAL_ECHOLNPAIR(MSG_KILL_INACTIVE_TIME, current_command);
   \       0x64   0x6A69             LDR      R1,[R5, #+36]
   \       0x66   0x.... 0x....      ADR.W    R0,?_44
   \       0x6A   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
   \       0x6E   0x.... 0x....      LDR.W    R0,??DataTable174_3
   \       0x72   0x79C0             LDRB     R0,[R0, #+7]
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD105             BNE.N    ??manage_inactivity_4
   \       0x78   0x210A             MOVS     R1,#+10
   \       0x7A   0x.... 0x....      LDR.W    R0,??DataTable174_4
   \       0x7E   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \       0x82   0xE005             B.N      ??manage_inactivity_5
   \                     ??manage_inactivity_4: (+1)
   \       0x84   0x2200             MOVS     R2,#+0
   \       0x86   0x210A             MOVS     R1,#+10
   \       0x88   0x.... 0x....      LDR.W    R0,??DataTable174_5
   \       0x8C   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
  13428              kill(PSTR(MSG_KILLED));
   \                     ??manage_inactivity_5: (+1)
   \       0x90   0x.... 0x....      ADR.W    R0,?_45
   \       0x94   0x.... 0x....      BL       _Z4killPKc
  13429            }
  13430          
  13431            // Prevent steppers timing-out in the middle of M600
  13432            #if ENABLED(FILAMENT_CHANGE_FEATURE) && ENABLED(FILAMENT_CHANGE_NO_STEPPER_TIMEOUT)
  13433              #define M600_TEST !busy_doing_M600
  13434            #else
  13435              #define M600_TEST true
  13436            #endif
  13437          
  13438            if (M600_TEST && stepper_inactive_time && ELAPSED(ms, previous_cmd_ms + stepper_inactive_time)
  13439                && !ignore_stepper_queue && !planner.blocks_queued()) {
   \                     ??manage_inactivity_3: (+1)
   \       0x98   0x7BE8             LDRB     R0,[R5, #+15]
   \       0x9A   0x2800             CMP      R0,#+0
   \       0x9C   0xD127             BNE.N    ??manage_inactivity_6
   \       0x9E   0x6C28             LDR      R0,[R5, #+64]
   \       0xA0   0x2800             CMP      R0,#+0
   \       0xA2   0xD024             BEQ.N    ??manage_inactivity_6
   \       0xA4   0x6BA9             LDR      R1,[R5, #+56]
   \       0xA6   0x1A76             SUBS     R6,R6,R1
   \       0xA8   0x1A36             SUBS     R6,R6,R0
   \       0xAA   0xD420             BMI.N    ??manage_inactivity_6
   \       0xAC   0x2C00             CMP      R4,#+0
   \       0xAE   0xD11E             BNE.N    ??manage_inactivity_6
   \       0xB0   0x.... 0x....      BL       _ZN7Planner13blocks_queuedEv
   \       0xB4   0x2800             CMP      R0,#+0
   \       0xB6   0xD11A             BNE.N    ??manage_inactivity_6
  13440              #if ENABLED(DISABLE_INACTIVE_X)
  13441                disable_X();
   \       0xB8   0x.... 0x....      LDR.W    R4,??DataTable174_1
   \       0xBC   0x.... 0x....      LDR.W    R6,??DataTable175
   \       0xC0   0x2201             MOVS     R2,#+1
   \       0xC2   0x8831             LDRH     R1,[R6, #+0]
   \       0xC4   0x6820             LDR      R0,[R4, #+0]
   \       0xC6   0x.... 0x....      BL       HAL_GPIO_WritePin
   \       0xCA   0x2000             MOVS     R0,#+0
   \       0xCC   0x7128             STRB     R0,[R5, #+4]
  13442              #endif
  13443              #if ENABLED(DISABLE_INACTIVE_Y)
  13444                disable_Y();
   \       0xCE   0x2201             MOVS     R2,#+1
   \       0xD0   0x8831             LDRH     R1,[R6, #+0]
   \       0xD2   0x6820             LDR      R0,[R4, #+0]
   \       0xD4   0x.... 0x....      BL       HAL_GPIO_WritePin
   \       0xD8   0x2000             MOVS     R0,#+0
   \       0xDA   0x7168             STRB     R0,[R5, #+5]
  13445              #endif
  13446              #if ENABLED(DISABLE_INACTIVE_Z)
  13447                disable_Z();
   \       0xDC   0x2201             MOVS     R2,#+1
   \       0xDE   0x8831             LDRH     R1,[R6, #+0]
   \       0xE0   0x6820             LDR      R0,[R4, #+0]
   \       0xE2   0x.... 0x....      BL       HAL_GPIO_WritePin
   \       0xE6   0x2000             MOVS     R0,#+0
   \       0xE8   0x71A8             STRB     R0,[R5, #+6]
  13448              #endif
  13449              #if ENABLED(DISABLE_INACTIVE_E)
  13450                disable_e_steppers();
   \       0xEA   0x.... 0x....      BL       _Z18disable_e_steppersv
  13451              #endif
  13452            }
  13453          
  13454            #ifdef CHDK // Check if pin should be set to LOW after M240 set it to HIGH
  13455              if (chdkActive && ELAPSED(ms, chdkHigh + CHDK_DELAY)) {
  13456                chdkActive = false;
  13457                WRITE(CHDK, LOW);
  13458              }
  13459            #endif
  13460          
  13461            #if HAS_KILL
  13462          
  13463              // Check if the kill button was pressed and wait just in case it was an accidental
  13464              // key kill key press
  13465              // -------------------------------------------------------------------------------
  13466              static int killCount = 0;   // make the inactivity button a bit less responsive
  13467              const int KILL_DELAY = 750;
  13468              if (!READ(KILL_PIN))
  13469                killCount++;
  13470              else if (killCount > 0)
  13471                killCount--;
  13472          
  13473              // Exceeded threshold and we can confirm that it was not accidental
  13474              // KILL the machine
  13475              // ----------------------------------------------------------------
  13476              if (killCount >= KILL_DELAY) {
  13477                SERIAL_ERROR_START;
  13478                SERIAL_ERRORLNPGM(MSG_KILL_BUTTON);
  13479                kill(PSTR(MSG_KILLED));
  13480              }
  13481            #endif
  13482          
  13483            #if HAS_HOME
  13484              // Check to see if we have to home, use poor man's debouncer
  13485              // ---------------------------------------------------------
  13486              static int homeDebounceCount = 0;   // poor man's debouncing count
  13487              const int HOME_DEBOUNCE_DELAY = 2500;
  13488              if (!IS_SD_PRINTING && !READ(HOME_PIN)) {
  13489                if (!homeDebounceCount) {
  13490                  enqueue_and_echo_commands_P(PSTR("G28"));
  13491                  LCD_MESSAGEPGM(MSG_AUTO_HOME);
  13492                }
  13493                if (homeDebounceCount < HOME_DEBOUNCE_DELAY)
  13494                  homeDebounceCount++;
  13495                else
  13496                  homeDebounceCount = 0;
  13497              }
  13498            #endif
  13499          
  13500          #if ENABLED(USE_CONTROLLER_FAN)
  13501              controllerFan(); // Check if fan should be turned on to cool stepper drivers down
  13502            #endif
  13503          
  13504            #if ENABLED(EXTRUDER_RUNOUT_PREVENT)
  13505              if (ELAPSED(ms, previous_cmd_ms + (EXTRUDER_RUNOUT_SECONDS) * 1000UL)
  13506                && thermalManager.degHotend(active_extruder) > EXTRUDER_RUNOUT_MINTEMP) {
  13507                bool oldstatus;
  13508                #if ENABLED(SWITCHING_EXTRUDER)
  13509                  oldstatus = E0_ENABLE_READ;
  13510                  enable_E0();
  13511                #else // !SWITCHING_EXTRUDER
  13512                  switch (active_extruder) {
  13513                    case 0: oldstatus = E0_ENABLE_READ; enable_E0(); break;
  13514                    #if E_STEPPERS > 1
  13515                      case 1: oldstatus = E1_ENABLE_READ; enable_E1(); break;
  13516                      #if E_STEPPERS > 2
  13517                        case 2: oldstatus = E2_ENABLE_READ; enable_E2(); break;
  13518                        #if E_STEPPERS > 3
  13519                          case 3: oldstatus = E3_ENABLE_READ; enable_E3(); break;
  13520                          #if E_STEPPERS > 4
  13521                            case 4: oldstatus = E4_ENABLE_READ; enable_E4(); break;
  13522                          #endif // E_STEPPERS > 4
  13523                        #endif // E_STEPPERS > 3
  13524                      #endif // E_STEPPERS > 2
  13525                    #endif // E_STEPPERS > 1
  13526                  }
  13527                #endif // !SWITCHING_EXTRUDER
  13528          
  13529                previous_cmd_ms = ms; // refresh_cmd_timeout()
  13530          
  13531                const float olde = current_position[E_AXIS];
  13532                current_position[E_AXIS] += EXTRUDER_RUNOUT_EXTRUDE;
  13533                planner.buffer_line_kinematic(current_position, MMM_TO_MMS(EXTRUDER_RUNOUT_SPEED), active_extruder);
  13534                current_position[E_AXIS] = olde;
  13535                planner.set_e_position_mm(olde);
  13536                stepper.synchronize();
  13537                #if ENABLED(SWITCHING_EXTRUDER)
  13538                  E0_ENABLE_WRITE(oldstatus);
  13539                #else
  13540                  switch (active_extruder) {
  13541                    case 0: E0_ENABLE_WRITE(oldstatus); break;
  13542                    #if E_STEPPERS > 1
  13543                      case 1: E1_ENABLE_WRITE(oldstatus); break;
  13544                      #if E_STEPPERS > 2
  13545                        case 2: E2_ENABLE_WRITE(oldstatus); break;
  13546                        #if E_STEPPERS > 3
  13547                          case 3: E3_ENABLE_WRITE(oldstatus); break;
  13548                          #if E_STEPPERS > 4
  13549                            case 4: E4_ENABLE_WRITE(oldstatus); break;
  13550                          #endif // E_STEPPERS > 4
  13551                        #endif // E_STEPPERS > 3
  13552                      #endif // E_STEPPERS > 2
  13553                    #endif // E_STEPPERS > 1
  13554                  }
  13555                #endif // !SWITCHING_EXTRUDER
  13556              }
  13557            #endif // EXTRUDER_RUNOUT_PREVENT
  13558          
  13559            #if ENABLED(DUAL_X_CARRIAGE)
  13560              // handle delayed move timeout
  13561              if (delayed_move_time && ELAPSED(ms, delayed_move_time + 1000UL) && IsRunning()) {
  13562                // travel moves have been received so enact them
  13563                delayed_move_time = 0xFFFFFFFFUL; // force moves to be done
  13564                set_destination_to_current();
  13565                prepare_move_to_destination();
  13566              }
  13567            #endif
  13568          
  13569            #if ENABLED(TEMP_STAT_LEDS)
  13570              handle_status_leds();
  13571            #endif
  13572          
  13573            #if ENABLED(HAVE_TMC2130)
  13574              checkOverTemp();
  13575            #endif
  13576          
  13577            planner.check_axes_activity();
   \                     ??manage_inactivity_6: (+1)
   \       0xEE   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0xF2   0x.... 0x....      B.W      _ZN7Planner19check_axes_activityEv
  13578          }
  13579          
  13580          /**
  13581           * Standard idle routine keeps the machine alive
  13582           */

   \                                 In section .text, align 2, keep-with-next
  13583          void idle(
  13584            #if ENABLED(FILAMENT_CHANGE_FEATURE)
  13585              bool no_stepper_sleep/*=false*/
  13586            #endif
  13587          ) {
   \                     _Z4idleb: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
  13588            lcd_update();
   \        0x4   0x.... 0x....      BL       _Z10lcd_updatev
  13589          //#if MASK_FOR_SPACE
  13590            host_keepalive();
   \        0x8   0x.... 0x....      BL       _Z14host_keepalivev
  13591          
  13592            //#if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)	/*--mks cfg-- HAS_TEMP_BED --*/
  13593            #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND)	
  13594            auto_report_temperatures();
  13595            #endif
  13596          
  13597          
  13598            manage_inactivity(
  13599              #if ENABLED(FILAMENT_CHANGE_FEATURE)
  13600                no_stepper_sleep
  13601              #endif
  13602            );
   \        0xC   0x4620             MOV      R0,R4
   \        0xE   0x.... 0x....      BL       _Z17manage_inactivityb
  13603          
  13604          
  13605            thermalManager.manage_heater();
   \       0x12   0x.... 0x....      BL       _ZN11Temperature13manage_heaterEv
  13606           // #endif
  13607          
  13608          
  13609            #if ENABLED(PRINTCOUNTER)
  13610              print_job_timer.tick();
  13611            #endif
  13612          
  13613            #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
  13614              buzzer.tick();
   \       0x16   0x.... 0x....      LDR.W    R0,??DataTable178
   \       0x1A   0x.... 0x....      BL       _ZN6Buzzer4tickEv
  13615            #endif
  13616          
  13617          #ifdef USE_MKS_WIFI  
  13618            	wifi_looping();
   \       0x1E   0x.... 0x....      BL       wifi_looping
  13619          #endif
  13620            
  13621             BlinkLed();
   \       0x22   0x.... 0x....      BL       _Z8BlinkLedv
  13622             GoHomeCheck();
   \       0x26   0x.... 0x....      BL       _Z11GoHomeCheckv
  13623             PrintOneKey();
   \       0x2A   0x.... 0x....      BL       _Z11PrintOneKeyv
  13624             LoadFilament();
   \       0x2E   0xE8BD 0x4010      POP      {R4,LR}
   \       0x32   0x.... 0x....      B.W      _Z12LoadFilamentv
  13625          }
  13626          
  13627          /**
  13628           * Kill all activity and lock the machine.
  13629           * After this the machine will need to be reset.
  13630           */
  13631          extern "C" void kill_c(const char* lcd_msg);

   \                                 In section .text, align 4, keep-with-next
  13632          void kill_c(const char* lcd_msg) {
   \                     kill_c: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
  13633            SERIAL_ERROR_START;
   \        0x4   0x.... 0x....      LDR.W    R0,??DataTable175_1
   \        0x8   0x.... 0x....      BL       _Z14serialprintPGMPKc
  13634            SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
   \        0xC   0x.... 0x....      ADR.W    R0,?_46
   \       0x10   0x.... 0x....      BL       _Z14serialprintPGMPKc
  13635          
  13636            thermalManager.disable_all_heaters();
   \       0x14   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
  13637            disable_all_steppers();
   \       0x18   0x.... 0x....      BL       _Z20disable_all_steppersv
  13638          
  13639            #if ENABLED(ULTRA_LCD)
  13640              kill_screen(lcd_msg);
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0x.... 0x....      BL       _Z11kill_screenPKc
  13641            #else
  13642              UNUSED(lcd_msg);
  13643            #endif
  13644          
  13645            _delay_ms(600); // Wait a short time (allows messages to get out before shutting down.
   \       0x22   0xF44F 0x7016      MOV      R0,#+600
   \       0x26   0x.... 0x....      BL       HAL_Delay
  13646            cli(); // Stop interrupts
   \       0x2A   0xB672             cpsid i
  13647          
  13648            _delay_ms(250); //Wait to ensure all interrupts routines stopped
   \       0x2C   0x20FA             MOVS     R0,#+250
   \       0x2E   0x.... 0x....      BL       HAL_Delay
  13649            thermalManager.disable_all_heaters(); //turn off heaters again
   \       0x32   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
  13650          
  13651            #if HAS_POWER_SWITCH
  13652              SET_INPUT(PS_ON_PIN);
  13653            #endif
  13654          
  13655            suicide();
   \       0x36   0x.... 0x....      BL       _Z7suicidev
  13656            while (1) {
   \                     ??kill_c_0: (+1)
   \       0x3A   0xE7FE             B.N      ??kill_c_0
  13657              #if ENABLED(USE_WATCHDOG)
  13658                watchdog_reset();
  13659              #endif
  13660            } // Wait for reset
  13661          }
  13662          
  13663          
  13664          
  13665          

   \                                 In section .text, align 4, keep-with-next
  13666          void kill(const char* lcd_msg) {
   \                     _Z4killPKc: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
  13667            SERIAL_ERROR_START;
   \        0x4   0x.... 0x....      LDR.W    R0,??DataTable175_1
   \        0x8   0x.... 0x....      BL       _Z14serialprintPGMPKc
  13668            SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
   \        0xC   0x.... 0x....      ADR.W    R0,?_46
   \       0x10   0x.... 0x....      BL       _Z14serialprintPGMPKc
  13669          
  13670            thermalManager.disable_all_heaters();
   \       0x14   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
  13671            disable_all_steppers();
   \       0x18   0x.... 0x....      BL       _Z20disable_all_steppersv
  13672          
  13673            #if ENABLED(ULTRA_LCD)
  13674              kill_screen(lcd_msg);
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0x.... 0x....      BL       _Z11kill_screenPKc
  13675            #else
  13676              UNUSED(lcd_msg);
  13677            #endif
  13678          
  13679            _delay_ms(600); // Wait a short time (allows messages to get out before shutting down.
   \       0x22   0xF44F 0x7016      MOV      R0,#+600
   \       0x26   0x.... 0x....      BL       HAL_Delay
  13680            cli(); // Stop interrupts
   \       0x2A   0xB672             cpsid i
  13681          
  13682            _delay_ms(250); //Wait to ensure all interrupts routines stopped
   \       0x2C   0x20FA             MOVS     R0,#+250
   \       0x2E   0x.... 0x....      BL       HAL_Delay
  13683            thermalManager.disable_all_heaters(); //turn off heaters again
   \       0x32   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
  13684          
  13685            #if HAS_POWER_SWITCH
  13686              SET_INPUT(PS_ON_PIN);
  13687            #endif
  13688          
  13689            suicide();
   \       0x36   0x.... 0x....      BL       _Z7suicidev
  13690            while (1) {
   \                     ??kill_0: (+1)
   \       0x3A   0xE7FE             B.N      ??kill_0
  13691              #if ENABLED(USE_WATCHDOG)
  13692                watchdog_reset();
  13693              #endif
  13694            } // Wait for reset
  13695          }
  13696          
  13697          /**
  13698           * Turn off heaters and stop the print in progress
  13699           * After a stop the machine may be resumed with M999
  13700           */

   \                                 In section .text, align 2, keep-with-next
  13701          void stop() {
   \                     _Z4stopv: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
  13702          	thermalManager.disable_all_heaters(); // 'unpause' taken care of in here
   \        0x2   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
  13703          	
  13704          #if ENABLED(PROBING_FANS_OFF)
  13705          	  if (fans_paused) fans_pause(false); // put things back the way they were
  13706          #endif
  13707            if (IsRunning()) {
   \        0x6   0x.... 0x....      BL       _Z9IsRunningv
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD018             BEQ.N    ??stop_0
  13708              Stopped_gcode_LastN = gcode_LastN; // Save last g_code for restart
   \        0xE   0x.... 0x....      LDR.W    R4,??DataTable177
   \       0x12   0x.... 0x....      LDR.W    R0,??DataTable173
   \       0x16   0x6A00             LDR      R0,[R0, #+32]
   \       0x18   0x6220             STR      R0,[R4, #+32]
  13709              SERIAL_ERROR_START;
   \       0x1A   0x.... 0x....      LDR.W    R0,??DataTable178_1
   \       0x1E   0x.... 0x....      BL       _Z14serialprintPGMPKc
  13710              SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
   \       0x22   0x.... 0x....      ADR.W    R0,?_47
   \       0x26   0x.... 0x....      BL       _Z14serialprintPGMPKc
  13711              LCD_MESSAGEPGM(MSG_STOPPED);
   \       0x2A   0x2100             MOVS     R1,#+0
   \       0x2C   0x.... 0x....      ADR.W    R0,?_48
   \       0x30   0x.... 0x....      BL       _Z16lcd_setstatuspgmPKch
  13712              safe_delay(350);       // allow enough time for messages to get out before stopping
   \       0x34   0xF44F 0x70AF      MOV      R0,#+350
   \       0x38   0x.... 0x....      BL       _Z10safe_delaym
  13713              Running = false;
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0x7020             STRB     R0,[R4, #+0]
  13714            }
  13715          }
   \                     ??stop_0: (+1)
   \       0x40   0xBD10             POP      {R4,PC}          ;; return
  13716          
  13717          /**
  13718           * Marlin entry-point: Set up before the program loop
  13719           *  - Set up the kill pin, filament runout, power hold
  13720           *  - Start the serial port
  13721           *  - Print startup messages and diagnostics
  13722           *  - Get EEPROM or default settings
  13723           *  - Initialize managers for:
  13724           *    â?temperature
  13725           *    â?planner
  13726           *    â?watchdog
  13727           *    â?stepper
  13728           *    â?photo pin
  13729           *    â?servos
  13730           *    â?LCD controller
  13731           *    â?Digipot I2C
  13732           *    â?Z probe sled
  13733           *    â?status LEDs
  13734           */
  13735          /*--mks--*/

   \                                 In section .text, align 2, keep-with-next
  13736          void setup() {
   \                     setup: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
  13737          /*	
  13738            #ifdef DISABLE_JTAG
  13739              // Disable JTAG on AT90USB chips to free up pins for IO
  13740              MCUCR = 0x80;
  13741              MCUCR = 0x80;
  13742            #endif
  13743          */
  13744            #if ENABLED(FILAMENT_RUNOUT_SENSOR)
  13745              setup_filrunoutpin();
   \        0x2   0x.... 0x....      BL       _Z18setup_filrunoutpinv
  13746            #endif
  13747          
  13748            setup_killpin();
   \        0x6   0x.... 0x....      BL       _Z13setup_killpinv
  13749          
  13750            //setup_powerhold();	/*--mks--*/
  13751          
  13752            #if HAS_STEPPER_RESET
  13753              disableStepperDrivers();
  13754            #endif
  13755          
  13756            //MYSERIAL.begin(BAUDRATE);	/*--mks--*/
  13757          //  SERIAL_PROTOCOLLNPGM("start");
  13758          //  SERIAL_ECHO_START;
  13759          
  13760            // Check startup - does nothing if bootloader sets MCUSR to 0
  13761            byte mcu = MCUSR;
  13762            if (mcu & 1) SERIAL_ECHOLNPGM(MSG_POWERUP);
  13763            if (mcu & 2) SERIAL_ECHOLNPGM(MSG_EXTERNAL_RESET);
  13764            if (mcu & 4) SERIAL_ECHOLNPGM(MSG_BROWNOUT_RESET);
  13765            if (mcu & 8) SERIAL_ECHOLNPGM(MSG_WATCHDOG_RESET);
  13766            if (mcu & 32) SERIAL_ECHOLNPGM(MSG_SOFTWARE_RESET);
  13767            //MCUSR = 0; /*--mks--*/
  13768          
  13769            SERIAL_ECHOPGM(MSG_MARLIN);
   \        0xA   0x.... 0x....      ADR.W    R0,?_49
   \        0xE   0x.... 0x....      BL       _Z14serialprintPGMPKc
  13770            SERIAL_CHAR(' ');
   \       0x12   0x.... 0x....      LDR.W    R4,??DataTable174_3
   \       0x16   0x79E0             LDRB     R0,[R4, #+7]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD105             BNE.N    ??setup_0
   \       0x1C   0x2120             MOVS     R1,#+32
   \       0x1E   0x.... 0x....      LDR.W    R0,??DataTable174_4
   \       0x22   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \       0x26   0xE005             B.N      ??setup_1
   \                     ??setup_0: (+1)
   \       0x28   0x2200             MOVS     R2,#+0
   \       0x2A   0x2120             MOVS     R1,#+32
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable174_5
   \       0x30   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
  13771            SERIAL_ECHOLNPGM(SHORT_BUILD_VERSION);
   \                     ??setup_1: (+1)
   \       0x34   0x....             ADR.N    R0,??DataTable166  ;; 0x20, 0x0A, 0x00, 0x00
   \       0x36   0x.... 0x....      BL       _Z14serialprintPGMPKc
  13772            SERIAL_EOL;
   \       0x3A   0x79E0             LDRB     R0,[R4, #+7]
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD105             BNE.N    ??setup_2
   \       0x40   0x210A             MOVS     R1,#+10
   \       0x42   0x.... 0x....      LDR.W    R0,??DataTable174_4
   \       0x46   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \       0x4A   0xE005             B.N      ??setup_3
   \                     ??setup_2: (+1)
   \       0x4C   0x2200             MOVS     R2,#+0
   \       0x4E   0x210A             MOVS     R1,#+10
   \       0x50   0x.... 0x....      LDR.W    R0,??DataTable174_5
   \       0x54   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
  13773          
  13774            #if defined(STRING_DISTRIBUTION_DATE) && defined(STRING_CONFIG_H_AUTHOR)
  13775              SERIAL_ECHO_START;
   \                     ??setup_3: (+1)
   \       0x58   0x.... 0x....      LDR.W    R5,??DataTable179
   \       0x5C   0x4628             MOV      R0,R5
   \       0x5E   0x.... 0x....      BL       _Z14serialprintPGMPKc
  13776              SERIAL_ECHOPGM(MSG_CONFIGURATION_VER);
   \       0x62   0x.... 0x....      ADR.W    R0,?_51
   \       0x66   0x.... 0x....      BL       _Z14serialprintPGMPKc
  13777              SERIAL_ECHOPGM(STRING_DISTRIBUTION_DATE);
   \       0x6A   0x.... 0x....      ADR.W    R0,?_52
   \       0x6E   0x.... 0x....      BL       _Z14serialprintPGMPKc
  13778              SERIAL_ECHOLNPGM(MSG_AUTHOR STRING_CONFIG_H_AUTHOR);
   \       0x72   0x.... 0x....      ADR.W    R0,?_53
   \       0x76   0x.... 0x....      BL       _Z14serialprintPGMPKc
  13779              SERIAL_ECHOLNPGM("Compiled: " __DATE__);
   \       0x7A   0x.... 0x....      ADR.W    R0,?_54
   \       0x7E   0x.... 0x....      BL       _Z14serialprintPGMPKc
  13780            #endif
  13781          
  13782            SERIAL_ECHO_START;
   \       0x82   0x4628             MOV      R0,R5
   \       0x84   0x.... 0x....      BL       _Z14serialprintPGMPKc
  13783            SERIAL_ECHOPAIR(MSG_FREE_MEMORY, freeMemory());
   \       0x88   0x.... 0x....      BL       _Z10freeMemoryv
   \       0x8C   0x4601             MOV      R1,R0
   \       0x8E   0x.... 0x....      ADR.W    R0,?_55
   \       0x92   0x.... 0x....      BL       _Z17serial_echopair_PPKci
  13784            SERIAL_ECHOLNPAIR(MSG_PLANNER_BUFFER_BYTES, (int)sizeof(block_t)*BLOCK_BUFFER_SIZE);
   \       0x96   0xF44F 0x61A8      MOV      R1,#+1344
   \       0x9A   0x.... 0x....      ADR.W    R0,?_56
   \       0x9E   0x.... 0x....      BL       _Z17serial_echopair_PPKci
   \       0xA2   0x79E0             LDRB     R0,[R4, #+7]
   \       0xA4   0x2800             CMP      R0,#+0
   \       0xA6   0xD105             BNE.N    ??setup_4
   \       0xA8   0x210A             MOVS     R1,#+10
   \       0xAA   0x.... 0x....      LDR.W    R0,??DataTable174_4
   \       0xAE   0x.... 0x....      BL       _ZN12MarlinSerial5writeEh
   \       0xB2   0xE005             B.N      ??setup_5
   \                     ??setup_4: (+1)
   \       0xB4   0x2200             MOVS     R2,#+0
   \       0xB6   0x210A             MOVS     R1,#+10
   \       0xB8   0x.... 0x....      LDR.W    R0,??DataTable174_5
   \       0xBC   0x.... 0x....      BL       _ZN12MarlinSerial5printEci
  13785          
  13786            // Send "ok" after commands by default
  13787            for (int8_t i = 0; i < BUFSIZE; i++) send_ok[i] = true;
   \                     ??setup_5: (+1)
   \       0xC0   0x2000             MOVS     R0,#+0
   \       0xC2   0x2201             MOVS     R2,#+1
   \       0xC4   0x.... 0x....      LDR.W    R3,??DataTable173
   \       0xC8   0xE002             B.N      ??setup_6
   \                     ??setup_7: (+1)
   \       0xCA   0x4419             ADD      R1,R3,R1
   \       0xCC   0x750A             STRB     R2,[R1, #+20]
   \       0xCE   0x1C40             ADDS     R0,R0,#+1
   \                     ??setup_6: (+1)
   \       0xD0   0x4601             MOV      R1,R0
   \       0xD2   0xB249             SXTB     R1,R1
   \       0xD4   0x2904             CMP      R1,#+4
   \       0xD6   0xDBF8             BLT.N    ??setup_7
  13788          
  13789            // Load data from EEPROM if available (or use defaults)
  13790            // This also updates variables in the planner, elsewhere
  13791            (void)settings.load();
   \       0xD8   0x.... 0x....      BL       _ZN14MarlinSettings4loadEv
  13792          
  13793            //#if HAS_M206_COMMAND			//mks_delta
  13794            if(MACHINETPYE != DELTA)
   \       0xDC   0x.... 0x....      LDR.W    R0,??DataTable174_2
   \       0xE0   0xF9B0 0x0058      LDRSH    R0,[R0, #+88]
   \       0xE4   0x2802             CMP      R0,#+2
   \       0xE6   0xD007             BEQ.N    ??setup_8
  13795              // Initialize current position based on home_offset
  13796              COPY(current_position, home_offset);
   \       0xE8   0x220C             MOVS     R2,#+12
   \       0xEA   0xF104 0x0138      ADD      R1,R4,#+56
   \       0xEE   0xF104 0x0008      ADD      R0,R4,#+8
   \       0xF2   0x.... 0x....      BL       __aeabi_memcpy
   \       0xF6   0xE005             B.N      ??setup_9
  13797            //#else
  13798            else
  13799              ZERO(current_position);
   \                     ??setup_8: (+1)
   \       0xF8   0x2200             MOVS     R2,#+0
   \       0xFA   0x2110             MOVS     R1,#+16
   \       0xFC   0xF104 0x0008      ADD      R0,R4,#+8
   \      0x100   0x.... 0x....      BL       __aeabi_memset
  13800          //  #endif
  13801          
  13802            // Vital to init stepper/planner equivalent for current_position
  13803            SYNC_PLAN_POSITION_KINEMATIC();
   \                     ??setup_9: (+1)
   \      0x104   0x.... 0x....      BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
  13804          
  13805            thermalManager.init();    // Initialize temperature loop
   \      0x108   0x.... 0x....      LDR.W    R0,??DataTable180_1
   \      0x10C   0x.... 0x....      BL       _ZN11Temperature4initEv
  13806          
  13807            #if ENABLED(USE_WATCHDOG)
  13808              watchdog_init();
  13809            #endif
  13810          
  13811            stepper.init();    // Initialize stepper, this enables interrupts!
   \      0x110   0x.... 0x....      BL       _ZN7Stepper4initEv
  13812            servo_init();
   \      0x114   0x.... 0x....      BL       _Z10servo_initv
  13813          
  13814            #if HAS_PHOTOGRAPH
  13815              OUT_WRITE(PHOTOGRAPH_PIN, LOW);
  13816            #endif
  13817          
  13818            #if HAS_CASE_LIGHT
  13819              update_case_light();
  13820            #endif
  13821          
  13822            #if HAS_BED_PROBE
  13823              endstops.enable_z_probe(false);
   \      0x118   0x2000             MOVS     R0,#+0
   \      0x11A   0x.... 0x....      BL       _ZN8Endstops14enable_z_probeEb
  13824            #endif
  13825          
  13826          #if ENABLED(USE_CONTROLLER_FAN)
  13827              SET_OUTPUT(CONTROLLER_FAN_PIN); //Set pin used for driver cooling fan
  13828            #endif
  13829          
  13830            #if HAS_STEPPER_RESET
  13831              enableStepperDrivers();
  13832            #endif
  13833          
  13834            #if ENABLED(DIGIPOT_I2C)
  13835              digipot_i2c_init();
  13836            #endif
  13837          
  13838            #if ENABLED(DAC_STEPPER_CURRENT)
  13839              dac_init();
  13840            #endif
  13841          
  13842            #if (ENABLED(Z_PROBE_SLED) || ENABLED(SOLENOID_PROBE)) && HAS_SOLENOID_1
  13843              OUT_WRITE(SOL1_PIN, LOW); // turn it off
  13844            #endif
  13845          
  13846            setup_homepin();
   \      0x11E   0x.... 0x....      BL       _Z13setup_homepinv
  13847          
  13848            #if PIN_EXISTS(STAT_LED_RED)
  13849              OUT_WRITE(STAT_LED_RED_PIN, LOW); // turn it off
  13850            #endif
  13851          
  13852            #if PIN_EXISTS(STAT_LED_BLUE)
  13853              OUT_WRITE(STAT_LED_BLUE_PIN, LOW); // turn it off
  13854            #endif
  13855          
  13856            #if ENABLED(RGB_LED) || ENABLED(RGBW_LED)
  13857              SET_OUTPUT(RGB_LED_R_PIN);
  13858              SET_OUTPUT(RGB_LED_G_PIN);
  13859              SET_OUTPUT(RGB_LED_B_PIN);
  13860              #if ENABLED(RGBW_LED)
  13861                SET_OUTPUT(RGB_LED_W_PIN);
  13862              #endif
  13863            #endif
  13864          
  13865            lcd_init();
   \      0x122   0x.... 0x....      BL       _Z8lcd_initv
  13866            #if ENABLED(SHOW_BOOTSCREEN)
  13867              #if ENABLED(DOGLCD)
  13868                safe_delay(BOOTSCREEN_TIMEOUT);
   \      0x126   0xF640 0x10C4      MOVW     R0,#+2500
   \      0x12A   0x.... 0x....      BL       _Z10safe_delaym
  13869              #elif ENABLED(ULTRA_LCD)
  13870                bootscreen();
  13871                #if DISABLED(SDSUPPORT)
  13872                  lcd_init();
  13873                #endif
  13874              #endif
  13875            #endif
  13876          
  13877            #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
  13878              // Initialize mixing to 100% color 1
  13879              for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
  13880                mixing_factor[i] = (i == 0) ? 1.0 : 0.0;
  13881              for (uint8_t t = 0; t < MIXING_VIRTUAL_TOOLS; t++)
  13882                for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
  13883                  mixing_virtual_tool_mix[t][i] = mixing_factor[i];
  13884            #endif
  13885          
  13886            #if ENABLED(BLTOUCH)
  13887              // Make sure any BLTouch error condition is cleared
  13888              bltouch_command(BLTOUCH_RESET);
  13889              set_bltouch_deployed(true);
  13890              set_bltouch_deployed(false);
  13891            #endif
  13892          
  13893            #if ENABLED(EXPERIMENTAL_I2CBUS) && I2C_SLAVE_ADDRESS > 0
  13894              i2c.onReceive(i2c_on_receive);
  13895              i2c.onRequest(i2c_on_request);
  13896            #endif
  13897          
  13898            #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
  13899              setup_endstop_interrupts();
  13900            #endif
  13901              
  13902            BLINK_LED(LED_ON);
   \      0x12E   0xF44F 0x607A      MOV      R0,#+4000
   \      0x132   0x.... 0x....      LDR.W    R1,??DataTable183
   \      0x136   0x8008             STRH     R0,[R1, #+0]
  13903          }
   \      0x138   0xBD31             POP      {R0,R4,R5,PC}    ;; return
  13904          
  13905          /**
  13906           * The main Marlin program loop
  13907           *
  13908           *  - Save or log commands to SD
  13909           *  - Process available commands (if not saving)
  13910           *  - Call heater manager
  13911           *  - Call inactivity manager
  13912           *  - Call endstop manager
  13913           *  - Call LCD update
  13914           */

   \                                 In section .text, align 2, keep-with-next
  13915          void loop() {
   \                     loop: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
  13916            if (commands_in_queue < BUFSIZE) 
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable173
   \        0x6   0x7A20             LDRB     R0,[R4, #+8]
   \        0x8   0x2804             CMP      R0,#+4
   \        0xA   0xDA01             BGE.N    ??loop_0
  13917              get_available_commands();
   \        0xC   0x.... 0x....      BL       _Z22get_available_commandsv
  13918          
  13919            #if ENABLED(SDSUPPORT)
  13920              card.checkautostart(false);
   \                     ??loop_0: (+1)
   \       0x10   0x.... 0x....      LDR.W    R5,??DataTable173_3
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x4628             MOV      R0,R5
   \       0x18   0x.... 0x....      BL       _ZN10CardReader14checkautostartEb
  13921            #endif
  13922          
  13923            if (commands_in_queue) {
   \       0x1C   0x7A20             LDRB     R0,[R4, #+8]
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD03B             BEQ.N    ??loop_1
  13924          
  13925              #if ENABLED(SDSUPPORT)
  13926          	
  13927                if (card.saving) {
   \       0x22   0x7828             LDRB     R0,[R5, #+0]
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD029             BEQ.N    ??loop_2
  13928                  char* command = command_queue[cmd_queue_index_r];
   \       0x28   0x.... 0x....      LDR.W    R0,??DataTable184
   \       0x2C   0x7A61             LDRB     R1,[R4, #+9]
   \       0x2E   0xEB01 0x0241      ADD      R2,R1,R1, LSL #+1
   \       0x32   0xEB10 0x1642      ADDS     R6,R0,R2, LSL #+5
  13929                  if (strstr_P(command, PSTR("M29"))) {
   \       0x36   0x....             ADR.N    R1,??DataTable168  ;; "M29"
   \       0x38   0x4630             MOV      R0,R6
   \       0x3A   0x.... 0x....      BL       __iar_Strstr
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD00F             BEQ.N    ??loop_3
  13930                    // M29 closes the file
  13931                    card.closefile();
   \       0x42   0x2100             MOVS     R1,#+0
   \       0x44   0x4628             MOV      R0,R5
   \       0x46   0x.... 0x....      BL       _ZN10CardReader9closefileEb
  13932                    SERIAL_PROTOCOLLNPGM(MSG_FILE_SAVED);
   \       0x4A   0x.... 0x....      ADR.W    R0,?_58
   \       0x4E   0x.... 0x....      BL       _Z14serialprintPGMPKc
  13933                    ok_to_send();
   \       0x52   0x.... 0x....      BL       _Z10ok_to_sendv
  13934                    BLINK_LED(LED_ON);
   \       0x56   0xF44F 0x607A      MOV      R0,#+4000
   \       0x5A   0x.... 0x....      LDR.W    R1,??DataTable183
   \       0x5E   0x8008             STRH     R0,[R1, #+0]
   \       0x60   0xE00E             B.N      ??loop_4
  13935                  }
  13936                  else {
  13937                    // Write the string from the read buffer to SD
  13938                    card.write_command(command);
   \                     ??loop_3: (+1)
   \       0x62   0x4631             MOV      R1,R6
   \       0x64   0x4628             MOV      R0,R5
   \       0x66   0x.... 0x....      BL       _ZN10CardReader13write_commandEPc
  13939                    if (card.logging)
   \       0x6A   0x7868             LDRB     R0,[R5, #+1]
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0xD002             BEQ.N    ??loop_5
  13940                      process_next_command(); // The card is saving because it's logging
   \       0x70   0x.... 0x....      BL       _Z20process_next_commandv
   \       0x74   0xE004             B.N      ??loop_4
  13941                    else
  13942                      ok_to_send();
   \                     ??loop_5: (+1)
   \       0x76   0x.... 0x....      BL       _Z10ok_to_sendv
   \       0x7A   0xE001             B.N      ??loop_4
  13943                  }
  13944                }
  13945                else
  13946                  process_next_command();
   \                     ??loop_2: (+1)
   \       0x7C   0x.... 0x....      BL       _Z20process_next_commandv
  13947          
  13948              #else
  13949          
  13950                process_next_command();
  13951          
  13952              #endif // SDSUPPORT
  13953          
  13954              // The queue may be reset by a command handler or by code invoked by idle() within a handler
  13955              if (commands_in_queue) {
   \                     ??loop_4: (+1)
   \       0x80   0x7A20             LDRB     R0,[R4, #+8]
   \       0x82   0x2800             CMP      R0,#+0
   \       0x84   0xD009             BEQ.N    ??loop_1
  13956                --commands_in_queue;
   \       0x86   0x1E40             SUBS     R0,R0,#+1
   \       0x88   0x7220             STRB     R0,[R4, #+8]
  13957                if (++cmd_queue_index_r >= BUFSIZE) cmd_queue_index_r = 0;
   \       0x8A   0x7A60             LDRB     R0,[R4, #+9]
   \       0x8C   0x1C40             ADDS     R0,R0,#+1
   \       0x8E   0x7260             STRB     R0,[R4, #+9]
   \       0x90   0xB2C0             UXTB     R0,R0
   \       0x92   0x2804             CMP      R0,#+4
   \       0x94   0xDB01             BLT.N    ??loop_1
   \       0x96   0x2000             MOVS     R0,#+0
   \       0x98   0x7260             STRB     R0,[R4, #+9]
  13958              }
  13959            }
  13960            endstops.report_state();
   \                     ??loop_1: (+1)
   \       0x9A   0x.... 0x....      BL       _ZN8Endstops12report_stateEv
  13961            idle();
   \       0x9E   0x2000             MOVS     R0,#+0
   \       0xA0   0x.... 0x....      BL       _Z4idleb
  13962          //#if MASK_FOR_SPACE
  13963            mks_PrintStatePolling();
   \       0xA4   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0xA8   0x....             B.N      mks_PrintStatePolling
  13964          //#endif
  13965          }
  13966          
  13967          
  13968          #include "mks_reprint.cpp"

   \                                 In section .bss, align 4
   \   __absolute DATA_REPRINT_ITMES mksReprint
   \                     mksReprint:
   \        0x0                      DS8 1048

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_initPrint()
   \                     mks_initPrint: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable183_1
   \        0x6   0x.... 0x....      LDR.W    R4,??DataTable183_2
   \        0xA   0x6801             LDR      R1,[R0, #+0]
   \        0xC   0x6361             STR      R1,[R4, #+52]
   \        0xE   0x6841             LDR      R1,[R0, #+4]
   \       0x10   0x63A1             STR      R1,[R4, #+56]
   \       0x12   0x6880             LDR      R0,[R0, #+8]
   \       0x14   0x63E0             STR      R0,[R4, #+60]
   \       0x16   0x.... 0x....      LDR.W    R0,??DataTable186  ;; 0x40a00000
   \       0x1A   0x6420             STR      R0,[R4, #+64]
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0x6460             STR      R0,[R4, #+68]
   \       0x20   0xF104 0x0568      ADD      R5,R4,#+104
   \       0x24   0x20A6             MOVS     R0,#+166
   \       0x26   0x7028             STRB     R0,[R5, #+0]
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0x6068             STR      R0,[R5, #+4]
   \       0x2C   0x4602             MOV      R2,R0
   \       0x2E   0x2114             MOVS     R1,#+20
   \       0x30   0x4620             MOV      R0,R4
   \       0x32   0x.... 0x....      BL       __aeabi_memset4
   \       0x36   0x2200             MOVS     R2,#+0
   \       0x38   0x211E             MOVS     R1,#+30
   \       0x3A   0xF104 0x0014      ADD      R0,R4,#+20
   \       0x3E   0x.... 0x....      BL       __aeabi_memset4
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0x8528             STRH     R0,[R5, #+40]
   \       0x46   0x8168             STRH     R0,[R5, #+10]
   \       0x48   0x81A8             STRH     R0,[R5, #+12]
   \       0x4A   0xF884 0x0414      STRB     R0,[R4, #+1044]
   \       0x4E   0x7228             STRB     R0,[R5, #+8]
   \       0x50   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_WriteToEpr()
   \                     _Z14mks_WriteToEprv: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x.... 0x....      LDR.W    R4,??DataTable183_2
   \        0x8   0xF104 0x056C      ADD      R5,R4,#+108
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable173_3
   \       0x10   0x.... 0x....      BL       _ZN10CardReader8getsdposEv
   \       0x14   0x6028             STR      R0,[R5, #+0]
   \       0x16   0x2204             MOVS     R2,#+4
   \       0x18   0x4629             MOV      R1,R5
   \       0x1A   0xF240 0x5079      MOVW     R0,#+1401
   \       0x1E   0x.... 0x....      BL       epr_write_data
   \       0x22   0x.... 0x....      LDR.W    R0,??DataTable184_2
   \       0x26   0x6800             LDR      R0,[R0, #+0]
   \       0x28   0x80E8             STRH     R0,[R5, #+6]
   \       0x2A   0x2202             MOVS     R2,#+2
   \       0x2C   0xF104 0x0172      ADD      R1,R4,#+114
   \       0x30   0xF240 0x507D      MOVW     R0,#+1405
   \       0x34   0x.... 0x....      BL       epr_write_data
   \       0x38   0x.... 0x....      LDR.W    R0,??DataTable174_2
   \       0x3C   0xF890 0x0036      LDRB     R0,[R0, #+54]
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD00A             BEQ.N    ??mks_WriteToEpr_0
   \       0x44   0x.... 0x....      LDR.W    R0,??DataTable184_3
   \       0x48   0x6800             LDR      R0,[R0, #+0]
   \       0x4A   0x8128             STRH     R0,[R5, #+8]
   \       0x4C   0x2202             MOVS     R2,#+2
   \       0x4E   0xF104 0x0174      ADD      R1,R4,#+116
   \       0x52   0xF240 0x507F      MOVW     R0,#+1407
   \       0x56   0x.... 0x....      BL       epr_write_data
   \                     ??mks_WriteToEpr_0: (+1)
   \       0x5A   0x2204             MOVS     R2,#+4
   \       0x5C   0xF104 0x0148      ADD      R1,R4,#+72
   \       0x60   0xF240 0x5081      MOVW     R0,#+1409
   \       0x64   0x.... 0x....      BL       epr_write_data
   \       0x68   0x2204             MOVS     R2,#+4
   \       0x6A   0xF104 0x014C      ADD      R1,R4,#+76
   \       0x6E   0xF240 0x5085      MOVW     R0,#+1413
   \       0x72   0x.... 0x....      BL       epr_write_data
   \       0x76   0x2204             MOVS     R2,#+4
   \       0x78   0xF104 0x0150      ADD      R1,R4,#+80
   \       0x7C   0xF240 0x5089      MOVW     R0,#+1417
   \       0x80   0x.... 0x....      BL       epr_write_data
   \       0x84   0x2204             MOVS     R2,#+4
   \       0x86   0xF104 0x0154      ADD      R1,R4,#+84
   \       0x8A   0xF240 0x508D      MOVW     R0,#+1421
   \       0x8E   0x.... 0x....      BL       epr_write_data
   \       0x92   0x2204             MOVS     R2,#+4
   \       0x94   0xF104 0x0158      ADD      R1,R4,#+88
   \       0x98   0xF240 0x5091      MOVW     R0,#+1425
   \       0x9C   0x.... 0x....      BL       epr_write_data
   \       0xA0   0x2204             MOVS     R2,#+4
   \       0xA2   0xF104 0x015C      ADD      R1,R4,#+92
   \       0xA6   0xF240 0x5095      MOVW     R0,#+1429
   \       0xAA   0x.... 0x....      BL       epr_write_data
   \       0xAE   0x2204             MOVS     R2,#+4
   \       0xB0   0xF104 0x0160      ADD      R1,R4,#+96
   \       0xB4   0xF240 0x5099      MOVW     R0,#+1433
   \       0xB8   0x.... 0x....      BL       epr_write_data
   \       0xBC   0x2204             MOVS     R2,#+4
   \       0xBE   0xF104 0x0164      ADD      R1,R4,#+100
   \       0xC2   0xF240 0x509D      MOVW     R0,#+1437
   \       0xC6   0x.... 0x....      BL       epr_write_data
   \       0xCA   0xF104 0x0680      ADD      R6,R4,#+128
   \       0xCE   0xF104 0x0784      ADD      R7,R4,#+132
   \       0xD2   0xF104 0x0888      ADD      R8,R4,#+136
   \       0xD6   0x4643             MOV      R3,R8
   \       0xD8   0x463A             MOV      R2,R7
   \       0xDA   0x4631             MOV      R1,R6
   \       0xDC   0x.... 0x....      LDR.W    R0,??DataTable173_4
   \       0xE0   0x.... 0x....      BL       _ZN9Stopwatch7getTimeEPmS0_S0_
   \       0xE4   0x.... 0x....      BL       HAL_GetTick
   \       0xE8   0x6228             STR      R0,[R5, #+32]
   \       0xEA   0x2204             MOVS     R2,#+4
   \       0xEC   0x4631             MOV      R1,R6
   \       0xEE   0xF240 0x50A6      MOVW     R0,#+1446
   \       0xF2   0x.... 0x....      BL       epr_write_data
   \       0xF6   0x2204             MOVS     R2,#+4
   \       0xF8   0x4639             MOV      R1,R7
   \       0xFA   0xF240 0x50AA      MOVW     R0,#+1450
   \       0xFE   0x.... 0x....      BL       epr_write_data
   \      0x102   0x2204             MOVS     R2,#+4
   \      0x104   0x4641             MOV      R1,R8
   \      0x106   0xF240 0x50AE      MOVW     R0,#+1454
   \      0x10A   0x.... 0x....      BL       epr_write_data
   \      0x10E   0x2204             MOVS     R2,#+4
   \      0x110   0xF104 0x018C      ADD      R1,R4,#+140
   \      0x114   0xF240 0x50B2      MOVW     R0,#+1458
   \      0x118   0x.... 0x....      BL       epr_write_data
   \      0x11C   0x2201             MOVS     R2,#+1
   \      0x11E   0xF104 0x017C      ADD      R1,R4,#+124
   \      0x122   0xF240 0x50A5      MOVW     R0,#+1445
   \      0x126   0x.... 0x....      BL       epr_write_data
   \      0x12A   0x2204             MOVS     R2,#+4
   \      0x12C   0xF104 0x0178      ADD      R1,R4,#+120
   \      0x130   0xF240 0x50A1      MOVW     R0,#+1441
   \      0x134   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \      0x138   0x.... 0x....      B.W      epr_write_data

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_ReadFromEpr()
   \                     mks_ReadFromEpr: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable183_2
   \        0x6   0x221E             MOVS     R2,#+30
   \        0x8   0xF104 0x0114      ADD      R1,R4,#+20
   \        0xC   0xF240 0x50B6      MOVW     R0,#+1462
   \       0x10   0x.... 0x....      BL       epr_read_data
   \       0x14   0x2204             MOVS     R2,#+4
   \       0x16   0xF104 0x016C      ADD      R1,R4,#+108
   \       0x1A   0xF240 0x5079      MOVW     R0,#+1401
   \       0x1E   0x.... 0x....      BL       epr_read_data
   \       0x22   0x2202             MOVS     R2,#+2
   \       0x24   0xF104 0x0172      ADD      R1,R4,#+114
   \       0x28   0xF240 0x507D      MOVW     R0,#+1405
   \       0x2C   0x.... 0x....      BL       epr_read_data
   \       0x30   0x.... 0x....      LDR.W    R0,??DataTable174_2
   \       0x34   0xF890 0x0036      LDRB     R0,[R0, #+54]
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD006             BEQ.N    ??mks_ReadFromEpr_0
   \       0x3C   0x2202             MOVS     R2,#+2
   \       0x3E   0xF104 0x0174      ADD      R1,R4,#+116
   \       0x42   0xF240 0x507F      MOVW     R0,#+1407
   \       0x46   0x.... 0x....      BL       epr_read_data
   \                     ??mks_ReadFromEpr_0: (+1)
   \       0x4A   0x2204             MOVS     R2,#+4
   \       0x4C   0xF104 0x0148      ADD      R1,R4,#+72
   \       0x50   0xF240 0x5081      MOVW     R0,#+1409
   \       0x54   0x.... 0x....      BL       epr_read_data
   \       0x58   0x2204             MOVS     R2,#+4
   \       0x5A   0xF104 0x014C      ADD      R1,R4,#+76
   \       0x5E   0xF240 0x5085      MOVW     R0,#+1413
   \       0x62   0x.... 0x....      BL       epr_read_data
   \       0x66   0x2204             MOVS     R2,#+4
   \       0x68   0xF104 0x0150      ADD      R1,R4,#+80
   \       0x6C   0xF240 0x5089      MOVW     R0,#+1417
   \       0x70   0x.... 0x....      BL       epr_read_data
   \       0x74   0x2204             MOVS     R2,#+4
   \       0x76   0xF104 0x0154      ADD      R1,R4,#+84
   \       0x7A   0xF240 0x508D      MOVW     R0,#+1421
   \       0x7E   0x.... 0x....      BL       epr_read_data
   \       0x82   0x2204             MOVS     R2,#+4
   \       0x84   0xF104 0x0158      ADD      R1,R4,#+88
   \       0x88   0xF240 0x5091      MOVW     R0,#+1425
   \       0x8C   0x.... 0x....      BL       epr_read_data
   \       0x90   0x2204             MOVS     R2,#+4
   \       0x92   0xF104 0x015C      ADD      R1,R4,#+92
   \       0x96   0xF240 0x5095      MOVW     R0,#+1429
   \       0x9A   0x.... 0x....      BL       epr_read_data
   \       0x9E   0x2204             MOVS     R2,#+4
   \       0xA0   0xF104 0x0160      ADD      R1,R4,#+96
   \       0xA4   0xF240 0x5099      MOVW     R0,#+1433
   \       0xA8   0x.... 0x....      BL       epr_read_data
   \       0xAC   0x2204             MOVS     R2,#+4
   \       0xAE   0xF104 0x0164      ADD      R1,R4,#+100
   \       0xB2   0xF240 0x509D      MOVW     R0,#+1437
   \       0xB6   0x.... 0x....      BL       epr_read_data
   \       0xBA   0x2204             MOVS     R2,#+4
   \       0xBC   0xF104 0x0180      ADD      R1,R4,#+128
   \       0xC0   0xF240 0x50A6      MOVW     R0,#+1446
   \       0xC4   0x.... 0x....      BL       epr_read_data
   \       0xC8   0x2204             MOVS     R2,#+4
   \       0xCA   0xF104 0x0184      ADD      R1,R4,#+132
   \       0xCE   0xF240 0x50AA      MOVW     R0,#+1450
   \       0xD2   0x.... 0x....      BL       epr_read_data
   \       0xD6   0x2204             MOVS     R2,#+4
   \       0xD8   0xF104 0x0188      ADD      R1,R4,#+136
   \       0xDC   0xF240 0x50AE      MOVW     R0,#+1454
   \       0xE0   0x.... 0x....      BL       epr_read_data
   \       0xE4   0x2204             MOVS     R2,#+4
   \       0xE6   0xF104 0x018C      ADD      R1,R4,#+140
   \       0xEA   0xF240 0x50B2      MOVW     R0,#+1458
   \       0xEE   0x.... 0x....      BL       epr_read_data
   \       0xF2   0x2201             MOVS     R2,#+1
   \       0xF4   0xF104 0x017C      ADD      R1,R4,#+124
   \       0xF8   0xF240 0x50A5      MOVW     R0,#+1445
   \       0xFC   0x.... 0x....      BL       epr_read_data
   \      0x100   0x2204             MOVS     R2,#+4
   \      0x102   0xF104 0x0178      ADD      R1,R4,#+120
   \      0x106   0xF240 0x50A1      MOVW     R0,#+1441
   \      0x10A   0xE8BD 0x4010      POP      {R4,LR}
   \      0x10E   0x.... 0x....      B.W      epr_read_data

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_resumePrint()
   \                     mks_resumePrint: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable183_2
   \        0x6   0xF894 0x0068      LDRB     R0,[R4, #+104]
   \        0xA   0x28A9             CMP      R0,#+169
   \        0xC   0xD111             BNE.N    ??mks_resumePrint_0
   \        0xE   0x20A7             MOVS     R0,#+167
   \       0x10   0xF884 0x0068      STRB     R0,[R4, #+104]
   \       0x14   0x6C20             LDR      R0,[R4, #+64]
   \       0x16   0x.... 0x....      BL       mks_preExtrude
   \       0x1A   0x6DE1             LDR      R1,[R4, #+92]
   \       0x1C   0x6DA0             LDR      R0,[R4, #+88]
   \       0x1E   0x.... 0x....      BL       mks_moveXY
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x.... 0x....      BL       mks_moveZ
   \       0x28   0x2100             MOVS     R1,#+0
   \       0x2A   0xF104 0x0014      ADD      R0,R4,#+20
   \       0x2E   0x.... 0x....      BL       _Z13lcd_setstatusPKcb
   \                     ??mks_resumePrint_0: (+1)
   \       0x32   0xF894 0x0068      LDRB     R0,[R4, #+104]
   \       0x36   0x28AA             CMP      R0,#+170
   \       0x38   0xD102             BNE.N    ??mks_resumePrint_1
   \       0x3A   0x20AB             MOVS     R0,#+171
   \       0x3C   0xF884 0x0068      STRB     R0,[R4, #+104]
   \                     ??mks_resumePrint_1: (+1)
   \       0x40   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp uint32_t pause_file_offset()
   \                     _Z17pause_file_offsetv: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x2500             MOVS     R5,#+0
   \        0x6   0xF04F 0x0860      MOV      R8,#+96
   \        0xA   0x.... 0x....      LDR.W    R9,??DataTable173
   \        0xE   0x.... 0x....      LDR.W    R0,??DataTable174_3
   \       0x12   0xF899 0x1011      LDRB     R1,[R9, #+17]
   \       0x16   0xFB08 0xF101      MUL      R1,R8,R1
   \       0x1A   0x4408             ADD      R0,R0,R1
   \       0x1C   0xF100 0x0188      ADD      R1,R0,#+136
   \       0x20   0xF109 0x0048      ADD      R0,R9,#+72
   \       0x24   0x.... 0x....      BL       strcpy
   \       0x28   0x....             LDR.N    R7,??DataTable173_3
   \       0x2A   0x6B79             LDR      R1,[R7, #+52]
   \       0x2C   0xF5B1 0x6F80      CMP      R1,#+1024
   \       0x30   0xD204             BCS.N    ??pause_file_offset_0
   \       0x32   0x4629             MOV      R1,R5
   \       0x34   0x4638             MOV      R0,R7
   \       0x36   0x.... 0x....      BL       _ZN10CardReader8setIndexEl
   \       0x3A   0xE004             B.N      ??pause_file_offset_1
   \                     ??pause_file_offset_0: (+1)
   \       0x3C   0xF5A1 0x6180      SUB      R1,R1,#+1024
   \       0x40   0x4638             MOV      R0,R7
   \       0x42   0x.... 0x....      BL       _ZN10CardReader8setIndexEl
   \                     ??pause_file_offset_1: (+1)
   \       0x46   0x4628             MOV      R0,R5
   \       0x48   0xF8C9 0x0044      STR      R0,[R9, #+68]
   \       0x4C   0xF8A9 0x0018      STRH     R0,[R9, #+24]
   \       0x50   0x4638             MOV      R0,R7
   \       0x52   0x.... 0x....      BL       _ZN10CardReader3eofEv
   \       0x56   0x4604             MOV      R4,R0
   \       0x58   0xE007             B.N      ??pause_file_offset_2
   \                     ??pause_file_offset_3: (+1)
   \       0x5A   0x462A             MOV      R2,R5
   \       0x5C   0x4641             MOV      R1,R8
   \       0x5E   0x4630             MOV      R0,R6
   \       0x60   0x.... 0x....      BL       __aeabi_memset
   \       0x64   0x4628             MOV      R0,R5
   \       0x66   0xF8C9 0x0044      STR      R0,[R9, #+68]
   \                     ??pause_file_offset_2: (+1)
   \       0x6A   0x2C00             CMP      R4,#+0
   \       0x6C   0xD16C             BNE.N    ??pause_file_offset_4
   \       0x6E   0xF8B9 0x0018      LDRH     R0,[R9, #+24]
   \       0x72   0xF5B0 0x6F80      CMP      R0,#+1024
   \       0x76   0xDA67             BGE.N    ??pause_file_offset_4
   \       0x78   0x4638             MOV      R0,R7
   \       0x7A   0x.... 0x....      BL       _ZN10CardReader3getEv
   \       0x7E   0x4682             MOV      R10,R0
   \       0x80   0x4656             MOV      R6,R10
   \       0x82   0xB276             SXTB     R6,R6
   \       0x84   0x4638             MOV      R0,R7
   \       0x86   0x.... 0x....      BL       _ZN10CardReader3eofEv
   \       0x8A   0x4604             MOV      R4,R0
   \       0x8C   0xF8B9 0x0018      LDRH     R0,[R9, #+24]
   \       0x90   0x1C40             ADDS     R0,R0,#+1
   \       0x92   0xF8A9 0x0018      STRH     R0,[R9, #+24]
   \       0x96   0x2C00             CMP      R4,#+0
   \       0x98   0xD10E             BNE.N    ??pause_file_offset_5
   \       0x9A   0xF11A 0x0F01      CMN      R10,#+1
   \       0x9E   0xD00B             BEQ.N    ??pause_file_offset_5
   \       0xA0   0x2E0A             CMP      R6,#+10
   \       0xA2   0xD009             BEQ.N    ??pause_file_offset_5
   \       0xA4   0x2E0D             CMP      R6,#+13
   \       0xA6   0xD007             BEQ.N    ??pause_file_offset_5
   \       0xA8   0x2E23             CMP      R6,#+35
   \       0xAA   0xD001             BEQ.N    ??pause_file_offset_6
   \       0xAC   0x2E3A             CMP      R6,#+58
   \       0xAE   0xD125             BNE.N    ??pause_file_offset_7
   \                     ??pause_file_offset_6: (+1)
   \       0xB0   0xF899 0x0012      LDRB     R0,[R9, #+18]
   \       0xB4   0x2800             CMP      R0,#+0
   \       0xB6   0xD121             BNE.N    ??pause_file_offset_7
   \                     ??pause_file_offset_5: (+1)
   \       0xB8   0x2C00             CMP      R4,#+0
   \       0xBA   0xD145             BNE.N    ??pause_file_offset_4
   \       0xBC   0x2000             MOVS     R0,#+0
   \       0xBE   0xF889 0x0012      STRB     R0,[R9, #+18]
   \       0xC2   0x2D00             CMP      R5,#+0
   \       0xC4   0xD0D1             BEQ.N    ??pause_file_offset_2
   \       0xC6   0x.... 0x....      LDR.W    R0,??DataTable184
   \       0xCA   0xF899 0x100A      LDRB     R1,[R9, #+10]
   \       0xCE   0xFB08 0xF101      MUL      R1,R8,R1
   \       0xD2   0x1846             ADDS     R6,R0,R1
   \       0xD4   0x2000             MOVS     R0,#+0
   \       0xD6   0x5570             STRB     R0,[R6, R5]
   \       0xD8   0x4605             MOV      R5,R0
   \       0xDA   0x4631             MOV      R1,R6
   \       0xDC   0xF109 0x0048      ADD      R0,R9,#+72
   \       0xE0   0x.... 0x....      BL       strcmp
   \       0xE4   0x2800             CMP      R0,#+0
   \       0xE6   0xD1B8             BNE.N    ??pause_file_offset_3
   \       0xE8   0x6B79             LDR      R1,[R7, #+52]
   \       0xEA   0xF8D9 0x0044      LDR      R0,[R9, #+68]
   \       0xEE   0x1A09             SUBS     R1,R1,R0
   \       0xF0   0x1E49             SUBS     R1,R1,#+1
   \       0xF2   0x4638             MOV      R0,R7
   \       0xF4   0x.... 0x....      BL       _ZN10CardReader8setIndexEl
   \       0xF8   0x6B78             LDR      R0,[R7, #+52]
   \       0xFA   0xE026             B.N      ??pause_file_offset_8
   \                     ??pause_file_offset_7: (+1)
   \       0xFC   0x2D5F             CMP      R5,#+95
   \       0xFE   0xDB05             BLT.N    ??pause_file_offset_9
   \      0x100   0xF8D9 0x0044      LDR      R0,[R9, #+68]
   \      0x104   0x1C40             ADDS     R0,R0,#+1
   \      0x106   0xF8C9 0x0044      STR      R0,[R9, #+68]
   \      0x10A   0xE7AE             B.N      ??pause_file_offset_2
   \                     ??pause_file_offset_9: (+1)
   \      0x10C   0x2E3B             CMP      R6,#+59
   \      0x10E   0xD107             BNE.N    ??pause_file_offset_10
   \      0x110   0x2001             MOVS     R0,#+1
   \      0x112   0xF889 0x0012      STRB     R0,[R9, #+18]
   \      0x116   0xF8D9 0x0044      LDR      R0,[R9, #+68]
   \      0x11A   0x1C40             ADDS     R0,R0,#+1
   \      0x11C   0xF8C9 0x0044      STR      R0,[R9, #+68]
   \                     ??pause_file_offset_10: (+1)
   \      0x120   0xF899 0x0012      LDRB     R0,[R9, #+18]
   \      0x124   0x2800             CMP      R0,#+0
   \      0x126   0xD1A0             BNE.N    ??pause_file_offset_2
   \      0x128   0x.... 0x....      LDR.W    R0,??DataTable184
   \      0x12C   0xF899 0x100A      LDRB     R1,[R9, #+10]
   \      0x130   0xFB08 0xF101      MUL      R1,R8,R1
   \      0x134   0x4408             ADD      R0,R0,R1
   \      0x136   0x5546             STRB     R6,[R0, R5]
   \      0x138   0x1C6D             ADDS     R5,R5,#+1
   \      0x13A   0xB2AD             UXTH     R5,R5
   \      0x13C   0xF8D9 0x0044      LDR      R0,[R9, #+68]
   \      0x140   0x1C40             ADDS     R0,R0,#+1
   \      0x142   0xF8C9 0x0044      STR      R0,[R9, #+68]
   \      0x146   0xE790             B.N      ??pause_file_offset_2
   \                     ??pause_file_offset_4: (+1)
   \      0x148   0x2000             MOVS     R0,#+0
   \                     ??pause_file_offset_8: (+1)
   \      0x14A   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return

   \                                 In section .data, align 4
   \                     axis_relative_modes:
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     axis_known_position:
   \        0x4   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     commands_in_queue:
   \        0x8   0x00               DC8 0
   \        0x9   0x00               DC8 0
   \        0xA   0x00               DC8 0
   \                     cmd_queue_index_r_bak:
   \        0xB   0x00               DC8 0
   \        0xC   0x00               DC8 0
   \        0xD   0x00               DC8 0
   \                     serial_wait_tick:
   \        0xE   0x00               DC8 0
   \        0xF   0x00               DC8 0
   \   __absolute uint8_t cmd_id_bak
   \                     cmd_id_bak:
   \       0x10   0x00               DC8 0
   \   __absolute uint8_t cmd_id_bak_temp
   \                     cmd_id_bak_temp:
   \       0x11   0x00               DC8 0
   \       0x12   0x00               DC8 0
   \       0x13   0x00               DC8 0
   \       0x14   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \       0x18   0x0000             DC16 0
   \                     filament_change_menu_response:
   \       0x1A   0x00               DC8 0
   \       0x1B   0x00               DC8 0
   \       0x1C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \       0x20   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \       0x24   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \       0x28   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \       0x2C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \       0x30   0x0000'0000        DC32 0
   \       0x34   0x0000'0000        DC32 0
   \                     previous_cmd_ms:
   \       0x38   0x0000'0000        DC32 0
   \       0x3C   0x0000'0000        DC32 0
   \       0x40   0x0001'D4C0        DC32 120000
   \   __absolute uint32_t volatile cmd_length
   \                     cmd_length:
   \       0x44   0x0000'0000        DC32 0
   \       0x48   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \       0x58   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \       0x68   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \       0x78   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \       0x88   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \       0x98   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .data, align 4
   \                     flow_percentage:
   \        0x0   0x0000'0064        DC32 100

   \                                 In section .data, align 4
   \                     volumetric_enabled:
   \        0x0   0x00               DC8 0
   \        0x1   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   \                     filament_size:
   \        0x4   0x4040'0000        DC32 40400000H
   \                     volumetric_multiplier:
   \        0x8   0x3F80'0000        DC32 3F800000H

   \                                 In section .data, align 1
   \                     soft_endstops_enabled:
   \        0x0   0x01               DC8 1

   \                                 In section .data, align 4
   \                     host_keepalive_interval:
   \        0x0   0x02               DC8 2
   \        0x1   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   \        0x4   0x0000'0000        DC32 0

   \                                 In section .data, align 4
   \                     home_bump_mm_P:
   \        0x0   0x40A0'0000        DC32 40A00000H, 40A00000H, 40A00000H
   \              0x40A0'0000  
   \              0x40A0'0000  

   \                                 In section .data, align 4
   \                     _ZZ27gcode_G29_MESH_BED_LEVELINGvE15mbl_probe_index:
   \        0x0   0xFFFF'FFFF        DC32 -1

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_pausePrint()
   \                     mks_pausePrint: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   \        0x6   0x.... 0x....      LDR.W    R4,??DataTable183_2
   \        0xA   0x....             LDR.N    R0,??DataTable174_3
   \        0xC   0x6881             LDR      R1,[R0, #+8]
   \        0xE   0x64A1             STR      R1,[R4, #+72]
   \       0x10   0x68C1             LDR      R1,[R0, #+12]
   \       0x12   0x64E1             STR      R1,[R4, #+76]
   \       0x14   0x6901             LDR      R1,[R0, #+16]
   \       0x16   0x6521             STR      R1,[R4, #+80]
   \       0x18   0x6941             LDR      R1,[R0, #+20]
   \       0x1A   0x6561             STR      R1,[R4, #+84]
   \       0x1C   0x6981             LDR      R1,[R0, #+24]
   \       0x1E   0x65A1             STR      R1,[R4, #+88]
   \       0x20   0x69C1             LDR      R1,[R0, #+28]
   \       0x22   0x65E1             STR      R1,[R4, #+92]
   \       0x24   0x6A01             LDR      R1,[R0, #+32]
   \       0x26   0x6621             STR      R1,[R4, #+96]
   \       0x28   0x6A41             LDR      R1,[R0, #+36]
   \       0x2A   0x6661             STR      R1,[R4, #+100]
   \       0x2C   0x.... 0x....      LDR.W    R1,??DataTable189_1
   \       0x30   0x6809             LDR      R1,[R1, #+0]
   \       0x32   0xF884 0x107C      STRB     R1,[R4, #+124]
   \       0x36   0x6F40             LDR      R0,[R0, #+116]
   \       0x38   0x67A0             STR      R0,[R4, #+120]
   \       0x3A   0xF04F 0x4040      MOV      R0,#-1073741824
   \       0x3E   0x.... 0x....      BL       mks_preExtrude
   \       0x42   0x6BE0             LDR      R0,[R4, #+60]
   \       0x44   0x.... 0x....      BL       mks_moveZ
   \       0x48   0x6BA1             LDR      R1,[R4, #+56]
   \       0x4A   0x6B60             LDR      R0,[R4, #+52]
   \       0x4C   0x.... 0x....      BL       mks_moveXY
   \       0x50   0x.... 0x....      BL       _Z17pause_file_offsetv
   \       0x54   0x....             LDR.N    R1,??DataTable173_3
   \       0x56   0x6348             STR      R0,[R1, #+52]
   \       0x58   0x.... 0x....      BL       _Z14mks_WriteToEprv
   \       0x5C   0x2100             MOVS     R1,#+0
   \       0x5E   0x.... 0x....      LDR.W    R0,??DataTable192_1
   \       0x62   0xE8BD 0x4010      POP      {R4,LR}
   \       0x66   0x.... 0x....      B.W      _Z13lcd_setstatusPKcb

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void find_pause_e_pos()
   \                     _Z16find_pause_e_posv: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0xB086             SUB      SP,SP,#+24
   \        0x4   0x2400             MOVS     R4,#+0
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \        0xC   0x4620             MOV      R0,R4
   \        0xE   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \       0x12   0x....             LDR.N    R0,??DataTable173
   \       0x14   0x7C40             LDRB     R0,[R0, #+17]
   \       0x16   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \       0x1A   0x....             LDR.N    R5,??DataTable174_3
   \       0x1C   0x.... 0x....      LDR.W    R6,??DataTable192_2
   \                     ??find_pause_e_pos_0: (+1)
   \       0x20   0x2C08             CMP      R4,#+8
   \       0x22   0xDA2B             BGE.N    ??find_pause_e_pos_1
   \       0x24   0x1C64             ADDS     R4,R4,#+1
   \       0x26   0xF99D 0x0001      LDRSB    R0,[SP, #+1]
   \       0x2A   0x2801             CMP      R0,#+1
   \       0x2C   0xD138             BNE.N    ??find_pause_e_pos_2
   \       0x2E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x32   0xEB00 0x0140      ADD      R1,R0,R0, LSL #+1
   \       0x36   0xEB05 0x1041      ADD      R0,R5,R1, LSL #+5
   \       0x3A   0x3088             ADDS     R0,R0,#+136
   \       0x3C   0x2145             MOVS     R1,#+69
   \       0x3E   0x.... 0x....      BL       __iar_Strchr
   \       0x42   0x2100             MOVS     R1,#+0
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xAB01             ADD      R3,SP,#+4
   \       0x48   0xD02A             BEQ.N    ??find_pause_e_pos_2
   \                     ??find_pause_e_pos_3: (+1)
   \       0x4A   0x1842             ADDS     R2,R0,R1
   \       0x4C   0xF992 0x2001      LDRSB    R2,[R2, #+1]
   \       0x50   0x2A20             CMP      R2,#+32
   \       0x52   0xD015             BEQ.N    ??find_pause_e_pos_4
   \       0x54   0x2A3B             CMP      R2,#+59
   \       0x56   0xD013             BEQ.N    ??find_pause_e_pos_4
   \       0x58   0x2A0D             CMP      R2,#+13
   \       0x5A   0xD011             BEQ.N    ??find_pause_e_pos_4
   \       0x5C   0x2A0A             CMP      R2,#+10
   \       0x5E   0xD00F             BEQ.N    ??find_pause_e_pos_4
   \       0x60   0x2914             CMP      R1,#+20
   \       0x62   0xDA0D             BGE.N    ??find_pause_e_pos_4
   \       0x64   0x545A             STRB     R2,[R3, R1]
   \       0x66   0x1C49             ADDS     R1,R1,#+1
   \       0x68   0xE7EF             B.N      ??find_pause_e_pos_3
   \                     ??find_pause_e_pos_5: (+1)
   \       0x6A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x6E   0x1E40             SUBS     R0,R0,#+1
   \       0x70   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \                     ??find_pause_e_pos_6: (+1)
   \       0x74   0xF99D 0x0001      LDRSB    R0,[SP, #+1]
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD1D1             BNE.N    ??find_pause_e_pos_0
   \                     ??find_pause_e_pos_1: (+1)
   \       0x7C   0xB006             ADD      SP,SP,#+24
   \       0x7E   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??find_pause_e_pos_4: (+1)
   \       0x80   0xA801             ADD      R0,SP,#+4
   \       0x82   0x.... 0x....      BL       atof
   \       0x86   0x2200             MOVS     R2,#+0
   \       0x88   0xF04F 0x4340      MOV      R3,#-1073741824
   \       0x8C   0x.... 0x....      BL       __aeabi_dadd
   \       0x90   0x.... 0x....      BL       __aeabi_d2f
   \       0x94   0x6570             STR      R0,[R6, #+84]
   \       0x96   0x6168             STR      R0,[R5, #+20]
   \       0x98   0x6268             STR      R0,[R5, #+36]
   \       0x9A   0x2000             MOVS     R0,#+0
   \       0x9C   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \                     ??find_pause_e_pos_2: (+1)
   \       0xA0   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0xA4   0x2800             CMP      R0,#+0
   \       0xA6   0xD1E0             BNE.N    ??find_pause_e_pos_5
   \       0xA8   0x2007             MOVS     R0,#+7
   \       0xAA   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \       0xAE   0xE7E1             B.N      ??find_pause_e_pos_6

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void quick_pause()
   \                     _Z11quick_pausev: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x....             LDR.N    R5,??DataTable173
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x8128             STRH     R0,[R5, #+8]
   \        0x8   0x72A8             STRB     R0,[R5, #+10]
   \        0xA   0x.... 0x....      LDR.W    R4,??DataTable192_4
   \        0xE   0x4620             MOV      R0,R4
   \       0x10   0x.... 0x....      BL       HAL_TIM_Base_Stop_IT
   \       0x14   0x7C28             LDRB     R0,[R5, #+16]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD102             BNE.N    ??quick_pause_0
   \       0x1A   0x2007             MOVS     R0,#+7
   \       0x1C   0x7468             STRB     R0,[R5, #+17]
   \       0x1E   0xE004             B.N      ??quick_pause_1
   \                     ??quick_pause_0: (+1)
   \       0x20   0x1E40             SUBS     R0,R0,#+1
   \       0x22   0x7468             STRB     R0,[R5, #+17]
   \       0x24   0xE001             B.N      ??quick_pause_1
   \                     ??quick_pause_2: (+1)
   \       0x26   0x.... 0x....      BL       _ZN7Planner21discard_current_blockEv
   \                     ??quick_pause_1: (+1)
   \       0x2A   0x.... 0x....      BL       _ZN7Planner13blocks_queuedEv
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD1F9             BNE.N    ??quick_pause_2
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0x.... 0x....      LDR.W    R1,??DataTable192_6
   \       0x38   0x6008             STR      R0,[R1, #+0]
   \       0x3A   0x.... 0x....      BL       _Z16find_pause_e_posv
   \       0x3E   0x2064             MOVS     R0,#+100
   \       0x40   0x.... 0x....      BL       _Z34set_current_from_steppers_for_axis8AxisEnum
   \       0x44   0x.... 0x....      BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
   \       0x48   0x....             LDR.N    R0,??DataTable174_3
   \       0x4A   0x6881             LDR      R1,[R0, #+8]
   \       0x4C   0x6181             STR      R1,[R0, #+24]
   \       0x4E   0x68C1             LDR      R1,[R0, #+12]
   \       0x50   0x61C1             STR      R1,[R0, #+28]
   \       0x52   0x6901             LDR      R1,[R0, #+16]
   \       0x54   0x6201             STR      R1,[R0, #+32]
   \       0x56   0x4620             MOV      R0,R4
   \       0x58   0x.... 0x....      BL       HAL_TIM_Base_Start_IT
   \       0x5C   0x.... 0x....      LDR.W    R0,??DataTable192_2
   \       0x60   0x21A9             MOVS     R1,#+169
   \       0x62   0xF880 0x1068      STRB     R1,[R0, #+104]
   \       0x66   0x2201             MOVS     R2,#+1
   \       0x68   0xF100 0x0168      ADD      R1,R0,#+104
   \       0x6C   0xF44F 0x60AF      MOV      R0,#+1400
   \       0x70   0x.... 0x....      BL       epr_write_data
   \       0x74   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \       0x78   0x....             B.N      mks_pausePrint

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_PrintStatePolling()
   \                     mks_PrintStatePolling: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x.... 0x....      LDR.W    R4,??DataTable183_2
   \        0x8   0xF104 0x0568      ADD      R5,R4,#+104
   \        0xC   0x7828             LDRB     R0,[R5, #+0]
   \        0xE   0x28A8             CMP      R0,#+168
   \       0x10   0xD101             BNE.N    ??mks_PrintStatePolling_0
   \       0x12   0x.... 0x....      BL       _Z11quick_pausev
   \                     ??mks_PrintStatePolling_0: (+1)
   \       0x16   0x7828             LDRB     R0,[R5, #+0]
   \       0x18   0x28A9             CMP      R0,#+169
   \       0x1A   0xD13B             BNE.N    ??mks_PrintStatePolling_1
   \       0x1C   0x....             LDR.N    R6,??DataTable174_3
   \       0x1E   0x68B7             LDR      R7,[R6, #+8]
   \       0x20   0x.... 0x....      LDR.W    R8,??DataTable192_7  ;; 0x38d1b718
   \       0x24   0x6CA0             LDR      R0,[R4, #+72]
   \       0x26   0x4639             MOV      R1,R7
   \       0x28   0x.... 0x....      BL       __aeabi_fsub
   \       0x2C   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \       0x30   0x4641             MOV      R1,R8
   \       0x32   0x.... 0x....      BL       __aeabi_cfrcmple
   \       0x36   0xD807             BHI.N    ??mks_PrintStatePolling_2
   \       0x38   0x64A7             STR      R7,[R4, #+72]
   \       0x3A   0x2204             MOVS     R2,#+4
   \       0x3C   0xF104 0x0148      ADD      R1,R4,#+72
   \       0x40   0xF240 0x5081      MOVW     R0,#+1409
   \       0x44   0x.... 0x....      BL       epr_write_data
   \                     ??mks_PrintStatePolling_2: (+1)
   \       0x48   0x68F7             LDR      R7,[R6, #+12]
   \       0x4A   0x6CE0             LDR      R0,[R4, #+76]
   \       0x4C   0x4639             MOV      R1,R7
   \       0x4E   0x.... 0x....      BL       __aeabi_fsub
   \       0x52   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \       0x56   0x4641             MOV      R1,R8
   \       0x58   0x.... 0x....      BL       __aeabi_cfrcmple
   \       0x5C   0xD807             BHI.N    ??mks_PrintStatePolling_3
   \       0x5E   0x64E7             STR      R7,[R4, #+76]
   \       0x60   0x2204             MOVS     R2,#+4
   \       0x62   0xF104 0x014C      ADD      R1,R4,#+76
   \       0x66   0xF240 0x5085      MOVW     R0,#+1413
   \       0x6A   0x.... 0x....      BL       epr_write_data
   \                     ??mks_PrintStatePolling_3: (+1)
   \       0x6E   0x6936             LDR      R6,[R6, #+16]
   \       0x70   0x6D20             LDR      R0,[R4, #+80]
   \       0x72   0x4631             MOV      R1,R6
   \       0x74   0x.... 0x....      BL       __aeabi_fsub
   \       0x78   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \       0x7C   0x4641             MOV      R1,R8
   \       0x7E   0x.... 0x....      BL       __aeabi_cfrcmple
   \       0x82   0xD807             BHI.N    ??mks_PrintStatePolling_1
   \       0x84   0x6526             STR      R6,[R4, #+80]
   \       0x86   0x2204             MOVS     R2,#+4
   \       0x88   0xF104 0x0150      ADD      R1,R4,#+80
   \       0x8C   0xF240 0x5089      MOVW     R0,#+1417
   \       0x90   0x.... 0x....      BL       epr_write_data
   \                     ??mks_PrintStatePolling_1: (+1)
   \       0x94   0x7828             LDRB     R0,[R5, #+0]
   \       0x96   0x28A7             CMP      R0,#+167
   \       0x98   0xD119             BNE.N    ??mks_PrintStatePolling_4
   \       0x9A   0x.... 0x....      LDR.W    R0,??DataTable192_8
   \       0x9E   0x7880             LDRB     R0,[R0, #+2]
   \       0xA0   0x2800             CMP      R0,#+0
   \       0xA2   0xD103             BNE.N    ??mks_PrintStatePolling_5
   \       0xA4   0x8D28             LDRH     R0,[R5, #+40]
   \       0xA6   0x1C40             ADDS     R0,R0,#+1
   \       0xA8   0x8528             STRH     R0,[R5, #+40]
   \       0xAA   0xE001             B.N      ??mks_PrintStatePolling_6
   \                     ??mks_PrintStatePolling_5: (+1)
   \       0xAC   0x2000             MOVS     R0,#+0
   \       0xAE   0x8528             STRH     R0,[R5, #+40]
   \                     ??mks_PrintStatePolling_6: (+1)
   \       0xB0   0x8D28             LDRH     R0,[R5, #+40]
   \       0xB2   0x2815             CMP      R0,#+21
   \       0xB4   0xDB0B             BLT.N    ??mks_PrintStatePolling_4
   \       0xB6   0x2000             MOVS     R0,#+0
   \       0xB8   0x8528             STRH     R0,[R5, #+40]
   \       0xBA   0x20A6             MOVS     R0,#+166
   \       0xBC   0x7028             STRB     R0,[R5, #+0]
   \       0xBE   0x2201             MOVS     R2,#+1
   \       0xC0   0x4629             MOV      R1,R5
   \       0xC2   0xF44F 0x60AF      MOV      R0,#+1400
   \       0xC6   0x.... 0x....      BL       epr_write_data
   \       0xCA   0x.... 0x....      BL       mks_clearFile
   \                     ??mks_PrintStatePolling_4: (+1)
   \       0xCE   0x7828             LDRB     R0,[R5, #+0]
   \       0xD0   0x28AB             CMP      R0,#+171
   \       0xD2   0xD11A             BNE.N    ??mks_PrintStatePolling_7
   \       0xD4   0x.... 0x....      LDR.W    R0,??DataTable192_9
   \       0xD8   0xF9B0 0x0058      LDRSH    R0,[R0, #+88]
   \       0xDC   0x2801             CMP      R0,#+1
   \       0xDE   0xD005             BEQ.N    ??mks_PrintStatePolling_8
   \       0xE0   0x2802             CMP      R0,#+2
   \       0xE2   0xD00F             BEQ.N    ??mks_PrintStatePolling_9
   \       0xE4   0x2804             CMP      R0,#+4
   \       0xE6   0xD001             BEQ.N    ??mks_PrintStatePolling_8
   \       0xE8   0x2808             CMP      R0,#+8
   \       0xEA   0xD10E             BNE.N    ??mks_PrintStatePolling_7
   \                     ??mks_PrintStatePolling_8: (+1)
   \       0xEC   0xF994 0x0414      LDRSB    R0,[R4, #+1044]
   \       0xF0   0x2801             CMP      R0,#+1
   \       0xF2   0xD102             BNE.N    ??mks_PrintStatePolling_10
   \       0xF4   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \       0xF8   0x....             B.N      mks_contiuePrintPause
   \                     ??mks_PrintStatePolling_10: (+1)
   \       0xFA   0x2802             CMP      R0,#+2
   \       0xFC   0xD105             BNE.N    ??mks_PrintStatePolling_7
   \       0xFE   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \      0x102   0x....             B.N      mks_contiuePrintPwdwn
   \                     ??mks_PrintStatePolling_9: (+1)
   \      0x104   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \      0x108   0x....             B.N      mks_contiuePrintDelta
   \                     ??mks_PrintStatePolling_7: (+1)
   \      0x10A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_setTemperature()
   \                     _Z18mks_setTemperaturev: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x.... 0x....      LDR.W    R4,??DataTable183_2
   \        0x8   0xF104 0x0572      ADD      R5,R4,#+114
   \        0xC   0x.... 0x....      LDR.W    R6,??DataTable192_9
   \       0x10   0xF896 0x0036      LDRB     R0,[R6, #+54]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD01F             BEQ.N    ??mks_setTemperature_0
   \       0x18   0x8868             LDRH     R0,[R5, #+2]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD01C             BEQ.N    ??mks_setTemperature_0
   \       0x1E   0xF104 0x0792      ADD      R7,R4,#+146
   \       0x22   0x2200             MOVS     R2,#+0
   \       0x24   0x2160             MOVS     R1,#+96
   \       0x26   0x4638             MOV      R0,R7
   \       0x28   0x.... 0x....      BL       __aeabi_memset
   \       0x2C   0x2207             MOVS     R2,#+7
   \       0x2E   0x.... 0x....      ADR.W    R1,?_59
   \       0x32   0x4638             MOV      R0,R7
   \       0x34   0x.... 0x....      BL       __aeabi_memcpy
   \       0x38   0x886A             LDRH     R2,[R5, #+2]
   \       0x3A   0x....             ADR.N    R1,??DataTable180  ;; 0x25, 0x64, 0x00, 0x00
   \       0x3C   0x4668             MOV      R0,SP
   \       0x3E   0x.... 0x....      BL       sprintf
   \       0x42   0x4669             MOV      R1,SP
   \       0x44   0x4638             MOV      R0,R7
   \       0x46   0x.... 0x....      BL       strcat
   \       0x4A   0xF104 0x0097      ADD      R0,R4,#+151
   \       0x4E   0x.... 0x....      LDR.W    R1,??DataTable192_10
   \       0x52   0x6288             STR      R0,[R1, #+40]
   \       0x54   0x.... 0x....      BL       _Z10gcode_M140v
   \                     ??mks_setTemperature_0: (+1)
   \       0x58   0x8828             LDRH     R0,[R5, #+0]
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD01C             BEQ.N    ??mks_setTemperature_1
   \       0x5E   0xF104 0x0792      ADD      R7,R4,#+146
   \       0x62   0x2200             MOVS     R2,#+0
   \       0x64   0x2160             MOVS     R1,#+96
   \       0x66   0x4638             MOV      R0,R7
   \       0x68   0x.... 0x....      BL       __aeabi_memset
   \       0x6C   0x2207             MOVS     R2,#+7
   \       0x6E   0x.... 0x....      ADR.W    R1,?_61
   \       0x72   0x4638             MOV      R0,R7
   \       0x74   0x.... 0x....      BL       __aeabi_memcpy
   \       0x78   0x882A             LDRH     R2,[R5, #+0]
   \       0x7A   0x....             ADR.N    R1,??DataTable180  ;; 0x25, 0x64, 0x00, 0x00
   \       0x7C   0x4668             MOV      R0,SP
   \       0x7E   0x.... 0x....      BL       sprintf
   \       0x82   0x4669             MOV      R1,SP
   \       0x84   0x4638             MOV      R0,R7
   \       0x86   0x.... 0x....      BL       strcat
   \       0x8A   0xF104 0x0097      ADD      R0,R4,#+151
   \       0x8E   0x.... 0x....      LDR.W    R1,??DataTable192_10
   \       0x92   0x6288             STR      R0,[R1, #+40]
   \       0x94   0x.... 0x....      BL       _Z10gcode_M109v
   \                     ??mks_setTemperature_1: (+1)
   \       0x98   0xF896 0x0036      LDRB     R0,[R6, #+54]
   \       0x9C   0x2800             CMP      R0,#+0
   \       0x9E   0xD01F             BEQ.N    ??mks_setTemperature_2
   \       0xA0   0x8868             LDRH     R0,[R5, #+2]
   \       0xA2   0x2800             CMP      R0,#+0
   \       0xA4   0xD01C             BEQ.N    ??mks_setTemperature_2
   \       0xA6   0xF104 0x0692      ADD      R6,R4,#+146
   \       0xAA   0x2200             MOVS     R2,#+0
   \       0xAC   0x2160             MOVS     R1,#+96
   \       0xAE   0x4630             MOV      R0,R6
   \       0xB0   0x.... 0x....      BL       __aeabi_memset
   \       0xB4   0x2207             MOVS     R2,#+7
   \       0xB6   0x.... 0x....      ADR.W    R1,?_62
   \       0xBA   0x4630             MOV      R0,R6
   \       0xBC   0x.... 0x....      BL       __aeabi_memcpy
   \       0xC0   0x886A             LDRH     R2,[R5, #+2]
   \       0xC2   0x....             ADR.N    R1,??DataTable180  ;; 0x25, 0x64, 0x00, 0x00
   \       0xC4   0x4668             MOV      R0,SP
   \       0xC6   0x.... 0x....      BL       sprintf
   \       0xCA   0x4669             MOV      R1,SP
   \       0xCC   0x4630             MOV      R0,R6
   \       0xCE   0x.... 0x....      BL       strcat
   \       0xD2   0xF104 0x0097      ADD      R0,R4,#+151
   \       0xD6   0x.... 0x....      LDR.W    R1,??DataTable192_10
   \       0xDA   0x6288             STR      R0,[R1, #+40]
   \       0xDC   0x.... 0x....      BL       _Z10gcode_M190v
   \                     ??mks_setTemperature_2: (+1)
   \       0xE0   0xB005             ADD      SP,SP,#+20
   \       0xE2   0xBDF0             POP      {R4-R7,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_setPositionZ()
   \                     mks_setPositionZ: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x....             LDR.N    R4,??DataTable183_2
   \        0x6   0xF104 0x0592      ADD      R5,R4,#+146
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x2160             MOVS     R1,#+96
   \        0xE   0x4628             MOV      R0,R5
   \       0x10   0x.... 0x....      BL       __aeabi_memset
   \       0x14   0x2206             MOVS     R2,#+6
   \       0x16   0x.... 0x....      ADR.W    R1,?_63
   \       0x1A   0x4628             MOV      R0,R5
   \       0x1C   0x.... 0x....      BL       __aeabi_memcpy
   \       0x20   0x2200             MOVS     R2,#+0
   \       0x22   0x2114             MOVS     R1,#+20
   \       0x24   0x4668             MOV      R0,SP
   \       0x26   0x.... 0x....      BL       __aeabi_memset4
   \       0x2A   0x6D20             LDR      R0,[R4, #+80]
   \       0x2C   0x.... 0x....      BL       __aeabi_f2d
   \       0x30   0x4602             MOV      R2,R0
   \       0x32   0x460B             MOV      R3,R1
   \       0x34   0x....             ADR.N    R1,??DataTable182  ;; 0x25, 0x66, 0x00, 0x00
   \       0x36   0x4668             MOV      R0,SP
   \       0x38   0x.... 0x....      BL       sprintf
   \       0x3C   0x4669             MOV      R1,SP
   \       0x3E   0x4628             MOV      R0,R5
   \       0x40   0x.... 0x....      BL       strcat
   \       0x44   0xF104 0x0096      ADD      R0,R4,#+150
   \       0x48   0x.... 0x....      LDR.W    R1,??DataTable192_10
   \       0x4C   0x6288             STR      R0,[R1, #+40]
   \       0x4E   0x.... 0x....      BL       _Z9gcode_G92v
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0x.... 0x....      LDR.W    R1,??DataTable192_11
   \       0x58   0x6588             STR      R0,[R1, #+88]
   \       0x5A   0xB005             ADD      SP,SP,#+20
   \       0x5C   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_setFeedrate()
   \                     _Z15mks_setFeedratev: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable183_2
   \        0x2   0x6F80             LDR      R0,[R0, #+120]
   \        0x4   0x.... 0x....      LDR.W    R1,??DataTable192_11
   \        0x8   0x6748             STR      R0,[R1, #+116]
   \        0xA   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_preExtrude(float)
   \                     mks_preExtrude: (+1)
   \        0x0   0xE92D 0x41F8      PUSH     {R3-R8,LR}
   \        0x4   0xB085             SUB      SP,SP,#+20
   \        0x6   0x4680             MOV      R8,R0
   \        0x8   0x.... 0x....      LDR.W    R4,??DataTable192_10
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0x7320             STRB     R0,[R4, #+12]
   \       0x10   0x....             LDR.N    R5,??DataTable183_2
   \       0x12   0xF105 0x0692      ADD      R6,R5,#+146
   \       0x16   0x2200             MOVS     R2,#+0
   \       0x18   0x2160             MOVS     R1,#+96
   \       0x1A   0x4630             MOV      R0,R6
   \       0x1C   0x.... 0x....      BL       __aeabi_memset
   \       0x20   0x2205             MOVS     R2,#+5
   \       0x22   0x.... 0x....      ADR.W    R1,?_65
   \       0x26   0x4630             MOV      R0,R6
   \       0x28   0x.... 0x....      BL       __aeabi_memcpy
   \       0x2C   0x2200             MOVS     R2,#+0
   \       0x2E   0x2114             MOVS     R1,#+20
   \       0x30   0x4668             MOV      R0,SP
   \       0x32   0x.... 0x....      BL       __aeabi_memset4
   \       0x36   0x....             ADR.N    R7,??DataTable182  ;; 0x25, 0x66, 0x00, 0x00
   \       0x38   0x4640             MOV      R0,R8
   \       0x3A   0x.... 0x....      BL       __aeabi_f2d
   \       0x3E   0x4602             MOV      R2,R0
   \       0x40   0x460B             MOV      R3,R1
   \       0x42   0x4639             MOV      R1,R7
   \       0x44   0x4668             MOV      R0,SP
   \       0x46   0x.... 0x....      BL       sprintf
   \       0x4A   0x4669             MOV      R1,SP
   \       0x4C   0x4630             MOV      R0,R6
   \       0x4E   0x.... 0x....      BL       strcat
   \       0x52   0xF105 0x0095      ADD      R0,R5,#+149
   \       0x56   0x62A0             STR      R0,[R4, #+40]
   \       0x58   0x.... 0x....      BL       _Z11gcode_G0_G1v
   \       0x5C   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   \       0x60   0x2000             MOVS     R0,#+0
   \       0x62   0x7320             STRB     R0,[R4, #+12]
   \       0x64   0x4602             MOV      R2,R0
   \       0x66   0x2160             MOVS     R1,#+96
   \       0x68   0x4630             MOV      R0,R6
   \       0x6A   0x.... 0x....      BL       __aeabi_memset
   \       0x6E   0x2206             MOVS     R2,#+6
   \       0x70   0x.... 0x....      ADR.W    R1,?_66
   \       0x74   0x4630             MOV      R0,R6
   \       0x76   0x.... 0x....      BL       __aeabi_memcpy
   \       0x7A   0x2200             MOVS     R2,#+0
   \       0x7C   0x2114             MOVS     R1,#+20
   \       0x7E   0x4668             MOV      R0,SP
   \       0x80   0x.... 0x....      BL       __aeabi_memset4
   \       0x84   0x6E68             LDR      R0,[R5, #+100]
   \       0x86   0x.... 0x....      BL       __aeabi_f2d
   \       0x8A   0x4602             MOV      R2,R0
   \       0x8C   0x460B             MOV      R3,R1
   \       0x8E   0x4639             MOV      R1,R7
   \       0x90   0x4668             MOV      R0,SP
   \       0x92   0x.... 0x....      BL       sprintf
   \       0x96   0x4669             MOV      R1,SP
   \       0x98   0x4630             MOV      R0,R6
   \       0x9A   0x.... 0x....      BL       strcat
   \       0x9E   0xF105 0x0096      ADD      R0,R5,#+150
   \       0xA2   0x62A0             STR      R0,[R4, #+40]
   \       0xA4   0x.... 0x....      BL       _Z9gcode_G92v
   \       0xA8   0xB006             ADD      SP,SP,#+24
   \       0xAA   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_moveXY(float, float)
   \                     mks_moveXY: (+1)
   \        0x0   0xE92D 0x41F8      PUSH     {R3-R8,LR}
   \        0x4   0xB085             SUB      SP,SP,#+20
   \        0x6   0x4680             MOV      R8,R0
   \        0x8   0x460C             MOV      R4,R1
   \        0xA   0x....             LDR.N    R5,??DataTable183_2
   \        0xC   0xF105 0x0692      ADD      R6,R5,#+146
   \       0x10   0x2200             MOVS     R2,#+0
   \       0x12   0x2160             MOVS     R1,#+96
   \       0x14   0x4630             MOV      R0,R6
   \       0x16   0x.... 0x....      BL       __aeabi_memset
   \       0x1A   0x2205             MOVS     R2,#+5
   \       0x1C   0x.... 0x....      ADR.W    R1,?_67
   \       0x20   0x4630             MOV      R0,R6
   \       0x22   0x.... 0x....      BL       __aeabi_memcpy
   \       0x26   0x2200             MOVS     R2,#+0
   \       0x28   0x2114             MOVS     R1,#+20
   \       0x2A   0x4668             MOV      R0,SP
   \       0x2C   0x.... 0x....      BL       __aeabi_memset4
   \       0x30   0x....             ADR.N    R7,??DataTable182  ;; 0x25, 0x66, 0x00, 0x00
   \       0x32   0x4640             MOV      R0,R8
   \       0x34   0x.... 0x....      BL       __aeabi_f2d
   \       0x38   0x4602             MOV      R2,R0
   \       0x3A   0x460B             MOV      R3,R1
   \       0x3C   0x4639             MOV      R1,R7
   \       0x3E   0x4668             MOV      R0,SP
   \       0x40   0x.... 0x....      BL       sprintf
   \       0x44   0x4669             MOV      R1,SP
   \       0x46   0x4630             MOV      R0,R6
   \       0x48   0x.... 0x....      BL       strcat
   \       0x4C   0x....             ADR.N    R1,??DataTable184_1  ;; 0x20, 0x59, 0x00, 0x00
   \       0x4E   0x4630             MOV      R0,R6
   \       0x50   0x.... 0x....      BL       strcat
   \       0x54   0x2200             MOVS     R2,#+0
   \       0x56   0x2114             MOVS     R1,#+20
   \       0x58   0x4668             MOV      R0,SP
   \       0x5A   0x.... 0x....      BL       __aeabi_memset4
   \       0x5E   0x4620             MOV      R0,R4
   \       0x60   0x.... 0x....      BL       __aeabi_f2d
   \       0x64   0x4602             MOV      R2,R0
   \       0x66   0x460B             MOV      R3,R1
   \       0x68   0x4639             MOV      R1,R7
   \       0x6A   0x4668             MOV      R0,SP
   \       0x6C   0x.... 0x....      BL       sprintf
   \       0x70   0x4669             MOV      R1,SP
   \       0x72   0x4630             MOV      R0,R6
   \       0x74   0x.... 0x....      BL       strcat
   \       0x78   0xF105 0x0095      ADD      R0,R5,#+149
   \       0x7C   0x.... 0x....      LDR.W    R1,??DataTable192_10
   \       0x80   0x6288             STR      R0,[R1, #+40]
   \       0x82   0x.... 0x....      BL       _Z11gcode_G0_G1v
   \       0x86   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   \       0x8A   0xB006             ADD      SP,SP,#+24
   \       0x8C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_moveZ(float)
   \                     mks_moveZ: (+1)
   \        0x0   0xB578             PUSH     {R3-R6,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x....             LDR.N    R5,??DataTable183_2
   \        0x8   0xF105 0x0692      ADD      R6,R5,#+146
   \        0xC   0x2200             MOVS     R2,#+0
   \        0xE   0x2160             MOVS     R1,#+96
   \       0x10   0x4630             MOV      R0,R6
   \       0x12   0x.... 0x....      BL       __aeabi_memset
   \       0x16   0x2205             MOVS     R2,#+5
   \       0x18   0x.... 0x....      ADR.W    R1,?_69
   \       0x1C   0x4630             MOV      R0,R6
   \       0x1E   0x.... 0x....      BL       __aeabi_memcpy
   \       0x22   0x2200             MOVS     R2,#+0
   \       0x24   0x2114             MOVS     R1,#+20
   \       0x26   0x4668             MOV      R0,SP
   \       0x28   0x.... 0x....      BL       __aeabi_memset4
   \       0x2C   0x6E29             LDR      R1,[R5, #+96]
   \       0x2E   0x4620             MOV      R0,R4
   \       0x30   0x.... 0x....      BL       __aeabi_fadd
   \       0x34   0x.... 0x....      BL       __aeabi_f2d
   \       0x38   0x4602             MOV      R2,R0
   \       0x3A   0x460B             MOV      R3,R1
   \       0x3C   0x....             ADR.N    R1,??DataTable182  ;; 0x25, 0x66, 0x00, 0x00
   \       0x3E   0x4668             MOV      R0,SP
   \       0x40   0x.... 0x....      BL       sprintf
   \       0x44   0x4669             MOV      R1,SP
   \       0x46   0x4630             MOV      R0,R6
   \       0x48   0x.... 0x....      BL       strcat
   \       0x4C   0xF105 0x0095      ADD      R0,R5,#+149
   \       0x50   0x.... 0x....      LDR.W    R1,??DataTable192_10
   \       0x54   0x6288             STR      R0,[R1, #+40]
   \       0x56   0x.... 0x....      BL       _Z11gcode_G0_G1v
   \       0x5A   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   \       0x5E   0xB006             ADD      SP,SP,#+24
   \       0x60   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_G28(char *)
   \                     _Z7mks_G28Pc: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x....             LDR.N    R5,??DataTable183_2
   \        0x6   0xF105 0x0692      ADD      R6,R5,#+146
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x2160             MOVS     R1,#+96
   \        0xE   0x4630             MOV      R0,R6
   \       0x10   0x.... 0x....      BL       __aeabi_memset
   \       0x14   0x4621             MOV      R1,R4
   \       0x16   0x4630             MOV      R0,R6
   \       0x18   0x.... 0x....      BL       strcpy
   \       0x1C   0xF105 0x0096      ADD      R0,R5,#+150
   \       0x20   0x.... 0x....      LDR.W    R1,??DataTable192_10
   \       0x24   0x6288             STR      R0,[R1, #+40]
   \       0x26   0x.... 0x....      BL       _Z9gcode_G28v
   \       0x2A   0x.... 0x....      LDR.W    R4,??DataTable192_12
   \       0x2E   0x7820             LDRB     R0,[R4, #+0]
   \       0x30   0xF010 0x0F3E      TST      R0,#0x3E
   \       0x34   0xD016             BEQ.N    ??mks_G28_0
   \       0x36   0x2810             CMP      R0,#+16
   \       0x38   0xD014             BEQ.N    ??mks_G28_0
   \       0x3A   0x2001             MOVS     R0,#+1
   \       0x3C   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   \       0x40   0xF9B4 0x0018      LDRSH    R0,[R4, #+24]
   \       0x44   0x2802             CMP      R0,#+2
   \       0x46   0xD00D             BEQ.N    ??mks_G28_0
   \       0x48   0x7820             LDRB     R0,[R4, #+0]
   \       0x4A   0x06C0             LSLS     R0,R0,#+27
   \       0x4C   0xD50A             BPL.N    ??mks_G28_0
   \       0x4E   0x205A             MOVS     R0,#+90
   \       0x50   0x.... 0x....      BL       _Z9code_seenc
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD005             BEQ.N    ??mks_G28_0
   \       0x58   0x.... 0x....      BL       _Z16code_value_floatv
   \       0x5C   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x60   0x.... 0x....      B.W      _Z17set_z_fade_heightf
   \                     ??mks_G28_0: (+1)
   \       0x64   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_contiuePrintPause()
   \                     mks_contiuePrintPause: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x2001             MOVS     R0,#+1
   \        0x4   0x.... 0x....      LDR.W    R1,??DataTable192_8
   \        0x8   0x7088             STRB     R0,[R1, #+2]
   \        0xA   0x.... 0x....      BL       _Z18mks_setTemperaturev

  	mks_G28("G28 X0 Y0");
  	        ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Src\mks_reprint.cpp",642  Warning[Pe2464]: 
          conversion from a string literal to "char *" is deprecated

  	char string[20];
  	     ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Src\mks_reprint.cpp",635  Warning[Pe177]: 
          variable "string" was declared but never referenced
   \        0xE   0x.... 0x....      ADR.W    R0,?_70
   \       0x12   0x.... 0x....      BL       _Z7mks_G28Pc
   \       0x16   0x....             LDR.N    R4,??DataTable183_2
   \       0x18   0x6C20             LDR      R0,[R4, #+64]
   \       0x1A   0x.... 0x....      BL       mks_preExtrude
   \       0x1E   0x6DE1             LDR      R1,[R4, #+92]
   \       0x20   0x6DA0             LDR      R0,[R4, #+88]
   \       0x22   0x.... 0x....      BL       mks_moveXY
   \       0x26   0x.... 0x....      BL       mks_setPositionZ
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x.... 0x....      BL       mks_moveZ
   \       0x30   0x.... 0x....      BL       _Z15mks_setFeedratev
   \       0x34   0xF894 0x107C      LDRB     R1,[R4, #+124]
   \       0x38   0x.... 0x....      LDR.W    R0,??DataTable189_1
   \       0x3C   0x6001             STR      R1,[R0, #+0]
   \       0x3E   0xF242 0x7010      MOVW     R0,#+10000
   \       0x42   0x4341             MULS     R1,R0,R1
   \       0x44   0x20FF             MOVS     R0,#+255
   \       0x46   0xFB91 0xF0F0      SDIV     R0,R1,R0
   \       0x4A   0x.... 0x....      LDR.W    R1,??DataTable192_13  ;; 0x40012c34
   \       0x4E   0x6008             STR      R0,[R1, #+0]
   \       0x50   0x2100             MOVS     R1,#+0
   \       0x52   0xF104 0x0014      ADD      R0,R4,#+20
   \       0x56   0x.... 0x....      BL       _Z13lcd_setstatusPKcb
   \       0x5A   0xE8BD 0x4010      POP      {R4,LR}
   \       0x5E   0x.... 0x....      B.W      _Z9gcode_M24v

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_contiuePrintPwdwn()
   \                     mks_contiuePrintPwdwn: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x2001             MOVS     R0,#+1
   \        0x4   0x.... 0x....      LDR.W    R1,??DataTable192_8
   \        0x8   0x7088             STRB     R0,[R1, #+2]
   \        0xA   0x.... 0x....      BL       _Z18mks_setTemperaturev
   \        0xE   0x.... 0x....      BL       mks_setPositionZ
   \       0x12   0xF04F 0x4040      MOV      R0,#-1073741824
   \       0x16   0x.... 0x....      BL       mks_preExtrude
   \       0x1A   0x....             LDR.N    R5,??DataTable183_2
   \       0x1C   0x6BE8             LDR      R0,[R5, #+60]
   \       0x1E   0x.... 0x....      BL       mks_moveZ

  	mks_G28("G28 X0 Y0");
  	        ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Src\mks_reprint.cpp",691  Warning[Pe2464]: 
          conversion from a string literal to "char *" is deprecated

  	char string[20];
  	     ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Src\mks_reprint.cpp",677  Warning[Pe177]: 
          variable "string" was declared but never referenced
   \       0x22   0x.... 0x....      ADR.W    R0,?_70
   \       0x26   0x.... 0x....      BL       _Z7mks_G28Pc
   \       0x2A   0xF640 0x30B8      MOVW     R0,#+3000
   \       0x2E   0x.... 0x....      BL       HAL_Delay
   \       0x32   0x6C28             LDR      R0,[R5, #+64]
   \       0x34   0x.... 0x....      BL       mks_preExtrude
   \       0x38   0x6DE9             LDR      R1,[R5, #+92]
   \       0x3A   0x6DA8             LDR      R0,[R5, #+88]
   \       0x3C   0x.... 0x....      BL       mks_moveXY
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0x.... 0x....      BL       mks_moveZ
   \       0x46   0x.... 0x....      BL       _Z15mks_setFeedratev
   \       0x4A   0xF105 0x0470      ADD      R4,R5,#+112
   \       0x4E   0x7B21             LDRB     R1,[R4, #+12]
   \       0x50   0x.... 0x....      LDR.W    R0,??DataTable189_1
   \       0x54   0x6001             STR      R1,[R0, #+0]
   \       0x56   0xF242 0x7010      MOVW     R0,#+10000
   \       0x5A   0x4341             MULS     R1,R0,R1
   \       0x5C   0x20FF             MOVS     R0,#+255
   \       0x5E   0xFB91 0xF0F0      SDIV     R0,R1,R0
   \       0x62   0x.... 0x....      LDR.W    R1,??DataTable192_13  ;; 0x40012c34
   \       0x66   0x6008             STR      R0,[R1, #+0]
   \       0x68   0x2100             MOVS     R1,#+0
   \       0x6A   0xF105 0x0014      ADD      R0,R5,#+20
   \       0x6E   0x.... 0x....      BL       _Z13lcd_setstatusPKcb
   \       0x72   0x.... 0x....      BL       _Z9gcode_M24v
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0x7020             STRB     R0,[R4, #+0]
   \       0x7A   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_contiuePrintDelta()
   \                     mks_contiuePrintDelta: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x2001             MOVS     R0,#+1
   \        0x4   0x.... 0x....      LDR.W    R1,??DataTable192_8
   \        0x8   0x7088             STRB     R0,[R1, #+2]
   \        0xA   0x.... 0x....      BL       _Z18mks_setTemperaturev

  	mks_G28("G28");
  	        ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Src\mks_reprint.cpp",732  Warning[Pe2464]: 
          conversion from a string literal to "char *" is deprecated

  	char string[20];
  	     ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Src\mks_reprint.cpp",724  Warning[Pe177]: 
          variable "string" was declared but never referenced
   \        0xE   0x....             ADR.N    R0,??DataTable188  ;; "G28"
   \       0x10   0x.... 0x....      BL       _Z7mks_G28Pc
   \       0x14   0x.... 0x....      LDR.W    R5,??DataTable192_2
   \       0x18   0x6BE8             LDR      R0,[R5, #+60]
   \       0x1A   0x.... 0x....      BL       mks_moveZ
   \       0x1E   0x6C28             LDR      R0,[R5, #+64]
   \       0x20   0x.... 0x....      BL       mks_preExtrude
   \       0x24   0x6DE9             LDR      R1,[R5, #+92]
   \       0x26   0x6DA8             LDR      R0,[R5, #+88]
   \       0x28   0x.... 0x....      BL       mks_moveXY
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x.... 0x....      BL       mks_moveZ
   \       0x32   0x.... 0x....      BL       _Z15mks_setFeedratev
   \       0x36   0xF105 0x0470      ADD      R4,R5,#+112
   \       0x3A   0x7B21             LDRB     R1,[R4, #+12]
   \       0x3C   0x.... 0x....      LDR.W    R0,??DataTable189_1
   \       0x40   0x6001             STR      R1,[R0, #+0]
   \       0x42   0xF242 0x7010      MOVW     R0,#+10000
   \       0x46   0x4341             MULS     R1,R0,R1
   \       0x48   0x20FF             MOVS     R0,#+255
   \       0x4A   0xFB91 0xF0F0      SDIV     R0,R1,R0
   \       0x4E   0x.... 0x....      LDR.W    R1,??DataTable192_13  ;; 0x40012c34
   \       0x52   0x6008             STR      R0,[R1, #+0]
   \       0x54   0x2100             MOVS     R1,#+0
   \       0x56   0xF105 0x0014      ADD      R0,R5,#+20
   \       0x5A   0x.... 0x....      BL       _Z13lcd_setstatusPKcb
   \       0x5E   0x.... 0x....      BL       _Z9gcode_M24v
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0x7020             STRB     R0,[R4, #+0]
   \       0x66   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_getPositionXYZE()
   \                     _Z19mks_getPositionXYZEv: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x.... 0x....      LDR.W    R5,??DataTable192_8
   \        0x6   0x.... 0x....      LDR.W    R4,??DataTable192_2
   \        0xA   0x6EE1             LDR      R1,[R4, #+108]
   \        0xC   0x4628             MOV      R0,R5
   \        0xE   0x.... 0x....      BL       _ZN10CardReader8setIndexEl
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0x70A8             STRB     R0,[R5, #+2]
   \       0x16   0x.... 0x....      BL       _Z19get_sdcard_commandsv
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x70A8             STRB     R0,[R5, #+2]
   \       0x1E   0xF884 0x0070      STRB     R0,[R4, #+112]
   \       0x22   0x4602             MOV      R2,R0
   \       0x24   0xE009             B.N      ??mks_getPositionXYZE_0
   \                     ??mks_getPositionXYZE_1: (+1)
   \       0x26   0x.... 0x....      LDR.W    R1,??DataTable192_11
   \       0x2A   0xF101 0x0308      ADD      R3,R1,#+8
   \       0x2E   0xF843 0x2020      STR      R2,[R3, R0, LSL #+2]
   \       0x32   0x3118             ADDS     R1,R1,#+24
   \       0x34   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
   \       0x38   0x1C40             ADDS     R0,R0,#+1
   \                     ??mks_getPositionXYZE_0: (+1)
   \       0x3A   0x2804             CMP      R0,#+4
   \       0x3C   0xDBF3             BLT.N    ??mks_getPositionXYZE_1
   \       0x3E   0x4615             MOV      R5,R2
   \       0x40   0xE015             B.N      ??mks_getPositionXYZE_2
   \                     ??mks_getPositionXYZE_3: (+1)
   \       0x42   0xEB04 0x0283      ADD      R2,R4,R3, LSL #+2
   \       0x46   0x6D90             LDR      R0,[R2, #+88]
   \       0x48   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \       0x4C   0x.... 0x....      BL       __aeabi_cfcmple
   \       0x50   0xD209             BCS.N    ??mks_getPositionXYZE_4
   \       0x52   0x.... 0x....      LDR.W    R0,??DataTable192_14
   \       0x56   0xF850 0x6023      LDR      R6,[R0, R3, LSL #+2]
   \       0x5A   0xF026 0x4000      BIC      R0,R6,#0x80000000
   \       0x5E   0x.... 0x....      BL       __aeabi_cfrcmple
   \       0x62   0xD800             BHI.N    ??mks_getPositionXYZE_4
   \       0x64   0x6596             STR      R6,[R2, #+88]
   \                     ??mks_getPositionXYZE_4: (+1)
   \       0x66   0x1C5B             ADDS     R3,R3,#+1
   \                     ??mks_getPositionXYZE_5: (+1)
   \       0x68   0x2B04             CMP      R3,#+4
   \       0x6A   0xDBEA             BLT.N    ??mks_getPositionXYZE_3
   \       0x6C   0x1C6D             ADDS     R5,R5,#+1
   \                     ??mks_getPositionXYZE_2: (+1)
   \       0x6E   0x4628             MOV      R0,R5
   \       0x70   0xB2C0             UXTB     R0,R0
   \       0x72   0x2804             CMP      R0,#+4
   \       0x74   0xDA0E             BGE.N    ??mks_getPositionXYZE_6
   \       0x76   0x.... 0x....      LDR.W    R1,??DataTable192_15
   \       0x7A   0xEB00 0x0240      ADD      R2,R0,R0, LSL #+1
   \       0x7E   0xEB01 0x1042      ADD      R0,R1,R2, LSL #+5
   \       0x82   0x.... 0x....      LDR.W    R1,??DataTable192_10
   \       0x86   0x6288             STR      R0,[R1, #+40]
   \       0x88   0x.... 0x....      BL       _Z21gcode_get_destinationv
   \       0x8C   0x2300             MOVS     R3,#+0
   \       0x8E   0x.... 0x....      LDR.W    R1,??DataTable192_7  ;; 0x38d1b718
   \       0x92   0xE7E9             B.N      ??mks_getPositionXYZE_5
   \                     ??mks_getPositionXYZE_6: (+1)
   \       0x94   0x6E20             LDR      R0,[R4, #+96]
   \       0x96   0x6520             STR      R0,[R4, #+80]
   \       0x98   0x6E60             LDR      R0,[R4, #+100]
   \       0x9A   0x6560             STR      R0,[R4, #+84]
   \       0x9C   0x2100             MOVS     R1,#+0
   \       0x9E   0x460A             MOV      R2,R1
   \       0xA0   0xE009             B.N      ??mks_getPositionXYZE_7
   \                     ??mks_getPositionXYZE_8: (+1)
   \       0xA2   0x.... 0x....      LDR.W    R0,??DataTable192_11
   \       0xA6   0xF100 0x0308      ADD      R3,R0,#+8
   \       0xAA   0xF843 0x2021      STR      R2,[R3, R1, LSL #+2]
   \       0xAE   0x3018             ADDS     R0,R0,#+24
   \       0xB0   0xF840 0x2021      STR      R2,[R0, R1, LSL #+2]
   \       0xB4   0x1C49             ADDS     R1,R1,#+1
   \                     ??mks_getPositionXYZE_7: (+1)
   \       0xB6   0x2904             CMP      R1,#+4
   \       0xB8   0xDBF3             BLT.N    ??mks_getPositionXYZE_8
   \       0xBA   0x4614             MOV      R4,R2
   \       0xBC   0xE00A             B.N      ??mks_getPositionXYZE_9
   \                     ??mks_getPositionXYZE_10: (+1)
   \       0xBE   0x2200             MOVS     R2,#+0
   \       0xC0   0x2160             MOVS     R1,#+96
   \       0xC2   0x.... 0x....      LDR.W    R0,??DataTable192_15
   \       0xC6   0xEB04 0x0344      ADD      R3,R4,R4, LSL #+1
   \       0xCA   0xEB00 0x1043      ADD      R0,R0,R3, LSL #+5
   \       0xCE   0x.... 0x....      BL       __aeabi_memset
   \       0xD2   0x1C64             ADDS     R4,R4,#+1
   \                     ??mks_getPositionXYZE_9: (+1)
   \       0xD4   0x2C04             CMP      R4,#+4
   \       0xD6   0xDBF2             BLT.N    ??mks_getPositionXYZE_10
   \       0xD8   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0xDC   0x.... 0x....      B.W      _Z19clear_command_queuev

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_clearDir()
   \                     mks_clearDir: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
   \        0x4   0x.... 0x....      LDR.W    R4,??DataTable192_2
   \        0x8   0xE008             B.N      ??mks_clearDir_0
   \                     ??mks_clearDir_1: (+1)
   \        0xA   0x1C41             ADDS     R1,R0,#+1
   \        0xC   0x4668             MOV      R0,SP
   \        0xE   0x.... 0x....      BL       strcpy
   \       0x12   0x4601             MOV      R1,R0
   \       0x14   0xF104 0x0014      ADD      R0,R4,#+20
   \       0x18   0x.... 0x....      BL       strcpy
   \                     ??mks_clearDir_0: (+1)
   \       0x1C   0x....             ADR.N    R1,??DataTable189  ;; "/"
   \       0x1E   0xF104 0x0014      ADD      R0,R4,#+20
   \       0x22   0x.... 0x....      BL       __iar_Strstr
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD1EF             BNE.N    ??mks_clearDir_1
   \       0x2A   0xB008             ADD      SP,SP,#+32
   \       0x2C   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \   __interwork __softfp void mks_contiuePrint_UI()
   \                     mks_contiuePrint_UI: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x.... 0x....      ADR.W    R0,?_72
   \        0x8   0x.... 0x....      BL       _Z13lcd_setstatusPKcb
   \        0xC   0x.... 0x....      LDR.W    R4,??DataTable192_8
   \       0x10   0x.... 0x....      LDR.W    R5,??DataTable192_2
   \       0x14   0x2300             MOVS     R3,#+0
   \       0x16   0x2201             MOVS     R2,#+1
   \       0x18   0xF105 0x0114      ADD      R1,R5,#+20
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0x.... 0x....      BL       _ZN10CardReader8openFileEPcbb
   \       0x22   0x4620             MOV      R0,R4
   \       0x24   0x.... 0x....      BL       _ZN10CardReader10isFileOpenEv
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD10F             BNE.N    ??mks_contiuePrint_UI_0
   \       0x2C   0xF105 0x0168      ADD      R1,R5,#+104
   \       0x30   0x20A6             MOVS     R0,#+166
   \       0x32   0x7008             STRB     R0,[R1, #+0]
   \       0x34   0x2201             MOVS     R2,#+1
   \       0x36   0xF44F 0x60AF      MOV      R0,#+1400
   \       0x3A   0x.... 0x....      BL       epr_write_data
   \       0x3E   0x2100             MOVS     R1,#+0
   \       0x40   0x.... 0x....      ADR.W    R0,?_73
   \       0x44   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x48   0x.... 0x....      B.W      _Z13lcd_setstatusPKcb
   \                     ??mks_contiuePrint_UI_0: (+1)
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0x70A0             STRB     R0,[R4, #+2]
   \       0x50   0xF995 0x0414      LDRSB    R0,[R5, #+1044]
   \       0x54   0x2802             CMP      R0,#+2
   \       0x56   0xD101             BNE.N    ??mks_contiuePrint_UI_1
   \       0x58   0x.... 0x....      BL       _Z19mks_getPositionXYZEv
   \                     ??mks_contiuePrint_UI_1: (+1)
   \       0x5C   0xF105 0x0668      ADD      R6,R5,#+104
   \       0x60   0x6871             LDR      R1,[R6, #+4]
   \       0x62   0x4620             MOV      R0,R4
   \       0x64   0x.... 0x....      BL       _ZN10CardReader8setIndexEl
   \       0x68   0x.... 0x....      LDR.W    R4,??DataTable192_11
   \       0x6C   0x6A33             LDR      R3,[R6, #+32]
   \       0x6E   0x69F2             LDR      R2,[R6, #+28]
   \       0x70   0x69B1             LDR      R1,[R6, #+24]
   \       0x72   0xF504 0x7062      ADD      R0,R4,#+904
   \       0x76   0x.... 0x....      BL       _ZN9Stopwatch7setTimeEmmm
   \       0x7A   0xB672             cpsid i
   \       0x7C   0x6A70             LDR      R0,[R6, #+36]
   \       0x7E   0x.... 0x....      BL       HAL_SetTick
   \       0x82   0xB662             cpsie i
   \       0x84   0x6CA8             LDR      R0,[R5, #+72]
   \       0x86   0x60A0             STR      R0,[R4, #+8]
   \       0x88   0x6CE8             LDR      R0,[R5, #+76]
   \       0x8A   0x60E0             STR      R0,[R4, #+12]
   \       0x8C   0x6D28             LDR      R0,[R5, #+80]
   \       0x8E   0x6120             STR      R0,[R4, #+16]
   \       0x90   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x94   0x....             B.N      mks_clearDir

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_rePrintCheck()
   \                     mks_rePrintCheck: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable192_8
   \        0x4   0x78C0             LDRB     R0,[R0, #+3]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD100             BNE.N    ??mks_rePrintCheck_0
   \        0xA   0x4770             BX       LR
   \                     ??mks_rePrintCheck_0: (+1)
   \        0xC   0xB538             PUSH     {R3-R5,LR}
   \        0xE   0x.... 0x....      LDR.W    R4,??DataTable192_2
   \       0x12   0xF104 0x0568      ADD      R5,R4,#+104
   \       0x16   0x2201             MOVS     R2,#+1
   \       0x18   0x4629             MOV      R1,R5
   \       0x1A   0xF44F 0x60AF      MOV      R0,#+1400
   \       0x1E   0x.... 0x....      BL       epr_read_data
   \       0x22   0x7828             LDRB     R0,[R5, #+0]
   \       0x24   0x28A9             CMP      R0,#+169
   \       0x26   0xD10E             BNE.N    ??mks_rePrintCheck_1
   \       0x28   0x20AA             MOVS     R0,#+170
   \       0x2A   0x7028             STRB     R0,[R5, #+0]
   \       0x2C   0x.... 0x....      BL       mks_ReadFromEpr
   \       0x30   0x6868             LDR      R0,[R5, #+4]
   \       0x32   0xF241 0x3189      MOVW     R1,#+5001
   \       0x36   0x4288             CMP      R0,R1
   \       0x38   0xD32D             BCC.N    ??mks_rePrintCheck_2
   \       0x3A   0x2001             MOVS     R0,#+1
   \       0x3C   0xF884 0x0414      STRB     R0,[R4, #+1044]
   \       0x40   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \       0x44   0x....             B.N      mks_contiuePrint_UI
   \                     ??mks_rePrintCheck_1: (+1)
   \       0x46   0x28A7             CMP      R0,#+167
   \       0x48   0xD125             BNE.N    ??mks_rePrintCheck_2
   \       0x4A   0x20AA             MOVS     R0,#+170
   \       0x4C   0x7028             STRB     R0,[R5, #+0]
   \       0x4E   0x221E             MOVS     R2,#+30
   \       0x50   0xF104 0x0114      ADD      R1,R4,#+20
   \       0x54   0xF240 0x50B6      MOVW     R0,#+1462
   \       0x58   0x.... 0x....      BL       epr_read_data
   \       0x5C   0x.... 0x....      BL       mks_ReadFromFile
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD00A             BEQ.N    ??mks_rePrintCheck_3
   \       0x64   0x6868             LDR      R0,[R5, #+4]
   \       0x66   0xF241 0x3189      MOVW     R1,#+5001
   \       0x6A   0x4288             CMP      R0,R1
   \       0x6C   0xD305             BCC.N    ??mks_rePrintCheck_3
   \       0x6E   0x2002             MOVS     R0,#+2
   \       0x70   0xF884 0x0414      STRB     R0,[R4, #+1044]
   \       0x74   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \       0x78   0x....             B.N      mks_contiuePrint_UI
   \                     ??mks_rePrintCheck_3: (+1)
   \       0x7A   0x20A6             MOVS     R0,#+166
   \       0x7C   0x7028             STRB     R0,[R5, #+0]
   \       0x7E   0x2201             MOVS     R2,#+1
   \       0x80   0x4629             MOV      R1,R5
   \       0x82   0xF44F 0x60AF      MOV      R0,#+1400
   \       0x86   0x.... 0x....      BL       epr_write_data
   \       0x8A   0x2100             MOVS     R1,#+0
   \       0x8C   0x....             LDR.N    R0,??DataTable192_16
   \       0x8E   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \       0x92   0x.... 0x....      B.W      _Z13lcd_setstatusPKcb
   \                     ??mks_rePrintCheck_2: (+1)
   \       0x96   0x20A6             MOVS     R0,#+166
   \       0x98   0x7028             STRB     R0,[R5, #+0]
   \       0x9A   0x2201             MOVS     R2,#+1
   \       0x9C   0x4629             MOV      R1,R5
   \       0x9E   0xF44F 0x60AF      MOV      R0,#+1400
   \       0xA2   0xE8BD 0x4038      POP      {R3-R5,LR}
   \       0xA6   0x.... 0x....      B.W      epr_write_data

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_WriteToFile()
   \                     mks_WriteToFile: (+1)
   \        0x0   0xE92D 0x41F8      PUSH     {R3-R8,LR}
   \        0x4   0xB085             SUB      SP,SP,#+20

  	mksReprint.card.openFile(MKS_PFT_NAME, false);
  	                         ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Src\mks_reprint.cpp",924  Warning[Pe2464]: 
          conversion from a string literal to "char *" is deprecated
   \        0x6   0x....             LDR.N    R5,??DataTable192_2
   \        0x8   0xF105 0x04F4      ADD      R4,R5,#+244
   \        0xC   0x2300             MOVS     R3,#+0
   \        0xE   0x461A             MOV      R2,R3
   \       0x10   0x.... 0x....      ADR.W    R1,?_74
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0x.... 0x....      BL       _ZN10CardReader8openFileEPcbb
   \       0x1A   0x4620             MOV      R0,R4
   \       0x1C   0x.... 0x....      BL       _ZN10CardReader10isFileOpenEv
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xF000 0x80BE      BEQ.W    ??mks_WriteToFile_0
   \       0x26   0x2200             MOVS     R2,#+0
   \       0x28   0x2114             MOVS     R1,#+20
   \       0x2A   0x4668             MOV      R0,SP
   \       0x2C   0x.... 0x....      BL       __aeabi_memset4
   \       0x30   0x2206             MOVS     R2,#+6
   \       0x32   0x.... 0x....      ADR.W    R1,?_75
   \       0x36   0x4668             MOV      R0,SP
   \       0x38   0x.... 0x....      BL       __aeabi_memcpy4
   \       0x3C   0x4669             MOV      R1,SP
   \       0x3E   0x4620             MOV      R0,R4
   \       0x40   0x.... 0x....      BL       _ZN10CardReader13write_commandEPc
   \       0x44   0x2200             MOVS     R2,#+0
   \       0x46   0x2114             MOVS     R1,#+20
   \       0x48   0x4668             MOV      R0,SP
   \       0x4A   0x.... 0x....      BL       __aeabi_memset4
   \       0x4E   0x....             ADR.N    R6,??DataTable192  ;; 0x25, 0x64, 0x00, 0x00
   \       0x50   0x6EEA             LDR      R2,[R5, #+108]
   \       0x52   0x4631             MOV      R1,R6
   \       0x54   0x4668             MOV      R0,SP
   \       0x56   0x.... 0x....      BL       sprintf
   \       0x5A   0x4669             MOV      R1,SP
   \       0x5C   0x4620             MOV      R0,R4
   \       0x5E   0x.... 0x....      BL       _ZN10CardReader13write_commandEPc
   \       0x62   0x2200             MOVS     R2,#+0
   \       0x64   0x2114             MOVS     R1,#+20
   \       0x66   0x4668             MOV      R0,SP
   \       0x68   0x.... 0x....      BL       __aeabi_memset4
   \       0x6C   0x....             LDR.N    R0,??DataTable192_17
   \       0x6E   0x6802             LDR      R2,[R0, #+0]
   \       0x70   0x4631             MOV      R1,R6
   \       0x72   0x4668             MOV      R0,SP
   \       0x74   0x.... 0x....      BL       sprintf
   \       0x78   0x4669             MOV      R1,SP
   \       0x7A   0x4620             MOV      R0,R4
   \       0x7C   0x.... 0x....      BL       _ZN10CardReader13write_commandEPc
   \       0x80   0x2200             MOVS     R2,#+0
   \       0x82   0x2114             MOVS     R1,#+20
   \       0x84   0x4668             MOV      R0,SP
   \       0x86   0x.... 0x....      BL       __aeabi_memset4
   \       0x8A   0x....             LDR.N    R0,??DataTable192_18
   \       0x8C   0x6802             LDR      R2,[R0, #+0]
   \       0x8E   0x4631             MOV      R1,R6
   \       0x90   0x4668             MOV      R0,SP
   \       0x92   0x.... 0x....      BL       sprintf
   \       0x96   0x4669             MOV      R1,SP
   \       0x98   0x4620             MOV      R0,R4
   \       0x9A   0x.... 0x....      BL       _ZN10CardReader13write_commandEPc
   \       0x9E   0xF105 0x0784      ADD      R7,R5,#+132
   \       0xA2   0x.... 0x....      LDR.W    R8,??DataTable192_11
   \       0xA6   0xF105 0x0388      ADD      R3,R5,#+136
   \       0xAA   0x463A             MOV      R2,R7
   \       0xAC   0xF105 0x0180      ADD      R1,R5,#+128
   \       0xB0   0xF508 0x7062      ADD      R0,R8,#+904
   \       0xB4   0x.... 0x....      BL       _ZN9Stopwatch7getTimeEPmS0_S0_
   \       0xB8   0x.... 0x....      BL       HAL_GetTick
   \       0xBC   0x60B8             STR      R0,[R7, #+8]
   \       0xBE   0x6879             LDR      R1,[R7, #+4]
   \       0xC0   0x683A             LDR      R2,[R7, #+0]
   \       0xC2   0x4291             CMP      R1,R2
   \       0xC4   0xD200             BCS.N    ??mks_WriteToFile_1
   \       0xC6   0x6078             STR      R0,[R7, #+4]
   \                     ??mks_WriteToFile_1: (+1)
   \       0xC8   0x2200             MOVS     R2,#+0
   \       0xCA   0x2114             MOVS     R1,#+20
   \       0xCC   0x4668             MOV      R0,SP
   \       0xCE   0x.... 0x....      BL       __aeabi_memset4
   \       0xD2   0xF8D5 0x2080      LDR      R2,[R5, #+128]
   \       0xD6   0x4631             MOV      R1,R6
   \       0xD8   0x4668             MOV      R0,SP
   \       0xDA   0x.... 0x....      BL       sprintf
   \       0xDE   0x4669             MOV      R1,SP
   \       0xE0   0x4620             MOV      R0,R4
   \       0xE2   0x.... 0x....      BL       _ZN10CardReader13write_commandEPc
   \       0xE6   0x2200             MOVS     R2,#+0
   \       0xE8   0x2114             MOVS     R1,#+20
   \       0xEA   0x4668             MOV      R0,SP
   \       0xEC   0x.... 0x....      BL       __aeabi_memset4
   \       0xF0   0x683A             LDR      R2,[R7, #+0]
   \       0xF2   0x4631             MOV      R1,R6
   \       0xF4   0x4668             MOV      R0,SP
   \       0xF6   0x.... 0x....      BL       sprintf
   \       0xFA   0x4669             MOV      R1,SP
   \       0xFC   0x4620             MOV      R0,R4
   \       0xFE   0x.... 0x....      BL       _ZN10CardReader13write_commandEPc
   \      0x102   0x2200             MOVS     R2,#+0
   \      0x104   0x2114             MOVS     R1,#+20
   \      0x106   0x4668             MOV      R0,SP
   \      0x108   0x.... 0x....      BL       __aeabi_memset4
   \      0x10C   0x687A             LDR      R2,[R7, #+4]
   \      0x10E   0x4631             MOV      R1,R6
   \      0x110   0x4668             MOV      R0,SP
   \      0x112   0x.... 0x....      BL       sprintf
   \      0x116   0x4669             MOV      R1,SP
   \      0x118   0x4620             MOV      R0,R4
   \      0x11A   0x.... 0x....      BL       _ZN10CardReader13write_commandEPc
   \      0x11E   0x2200             MOVS     R2,#+0
   \      0x120   0x2114             MOVS     R1,#+20
   \      0x122   0x4668             MOV      R0,SP
   \      0x124   0x.... 0x....      BL       __aeabi_memset4
   \      0x128   0x68BA             LDR      R2,[R7, #+8]
   \      0x12A   0x4631             MOV      R1,R6
   \      0x12C   0x4668             MOV      R0,SP
   \      0x12E   0x.... 0x....      BL       sprintf
   \      0x132   0x4669             MOV      R1,SP
   \      0x134   0x4620             MOV      R0,R4
   \      0x136   0x.... 0x....      BL       _ZN10CardReader13write_commandEPc
   \      0x13A   0x2200             MOVS     R2,#+0
   \      0x13C   0x2114             MOVS     R1,#+20
   \      0x13E   0x4668             MOV      R0,SP
   \      0x140   0x.... 0x....      BL       __aeabi_memset4
   \      0x144   0x....             LDR.N    R0,??DataTable189_1
   \      0x146   0x6802             LDR      R2,[R0, #+0]
   \      0x148   0x4631             MOV      R1,R6
   \      0x14A   0x4668             MOV      R0,SP
   \      0x14C   0x.... 0x....      BL       sprintf
   \      0x150   0x4669             MOV      R1,SP
   \      0x152   0x4620             MOV      R0,R4
   \      0x154   0x.... 0x....      BL       _ZN10CardReader13write_commandEPc
   \      0x158   0x2200             MOVS     R2,#+0
   \      0x15A   0x2114             MOVS     R1,#+20
   \      0x15C   0x4668             MOV      R0,SP
   \      0x15E   0x.... 0x....      BL       __aeabi_memset4
   \      0x162   0xF8D8 0x0074      LDR      R0,[R8, #+116]
   \      0x166   0x.... 0x....      BL       __aeabi_f2d
   \      0x16A   0x4602             MOV      R2,R0
   \      0x16C   0x460B             MOV      R3,R1
   \      0x16E   0x....             ADR.N    R1,??DataTable192_3  ;; 0x25, 0x66, 0x00, 0x00
   \      0x170   0x4668             MOV      R0,SP
   \      0x172   0x.... 0x....      BL       sprintf
   \      0x176   0x4669             MOV      R1,SP
   \      0x178   0x4620             MOV      R0,R4
   \      0x17A   0x.... 0x....      BL       _ZN10CardReader13write_commandEPc
   \      0x17E   0x2200             MOVS     R2,#+0
   \      0x180   0x2114             MOVS     R1,#+20
   \      0x182   0x4668             MOV      R0,SP
   \      0x184   0x.... 0x....      BL       __aeabi_memset4
   \      0x188   0x2204             MOVS     R2,#+4
   \      0x18A   0x....             ADR.N    R1,??DataTable192_5  ;; "end"
   \      0x18C   0x4668             MOV      R0,SP
   \      0x18E   0x.... 0x....      BL       __aeabi_memcpy4
   \      0x192   0x4669             MOV      R1,SP
   \      0x194   0x4620             MOV      R0,R4
   \      0x196   0x.... 0x....      BL       _ZN10CardReader13write_commandEPc
   \      0x19A   0x2101             MOVS     R1,#+1
   \      0x19C   0x4620             MOV      R0,R4
   \      0x19E   0x.... 0x....      BL       _ZN10CardReader9closefileEb
   \                     ??mks_WriteToFile_0: (+1)
   \      0x1A2   0xB006             ADD      SP,SP,#+24
   \      0x1A4   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \   __interwork __softfp bool mks_get_commands()
   \                     _Z16mks_get_commandsv: (+1)
   \        0x0   0xE92D 0x47F8      PUSH     {R3-R10,LR}
   \        0x4   0xB085             SUB      SP,SP,#+20
   \        0x6   0x2700             MOVS     R7,#+0
   \        0x8   0x46BA             MOV      R10,R7
   \        0xA   0x....             LDR.N    R5,??DataTable192_2
   \        0xC   0xF105 0x06F4      ADD      R6,R5,#+244
   \       0x10   0x4630             MOV      R0,R6
   \       0x12   0x.... 0x....      BL       _ZN10CardReader3eofEv
   \       0x16   0x4680             MOV      R8,R0
   \       0x18   0x463C             MOV      R4,R7
   \       0x1A   0xE00E             B.N      ??mks_get_commands_1
   \                     ??mks_get_commands_2: (+1)
   \       0x1C   0x....             ADR.N    R1,??DataTable192_5  ;; "end"
   \       0x1E   0x4668             MOV      R0,SP
   \       0x20   0x.... 0x....      BL       strcmp
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD100             BNE.N    ??mks_get_commands_3
   \       0x28   0x2401             MOVS     R4,#+1
   \                     ??mks_get_commands_3: (+1)
   \       0x2A   0xF04F 0x0A00      MOV      R10,#+0
   \       0x2E   0x4652             MOV      R2,R10
   \       0x30   0x2114             MOVS     R1,#+20
   \       0x32   0x4668             MOV      R0,SP
   \       0x34   0x.... 0x....      BL       __aeabi_memset4
   \       0x38   0x1C7F             ADDS     R7,R7,#+1
   \                     ??mks_get_commands_1: (+1)
   \       0x3A   0xF1B8 0x0F00      CMP      R8,#+0
   \       0x3E   0xD165             BNE.N    ??mks_get_commands_4
   \       0x40   0x4630             MOV      R0,R6
   \       0x42   0x.... 0x....      BL       _ZN10CardReader3getEv
   \       0x46   0x4681             MOV      R9,R0
   \       0x48   0x4630             MOV      R0,R6
   \       0x4A   0x.... 0x....      BL       _ZN10CardReader3eofEv
   \       0x4E   0x4680             MOV      R8,R0
   \       0x50   0x4650             MOV      R0,R10
   \       0x52   0xB280             UXTH     R0,R0
   \       0x54   0x4649             MOV      R1,R9
   \       0x56   0xB249             SXTB     R1,R1
   \       0x58   0x290A             CMP      R1,#+10
   \       0x5A   0xD151             BNE.N    ??mks_get_commands_5
   \       0x5C   0x2100             MOVS     R1,#+0
   \       0x5E   0x466A             MOV      R2,SP
   \       0x60   0x4410             ADD      R0,R2,R0
   \       0x62   0xF800 0x1C01      STRB     R1,[R0, #-1]
   \       0x66   0x4638             MOV      R0,R7
   \       0x68   0xB240             SXTB     R0,R0
   \       0x6A   0x1E40             SUBS     R0,R0,#+1
   \       0x6C   0x2809             CMP      R0,#+9
   \       0x6E   0xD8DC             BHI.N    ??mks_get_commands_3
   \       0x70   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??mks_get_commands_0:
   \       0x74   0x07 0x0C          DC8      0x7,0xC,0x13,0x1A
   \              0x13 0x1A    
   \       0x78   0x21 0x28          DC8      0x21,0x28,0x2F,0x36
   \              0x2F 0x36    
   \       0x7C   0x3D 0x06          DC8      0x3D,0x6
   \                     ??mks_get_commands_6: (+1)
   \       0x7E   0xE7D4             B.N      ??mks_get_commands_3
   \                     ??mks_get_commands_7: (+1)
   \       0x80   0xE7CC             B.N      ??mks_get_commands_2
   \                     ??mks_get_commands_8: (+1)
   \       0x82   0x4668             MOV      R0,SP
   \       0x84   0x.... 0x....      BL       atoi
   \       0x88   0x66E8             STR      R0,[R5, #+108]
   \       0x8A   0xE7CE             B.N      ??mks_get_commands_3
   \                     ??mks_get_commands_9: (+1)
   \       0x8C   0x4668             MOV      R0,SP
   \       0x8E   0x.... 0x....      BL       atoi
   \       0x92   0xF105 0x016C      ADD      R1,R5,#+108
   \       0x96   0x80C8             STRH     R0,[R1, #+6]
   \       0x98   0xE7C7             B.N      ??mks_get_commands_3
   \                     ??mks_get_commands_10: (+1)
   \       0x9A   0x4668             MOV      R0,SP
   \       0x9C   0x.... 0x....      BL       atoi
   \       0xA0   0xF105 0x016C      ADD      R1,R5,#+108
   \       0xA4   0x8108             STRH     R0,[R1, #+8]
   \       0xA6   0xE7C0             B.N      ??mks_get_commands_3
   \                     ??mks_get_commands_11: (+1)
   \       0xA8   0x4668             MOV      R0,SP
   \       0xAA   0x.... 0x....      BL       atoi
   \       0xAE   0xF105 0x016C      ADD      R1,R5,#+108
   \       0xB2   0x6148             STR      R0,[R1, #+20]
   \       0xB4   0xE7B9             B.N      ??mks_get_commands_3
   \                     ??mks_get_commands_12: (+1)
   \       0xB6   0x4668             MOV      R0,SP
   \       0xB8   0x.... 0x....      BL       atoi
   \       0xBC   0xF105 0x016C      ADD      R1,R5,#+108
   \       0xC0   0x6188             STR      R0,[R1, #+24]
   \       0xC2   0xE7B2             B.N      ??mks_get_commands_3
   \                     ??mks_get_commands_13: (+1)
   \       0xC4   0x4668             MOV      R0,SP
   \       0xC6   0x.... 0x....      BL       atoi
   \       0xCA   0xF105 0x016C      ADD      R1,R5,#+108
   \       0xCE   0x61C8             STR      R0,[R1, #+28]
   \       0xD0   0xE7AB             B.N      ??mks_get_commands_3
   \                     ??mks_get_commands_14: (+1)
   \       0xD2   0x4668             MOV      R0,SP
   \       0xD4   0x.... 0x....      BL       atoi
   \       0xD8   0xF105 0x016C      ADD      R1,R5,#+108
   \       0xDC   0x6208             STR      R0,[R1, #+32]
   \       0xDE   0xE7A4             B.N      ??mks_get_commands_3
   \                     ??mks_get_commands_15: (+1)
   \       0xE0   0x4668             MOV      R0,SP
   \       0xE2   0x.... 0x....      BL       atoi
   \       0xE6   0xF105 0x016C      ADD      R1,R5,#+108
   \       0xEA   0x7408             STRB     R0,[R1, #+16]
   \       0xEC   0xE79D             B.N      ??mks_get_commands_3
   \                     ??mks_get_commands_16: (+1)
   \       0xEE   0x4668             MOV      R0,SP
   \       0xF0   0x.... 0x....      BL       atof
   \       0xF4   0x.... 0x....      BL       __aeabi_d2f
   \       0xF8   0xF105 0x016C      ADD      R1,R5,#+108
   \       0xFC   0x60C8             STR      R0,[R1, #+12]
   \       0xFE   0xE794             B.N      ??mks_get_commands_3
   \                     ??mks_get_commands_5: (+1)
   \      0x100   0x4669             MOV      R1,SP
   \      0x102   0xF801 0x9000      STRB     R9,[R1, R0]
   \      0x106   0xF10A 0x0A01      ADD      R10,R10,#+1
   \      0x10A   0xE796             B.N      ??mks_get_commands_1
   \                     ??mks_get_commands_4: (+1)
   \      0x10C   0x4620             MOV      R0,R4
   \      0x10E   0xB006             ADD      SP,SP,#+24
   \      0x110   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp bool mks_ReadFromFile()
   \                     mks_ReadFromFile: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x2400             MOVS     R4,#+0

  	mksReprint.card.openFile(MKS_PFT_NAME, true);
  	                         ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Src\mks_reprint.cpp",1070  Warning[Pe2464]: 
          conversion from a string literal to "char *" is deprecated
   \        0x4   0x....             LDR.N    R5,??DataTable192_19
   \        0x6   0x4623             MOV      R3,R4
   \        0x8   0x2201             MOVS     R2,#+1
   \        0xA   0x.... 0x....      ADR.W    R1,?_74
   \        0xE   0x4628             MOV      R0,R5
   \       0x10   0x.... 0x....      BL       _ZN10CardReader8openFileEPcbb
   \       0x14   0x4628             MOV      R0,R5
   \       0x16   0x.... 0x....      BL       _ZN10CardReader10isFileOpenEv
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD006             BEQ.N    ??mks_ReadFromFile_0
   \       0x1E   0x.... 0x....      BL       _Z16mks_get_commandsv
   \       0x22   0x4604             MOV      R4,R0
   \       0x24   0x2101             MOVS     R1,#+1
   \       0x26   0x4628             MOV      R0,R5
   \       0x28   0x.... 0x....      BL       _ZN10CardReader9closefileEb
   \                     ??mks_ReadFromFile_0: (+1)
   \       0x2C   0x4620             MOV      R0,R4
   \       0x2E   0xBD32             POP      {R1,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_clearFile()
   \                     mks_clearFile: (+1)
   \        0x0   0xB518             PUSH     {R3,R4,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x4668             MOV      R0,SP
   \        0x6   0x.... 0x....      ADR.W    R1,?_77
   \        0xA   0x2214             MOVS     R2,#+20
   \        0xC   0x.... 0x....      BL       __aeabi_memcpy4

  	mksReprint.card.openFile(MKS_PFT_NAME, false);
  	                         ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Src\mks_reprint.cpp",1086  Warning[Pe2464]: 
          conversion from a string literal to "char *" is deprecated

  static long gcode_N, gcode_LastN, Stopped_gcode_LastN = 0;
                                    ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\Marlin_main.cpp",369  Warning[Pe550]: 
          variable "Stopped_gcode_LastN" was set but never used

  static inline signed char pgm_read_any(const signed char *p) { return pgm_read_byte_near(p); }
                            ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\Marlin_main.cpp",742  Warning[Pe177]: 
          function "pgm_read_any(signed char const *)" was declared but never
          referenced

  static inline float pgm_read_any(const float *p) { return pgm_read_float_near(p); }
                      ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\Marlin_main.cpp",741  Warning[Pe177]: 
          function "pgm_read_any(float const *)" was declared but never
          referenced

      static bool blocks_queued() { return (block_buffer_head != block_buffer_tail); }
                                    ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\planner.h",415  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement
   \       0x10   0x....             LDR.N    R4,??DataTable192_19
   \       0x12   0x2300             MOVS     R3,#+0
   \       0x14   0x461A             MOV      R2,R3
   \       0x16   0x.... 0x....      ADR.W    R1,?_74
   \       0x1A   0x4620             MOV      R0,R4
   \       0x1C   0x.... 0x....      BL       _ZN10CardReader8openFileEPcbb
   \       0x20   0x4669             MOV      R1,SP
   \       0x22   0x4620             MOV      R0,R4
   \       0x24   0x.... 0x....      BL       _ZN10CardReader13write_commandEPc
   \       0x28   0x2101             MOVS     R1,#+1
   \       0x2A   0x4620             MOV      R0,R4
   \       0x2C   0x.... 0x....      BL       _ZN10CardReader9closefileEb
   \       0x30   0xB006             ADD      SP,SP,#+24
   \       0x32   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \        0x0   0x65 0x6E          DC8 "enqueueing \""
   \              0x71 0x75    
   \              0x65 0x75    
   \              0x65 0x69    
   \              0x6E 0x67    
   \              0x20 0x22    
   \              0x00         
   \        0xD   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \        0x0   0x20 0x49          DC8 " Invalid extruder "
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x65    
   \              0x78 0x74    
   \              0x72 0x75    
   \              0x64 0x65    
   \              0x72 0x20    
   \              0x00         
   \       0x13   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \        0x0   0x2A 0x2A          DC8 "*** Z HOMED TO ENDSTOP (Z_MIN_PROBE_ENDSTOP) ***\012"
   \              0x2A 0x20    
   \              0x5A 0x20    
   \              0x48 0x4F    
   \              0x4D 0x45    
   \              0x44 0x20    
   \              0x54 0x4F    
   \              0x20 0x45    
   \              0x4E 0x44    
   \              0x53 0x54    
   \              0x4F 0x50    
   \              0x20 0x28    
   \              0x5A 0x5F    
   \              0x4D 0x49    
   \              0x4E 0x5F    
   \              0x50 0x52    
   \              0x4F 0x42    
   \              0x45 0x5F    
   \              0x45 0x4E    
   \              0x44 0x53    
   \              0x54 0x4F    
   \              0x50 0x29    
   \              0x20 0x2A    
   \              0x2A 0x2A    
   \              0x0A 0x00    
   \       0x32   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \        0x0   0x48 0x6F          DC8 "Home "
   \              0x6D 0x65    
   \              0x20 0x00    
   \        0x6   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_7:
   \        0x0   0x20 0x66          DC8 " first\012"
   \              0x69 0x72    
   \              0x73 0x74    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_8:
   \        0x0   0x48 0x6F          DC8 "Home %s%s%s first"
   \              0x6D 0x65    
   \              0x20 0x25    
   \              0x73 0x25    
   \              0x73 0x25    
   \              0x73 0x20    
   \              0x66 0x69    
   \              0x72 0x73    
   \              0x74 0x00    
   \       0x12   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable112:
   \        0x0   0x....'....        DC32     card

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable112_1:
   \        0x0   0x....'....        DC32     __dso_handle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable112_2:
   \        0x0   0x....'....        DC32     _ZN10CardReaderD1Ev

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable112_3:
   \        0x0   0x....'....        DC32     mks_heating_busy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable113:
   \        0x0   0x58 0x00          DC8      "X",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable113_1:
   \        0x0   0x59 0x00          DC8      "Y",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable113_2:
   \        0x0   0x5A 0x00          DC8      "Z",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable113_3:
   \        0x0   0x00 0x00          DC8      "",0x0,0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable113_4:
   \        0x0   0x....'....        DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable113_5:
   \        0x0   0x4270'0000        DC32     0x42700000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable113_6:
   \        0x0   0x4316'0000        DC32     0x43160000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable113_7:
   \        0x0   0x....'....        DC32     home_dir_P

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable113_8:
   \        0x0   0x....'....        DC32     mksReprint

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable113_9:
   \        0x0   0x....'....        DC32     _ZN7Planner11abl_enabledE

   \                                 In section .text, align 4, keep-with-next
   \                     ?_10:
   \        0x0   0x42 0x65          DC8 "Bed X: "
   \              0x64 0x20    
   \              0x58 0x3A    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_11:
   \        0x0   0x20 0x59          DC8 " Y: "
   \              0x3A 0x20    
   \              0x00         
   \        0x5   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_12:
   \        0x0   0x20 0x5A          DC8 " Z: "
   \              0x3A 0x20    
   \              0x00         
   \        0x5   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable115:
   \        0x0   0x....'....        DC32     _ZN18DATA_REPRINT_ITMESD1Ev

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable116:
   \        0x0   0x....'....        DC32     home_bump_mm_P

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable116_1:
   \        0x0   0x....'....        DC32     injected_commands_P

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable116_2:
   \        0x0   0x....'....        DC32     axis_relative_modes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable116_3:
   \        0x0   0x....'....        DC32     echomagic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable116_4:
   \        0x0   0x....'....        DC32     customizedSerial

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable116_5:
   \        0x0   0x....'....        DC32     serial2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable116_6:
   \        0x0   0x....'....        DC32     errormagic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable116_7:
   \        0x0   0x....'....        DC32     axis_homed

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable120:
   \        0x0   0x47AE'147B        DC32     0x47ae147b

   \                                 In section .text, align 4, keep-with-next
   \                     ?_13:
   \        0x0   0x42 0x69          DC8 "Bilinear Leveling Grid:\012"
   \              0x6C 0x69    
   \              0x6E 0x65    
   \              0x61 0x72    
   \              0x20 0x4C    
   \              0x65 0x76    
   \              0x65 0x6C    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x47 0x72    
   \              0x69 0x64    
   \              0x3A 0x0A    
   \              0x00         
   \       0x19   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable121:
   \        0x0   0x3F84'7AE1        DC32     0x3f847ae1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable122:
   \        0x0   0x....'....        DC32     saved_feedrate_mm_s

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable123:
   \        0x0   0x....'....        DC32     mks_heating_busy+0x10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable123_1:
   \        0x0   0x....'....        DC32     _ZN8Endstops15z_probe_enabledE

   \                                 In section .text, align 4, keep-with-next
   \                     ?_14:
   \        0x0   0x55 0x6E          DC8 "Unknown command: \""
   \              0x6B 0x6E    
   \              0x6F 0x77    
   \              0x6E 0x20    
   \              0x63 0x6F    
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x3A    
   \              0x20 0x22    
   \              0x00         
   \       0x13   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable126:
   \        0x0   0xC120'0000        DC32     0xc1200000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable126_1:
   \        0x0   0x....'....        DC32     mks_heating_busy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable126_2:
   \        0x0   0x....'....        DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable126_3:
   \        0x0   0x....'....        DC32     mks_heating_busy+0x8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable126_4:
   \        0x0   0x....'....        DC32     _ZN20unified_bed_leveling5stateE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable126_5:
   \        0x0   0x....'....        DC32     Running

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable126_6:
   \        0x0   0x....'....        DC32     _ZN7Planner11abl_enabledE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable126_7:
   \        0x0   0x....'....        DC32     _ZN7Planner13z_fade_heightE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable126_8:
   \        0x0   0xB586'37BD        DC32     0xb58637bd

   \                                 In section .text, align 4, keep-with-next
   \                     ?_15:
   \        0x0   0x62 0x75          DC8 "busy: processing\012"
   \              0x73 0x79    
   \              0x3A 0x20    
   \              0x70 0x72    
   \              0x6F 0x63    
   \              0x65 0x73    
   \              0x73 0x69    
   \              0x6E 0x67    
   \              0x0A 0x00    
   \       0x12   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_16:
   \        0x0   0x62 0x75          DC8 "busy: paused for user\012"
   \              0x73 0x79    
   \              0x3A 0x20    
   \              0x70 0x61    
   \              0x75 0x73    
   \              0x65 0x64    
   \              0x20 0x66    
   \              0x6F 0x72    
   \              0x20 0x75    
   \              0x73 0x65    
   \              0x72 0x0A    
   \              0x00         
   \       0x17   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_17:
   \        0x0   0x62 0x75          DC8 "busy: paused for input\012"
   \              0x73 0x79    
   \              0x3A 0x20    
   \              0x70 0x61    
   \              0x75 0x73    
   \              0x65 0x64    
   \              0x20 0x66    
   \              0x6F 0x72    
   \              0x20 0x69    
   \              0x6E 0x70    
   \              0x75 0x74    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable127:
   \        0x0   0x3586'37BE        DC32     0x358637be

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable127_1:
   \        0x0   0x....'....        DC32     _ZN7Planner21inverse_z_fade_heightE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable127_2:
   \        0x0   0x....'....        DC32     _ZN7Planner16bed_level_matrixE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable127_3:
   \        0x0   0x....'....        DC32     z_values

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable128:
   \        0x0   0x....'....        DC32     customizedSerial

   \                                 In section .text, align 4, keep-with-next
   \                     ?_18:
   \        0x0   0x3F 0x50          DC8 "?Probe "
   \              0x72 0x6F    
   \              0x62 0x65    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_19:
   \        0x0   0x20 0x70          DC8 " position out of range.\012"
   \              0x6F 0x73    
   \              0x69 0x74    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x6F 0x75    
   \              0x74 0x20    
   \              0x6F 0x66    
   \              0x20 0x72    
   \              0x61 0x6E    
   \              0x67 0x65    
   \              0x2E 0x0A    
   \              0x00         
   \       0x19   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_20:
   \        0x0   0x20 0x6E          DC8 " not entered.\012"
   \              0x6F 0x74    
   \              0x20 0x65    
   \              0x6E 0x74    
   \              0x65 0x72    
   \              0x65 0x64    
   \              0x2E 0x0A    
   \              0x00         
   \        0xF   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable129:
   \        0x0   0x....'....        DC32     mks_heating_busy+0x84

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable129_1:
   \        0x0   0x....'....        DC32     serial2

   \                                 In section .text, align 4, keep-with-next
   \                     ?_21:
   \        0x0   0x4E 0x75          DC8 4EH, 75H, 6DH, 20H, 58H, 2CH, 59H, 3AH
   \              0x6D 0x20    
   \              0x58 0x2C    
   \              0x59 0x3A    
   \        0x8   0x20 0x6D          DC8 20H, 6DH, 6BH, 73H, 43H, 66H, 67H, 2EH
   \              0x6B 0x73    
   \              0x43 0x66    
   \              0x67 0x2E    
   \       0x10   0x67 0x72          DC8 67H, 72H, 69H, 64H, 5FH, 6DH, 61H, 78H
   \              0x69 0x64    
   \              0x5F 0x6D    
   \              0x61 0x78    
   \       0x18   0x5F 0x70          DC8 5FH, 70H, 6FH, 69H, 6EH, 74H, 73H, 5FH
   \              0x6F 0x69    
   \              0x6E 0x74    
   \              0x73 0x5F    
   \       0x20   0x78 0x2C          DC8 78H, 2CH, 6DH, 6BH, 73H, 43H, 66H, 67H
   \              0x6D 0x6B    
   \              0x73 0x43    
   \              0x66 0x67    
   \       0x28   0x2E 0x67          DC8 2EH, 67H, 72H, 69H, 64H, 5FH, 6DH, 61H
   \              0x72 0x69    
   \              0x64 0x5F    
   \              0x6D 0x61    
   \       0x30   0x78 0x5F          DC8 78H, 5FH, 70H, 6FH, 69H, 6EH, 74H, 73H
   \              0x70 0x6F    
   \              0x69 0x6E    
   \              0x74 0x73    
   \       0x38   0x5F 0x79          DC8 5FH, 79H, 0AH, 0
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_22:
   \        0x0   0x5A 0x20          DC8 "Z offset: "
   \              0x6F 0x66    
   \              0x66 0x73    
   \              0x65 0x74    
   \              0x3A 0x20    
   \              0x00         
   \        0xB   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_23:
   \        0x0   0x0A 0x4D          DC8 "\012Measured points:\012"
   \              0x65 0x61    
   \              0x73 0x75    
   \              0x72 0x65    
   \              0x64 0x20    
   \              0x70 0x6F    
   \              0x69 0x6E    
   \              0x74 0x73    
   \              0x3A 0x0A    
   \              0x00         
   \       0x13   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable130:
   \        0x0   0x....'....        DC32     _ZN17mesh_bed_leveling8z_valuesE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable131:
   \        0x0   0x4040'0000        DC32     0x40400000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable131_1:
   \        0x0   0x....'....        DC32     mksCfg+0x60

   \                                 In section .text, align 4, keep-with-next
   \                     ?_28:
   \        0x0   0x20 0x42          DC8 " B@:"
   \              0x40 0x3A    
   \              0x00         
   \        0x5   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable132:
   \        0x0   0x20 0x54          DC8      " T:"
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_33:
   \        0x0   0x53 0x43          DC8 "SCARA Theta:"
   \              0x41 0x52    
   \              0x41 0x20    
   \              0x54 0x68    
   \              0x65 0x74    
   \              0x61 0x3A    
   \              0x00         
   \        0xD   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_34:
   \        0x0   0x20 0x20          DC8 "   Psi+Theta:"
   \              0x20 0x50    
   \              0x73 0x69    
   \              0x2B 0x54    
   \              0x68 0x65    
   \              0x74 0x61    
   \              0x3A 0x00    
   \        0xE   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable133:
   \        0x0   0x3FF0'0000        DC32     0x3ff00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable133_1:
   \        0x0   0x20 0x2F          DC8      0x20, 0x2F, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable133_2:
   \        0x0   0x20 0x42          DC8      " B:"
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable133_3:
   \        0x0   0x....'....        DC32     mks_heating_busy+0x398

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable133_4:
   \        0x0   0x9999'999A        DC32     0x9999999a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable133_5:
   \        0x0   0x3FF1'9999        DC32     0x3ff19999

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable134:
   \        0x0   0x20 0x40          DC8      " @:"
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable135:
   \        0x0   0x58 0x3A          DC8      0x58, 0x3A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable135_1:
   \        0x0   0x20 0x59          DC8      " Y:"
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable135_2:
   \        0x0   0x....'....        DC32     endstop_adj

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable136:
   \        0x0   0x20 0x5A          DC8      " Z:"
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable136_1:
   \        0x0   0x20 0x45          DC8      " E:"
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable136_2:
   \        0x0   0x....'....        DC32     mks_heating_busy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable136_3:
   \        0x0   0x....'....        DC32     axis_relative_modes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable136_4:
   \        0x0   0x4270'0000        DC32     0x42700000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable136_5:
   \        0x0   0x....'....        DC32     echomagic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable136_6:
   \        0x0   0x....'....        DC32     serial2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable136_7:
   \        0x0   0x....'....        DC32     host_keepalive_interval

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable136_8:
   \        0x0   0x....'....        DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable136_9:
   \        0x0   0x4396'0000        DC32     0x43960000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable136_10:
   \        0x0   0xC2C8'0000        DC32     0xc2c80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable136_11:
   \        0x0   0x4260'0000        DC32     0x42600000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable136_12:
   \        0x0   0xEB1C'432D        DC32     0xeb1c432d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable136_13:
   \        0x0   0xBF1A'36E2        DC32     0xbf1a36e2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable136_14:
   \        0x0   0x3F1A'36E2        DC32     0x3f1a36e2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable136_15:
   \        0x0   0x3FB9'9999        DC32     0x3fb99999

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable136_16:
   \        0x0   0x....'....        DC32     _ZN17mesh_bed_leveling8z_offsetE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable136_17:
   \        0x0   0x....'....        DC32     customizedSerial

   \                                 In section .text, align 4, keep-with-next
   \                     ?_35:
   \        0x0   0x41 0x63          DC8 "Active Extruder: "
   \              0x74 0x69    
   \              0x76 0x65    
   \              0x20 0x45    
   \              0x78 0x74    
   \              0x72 0x75    
   \              0x64 0x65    
   \              0x72 0x3A    
   \              0x20 0x00    
   \       0x12   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_38:
   \        0x0   0x48 0x41          DC8 "HAS_NO_TEMP_BED!\012"
   \              0x53 0x5F    
   \              0x4E 0x4F    
   \              0x5F 0x54    
   \              0x45 0x4D    
   \              0x50 0x5F    
   \              0x42 0x45    
   \              0x44 0x21    
   \              0x0A 0x00    
   \       0x12   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_39:
   \        0x0   0x52 0x65          DC8 "Resend: "
   \              0x73 0x65    
   \              0x6E 0x64    
   \              0x3A 0x20    
   \              0x00         
   \        0x9   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable139:
   \        0x0   0x....'....        DC32     axis_homed

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable139_1:
   \        0x0   0x....'....        DC32     z_values

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable139_2:
   \        0x0   0x....'....        DC32     `filament_change_beep(bool)::runout_beep`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable139_3:
   \        0x0   0x....'....        DC32     mks_heating_busy+0x398

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable140:
   \        0x0   0x....'....        DC32     axis_relative_modes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable140_1:
   \        0x0   0x....'....        DC32     command_queue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable140_2:
   \        0x0   0x....'....        DC32     mks_heating_busy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable140_3:
   \        0x0   0x6F 0x6B          DC8      0x6F, 0x6B, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable140_4:
   \        0x0   0x....'....        DC32     echomagic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable140_5:
   \        0x0   0x....'....        DC32     customizedSerial

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable140_6:
   \        0x0   0x....'....        DC32     serial2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable140_7:
   \        0x0   0x....'....        DC32     mksReprint

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable141:
   \        0x0   0x....'....        DC32     mksCfg+0x34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable141_1:
   \        0x0   0x....'....        DC32     ?_36

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable145:
   \        0x0   0x....'....        DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable146:
   \        0x0   0x....'....        DC32     mks_heating_busy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable147:
   \        0x0   0x....'....        DC32     soft_endstops_enabled

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable147_1:
   \        0x0   0x....'....        DC32     mksCfg+0x20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable147_2:
   \        0x0   0x....'....        DC32     Running

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable147_3:
   \        0x0   0x....'....        DC32     mksCfg+0x60

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable148:
   \        0x0   0x....'....        DC32     z_values

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable148_1:
   \        0x0   0x....'....        DC32     axis_homed

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable148_2:
   \        0x0   0x5444'2D18        DC32     0x54442d18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable149:
   \        0x0   0x4009'21FB        DC32     0x400921fb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable149_1:
   \        0x0   0x4352'0000        DC32     0x43520000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable149_2:
   \        0x0   0x4066'8000        DC32     0x40668000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable149_3:
   \        0x0   0x43A5'0000        DC32     0x43a50000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_41:
   \        0x0   0x20 0x63          DC8 " cold extrusion prevented\012"
   \              0x6F 0x6C    
   \              0x64 0x20    
   \              0x65 0x78    
   \              0x74 0x72    
   \              0x75 0x73    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x70 0x72    
   \              0x65 0x76    
   \              0x65 0x6E    
   \              0x74 0x65    
   \              0x64 0x0A    
   \              0x00         
   \       0x1B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_42:
   \        0x0   0x20 0x74          DC8 " too long extrusion prevented\012"
   \              0x6F 0x6F    
   \              0x20 0x6C    
   \              0x6F 0x6E    
   \              0x67 0x20    
   \              0x65 0x78    
   \              0x74 0x72    
   \              0x75 0x73    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x70 0x72    
   \              0x65 0x76    
   \              0x65 0x6E    
   \              0x74 0x65    
   \              0x64 0x0A    
   \              0x00         
   \       0x1F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable153:
   \        0x0   0x....'....        DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ?_43:
   \        0x0   0x4D 0x36          DC8 "M600"
   \              0x30 0x30    
   \              0x00         
   \        0x5   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable157:
   \        0x0   0x....'....        DC32     mks_heating_busy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable158:
   \        0x0   0x....'....        DC32     _ZN17mesh_bed_leveling13index_to_xposE

   \                                 In section .text, align 4, keep-with-next
   \                     ?_44:
   \        0x0   0x4B 0x49          DC8 4BH, 49H, 4CH, 4CH, 20H, 63H, 61H, 75H
   \              0x4C 0x4C    
   \              0x20 0x63    
   \              0x61 0x75    
   \        0x8   0x73 0x65          DC8 73H, 65H, 64H, 20H, 62H, 79H, 20H, 74H
   \              0x64 0x20    
   \              0x62 0x79    
   \              0x20 0x74    
   \       0x10   0x6F 0x6F          DC8 6FH, 6FH, 20H, 6DH, 75H, 63H, 68H, 20H
   \              0x20 0x6D    
   \              0x75 0x63    
   \              0x68 0x20    
   \       0x18   0x69 0x6E          DC8 69H, 6EH, 61H, 63H, 74H, 69H, 76H, 65H
   \              0x61 0x63    
   \              0x74 0x69    
   \              0x76 0x65    
   \       0x20   0x20 0x74          DC8 20H, 74H, 69H, 6DH, 65H, 20H, 2DH, 20H
   \              0x69 0x6D    
   \              0x65 0x20    
   \              0x2D 0x20    
   \       0x28   0x63 0x75          DC8 63H, 75H, 72H, 72H, 65H, 6EH, 74H, 20H
   \              0x72 0x72    
   \              0x65 0x6E    
   \              0x74 0x20    
   \       0x30   0x63 0x6F          DC8 63H, 6FH, 6DH, 6DH, 61H, 6EH, 64H, 3AH
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x3A    
   \       0x38   0x20 0x00          DC8 20H, 0
   \       0x3A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_45:
   \        0x0   0x4B 0x49          DC8 "KILLED. "
   \              0x4C 0x4C    
   \              0x45 0x44    
   \              0x2E 0x20    
   \              0x00         
   \        0x9   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable160:
   \        0x0   0x....'....        DC32     Running

   \                                 In section .text, align 4, keep-with-next
   \                     ?_46:
   \        0x0   0x50 0x72          DC8 "Printer halted. kill() called!\012"
   \              0x69 0x6E    
   \              0x74 0x65    
   \              0x72 0x20    
   \              0x68 0x61    
   \              0x6C 0x74    
   \              0x65 0x64    
   \              0x2E 0x20    
   \              0x6B 0x69    
   \              0x6C 0x6C    
   \              0x28 0x29    
   \              0x20 0x63    
   \              0x61 0x6C    
   \              0x6C 0x65    
   \              0x64 0x21    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable163:
   \        0x0   0x....'....        DC32     _ZN17mesh_bed_leveling13index_to_yposE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable163_1:
   \        0x0   0x....'....        DC32     mksCfg+0x60

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable163_2:
   \        0x0   0x....'....        DC32     echomagic

   \                                 In section .text, align 4, keep-with-next
   \                     ?_47:
   \        0x0   0x50 0x72          DC8 50H, 72H, 69H, 6EH, 74H, 65H, 72H, 20H
   \              0x69 0x6E    
   \              0x74 0x65    
   \              0x72 0x20    
   \        0x8   0x73 0x74          DC8 73H, 74H, 6FH, 70H, 70H, 65H, 64H, 20H
   \              0x6F 0x70    
   \              0x70 0x65    
   \              0x64 0x20    
   \       0x10   0x64 0x75          DC8 64H, 75H, 65H, 20H, 74H, 6FH, 20H, 65H
   \              0x65 0x20    
   \              0x74 0x6F    
   \              0x20 0x65    
   \       0x18   0x72 0x72          DC8 72H, 72H, 6FH, 72H, 73H, 2EH, 20H, 46H
   \              0x6F 0x72    
   \              0x73 0x2E    
   \              0x20 0x46    
   \       0x20   0x69 0x78          DC8 69H, 78H, 20H, 74H, 68H, 65H, 20H, 65H
   \              0x20 0x74    
   \              0x68 0x65    
   \              0x20 0x65    
   \       0x28   0x72 0x72          DC8 72H, 72H, 6FH, 72H, 20H, 61H, 6EH, 64H
   \              0x6F 0x72    
   \              0x20 0x61    
   \              0x6E 0x64    
   \       0x30   0x20 0x75          DC8 20H, 75H, 73H, 65H, 20H, 4DH, 39H, 39H
   \              0x73 0x65    
   \              0x20 0x4D    
   \              0x39 0x39    
   \       0x38   0x39 0x20          DC8 39H, 20H, 74H, 6FH, 20H, 72H, 65H, 73H
   \              0x74 0x6F    
   \              0x20 0x72    
   \              0x65 0x73    
   \       0x40   0x74 0x61          DC8 74H, 61H, 72H, 74H, 2EH, 20H, 28H, 54H
   \              0x72 0x74    
   \              0x2E 0x20    
   \              0x28 0x54    
   \       0x48   0x65 0x6D          DC8 65H, 6DH, 70H, 65H, 72H, 61H, 74H, 75H
   \              0x70 0x65    
   \              0x72 0x61    
   \              0x74 0x75    
   \       0x50   0x72 0x65          DC8 72H, 65H, 20H, 69H, 73H, 20H, 72H, 65H
   \              0x20 0x69    
   \              0x73 0x20    
   \              0x72 0x65    
   \       0x58   0x73 0x65          DC8 73H, 65H, 74H, 2EH, 20H, 53H, 65H, 74H
   \              0x74 0x2E    
   \              0x20 0x53    
   \              0x65 0x74    
   \       0x60   0x20 0x69          DC8 20H, 69H, 74H, 20H, 61H, 66H, 74H, 65H
   \              0x74 0x20    
   \              0x61 0x66    
   \              0x74 0x65    
   \       0x68   0x72 0x20          DC8 72H, 20H, 72H, 65H, 73H, 74H, 61H, 72H
   \              0x72 0x65    
   \              0x73 0x74    
   \              0x61 0x72    
   \       0x70   0x74 0x69          DC8 74H, 69H, 6EH, 67H, 29H, 0AH, 0
   \              0x6E 0x67    
   \              0x29 0x0A    
   \              0x00         
   \       0x77   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_48:
   \        0x0   0x53 0x54          DC8 "STOPPED. "
   \              0x4F 0x50    
   \              0x50 0x45    
   \              0x44 0x2E    
   \              0x20 0x00    
   \        0xA   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_49:
   \        0x0   0x4D 0x61          DC8 "Marlin"
   \              0x72 0x6C    
   \              0x69 0x6E    
   \              0x00         
   \        0x7   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_51:
   \        0x0   0x20 0x4C          DC8 " Last Updated: "
   \              0x61 0x73    
   \              0x74 0x20    
   \              0x55 0x70    
   \              0x64 0x61    
   \              0x74 0x65    
   \              0x64 0x3A    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_52:
   \        0x0   0x32 0x30          DC8 "2017-05-12 12:00"
   \              0x31 0x37    
   \              0x2D 0x30    
   \              0x35 0x2D    
   \              0x31 0x32    
   \              0x20 0x31    
   \              0x32 0x3A    
   \              0x30 0x30    
   \              0x00         
   \       0x11   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_53:
   \        0x0   0x20 0x7C          DC8 " | Author: (none, default config)\012"
   \              0x20 0x41    
   \              0x75 0x74    
   \              0x68 0x6F    
   \              0x72 0x3A    
   \              0x20 0x28    
   \              0x6E 0x6F    
   \              0x6E 0x65    
   \              0x2C 0x20    
   \              0x64 0x65    
   \              0x66 0x61    
   \              0x75 0x6C    
   \              0x74 0x20    
   \              0x63 0x6F    
   \              0x6E 0x66    
   \              0x69 0x67    
   \              0x29 0x0A    
   \              0x00         
   \       0x23   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_54:
   \        0x0   0x43 0x6F          DC8 "Compiled: May  7 2021\012"
   \              0x6D 0x70    
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x3A 0x20    
   \              0x4D 0x61    
   \              0x79 0x20    
   \              0x20 0x37    
   \              0x20 0x32    
   \              0x30 0x32    
   \              0x31 0x0A    
   \              0x00         
   \       0x17   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_55:
   \        0x0   0x20 0x46          DC8 " Free Memory: "
   \              0x72 0x65    
   \              0x65 0x20    
   \              0x4D 0x65    
   \              0x6D 0x6F    
   \              0x72 0x79    
   \              0x3A 0x20    
   \              0x00         
   \        0xF   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_56:
   \        0x0   0x20 0x20          DC8 "  PlannerBufferBytes: "
   \              0x50 0x6C    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x72 0x42    
   \              0x75 0x66    
   \              0x66 0x65    
   \              0x72 0x42    
   \              0x79 0x74    
   \              0x65 0x73    
   \              0x3A 0x20    
   \              0x00         
   \       0x17   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_58:
   \        0x0   0x44 0x6F          DC8 "Done saving file.\012"
   \              0x6E 0x65    
   \              0x20 0x73    
   \              0x61 0x76    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x66 0x69    
   \              0x6C 0x65    
   \              0x2E 0x0A    
   \              0x00         
   \       0x13   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable166:
   \        0x0   0x20 0x0A          DC8      0x20, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable166_1:
   \        0x0   0x5444'2D18        DC32     0x54442d18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable166_2:
   \        0x0   0x4019'21FB        DC32     0x401921fb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable166_3:
   \        0x0   0xC019'21FB        DC32     0xc01921fb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable166_4:
   \        0x0   0x40C9'0FDB        DC32     0x40c90fdb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable166_5:
   \        0x0   0x3A83'126F        DC32     0x3a83126f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable166_6:
   \        0x0   0x3FE0'0000        DC32     0x3fe00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable167:
   \        0x0   0x3FF0'0000        DC32     0x3ff00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable167_1:
   \        0x0   0x47AE'147B        DC32     0x47ae147b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable167_2:
   \        0x0   0x3F84'7AE1        DC32     0x3f847ae1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable168:
   \        0x0   0x4D 0x32          DC8      "M29"
   \              0x39 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable169:
   \        0x0   0x4062'C000        DC32     0x4062c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable169_1:
   \        0x0   0x4009'21FB        DC32     0x400921fb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable169_2:
   \        0x0   0x4066'8000        DC32     0x40668000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable169_3:
   \        0x0   0x....'....        DC32     axis_homed

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable169_4:
   \        0x0   0x42C8'0000        DC32     0x42c80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable169_5:
   \        0x0   0xC2C8'0000        DC32     0xc2c80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable169_6:
   \        0x0   0x4260'0000        DC32     0x42600000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable169_7:
   \        0x0   0x5444'2D18        DC32     0x54442d18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable170:
   \        0x0   0x....'....        DC32     home_dir_P

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable170_1:
   \        0x0   0xBF80'0000        DC32     0xbf800000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable171:
   \        0x0   0xC260'0000        DC32     0xc2600000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable171_1:
   \        0x0   0x4316'0000        DC32     0x43160000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable172:
   \        0x0   0x....'....        DC32     volumetric_enabled

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable173:
   \        0x0   0x....'....        DC32     axis_relative_modes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable173_1:
   \        0x0   0x....'....        DC32     gArrayGpioPort

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable173_2:
   \        0x0   0x....'....        DC32     gArrayGpioPin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable173_3:
   \        0x0   0x....'....        DC32     card

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable173_4:
   \        0x0   0x....'....        DC32     mks_heating_busy+0x388

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable174:
   \        0x0   0x....'....        DC32     axis_relative_modes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable174_1:
   \        0x0   0x....'....        DC32     gArrayGpioPort+0x38

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable174_2:
   \        0x0   0x....'....        DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable174_3:
   \        0x0   0x....'....        DC32     mks_heating_busy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable174_4:
   \        0x0   0x....'....        DC32     customizedSerial

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable174_5:
   \        0x0   0x....'....        DC32     serial2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable175:
   \        0x0   0x....'....        DC32     gArrayGpioPin+0x1C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable175_1:
   \        0x0   0x....'....        DC32     errormagic

   \                                 In section .text, align 4, keep-with-next
   \                     ?_59:
   \        0x0   0x4D 0x31          DC8 "M140 S"
   \              0x34 0x30    
   \              0x20 0x53    
   \              0x00         
   \        0x7   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_61:
   \        0x0   0x4D 0x31          DC8 "M109 S"
   \              0x30 0x39    
   \              0x20 0x53    
   \              0x00         
   \        0x7   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_62:
   \        0x0   0x4D 0x31          DC8 "M190 S"
   \              0x39 0x30    
   \              0x20 0x53    
   \              0x00         
   \        0x7   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_63:
   \        0x0   0x47 0x39          DC8 "G92 Z"
   \              0x32 0x20    
   \              0x5A 0x00    
   \        0x6   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable177:
   \        0x0   0x....'....        DC32     Running

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable178:
   \        0x0   0x....'....        DC32     mks_heating_busy+0x398

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable178_1:
   \        0x0   0x....'....        DC32     errormagic

   \                                 In section .text, align 4, keep-with-next
   \                     ?_65:
   \        0x0   0x47 0x31          DC8 "G1 E"
   \              0x20 0x45    
   \              0x00         
   \        0x5   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_66:
   \        0x0   0x47 0x39          DC8 "G92 E"
   \              0x32 0x20    
   \              0x45 0x00    
   \        0x6   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable179:
   \        0x0   0x....'....        DC32     echomagic

   \                                 In section .text, align 4, keep-with-next
   \                     ?_67:
   \        0x0   0x47 0x31          DC8 "G1 X"
   \              0x20 0x58    
   \              0x00         
   \        0x5   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable180:
   \        0x0   0x25 0x64          DC8      0x25, 0x64, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable180_1:
   \        0x0   0x....'....        DC32     thermalManager

   \                                 In section .text, align 4, keep-with-next
   \                     ?_69:
   \        0x0   0x47 0x31          DC8 "G1 Z"
   \              0x20 0x5A    
   \              0x00         
   \        0x5   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable182:
   \        0x0   0x25 0x66          DC8      0x25, 0x66, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable183:
   \        0x0   0x....'....        DC32     blink_time

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable183_1:
   \        0x0   0x....'....        DC32     mksCfg+0xD4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable183_2:
   \        0x0   0x....'....        DC32     mksReprint

   \                                 In section .text, align 4, keep-with-next
   \                     ?_70:
   \        0x0   0x47 0x32          DC8 "G28 X0 Y0"
   \              0x38 0x20    
   \              0x58 0x30    
   \              0x20 0x59    
   \              0x30 0x00    
   \        0xA   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable184:
   \        0x0   0x....'....        DC32     command_queue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable184_1:
   \        0x0   0x20 0x59          DC8      0x20, 0x59, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable184_2:
   \        0x0   0x....'....        DC32     _ZN11Temperature18target_temperatureE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable184_3:
   \        0x0   0x....'....        DC32     _ZN11Temperature22target_temperature_bedE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable186:
   \        0x0   0x40A0'0000        DC32     0x40a00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable188:
   \        0x0   0x47 0x32          DC8      "G28"
   \              0x38 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable189:
   \        0x0   0x2F 0x00          DC8      "/",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable189_1:
   \        0x0   0x....'....        DC32     fanSpeeds

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192:
   \        0x0   0x25 0x64          DC8      0x25, 0x64, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_1:
   \        0x0   0x....'....        DC32     MSG_PAUSE_PRINT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_2:
   \        0x0   0x....'....        DC32     mksReprint

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_3:
   \        0x0   0x25 0x66          DC8      0x25, 0x66, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_4:
   \        0x0   0x....'....        DC32     htim2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_5:
   \        0x0   0x65 0x6E          DC8      "end"
   \              0x64 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_6:
   \        0x0   0x....'....        DC32     _ZN7Stepper13current_blockE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_7:
   \        0x0   0x38D1'B718        DC32     0x38d1b718

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_8:
   \        0x0   0x....'....        DC32     card

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_9:
   \        0x0   0x....'....        DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_10:
   \        0x0   0x....'....        DC32     axis_relative_modes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_11:
   \        0x0   0x....'....        DC32     mks_heating_busy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_12:
   \        0x0   0x....'....        DC32     mksCfg+0x40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_13:
   \        0x0   0x4001'2C34        DC32     0x40012c34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_14:
   \        0x0   0x....'....        DC32     mks_heating_busy+0x18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_15:
   \        0x0   0x....'....        DC32     command_queue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_16:
   \        0x0   0x....'....        DC32     WELCOME_MSG

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_17:
   \        0x0   0x....'....        DC32     _ZN11Temperature18target_temperatureE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_18:
   \        0x0   0x....'....        DC32     _ZN11Temperature22target_temperature_bedE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_19:
   \        0x0   0x....'....        DC32     mksReprint+0xF4

   \                                 In section .text, align 4, keep-with-next
   \                     ?_72:
   \        0x0   0x52 0x65          DC8 "Resume print?"
   \              0x73 0x75    
   \              0x6D 0x65    
   \              0x20 0x70    
   \              0x72 0x69    
   \              0x6E 0x74    
   \              0x3F 0x00    
   \        0xE   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_73:
   \        0x0   0x52 0x65          DC8 "Resume print failed!"
   \              0x73 0x75    
   \              0x6D 0x65    
   \              0x20 0x70    
   \              0x72 0x69    
   \              0x6E 0x74    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x21    
   \              0x00         
   \       0x15   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_74:
   \        0x0   0x6D 0x6B          DC8 "mks_pft.sys"
   \              0x73 0x5F    
   \              0x70 0x66    
   \              0x74 0x2E    
   \              0x73 0x79    
   \              0x73 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_75:
   \        0x0   0x73 0x74          DC8 "start"
   \              0x61 0x72    
   \              0x74 0x00    
   \        0x6   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_77:
   \        0x0   0x63 0x6C          DC8 "clear"
   \              0x65 0x61    
   \              0x72 0x00    
   \        0x6   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_4:
   \        0x0   0x58 0x00          DC8 "X"

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_5:
   \        0x0   0x59 0x00          DC8 "Y"

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_6:
   \        0x0   0x5A 0x00          DC8 "Z"

   \                                 In section .rodata, align 1, keep-with-next
   \                     ?_9:
   \        0x0   0x00               DC8 ""

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_24:
   \        0x0   0x20 0x54          DC8 " T:"
   \              0x3A 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_25:
   \        0x0   0x20 0x2F          DC8 " /"
   \              0x00         
   \        0x3   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_26:
   \        0x0   0x20 0x42          DC8 " B:"
   \              0x3A 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_27:
   \        0x0   0x20 0x40          DC8 " @:"
   \              0x3A 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_29:
   \        0x0   0x58 0x3A          DC8 "X:"
   \              0x00         
   \        0x3   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_30:
   \        0x0   0x20 0x59          DC8 " Y:"
   \              0x3A 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_31:
   \        0x0   0x20 0x5A          DC8 " Z:"
   \              0x3A 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_32:
   \        0x0   0x20 0x45          DC8 " E:"
   \              0x3A 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_36:
   \        0x0   0x62 0x65          DC8 "bed leveling hasn't defined!"
   \              0x64 0x20    
   \              0x6C 0x65    
   \              0x76 0x65    
   \              0x6C 0x69    
   \              0x6E 0x67    
   \              0x20 0x68    
   \              0x61 0x73    
   \              0x6E 0x27    
   \              0x74 0x20    
   \              0x64 0x65    
   \              0x66 0x69    
   \              0x6E 0x65    
   \              0x64 0x21    
   \              0x00         
   \       0x1D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_37:
   \        0x0   0x2F 0x00          DC8 "/"

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_40:
   \        0x0   0x6F 0x6B          DC8 "ok"
   \              0x00         
   \        0x3   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_50:
   \        0x0   0x20 0x0A          DC8 " \012"
   \              0x00         
   \        0x3   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_57:
   \        0x0   0x4D 0x32          DC8 "M29"
   \              0x39 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_60:
   \        0x0   0x25 0x64          DC8 "%d"
   \              0x00         
   \        0x3   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_64:
   \        0x0   0x25 0x66          DC8 "%f"
   \              0x00         
   \        0x3   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_68:
   \        0x0   0x20 0x59          DC8 " Y"
   \              0x00         
   \        0x3   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_71:
   \        0x0   0x47 0x32          DC8 "G28"
   \              0x38 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_76:
   \        0x0   0x65 0x6E          DC8 "end"
   \              0x64 0x00    

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   ADJUST_DELTA(float const *)
        16   -> __aeabi_fadd
        16   -> bilinear_z_offset(float const *)
       8   Buzzer::Buzzer()
         8   -> Buzzer::reset()
         8   -> CircularQueue<tone_t, (uint8_t)'\004'>::CircularQueue()
       0   Buzzer::off()
         0   -> HAL_GPIO_WritePin
       0   Buzzer::on()
         0   -> HAL_GPIO_WritePin
       8   Buzzer::reset()
         8   -> Buzzer::off()
      16   Buzzer::tick()
         0   -> Buzzer::on()
         0   -> Buzzer::reset()
        16   -> CircularQueue<tone_t, (uint8_t)'\004'>::dequeue()
        16   -> CircularQueue<tone_t, (uint8_t)'\004'>::isEmpty()
        16   -> HAL_GetTick
      24   Buzzer::tone(uint16_t const &, uint16_t const &)
        24   -- Indirect call
        24   -> CircularQueue<tone_t, (uint8_t)'\004'>::enqueue(tone_t const &)
        24   -> CircularQueue<tone_t, (uint8_t)'\004'>::isFull()
        24   -> Temperature::manage_heater()
       0   CardReader::eof()
      16   CardReader::get()
        16   -> SdBaseFile::curPosition() const
         0   -> SdBaseFile::read()
       0   CardReader::isFileOpen()
         0   -> SdBaseFile::isOpen() const
       0   CardReader::lastOpenOk()
       0   CardReader::pauseSDPrint()
       0   CardReader::setIndex(long)
         0   -> SdBaseFile::seekSet(uint32_t)
       8   CardReader::~CardReader()
         8   -> SdFile::~SdFile()
         8   -> __aeabi_vec_dtor
       0   CircularQueue<tone_t, (uint8_t)'\004'>::CircularQueue()
      16   CircularQueue<tone_t, (uint8_t)'\004'>::dequeue()
        16   -> CircularQueue<tone_t, (uint8_t)'\004'>::isEmpty()
        16   -> __aeabi_memset4
      16   CircularQueue<tone_t, (uint8_t)'\004'>::enqueue(tone_t const &)
        16   -> CircularQueue<tone_t, (uint8_t)'\004'>::isFull()
       0   CircularQueue<tone_t, (uint8_t)'\004'>::isEmpty()
       0   CircularQueue<tone_t, (uint8_t)'\004'>::isFull()
       8   DATA_REPRINT_ITMES::<_ZN18DATA_REPRINT_ITMESC1Ev>()
         8   -> CardReader::CardReader()
       8   DATA_REPRINT_ITMES::~<unnamed>()
         8   -> CardReader::~CardReader()
       0   Endstops::enable(bool)
       0   Endstops::enable_globally(bool)
       0   Endstops::enable_z_probe(bool)
       0   Endstops::hit_on_purpose()
       0   Endstops::not_homing()
      16   FlushSerialRequestResend()
        16   -> MarlinSerial::flush()
        16   -> MarlinSerial::print(char, int)
        16   -> MarlinSerial::print(long, int)
        16   -> MarlinSerial::write(uint8_t)
         0   -> ok_to_send()
        16   -> serialprintPGM(char const *)
       0   IsRunning()
       0   IsStopped()
       0   MarlinSerial::available()
         0   -> BSP_UartGetNbRxAvalaibleBytes
      16   MarlinSerial::print(char const *)
         0   -> MarlinSerial::write(char const *)
         0   -> package_to_wifi
        16   -> strlen
      16   MarlinSerial::write(char const *)
         0   -> BSP_UartIfQueueTxData
        16   -> strlen
       8   MarlinSerial::write(uint8_t)
         8   -> BSP_UartIfQueueTxData
       0   Planner::apply_leveling(float *)
         0   -> Planner::apply_leveling(float &, float &, float &)
       0   Planner::blocks_queued()
      32   Planner::buffer_line(float, float, float, float const &, float const &, uint8_t)
        32   -> Planner::_buffer_line(float const &, float const &, float const &, float const &, float, uint8_t)
        32   -> Planner::apply_leveling(float &, float &, float &)
      48   Planner::buffer_line_kinematic(float const *, float const &, uint8_t)
        48   -> Planner::_buffer_line(float const &, float const &, float const &, float const &, float, uint8_t)
        48   -> Planner::apply_leveling(float *)
        48   -> inverse_kinematics(float const *)
        48   -> inverse_kinematics_MORGAN_SCARA(float const *)
       8   Planner::discard_current_block()
         8   -> Planner::blocks_queued()
       0   Planner::set_e_position_mm(float const &)
         0   -> Planner::set_position_mm(AxisEnum, float const &)
      24   Planner::set_position_mm(float, float, float, float const &)
        24   -> Planner::_set_position_mm(float const &, float const &, float const &, float const &)
        24   -> Planner::apply_leveling(float &, float &, float &)
       8   RUNPLAN(float)
         8   -> Planner::buffer_line_kinematic(float const *, float const &, uint8_t)
         8   -> line_to_destination(float)
      24   SCARA_move_to_cal(uint8_t, uint8_t)
        24   -> IsRunning()
        24   -> __aeabi_fadd
        24   -> __aeabi_ui2f
        24   -> forward_kinematics_SCARA(float const &, float const &)
        24   -> prepare_move_to_destination()
       0   SYNC_PLAN_POSITION_KINEMATIC()
         0   -> sync_plan_position()
         0   -> sync_plan_position_kinematic()
       0   SdBaseFile::curPosition() const
       0   SdBaseFile::isOpen() const
       0   SdBaseFile::subobject ~SdBaseFile()
         0   -> SdBaseFile::~SdBaseFile()
       8   SdBaseFile::~SdBaseFile()
         8   -> SdBaseFile::close()
         8   -> SdBaseFile::isOpen() const
       8   SdFile::~SdFile()
         8   -> SdBaseFile::subobject ~SdBaseFile()
       0   Stepper::get_axis_position_degrees(AxisEnum)
         0   -> Stepper::get_axis_position_mm(AxisEnum)
       0   Temperature::degBed()
       0   Temperature::degHotend(uint8_t)
       0   Temperature::degTargetBed()
         0   -> __aeabi_i2f
       0   Temperature::degTargetHotend(uint8_t)
         0   -> __aeabi_i2f
       8   Temperature::isCoolingBed()
         8   -> __aeabi_i2f
         8 __aeabi_cfcmple
       8   Temperature::isCoolingHotend(uint8_t)
         8   -> __aeabi_i2f
         8 __aeabi_cfcmple
       8   Temperature::setTargetBed(float)
         0   -> Temperature::start_watching_bed()
         8   -> __aeabi_f2iz
       8   Temperature::setTargetHotend(float, uint8_t)
         0   -> Temperature::start_watching_heater(uint8_t)
         8   -> __aeabi_f2iz
       8   Temperature::tooColdToExtrude(uint8_t)
         8   -> Temperature::degHotend(uint8_t)
         8 __aeabi_cfcmple
      40   __sti__routine()
        40   -> Buzzer::Buzzer()
        40   -> CardReader::CardReader()
        40   -> DATA_REPRINT_ITMES::<_ZN18DATA_REPRINT_ITMESC1Ev>()
        40   -> Stopwatch::Stopwatch()
         0   -> __aeabi_atexit
        40   -> __aeabi_atexit
        40   -> __aeabi_fdiv
        40   -> __aeabi_fmul
        40   -> __aeabi_fsub
        40   -> unified_bed_leveling::unified_bed_leveling()
       0   _commit_command(bool)
       8   _enqueuecommand(char const *, bool)
         8   -> _commit_command(bool)
         8   -> strcpy
      24   _manual_goto_xy(float const &, float const &)
         0   -> Stepper::synchronize()
        24   -> __aeabi_d2f
        24   -> __aeabi_dadd
        24   -> __aeabi_f2d
        24   -> __aeabi_fadd
        24   -> __aeabi_fdiv
        24   -> line_to_current_position()
      24   axis_unhomed_error(bool, bool, bool)
        24   -> lcd_status_printf_P(uint8_t, char const *, ...)
        24   -> serialprintPGM(char const *)
       0   base_home_pos(AxisEnum)
       0   base_max_pos(AxisEnum)
       0   base_min_pos(AxisEnum)
      64   bilinear_line_to_destination(float, uint16_t, uint16_t)
        64   -> __aeabi_f2iz
        64   -> __aeabi_fadd
        64   -> __aeabi_fdiv
        64   -> __aeabi_fmul
        64   -> __aeabi_fsub
        64   -> __aeabi_i2f
        64   -> __aeabi_memcpy
        64   -> bilinear_line_to_destination(float, uint16_t, uint16_t)
        64   -> line_to_destination(float)
        64   -> set_current_to_destination()
      24   bilinear_z_offset(float const *)
        24   -> __aeabi_f2iz
         0   -> __aeabi_fadd
        24   -> __aeabi_fadd
        24   -> __aeabi_fmul
        24   -> __aeabi_fsub
        24   -> __aeabi_i2f
        24   -> floorf
        24 __aeabi_cfcmpeq
        24 __aeabi_cfcmple
      24   calculate_volumetric_multiplier(float)
         0   -> __aeabi_d2f
        24   -> __aeabi_ddiv
        24   -> __aeabi_dmul
        24   -> __aeabi_f2d
        24 __aeabi_cfcmpeq
       8   calculate_volumetric_multipliers()
         8   -> calculate_volumetric_multiplier(float)
       8   clamp_to_software_endstops(float *)
         8 __aeabi_cfcmple
       0   clean_up_after_endstop_or_probe_move()
         0   -> refresh_cmd_timeout()
       0   clear_command_queue()
       0   code_has_value()
       8   code_seen(char)
         8   -> __iar_Strchr
       8   code_value_bool()
         8   -> code_has_value()
         8   -> code_value_byte()
       8   code_value_byte()
         8   -> strtol
      16   code_value_float()
         0   -> __aeabi_d2f
        16   -> __aeabi_d2f
        16   -> __iar_Strchr
        16   -> strtod
       0   code_value_int()
         0   -> strtol
       0   code_value_long()
         0   -> strtol
       0   code_value_millis()
         0   -> code_value_ulong()
       8   code_value_millis_from_seconds()
         0   -> __aeabi_f2uiz
         8   -> __aeabi_fmul
         8   -> code_value_float()
       8   code_value_temp_abs()
         8   -> code_value_int()
       8   code_value_temp_diff()
         8   -> code_value_int()
       0   code_value_ulong()
         0   -> strtoul
       8   code_value_ushort()
         8   -> strtoul
      32   delta_safe_distance_from_top()
        32   -> __aeabi_fadd
        32   -> __aeabi_fsub
        32   -> inverse_kinematics(float const *)
        32   -> inverse_kinematics_MORGAN_SCARA(float const *)
      16   disable_all_steppers()
        16   -> HAL_GPIO_WritePin
         0   -> disable_e_steppers()
       0   disable_e_steppers()
         0   -> HAL_GPIO_WritePin
      32   do_blocking_move_to(float const &, float const &, float const &, float const &)
        32   -> Stepper::synchronize()
        32   -> line_to_current_position()
        32   -> prepare_move_to_destination()
         0   -> prepare_uninterpolated_move_to_destination(float)
        32   -> prepare_uninterpolated_move_to_destination(float)
        32   -> set_destination_to_current()
        32 __aeabi_cfcmpeq
        32 __aeabi_cfcmple
       0   do_blocking_move_to_x(float const &, float const &)
         0   -> do_blocking_move_to(float const &, float const &, float const &, float const &)
       0   do_blocking_move_to_xy(float const &, float const &, float const &)
         0   -> do_blocking_move_to(float const &, float const &, float const &, float const &)
       0   do_blocking_move_to_z(float const &, float const &)
         0   -> do_blocking_move_to(float const &, float const &, float const &, float const &)
      32   do_homing_move(AxisEnum, float, float)
        32   -> Endstops::hit_on_purpose()
        32   -> Planner::buffer_line(float, float, float, float const &, float const &, uint8_t)
        32   -> SYNC_PLAN_POSITION_KINEMATIC()
        32   -> Stepper::synchronize()
        32   -> inverse_kinematics(float const *)
        32   -> inverse_kinematics_MORGAN_SCARA(float const *)
        32   -> sync_plan_position()
        32 __aeabi_cfcmpeq
      16   do_probe_move(float, float)
        16   -> Endstops::hit_on_purpose()
        16   -> SYNC_PLAN_POSITION_KINEMATIC()
        16   -> __aeabi_fadd
        16   -> __aeabi_fdiv
        16   -> do_blocking_move_to_z(float const &, float const &)
        16   -> set_current_from_steppers_for_axis(AxisEnum)
      16   do_probe_raise(float)
        16   -> __aeabi_fadd
        16   -> __aeabi_fsub
        16   -> do_blocking_move_to_z(float const &, float const &)
        16 __aeabi_cfcmple
      48   drain_injected_commands_P()
        48   -> enqueue_and_echo_command(char const *, bool)
        48   -> strncpy
       8   duration_t::day() const
         8   -> duration_t::hour() const
       0   duration_t::duration_t(uint32_t const &)
       8   duration_t::hour() const
         8   -> duration_t::minute() const
       8   duration_t::minute() const
         8   -> duration_t::second() const
       0   duration_t::second() const
      48   duration_t::toString(char *) const
        48   -> duration_t::day() const
        48   -> duration_t::hour() const
        48   -> duration_t::minute() const
        48   -> duration_t::second() const
        48   -> duration_t::year() const
         0   -> sprintf
        48   -> sprintf
       8   duration_t::year() const
         8   -> duration_t::day() const
      16   enable_all_steppers()
         0   -> HAL_GPIO_WritePin
        16   -> HAL_GPIO_WritePin
       8   enqueue_and_echo_command(char const *, bool)
         8   -> MarlinSerial::print(char, int)
         8   -> MarlinSerial::write(uint8_t)
         8   -> _enqueuecommand(char const *, bool)
         8   -> serial_echopair_P(char const *, char const *)
         8   -> serialprintPGM(char const *)
       0   enqueue_and_echo_commands_P(char const *)
         0   -> drain_injected_commands_P()
      40   extrapolate_one_point(uint8_t, uint8_t, int8_t, int8_t)
        40   -> MarlinSerial::print(char, int)
        40   -> MarlinSerial::write(uint8_t)
        40   -> __aeabi_fadd
        40   -> __aeabi_fdiv
        40   -> __aeabi_fmul
        40   -> __aeabi_fsub
        40   -> isnan(float)
      48   extrapolate_unprobed_bed_level()
        48   -> extrapolate_one_point(uint8_t, uint8_t, int8_t, int8_t)
      16   filament_change_beep(bool)
        16   -> Buzzer::tone(uint16_t const &, uint16_t const &)
        16   -> HAL_GetTick
      40   find_pause_e_pos()
        40   -> __aeabi_d2f
        40   -> __aeabi_dadd
        40   -> __iar_Strchr
        40   -> atof
       0   forward_kinematics_DELTA(float *)
         0   -> forward_kinematics_DELTA(float, float, float)
      80   forward_kinematics_DELTA(float, float, float)
        80   -> __aeabi_fadd
        80   -> __aeabi_fdiv
        80   -> __aeabi_fmul
        80   -> __aeabi_fsub
        80   -> sqrtf
      32   forward_kinematics_SCARA(float const &, float const &)
        32   -> __aeabi_d2f
        32   -> __aeabi_ddiv
        32   -> __aeabi_dmul
        32   -> __aeabi_f2d
        32   -> __aeabi_fadd
        32   -> cos
        32   -> sin
       0   freeMemory()
       8   gcode_G0_G1()
         8   -> IsRunning()
         8   -> gcode_get_destination()
         0   -> prepare_move_to_destination()
       8   gcode_G0_G1_SCARA(bool)
         8   -> IsRunning()
         8   -> gcode_get_destination()
         0   -> prepare_move_to_destination()
         0   -> prepare_uninterpolated_move_to_destination(float)
      40   gcode_G28()
        40   -> Endstops::enable(bool)
        40   -> Endstops::not_homing()
        40   -> SYNC_PLAN_POSITION_KINEMATIC()
        40   -> Stepper::synchronize()
        40   -> clean_up_after_endstop_or_probe_move()
        40   -> code_seen(char)
        40   -> do_blocking_move_to_z(float const &, float const &)
        40   -> home_delta()
        40   -> homeaxis(AxisEnum)
        40   -> quick_home_xy()
        40   -> report_current_position()
        40   -> set_bed_leveling_enabled(bool)
        40   -> set_destination_to_current()
        40   -> setup_for_endstop_or_probe_move()
        40 __aeabi_cfcmple
    1264   gcode_G29()
      1248   -> MarlinSerial::print(char, int)
      1248   -> MarlinSerial::print(double, int)
      1248   -> MarlinSerial::write(uint8_t)
      1248   -> Planner::unapply_leveling(float *)
      1248   -> SYNC_PLAN_POSITION_KINEMATIC()
      1248   -> Stepper::synchronize()
      1248   -> __aeabi_d2f
      1248   -> __aeabi_d2iz
      1248   -> __aeabi_dadd
      1248   -> __aeabi_ddiv
      1248   -> __aeabi_f2d
      1248   -> __aeabi_f2iz
      1248   -> __aeabi_fadd
      1248   -> __aeabi_fdiv
      1248   -> __aeabi_fmul
      1248   -> __aeabi_fsub
      1248   -> __aeabi_i2f
      1248   -> __aeabi_memcpy
      1248   -> __aeabi_memcpy4
      1264   -> __aeabi_memcpy4
      1248   -> __aeabi_ui2f
      1248   -> apply_rotation_xyz(matrix_3x3, float &, float &, float &)
      1248   -> axis_unhomed_error(bool, bool, bool)
      1248   -> bilinear_z_offset(float const *)
      1248   -> clean_up_after_endstop_or_probe_move()
      1248   -> code_has_value()
      1248   -> code_seen(char)
      1248   -> code_value_bool()
      1248   -> code_value_byte()
      1248   -> code_value_float()
      1248   -> code_value_int()
      1248   -> extrapolate_unprobed_bed_level()
      1248   -> floor
      1248   -> free
      1248   -> idle(bool)
      1248   -> isnan(float)
      1248   -> kill(char const *)
      1248   -> malloc
      1248   -> matrix_3x3::create_look_at(vector_3)
      1248   -> matrix_3x3::debug(char const *)
      1248   -> out_of_range_error(char const *)
      1248   -> position_is_reachable(float const *, bool)
      1248   -> print_bilinear_leveling_grid()
      1248   -> probe_pt(float, float, bool, int)
      1248   -> qr_solve(float *, int, int, float *, float *)
      1248   -> rand
      1248   -> refresh_bed_level()
      1248   -> report_current_position()
      1248   -> reset_bed_level()
      1248   -> serialprintPGM(char const *)
      1248   -> set_bed_leveling_enabled(bool)
      1248   -> set_current_from_steppers_for_axis(AxisEnum)
      1248   -> set_probe_deployed(bool)
      1248   -> setup_for_endstop_or_probe_move()
      1248   -> vector_3::cross(vector_3, vector_3)
      1248   -> vector_3::get_normal()
      1248   -> vector_3::operator-(vector_3)
      1248   -> vector_3::vector_3(float, float, float)
      1248 __aeabi_cfcmpeq
      1248 __aeabi_cfcmple
      1248 __aeabi_cfrcmple
      24   gcode_G29_MESH_BED_LEVELING()
        24   -> Buzzer::tone(uint16_t const &, uint16_t const &)
        24   -> MarlinSerial::print(char, int)
        24   -> MarlinSerial::write(uint8_t)
        24   -> Stepper::synchronize()
        24   -> __aeabi_fadd
        24   -> _manual_goto_xy(float const &, float const &)
        24   -> code_seen(char)
        24   -> code_value_byte()
        24   -> code_value_float()
        24   -> code_value_int()
        24   -> enqueue_and_echo_commands_P(char const *)
        24   -> line_to_current_position()
        24   -> mbl_mesh_report()
        24   -> mesh_bed_leveling::active()
        24   -> mesh_bed_leveling::has_mesh()
        24   -> mesh_bed_leveling::reset()
        24   -> mesh_bed_leveling::set_zigzag_z(int8_t, float const &)
        24   -> mesh_bed_leveling::zigzag(int8_t, int8_t &, int8_t &)
        24   -> mesh_probing_done()
        24   -> report_current_position()
        24   -> reset_bed_level()
        24   -> say_not_entered()
        24   -> serial_echopair_P(char const *, char const *)
        24   -> serialprintPGM(char const *)
      72   gcode_G2_G3(bool)
        72   -> IsRunning()
        72   -> __aeabi_d2f
        72   -> __aeabi_dmul
        72   -> __aeabi_dsub
        72   -> __aeabi_f2d
        72   -> __aeabi_fadd
        72   -> __aeabi_fdiv
        72   -> __aeabi_fmul
        72   -> __aeabi_fsub
        72   -> code_seen(char)
        72   -> code_value_float()
        72   -> gcode_get_destination()
        72   -> plan_arc(float *, float *, uint8_t)
        72   -> refresh_cmd_timeout()
        72   -> serialprintPGM(char const *)
        72   -> sqrt
        72   -> sqrtf
        72 __aeabi_cfcmpeq
        72 __aeabi_cfcmple
      40   gcode_G30()
        40   -> MarlinSerial::print(char, int)
        40   -> MarlinSerial::write(uint8_t)
        40   -> __aeabi_dadd
        40   -> __aeabi_f2d
        40   -> __aeabi_fadd
        40   -> clean_up_after_endstop_or_probe_move()
        40   -> code_seen(char)
        40   -> code_value_bool()
        40   -> code_value_float()
        40   -> position_is_reachable(float const *, bool)
        40   -> probe_pt(float, float, bool, int)
        40   -> report_current_position()
        40   -> serial_echopair_P(char const *, double)
        40   -> set_bed_leveling_enabled(bool)
        40   -> setup_for_endstop_or_probe_move()
       8   gcode_G4()
         8   -> HAL_GetTick
         8   -> Stepper::synchronize()
         8   -> code_seen(char)
         8   -> code_value_millis()
         8   -> code_value_millis_from_seconds()
         8   -> idle(bool)
         8   -> lcd_hasstatus()
         8   -> lcd_setstatuspgm(char const *, uint8_t)
         8   -> refresh_cmd_timeout()
      24   gcode_G92()
        24   -> SYNC_PLAN_POSITION_KINEMATIC()
        24   -> Stepper::synchronize()
        24   -> __aeabi_fadd
        24   -> __aeabi_fsub
        24   -> code_seen(char)
        24   -> code_value_float()
         0   -> report_current_position()
        24   -> sync_plan_position_e()
        24   -> update_software_endstops(AxisEnum)
      24   gcode_M0_M1()
        24   -> HAL_GetTick
        24   -> Stepper::synchronize()
        24   -> code_seen(char)
        24   -> code_value_millis()
        24   -> code_value_millis_from_seconds()
        24   -> idle(bool)
        24   -> lcd_detected()
        24   -> lcd_setstatus(char const *, bool)
        24   -> lcd_setstatuspgm(char const *, uint8_t)
        24   -> refresh_cmd_timeout()
      16   gcode_M104()
         0   -> Planner::autotemp_M104_M109()
        16   -> Stopwatch::stop()
        16   -> Temperature::degHotend(uint8_t)
        16   -> Temperature::setTargetHotend(float, uint8_t)
        16   -> __aeabi_fmul
        16   -> __aeabi_i2f
        16   -> code_seen(char)
        16   -> code_value_temp_abs()
        16   -> get_target_extruder_from_command(int)
        16   -> lcd_setstatuspgm(char const *, uint8_t)
        16 __aeabi_cfcmple
        16 __aeabi_cfrcmple
       8   gcode_M105()
         0   -> MarlinSerial::print(char, int)
         0   -> MarlinSerial::write(uint8_t)
         8   -> get_target_extruder_from_command(int)
         8   -> print_heaterstates()
         8   -> serialprintPGM(char const *)
       8   gcode_M106()
         8   -> code_seen(char)
         8   -> code_value_ushort()
       8   gcode_M107()
         8   -> code_seen(char)
         8   -> code_value_ushort()
       0   gcode_M108()
      48   gcode_M109()
        48   -> HAL_GetTick
        48   -> MarlinSerial::print(char, int)
        48   -> MarlinSerial::print(long, int)
        48   -> MarlinSerial::write(uint8_t)
        48   -> Planner::autotemp_M104_M109()
        48   -> Stopwatch::start()
        48   -> Stopwatch::stop()
        48   -> Temperature::degHotend(uint8_t)
        48   -> Temperature::degTargetHotend(uint8_t)
        48   -> Temperature::isCoolingHotend(uint8_t)
        48   -> Temperature::setTargetHotend(float, uint8_t)
        48   -> __aeabi_fmul
        48   -> __aeabi_fsub
        48   -> __aeabi_i2f
        48   -> code_seen(char)
        48   -> code_value_temp_abs()
        48   -> get_target_extruder_from_command(int)
        48   -> idle(bool)
        48   -> lcd_setstatuspgm(char const *, uint8_t)
        48   -> print_heaterstates()
        48   -> refresh_cmd_timeout()
        48   -> serialprintPGM(char const *)
        48 __aeabi_cfcmpeq
        48 __aeabi_cfcmple
        48 __aeabi_cfrcmple
       8   gcode_M110()
         8   -> code_seen(char)
         8   -> code_value_long()
      16   gcode_M111()
         0   -> MarlinSerial::print(char, int)
        16   -> MarlinSerial::print(char, int)
         0   -> MarlinSerial::write(uint8_t)
        16   -> MarlinSerial::write(uint8_t)
        16   -> code_seen(char)
        16   -> code_value_byte()
        16   -> serialprintPGM(char const *)
       0   gcode_M112()
         0   -> kill(char const *)
       8   gcode_M113()
         0   -> MarlinSerial::print(char, int)
         0   -> MarlinSerial::write(uint8_t)
         8   -> code_seen(char)
         8   -> code_value_byte()
         8   -> serial_echopair_P(char const *, unsigned long)
         8   -> serialprintPGM(char const *)
       8   gcode_M114()
         8   -> Stepper::synchronize()
         0   -> report_current_position()
       0   gcode_M115()
         0   -> serialprintPGM(char const *)
       0   gcode_M117()
         0   -> lcd_setstatus(char const *, bool)
       0   gcode_M119()
         0   -> Endstops::M119()
       0   gcode_M120()
         0   -> Endstops::enable_globally(bool)
       0   gcode_M121()
         0   -> Endstops::enable_globally(bool)
       8   gcode_M140()
         0   -> Temperature::setTargetBed(float)
         8   -> __aeabi_i2f
         8   -> code_seen(char)
         8   -> code_value_temp_abs()
      24   gcode_M145()
        24   -> __aeabi_f2iz
        24   -> __aeabi_i2f
        24   -> code_seen(char)
        24   -> code_value_int()
         0   -> serialprintPGM(char const *)
        24   -> serialprintPGM(char const *)
        24 __aeabi_cfcmple
       8   gcode_M17()
         0   -> enable_all_steppers()
         8   -> lcd_setstatuspgm(char const *, uint8_t)
       8   gcode_M18_M84()
         8   -> HAL_GPIO_WritePin
         0   -> Stepper::finish_and_disable()
         8   -> Stepper::synchronize()
         8   -> code_seen(char)
         8   -> code_value_millis_from_seconds()
         0   -> disable_e_steppers()
      48   gcode_M190()
        48   -> HAL_GetTick
        48   -> MarlinSerial::print(char, int)
        48   -> MarlinSerial::print(long, int)
        48   -> MarlinSerial::write(uint8_t)
        48   -> Stopwatch::start()
        48   -> Temperature::degBed()
        48   -> Temperature::degTargetBed()
        48   -> Temperature::isCoolingBed()
        48   -> Temperature::setTargetBed(float)
        48   -> __aeabi_fsub
        48   -> __aeabi_i2f
        48   -> code_seen(char)
        48   -> code_value_temp_abs()
        48   -> idle(bool)
        48   -> lcd_setstatuspgm(char const *, uint8_t)
        48   -> print_heaterstates()
        48   -> refresh_cmd_timeout()
        48   -> serialprintPGM(char const *)
        48 __aeabi_cfcmpeq
        48 __aeabi_cfcmple
        48 __aeabi_cfrcmple
       8   gcode_M20()
         8   -> CardReader::ls()
         0   -> serialprintPGM(char const *)
         8   -> serialprintPGM(char const *)
       8   gcode_M200()
         0   -> calculate_volumetric_multipliers()
         8   -> code_seen(char)
         8   -> code_value_float()
         8   -> get_target_extruder_from_command(int)
         8 __aeabi_cfcmpeq
       8   gcode_M201()
         0   -> Planner::reset_acceleration_rates()
         8   -> __aeabi_f2uiz
         8   -> code_seen(char)
         8   -> code_value_float()
       8   gcode_M203()
         8   -> code_seen(char)
         8   -> code_value_float()
       8   gcode_M204()
         0   -> MarlinSerial::print(char, int)
         8   -> MarlinSerial::print(char, int)
         0   -> MarlinSerial::write(uint8_t)
         8   -> MarlinSerial::write(uint8_t)
         8   -> code_seen(char)
         8   -> code_value_float()
         8   -> serial_echopair_P(char const *, float)
       8   gcode_M205()
         8   -> code_seen(char)
         8   -> code_value_float()
         8   -> code_value_millis()
      16   gcode_M206()
        16   -> SYNC_PLAN_POSITION_KINEMATIC()
        16   -> code_seen(char)
        16   -> code_value_float()
         0   -> report_current_position()
        16   -> set_home_offset(AxisEnum, float)
       0   gcode_M21()
         0   -> CardReader::initsd()
      24   gcode_M211()
         0   -> MarlinSerial::print(char, int)
         0   -> MarlinSerial::write(uint8_t)
        24   -> code_seen(char)
        24   -> code_value_bool()
        24   -> serial_echopair_P(char const *, float)
        24   -> serialprintPGM(char const *)
       0   gcode_M22()
         0   -> CardReader::release()
       8   gcode_M220()
         8   -> code_seen(char)
         8   -> code_value_int()
       8   gcode_M221()
         8   -> code_seen(char)
         8   -> code_value_int()
         8   -> get_target_extruder_from_command(int)
      16   gcode_M226()
        16   -> HAL_GPIO_ReadPin
        16   -> Stepper::synchronize()
        16   -> code_seen(char)
        16   -> code_value_int()
        16   -> idle(bool)
        16   -> pin_is_protected(uint8_t)
      16   gcode_M23()
         0   -> CardReader::openFile(char *, bool, bool)
        16   -> CardReader::openFile(char *, bool, bool)
        16   -> __iar_Strstr
       8   gcode_M24()
         8   -> CardReader::lastOpenOk()
         8   -> CardReader::startFileprint()
         0   -> Stopwatch::start()
         8   -> mks_resumePrint
       8   gcode_M25()
         8   -> CardReader::pauseSDPrint()
         8   -> Stopwatch::pause()
       8   gcode_M26()
         0   -> CardReader::setIndex(long)
         8   -> code_seen(char)
         8   -> code_value_long()
       0   gcode_M27()
         0   -> CardReader::getStatus()
       0   gcode_M28()
         0   -> CardReader::openFile(char *, bool, bool)
       0   gcode_M29()
       8   gcode_M30()
         8   -> CardReader::closefile(bool)
         0   -> CardReader::removeFile(char *)
       8   gcode_M300()
         8   -> Buzzer::tone(uint16_t const &, uint16_t const &)
         8   -> code_seen(char)
         8   -> code_value_ushort()
       8   gcode_M301()
         8   -> MarlinSerial::print(char const *)
         0   -> MarlinSerial::print(char, int)
         0   -> MarlinSerial::write(uint8_t)
         8   -> Temperature::updatePID()
         8   -> __aeabi_d2f
         8   -> __aeabi_ddiv
         8   -> __aeabi_dmul
         8   -> __aeabi_f2d
         8   -> code_seen(char)
         8   -> code_value_float()
         8   -> code_value_int()
         8   -> serial_echopair_P(char const *, double)
         8   -> serial_echopair_P(char const *, float)
         8   -> serialprintPGM(char const *)
      16   gcode_M302()
        16   -> __aeabi_d2iz
        16   -> __aeabi_dadd
        16   -> __aeabi_f2d
        16   -> __aeabi_i2f
        16   -> code_seen(char)
        16   -> code_value_bool()
        16   -> code_value_temp_abs()
        16   -> serial_echopair_P(char const *, char const *)
        16   -> serial_echopair_P(char const *, int)
         0   -> serialprintPGM(char const *)
        16   -> serialprintPGM(char const *)
        16 __aeabi_cfcmpeq
      24   gcode_M303()
        24   -> Temperature::PID_autotune(float, int, int, bool)
        24   -> __aeabi_i2f
        24   -> code_seen(char)
        24   -> code_value_bool()
        24   -> code_value_int()
        24   -> code_value_temp_abs()
         0   -> serialprintPGM(char const *)
        24   -> serialprintPGM(char const *)
       8   gcode_M304()
         0   -> MarlinSerial::print(char, int)
         0   -> MarlinSerial::write(uint8_t)
         8   -> Temperature::updatePID()
         8   -> __aeabi_d2f
         8   -> __aeabi_ddiv
         8   -> __aeabi_dmul
         8   -> __aeabi_f2d
         8   -> code_seen(char)
         8   -> code_value_float()
         8   -> serial_echopair_P(char const *, double)
         8   -> serial_echopair_P(char const *, float)
         8   -> serialprintPGM(char const *)
      40   gcode_M31()
        40   -> MarlinSerial::print(char, int)
        40   -> MarlinSerial::write(uint8_t)
        40   -> Stopwatch::duration()
        40   -> duration_t::duration_t(uint32_t const &)
        40   -> duration_t::toString(char *) const
        40   -> lcd_setstatus(char const *, bool)
        40   -> serial_echopair_P(char const *, char const *)
        40   -> serialprintPGM(char const *)
      24   gcode_M32()
        24   -> CardReader::openFile(char *, bool, bool)
        24   -> CardReader::setIndex(long)
        24   -> CardReader::startFileprint()
        24   -> Stepper::synchronize()
         0   -> Stopwatch::start()
        24   -> __iar_Strchr
        24   -> code_seen(char)
        24   -> code_value_long()
       8   gcode_M355()
         0   -> serialprintPGM(char const *)
         8   -> serialprintPGM(char const *)
       8   gcode_M360()
         0   -> SCARA_move_to_cal(uint8_t, uint8_t)
         8   -> serialprintPGM(char const *)
       8   gcode_M361()
         0   -> SCARA_move_to_cal(uint8_t, uint8_t)
         8   -> serialprintPGM(char const *)
       8   gcode_M362()
         0   -> SCARA_move_to_cal(uint8_t, uint8_t)
         8   -> serialprintPGM(char const *)
       8   gcode_M363()
         0   -> SCARA_move_to_cal(uint8_t, uint8_t)
         8   -> serialprintPGM(char const *)
       8   gcode_M364()
         0   -> SCARA_move_to_cal(uint8_t, uint8_t)
         8   -> serialprintPGM(char const *)
       0   gcode_M400()
         0   -> Stepper::synchronize()
       0   gcode_M401()
         0   -> set_probe_deployed(bool)
       0   gcode_M402()
         0   -> set_probe_deployed(bool)
       0   gcode_M410()
         0   -> quickstop_stepper()
      16   gcode_M42()
        16   -> HAL_GPIO_WritePin
        16   -> code_seen(char)
        16   -> code_value_int()
        16   -> pin_is_protected(uint8_t)
         0   -> serialprintPGM(char const *)
        16   -> serialprintPGM(char const *)
      24   gcode_M420()
         0   -> MarlinSerial::print(char, int)
        24   -> MarlinSerial::print(char, int)
         0   -> MarlinSerial::write(uint8_t)
        24   -> MarlinSerial::write(uint8_t)
        24   -> code_has_value()
        24   -> code_seen(char)
        24   -> code_value_bool()
        24   -> code_value_float()
        24   -> code_value_int()
        24   -> isnan(float)
        24   -> matrix_3x3::debug(char const *)
        24   -> mbl_mesh_report()
        24   -> mesh_bed_leveling::active()
        24   -> mesh_bed_leveling::has_mesh()
        24   -> print_bilinear_leveling_grid()
        24   -> serial_echopair_P(char const *, bool)
        24   -> serial_echopair_P(char const *, char const *)
        24   -> serial_echopair_P(char const *, int)
         0   -> serialprintPGM(char const *)
        24   -> serialprintPGM(char const *)
        24   -> set_bed_leveling_enabled(bool)
        24   -> set_z_fade_height(float)
        24   -> unified_bed_leveling::display_map(int)
        24   -> unified_bed_leveling::load_mesh(int16_t)
        24 __aeabi_cfcmpeq
      32   gcode_M421()
        32   -> __aeabi_f2iz
        32   -> code_seen(char)
        32   -> code_value_float()
         0   -> serialprintPGM(char const *)
        32   -> serialprintPGM(char const *)
      40   gcode_M421_MESH_BED_LEVELING()
        40   -> __aeabi_f2iz
        40   -> code_seen(char)
        40   -> code_value_float()
        40   -> mesh_bed_leveling::probe_index_x(float const &)
        40   -> mesh_bed_leveling::probe_index_y(float const &)
        40   -> mesh_bed_leveling::set_z(int8_t, int8_t, float const &)
        40   -> serialprintPGM(char const *)
      40   gcode_M428()
        40   -> Buzzer::tone(uint16_t const &, uint16_t const &)
        40   -> SYNC_PLAN_POSITION_KINEMATIC()
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_fadd
        40   -> __aeabi_fsub
        40   -> base_home_pos(AxisEnum)
        40   -> lcd_setalertstatuspgm(char const *)
        40   -> lcd_setstatuspgm(char const *, uint8_t)
        40   -> report_current_position()
        40   -> serialprintPGM(char const *)
        40   -> set_home_offset(AxisEnum, float)
        40 __aeabi_cdcmple
        40 __aeabi_cfcmple
        40 __aeabi_cfrcmple
       8   gcode_M49()
         0   -> serialprintPGM(char const *)
         8   -> serialprintPGM(char const *)
       0   gcode_M500()
         0   -> MarlinSettings::save()
       0   gcode_M501()
         0   -> MarlinSettings::load()
       0   gcode_M502()
         0   -> MarlinSettings::reset()
       8   gcode_M503()
         0   -> MarlinSettings::report(bool)
         8   -> code_seen(char)
         8   -> code_value_bool()
      64   gcode_M600()
        64   -> HAL_GetTick
        64   -> Planner::buffer_line_kinematic(float const *, float const &, uint8_t)
        64   -> Planner::set_e_position_mm(float const &)
        64   -> RUNPLAN(float)
        64   -> Stepper::synchronize()
        64   -> Stopwatch::isRunning()
        64   -> Stopwatch::pause()
        64   -> Stopwatch::start()
        64   -> Temperature::degHotend(uint8_t)
        64   -> Temperature::setTargetHotend(float, uint8_t)
        64   -> Temperature::tooColdToExtrude(uint8_t)
        64   -> __aeabi_fadd
        64   -> __aeabi_fdiv
        64   -> __aeabi_fsub
        64   -> __aeabi_i2f
        64   -> __aeabi_memcpy
        64   -> code_seen(char)
        64   -> code_value_float()
        64   -> disable_e_steppers()
        64   -> filament_change_beep(bool)
        64   -> idle(bool)
        64   -> lcd_filament_change_show_message(FilamentChangeMessage)
        64   -> safe_delay(millis_t)
        64   -> serialprintPGM(char const *)
        64   -> set_destination_to_current()
        64 __aeabi_cfcmple
        64 __aeabi_cfrcmple
      16   gcode_M665()
        16   -> __aeabi_fadd
        16   -> __aeabi_fsub
        16   -> code_seen(char)
        16   -> code_value_float()
         0   -> recalc_delta_settings(float, float)
        16   -> update_software_endstops(AxisEnum)
      16   gcode_M666()
        16   -> __aeabi_fsub
        16   -> code_seen(char)
        16   -> code_value_float()
        16 __aeabi_cfcmple
       0   gcode_M75()
         0   -> Stopwatch::start()
       0   gcode_M76()
         0   -> Stopwatch::pause()
       0   gcode_M77()
         0   -> Stopwatch::stop()
       8   gcode_M81()
         8   -> Stepper::finish_and_disable()
         8   -> Temperature::disable_all_heaters()
         0   -> lcd_setstatuspgm(char const *, uint8_t)
         8   -> safe_delay(millis_t)
       0   gcode_M82()
       0   gcode_M83()
       8   gcode_M85()
         8   -> code_seen(char)
         8   -> code_value_millis_from_seconds()
      16   gcode_M851()
         0   -> MarlinSerial::print(char, int)
        16   -> MarlinSerial::print(double, int)
         0   -> MarlinSerial::write(uint8_t)
        16   -> __aeabi_f2d
        16   -> code_seen(char)
        16   -> code_value_float()
        16   -> refresh_zprobe_zoffset(bool)
        16   -> serial_echopair_P(char const *, float)
        16   -> serialprintPGM(char const *)
        16 __aeabi_cfcmple
        16 __aeabi_cfrcmple
       0   gcode_M907()
      24   gcode_M92()
         0   -> Planner::refresh_positioning()
        24   -> __aeabi_f2uiz
        24   -> __aeabi_fdiv
        24   -> __aeabi_fmul
        24   -> __aeabi_ui2f
        24   -> code_seen(char)
        24   -> code_value_float()
        24 __aeabi_cfcmple
       0   gcode_M928()
         0   -> CardReader::openLogFile(char *)
       8   gcode_M999()
         0   -> FlushSerialRequestResend()
         8   -> code_seen(char)
         8   -> code_value_bool()
         8   -> lcd_reset_alert_level()
       0   gcode_T(uint8_t)
         0   -> tool_change(uint8_t, float, bool)
      16   gcode_get_destination()
        16   -> __aeabi_fadd
        16   -> __aeabi_fdiv
        16   -> code_seen(char)
        16   -> code_value_float()
        16 __aeabi_cfrcmple
      16   gcode_line_error(char const *, bool)
        16   -> FlushSerialRequestResend()
        16   -> MarlinSerial::print(char, int)
        16   -> MarlinSerial::print(long, int)
        16   -> MarlinSerial::write(uint8_t)
        16   -> serialprintPGM(char const *)
       8   get_available_commands()
         8   -> drain_injected_commands_P()
         0   -> get_sdcard_commands()
         8   -> get_serial_commands()
         8   -> get_wifi_commands()
      24   get_cartesian_from_steppers()
        24   -> Stepper::get_axis_position_degrees(AxisEnum)
        24   -> Stepper::get_axis_position_mm(AxisEnum)
        24   -> __aeabi_fadd
        24   -> forward_kinematics_DELTA(float, float, float)
        24   -> forward_kinematics_SCARA(float const &, float const &)
      32   get_homing_bump_feedrate(AxisEnum)
        32   -> __aeabi_fdiv
        32   -> __aeabi_i2f
        32   -> serialprintPGM(char const *)
      32   get_sdcard_commands()
        32   -> CardReader::checkautostart(bool)
        32   -> CardReader::eof()
        32   -> CardReader::get()
        32   -> CardReader::getsdpos()
        32   -> CardReader::printingHasFinished()
        32   -> _commit_command(bool)
        32   -> serialprintPGM(char const *)
      32   get_serial_commands()
        32   -> HAL_GetTick
        32   -> IsStopped()
        32   -> MarlinSerial::available()
        32   -> MarlinSerial::read()
        32   -> __iar_Strchr
        32   -> __iar_Strstr
        32   -> _enqueuecommand(char const *, bool)
         0   -> gcode_line_error(char const *, bool)
        32   -> kill(char const *)
        32   -> lcd_setstatuspgm(char const *, uint8_t)
        32   -> quickstop_stepper()
        32   -> serialprintPGM(char const *)
        32   -> strcmp
        32   -> strtol
      16   get_target_extruder_from_command(int)
        16   -> MarlinSerial::print(char, int)
        16   -> MarlinSerial::print(int, int)
        16   -> MarlinSerial::write(uint8_t)
        16   -> code_seen(char)
        16   -> code_value_byte()
        16   -> serial_echopair_P(char const *, uint8_t)
        16   -> serialprintPGM(char const *)
      24   get_wifi_commands()
        24   -> IsStopped()
        24   -> __iar_Strchr
        24   -> _enqueuecommand(char const *, bool)
        24   -> kill(char const *)
        24   -> lcd_setstatuspgm(char const *, uint8_t)
        24   -> quickstop_stepper()
        24   -> serialprintPGM(char const *)
        24   -> strcmp
        24   -> strtol
       8   handle_filament_runout()
         0   -> Stepper::synchronize()
         8   -> enqueue_and_echo_commands_P(char const *)
       0   home_all_axes()
         0   -> gcode_G28()
       0   home_bump_mm(AxisEnum)
       8   home_delta()
         8   -> Endstops::hit_on_purpose()
         0   -> SYNC_PLAN_POSITION_KINEMATIC()
         8   -> Stepper::synchronize()
         8   -> __aeabi_fadd
         8   -> __aeabi_fsub
         8   -> __aeabi_memset
         8   -> homeaxis(AxisEnum)
         8   -> line_to_current_position()
         8   -> set_axis_is_at_home(AxisEnum)
         8   -> sync_plan_position()
       0   home_dir(AxisEnum)
      32   homeaxis(AxisEnum)
        32   -> Buzzer::tone(uint16_t const &, uint16_t const &)
        32   -> SYNC_PLAN_POSITION_KINEMATIC()
        32   -> __aeabi_d2f
        32   -> __aeabi_dmul
        32   -> __aeabi_f2d
        32   -> __aeabi_fmul
        32   -> __aeabi_i2d
        32   -> __aeabi_i2f
        32   -> do_homing_move(AxisEnum, float, float)
        32   -> get_homing_bump_feedrate(AxisEnum)
        32   -> home_bump_mm(AxisEnum)
        32   -> home_dir(AxisEnum)
        32   -> max_length(AxisEnum)
        32   -> set_axis_is_at_home(AxisEnum)
        32   -> set_probe_deployed(bool)
        32   -> sync_plan_position()
        32 __aeabi_cfcmpeq
        32 __aeabi_cfcmple
      16   host_keepalive()
        16   -> HAL_GetTick
        16   -> serialprintPGM(char const *)
       8   idle(bool)
         8   -> BlinkLed()
         8   -> Buzzer::tick()
         8   -> GoHomeCheck()
         0   -> LoadFilament()
         8   -> PrintOneKey()
         8   -> Temperature::manage_heater()
         8   -> host_keepalive()
         8   -> lcd_update()
         8   -> manage_inactivity(bool)
         8   -> wifi_looping
      48   inverse_kinematics(float const *)
        48   -> __aeabi_fadd
        48   -> __aeabi_fmul
        48   -> __aeabi_fsub
        48   -> sqrtf
      40   inverse_kinematics_MORGAN_SCARA(float const *)
        40   -> __aeabi_d2f
        40   -> __aeabi_ddiv
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_fadd
        40   -> __aeabi_fdiv
        40   -> __aeabi_fmul
        40   -> __aeabi_fsub
        40   -> atan2f
        40   -> sqrtf
       0   isnan(float)
       8   kill(char const *)
         8   -> HAL_Delay
         8   -> Temperature::disable_all_heaters()
         8   -> disable_all_steppers()
         8   -> kill_screen(char const *)
         8   -> serialprintPGM(char const *)
         8   -> suicide()
       8   kill_c
         8   -> HAL_Delay
         8   -> Temperature::disable_all_heaters()
         8   -> disable_all_steppers()
         8   -> kill_screen(char const *)
         8   -> serialprintPGM(char const *)
         8   -> suicide()
      16   line_to_current_position()
        16   -> Planner::buffer_line(float, float, float, float const &, float const &, uint8_t)
       0   line_to_destination()
         0   -> line_to_destination(float)
      16   line_to_destination(float)
        16   -> Planner::buffer_line(float, float, float, float const &, float const &, uint8_t)
      16   loop
        16   -> CardReader::checkautostart(bool)
        16   -> CardReader::closefile(bool)
        16   -> CardReader::write_command(char *)
        16   -> Endstops::report_state()
        16   -> __iar_Strstr
        16   -> get_available_commands()
        16   -> idle(bool)
         0   -> mks_PrintStatePolling
        16   -> ok_to_send()
        16   -> process_next_command()
        16   -> serialprintPGM(char const *)
      16   manage_inactivity(bool)
        16   -> HAL_GPIO_ReadPin
        16   -> HAL_GPIO_WritePin
        16   -> HAL_GetTick
        16   -> MarlinSerial::print(char, int)
        16   -> MarlinSerial::write(uint8_t)
        16   -> Planner::blocks_queued()
         0   -> Planner::check_axes_activity()
        16   -> Stopwatch::isRunning()
        16   -> disable_e_steppers()
        16   -> get_available_commands()
        16   -> handle_filament_runout()
        16   -> kill(char const *)
        16   -> serial_echopair_P(char const *, char const *)
        16   -> serialprintPGM(char const *)
       0   max_length(AxisEnum)
       8   mbl_mesh_report()
         8   -> MarlinSerial::print(double, int)
         8   -> __aeabi_f2d
         0   -> print_2d_array(uint8_t, uint8_t, uint8_t, uint8_t)
         8   -> serialprintPGM(char const *)
       0   mesh_bed_leveling::active()
      40   mesh_bed_leveling::cell_index_x(float const &)
        40   -> __aeabi_d2iz
        40   -> __aeabi_ddiv
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_fadd
        40   -> __aeabi_fdiv
        40   -> __aeabi_fsub
        40   -> __aeabi_i2f
        40   -> __aeabi_ui2f
      40   mesh_bed_leveling::cell_index_y(float const &)
        40   -> __aeabi_d2iz
        40   -> __aeabi_ddiv
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_fadd
        40   -> __aeabi_fdiv
        40   -> __aeabi_fsub
        40   -> __aeabi_i2f
        40   -> __aeabi_ui2f
       0   mesh_bed_leveling::has_mesh()
      24   mesh_bed_leveling::probe_index_x(float const &)
        24   -> __aeabi_d2iz
        24   -> __aeabi_dadd
        24   -> __aeabi_ddiv
        24   -> __aeabi_dmul
        24   -> __aeabi_f2d
        24   -> __aeabi_fadd
        24   -> __aeabi_fdiv
        24   -> __aeabi_fsub
        24   -> __aeabi_i2f
        24   -> __aeabi_ui2f
      24   mesh_bed_leveling::probe_index_y(float const &)
        24   -> __aeabi_d2iz
        24   -> __aeabi_dadd
        24   -> __aeabi_ddiv
        24   -> __aeabi_dmul
        24   -> __aeabi_f2d
        24   -> __aeabi_fadd
        24   -> __aeabi_fdiv
        24   -> __aeabi_fsub
        24   -> __aeabi_i2f
        24   -> __aeabi_ui2f
       0   mesh_bed_leveling::set_active(bool)
       0   mesh_bed_leveling::set_has_mesh(bool)
       0   mesh_bed_leveling::set_z(int8_t, int8_t, float const &)
      16   mesh_bed_leveling::set_zigzag_z(int8_t, float const &)
        16   -> mesh_bed_leveling::set_z(int8_t, int8_t, float const &)
        16   -> mesh_bed_leveling::zigzag(int8_t, int8_t &, int8_t &)
       8   mesh_bed_leveling::zigzag(int8_t, int8_t &, int8_t &)
      56   mesh_line_to_destination(float, uint8_t, uint8_t)
        56   -> __aeabi_fadd
        56   -> __aeabi_fdiv
        56   -> __aeabi_fmul
        56   -> __aeabi_fsub
        56   -> __aeabi_memcpy
        56   -> line_to_destination(float)
        56   -> mesh_bed_leveling::cell_index_x(float const &)
        56   -> mesh_bed_leveling::cell_index_y(float const &)
        56   -> mesh_line_to_destination(float, uint8_t, uint8_t)
        56   -> set_current_to_destination()
       8   mesh_probing_done()
         8   -> home_all_axes()
         8   -> mesh_bed_leveling::set_has_mesh(bool)
         0   -> set_bed_leveling_enabled(bool)
      16   mks_G28(char *)
        16   -> __aeabi_memset
        16   -> code_seen(char)
        16   -> code_value_float()
        16   -> gcode_G28()
        16   -> set_bed_leveling_enabled(bool)
         0   -> set_z_fade_height(float)
        16   -> strcpy
      24   mks_PrintStatePolling
        24   -> __aeabi_fsub
        24   -> epr_write_data
        24   -> mks_clearFile
         0   -> mks_contiuePrintDelta
         0   -> mks_contiuePrintPause
         0   -> mks_contiuePrintPwdwn
        24   -> quick_pause()
        24 __aeabi_cfrcmple
       8   mks_ReadFromEpr
         0   -> epr_read_data
         8   -> epr_read_data
      16   mks_ReadFromFile
        16   -> CardReader::closefile(bool)
        16   -> CardReader::isFileOpen()
        16   -> CardReader::openFile(char *, bool, bool)
        16   -> mks_get_commands()
      24   mks_WriteToEpr()
        24   -> CardReader::getsdpos()
        24   -> HAL_GetTick
        24   -> Stopwatch::getTime(millis_t *, millis_t *, millis_t *)
         0   -> epr_write_data
        24   -> epr_write_data
      48   mks_WriteToFile
        48   -> CardReader::closefile(bool)
        48   -> CardReader::isFileOpen()
        48   -> CardReader::openFile(char *, bool, bool)
        48   -> CardReader::write_command(char *)
        48   -> HAL_GetTick
        48   -> Stopwatch::getTime(millis_t *, millis_t *, millis_t *)
        48   -> __aeabi_f2d
        48   -> __aeabi_memcpy4
        48   -> __aeabi_memset4
        48   -> sprintf
      40   mks_clearDir
        40   -> __iar_Strstr
        40   -> strcpy
      32   mks_clearFile
        32   -> CardReader::closefile(bool)
        32   -> CardReader::openFile(char *, bool, bool)
        32   -> CardReader::write_command(char *)
        32   -> __aeabi_memcpy4
      16   mks_contiuePrintDelta
        16   -> gcode_M24()
        16   -> lcd_setstatus(char const *, bool)
        16   -> mks_G28(char *)
        16   -> mks_moveXY
        16   -> mks_moveZ
        16   -> mks_preExtrude
        16   -> mks_setFeedrate()
        16   -> mks_setTemperature()
       8   mks_contiuePrintPause
         0   -> gcode_M24()
         8   -> lcd_setstatus(char const *, bool)
         8   -> mks_G28(char *)
         8   -> mks_moveXY
         8   -> mks_moveZ
         8   -> mks_preExtrude
         8   -> mks_setFeedrate()
         8   -> mks_setPositionZ
         8   -> mks_setTemperature()
      16   mks_contiuePrintPwdwn
        16   -> HAL_Delay
        16   -> gcode_M24()
        16   -> lcd_setstatus(char const *, bool)
        16   -> mks_G28(char *)
        16   -> mks_moveXY
        16   -> mks_moveZ
        16   -> mks_preExtrude
        16   -> mks_setFeedrate()
        16   -> mks_setPositionZ
        16   -> mks_setTemperature()
      16   mks_contiuePrint_UI
        16   -> CardReader::isFileOpen()
        16   -> CardReader::openFile(char *, bool, bool)
        16   -> CardReader::setIndex(long)
        16   -> HAL_SetTick
        16   -> Stopwatch::setTime(millis_t, millis_t, millis_t)
        16   -> epr_write_data
         0   -> lcd_setstatus(char const *, bool)
        16   -> lcd_setstatus(char const *, bool)
         0   -> mks_clearDir
        16   -> mks_getPositionXYZE()
      16   mks_getPositionXYZE()
        16   -> CardReader::setIndex(long)
        16   -> __aeabi_memset
         0   -> clear_command_queue()
        16   -> gcode_get_destination()
        16   -> get_sdcard_commands()
        16 __aeabi_cfcmple
        16 __aeabi_cfrcmple
      56   mks_get_commands()
        56   -> CardReader::eof()
        56   -> CardReader::get()
        56   -> __aeabi_d2f
        56   -> __aeabi_memset4
        56   -> atof
        56   -> atoi
        56   -> strcmp
      16   mks_initPrint
        16   -> __aeabi_memset4
      48   mks_moveXY
        48   -> Stepper::synchronize()
        48   -> __aeabi_f2d
        48   -> __aeabi_memcpy
        48   -> __aeabi_memset
        48   -> __aeabi_memset4
        48   -> gcode_G0_G1()
        48   -> sprintf
        48   -> strcat
      40   mks_moveZ
        40   -> Stepper::synchronize()
        40   -> __aeabi_f2d
        40   -> __aeabi_fadd
        40   -> __aeabi_memcpy
        40   -> __aeabi_memset
        40   -> __aeabi_memset4
        40   -> gcode_G0_G1()
        40   -> sprintf
        40   -> strcat
       8   mks_pausePrint
         8   -> Stepper::synchronize()
         0   -> lcd_setstatus(char const *, bool)
         8   -> mks_WriteToEpr()
         8   -> mks_moveXY
         8   -> mks_moveZ
         8   -> mks_preExtrude
         8   -> pause_file_offset()
      48   mks_preExtrude
        48   -> Stepper::synchronize()
        48   -> __aeabi_f2d
        48   -> __aeabi_memcpy
        48   -> __aeabi_memset
        48   -> __aeabi_memset4
        48   -> gcode_G0_G1()
        48   -> gcode_G92()
        48   -> sprintf
        48   -> strcat
      16   mks_rePrintCheck
        16   -> epr_read_data
         0   -> epr_write_data
        16   -> epr_write_data
         0   -> lcd_setstatus(char const *, bool)
        16   -> mks_ReadFromEpr
        16   -> mks_ReadFromFile
         0   -> mks_contiuePrint_UI
       8   mks_resumePrint
         8   -> lcd_setstatus(char const *, bool)
         8   -> mks_moveXY
         8   -> mks_moveZ
         8   -> mks_preExtrude
       0   mks_setFeedrate()
      32   mks_setPositionZ
        32   -> __aeabi_f2d
        32   -> __aeabi_memcpy
        32   -> __aeabi_memset
        32   -> __aeabi_memset4
        32   -> gcode_G92()
        32   -> sprintf
        32   -> strcat
      40   mks_setTemperature()
        40   -> __aeabi_memcpy
        40   -> __aeabi_memset
        40   -> gcode_M109()
        40   -> gcode_M140()
        40   -> gcode_M190()
        40   -> sprintf
        40   -> strcat
       8   ok_to_send()
         0   -> MarlinSerial::print(char, int)
         0   -> MarlinSerial::write(uint8_t)
         8   -> refresh_cmd_timeout()
         8   -> serialprintPGM(char const *)
       8   out_of_range_error(char const *)
         0   -> serialprintPGM(char const *)
         8   -> serialprintPGM(char const *)
      32   pause_file_offset()
        32   -> CardReader::eof()
        32   -> CardReader::get()
        32   -> CardReader::setIndex(long)
        32   -> __aeabi_memset
        32   -> strcmp
        32   -> strcpy
       0   pin_is_protected(uint8_t)
      96   plan_arc(float *, float *, uint8_t)
        96   -> HAL_GetTick
        96   -> Planner::buffer_line_kinematic(float const *, float const &, uint8_t)
        96   -> Temperature::manage_heater()
        96   -> __aeabi_d2f
        96   -> __aeabi_dadd
        96   -> __aeabi_dmul
        96   -> __aeabi_dsub
        96   -> __aeabi_f2d
        96   -> __aeabi_f2iz
        96   -> __aeabi_fadd
        96   -> __aeabi_fdiv
        96   -> __aeabi_fmul
        96   -> __aeabi_fsub
        96   -> __aeabi_i2f
        96   -> __aeabi_ui2f
        96   -> atan2f
        96   -> clamp_to_software_endstops(float *)
        96   -> cosf
        96   -> floorf
        96   -> idle(bool)
        96   -> set_current_to_destination()
        96   -> sinf
        96   -> sqrtf
        96 __aeabi_cfcmpeq
        96 __aeabi_cfcmple
      40   position_is_reachable(float const *, bool)
        40   -> __aeabi_dadd
        40   -> __aeabi_f2d
        40   -> __aeabi_fadd
        40   -> __aeabi_fmul
        40   -> __aeabi_fsub
        40 __aeabi_cdrcmple
        40 __aeabi_cfrcmple
     120   prepare_kinematic_move_to(float *)
       120   -> ADJUST_DELTA(float const *)
       120   -> Planner::buffer_line(float, float, float, float const &, float const &, uint8_t)
       120   -> Planner::buffer_line_kinematic(float const *, float const &, uint8_t)
       120   -> Stepper::get_axis_position_degrees(AxisEnum)
       120   -> __aeabi_d2f
       120   -> __aeabi_dmul
       120   -> __aeabi_f2d
       120   -> __aeabi_f2iz
       120   -> __aeabi_fadd
       120   -> __aeabi_fdiv
       120   -> __aeabi_fmul
       120   -> __aeabi_fsub
       120   -> __aeabi_i2f
       120   -> __aeabi_memcpy
       120   -> __aeabi_ui2f
       120   -> inverse_kinematics(float const *)
       120   -> inverse_kinematics_MORGAN_SCARA(float const *)
       120   -> sqrtf
       120 __aeabi_cfcmpeq
       120 __aeabi_cfcmple
       120 __aeabi_cfrcmple
      16   prepare_move_to_destination()
        16   -> Temperature::tooColdToExtrude(uint8_t)
        16   -> __aeabi_f2iz
        16   -> __aeabi_fsub
        16   -> clamp_to_software_endstops(float *)
        16   -> labs
        16   -> prepare_kinematic_move_to(float *)
        16   -> prepare_move_to_destination_cartesian()
        16   -> refresh_cmd_timeout()
        16   -> serialprintPGM(char const *)
         0   -> set_current_to_destination()
        16 __aeabi_cfcmpeq
      24   prepare_move_to_destination_cartesian()
        24   -> __aeabi_d2f
        24   -> __aeabi_dmul
        24   -> __aeabi_f2d
        24   -> __aeabi_fmul
        24   -> __aeabi_i2f
        24   -> bilinear_line_to_destination(float, uint16_t, uint16_t)
        24   -> line_to_destination()
        24   -> line_to_destination(float)
        24   -> mesh_bed_leveling::active()
        24   -> mesh_line_to_destination(float, uint8_t, uint8_t)
        24   -> ubl_line_to_destination(float const &, uint8_t)
        24 __aeabi_cfcmpeq
      16   prepare_uninterpolated_move_to_destination(float)
        16   -> Planner::buffer_line_kinematic(float const *, float const &, uint8_t)
        16   -> __aeabi_d2f
        16   -> __aeabi_dmul
        16   -> __aeabi_f2d
        16   -> __aeabi_fmul
        16   -> __aeabi_i2f
        16   -> refresh_cmd_timeout()
        16   -> set_current_to_destination()
        16 __aeabi_cfcmpeq
      40   print_2d_array(uint8_t, uint8_t, uint8_t, uint8_t)
         0   -> MarlinSerial::print(char, int)
        40   -> MarlinSerial::print(char, int)
        40   -> MarlinSerial::print(double, int)
        40   -> MarlinSerial::print(int, int)
         0   -> MarlinSerial::write(uint8_t)
        40   -> MarlinSerial::write(uint8_t)
        40   -> __aeabi_f2d
        40   -> isnan(float)
        40 __aeabi_cfrcmple
       8   print_bilinear_leveling_grid()
         0   -> print_2d_array(uint8_t, uint8_t, uint8_t, uint8_t)
         8   -> serialprintPGM(char const *)
      32   print_heaterstates()
        32   -> MarlinSerial::print(double, int)
         0   -> MarlinSerial::print(int, int)
        32   -> MarlinSerial::print(int, int)
        32   -> Temperature::degBed()
        32   -> Temperature::degHotend(uint8_t)
        32   -> Temperature::degTargetBed()
        32   -> Temperature::degTargetHotend(uint8_t)
        32   -> Temperature::getHeaterPower(int)
        32   -> __aeabi_f2d
        32   -> serialprintPGM(char const *)
      48   probe_pt(float, float, bool, int)
        48   -> MarlinSerial::print(char, int)
        48   -> MarlinSerial::print(double, int)
        48   -> MarlinSerial::write(uint8_t)
        48   -> __aeabi_f2d
        48   -> __aeabi_fsub
        48   -> do_blocking_move_to_xy(float const &, float const &, float const &)
        48   -> do_blocking_move_to_z(float const &, float const &)
        48   -> do_probe_raise(float)
        48   -> run_z_probe()
        48   -> serialprintPGM(char const *)
        48   -> set_probe_deployed(bool)
        48 __aeabi_cfcmple
      24   process_next_command()
        24   -> MarlinSerial::print(char const *)
        24   -> MarlinSerial::print(char, int)
        24   -> MarlinSerial::write(uint8_t)
        24   -> MarlinSettings::save()
        24   -> __aeabi_memset
        24   -> __aeabi_memset4
        24   -> __iar_Strchr
        24   -> __iar_Strstr
        24   -> code_seen(char)
        24   -> code_value_float()
        24   -> epr_write_data
        24   -> gcode_G0_G1()
        24   -> gcode_G0_G1_SCARA(bool)
        24   -> gcode_G26()
        24   -> gcode_G28()
        24   -> gcode_G29()
        24   -> gcode_G29_MESH_BED_LEVELING()
        24   -> gcode_G29_UBL()
        24   -> gcode_G2_G3(bool)
        24   -> gcode_G30()
        24   -> gcode_G4()
        24   -> gcode_G92()
        24   -> gcode_M0_M1()
        24   -> gcode_M104()
        24   -> gcode_M105()
        24   -> gcode_M106()
        24   -> gcode_M107()
        24   -> gcode_M108()
        24   -> gcode_M109()
        24   -> gcode_M110()
        24   -> gcode_M111()
        24   -> gcode_M112()
        24   -> gcode_M113()
        24   -> gcode_M114()
        24   -> gcode_M115()
        24   -> gcode_M117()
        24   -> gcode_M119()
        24   -> gcode_M120()
        24   -> gcode_M121()
        24   -> gcode_M140()
        24   -> gcode_M145()
        24   -> gcode_M17()
        24   -> gcode_M18_M84()
        24   -> gcode_M190()
        24   -> gcode_M20()
        24   -> gcode_M200()
        24   -> gcode_M201()
        24   -> gcode_M203()
        24   -> gcode_M204()
        24   -> gcode_M205()
        24   -> gcode_M206()
        24   -> gcode_M21()
        24   -> gcode_M211()
        24   -> gcode_M22()
        24   -> gcode_M220()
        24   -> gcode_M221()
        24   -> gcode_M226()
        24   -> gcode_M23()
        24   -> gcode_M24()
        24   -> gcode_M25()
        24   -> gcode_M26()
        24   -> gcode_M27()
        24   -> gcode_M28()
        24   -> gcode_M29()
        24   -> gcode_M30()
        24   -> gcode_M300()
        24   -> gcode_M301()
        24   -> gcode_M302()
        24   -> gcode_M303()
        24   -> gcode_M304()
        24   -> gcode_M31()
        24   -> gcode_M32()
        24   -> gcode_M355()
        24   -> gcode_M360()
        24   -> gcode_M361()
        24   -> gcode_M362()
        24   -> gcode_M363()
        24   -> gcode_M364()
        24   -> gcode_M400()
        24   -> gcode_M401()
        24   -> gcode_M402()
        24   -> gcode_M410()
        24   -> gcode_M42()
        24   -> gcode_M420()
        24   -> gcode_M421()
        24   -> gcode_M421_MESH_BED_LEVELING()
        24   -> gcode_M428()
        24   -> gcode_M49()
        24   -> gcode_M500()
        24   -> gcode_M501()
        24   -> gcode_M502()
        24   -> gcode_M503()
        24   -> gcode_M600()
        24   -> gcode_M665()
        24   -> gcode_M666()
        24   -> gcode_M75()
        24   -> gcode_M76()
        24   -> gcode_M77()
        24   -> gcode_M81()
        24   -> gcode_M82()
        24   -> gcode_M83()
        24   -> gcode_M85()
        24   -> gcode_M851()
        24   -> gcode_M907()
        24   -> gcode_M92()
        24   -> gcode_M928()
        24   -> gcode_M999()
        24   -> gcode_T(uint8_t)
        24   -> mks_clearDir
        24   -> mks_clearFile
         0   -> ok_to_send()
        24   -> serialprintPGM(char const *)
        24   -> set_bed_leveling_enabled(bool)
        24   -> set_z_fade_height(float)
        24   -> strcat
        24   -> strcpy
        24   -> unknown_command_error()
      48   quick_home_xy()
        48   -> Endstops::hit_on_purpose()
        48   -> __aeabi_d2f
        48   -> __aeabi_dadd
        48   -> __aeabi_dmul
        48   -> __aeabi_f2d
        48   -> __aeabi_fdiv
        48   -> __aeabi_fmul
        48   -> __aeabi_i2d
        48   -> do_blocking_move_to_xy(float const &, float const &, float const &)
        48   -> home_dir(AxisEnum)
        48   -> max_length(AxisEnum)
        48   -> sqrt
        48   -> sync_plan_position()
        48 __aeabi_cfcmple
      16   quick_pause()
        16   -> HAL_TIM_Base_Start_IT
        16   -> HAL_TIM_Base_Stop_IT
        16   -> Planner::blocks_queued()
        16   -> Planner::discard_current_block()
        16   -> SYNC_PLAN_POSITION_KINEMATIC()
        16   -> epr_write_data
        16   -> find_pause_e_pos()
         0   -> mks_pausePrint
        16   -> set_current_from_steppers_for_axis(AxisEnum)
       8   quickstop_stepper()
         0   -> SYNC_PLAN_POSITION_KINEMATIC()
         8   -> Stepper::quick_stop()
         8   -> Stepper::synchronize()
         8   -> set_current_from_steppers_for_axis(AxisEnum)
      40   recalc_delta_settings(float, float)
        40   -> __aeabi_d2f
        40   -> __aeabi_ddiv
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_fadd
        40   -> __aeabi_fmul
        40   -> cos
        40   -> sin
       8   refresh_bed_level()
         8   -> __aeabi_d2f
         8   -> __aeabi_ddiv
         8   -> __aeabi_i2d
       8   refresh_cmd_timeout()
         8   -> HAL_GetTick
      40   refresh_zprobe_zoffset(bool)
        40   -> __aeabi_fsub
        40   -> isnan(float)
        40 __aeabi_cfcmpeq
      24   report_current_position()
         0   -> MarlinSerial::print(char, int)
        24   -> MarlinSerial::print(char, int)
        24   -> MarlinSerial::print(double, int)
         0   -> MarlinSerial::write(uint8_t)
        24   -> MarlinSerial::write(uint8_t)
        24   -> Stepper::get_axis_position_degrees(AxisEnum)
        24   -> Stepper::report_positions()
        24   -> __aeabi_f2d
        24   -> serial_echopair_P(char const *, float)
        24   -> serialprintPGM(char const *)
      16   reset_bed_level()
         0   -> matrix_3x3::set_to_identity()
        16   -> mesh_bed_leveling::has_mesh()
        16   -> mesh_bed_leveling::reset()
         0   -> mesh_bed_leveling::set_has_mesh(bool)
        16   -> set_bed_leveling_enabled(bool)
         0   -> unified_bed_leveling::reset()
      32   run_z_probe()
        32   -> __aeabi_fadd
        32   -> __aeabi_fdiv
        32   -> __aeabi_fsub
        32   -> do_blocking_move_to_z(float const &, float const &)
        32   -> do_probe_move(float, float)
        32   -> refresh_cmd_timeout()
        32 __aeabi_cfcmple
       0   say_not_entered()
         0   -> serialprintPGM(char const *)
       0   serial_echopair_P(char const *, bool)
         0   -> serial_echopair_P(char const *, int)
       0   serial_echopair_P(char const *, uint8_t)
         0   -> serial_echopair_P(char const *, int)
       0   serialprintPGM(char const *)
         0   -> MarlinSerial::print(char const *)
         0   -> MarlinSerial::write(char const *)
       0   servo_init()
      48   set_axis_is_at_home(AxisEnum)
        48   -> __aeabi_fadd
        48   -> __aeabi_fsub
        48   -> base_home_pos(AxisEnum)
        48   -> base_max_pos(AxisEnum)
        48   -> base_min_pos(AxisEnum)
        48   -> forward_kinematics_SCARA(float const &, float const &)
        48   -> inverse_kinematics_MORGAN_SCARA(float const *)
        48   -> serialprintPGM(char const *)
        48   -> update_software_endstops(AxisEnum)
      16   set_bed_leveling_enabled(bool)
        16   -> Planner::apply_leveling(float &, float &, float &)
         0   -> Planner::unapply_leveling(float *)
        16   -> bilinear_z_offset(float const *)
        16   -> mesh_bed_leveling::active()
        16   -> mesh_bed_leveling::has_mesh()
        16   -> mesh_bed_leveling::set_active(bool)
         0   -> set_current_from_steppers_for_axis(AxisEnum)
      16   set_current_from_steppers_for_axis(AxisEnum)
        16   -> Planner::unapply_leveling(float *)
         0   -> __aeabi_memcpy
        16   -> get_cartesian_from_steppers()
       0   set_current_to_destination()
         0   -> __aeabi_memcpy
       0   set_destination_to_current()
         0   -> __aeabi_memcpy
      16   set_home_offset(AxisEnum, float)
        16   -> __aeabi_fadd
        16   -> __aeabi_fsub
         0   -> update_software_endstops(AxisEnum)
      24   set_probe_deployed(bool)
        24   -> Endstops::enable_z_probe(bool)
        24   -> do_blocking_move_to(float const &, float const &, float const &, float const &)
        24   -> do_probe_raise(float)
        24 __aeabi_cfcmple
       8   set_z_fade_height(float)
         8   -> __aeabi_fdiv
         8   -> mesh_bed_leveling::active()
         0   -> set_current_from_steppers_for_axis(AxisEnum)
         8 __aeabi_cfcmple
         8 __aeabi_cfrcmple
      16   setup
        16   -> Endstops::enable_z_probe(bool)
        16   -> MarlinSerial::print(char, int)
        16   -> MarlinSerial::write(uint8_t)
        16   -> MarlinSettings::load()
        16   -> SYNC_PLAN_POSITION_KINEMATIC()
        16   -> Stepper::init()
        16   -> Temperature::init()
        16   -> __aeabi_memcpy
        16   -> __aeabi_memset
        16   -> freeMemory()
        16   -> lcd_init()
        16   -> safe_delay(millis_t)
        16   -> serial_echopair_P(char const *, int)
        16   -> serialprintPGM(char const *)
        16   -> servo_init()
        16   -> setup_filrunoutpin()
        16   -> setup_homepin()
        16   -> setup_killpin()
       0   setup_filrunoutpin()
       0   setup_for_endstop_or_probe_move()
         0   -> refresh_cmd_timeout()
       0   setup_homepin()
       0   setup_killpin()
       0   setup_powerhold()
       8   stop()
         8   -> IsRunning()
         8   -> Temperature::disable_all_heaters()
         8   -> lcd_setstatuspgm(char const *, uint8_t)
         8   -> safe_delay(millis_t)
         8   -> serialprintPGM(char const *)
       0   suicide()
       0   sync_plan_position()
         0   -> Planner::set_position_mm(float, float, float, float const &)
       0   sync_plan_position_e()
         0   -> Planner::set_e_position_mm(float const &)
       0   sync_plan_position_kinematic()
         0   -> Planner::set_position_mm_kinematic(float const *)
       8   tool_change(uint8_t, float, bool)
         0   -> MarlinSerial::print(char, int)
         0   -> MarlinSerial::write(uint8_t)
         8   -> serial_echopair_P(char const *, int)
         8   -> serialprintPGM(char const *)
       8   unknown_command_error()
         0   -> MarlinSerial::print(char, int)
         8   -> MarlinSerial::print(char, int)
         0   -> MarlinSerial::write(uint8_t)
         8   -> MarlinSerial::write(uint8_t)
         8   -> serial_echopair_P(char const *, char const *)
         8   -> serialprintPGM(char const *)
      24   update_software_endstops(AxisEnum)
        24   -> __aeabi_fadd
        24   -> __aeabi_fsub
        24   -> base_max_pos(AxisEnum)
        24   -> base_min_pos(AxisEnum)
        24   -> delta_safe_distance_from_top()


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable112
       4  ??DataTable112_1
       4  ??DataTable112_2
       4  ??DataTable112_3
       4  ??DataTable113
       4  ??DataTable113_1
       4  ??DataTable113_2
       4  ??DataTable113_3
       4  ??DataTable113_4
       4  ??DataTable113_5
       4  ??DataTable113_6
       4  ??DataTable113_7
       4  ??DataTable113_8
       4  ??DataTable113_9
       4  ??DataTable115
       4  ??DataTable116
       4  ??DataTable116_1
       4  ??DataTable116_2
       4  ??DataTable116_3
       4  ??DataTable116_4
       4  ??DataTable116_5
       4  ??DataTable116_6
       4  ??DataTable116_7
       4  ??DataTable120
       4  ??DataTable121
       4  ??DataTable122
       4  ??DataTable123
       4  ??DataTable123_1
       4  ??DataTable126
       4  ??DataTable126_1
       4  ??DataTable126_2
       4  ??DataTable126_3
       4  ??DataTable126_4
       4  ??DataTable126_5
       4  ??DataTable126_6
       4  ??DataTable126_7
       4  ??DataTable126_8
       4  ??DataTable127
       4  ??DataTable127_1
       4  ??DataTable127_2
       4  ??DataTable127_3
       4  ??DataTable128
       4  ??DataTable129
       4  ??DataTable129_1
       4  ??DataTable130
       4  ??DataTable131
       4  ??DataTable131_1
       4  ??DataTable132
       4  ??DataTable133
       4  ??DataTable133_1
       4  ??DataTable133_2
       4  ??DataTable133_3
       4  ??DataTable133_4
       4  ??DataTable133_5
       4  ??DataTable134
       4  ??DataTable135
       4  ??DataTable135_1
       4  ??DataTable135_2
       4  ??DataTable136
       4  ??DataTable136_1
       4  ??DataTable136_10
       4  ??DataTable136_11
       4  ??DataTable136_12
       4  ??DataTable136_13
       4  ??DataTable136_14
       4  ??DataTable136_15
       4  ??DataTable136_16
       4  ??DataTable136_17
       4  ??DataTable136_2
       4  ??DataTable136_3
       4  ??DataTable136_4
       4  ??DataTable136_5
       4  ??DataTable136_6
       4  ??DataTable136_7
       4  ??DataTable136_8
       4  ??DataTable136_9
       4  ??DataTable139
       4  ??DataTable139_1
       4  ??DataTable139_2
       4  ??DataTable139_3
       4  ??DataTable140
       4  ??DataTable140_1
       4  ??DataTable140_2
       4  ??DataTable140_3
       4  ??DataTable140_4
       4  ??DataTable140_5
       4  ??DataTable140_6
       4  ??DataTable140_7
       4  ??DataTable141
       4  ??DataTable141_1
       4  ??DataTable145
       4  ??DataTable146
       4  ??DataTable147
       4  ??DataTable147_1
       4  ??DataTable147_2
       4  ??DataTable147_3
       4  ??DataTable148
       4  ??DataTable148_1
       4  ??DataTable148_2
       4  ??DataTable149
       4  ??DataTable149_1
       4  ??DataTable149_2
       4  ??DataTable149_3
       4  ??DataTable153
       4  ??DataTable157
       4  ??DataTable158
       4  ??DataTable160
       4  ??DataTable163
       4  ??DataTable163_1
       4  ??DataTable163_2
       4  ??DataTable166
       4  ??DataTable166_1
       4  ??DataTable166_2
       4  ??DataTable166_3
       4  ??DataTable166_4
       4  ??DataTable166_5
       4  ??DataTable166_6
       4  ??DataTable167
       4  ??DataTable167_1
       4  ??DataTable167_2
       4  ??DataTable168
       4  ??DataTable169
       4  ??DataTable169_1
       4  ??DataTable169_2
       4  ??DataTable169_3
       4  ??DataTable169_4
       4  ??DataTable169_5
       4  ??DataTable169_6
       4  ??DataTable169_7
       4  ??DataTable170
       4  ??DataTable170_1
       4  ??DataTable171
       4  ??DataTable171_1
       4  ??DataTable172
       4  ??DataTable173
       4  ??DataTable173_1
       4  ??DataTable173_2
       4  ??DataTable173_3
       4  ??DataTable173_4
       4  ??DataTable174
       4  ??DataTable174_1
       4  ??DataTable174_2
       4  ??DataTable174_3
       4  ??DataTable174_4
       4  ??DataTable174_5
       4  ??DataTable175
       4  ??DataTable175_1
       4  ??DataTable177
       4  ??DataTable178
       4  ??DataTable178_1
       4  ??DataTable179
       4  ??DataTable180
       4  ??DataTable180_1
       4  ??DataTable182
       4  ??DataTable183
       4  ??DataTable183_1
       4  ??DataTable183_2
       4  ??DataTable184
       4  ??DataTable184_1
       4  ??DataTable184_2
       4  ??DataTable184_3
       4  ??DataTable186
       4  ??DataTable188
       4  ??DataTable189
       4  ??DataTable189_1
       4  ??DataTable192
       4  ??DataTable192_1
       4  ??DataTable192_10
       4  ??DataTable192_11
       4  ??DataTable192_12
       4  ??DataTable192_13
       4  ??DataTable192_14
       4  ??DataTable192_15
       4  ??DataTable192_16
       4  ??DataTable192_17
       4  ??DataTable192_18
       4  ??DataTable192_19
       4  ??DataTable192_2
       4  ??DataTable192_3
       4  ??DataTable192_4
       4  ??DataTable192_5
       4  ??DataTable192_6
       4  ??DataTable192_7
       4  ??DataTable192_8
       4  ??DataTable192_9
      16  ?_0
      20  ?_1
       8  ?_10
       8  ?_11
       8  ?_12
      28  ?_13
      20  ?_14
      20  ?_15
      24  ?_16
      24  ?_17
       8  ?_18
      28  ?_19
      52  ?_2
      16  ?_20
      60  ?_21
      12  ?_22
      20  ?_23
       4  ?_24
       4  ?_25
       4  ?_26
       4  ?_27
       8  ?_28
       4  ?_29
       8  ?_3
       4  ?_30
       4  ?_31
       4  ?_32
      16  ?_33
      16  ?_34
      20  ?_35
      32  ?_36
       2  ?_37
      20  ?_38
      12  ?_39
       2  ?_4
       4  ?_40
      28  ?_41
      32  ?_42
       8  ?_43
      60  ?_44
      12  ?_45
      32  ?_46
     120  ?_47
      12  ?_48
       8  ?_49
       2  ?_5
       4  ?_50
      16  ?_51
      20  ?_52
      36  ?_53
      24  ?_54
      16  ?_55
      24  ?_56
       4  ?_57
      20  ?_58
       8  ?_59
       2  ?_6
       4  ?_60
       8  ?_61
       8  ?_62
       8  ?_63
       4  ?_64
       8  ?_65
       8  ?_66
       8  ?_67
       4  ?_68
       8  ?_69
       8  ?_7
      12  ?_70
       4  ?_71
      16  ?_72
      24  ?_73
      12  ?_74
       8  ?_75
       4  ?_76
      20  ?_77
       8  ?_78
      12  ?_79
      20  ?_8
       1  ?_9
      88  ADJUST_DELTA(float const *)
      32  Buzzer::Buzzer()
      28  Buzzer::off()
      28  Buzzer::on()
      14  Buzzer::reset()
      76  Buzzer::tick()
      58  Buzzer::tone(uint16_t const &, uint16_t const &)
      16  CardReader::eof()
      26  CardReader::get()
       8  CardReader::isFileOpen()
       6  CardReader::lastOpenOk()
       6  CardReader::pauseSDPrint()
      10  CardReader::setIndex(long)
      52  CardReader::~CardReader()
      14  CircularQueue<tone_t, (uint8_t)'\004'>::CircularQueue()
      62  CircularQueue<tone_t, (uint8_t)'\004'>::dequeue()
      56  CircularQueue<tone_t, (uint8_t)'\004'>::enqueue(tone_t const &)
      10  CircularQueue<tone_t, (uint8_t)'\004'>::isEmpty()
      16  CircularQueue<tone_t, (uint8_t)'\004'>::isFull()
      16  DATA_REPRINT_ITMES::<_ZN18DATA_REPRINT_ITMESC1Ev>()
      16  DATA_REPRINT_ITMES::~<unnamed>()
      12  Endstops::enable(bool)
      20  Endstops::enable_globally(bool)
      12  Endstops::enable_z_probe(bool)
      12  Endstops::hit_on_purpose()
      20  Endstops::not_homing()
      80  FlushSerialRequestResend()
      12  IsRunning()
      16  IsStopped()
       4  MarlinSerial::available()
      64  MarlinSerial::print(char const *)
      28  MarlinSerial::write(char const *)
      12  MarlinSerial::write(uint8_t)
      10  Planner::apply_leveling(float *)
      28  Planner::blocks_queued()
      64  Planner::buffer_line(float, float, float, float const &, float const &, uint8_t)
     136  Planner::buffer_line_kinematic(float const *, float const &, uint8_t)
      28  Planner::discard_current_block()
       8  Planner::set_e_position_mm(float const &)
      52  Planner::set_position_mm(float, float, float, float const &)
      42  RUNPLAN(float)
      76  Running
          gridx
          gridy
          nextx
          nexty
          last_gridx
          last_gridy
          bilinear_grid_spacing
          bilinear_start
          bilinear_grid_factor
          Stopped_gcode_LastN
          z1
          d2
          z3
          d4
          L
          D
          ratio_x
          ratio_y
          last_x
          last_y
      80  SCARA_move_to_cal(uint8_t, uint8_t)
      24  SYNC_PLAN_POSITION_KINEMATIC()
       4  SdBaseFile::curPosition() const
      12  SdBaseFile::isOpen() const
       4  SdBaseFile::subobject ~SdBaseFile()
      22  SdBaseFile::~SdBaseFile()
      16  SdFile::~SdFile()
       4  Stepper::get_axis_position_degrees(AxisEnum)
      12  Temperature::degBed()
      12  Temperature::degHotend(uint8_t)
      12  Temperature::degTargetBed()
      12  Temperature::degTargetHotend(uint8_t)
      36  Temperature::isCoolingBed()
      36  Temperature::isCoolingHotend(uint8_t)
      24  Temperature::setTargetBed(float)
      24  Temperature::setTargetHotend(float, uint8_t)
      48  Temperature::tooColdToExtrude(uint8_t)
     318  __sti__routine()
      36  _commit_command(bool)
      60  _enqueuecommand(char const *, bool)
     148  _manual_goto_xy(float const &, float const &)
       4  axis_codes
      96  axis_homed
          delta_tower
          delta_diagonal_rod_2_tower
          cartes
          delta_tower_angle_trim
          position_shift
          zprobe_zoffset
          delta_radius
          delta_diagonal_rod
          delta_calibration_radius
          delta_segments_per_second
          last_zoffset
     168  axis_relative_modes
          axis_known_position
          commands_in_queue
          cmd_queue_index_r
          cmd_queue_index_w
          cmd_queue_index_r_bak
          relative_mode
          filament_ran_out
          serial_wait_tick
          busy_doing_M600
          cmd_id_bak
          cmd_id_bak_temp
          sd_comment_mode
          send_ok
          read_cnt
          filament_change_menu_response
          gcode_N
          gcode_LastN
          current_command
          current_command_args
          seen_pointer
          serial_count
          wifi_read_count
          previous_cmd_ms
          max_inactive_time
          stepper_inactive_time
          cmd_length
          command_queue_bak_end
     174  axis_unhomed_error(bool, bool, bool)
      12  base_home_pos(AxisEnum)
      12  base_max_pos(AxisEnum)
      12  base_min_pos(AxisEnum)
     606  bilinear_line_to_destination(float, uint16_t, uint16_t)
     488  bilinear_z_offset(float const *)
     144  calculate_volumetric_multiplier(float)
      26  calculate_volumetric_multipliers()
     800  card
     108  clamp_to_software_endstops(float *)
      18  clean_up_after_endstop_or_probe_move()
      14  clear_command_queue()
      56  code_has_value()
      28  code_seen(char)
      28  code_value_bool()
      68  code_value_byte()
      60  code_value_float()
      20  code_value_int()
      20  code_value_long()
       4  code_value_millis()
      24  code_value_millis_from_seconds()
      10  code_value_temp_abs()
      10  code_value_temp_diff()
      20  code_value_ulong()
      24  code_value_ushort()
     384  command_queue
      20  debug_strings
      94  delta_safe_distance_from_top()
      62  disable_all_steppers()
      18  disable_e_steppers()
     408  do_blocking_move_to(float const &, float const &, float const &, float const &)
      12  do_blocking_move_to_x(float const &, float const &)
       8  do_blocking_move_to_xy(float const &, float const &, float const &)
      14  do_blocking_move_to_z(float const &, float const &)
     154  do_homing_move(AxisEnum, float, float)
      48  do_probe_move(float, float)
      96  do_probe_raise(float)
      88  drain_injected_commands_P()
      16  duration_t::day() const
       6  duration_t::duration_t(uint32_t const &)
      14  duration_t::hour() const
      14  duration_t::minute() const
       4  duration_t::second() const
     216  duration_t::toString(char *) const
      18  duration_t::year() const
      54  enable_all_steppers()
       1  enable_soft_endstops
      12  endstop_adj
     102  enqueue_and_echo_command(char const *, bool)
       8  enqueue_and_echo_commands_P(char const *)
     278  extrapolate_one_point(uint8_t, uint8_t, int8_t, int8_t)
     182  extrapolate_unprobed_bed_level()
       4  fanSpeeds
      88  filament_change_beep(bool)
     176  find_pause_e_pos()
       4  flow_percentage
       8  forward_kinematics_DELTA(float *)
    1054  forward_kinematics_DELTA(float, float, float)
     238  forward_kinematics_SCARA(float const &, float const &)
       6  freeMemory()
      24  gcode_G0_G1()
      40  gcode_G0_G1_SCARA(bool)
     360  gcode_G28()
    4104  gcode_G29()
     724  gcode_G29_MESH_BED_LEVELING()
     600  gcode_G2_G3(bool)
     304  gcode_G30()
      92  gcode_G4()
     160  gcode_G92()
     220  gcode_M0_M1()
     248  gcode_M104()
      76  gcode_M105()
      80  gcode_M106()
      44  gcode_M107()
      12  gcode_M108()
     644  gcode_M109()
      28  gcode_M110()
     180  gcode_M111()
      12  gcode_M112()
     104  gcode_M113()
      14  gcode_M114()
      12  gcode_M115()
      40  gcode_M117()
       4  gcode_M119()
       6  gcode_M120()
       6  gcode_M121()
      44  gcode_M140()
     196  gcode_M145()
      24  gcode_M17()
     208  gcode_M18_M84()
     472  gcode_M190()
      36  gcode_M20()
     112  gcode_M200()
      56  gcode_M201()
      48  gcode_M203()
     272  gcode_M204()
     148  gcode_M205()
     124  gcode_M206()
      12  gcode_M21()
     200  gcode_M211()
      12  gcode_M22()
      28  gcode_M220()
      48  gcode_M221()
     160  gcode_M226()
     112  gcode_M23()
      44  gcode_M24()
      36  gcode_M25()
      44  gcode_M26()
      12  gcode_M27()
      24  gcode_M28()
       2  gcode_M29()
      44  gcode_M30()
      88  gcode_M300()
     332  gcode_M301()
     192  gcode_M302()
     176  gcode_M303()
     240  gcode_M304()
     104  gcode_M31()
     136  gcode_M32()
      28  gcode_M355()
      24  gcode_M360()
      24  gcode_M361()
      24  gcode_M362()
      24  gcode_M363()
      24  gcode_M364()
       4  gcode_M400()
       6  gcode_M401()
       6  gcode_M402()
       4  gcode_M410()
     144  gcode_M42()
     636  gcode_M420()
     208  gcode_M421()
     264  gcode_M421_MESH_BED_LEVELING()
     328  gcode_M428()
      80  gcode_M49()
       4  gcode_M500()
       4  gcode_M501()
       4  gcode_M502()
      34  gcode_M503()
     964  gcode_M600()
     232  gcode_M665()
     124  gcode_M666()
      12  gcode_M75()
      12  gcode_M76()
      12  gcode_M77()
      84  gcode_M81()
      12  gcode_M82()
      12  gcode_M83()
      28  gcode_M85()
     196  gcode_M851()
       2  gcode_M907()
     164  gcode_M92()
      20  gcode_M928()
      44  gcode_M999()
       8  gcode_T(uint8_t)
     110  gcode_get_destination()
     102  gcode_line_error(char const *, bool)
      28  get_available_commands()
     172  get_cartesian_from_steppers()
     100  get_homing_bump_feedrate(AxisEnum)
     328  get_sdcard_commands()
     588  get_serial_commands()
     160  get_target_extruder_from_command(int)
     288  get_wifi_commands()
      34  handle_filament_runout()
       4  home_all_axes()
      10  home_bump_mm(AxisEnum)
      12  home_bump_mm_P
     120  home_delta()
       8  home_dir(AxisEnum)
      88  home_dir_P
          base_min_pos_P
          base_max_pos_P
          base_home_pos_P
          max_length_P
          L1_2
          L1_2_2
          L2_2
          C2
          S2
          SK1
          SK2
          THETA
          PSI
     436  homeaxis(AxisEnum)
     114  host_keepalive()
       8  host_keepalive_interval
          next_busy_signal_ms
      54  idle(bool)
       4  injected_commands_P
     398  inverse_kinematics(float const *)
     380  inverse_kinematics_MORGAN_SCARA(float const *)
      26  isnan(float)
      60  kill(char const *)
      60  kill_c
       4  last_wait_time
      36  line_to_current_position()
      12  line_to_destination()
      36  line_to_destination(float)
     170  loop
     246  manage_inactivity(bool)
      12  max_length(AxisEnum)
      96  mbl_mesh_report()
       4  mbl_probe_index
      16  mesh_bed_leveling::active()
     144  mesh_bed_leveling::cell_index_x(float const &)
     144  mesh_bed_leveling::cell_index_y(float const &)
      16  mesh_bed_leveling::has_mesh()
     172  mesh_bed_leveling::probe_index_x(float const &)
     172  mesh_bed_leveling::probe_index_y(float const &)
      28  mesh_bed_leveling::set_active(bool)
      28  mesh_bed_leveling::set_has_mesh(bool)
      20  mesh_bed_leveling::set_z(int8_t, int8_t, float const &)
      30  mesh_bed_leveling::set_zigzag_z(int8_t, float const &)
      56  mesh_bed_leveling::zigzag(int8_t, int8_t &, int8_t &)
     472  mesh_line_to_destination(float, uint8_t, uint8_t)
      22  mesh_probing_done()
    1048  mksReprint
     102  mks_G28(char *)
     270  mks_PrintStatePolling
     274  mks_ReadFromEpr
      48  mks_ReadFromFile
     316  mks_WriteToEpr()
     424  mks_WriteToFile
      46  mks_clearDir
      52  mks_clearFile
     104  mks_contiuePrintDelta
      98  mks_contiuePrintPause
     124  mks_contiuePrintPwdwn
     150  mks_contiuePrint_UI
     224  mks_getPositionXYZE()
     276  mks_get_commands()
     952  mks_heating_busy
          marlin_debug_flags
          active_extruder
          wait_for_heatup
          wait_for_user
          target_extruder
          busy_state
          from_wifi_flag
          current_position
          destination
          homing_feedrate_mm_s
          home_offset
          workspace_offset
          soft_endstop_min
          soft_endstop_max
          delta
          feedrate_mm_s
          feedrate_percentage
          xy_probe_feedrate_mm_s
          delta_clip_start_height
          ubl
          command_queue_bak
          print_job_timer
          buzzer
      82  mks_initPrint
     144  mks_moveXY
      98  mks_moveZ
     106  mks_pausePrint
     174  mks_preExtrude
     170  mks_rePrintCheck
      66  mks_resumePrint
      12  mks_setFeedrate()
      94  mks_setPositionZ
     228  mks_setTemperature()
      60  ok_to_send()
      30  out_of_range_error(char const *)
     334  pause_file_offset()
      40  pin_is_protected(uint8_t)
     996  plan_arc(float *, float *, uint8_t)
     594  position_is_reachable(float const *, bool)
    1244  prepare_kinematic_move_to(float *)
     156  prepare_move_to_destination()
     272  prepare_move_to_destination_cartesian()
     116  prepare_uninterpolated_move_to_destination(float)
     564  print_2d_array(uint8_t, uint8_t, uint8_t, uint8_t)
      28  print_bilinear_leveling_grid()
     382  print_heaterstates()
     334  probe_pt(float, float, bool, int)
    2220  process_next_command()
     276  quick_home_xy()
     122  quick_pause()
      24  quickstop_stepper()
     364  recalc_delta_settings(float, float)
      76  refresh_bed_level()
      16  refresh_cmd_timeout()
     170  refresh_zprobe_zoffset(bool)
     298  report_current_position()
      12  reset
     150  reset_bed_level()
     128  run_z_probe()
       8  runout_beep
          next_buzz
       8  saved_feedrate_mm_s
          saved_feedrate_percentage
       8  say_not_entered()
       1  sd_comment_mode
     160  sensitive_pins
       1  serial_comment_mode
       4  serial_echopair_P(char const *, bool)
       4  serial_echopair_P(char const *, uint8_t)
      96  serial_line_buffer
      36  serialprintPGM(char const *)
       2  servo_init()
     262  set_axis_is_at_home(AxisEnum)
     222  set_bed_leveling_enabled(bool)
      76  set_current_from_steppers_for_axis(AxisEnum)
      20  set_current_to_destination()
      20  set_destination_to_current()
      56  set_home_offset(AxisEnum, float)
      80  set_probe_deployed(bool)
     126  set_z_fade_height(float)
     314  setup
       2  setup_filrunoutpin()
      22  setup_for_endstop_or_probe_move()
       2  setup_homepin()
       2  setup_killpin()
       2  setup_powerhold()
       1  soft_endstops_enabled
      66  stop()
       1  stop_buffering
       8  str_debug_1
      16  str_debug_16
       8  str_debug_2
       8  str_debug_4
       8  str_debug_8
       2  suicide()
      20  sync_plan_position()
      12  sync_plan_position_e()
      12  sync_plan_position_kinematic()
      54  tool_change(uint8_t, float, bool)
      92  unknown_command_error()
      94  update_software_endstops(AxisEnum)
      12  volumetric_enabled
          filament_size
          volumetric_multiplier
       1  wifi_comment_mode
      96  wifi_line_buffer
    1024  z_values
    2854  -- Other

 
  3 581 bytes in section .bss
  1 333 bytes in section .data
      4 bytes in section .init_array
  3 043 bytes in section .rodata
 45 272 bytes in section .text
 
 23 214 bytes of CODE  memory (+ 22 062 bytes shared)
    125 bytes of CONST memory (+  2 918 bytes shared)
  4 709 bytes of DATA  memory (+    205 bytes shared)

Errors: none
Warnings: 72
