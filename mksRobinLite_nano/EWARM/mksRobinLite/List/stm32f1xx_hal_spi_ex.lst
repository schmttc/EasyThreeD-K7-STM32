###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       28/Dec/2020  22:13:56
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\nano\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_spi_ex.c
#    Command line =  
#        -f C:\Users\ADMINI~1\AppData\Local\Temp\EWFC9D.tmp
#        (F:\nano\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_spi_ex.c -D
#        USE_HAL_DRIVER -D STM32F103xE -D MKS_ROBIN -D MARLIN -D __arm__ -D
#        USE_MKS_WIFI --preprocess=s F:\nano\EWARM\mksRobinLite\List -lC
#        F:\nano\EWARM\mksRobinLite\List -lA F:\nano\EWARM\mksRobinLite\List
#        --diag_suppress Pa050 -o F:\nano\EWARM\mksRobinLite\Obj --no_unroll
#        --no_inline --no_tbaa --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --char_is_signed --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Full.h" -I F:\nano\EWARM/../Inc\ -I
#        F:\nano\EWARM/../Src\ -I
#        F:\nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\ -I
#        F:\nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\ -I
#        F:\nano\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/Inc\ -I
#        F:\nano\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\ -I
#        F:\nano\EWARM/../Drivers/CMSIS/Include\ -I
#        F:\nano\EWARM/../Drivers/BSP/STM32MKS-3dPrinter\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/Common\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/l6474\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/at24cxx\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/w25qxx\ -I
#        F:\nano\EWARM/../Drivers/BSP/MotorControl\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/FatFs/src\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/Marlin\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/u8glib_arm_v1.17/src\ -I
#        F:\nano\EWARM/../Middlewares/arduino\ -I
#        F:\nano\EWARM/../Middlewares/arduino/avr\ -I
#        F:\nano\EWARM/../Inc/Logo\ -Om --use_c++_inline -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.0\arm\CMSIS\Core\Include\" -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  F:\nano\EWARM\mksRobinLite\List\stm32f1xx_hal_spi_ex.lst
#    Object file  =  F:\nano\EWARM\mksRobinLite\Obj\stm32f1xx_hal_spi_ex.o
#
###############################################################################

F:\nano\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_spi_ex.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f1xx_hal_spi_ex.c
      4            * @author  MCD Application Team
      5            * @version V1.0.4
      6            * @date    29-April-2016
      7            * @brief   Extended SPI HAL module driver.
      8            *    
      9            *          This file provides firmware functions to manage the following 
     10            *          functionalities SPI extension peripheral:
     11            *           + Extended Peripheral Control functions
     12            *  
     13            ******************************************************************************
     14            * @attention
     15            *
     16            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
     17            *
     18            * Redistribution and use in source and binary forms, with or without modification,
     19            * are permitted provided that the following conditions are met:
     20            *   1. Redistributions of source code must retain the above copyright notice,
     21            *      this list of conditions and the following disclaimer.
     22            *   2. Redistributions in binary form must reproduce the above copyright notice,
     23            *      this list of conditions and the following disclaimer in the documentation
     24            *      and/or other materials provided with the distribution.
     25            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     26            *      may be used to endorse or promote products derived from this software
     27            *      without specific prior written permission.
     28            *
     29            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     30            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     31            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     32            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     33            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     34            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     35            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     36            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     37            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     38            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     39            *
     40            ******************************************************************************
     41            */
     42          
     43          /* Includes ------------------------------------------------------------------*/
     44          #include "stm32f1xx_hal.h"
     45          
     46          /** @addtogroup STM32F1xx_HAL_Driver
     47            * @{
     48            */
     49          
     50          /** @addtogroup SPI
     51            * @{
     52            */
     53          #ifdef HAL_SPI_MODULE_ENABLED
     54          
     55          /** @defgroup SPI_Private_Variables SPI Private Variables
     56           * @{
     57           */
     58          /* Variable used to determine if device is impacted by implementation of workaround
     59             related to wrong CRC errors detection on SPI2. Conditions in which this workaround has to be applied, are:
     60              - STM32F101CDE/STM32F103CDE
     61              - Revision ID : Z
     62              - SPI2
     63              - In receive only mode, with CRC calculation enabled, at the end of the CRC reception,
     64                the software needs to check the CRCERR flag. If it is found set, read back the SPI_RXCRC:
     65                  + If the value is 0, the complete data transfer is successful.
     66                  + Otherwise, one or more errors have been detected during the data transfer by CPU or DMA.
     67                If CRCERR is found reset, the complete data transfer is considered successful.
     68          */

   \                                 In section .bss, align 1
     69          uint8_t uCRCErrorWorkaroundCheck = 0;
   \                     uCRCErrorWorkaroundCheck:
   \   00000000                      DS8 1
     70          /**
     71            * @}
     72            */
     73          
     74          
     75          /* Private typedef -----------------------------------------------------------*/
     76          /* Private define ------------------------------------------------------------*/
     77          /* Private macro -------------------------------------------------------------*/
     78          /* Private variables ---------------------------------------------------------*/
     79          /* Private function prototypes -----------------------------------------------*/
     80          /* Private functions ---------------------------------------------------------*/
     81          
     82          /** @addtogroup SPI_Exported_Functions
     83            * @{
     84            */
     85          
     86          /** @addtogroup SPI_Exported_Functions_Group1
     87           *
     88            * @{
     89            */
     90          
     91          /**
     92            * @brief  Initializes the SPI according to the specified parameters 
     93            *         in the SPI_InitTypeDef and create the associated handle.
     94            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
     95            *                the configuration information for SPI module.
     96            * @retval HAL status
     97            */

   \                                 In section .text, align 2, keep-with-next
     98          HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
     99          {
   \                     HAL_SPI_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    100            /* Check the SPI handle allocation */
    101            if(hspi == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_SPI_Init_0
    102            {
    103              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD10             POP      {R4,PC}
    104            }
    105          
    106            /* Check the parameters */
    107            assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
    108            assert_param(IS_SPI_MODE(hspi->Init.Mode));
    109            assert_param(IS_SPI_DIRECTION_MODE(hspi->Init.Direction));
    110            assert_param(IS_SPI_DATASIZE(hspi->Init.DataSize));
    111            assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
    112            assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));
    113            assert_param(IS_SPI_NSS(hspi->Init.NSS));
    114            assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
    115            assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
    116            assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
    117            assert_param(IS_SPI_CRC_CALCULATION(hspi->Init.CRCCalculation));
    118            assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
    119          
    120            if(hspi->State == HAL_SPI_STATE_RESET)
   \                     ??HAL_SPI_Init_0: (+1)
   \   0000000A   0xF994 0x0051      LDRSB    R0,[R4, #+81]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD102             BNE.N    ??HAL_SPI_Init_1
    121            {
    122              /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    123              HAL_SPI_MspInit(hspi);
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       HAL_SPI_MspInit
    124            }
    125            
    126            hspi->State = HAL_SPI_STATE_BUSY;
   \                     ??HAL_SPI_Init_1: (+1)
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0xF884 0x0051      STRB     R0,[R4, #+81]
    127          
    128            /* Disble the selected SPI peripheral */
    129            __HAL_SPI_DISABLE(hspi);
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000026   0x6001             STR      R1,[R0, #+0]
    130          
    131            /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
    132            /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
    133            Communication speed, First bit and CRC calculation state */
    134            WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
    135                                            hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
    136                                            hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation) );
   \   00000028   0x6861             LDR      R1,[R4, #+4]
   \   0000002A   0x68A0             LDR      R0,[R4, #+8]
   \   0000002C   0x4301             ORRS     R1,R0,R1
   \   0000002E   0x68E0             LDR      R0,[R4, #+12]
   \   00000030   0x4301             ORRS     R1,R0,R1
   \   00000032   0x6920             LDR      R0,[R4, #+16]
   \   00000034   0x4301             ORRS     R1,R0,R1
   \   00000036   0x6960             LDR      R0,[R4, #+20]
   \   00000038   0x4301             ORRS     R1,R0,R1
   \   0000003A   0x69A0             LDR      R0,[R4, #+24]
   \   0000003C   0xF400 0x7000      AND      R0,R0,#0x200
   \   00000040   0x4301             ORRS     R1,R0,R1
   \   00000042   0x69E0             LDR      R0,[R4, #+28]
   \   00000044   0x4301             ORRS     R1,R0,R1
   \   00000046   0x6A20             LDR      R0,[R4, #+32]
   \   00000048   0x4301             ORRS     R1,R0,R1
   \   0000004A   0x6AA0             LDR      R0,[R4, #+40]
   \   0000004C   0x4301             ORRS     R1,R0,R1
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x6001             STR      R1,[R0, #+0]
    137          
    138            /* Configure : NSS management */
    139            WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16) & SPI_CR2_SSOE) | hspi->Init.TIMode));
   \   00000052   0x69A1             LDR      R1,[R4, #+24]
   \   00000054   0x0C09             LSRS     R1,R1,#+16
   \   00000056   0xF001 0x0104      AND      R1,R1,#0x4
   \   0000005A   0x6A60             LDR      R0,[R4, #+36]
   \   0000005C   0x4301             ORRS     R1,R0,R1
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x6041             STR      R1,[R0, #+4]
    140          
    141            /*---------------------------- SPIx CRCPOLY Configuration ------------------*/
    142            /* Configure : CRC Polynomial */
    143            WRITE_REG(hspi->Instance->CRCPR, hspi->Init.CRCPolynomial);
   \   00000062   0x6AE0             LDR      R0,[R4, #+44]
   \   00000064   0x6821             LDR      R1,[R4, #+0]
   \   00000066   0x6108             STR      R0,[R1, #+16]
    144          
    145          #if defined (STM32F101x6) || defined (STM32F101xB) || defined (STM32F101xE) || defined (STM32F101xG) || defined (STM32F102x6) || defined (STM32F102xB) || defined (STM32F103x6) || defined (STM32F103xB) || defined (STM32F103xE) || defined (STM32F103xG) || defined (STM32F105xC) || defined (STM32F107xC)
    146            /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
    147            CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x69C1             LDR      R1,[R0, #+28]
   \   0000006C   0xF421 0x6100      BIC      R1,R1,#0x800
   \   00000070   0x61C1             STR      R1,[R0, #+28]
    148          #endif
    149          
    150          #if defined (STM32F101xE) || defined (STM32F103xE)
    151            /* Check RevisionID value for identifying if Device is Rev Z (0x0001) in order to enable workaround for
    152               CRC errors wrongly detected */
    153            /* Pb is that ES_STM32F10xxCDE also identify an issue in Debug registers access while not in Debug mode.
    154               Revision ID information is only available in Debug mode, so Workaround could not be implemented
    155               to distinguish Rev Z devices (issue present) from more recent version (issue fixed).
    156               So, in case of Revison Z F101 or F103 devices, below variable should be assigned to 1 */
    157            uCRCErrorWorkaroundCheck = 0;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x....             LDR.N    R1,??DataTable1
   \   00000076   0x7008             STRB     R0,[R1, #+0]
    158          #else
    159            uCRCErrorWorkaroundCheck = 0;
    160          #endif
    161          
    162            hspi->ErrorCode = HAL_SPI_ERROR_NONE;
   \   00000078   0x6560             STR      R0,[R4, #+84]
    163            hspi->State = HAL_SPI_STATE_READY;
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0xF884 0x0051      STRB     R0,[R4, #+81]
    164            
    165            return HAL_OK;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xBD10             POP      {R4,PC}          ;; return
    166          }
    167          
    168          /**
    169            * @}
    170            */
    171          
    172          /**
    173            * @}
    174            */
    175          
    176          /** @addtogroup SPI_Private_Functions
    177            * @{
    178            */
    179          
    180          /**
    181            * @brief  Checks if encountered CRC error could be corresponding to wrongly detected errors 
    182            *         according to SPI instance, Device type, and revision ID.
    183            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    184            *               the configuration information for SPI module.
    185            * @retval CRC error validity (SPI_INVALID_CRC_ERROR or SPI_VALID_CRC_ERROR).  
    186          */

   \                                 In section .text, align 2, keep-with-next
    187          uint8_t SPI_ISCRCErrorValid(SPI_HandleTypeDef *hspi)
    188          {
    189          #if defined (STM32F101xE) || defined (STM32F103xE)
    190            /* Check how to handle this CRC error (workaround to be applied or not) */
    191            /* If CRC errors could be wrongly detected (issue 2.15.2 in STM32F10xxC/D/E silicon limitations ES (DocID14732 Rev 13) */
    192            if ( (uCRCErrorWorkaroundCheck != 0) && (hspi->Instance == SPI2) )
   \                     SPI_ISCRCErrorValid: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable1
   \   00000002   0x7809             LDRB     R1,[R1, #+0]
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD008             BEQ.N    ??SPI_ISCRCErrorValid_0
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x....             LDR.N    R1,??DataTable1_1  ;; 0x40003800
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xD104             BNE.N    ??SPI_ISCRCErrorValid_0
    193            {
    194              if (hspi->Instance->RXCRCR == 0)
   \   00000010   0x6940             LDR      R0,[R0, #+20]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD101             BNE.N    ??SPI_ISCRCErrorValid_0
    195              {
    196                return (SPI_INVALID_CRC_ERROR);
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x4770             BX       LR
    197              }
    198            }
    199            return (SPI_VALID_CRC_ERROR);
   \                     ??SPI_ISCRCErrorValid_0: (+1)
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x4770             BX       LR               ;; return
    200          #else
    201            return (SPI_VALID_CRC_ERROR);
    202          #endif
    203          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     uCRCErrorWorkaroundCheck

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x40003800         DC32     0x40003800
    204          /**
    205            * @}
    206            */
    207          
    208          #endif /* HAL_SPI_MODULE_ENABLED */
    209          /**
    210            * @}
    211            */
    212          
    213          /**
    214            * @}
    215            */
    216          
    217          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HAL_SPI_Init
         8   -> HAL_SPI_MspInit
       0   SPI_ISCRCErrorValid


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
     132  HAL_SPI_Init
      30  SPI_ISCRCErrorValid
       1  uCRCErrorWorkaroundCheck

 
   1 byte  in section .bss
 170 bytes in section .text
 
 170 bytes of CODE memory
   1 byte  of DATA memory

Errors: none
Warnings: none
