###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       28/Dec/2020  22:13:38
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  F:\nano\Drivers\BSP\Components\at24cxx\at24cxx.cpp
#    Command line =  
#        -f C:\Users\ADMINI~1\AppData\Local\Temp\EWB635.tmp
#        (F:\nano\Drivers\BSP\Components\at24cxx\at24cxx.cpp -D USE_HAL_DRIVER
#        -D STM32F103xE -D MKS_ROBIN -D MARLIN -D __arm__ -D USE_MKS_WIFI
#        --preprocess=s F:\nano\EWARM\mksRobinLite\List -lC
#        F:\nano\EWARM\mksRobinLite\List -lA F:\nano\EWARM\mksRobinLite\List
#        --diag_suppress Pa050 -o F:\nano\EWARM\mksRobinLite\Obj --no_unroll
#        --no_inline --no_tbaa --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --char_is_signed --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Full.h" -I F:\nano\EWARM/../Inc\ -I
#        F:\nano\EWARM/../Src\ -I
#        F:\nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\ -I
#        F:\nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\ -I
#        F:\nano\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/Inc\ -I
#        F:\nano\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\ -I
#        F:\nano\EWARM/../Drivers/CMSIS/Include\ -I
#        F:\nano\EWARM/../Drivers/BSP/STM32MKS-3dPrinter\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/Common\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/l6474\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/at24cxx\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/w25qxx\ -I
#        F:\nano\EWARM/../Drivers/BSP/MotorControl\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/FatFs/src\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/Marlin\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/u8glib_arm_v1.17/src\ -I
#        F:\nano\EWARM/../Middlewares/arduino\ -I
#        F:\nano\EWARM/../Middlewares/arduino/avr\ -I
#        F:\nano\EWARM/../Inc/Logo\ -Om --c++ --no_exceptions --no_rtti -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  F:\nano\EWARM\mksRobinLite\List\at24cxx.lst
#    Object file  =  F:\nano\EWARM\mksRobinLite\Obj\at24cxx.o
#
###############################################################################

F:\nano\Drivers\BSP\Components\at24cxx\at24cxx.cpp
      1          
Warning[Ms014]: some characters could not be correctly encoded in
          "F:\nano\EWARM\mksRobinLite\List\at24cxx.s", and have been replaced
          with '@'. The first such character has unicode code point 0x65b9
          ("@")
      2          #include "at24cxx.h"
      3          #include "sys.h"
      4          /*--------------------------MKS EEPROM-------------------------*/
      5          

   \                                 In section .bss, align 2
      6          volatile u16 delayCnt;	
   \                     delayCnt:
   \   00000000                      DS8 2
      7          //#include "stm32f10x.h"
      8           
      9          
     10          //IO@@@@
     11           
     12          #define SDA_IN()  {GPIOB->CRL&=0X0FFFFFFF;GPIOB->CRL|=(u32)8<<28;}
     13          #define SDA_OUT() {GPIOB->CRL&=0X0FFFFFFF;GPIOB->CRL|=(u32)3<<28;}
     14          
     15          //IO@@@@	 
     16          #define IIC_SCL    PBout(6) //SCL
     17          #define IIC_SDA    PBout(7) //SDA	 
     18          #define READ_SDA   PBin(7)  //@@SDA 
     19          /*
     20          static u8  fac_us=0;							//us@@@@@			   
     21          static u16 fac_ms=0;							//ms@@@@@,@ucos@,@@@@@@@ms@
     22          
     23          void delay_init()
     24          {
     25          	SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK_Div8);	//@@@@@@  HCLK/8
     26          	fac_us=SystemCoreClock/8000000;				//@@@@@@1/8  
     27          	fac_ms=(u16)fac_us*1000;					//@OS@,@@@@ms@@@systick@@@   
     28          
     29          }		
     30          */

   \                                 In section .text, align 2, keep-with-next
     31          void delay_us(uint32_t nus)
     32          {
   \                     _Z8delay_usj: (+1)
   \   00000000   0xE007             B.N      ??delay_us_0
     33                while(nus--)
     34                {
     35                  delayCnt = 5;  //10,8,6 -ok          
   \                     ??delay_us_1: (+1)
   \   00000002   0x....             LDR.N    R1,??DataTable9
   \   00000004   0x2205             MOVS     R2,#+5
   \   00000006   0x800A             STRH     R2,[R1, #+0]
     36                  while(delayCnt--);
   \                     ??delay_us_2: (+1)
   \   00000008   0x880A             LDRH     R2,[R1, #+0]
   \   0000000A   0x1E53             SUBS     R3,R2,#+1
   \   0000000C   0x800B             STRH     R3,[R1, #+0]
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0xD1FA             BNE.N    ??delay_us_2
     37                }
   \                     ??delay_us_0: (+1)
   \   00000012   0x4601             MOV      R1,R0
   \   00000014   0x1E48             SUBS     R0,R1,#+1
   \   00000016   0x2900             CMP      R1,#+0
   \   00000018   0xD1F3             BNE.N    ??delay_us_1
     38           /*
     39          	u32 temp;	    	 
     40          	SysTick->LOAD=nus*fac_us; 					//@@@@	  		 
     41          	SysTick->VAL=0x00;        					//@@@@@
     42          	SysTick->CTRL|=SysTick_CTRL_ENABLE_Msk ;	//@@@@	  
     43          	do
     44          	{
     45          		temp=SysTick->CTRL;
     46          	}while((temp&0x01)&&!(temp&(1<<16)));		//@@@@@@   
     47          	SysTick->CTRL&=~SysTick_CTRL_ENABLE_Msk;	//@@@@@
     48          	SysTick->VAL =0X00;      		        //@@@@@	 
     49             */     
     50          }
   \   0000001A   0x4770             BX       LR               ;; return
     51          //@@nms
     52          //@@nms@@@
     53          //SysTick->LOAD@24@@@@,@@,@@@@@:
     54          //nms<=0xffffff*8*1000/SYSCLK
     55          //SYSCLK@@@Hz,nms@@@ms
     56          //@72M@@@,nms<=1864 

   \                                 In section .text, align 2, keep-with-next
     57          void delay_ms(uint16_t nms)
     58          {	 
   \                     _Z8delay_mst: (+1)
   \   00000000   0xE008             B.N      ??delay_ms_0
     59          
     60                while(nms--)
     61                {
     62                  delayCnt = 5000;        //10000,8000,6000 -ok          
   \                     ??delay_ms_1: (+1)
   \   00000002   0x....             LDR.N    R1,??DataTable9
   \   00000004   0xF241 0x3288      MOVW     R2,#+5000
   \   00000008   0x800A             STRH     R2,[R1, #+0]
     63                  while(delayCnt--);
   \                     ??delay_ms_2: (+1)
   \   0000000A   0x880A             LDRH     R2,[R1, #+0]
   \   0000000C   0x1E53             SUBS     R3,R2,#+1
   \   0000000E   0x800B             STRH     R3,[R1, #+0]
   \   00000010   0x2A00             CMP      R2,#+0
   \   00000012   0xD1FA             BNE.N    ??delay_ms_2
     64                }
   \                     ??delay_ms_0: (+1)
   \   00000014   0x4601             MOV      R1,R0
   \   00000016   0x1E48             SUBS     R0,R1,#+1
   \   00000018   0xB289             UXTH     R1,R1
   \   0000001A   0x2900             CMP      R1,#+0
   \   0000001C   0xD1F1             BNE.N    ??delay_ms_1
     65            
     66          	/*u32 temp;		   
     67          	SysTick->LOAD=(u32)nms*fac_ms;				//@@@@(SysTick->LOAD@24bit)
     68          	SysTick->VAL =0x00;							//@@@@@
     69          	SysTick->CTRL|=SysTick_CTRL_ENABLE_Msk ;	//@@@@  
     70          	do
     71          	{
     72          		temp=SysTick->CTRL;
     73          	}while((temp&0x01)&&!(temp&(1<<16)));		//@@@@@@   
     74          	SysTick->CTRL&=~SysTick_CTRL_ENABLE_Msk;	//@@@@@
     75          	SysTick->VAL =0X00;       					//@@@@@	
     76          */
     77          }
   \   0000001E   0x4770             BX       LR               ;; return
     78          //@@@IIC@@

   \                                 In section .text, align 2, keep-with-next
     79          void AT24CXX_Init(void)
     80          {
     81                  //delay_init();
     82          	IIC_Init();
   \                     AT24CXX_Init: (+1)
   \   00000000   0x....             B.N      IIC_Init
     83          }
     84          //@AT24CXX@@@@@@@@@@
     85          //ReadAddr:@@@@@@@  
     86          //@@@  :@@@@@

   \                                 In section .text, align 2, keep-with-next
     87          uint8_t AT24CXX_ReadOneByte(uint16_t ReadAddr)
     88          {				  
   \                     AT24CXX_ReadOneByte: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
     89          	uint8_t temp=0;		  	    																 
     90              IIC_Start();  
   \   00000004   0x.... 0x....      BL       IIC_Start
     91          	if(EE_TYPE>AT24C16)
     92          	{
     93          		IIC_Send_Byte(0XA0);	   //@@@@@
     94          		IIC_Wait_Ack();
     95          		IIC_Send_Byte(ReadAddr>>8);//@@@@@
     96          		IIC_Wait_Ack();		 
     97          	}else IIC_Send_Byte(0XA0+((ReadAddr/256)<<1));   //@@@@@@0XA0,@@@ 	 
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0x0A00             LSRS     R0,R0,#+8
   \   0000000C   0x0040             LSLS     R0,R0,#+1
   \   0000000E   0x30A0             ADDS     R0,R0,#+160
   \   00000010   0xB2C0             UXTB     R0,R0
   \   00000012   0x.... 0x....      BL       IIC_Send_Byte
     98          
     99          	IIC_Wait_Ack(); 
   \   00000016   0x.... 0x....      BL       IIC_Wait_Ack
    100              IIC_Send_Byte(ReadAddr%256);   //@@@@@
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0xB2C0             UXTB     R0,R0
   \   0000001E   0x.... 0x....      BL       IIC_Send_Byte
    101          	IIC_Wait_Ack();	    
   \   00000022   0x.... 0x....      BL       IIC_Wait_Ack
    102          	IIC_Start();  	 	   
   \   00000026   0x.... 0x....      BL       IIC_Start
    103          	IIC_Send_Byte(0XA1);           //@@@@@@			   
   \   0000002A   0x20A1             MOVS     R0,#+161
   \   0000002C   0x.... 0x....      BL       IIC_Send_Byte
    104          	IIC_Wait_Ack();	 
   \   00000030   0x.... 0x....      BL       IIC_Wait_Ack
    105              temp=IIC_Read_Byte(0);		   
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x.... 0x....      BL       IIC_Read_Byte
   \   0000003A   0x4604             MOV      R4,R0
    106              IIC_Stop();//@@@@@@@@	    
   \   0000003C   0x.... 0x....      BL       IIC_Stop
    107          	return temp;
   \   00000040   0x4620             MOV      R0,R4
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
    108          }
    109          //@AT24CXX@@@@@@@@@@
    110          //WriteAddr  :@@@@@@@@@    
    111          //DataToWrite:@@@@@@

   \                                 In section .text, align 2, keep-with-next
    112          void AT24CXX_WriteOneByte(uint16_t WriteAddr,uint8_t DataToWrite)
    113          {				   	  	    																 
   \                     AT24CXX_WriteOneByte: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    114              IIC_Start();  
   \   00000006   0x.... 0x....      BL       IIC_Start
    115          	if(EE_TYPE>AT24C16)
    116          	{
    117          		IIC_Send_Byte(0XA0);	    //@@@@@
    118          		IIC_Wait_Ack();
    119          		IIC_Send_Byte(WriteAddr>>8);//@@@@@
    120           	}else
    121          	{
    122          		IIC_Send_Byte(0XA0+((WriteAddr/256)<<1));   //@@@@@@0XA0,@@@ 
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x0A00             LSRS     R0,R0,#+8
   \   0000000E   0x0040             LSLS     R0,R0,#+1
   \   00000010   0x30A0             ADDS     R0,R0,#+160
   \   00000012   0xB2C0             UXTB     R0,R0
   \   00000014   0x.... 0x....      BL       IIC_Send_Byte
    123          	}	 
    124          	IIC_Wait_Ack();	   
   \   00000018   0x.... 0x....      BL       IIC_Wait_Ack
    125              IIC_Send_Byte(WriteAddr%256);   //@@@@@
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0xB2C0             UXTB     R0,R0
   \   00000020   0x.... 0x....      BL       IIC_Send_Byte
    126          	IIC_Wait_Ack(); 	 										  		   
   \   00000024   0x.... 0x....      BL       IIC_Wait_Ack
    127          	IIC_Send_Byte(DataToWrite);     //@@@@							   
   \   00000028   0x4628             MOV      R0,R5
   \   0000002A   0x.... 0x....      BL       IIC_Send_Byte
    128          	IIC_Wait_Ack();  		    	   
   \   0000002E   0x.... 0x....      BL       IIC_Wait_Ack
    129              IIC_Stop();//@@@@@@@@ 
   \   00000032   0x.... 0x....      BL       IIC_Stop
    130          	//delay_ms(10);	 
    131          	delay_ms(3);	 //5-ok;3-ok;2-ok;1-bad;
   \   00000036   0x2003             MOVS     R0,#+3
   \   00000038   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000003C   0x....             B.N      _Z8delay_mst
    132          }
    133          //@AT24CXX@@@@@@@@@@@@@@Len@@@
    134          //@@@@@@@16bit@@32bit@@@.
    135          //WriteAddr  :@@@@@@@  
    136          //DataToWrite:@@@@@@@
    137          //Len        :@@@@@@@@2,4

   \                                 In section .text, align 2, keep-with-next
    138          void AT24CXX_WriteLenByte(uint16_t WriteAddr,uint32_t DataToWrite,uint8_t Len)
    139          {  	
   \                     AT24CXX_WriteLenByte: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    140          	uint8_t t;
    141          	for(t=0;t<Len;t++)
   \   00000008   0x2700             MOVS     R7,#+0
   \   0000000A   0xE009             B.N      ??AT24CXX_WriteLenByte_0
    142          	{
    143          		AT24CXX_WriteOneByte(WriteAddr+t,(DataToWrite>>(8*t))&0xff);
   \                     ??AT24CXX_WriteLenByte_1: (+1)
   \   0000000C   0x00F8             LSLS     R0,R7,#+3
   \   0000000E   0x4629             MOV      R1,R5
   \   00000010   0x40C1             LSRS     R1,R1,R0
   \   00000012   0xB2C9             UXTB     R1,R1
   \   00000014   0x1938             ADDS     R0,R7,R4
   \   00000016   0xB280             UXTH     R0,R0
   \   00000018   0x.... 0x....      BL       AT24CXX_WriteOneByte
    144          	}												    
   \   0000001C   0x1C7F             ADDS     R7,R7,#+1
   \   0000001E   0xB2FF             UXTB     R7,R7
   \                     ??AT24CXX_WriteLenByte_0: (+1)
   \   00000020   0x4630             MOV      R0,R6
   \   00000022   0x4287             CMP      R7,R0
   \   00000024   0xDBF2             BLT.N    ??AT24CXX_WriteLenByte_1
    145          }
   \   00000026   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    146          
    147          //@AT24CXX@@@@@@@@@@@@@@Len@@@
    148          //@@@@@@@16bit@@32bit@@@.
    149          //ReadAddr   :@@@@@@@ 
    150          //@@@     :@@
    151          //Len        :@@@@@@@@2,4

   \                                 In section .text, align 2, keep-with-next
    152          uint32_t AT24CXX_ReadLenByte(uint16_t ReadAddr,uint8_t Len)
    153          {  	
   \                     AT24CXX_ReadLenByte: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    154          	uint8_t t;
    155          	uint32_t temp=0;
   \   00000006   0x2600             MOVS     R6,#+0
    156          	for(t=0;t<Len;t++)
   \   00000008   0x4637             MOV      R7,R6
   \   0000000A   0xE00B             B.N      ??AT24CXX_ReadLenByte_0
    157          	{
    158          		temp<<=8;
    159          		temp+=AT24CXX_ReadOneByte(ReadAddr+Len-t-1); 	 				   
   \                     ??AT24CXX_ReadLenByte_1: (+1)
   \   0000000C   0x4628             MOV      R0,R5
   \   0000000E   0x1900             ADDS     R0,R0,R4
   \   00000010   0x4639             MOV      R1,R7
   \   00000012   0xB2C9             UXTB     R1,R1
   \   00000014   0x1A40             SUBS     R0,R0,R1
   \   00000016   0x1E40             SUBS     R0,R0,#+1
   \   00000018   0xB280             UXTH     R0,R0
   \   0000001A   0x.... 0x....      BL       AT24CXX_ReadOneByte
   \   0000001E   0xEB00 0x2606      ADD      R6,R0,R6, LSL #+8
    160          	}
   \   00000022   0x1C7F             ADDS     R7,R7,#+1
   \                     ??AT24CXX_ReadLenByte_0: (+1)
   \   00000024   0x4638             MOV      R0,R7
   \   00000026   0x4629             MOV      R1,R5
   \   00000028   0xB2C0             UXTB     R0,R0
   \   0000002A   0x4288             CMP      R0,R1
   \   0000002C   0xD3EE             BCC.N    ??AT24CXX_ReadLenByte_1
    161          	return temp;												    
   \   0000002E   0x4630             MOV      R0,R6
   \   00000030   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    162          }
    163          //@@AT24CXX@@@@
    164          //@@@@24XX@@@@@@@(255)@@@@@@.
    165          //@@@@@24C@@,@@@@@@@
    166          //@@1:@@@@
    167          //@@0:@@@@

   \                                 In section .text, align 2, keep-with-next
    168          uint8_t AT24CXX_Check(void)
    169          {
   \                     AT24CXX_Check: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    170          	uint8_t temp;
    171          	temp=AT24CXX_ReadOneByte(255);//@@@@@@@@AT24CXX			   
    172          	if(temp==0X55)return 0;		   
   \   00000002   0x20FF             MOVS     R0,#+255
   \   00000004   0x.... 0x....      BL       AT24CXX_ReadOneByte
   \   00000008   0x2855             CMP      R0,#+85
   \   0000000A   0xD101             BNE.N    ??AT24CXX_Check_0
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD02             POP      {R1,PC}
    173          	else//@@@@@@@@@@@
    174          	{
    175          		AT24CXX_WriteOneByte(255,0X55);
   \                     ??AT24CXX_Check_0: (+1)
   \   00000010   0x2155             MOVS     R1,#+85
   \   00000012   0x20FF             MOVS     R0,#+255
   \   00000014   0x.... 0x....      BL       AT24CXX_WriteOneByte
    176          	    temp=AT24CXX_ReadOneByte(255);	  
    177          		if(temp==0X55)return 0;
   \   00000018   0x20FF             MOVS     R0,#+255
   \   0000001A   0x.... 0x....      BL       AT24CXX_ReadOneByte
   \   0000001E   0x2855             CMP      R0,#+85
   \   00000020   0xD101             BNE.N    ??AT24CXX_Check_1
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBD02             POP      {R1,PC}
    178          	}
    179          	return 1;											  
   \                     ??AT24CXX_Check_1: (+1)
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xBD02             POP      {R1,PC}          ;; return
    180          }
    181          
    182          //@AT24CXX@@@@@@@@@@@@@@@@@@
    183          //ReadAddr :@@@@@@@ @24c02@0~255
    184          //pBuffer  :@@@@@@@
    185          //NumToRead:@@@@@@@@
    186          //HAL_StatusTypeDef AT24CXX_Read(uint16_t MemAddress, uint8_t* pBuffer, uint32_t BufferSize)
    187          //void AT24CXX_Read(uint16_t ReadAddr,uint8_t *pBuffer,uint16_t NumToRead)

   \                                 In section .text, align 2, keep-with-next
    188          void AT24CXX_Read(uint16_t ReadAddr,uint8_t *pBuffer,uint32_t NumToRead)
    189          
    190          {
   \                     AT24CXX_Read: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x0014             MOVS     R4,R2
   \   00000008   0xE007             B.N      ??AT24CXX_Read_0
    191          	while(NumToRead)
    192          	{
    193          		*pBuffer++=AT24CXX_ReadOneByte(ReadAddr++);	
   \                     ??AT24CXX_Read_1: (+1)
   \   0000000A   0x4628             MOV      R0,R5
   \   0000000C   0xB280             UXTH     R0,R0
   \   0000000E   0x.... 0x....      BL       AT24CXX_ReadOneByte
   \   00000012   0x1C6D             ADDS     R5,R5,#+1
   \   00000014   0xF806 0x0B01      STRB     R0,[R6], #+1
    194          		NumToRead--;
   \   00000018   0x1E64             SUBS     R4,R4,#+1
    195          	}
   \                     ??AT24CXX_Read_0: (+1)
   \   0000001A   0xD1F6             BNE.N    ??AT24CXX_Read_1
    196          }  
   \   0000001C   0xBD70             POP      {R4-R6,PC}       ;; return
    197          //@AT24CXX@@@@@@@@@@@@@@@@@@
    198          //WriteAddr :@@@@@@@ @24c02@0~255
    199          //pBuffer   :@@@@@@@
    200          //NumToWrite:@@@@@@@@
    201          //HAL_StatusTypeDef AT24CXX_Write(uint16_t MemAddress, uint8_t* pBuffer, uint32_t BufferSize)
    202          //void AT24CXX_Write(u16 WriteAddr,u8 *pBuffer,u16 NumToWrite)

   \                                 In section .text, align 2, keep-with-next
    203          void AT24CXX_Write(uint16_t WriteAddr,uint8_t*pBuffer,uint32_t NumToWrite)
    204          
    205          {
   \                     AT24CXX_Write: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0xE006             B.N      ??AT24CXX_Write_0
    206          	while(NumToWrite--)
    207          	{
    208          		AT24CXX_WriteOneByte(WriteAddr,*pBuffer);
   \                     ??AT24CXX_Write_1: (+1)
   \   0000000A   0xF815 0x1B01      LDRB     R1,[R5], #+1
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0xB280             UXTH     R0,R0
   \   00000012   0x.... 0x....      BL       AT24CXX_WriteOneByte
    209          		WriteAddr++;
   \   00000016   0x1C64             ADDS     R4,R4,#+1
    210          		pBuffer++;
    211          	}
   \                     ??AT24CXX_Write_0: (+1)
   \   00000018   0x4630             MOV      R0,R6
   \   0000001A   0x1E46             SUBS     R6,R0,#+1
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD1F4             BNE.N    ??AT24CXX_Write_1
    212          }
   \   00000020   0xBD70             POP      {R4-R6,PC}       ;; return
    213          
    214          //@@@IIC

   \                                 In section .text, align 2, keep-with-next
    215          void IIC_Init(void)
    216          {		
   \                     IIC_Init: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
    217          	GPIO_InitTypeDef GPIO_InitStruct;
    218          
    219          	GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
   \   00000002   0x20C0             MOVS     R0,#+192
   \   00000004   0x9000             STR      R0,[SP, #+0]
    220          	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x9001             STR      R0,[SP, #+4]
    221          	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM;
   \   0000000A   0x9003             STR      R0,[SP, #+12]
    222          	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   \   0000000C   0x....             LDR.N    R4,??DataTable9_1  ;; 0x40010c00
   \   0000000E   0x4669             MOV      R1,SP
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       HAL_GPIO_Init
    223          	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_6|GPIO_PIN_7, GPIO_PIN_SET);
   \   00000016   0x2201             MOVS     R2,#+1
   \   00000018   0x21C0             MOVS     R1,#+192
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       HAL_GPIO_WritePin
    224          	
    225          }
   \   00000020   0xBD1F             POP      {R0-R4,PC}       ;; return
    226          //@@IIC@@@@

   \                                 In section .text, align 2, keep-with-next
    227          void IIC_Start(void)
    228          {
   \                     IIC_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    229          	SDA_OUT();     //sda@@@
   \   00000002   0x....             LDR.N    R0,??DataTable9_1  ;; 0x40010c00
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0xF021 0x4170      BIC      R1,R1,#0xF0000000
   \   0000000A   0x6001             STR      R1,[R0, #+0]
   \   0000000C   0x6801             LDR      R1,[R0, #+0]
   \   0000000E   0xF041 0x5140      ORR      R1,R1,#0x30000000
   \   00000012   0x6001             STR      R1,[R0, #+0]
    230          	IIC_SDA=1;	  	  
   \   00000014   0x....             LDR.N    R4,??DataTable9_2  ;; 0x42218198
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x6060             STR      R0,[R4, #+4]
    231          	IIC_SCL=1;
   \   0000001A   0x6020             STR      R0,[R4, #+0]
    232          	delay_us(4);
   \   0000001C   0x2004             MOVS     R0,#+4
   \   0000001E   0x.... 0x....      BL       _Z8delay_usj
    233           	IIC_SDA=0;//START:when CLK is high,DATA change form high to low 
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x6060             STR      R0,[R4, #+4]
    234          	delay_us(4);
   \   00000026   0x2004             MOVS     R0,#+4
   \   00000028   0x.... 0x....      BL       _Z8delay_usj
    235          	IIC_SCL=0;//@@I2C@@@@@@@@@@@@ 
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x6020             STR      R0,[R4, #+0]
    236          }	  
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    237          //@@IIC@@@@

   \                                 In section .text, align 2, keep-with-next
    238          void IIC_Stop(void)
    239          {
   \                     IIC_Stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    240          	SDA_OUT();//sda@@@
   \   00000002   0x....             LDR.N    R0,??DataTable9_1  ;; 0x40010c00
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0xF021 0x4170      BIC      R1,R1,#0xF0000000
   \   0000000A   0x6001             STR      R1,[R0, #+0]
   \   0000000C   0x6801             LDR      R1,[R0, #+0]
   \   0000000E   0xF041 0x5140      ORR      R1,R1,#0x30000000
   \   00000012   0x6001             STR      R1,[R0, #+0]
    241          	IIC_SCL=0;
   \   00000014   0x....             LDR.N    R4,??DataTable9_2  ;; 0x42218198
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x6020             STR      R0,[R4, #+0]
    242          	IIC_SDA=0;//STOP:when CLK is high DATA change form low to high
   \   0000001A   0x6060             STR      R0,[R4, #+4]
    243           	delay_us(4);
   \   0000001C   0x2004             MOVS     R0,#+4
   \   0000001E   0x.... 0x....      BL       _Z8delay_usj
    244          	IIC_SCL=1; 
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x6020             STR      R0,[R4, #+0]
    245          	IIC_SDA=1;//@@I2C@@@@@@
   \   00000026   0x6060             STR      R0,[R4, #+4]
    246          	delay_us(4);							   	
   \   00000028   0x2004             MOVS     R0,#+4
   \   0000002A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000002E   0x....             B.N      _Z8delay_usj
    247          }
    248          //@@@@@@@@
    249          //@@@@1@@@@@@@
    250          //        0@@@@@@@

   \                                 In section .text, align 2, keep-with-next
    251          uint8_t IIC_Wait_Ack(void)
    252          {
   \                     IIC_Wait_Ack: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    253          	uint8_t ucErrTime=0;
   \   00000002   0x2400             MOVS     R4,#+0
    254          	SDA_IN();      //SDA@@@@@  
   \   00000004   0x....             LDR.N    R0,??DataTable9_1  ;; 0x40010c00
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0xF021 0x4170      BIC      R1,R1,#0xF0000000
   \   0000000C   0x6001             STR      R1,[R0, #+0]
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
   \   00000010   0xF041 0x4100      ORR      R1,R1,#0x80000000
   \   00000014   0x6001             STR      R1,[R0, #+0]
    255          	IIC_SDA=1;delay_us(1);	   
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x....             LDR.N    R1,??DataTable9_3  ;; 0x4221819c
   \   0000001A   0x6008             STR      R0,[R1, #+0]
   \   0000001C   0x.... 0x....      BL       _Z8delay_usj
    256          	IIC_SCL=1;delay_us(1);	 
   \   00000020   0x....             LDR.N    R5,??DataTable9_4  ;; 0x4221811c
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x67E8             STR      R0,[R5, #+124]
   \   00000026   0x.... 0x....      BL       _Z8delay_usj
    257          	while(READ_SDA)
   \                     ??IIC_Wait_Ack_0: (+1)
   \   0000002A   0x6828             LDR      R0,[R5, #+0]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD008             BEQ.N    ??IIC_Wait_Ack_1
    258          	{
    259          		ucErrTime++;
   \   00000030   0x1C64             ADDS     R4,R4,#+1
    260          		if(ucErrTime>250)
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0xB2C0             UXTB     R0,R0
   \   00000036   0x28FB             CMP      R0,#+251
   \   00000038   0xDBF7             BLT.N    ??IIC_Wait_Ack_0
    261          		{
    262          			IIC_Stop();
   \   0000003A   0x.... 0x....      BL       IIC_Stop
    263          			return 1;
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0xBD32             POP      {R1,R4,R5,PC}
    264          		}
    265          	}
    266          	IIC_SCL=0;//@@@@0 	   
   \                     ??IIC_Wait_Ack_1: (+1)
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x67E8             STR      R0,[R5, #+124]
    267          	return 0;  
   \   00000046   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    268          } 
    269          //@@ACK@@

   \                                 In section .text, align 2, keep-with-next
    270          void IIC_Ack(void)
    271          {
   \                     IIC_Ack: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    272          	IIC_SCL=0;
   \   00000002   0x....             LDR.N    R4,??DataTable9_2  ;; 0x42218198
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x6020             STR      R0,[R4, #+0]
    273          	SDA_OUT();
   \   00000008   0x....             LDR.N    R0,??DataTable9_1  ;; 0x40010c00
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0xF021 0x4170      BIC      R1,R1,#0xF0000000
   \   00000010   0x6001             STR      R1,[R0, #+0]
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0xF041 0x5140      ORR      R1,R1,#0x30000000
   \   00000018   0x6001             STR      R1,[R0, #+0]
    274          	IIC_SDA=0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x6060             STR      R0,[R4, #+4]
    275          	delay_us(2);
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0x.... 0x....      BL       _Z8delay_usj
    276          	IIC_SCL=1;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x6020             STR      R0,[R4, #+0]
    277          	delay_us(2);
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0x.... 0x....      BL       _Z8delay_usj
    278          	IIC_SCL=0;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x6020             STR      R0,[R4, #+0]
    279          }
   \   00000032   0xBD10             POP      {R4,PC}          ;; return
    280          //@@@ACK@@		    

   \                                 In section .text, align 2, keep-with-next
    281          void IIC_NAck(void)
    282          {
   \                     IIC_NAck: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    283          	IIC_SCL=0;
   \   00000002   0x....             LDR.N    R4,??DataTable9_2  ;; 0x42218198
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x6020             STR      R0,[R4, #+0]
    284          	SDA_OUT();
   \   00000008   0x....             LDR.N    R0,??DataTable9_1  ;; 0x40010c00
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0xF021 0x4170      BIC      R1,R1,#0xF0000000
   \   00000010   0x6001             STR      R1,[R0, #+0]
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0xF041 0x5140      ORR      R1,R1,#0x30000000
   \   00000018   0x6001             STR      R1,[R0, #+0]
    285          	IIC_SDA=1;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x6060             STR      R0,[R4, #+4]
    286          	delay_us(2);
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0x.... 0x....      BL       _Z8delay_usj
    287          	IIC_SCL=1;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x6020             STR      R0,[R4, #+0]
    288          	delay_us(2);
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0x.... 0x....      BL       _Z8delay_usj
    289          	IIC_SCL=0;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x6020             STR      R0,[R4, #+0]
    290          }					 				     
   \   00000032   0xBD10             POP      {R4,PC}          ;; return
    291          //IIC@@@@@@
    292          //@@@@@@@@
    293          //1@@@@
    294          //0@@@@			  

   \                                 In section .text, align 2, keep-with-next
    295          void IIC_Send_Byte(uint8_t txd)
    296          {                        
   \                     IIC_Send_Byte: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    297              uint8_t t;   
    298          	SDA_OUT(); 	    
   \   00000004   0x....             LDR.N    R0,??DataTable9_1  ;; 0x40010c00
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0xF021 0x4170      BIC      R1,R1,#0xF0000000
   \   0000000C   0x6001             STR      R1,[R0, #+0]
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
   \   00000010   0xF041 0x5140      ORR      R1,R1,#0x30000000
   \   00000014   0x6001             STR      R1,[R0, #+0]
    299              IIC_SCL=0;//@@@@@@@@@@
   \   00000016   0x....             LDR.N    R5,??DataTable9_2  ;; 0x42218198
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x6028             STR      R0,[R5, #+0]
    300              for(t=0;t<8;t++)
   \   0000001C   0x4606             MOV      R6,R0
   \   0000001E   0xE016             B.N      ??IIC_Send_Byte_0
    301              {              
    302                  //IIC_SDA=(txd&0x80)>>7;
    303          		if((txd&0x80)>>7)
   \                     ??IIC_Send_Byte_1: (+1)
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0xB2C0             UXTB     R0,R0
   \   00000024   0x09C0             LSRS     R0,R0,#+7
   \   00000026   0x1E40             SUBS     R0,R0,#+1
   \   00000028   0x4180             SBCS     R0,R0,R0
   \   0000002A   0x43C0             MVNS     R0,R0
   \   0000002C   0x0FC0             LSRS     R0,R0,#+31
   \   0000002E   0x6068             STR      R0,[R5, #+4]
    304          			IIC_SDA=1;
    305          		else
    306          			IIC_SDA=0;
    307          		txd<<=1; 	  
   \   00000030   0x0064             LSLS     R4,R4,#+1
    308          		delay_us(2);   //@TEA5767@@@@@@@@@@
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0x.... 0x....      BL       _Z8delay_usj
    309          		IIC_SCL=1;
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0x6028             STR      R0,[R5, #+0]
    310          		delay_us(2); 
   \   0000003C   0x2002             MOVS     R0,#+2
   \   0000003E   0x.... 0x....      BL       _Z8delay_usj
    311          		IIC_SCL=0;	
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x6028             STR      R0,[R5, #+0]
    312          		delay_us(2);
   \   00000046   0x2002             MOVS     R0,#+2
   \   00000048   0x.... 0x....      BL       _Z8delay_usj
    313              }	 
   \   0000004C   0x1C76             ADDS     R6,R6,#+1
   \                     ??IIC_Send_Byte_0: (+1)
   \   0000004E   0x4630             MOV      R0,R6
   \   00000050   0xB2C0             UXTB     R0,R0
   \   00000052   0x2808             CMP      R0,#+8
   \   00000054   0xDBE4             BLT.N    ??IIC_Send_Byte_1
    314          } 	    
   \   00000056   0xBD70             POP      {R4-R6,PC}       ;; return
    315          //@1@@@@ack=1@@@@ACK@ack=0@@@nACK   

   \                                 In section .text, align 2, keep-with-next
    316          uint8_t IIC_Read_Byte(unsigned char ack)
    317          {
   \                     IIC_Read_Byte: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    318          	unsigned char i,receive=0;
   \   00000004   0x2500             MOVS     R5,#+0
    319          	SDA_IN();//SDA@@@@@
   \   00000006   0x....             LDR.N    R0,??DataTable9_1  ;; 0x40010c00
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0xF021 0x4170      BIC      R1,R1,#0xF0000000
   \   0000000E   0x6001             STR      R1,[R0, #+0]
   \   00000010   0x6801             LDR      R1,[R0, #+0]
   \   00000012   0xF041 0x4100      ORR      R1,R1,#0x80000000
   \   00000016   0x6001             STR      R1,[R0, #+0]
    320              for(i=0;i<8;i++ )
   \   00000018   0x462E             MOV      R6,R5
   \   0000001A   0x....             LDR.N    R7,??DataTable9_4  ;; 0x4221811c
   \   0000001C   0xE00F             B.N      ??IIC_Read_Byte_0
    321          	{
    322                  IIC_SCL=0; 
   \                     ??IIC_Read_Byte_1: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x67F8             STR      R0,[R7, #+124]
    323                  delay_us(2);
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0x.... 0x....      BL       _Z8delay_usj
    324          		IIC_SCL=1;
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x67F8             STR      R0,[R7, #+124]
    325                  receive<<=1;
   \   0000002C   0x006D             LSLS     R5,R5,#+1
    326                  if(READ_SDA)receive++;   
   \   0000002E   0x6838             LDR      R0,[R7, #+0]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD000             BEQ.N    ??IIC_Read_Byte_2
   \   00000034   0x1C6D             ADDS     R5,R5,#+1
    327          		delay_us(1); 
   \                     ??IIC_Read_Byte_2: (+1)
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x.... 0x....      BL       _Z8delay_usj
    328              }					 
   \   0000003C   0x1C76             ADDS     R6,R6,#+1
   \                     ??IIC_Read_Byte_0: (+1)
   \   0000003E   0x4630             MOV      R0,R6
   \   00000040   0xB2C0             UXTB     R0,R0
   \   00000042   0x2808             CMP      R0,#+8
   \   00000044   0xDBEB             BLT.N    ??IIC_Read_Byte_1
    329              if (!ack)
   \   00000046   0x2C00             CMP      R4,#+0
   \   00000048   0xD102             BNE.N    ??IIC_Read_Byte_3
    330                  IIC_NAck();//@@nACK
   \   0000004A   0x.... 0x....      BL       IIC_NAck
   \   0000004E   0xE001             B.N      ??IIC_Read_Byte_4
    331              else
    332                  IIC_Ack(); //@@ACK   
   \                     ??IIC_Read_Byte_3: (+1)
   \   00000050   0x.... 0x....      BL       IIC_Ack
    333              return receive;
   \                     ??IIC_Read_Byte_4: (+1)
   \   00000054   0x4628             MOV      R0,R5
   \   00000056   0xB2C0             UXTB     R0,R0
   \   00000058   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    334          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     delayCnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x40010C00         DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x42218198         DC32     0x42218198

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x4221819C         DC32     0x4221819c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x4221811C         DC32     0x4221811c
    335          
    336          /*--------------------------MKS EEPROM-------------------------*/
    337          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   AT24CXX_Check
         8   -> AT24CXX_ReadOneByte
         8   -> AT24CXX_WriteOneByte
       0   AT24CXX_Init
         0   -> IIC_Init
      16   AT24CXX_Read
        16   -> AT24CXX_ReadOneByte
      24   AT24CXX_ReadLenByte
        24   -> AT24CXX_ReadOneByte
       8   AT24CXX_ReadOneByte
         8   -> IIC_Read_Byte
         8   -> IIC_Send_Byte
         8   -> IIC_Start
         8   -> IIC_Stop
         8   -> IIC_Wait_Ack
      16   AT24CXX_Write
        16   -> AT24CXX_WriteOneByte
      24   AT24CXX_WriteLenByte
        24   -> AT24CXX_WriteOneByte
      16   AT24CXX_WriteOneByte
        16   -> IIC_Send_Byte
        16   -> IIC_Start
        16   -> IIC_Stop
        16   -> IIC_Wait_Ack
         0   -> delay_ms(uint16_t)
       8   IIC_Ack
         8   -> delay_us(uint32_t)
      24   IIC_Init
        24   -> HAL_GPIO_Init
        24   -> HAL_GPIO_WritePin
       8   IIC_NAck
         8   -> delay_us(uint32_t)
      24   IIC_Read_Byte
        24   -> IIC_Ack
        24   -> IIC_NAck
        24   -> delay_us(uint32_t)
      16   IIC_Send_Byte
        16   -> delay_us(uint32_t)
       8   IIC_Start
         8   -> delay_us(uint32_t)
       8   IIC_Stop
         0   -> delay_us(uint32_t)
         8   -> delay_us(uint32_t)
      16   IIC_Wait_Ack
        16   -> IIC_Stop
        16   -> delay_us(uint32_t)
       0   delay_ms(uint16_t)
       0   delay_us(uint32_t)


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
      42  AT24CXX_Check
       2  AT24CXX_Init
      30  AT24CXX_Read
      50  AT24CXX_ReadLenByte
      68  AT24CXX_ReadOneByte
      34  AT24CXX_Write
      40  AT24CXX_WriteLenByte
      62  AT24CXX_WriteOneByte
      52  IIC_Ack
      34  IIC_Init
      52  IIC_NAck
      90  IIC_Read_Byte
      88  IIC_Send_Byte
      50  IIC_Start
      48  IIC_Stop
      72  IIC_Wait_Ack
       2  delayCnt
      32  delay_ms(uint16_t)
      28  delay_us(uint32_t)

 
   2 bytes in section .bss
 894 bytes in section .text
 
 894 bytes of CODE memory
   2 bytes of DATA memory

Errors: none
Warnings: 1
