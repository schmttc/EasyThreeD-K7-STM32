###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.1.114/W32 for ARM         07/Apr/2021  11:05:08
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\Sd2Card.cpp
#    Command line =  
#        -f C:\Users\PLT\AppData\Local\Temp\EW91A2.tmp
#        (C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\Sd2Card.cpp
#        -D USE_HAL_DRIVER -D STM32F103xE -D MKS_ROBIN -D MARLIN -D __arm__ -D
#        USE_MKS_WIFI --preprocess=s
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List -lC
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List -lA
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List
#        --diag_suppress Pa050 -o
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.1\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Inc\ -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Src\ -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/Inc\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/CMSIS/Include\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/STM32MKS-3dPrinter\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/Common\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/l6474\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Drivers/BSP/MotorControl\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/Third_Party/u8glib_arm_v1.17/src\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/arduino\
#        -I
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Middlewares/arduino/avr\
#        -I C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM/../Inc/Logo\ -Om --c++
#        --no_exceptions --no_rtti -I "D:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.1\arm\CMSIS\Core\Include\" -I "D:\Program
#        Files (x86)\IAR Systems\Embedded Workbench
#        8.1\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\List\Sd2Card.lst
#    Object file  =  
#        C:\Users\PLT\Desktop\mksRobinLite_nano\EWARM\mksRobinLite\Obj\Sd2Card.o
#
###############################################################################

C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\Sd2Card.cpp
      1          /**
      2           * Marlin 3D Printer Firmware
      3           * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
      4           *
      5           * Based on Sprinter and grbl.
      6           * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
      7           *
      8           * This program is free software: you can redistribute it and/or modify
      9           * it under the terms of the GNU General Public License as published by
     10           * the Free Software Foundation, either version 3 of the License, or
     11           * (at your option) any later version.
     12           *
     13           * This program is distributed in the hope that it will be useful,
     14           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     15           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     16           * GNU General Public License for more details.
     17           *
     18           * You should have received a copy of the GNU General Public License
     19           * along with this program.  If not, see <http://www.gnu.org/licenses/>.
     20           *
     21           */
     22          
     23          /**
     24           * Arduino Sd2Card Library
     25           * Copyright (C) 2009 by William Greiman
     26           *
     27           * This file is part of the Arduino Sd2Card Library
     28           */
     29          #include "Marlin.h"

    #define SDSS   18
            ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marlin\pins_MKS_ROBIN_LITE.h",161  Warning[Pa181]: 
          incompatible redefinition of macro "SDSS" (declared at line 62)

  #define UNUSED(x) ((void)(x))
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_def.h",87  Warning[Pa181]: 
          incompatible redefinition of macro "UNUSED" (declared at line 88 of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Middlewares\Third_Party\Marl
          in\macros.h")

  #define PRINT_LED_PIN         PDout(2)
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\BSP\STM32MKS-3dPrinter\mks_fastio.h",14  Warning[Pa181]: 
          incompatible redefinition of macro "PRINT_LED_PIN" (declared at line
          146 of "C:\Users\PLT\Desktop\mksRobinLite_nano\Inc\main.h")
     30          #include "stm32f10x_spi.h"

  #define IS_SPI_DIRECTION_MODE(MODE) (((MODE) == SPI_Direction_2Lines_FullDuplex) || \
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\STM32F10x_StdPeriph_Driver\Inc\stm32f10x_spi.h",132  Warning[Pa181]: 
          incompatible redefinition of macro "IS_SPI_DIRECTION_MODE" (declared
          at line 466 of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\STM32F1xx_HAL_Driver
          \Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_MODE(MODE) (((MODE) == SPI_Mode_Master) || \
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\STM32F10x_StdPeriph_Driver\Inc\stm32f10x_spi.h",146  Warning[Pa181]: 
          incompatible redefinition of macro "IS_SPI_MODE" (declared at line
          459 of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\STM32F1xx_HAL_Driver
          \Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_DATASIZE(DATASIZE) (((DATASIZE) == SPI_DataSize_16b) || \
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\STM32F10x_StdPeriph_Driver\Inc\stm32f10x_spi.h",158  Warning[Pa181]: 
          incompatible redefinition of macro "IS_SPI_DATASIZE" (declared at
          line 488 of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\STM32F1xx_HAL_Driver
          \Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_CPOL(CPOL) (((CPOL) == SPI_CPOL_Low) || \
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\STM32F10x_StdPeriph_Driver\Inc\stm32f10x_spi.h",170  Warning[Pa181]: 
          incompatible redefinition of macro "IS_SPI_CPOL" (declared at line
          496 of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\STM32F1xx_HAL_Driver
          \Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_CPHA(CPHA) (((CPHA) == SPI_CPHA_1Edge) || \
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\STM32F10x_StdPeriph_Driver\Inc\stm32f10x_spi.h",182  Warning[Pa181]: 
          incompatible redefinition of macro "IS_SPI_CPHA" (declared at line
          504 of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\STM32F1xx_HAL_Driver
          \Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_NSS(NSS) (((NSS) == SPI_NSS_Soft) || \
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\STM32F10x_StdPeriph_Driver\Inc\stm32f10x_spi.h",194  Warning[Pa181]: 
          incompatible redefinition of macro "IS_SPI_NSS" (declared at line 512
          of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\STM32F1xx_HAL_Driver
          \Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_BAUDRATE_PRESCALER(PRESCALER) (((PRESCALER) == SPI_BaudRatePrescaler_2) || \
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\STM32F10x_StdPeriph_Driver\Inc\stm32f10x_spi.h",212  Warning[Pa181]: 
          incompatible redefinition of macro "IS_SPI_BAUDRATE_PRESCALER"
          (declared at line 521 of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\STM32F1xx_HAL_Driver
          \Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_FIRST_BIT(BIT) (((BIT) == SPI_FirstBit_MSB) || \
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\STM32F10x_StdPeriph_Driver\Inc\stm32f10x_spi.h",230  Warning[Pa181]: 
          incompatible redefinition of macro "IS_SPI_FIRST_BIT" (declared at
          line 535 of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\STM32F1xx_HAL_Driver
          \Inc\stm32f1xx_hal_spi.h")

  #define SPI_FLAG_CRCERR                 ((uint16_t)0x0010)
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\STM32F10x_StdPeriph_Driver\Inc\stm32f10x_spi.h",408  Warning[Pa181]: 
          incompatible redefinition of macro "SPI_FLAG_CRCERR" (declared at
          line 308 of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\STM32F1xx_HAL_Driver
          \Inc\stm32f1xx_hal_spi.h")

  #define SPI_FLAG_MODF                   ((uint16_t)0x0020)
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\STM32F10x_StdPeriph_Driver\Inc\stm32f10x_spi.h",409  Warning[Pa181]: 
          incompatible redefinition of macro "SPI_FLAG_MODF" (declared at line
          309 of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\STM32F1xx_HAL_Driver
          \Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_CRC_POLYNOMIAL(POLYNOMIAL) ((POLYNOMIAL) >= 0x1)
          ^
"C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\STM32F10x_StdPeriph_Driver\Inc\stm32f10x_spi.h",425  Warning[Pa181]: 
          incompatible redefinition of macro "IS_SPI_CRC_POLYNOMIAL" (declared
          at line 558 of
          "C:\Users\PLT\Desktop\mksRobinLite_nano\Drivers\STM32F1xx_HAL_Driver
          \Inc\stm32f1xx_hal_spi.h")
     31          #include"spi.h"
     32          
     33          #define SPDR SPI2->DR
     34          
     35          #if ENABLED(SDSUPPORT)
     36          #include "Sd2Card.h"

   \                                 In section .text, align 2
   \   __interwork __softfp void Sd2Card::error(uint8_t)
   \                     _ZN7Sd2Card5errorEh: (+1)
   \        0x0   0x7041             STRB     R1,[R0, #+1]
   \        0x2   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp bool Sd2Card::readCSD(csd_t *)
   \                     _ZN7Sd2Card7readCSDEP5csd_t: (+1)
   \        0x0   0x460A             MOV      R2,R1
   \        0x2   0x2109             MOVS     R1,#+9
   \        0x4   0x.... 0x....      B.W      _ZN7Sd2Card12readRegisterEhPv

   \                                 In section .text, align 2
   \   __interwork __softfp int Sd2Card::type() const
   \                     _ZNK7Sd2Card4typeEv: (+1)
   \        0x0   0x7900             LDRB     R0,[R0, #+4]
   \        0x2   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint8_t Sd2Card::cardAcmd(uint8_t, uint32_t)
   \                     _ZN7Sd2Card8cardAcmdEhj: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
   \        0x8   0x2200             MOVS     R2,#+0
   \        0xA   0x2137             MOVS     R1,#+55
   \        0xC   0x.... 0x....      BL       _ZN7Sd2Card11cardCommandEhj
   \       0x10   0x4632             MOV      R2,R6
   \       0x12   0x4629             MOV      R1,R5
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x1A   0x.... 0x....      B.W      _ZN7Sd2Card11cardCommandEhj

   \                                 In section .text, align 2
   \   __interwork __softfp void Sd2Card::type(uint8_t)
   \                     _ZN7Sd2Card4typeEh: (+1)
   \        0x0   0x7101             STRB     R1,[R0, #+4]
   \        0x2   0x4770             BX       LR               ;; return
     37          
     38          #if ENABLED(USE_WATCHDOG)
     39            #include "watchdog.h"
     40          #endif
     41          
     42          //------------------------------------------------------------------------------
     43          #if DISABLED(SOFTWARE_SPI)
     44            // functions for hardware SPI
     45            //------------------------------------------------------------------------------
     46            // make sure SPCR rate is in expected bits
     47          /*  #if (SPR0 != 0 || SPR1 != 1)
     48              #error "unexpected SPCR bits"
     49            #endif
     50            */	/*--mks--*/
     51            /**
     52             * Initialize hardware SPI
     53             * Set SCK rate to F_CPU/pow(2, 1 + spiRate) for spiRate [0,6]
     54             */

   \                                 In section .text, align 2, keep-with-next
     55            static void spiInit(uint8_t spiRate) {
   \                     _ZN33_INTERNAL_11_Sd2Card_cpp_f61128977spiInitEh: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
     56              // See avr processor documentation
     57              //SPCR = _BV(SPE) | _BV(MSTR) | (spiRate >> 1);	/*--mks--*/
     58              //SPSR = spiRate & 1 || spiRate == 6 ? 0 : _BV(SPI2X);
     59          	uint8_t rate_table[8]={SPI_BAUDRATEPRESCALER_2,SPI_BAUDRATEPRESCALER_4,SPI_BAUDRATEPRESCALER_8,SPI_BAUDRATEPRESCALER_16,SPI_BAUDRATEPRESCALER_32,SPI_BAUDRATEPRESCALER_64,SPI_BAUDRATEPRESCALER_128,SPI_BAUDRATEPRESCALER_256};
   \        0x2   0x4669             MOV      R1,SP
   \        0x4   0x.... 0x....      ADR.W    R2,?_0
   \        0x8   0xE9D2 0x3400      LDRD     R3,R4,[R2, #+0]
   \        0xC   0xE9C1 0x3400      STRD     R3,R4,[R1, #+0]
     60          	SPI2_SetSpeed(rate_table[spiRate]);
   \       0x10   0x5C08             LDRB     R0,[R1, R0]
   \       0x12   0x.... 0x....      BL       SPI2_SetSpeed
     61          	
     62            }
   \       0x16   0xBD13             POP      {R0,R1,R4,PC}    ;; return
     63            //------------------------------------------------------------------------------
     64            /** SPI receive a byte */

   \                                 In section .text, align 2, keep-with-next
     65            static uint8_t spiRec() {	/*--mks--*/
   \                     _ZN33_INTERNAL_11_Sd2Card_cpp_f61128976spiRecEv: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
     66          	  SPI2->DR = 0XFF;//SPI2->DR = 0XFF;  //SPDR = 0XFF;
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable8  ;; 0x40003800
   \        0x6   0x20FF             MOVS     R0,#+255
   \        0x8   0x60E0             STR      R0,[R4, #+12]
     67          	   while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_RXNE) == RESET){} //|━：：??y?：?：o?：a：o：＜???byte  
   \                     ??spiRec_0: (+1)
   \        0xA   0x2101             MOVS     R1,#+1
   \        0xC   0x4620             MOV      R0,R4
   \        0xE   0x.... 0x....      BL       SPI_I2S_GetFlagStatus
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD0F9             BEQ.N    ??spiRec_0
     68          	  return SPI2->DR;
   \       0x16   0x68E0             LDR      R0,[R4, #+12]
   \       0x18   0xB2C0             UXTB     R0,R0
   \       0x1A   0xBD10             POP      {R4,PC}          ;; return
     69            }
     70            //------------------------------------------------------------------------------
     71            /** SPI read data - only one call so force inline */
     72            //  static inline __attribute__((always_inline))
     73            //  void spiRead(uint8_t* buf, uint16_t nbyte) {

   \                                 In section .text, align 2, keep-with-next
     74          	static inline  void spiRead(uint8_t* buf, uint16_t nbyte) {
   \                     _ZN33_INTERNAL_11_Sd2Card_cpp_f61128977spiReadEPht: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
     75          		if (nbyte-- == 0) return;
   \        0x2   0x1E4A             SUBS     R2,R1,#+1
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD11A             BNE.N    ??spiRead_0
   \        0x8   0xE017             B.N      ??spiRead_1
     76          		while((SPI2->SR &SPI_I2S_FLAG_TXE)==RESET); //|━：：??y?∴?└?：a???? 
     77          		SPI2->DR = 0XFF;
     78          		for (uint16_t i = 0; i < nbyte; i++) 
     79          			{
     80          			while((SPI2->SR &SPI_I2S_FLAG_RXNE)==RESET);//|━：：??y?：?：o?：a：o：＜???byte
   \                     ??spiRead_2: (+1)
   \        0xA   0x681D             LDR      R5,[R3, #+0]
   \        0xC   0x07ED             LSLS     R5,R5,#+31
   \        0xE   0xD5FC             BPL.N    ??spiRead_2
     81          			buf[i] = SPI2->DR;
   \       0x10   0x685D             LDR      R5,[R3, #+4]
   \       0x12   0x4626             MOV      R6,R4
   \       0x14   0xB2B6             UXTH     R6,R6
   \       0x16   0x5585             STRB     R5,[R0, R6]
     82          			while((SPI2->SR &SPI_I2S_FLAG_TXE)==RESET); //|━：：??y?∴?└?：a???? 
   \                     ??spiRead_3: (+1)
   \       0x18   0x681D             LDR      R5,[R3, #+0]
   \       0x1A   0x07AD             LSLS     R5,R5,#+30
   \       0x1C   0xD5FC             BPL.N    ??spiRead_3
     83          			SPI2->DR = 0XFF;
   \       0x1E   0x6059             STR      R1,[R3, #+4]
     84          		}
   \       0x20   0x1C64             ADDS     R4,R4,#+1
   \                     ??spiRead_4: (+1)
   \       0x22   0x4625             MOV      R5,R4
   \       0x24   0x4616             MOV      R6,R2
   \       0x26   0xB2AD             UXTH     R5,R5
   \       0x28   0xB2B6             UXTH     R6,R6
   \       0x2A   0x42B5             CMP      R5,R6
   \       0x2C   0xD3ED             BCC.N    ??spiRead_2
     85          		while((SPI2->SR &SPI_I2S_FLAG_RXNE)==RESET);//|━：：??y?：?：o?：a：o：＜???byte
   \                     ??spiRead_5: (+1)
   \       0x2E   0x681C             LDR      R4,[R3, #+0]
   \       0x30   0x07E4             LSLS     R4,R4,#+31
   \       0x32   0xD5FC             BPL.N    ??spiRead_5
     86          		buf[nbyte] = SPI2->DR;
   \       0x34   0x685B             LDR      R3,[R3, #+4]
   \       0x36   0xB292             UXTH     R2,R2
   \       0x38   0x5483             STRB     R3,[R0, R2]
     87          	}
   \                     ??spiRead_1: (+1)
   \       0x3A   0xBC70             POP      {R4-R6}
   \       0x3C   0x4770             BX       LR               ;; return
   \                     ??spiRead_0: (+1)
   \       0x3E   0x.... 0x....      LDR.W    R3,??DataTable8_1  ;; 0x40003808
   \       0x42   0x681C             LDR      R4,[R3, #+0]
   \       0x44   0x07A4             LSLS     R4,R4,#+30
   \       0x46   0xD5FA             BPL.N    ??spiRead_0
   \       0x48   0x24FF             MOVS     R4,#+255
   \       0x4A   0x4621             MOV      R1,R4
   \       0x4C   0x6059             STR      R1,[R3, #+4]
   \       0x4E   0x2400             MOVS     R4,#+0
   \       0x50   0xE7E7             B.N      ??spiRead_4
     88            //------------------------------------------------------------------------------
     89            /** SPI send a byte */
     90            //  static void spiSend(uint8_t b) {	  /*--mks--*/

   \                                 In section .text, align 2, keep-with-next
     91            void spiSend(uint8_t b) { 	  
   \                     _Z7spiSendh: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable8_1  ;; 0x40003808
     92          		uint8_t tempData;
                 		        ^
Warning[Pe550]: variable "tempData" was set but never used
     93          		
     94          		while((SPI2->SR &SPI_I2S_FLAG_TXE)==RESET); //|━：：??y?∴?└?：a???? 
   \                     ??spiSend_0: (+1)
   \        0x4   0x680A             LDR      R2,[R1, #+0]
   \        0x6   0x0792             LSLS     R2,R2,#+30
   \        0x8   0xD5FC             BPL.N    ??spiSend_0
     95          		SPI2->DR = b;
   \        0xA   0x6048             STR      R0,[R1, #+4]
     96          		while((SPI2->SR &SPI_I2S_FLAG_RXNE)==RESET);//|━：：??y?：?：o?：a：o：＜???byte	
   \                     ??spiSend_1: (+1)
   \        0xC   0x6808             LDR      R0,[R1, #+0]
   \        0xE   0x07C0             LSLS     R0,R0,#+31
   \       0x10   0xD5FC             BPL.N    ??spiSend_1
     97          		tempData = SPI2->DR; 
   \       0x12   0x6848             LDR      R0,[R1, #+4]
     98          	}
   \       0x14   0x4770             BX       LR               ;; return
     99            //------------------------------------------------------------------------------
    100            /** SPI send block - only one call so force inline */  /*--mks--*/

   \                                 In section .text, align 2, keep-with-next
    101            static inline void spiSendBlock(uint8_t token, const uint8_t* buf) {	
   \                     _ZN33_INTERNAL_11_Sd2Card_cpp_f611289712spiSendBlockEhPKh: (+1)
   \        0x0   0x.... 0x....      LDR.W    R2,??DataTable8_1  ;; 0x40003808
    102          	  uint8_t tempData;
                 	          ^
Warning[Pe550]: variable "tempData" was set but never used
    103          	  
    104          	  while((SPI2->SR &SPI_I2S_FLAG_TXE)==RESET); //|━：：??y?∴?└?：a???? 
   \                     ??spiSendBlock_0: (+1)
   \        0x4   0x6813             LDR      R3,[R2, #+0]
   \        0x6   0x079B             LSLS     R3,R3,#+30
   \        0x8   0xD5FC             BPL.N    ??spiSendBlock_0
    105          	  SPI2->DR = token;
   \        0xA   0x6050             STR      R0,[R2, #+4]
    106          	  while((SPI2->SR &SPI_I2S_FLAG_RXNE)==RESET);//|━：：??y?：?：o?：a：o：＜???byte	  
   \                     ??spiSendBlock_1: (+1)
   \        0xC   0x6810             LDR      R0,[R2, #+0]
   \        0xE   0x07C0             LSLS     R0,R0,#+31
   \       0x10   0xD5FC             BPL.N    ??spiSendBlock_1
    107          	  tempData = SPI2->DR; 
   \       0x12   0x6850             LDR      R0,[R2, #+4]
    108          	  for (uint16_t i = 0; i < 512; i += 2) 
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xE013             B.N      ??spiSendBlock_2
    109          		  {
    110          		  while((SPI2->SR &SPI_I2S_FLAG_TXE)==RESET); //|━：：??y?∴?└?：a???? 
   \                     ??spiSendBlock_3: (+1)
   \       0x18   0x6813             LDR      R3,[R2, #+0]
   \       0x1A   0x079B             LSLS     R3,R3,#+30
   \       0x1C   0xD5FC             BPL.N    ??spiSendBlock_3
    111          		  SPI2->DR = buf[i];
   \       0x1E   0x5C0B             LDRB     R3,[R1, R0]
   \       0x20   0x6053             STR      R3,[R2, #+4]
    112          		  while((SPI2->SR &SPI_I2S_FLAG_RXNE)==RESET);//|━：：??y?：?：o?：a：o：＜???byte	  
   \                     ??spiSendBlock_4: (+1)
   \       0x22   0x6813             LDR      R3,[R2, #+0]
   \       0x24   0x07DB             LSLS     R3,R3,#+31
   \       0x26   0xD5FC             BPL.N    ??spiSendBlock_4
    113          		  tempData = SPI2->DR; 
   \       0x28   0x6853             LDR      R3,[R2, #+4]
    114          		  
    115          		  while((SPI2->SR &SPI_I2S_FLAG_TXE)==RESET); //|━：：??y?∴?└?：a???? 
   \                     ??spiSendBlock_5: (+1)
   \       0x2A   0x6813             LDR      R3,[R2, #+0]
   \       0x2C   0x079B             LSLS     R3,R3,#+30
   \       0x2E   0xD5FC             BPL.N    ??spiSendBlock_5
    116          		  SPI2->DR = buf[i + 1];
   \       0x30   0x180B             ADDS     R3,R1,R0
   \       0x32   0x785B             LDRB     R3,[R3, #+1]
   \       0x34   0x6053             STR      R3,[R2, #+4]
    117          		  while((SPI2->SR &SPI_I2S_FLAG_RXNE)==RESET);//|━：：??y?：?：o?：a：o：＜???byte	  
   \                     ??spiSendBlock_6: (+1)
   \       0x36   0x6813             LDR      R3,[R2, #+0]
   \       0x38   0x07DB             LSLS     R3,R3,#+31
   \       0x3A   0xD5FC             BPL.N    ??spiSendBlock_6
    118          		  tempData = SPI2->DR; 
   \       0x3C   0x6853             LDR      R3,[R2, #+4]
    119          		  }
   \       0x3E   0x1C80             ADDS     R0,R0,#+2
   \                     ??spiSendBlock_2: (+1)
   \       0x40   0xF5B0 0x7F00      CMP      R0,#+512
   \       0x44   0xDBE8             BLT.N    ??spiSendBlock_3
    120          		  while((SPI2->SR &SPI_I2S_FLAG_TXE)==RESET); //|━：：??y?∴?└?：a???? 
   \                     ??spiSendBlock_7: (+1)
   \       0x46   0x6810             LDR      R0,[R2, #+0]
   \       0x48   0x0780             LSLS     R0,R0,#+30
   \       0x4A   0xD5FC             BPL.N    ??spiSendBlock_7
    121          
    122            }
   \       0x4C   0x4770             BX       LR               ;; return
    123                 //------------------------------------------------------------------------------
    124          #else  // SOFTWARE_SPI
    125                 //------------------------------------------------------------------------------
    126            /** nop to tune soft SPI timing */
    127            #define nop asm volatile ("nop\n\t")
    128            //------------------------------------------------------------------------------
    129            /** Soft SPI receive byte */
    130            static uint8_t spiRec() {
    131              uint8_t data = 0;
    132              // no interrupts during byte receive - about 8 us
    133              cli();
    134              // output pin high - like sending 0XFF
    135              WRITE(SPI_MOSI_PIN, HIGH);
    136          
    137              for (uint8_t i = 0; i < 8; i++) {
    138                WRITE(SPI_SCK_PIN, HIGH);
    139          
    140                // adjust so SCK is nice
    141                nop;
    142                nop;
    143          
    144                data <<= 1;
    145          
    146                if (READ(SPI_MISO_PIN)) data |= 1;
    147          
    148                WRITE(SPI_SCK_PIN, LOW);
    149              }
    150              // enable interrupts
    151              sei();
    152              return data;
    153            }
    154            //------------------------------------------------------------------------------
    155            /** Soft SPI read data */
    156            static void spiRead(uint8_t* buf, uint16_t nbyte) {
    157              for (uint16_t i = 0; i < nbyte; i++)
    158                buf[i] = spiRec();
    159            }
    160            //------------------------------------------------------------------------------
    161            /** Soft SPI send byte */
    162            static void spiSend(uint8_t data) {
    163              // no interrupts during byte send - about 8 us
    164              cli();
    165              for (uint8_t i = 0; i < 8; i++) {
    166                WRITE(SPI_SCK_PIN, LOW);
    167          
    168                WRITE(SPI_MOSI_PIN, data & 0X80);
    169          
    170                data <<= 1;
    171          
    172                WRITE(SPI_SCK_PIN, HIGH);
    173              }
    174              // hold SCK high for a few ns
    175              nop;
    176              nop;
    177              nop;
    178              nop;
    179          
    180              WRITE(SPI_SCK_PIN, LOW);
    181              // enable interrupts
    182              sei();
    183            }
    184            //------------------------------------------------------------------------------
    185            /** Soft SPI send block */
    186            void spiSendBlock(uint8_t token, const uint8_t* buf) {
    187              spiSend(token);
    188              for (uint16_t i = 0; i < 512; i++)
    189                spiSend(buf[i]);
    190            }
    191          #endif  // SOFTWARE_SPI
    192          //------------------------------------------------------------------------------
    193          // send command and return error code.  Return zero for OK

   \                                 In section .text, align 2, keep-with-next
    194          uint8_t Sd2Card::cardCommand(uint8_t cmd, uint32_t arg) {
   \                     _ZN7Sd2Card11cardCommandEhj: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
    195            // select card
    196            chipSelectLow();
   \        0x8   0x.... 0x....      BL       _ZN7Sd2Card13chipSelectLowEv
    197          
    198            // wait up to 300 ms if busy
    199            waitNotBusy(300);
   \        0xC   0xF44F 0x7196      MOV      R1,#+300
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0x.... 0x....      BL       _ZN7Sd2Card11waitNotBusyEt
    200          
    201            // send command
    202            spiSend(cmd | 0x40);
   \       0x16   0xF045 0x0040      ORR      R0,R5,#0x40
   \       0x1A   0x.... 0x....      BL       _Z7spiSendh
    203          
    204            // send argument
    205            for (int8_t s = 24; s >= 0; s -= 8) spiSend(arg >> s);
   \       0x1E   0x2718             MOVS     R7,#+24
   \       0x20   0xE005             B.N      ??cardCommand_0
   \                     ??cardCommand_1: (+1)
   \       0x22   0x4630             MOV      R0,R6
   \       0x24   0x40F8             LSRS     R0,R0,R7
   \       0x26   0xB2C0             UXTB     R0,R0
   \       0x28   0x.... 0x....      BL       _Z7spiSendh
   \       0x2C   0x3F08             SUBS     R7,R7,#+8
   \                     ??cardCommand_0: (+1)
   \       0x2E   0x4638             MOV      R0,R7
   \       0x30   0xB240             SXTB     R0,R0
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD5F5             BPL.N    ??cardCommand_1
    206          
    207            // send CRC
    208            uint8_t crc = 0XFF;
   \       0x36   0x20FF             MOVS     R0,#+255
    209            if (cmd == CMD0) crc = 0X95;  // correct crc for CMD0 with arg 0
   \       0x38   0x0029             MOVS     R1,R5
   \       0x3A   0xD100             BNE.N    ??cardCommand_2
   \       0x3C   0x2095             MOVS     R0,#+149
    210            if (cmd == CMD8) crc = 0X87;  // correct crc for CMD8 with arg 0X1AA
   \                     ??cardCommand_2: (+1)
   \       0x3E   0x2908             CMP      R1,#+8
   \       0x40   0xD100             BNE.N    ??cardCommand_3
   \       0x42   0x2087             MOVS     R0,#+135
    211            spiSend(crc);
   \                     ??cardCommand_3: (+1)
   \       0x44   0x.... 0x....      BL       _Z7spiSendh
    212          
    213            // skip stuff byte for stop read
    214            if (cmd == CMD12) spiRec();
   \       0x48   0x2D0C             CMP      R5,#+12
   \       0x4A   0xD101             BNE.N    ??cardCommand_4
   \       0x4C   0x.... 0x....      BL       _ZN33_INTERNAL_11_Sd2Card_cpp_f61128976spiRecEv
    215          
    216            // wait for response
    217            for (uint8_t i = 0; ((status_ = spiRec()) & 0X80) && i != 0XFF; i++) { /* Intentionally left empty */ }
   \                     ??cardCommand_4: (+1)
   \       0x50   0x2500             MOVS     R5,#+0
   \                     ??cardCommand_5: (+1)
   \       0x52   0x.... 0x....      BL       _ZN33_INTERNAL_11_Sd2Card_cpp_f61128976spiRecEv
   \       0x56   0x70E0             STRB     R0,[R4, #+3]
   \       0x58   0x0601             LSLS     R1,R0,#+24
   \       0x5A   0xD505             BPL.N    ??cardCommand_6
   \       0x5C   0x4629             MOV      R1,R5
   \       0x5E   0xB2C9             UXTB     R1,R1
   \       0x60   0x29FF             CMP      R1,#+255
   \       0x62   0xD001             BEQ.N    ??cardCommand_6
   \       0x64   0x1C6D             ADDS     R5,R5,#+1
   \       0x66   0xE7F4             B.N      ??cardCommand_5
    218            return status_;
   \                     ??cardCommand_6: (+1)
   \       0x68   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    219          }
    220          //------------------------------------------------------------------------------
    221          /**
    222           * Determine the size of an SD flash memory card.
    223           *
    224           * \return The number of 512 byte data blocks in the card
    225           *         or zero if an error occurs.
    226           */

   \                                 In section .text, align 2, keep-with-next
    227          uint32_t Sd2Card::cardSize() {
   \                     _ZN7Sd2Card8cardSizeEv: (+1)
   \        0x0   0xB51F             PUSH     {R0-R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    228            csd_t csd;
    229            if (!readCSD(&csd)) return 0;
   \        0x4   0x4669             MOV      R1,SP
   \        0x6   0x.... 0x....      BL       _ZN7Sd2Card7readCSDEP5csd_t
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD101             BNE.N    ??cardSize_0
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xE037             B.N      ??cardSize_1
    230            if (csd.v1.csd_ver == 0) {
   \                     ??cardSize_0: (+1)
   \       0x12   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x16   0x0980             LSRS     R0,R0,#+6
   \       0x18   0xD11E             BNE.N    ??cardSize_2
    231              uint8_t read_bl_len = csd.v1.read_bl_len;
    232              uint16_t c_size = (csd.v1.c_size_high << 10)
    233                                | (csd.v1.c_size_mid << 2) | csd.v1.c_size_low;
    234              uint8_t c_size_mult = (csd.v1.c_size_mult_high << 1)
    235                                    | csd.v1.c_size_mult_low;
    236              return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
   \       0x1A   0xF89D 0x1006      LDRB     R1,[SP, #+6]
   \       0x1E   0xF001 0x0103      AND      R1,R1,#0x3
   \       0x22   0xF89D 0x0007      LDRB     R0,[SP, #+7]
   \       0x26   0x0080             LSLS     R0,R0,#+2
   \       0x28   0xEA40 0x2081      ORR      R0,R0,R1, LSL #+10
   \       0x2C   0xF89D 0x1008      LDRB     R1,[SP, #+8]
   \       0x30   0xEA50 0x1091      ORRS     R0,R0,R1, LSR #+6
   \       0x34   0x1C40             ADDS     R0,R0,#+1
   \       0x36   0xF89D 0x1009      LDRB     R1,[SP, #+9]
   \       0x3A   0x0049             LSLS     R1,R1,#+1
   \       0x3C   0xF001 0x0106      AND      R1,R1,#0x6
   \       0x40   0xF89D 0x200A      LDRB     R2,[SP, #+10]
   \       0x44   0xEA41 0x11D2      ORR      R1,R1,R2, LSR #+7
   \       0x48   0xF89D 0x2005      LDRB     R2,[SP, #+5]
   \       0x4C   0xF002 0x020F      AND      R2,R2,#0xF
   \       0x50   0x1851             ADDS     R1,R2,R1
   \       0x52   0x1FC9             SUBS     R1,R1,#+7
   \       0x54   0x4088             LSLS     R0,R0,R1
   \       0x56   0xE014             B.N      ??cardSize_1
    237            }
    238            else if (csd.v2.csd_ver == 1) {
   \                     ??cardSize_2: (+1)
   \       0x58   0x2801             CMP      R0,#+1
   \       0x5A   0xD10D             BNE.N    ??cardSize_3
    239              uint32_t c_size = ((uint32_t)csd.v2.c_size_high << 16)
    240                                | (csd.v2.c_size_mid << 8) | csd.v2.c_size_low;
    241              return (c_size + 1) << 10;
   \       0x5C   0xF89D 0x1007      LDRB     R1,[SP, #+7]
   \       0x60   0x0889             LSRS     R1,R1,#+2
   \       0x62   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \       0x66   0x0200             LSLS     R0,R0,#+8
   \       0x68   0xEA40 0x4001      ORR      R0,R0,R1, LSL #+16
   \       0x6C   0xF89D 0x1009      LDRB     R1,[SP, #+9]
   \       0x70   0x4308             ORRS     R0,R1,R0
   \       0x72   0x1C40             ADDS     R0,R0,#+1
   \       0x74   0x0280             LSLS     R0,R0,#+10
   \       0x76   0xE004             B.N      ??cardSize_1
    242            }
    243            else {
    244              error(SD_CARD_ERROR_BAD_CSD);
   \                     ??cardSize_3: (+1)
   \       0x78   0x210B             MOVS     R1,#+11
   \       0x7A   0x4620             MOV      R0,R4
   \       0x7C   0x.... 0x....      BL       _ZN7Sd2Card5errorEh
    245              return 0;
   \       0x80   0x2000             MOVS     R0,#+0
   \                     ??cardSize_1: (+1)
   \       0x82   0xB004             ADD      SP,SP,#+16
   \       0x84   0xBD10             POP      {R4,PC}          ;; return
    246            }
    247          }
    248          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    249          void Sd2Card::chipSelectHigh() {
    250            //digitalWrite(chipSelectPin_, HIGH);
    251            SD_CS_OP = 1;
   \                     _ZN7Sd2Card14chipSelectHighEv: (+1)
   \        0x0   0x2001             MOVS     R0,#+1
   \        0x2   0x....             LDR.N    R1,??DataTable8_2  ;; 0x422101bc
   \        0x4   0x6008             STR      R0,[R1, #+0]
    252          }
   \        0x6   0x4770             BX       LR               ;; return
    253          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    254          void Sd2Card::chipSelectLow() {
   \                     _ZN7Sd2Card13chipSelectLowEv: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    255            #if DISABLED(SOFTWARE_SPI)
    256              spiInit(spiRate_);
   \        0x2   0x7880             LDRB     R0,[R0, #+2]
   \        0x4   0x.... 0x....      BL       _ZN33_INTERNAL_11_Sd2Card_cpp_f61128977spiInitEh
    257            #endif  // SOFTWARE_SPI
    258          //  digitalWrite(chipSelectPin_, LOW);
    259            SD_CS_OP = 0;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x....             LDR.N    R1,??DataTable8_2  ;; 0x422101bc
   \        0xC   0x6008             STR      R0,[R1, #+0]
    260          }
   \        0xE   0xBD01             POP      {R0,PC}          ;; return
    261          //------------------------------------------------------------------------------
    262          /** Erase a range of blocks.
    263           *
    264           * \param[in] firstBlock The address of the first block in the range.
    265           * \param[in] lastBlock The address of the last block in the range.
    266           *
    267           * \note This function requests the SD card to do a flash erase for a
    268           * range of blocks.  The data on the card after an erase operation is
    269           * either 0 or 1, depends on the card vendor.  The card must support
    270           * single block erase.
    271           *
    272           * \return The value one, true, is returned for success and
    273           * the value zero, false, is returned for failure.
    274           */

   \                                 In section .text, align 2, keep-with-next
    275          bool Sd2Card::erase(uint32_t firstBlock, uint32_t lastBlock) {
   \                     _ZN7Sd2Card5eraseEjj: (+1)
   \        0x0   0xB57F             PUSH     {R0-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
    276            csd_t csd;
    277            if (!readCSD(&csd)) goto fail;
   \        0x8   0x4669             MOV      R1,SP
   \        0xA   0x.... 0x....      BL       _ZN7Sd2Card7readCSDEP5csd_t
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD015             BEQ.N    ??erase_0
    278            // check for single block erase
    279            if (!csd.v1.erase_blk_en) {
   \       0x12   0xF89D 0x000A      LDRB     R0,[SP, #+10]
   \       0x16   0xF3C0 0x1180      UBFX     R1,R0,#+6,#+1
   \       0x1A   0x2900             CMP      R1,#+0
   \       0x1C   0xD115             BNE.N    ??erase_1
    280              // erase size mask
    281              uint8_t m = (csd.v1.sector_size_high << 1) | csd.v1.sector_size_low;
   \       0x1E   0x0040             LSLS     R0,R0,#+1
   \       0x20   0xF000 0x007E      AND      R0,R0,#0x7E
   \       0x24   0xF89D 0x100B      LDRB     R1,[SP, #+11]
   \       0x28   0xEA40 0x10D1      ORR      R0,R0,R1, LSR #+7
    282              if ((firstBlock & m) != 0 || ((lastBlock + 1) & m) != 0) {
   \       0x2C   0x4205             TST      R5,R0
   \       0x2E   0xD102             BNE.N    ??erase_2
   \       0x30   0x1C71             ADDS     R1,R6,#+1
   \       0x32   0x4201             TST      R1,R0
   \       0x34   0xD009             BEQ.N    ??erase_1
    283                // error card can't erase specified area
    284                error(SD_CARD_ERROR_ERASE_SINGLE_BLOCK);
   \                     ??erase_2: (+1)
   \       0x36   0x210D             MOVS     R1,#+13
   \       0x38   0x4620             MOV      R0,R4
   \       0x3A   0x.... 0x....      BL       _ZN7Sd2Card5errorEh
    285                goto fail;
    286              }
    287            }
    288            if (type_ != SD_CARD_TYPE_SDHC) {
    289              firstBlock <<= 9;
    290              lastBlock <<= 9;
    291            }
    292            if (cardCommand(CMD32, firstBlock)
    293                || cardCommand(CMD33, lastBlock)
    294                || cardCommand(CMD38, 0)) {
    295              error(SD_CARD_ERROR_ERASE);
    296              goto fail;
    297            }
    298            if (!waitNotBusy(SD_ERASE_TIMEOUT)) {
    299              error(SD_CARD_ERROR_ERASE_TIMEOUT);
    300              goto fail;
    301            }
    302            chipSelectHigh();
    303            return true;
    304          fail:
    305            chipSelectHigh();
   \                     ??erase_0: (+1)
   \       0x3E   0x4620             MOV      R0,R4
   \       0x40   0x.... 0x....      BL       _ZN7Sd2Card14chipSelectHighEv
    306            return false;
   \       0x44   0x2000             MOVS     R0,#+0
   \                     ??erase_3: (+1)
   \       0x46   0xB004             ADD      SP,SP,#+16
   \       0x48   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??erase_1: (+1)
   \       0x4A   0x7920             LDRB     R0,[R4, #+4]
   \       0x4C   0x2803             CMP      R0,#+3
   \       0x4E   0xD001             BEQ.N    ??erase_4
   \       0x50   0x026D             LSLS     R5,R5,#+9
   \       0x52   0x0276             LSLS     R6,R6,#+9
   \                     ??erase_4: (+1)
   \       0x54   0x462A             MOV      R2,R5
   \       0x56   0x2120             MOVS     R1,#+32
   \       0x58   0x4620             MOV      R0,R4
   \       0x5A   0x.... 0x....      BL       _ZN7Sd2Card11cardCommandEhj
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD10D             BNE.N    ??erase_5
   \       0x62   0x4632             MOV      R2,R6
   \       0x64   0x2121             MOVS     R1,#+33
   \       0x66   0x4620             MOV      R0,R4
   \       0x68   0x.... 0x....      BL       _ZN7Sd2Card11cardCommandEhj
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0xD106             BNE.N    ??erase_5
   \       0x70   0x2200             MOVS     R2,#+0
   \       0x72   0x2126             MOVS     R1,#+38
   \       0x74   0x4620             MOV      R0,R4
   \       0x76   0x.... 0x....      BL       _ZN7Sd2Card11cardCommandEhj
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD004             BEQ.N    ??erase_6
   \                     ??erase_5: (+1)
   \       0x7E   0x210C             MOVS     R1,#+12
   \       0x80   0x4620             MOV      R0,R4
   \       0x82   0x.... 0x....      BL       _ZN7Sd2Card5errorEh
   \       0x86   0xE7DA             B.N      ??erase_0
   \                     ??erase_6: (+1)
   \       0x88   0xF242 0x7110      MOVW     R1,#+10000
   \       0x8C   0x4620             MOV      R0,R4
   \       0x8E   0x.... 0x....      BL       _ZN7Sd2Card11waitNotBusyEt
   \       0x92   0x2800             CMP      R0,#+0
   \       0x94   0xD104             BNE.N    ??erase_7
   \       0x96   0x210E             MOVS     R1,#+14
   \       0x98   0x4620             MOV      R0,R4
   \       0x9A   0x.... 0x....      BL       _ZN7Sd2Card5errorEh
   \       0x9E   0xE7CE             B.N      ??erase_0
   \                     ??erase_7: (+1)
   \       0xA0   0x4620             MOV      R0,R4
   \       0xA2   0x.... 0x....      BL       _ZN7Sd2Card14chipSelectHighEv
   \       0xA6   0x2001             MOVS     R0,#+1
   \       0xA8   0xE7CD             B.N      ??erase_3
    307          }
    308          //------------------------------------------------------------------------------
    309          /** Determine if card supports single block erase.
    310           *
    311           * \return The value one, true, is returned if single block erase is supported.
    312           * The value zero, false, is returned if single block erase is not supported.
    313           */

   \                                 In section .text, align 2, keep-with-next
    314          bool Sd2Card::eraseSingleBlockEnable() {
   \                     _ZN7Sd2Card22eraseSingleBlockEnableEv: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    315            csd_t csd;
    316            return readCSD(&csd) ? csd.v1.erase_blk_en : false;
   \        0x2   0x4669             MOV      R1,SP
   \        0x4   0x.... 0x....      BL       _ZN7Sd2Card7readCSDEP5csd_t
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD004             BEQ.N    ??eraseSingleBlockEnable_0
   \        0xC   0xF89D 0x000A      LDRB     R0,[SP, #+10]
   \       0x10   0xF3C0 0x1080      UBFX     R0,R0,#+6,#+1
   \       0x14   0xE000             B.N      ??eraseSingleBlockEnable_1
   \                     ??eraseSingleBlockEnable_0: (+1)
   \       0x16   0x2000             MOVS     R0,#+0
   \                     ??eraseSingleBlockEnable_1: (+1)
   \       0x18   0x1E40             SUBS     R0,R0,#+1
   \       0x1A   0x4180             SBCS     R0,R0,R0
   \       0x1C   0x43C0             MVNS     R0,R0
   \       0x1E   0x0FC0             LSRS     R0,R0,#+31
   \       0x20   0xB005             ADD      SP,SP,#+20
   \       0x22   0xBD00             POP      {PC}             ;; return
    317          }
    318          //------------------------------------------------------------------------------
    319          /**
    320           * Initialize an SD flash memory card.
    321           *
    322           * \param[in] sckRateID SPI clock rate selector. See setSckRate().
    323           * \param[in] chipSelectPin SD chip select pin number.
    324           *
    325           * \return The value one, true, is returned for success and
    326           * the value zero, false, is returned for failure.  The reason for failure
    327           * can be determined by calling errorCode() and errorData().
    328           */

   \                                 In section .text, align 2, keep-with-next
    329          bool Sd2Card::init(uint8_t sckRateID, uint8_t chipSelectPin) {
   \                     _ZN7Sd2Card4initEhh: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
    330            errorCode_ = type_ = 0;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x7128             STRB     R0,[R5, #+4]
   \        0xA   0x7068             STRB     R0,[R5, #+1]
    331            chipSelectPin_ = chipSelectPin;
   \        0xC   0x702A             STRB     R2,[R5, #+0]
    332            // 16-bit init start time allows over a minute
    333            uint16_t t0 = (uint16_t)millis();
   \        0xE   0x.... 0x....      BL       HAL_GetTick
   \       0x12   0x4606             MOV      R6,R0
   \       0x14   0xB2B6             UXTH     R6,R6
    334            uint32_t arg;
    335          
    336            // If init takes more than 4s it could trigger
    337            // watchdog leading to a reboot loop.
    338            #if ENABLED(USE_WATCHDOG)
    339              watchdog_reset();
    340            #endif
    341          
    342            // set pin modes
    343            pinMode(chipSelectPin_, OUTPUT);
    344            chipSelectHigh();
   \       0x16   0x4628             MOV      R0,R5
   \       0x18   0x.... 0x....      BL       _ZN7Sd2Card14chipSelectHighEv
    345            SET_INPUT(SPI_MISO_PIN);
    346            SET_OUTPUT(SPI_MOSI_PIN);
    347            SET_OUTPUT(SPI_SCK_PIN);
    348          
    349            #if DISABLED(SOFTWARE_SPI)
    350              // SS must be in output mode even it is not chip select
    351              SET_OUTPUT(SS_PIN);
    352              // set SS high - may be chip select for another SPI device
    353              #if SET_SPI_SS_HIGH
    354                WRITE(SS_PIN, HIGH);
   \       0x1C   0x2201             MOVS     R2,#+1
   \       0x1E   0x....             LDR.N    R0,??DataTable8_3
   \       0x20   0x8C81             LDRH     R1,[R0, #+36]
   \       0x22   0x....             LDR.N    R0,??DataTable8_4
   \       0x24   0x6C80             LDR      R0,[R0, #+72]
   \       0x26   0x.... 0x....      BL       HAL_GPIO_WritePin
    355              #endif  // SET_SPI_SS_HIGH
    356              // set SCK rate for initialization commands
    357              spiRate_ = SPI_SD_INIT_RATE;
   \       0x2A   0x2003             MOVS     R0,#+3
   \       0x2C   0x70A8             STRB     R0,[R5, #+2]
    358              spiInit(spiRate_);
   \       0x2E   0x.... 0x....      BL       _ZN33_INTERNAL_11_Sd2Card_cpp_f61128977spiInitEh
    359            #endif  // SOFTWARE_SPI
    360          
    361            // must supply min of 74 clock cycles with CS high.
    362            for (uint8_t i = 0; i < 10; i++) spiSend(0XFF);
   \       0x32   0x2700             MOVS     R7,#+0
   \       0x34   0xE003             B.N      ??init_0
   \                     ??init_1: (+1)
   \       0x36   0x20FF             MOVS     R0,#+255
   \       0x38   0x.... 0x....      BL       _Z7spiSendh
   \       0x3C   0x1C7F             ADDS     R7,R7,#+1
   \                     ??init_0: (+1)
   \       0x3E   0x4638             MOV      R0,R7
   \       0x40   0xB2C0             UXTB     R0,R0
   \       0x42   0x280A             CMP      R0,#+10
   \       0x44   0xDBF7             BLT.N    ??init_1
    363          
    364            // command to go idle in SPI mode
    365            while ((status_ = cardCommand(CMD0, 0)) != R1_IDLE_STATE) {
   \                     ??init_2: (+1)
   \       0x46   0x2200             MOVS     R2,#+0
   \       0x48   0x4611             MOV      R1,R2
   \       0x4A   0x4628             MOV      R0,R5
   \       0x4C   0x.... 0x....      BL       _ZN7Sd2Card11cardCommandEhj
   \       0x50   0x70E8             STRB     R0,[R5, #+3]
   \       0x52   0x2801             CMP      R0,#+1
   \       0x54   0xD05F             BEQ.N    ??init_3
    366              if (((uint16_t)millis() - t0) > SD_INIT_TIMEOUT) {
   \       0x56   0x.... 0x....      BL       HAL_GetTick
   \       0x5A   0xB280             UXTH     R0,R0
   \       0x5C   0x1B80             SUBS     R0,R0,R6
   \       0x5E   0xF240 0x71D1      MOVW     R1,#+2001
   \       0x62   0x4288             CMP      R0,R1
   \       0x64   0xDBEF             BLT.N    ??init_2
    367                error(SD_CARD_ERROR_CMD0);
   \       0x66   0x2101             MOVS     R1,#+1
   \       0x68   0x4628             MOV      R0,R5
   \       0x6A   0x.... 0x....      BL       _ZN7Sd2Card5errorEh
    368                goto fail;
    369              }
    370            }
    371            // check SD version
    372            if ((cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    373              type(SD_CARD_TYPE_SD1);
    374            }
    375            else {
    376              // only need last byte of r7 response
    377              for (uint8_t i = 0; i < 4; i++) status_ = spiRec();
    378              if (status_ != 0XAA) {
    379                error(SD_CARD_ERROR_CMD8);
    380                goto fail;
    381              }
    382              type(SD_CARD_TYPE_SD2);
    383            }
    384            // initialize card and send host supports SDHC if SD2
    385            arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
    386          
    387            while ((status_ = cardAcmd(ACMD41, arg)) != R1_READY_STATE) {
    388              // check for timeout
    389              if (((uint16_t)millis() - t0) > SD_INIT_TIMEOUT) {
    390                error(SD_CARD_ERROR_ACMD41);
    391                goto fail;
    392              }
    393            }
    394            // if SD2 read OCR register to check for SDHC card
    395            if (type() == SD_CARD_TYPE_SD2) {
    396              if (cardCommand(CMD58, 0)) {
    397                error(SD_CARD_ERROR_CMD58);
    398                goto fail;
    399              }
    400              if ((spiRec() & 0XC0) == 0XC0) type(SD_CARD_TYPE_SDHC);
    401              // discard rest of ocr - contains allowed voltage range
    402              for (uint8_t i = 0; i < 3; i++) spiRec();
    403            }
    404            chipSelectHigh();
    405          
    406            #if DISABLED(SOFTWARE_SPI)
    407              return setSckRate(sckRateID);
    408            #else  // SOFTWARE_SPI
    409              UNUSED(sckRateID);
    410              return true;
    411            #endif  // SOFTWARE_SPI
    412          
    413          fail:
    414            chipSelectHigh();
   \                     ??init_4: (+1)
   \       0x6E   0x4628             MOV      R0,R5
   \       0x70   0x.... 0x....      BL       _ZN7Sd2Card14chipSelectHighEv
    415            return false;
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \                     ??init_5: (+1)
   \       0x78   0x2700             MOVS     R7,#+0
   \       0x7A   0xE003             B.N      ??init_6
   \                     ??init_7: (+1)
   \       0x7C   0x.... 0x....      BL       _ZN33_INTERNAL_11_Sd2Card_cpp_f61128976spiRecEv
   \       0x80   0x70E8             STRB     R0,[R5, #+3]
   \       0x82   0x1C7F             ADDS     R7,R7,#+1
   \                     ??init_6: (+1)
   \       0x84   0x4638             MOV      R0,R7
   \       0x86   0xB2C0             UXTB     R0,R0
   \       0x88   0x2803             CMP      R0,#+3
   \       0x8A   0xDDF7             BLE.N    ??init_7
   \       0x8C   0x78E8             LDRB     R0,[R5, #+3]
   \       0x8E   0x28AA             CMP      R0,#+170
   \       0x90   0xD004             BEQ.N    ??init_8
   \       0x92   0x2102             MOVS     R1,#+2
   \       0x94   0x4628             MOV      R0,R5
   \       0x96   0x.... 0x....      BL       _ZN7Sd2Card5errorEh
   \       0x9A   0xE7E8             B.N      ??init_4
   \                     ??init_8: (+1)
   \       0x9C   0x2102             MOVS     R1,#+2
   \       0x9E   0x4628             MOV      R0,R5
   \       0xA0   0x.... 0x....      BL       _ZN7Sd2Card4typeEh
   \                     ??init_9: (+1)
   \       0xA4   0x4628             MOV      R0,R5
   \       0xA6   0x.... 0x....      BL       _ZNK7Sd2Card4typeEv
   \       0xAA   0x2802             CMP      R0,#+2
   \       0xAC   0xD116             BNE.N    ??init_10
   \       0xAE   0xF04F 0x4780      MOV      R7,#+1073741824
   \                     ??init_11: (+1)
   \       0xB2   0x463A             MOV      R2,R7
   \       0xB4   0x2129             MOVS     R1,#+41
   \       0xB6   0x4628             MOV      R0,R5
   \       0xB8   0x.... 0x....      BL       _ZN7Sd2Card8cardAcmdEhj
   \       0xBC   0x70E8             STRB     R0,[R5, #+3]
   \       0xBE   0x2800             CMP      R0,#+0
   \       0xC0   0xD036             BEQ.N    ??init_12
   \       0xC2   0x.... 0x....      BL       HAL_GetTick
   \       0xC6   0xB280             UXTH     R0,R0
   \       0xC8   0x1B80             SUBS     R0,R0,R6
   \       0xCA   0xF240 0x71D1      MOVW     R1,#+2001
   \       0xCE   0x4288             CMP      R0,R1
   \       0xD0   0xDBEF             BLT.N    ??init_11
   \       0xD2   0x210A             MOVS     R1,#+10
   \       0xD4   0x4628             MOV      R0,R5
   \       0xD6   0x.... 0x....      BL       _ZN7Sd2Card5errorEh
   \       0xDA   0xE7C8             B.N      ??init_4
   \                     ??init_10: (+1)
   \       0xDC   0x2700             MOVS     R7,#+0
   \       0xDE   0xE7E8             B.N      ??init_11
   \                     ??init_13: (+1)
   \       0xE0   0x.... 0x....      BL       _ZN33_INTERNAL_11_Sd2Card_cpp_f61128976spiRecEv
   \       0xE4   0xF000 0x00C0      AND      R0,R0,#0xC0
   \       0xE8   0x28C0             CMP      R0,#+192
   \       0xEA   0xD103             BNE.N    ??init_14
   \       0xEC   0x2103             MOVS     R1,#+3
   \       0xEE   0x4628             MOV      R0,R5
   \       0xF0   0x.... 0x....      BL       _ZN7Sd2Card4typeEh
   \                     ??init_14: (+1)
   \       0xF4   0x2600             MOVS     R6,#+0
   \       0xF6   0xE002             B.N      ??init_15
   \                     ??init_16: (+1)
   \       0xF8   0x.... 0x....      BL       _ZN33_INTERNAL_11_Sd2Card_cpp_f61128976spiRecEv
   \       0xFC   0x1C76             ADDS     R6,R6,#+1
   \                     ??init_15: (+1)
   \       0xFE   0x4630             MOV      R0,R6
   \      0x100   0xB2C0             UXTB     R0,R0
   \      0x102   0x2803             CMP      R0,#+3
   \      0x104   0xDBF8             BLT.N    ??init_16
   \                     ??init_17: (+1)
   \      0x106   0x4628             MOV      R0,R5
   \      0x108   0x.... 0x....      BL       _ZN7Sd2Card14chipSelectHighEv
   \      0x10C   0x4621             MOV      R1,R4
   \      0x10E   0x4628             MOV      R0,R5
   \      0x110   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \      0x114   0x....             B.N      _ZN7Sd2Card10setSckRateEh
   \                     ??init_3: (+1)
   \      0x116   0xF44F 0x72D5      MOV      R2,#+426
   \      0x11A   0x2108             MOVS     R1,#+8
   \      0x11C   0x4628             MOV      R0,R5
   \      0x11E   0x.... 0x....      BL       _ZN7Sd2Card11cardCommandEhj
   \      0x122   0x0740             LSLS     R0,R0,#+29
   \      0x124   0xD5A8             BPL.N    ??init_5
   \      0x126   0x2101             MOVS     R1,#+1
   \      0x128   0x4628             MOV      R0,R5
   \      0x12A   0x.... 0x....      BL       _ZN7Sd2Card4typeEh
   \      0x12E   0xE7B9             B.N      ??init_9
   \                     ??init_12: (+1)
   \      0x130   0x4628             MOV      R0,R5
   \      0x132   0x.... 0x....      BL       _ZNK7Sd2Card4typeEv
   \      0x136   0x2802             CMP      R0,#+2
   \      0x138   0xD1E5             BNE.N    ??init_17
   \      0x13A   0x2200             MOVS     R2,#+0
   \      0x13C   0x213A             MOVS     R1,#+58
   \      0x13E   0x4628             MOV      R0,R5
   \      0x140   0x.... 0x....      BL       _ZN7Sd2Card11cardCommandEhj
   \      0x144   0x2800             CMP      R0,#+0
   \      0x146   0xD0CB             BEQ.N    ??init_13
   \      0x148   0x2108             MOVS     R1,#+8
   \      0x14A   0x4628             MOV      R0,R5
   \      0x14C   0x.... 0x....      BL       _ZN7Sd2Card5errorEh
   \      0x150   0xE78D             B.N      ??init_4
    416          }
    417          //------------------------------------------------------------------------------
    418          /**
    419           * Read a 512 byte block from an SD card.
    420           *
    421           * \param[in] blockNumber Logical block to be read.
    422           * \param[out] dst Pointer to the location that will receive the data.
    423           * \return The value one, true, is returned for success and
    424           * the value zero, false, is returned for failure.
    425           */

   \                                 In section .text, align 2, keep-with-next
    426          bool Sd2Card::readBlock(uint32_t blockNumber, uint8_t* dst) {
   \                     _ZN7Sd2Card9readBlockEjPh: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
    427            // use address if not SDHC card
    428            if (type() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;
   \        0x8   0x.... 0x....      BL       _ZNK7Sd2Card4typeEv
   \        0xC   0x2803             CMP      R0,#+3
   \        0xE   0xD000             BEQ.N    ??readBlock_0
   \       0x10   0x026D             LSLS     R5,R5,#+9
    429          
    430            #if ENABLED(SD_CHECK_AND_RETRY)
    431              uint8_t retryCnt = 3;
    432              do {
    433                if (!cardCommand(CMD17, blockNumber)) {
    434                  if (readData(dst, 512)) return true;
    435                }
    436                else
    437                  error(SD_CARD_ERROR_CMD17);
    438          
    439                if (!--retryCnt) break;
    440          
    441                chipSelectHigh();
    442                cardCommand(CMD12, 0); // Try sending a stop command, ignore the result.
    443                errorCode_ = 0;
    444              } while (true);
    445            #else
    446              if (cardCommand(CMD17, blockNumber))
   \                     ??readBlock_0: (+1)
   \       0x12   0x462A             MOV      R2,R5
   \       0x14   0x2111             MOVS     R1,#+17
   \       0x16   0x4620             MOV      R0,R4
   \       0x18   0x.... 0x....      BL       _ZN7Sd2Card11cardCommandEhj
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD008             BEQ.N    ??readBlock_1
    447                error(SD_CARD_ERROR_CMD17);
   \       0x20   0x2104             MOVS     R1,#+4
   \       0x22   0x4620             MOV      R0,R4
   \       0x24   0x.... 0x....      BL       _ZN7Sd2Card5errorEh
    448              else
    449                return readData(dst, 512);
    450            #endif
    451          
    452            chipSelectHigh();
   \       0x28   0x4620             MOV      R0,R4
   \       0x2A   0x.... 0x....      BL       _ZN7Sd2Card14chipSelectHighEv
    453            return false;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0xBD70             POP      {R4-R6,PC}
   \                     ??readBlock_1: (+1)
   \       0x32   0xF44F 0x7200      MOV      R2,#+512
   \       0x36   0x4631             MOV      R1,R6
   \       0x38   0x4620             MOV      R0,R4
   \       0x3A   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x3E   0x....             B.N      _ZN7Sd2Card8readDataEPht
    454          }
    455          //------------------------------------------------------------------------------
    456          /** Read one data block in a multiple block read sequence
    457           *
    458           * \param[in] dst Pointer to the location for the data to be read.
    459           *
    460           * \return The value one, true, is returned for success and
    461           * the value zero, false, is returned for failure.
    462           */

   \                                 In section .text, align 2, keep-with-next
    463          bool Sd2Card::readData(uint8_t* dst) {
   \                     _ZN7Sd2Card8readDataEPh: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    464            chipSelectLow();
   \        0x6   0x.... 0x....      BL       _ZN7Sd2Card13chipSelectLowEv
    465            return readData(dst, 512);
   \        0xA   0xF44F 0x7200      MOV      R2,#+512
   \        0xE   0x4629             MOV      R1,R5
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0xE8BD 0x4038      POP      {R3-R5,LR}
   \       0x16                      REQUIRE _ZN7Sd2Card8readDataEPht
   \       0x16                      ;; // Fall through to label Sd2Card::readData(uint8_t *, uint16_t)
    466          }
    467          
    468          #if ENABLED(SD_CHECK_AND_RETRY)
    469          static const uint16_t crctab[] PROGMEM = {
    470            0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7,
    471            0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF,
    472            0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6,
    473            0x9339, 0x8318, 0xB37B, 0xA35A, 0xD3BD, 0xC39C, 0xF3FF, 0xE3DE,
    474            0x2462, 0x3443, 0x0420, 0x1401, 0x64E6, 0x74C7, 0x44A4, 0x5485,
    475            0xA56A, 0xB54B, 0x8528, 0x9509, 0xE5EE, 0xF5CF, 0xC5AC, 0xD58D,
    476            0x3653, 0x2672, 0x1611, 0x0630, 0x76D7, 0x66F6, 0x5695, 0x46B4,
    477            0xB75B, 0xA77A, 0x9719, 0x8738, 0xF7DF, 0xE7FE, 0xD79D, 0xC7BC,
    478            0x48C4, 0x58E5, 0x6886, 0x78A7, 0x0840, 0x1861, 0x2802, 0x3823,
    479            0xC9CC, 0xD9ED, 0xE98E, 0xF9AF, 0x8948, 0x9969, 0xA90A, 0xB92B,
    480            0x5AF5, 0x4AD4, 0x7AB7, 0x6A96, 0x1A71, 0x0A50, 0x3A33, 0x2A12,
    481            0xDBFD, 0xCBDC, 0xFBBF, 0xEB9E, 0x9B79, 0x8B58, 0xBB3B, 0xAB1A,
    482            0x6CA6, 0x7C87, 0x4CE4, 0x5CC5, 0x2C22, 0x3C03, 0x0C60, 0x1C41,
    483            0xEDAE, 0xFD8F, 0xCDEC, 0xDDCD, 0xAD2A, 0xBD0B, 0x8D68, 0x9D49,
    484            0x7E97, 0x6EB6, 0x5ED5, 0x4EF4, 0x3E13, 0x2E32, 0x1E51, 0x0E70,
    485            0xFF9F, 0xEFBE, 0xDFDD, 0xCFFC, 0xBF1B, 0xAF3A, 0x9F59, 0x8F78,
    486            0x9188, 0x81A9, 0xB1CA, 0xA1EB, 0xD10C, 0xC12D, 0xF14E, 0xE16F,
    487            0x1080, 0x00A1, 0x30C2, 0x20E3, 0x5004, 0x4025, 0x7046, 0x6067,
    488            0x83B9, 0x9398, 0xA3FB, 0xB3DA, 0xC33D, 0xD31C, 0xE37F, 0xF35E,
    489            0x02B1, 0x1290, 0x22F3, 0x32D2, 0x4235, 0x5214, 0x6277, 0x7256,
    490            0xB5EA, 0xA5CB, 0x95A8, 0x8589, 0xF56E, 0xE54F, 0xD52C, 0xC50D,
    491            0x34E2, 0x24C3, 0x14A0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
    492            0xA7DB, 0xB7FA, 0x8799, 0x97B8, 0xE75F, 0xF77E, 0xC71D, 0xD73C,
    493            0x26D3, 0x36F2, 0x0691, 0x16B0, 0x6657, 0x7676, 0x4615, 0x5634,
    494            0xD94C, 0xC96D, 0xF90E, 0xE92F, 0x99C8, 0x89E9, 0xB98A, 0xA9AB,
    495            0x5844, 0x4865, 0x7806, 0x6827, 0x18C0, 0x08E1, 0x3882, 0x28A3,
    496            0xCB7D, 0xDB5C, 0xEB3F, 0xFB1E, 0x8BF9, 0x9BD8, 0xABBB, 0xBB9A,
    497            0x4A75, 0x5A54, 0x6A37, 0x7A16, 0x0AF1, 0x1AD0, 0x2AB3, 0x3A92,
    498            0xFD2E, 0xED0F, 0xDD6C, 0xCD4D, 0xBDAA, 0xAD8B, 0x9DE8, 0x8DC9,
    499            0x7C26, 0x6C07, 0x5C64, 0x4C45, 0x3CA2, 0x2C83, 0x1CE0, 0x0CC1,
    500            0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8,
    501            0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0
    502          };
    503          static uint16_t CRC_CCITT(const uint8_t* data, size_t n) {
    504            uint16_t crc = 0;
    505            for (size_t i = 0; i < n; i++) {
    506              crc = pgm_read_word(&crctab[(crc >> 8 ^ data[i]) & 0XFF]) ^ (crc << 8);
    507            }
    508            return crc;
    509          }
    510          #endif
    511          
    512          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    513          bool Sd2Card::readData(uint8_t* dst, uint16_t count) {
   \                     _ZN7Sd2Card8readDataEPht: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
    514            // wait for start block token
    515            uint16_t t0 = millis();
   \        0x8   0x.... 0x....      BL       HAL_GetTick
   \        0xC   0x4607             MOV      R7,R0
   \        0xE   0xB2BF             UXTH     R7,R7
    516            while ((status_ = spiRec()) == 0XFF) {
   \                     ??readData_0: (+1)
   \       0x10   0x.... 0x....      BL       _ZN33_INTERNAL_11_Sd2Card_cpp_f61128976spiRecEv
   \       0x14   0x70E0             STRB     R0,[R4, #+3]
   \       0x16   0x4601             MOV      R1,R0
   \       0x18   0x29FF             CMP      R1,#+255
   \       0x1A   0xD123             BNE.N    ??readData_1
    517              if (((uint16_t)millis() - t0) > SD_READ_TIMEOUT) {
   \       0x1C   0x.... 0x....      BL       HAL_GetTick
   \       0x20   0xB280             UXTH     R0,R0
   \       0x22   0x1BC0             SUBS     R0,R0,R7
   \       0x24   0xF240 0x112D      MOVW     R1,#+301
   \       0x28   0x4288             CMP      R0,R1
   \       0x2A   0xDBF1             BLT.N    ??readData_0
    518                error(SD_CARD_ERROR_READ_TIMEOUT);
   \       0x2C   0x2111             MOVS     R1,#+17
   \       0x2E   0x4620             MOV      R0,R4
   \       0x30   0x.... 0x....      BL       _ZN7Sd2Card5errorEh
    519                goto fail;
    520              }
    521            }
    522            if (status_ != DATA_START_BLOCK) {
    523              error(SD_CARD_ERROR_READ);
    524              goto fail;
    525            }
    526            // transfer data
    527            spiRead(dst, count);
    528          
    529          #if ENABLED(SD_CHECK_AND_RETRY)
    530            {
    531              uint16_t calcCrc = CRC_CCITT(dst, count);
    532              uint16_t recvCrc = spiRec() << 8;
    533              recvCrc |= spiRec();
    534              if (calcCrc != recvCrc) {
    535                error(SD_CARD_ERROR_CRC);
    536                goto fail;
    537              }
    538            }
    539          #else
    540            // discard CRC
    541            spiRec();
    542            spiRec();
    543          #endif
    544            chipSelectHigh();
    545            // Send an additional dummy byte, required by Toshiba Flash Air SD Card
    546            spiSend(0XFF);
    547            return true;
    548          fail:
    549            chipSelectHigh();
   \                     ??readData_2: (+1)
   \       0x34   0x4620             MOV      R0,R4
   \       0x36   0x.... 0x....      BL       _ZN7Sd2Card14chipSelectHighEv
    550            // Send an additional dummy byte, required by Toshiba Flash Air SD Card
    551            spiSend(0XFF);
   \       0x3A   0x20FF             MOVS     R0,#+255
   \       0x3C   0x.... 0x....      BL       _Z7spiSendh
    552            return false;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \                     ??readData_3: (+1)
   \       0x44   0x4631             MOV      R1,R6
   \       0x46   0x4628             MOV      R0,R5
   \       0x48   0x.... 0x....      BL       _ZN33_INTERNAL_11_Sd2Card_cpp_f61128977spiReadEPht
   \       0x4C   0x.... 0x....      BL       _ZN33_INTERNAL_11_Sd2Card_cpp_f61128976spiRecEv
   \       0x50   0x.... 0x....      BL       _ZN33_INTERNAL_11_Sd2Card_cpp_f61128976spiRecEv
   \       0x54   0x4620             MOV      R0,R4
   \       0x56   0x.... 0x....      BL       _ZN7Sd2Card14chipSelectHighEv
   \       0x5A   0x20FF             MOVS     R0,#+255
   \       0x5C   0x.... 0x....      BL       _Z7spiSendh
   \       0x60   0x2001             MOVS     R0,#+1
   \       0x62   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??readData_1: (+1)
   \       0x64   0x28FE             CMP      R0,#+254
   \       0x66   0xD0ED             BEQ.N    ??readData_3
   \       0x68   0x210F             MOVS     R1,#+15
   \       0x6A   0x4620             MOV      R0,R4
   \       0x6C   0x.... 0x....      BL       _ZN7Sd2Card5errorEh
   \       0x70   0xE7E0             B.N      ??readData_2
    553          }
    554          //------------------------------------------------------------------------------
    555          /** read CID or CSR register */

   \                                 In section .text, align 2, keep-with-next
    556          bool Sd2Card::readRegister(uint8_t cmd, void* buf) {
   \                     _ZN7Sd2Card12readRegisterEhPv: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x4615             MOV      R5,R2
    557            uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
    558            if (cardCommand(cmd, 0)) {
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x.... 0x....      BL       _ZN7Sd2Card11cardCommandEhj
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD008             BEQ.N    ??readRegister_0
    559              error(SD_CARD_ERROR_READ_REG);
   \       0x10   0x2110             MOVS     R1,#+16
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0x.... 0x....      BL       _ZN7Sd2Card5errorEh
    560              goto fail;
    561            }
    562            return readData(dst, 16);
    563          fail:
    564            chipSelectHigh();
   \       0x18   0x4620             MOV      R0,R4
   \       0x1A   0x.... 0x....      BL       _ZN7Sd2Card14chipSelectHighEv
    565            return false;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??readRegister_0: (+1)
   \       0x22   0x2210             MOVS     R2,#+16
   \       0x24   0x4629             MOV      R1,R5
   \       0x26   0x4620             MOV      R0,R4
   \       0x28   0xE8BD 0x4038      POP      {R3-R5,LR}
   \       0x2C   0x....             B.N      _ZN7Sd2Card8readDataEPht
    566          }
    567          //------------------------------------------------------------------------------
    568          /** Start a read multiple blocks sequence.
    569           *
    570           * \param[in] blockNumber Address of first block in sequence.
    571           *
    572           * \note This function is used with readData() and readStop() for optimized
    573           * multiple block reads.  SPI chipSelect must be low for the entire sequence.
    574           *
    575           * \return The value one, true, is returned for success and
    576           * the value zero, false, is returned for failure.
    577           */

   \                                 In section .text, align 2, keep-with-next
    578          bool Sd2Card::readStart(uint32_t blockNumber) {
   \                     _ZN7Sd2Card9readStartEj: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    579            if (type() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;
   \        0x6   0x.... 0x....      BL       _ZNK7Sd2Card4typeEv
   \        0xA   0x2803             CMP      R0,#+3
   \        0xC   0xD000             BEQ.N    ??readStart_0
   \        0xE   0x026D             LSLS     R5,R5,#+9
    580            if (cardCommand(CMD18, blockNumber)) {
   \                     ??readStart_0: (+1)
   \       0x10   0x462A             MOV      R2,R5
   \       0x12   0x2112             MOVS     R1,#+18
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0x.... 0x....      BL       _ZN7Sd2Card11cardCommandEhj
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD008             BEQ.N    ??readStart_1
    581              error(SD_CARD_ERROR_CMD18);
   \       0x1E   0x2105             MOVS     R1,#+5
   \       0x20   0x4620             MOV      R0,R4
   \       0x22   0x.... 0x....      BL       _ZN7Sd2Card5errorEh
    582              goto fail;
    583            }
    584            chipSelectHigh();
    585            return true;
    586          fail:
    587            chipSelectHigh();
   \       0x26   0x4620             MOV      R0,R4
   \       0x28   0x.... 0x....      BL       _ZN7Sd2Card14chipSelectHighEv
    588            return false;
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??readStart_1: (+1)
   \       0x30   0x4620             MOV      R0,R4
   \       0x32   0x.... 0x....      BL       _ZN7Sd2Card14chipSelectHighEv
   \       0x36   0x2001             MOVS     R0,#+1
   \       0x38   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    589          }
    590          //------------------------------------------------------------------------------
    591          /** End a read multiple blocks sequence.
    592           *
    593          * \return The value one, true, is returned for success and
    594           * the value zero, false, is returned for failure.
    595           */

   \                                 In section .text, align 2, keep-with-next
    596          bool Sd2Card::readStop() {
   \                     _ZN7Sd2Card8readStopEv: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    597            chipSelectLow();
   \        0x4   0x.... 0x....      BL       _ZN7Sd2Card13chipSelectLowEv
    598            if (cardCommand(CMD12, 0)) {
   \        0x8   0x2200             MOVS     R2,#+0
   \        0xA   0x210C             MOVS     R1,#+12
   \        0xC   0x4620             MOV      R0,R4
   \        0xE   0x.... 0x....      BL       _ZN7Sd2Card11cardCommandEhj
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD008             BEQ.N    ??readStop_0
    599              error(SD_CARD_ERROR_CMD12);
   \       0x16   0x2103             MOVS     R1,#+3
   \       0x18   0x4620             MOV      R0,R4
   \       0x1A   0x.... 0x....      BL       _ZN7Sd2Card5errorEh
    600              goto fail;
    601            }
    602            chipSelectHigh();
    603            return true;
    604          fail:
    605            chipSelectHigh();
   \       0x1E   0x4620             MOV      R0,R4
   \       0x20   0x.... 0x....      BL       _ZN7Sd2Card14chipSelectHighEv
    606            return false;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0xBD10             POP      {R4,PC}
   \                     ??readStop_0: (+1)
   \       0x28   0x4620             MOV      R0,R4
   \       0x2A   0x.... 0x....      BL       _ZN7Sd2Card14chipSelectHighEv
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0xBD10             POP      {R4,PC}          ;; return
    607          }
    608          //------------------------------------------------------------------------------
    609          /**
    610           * Set the SPI clock rate.
    611           *
    612           * \param[in] sckRateID A value in the range [0, 6].
    613           *
    614           * The SPI clock will be set to F_CPU/pow(2, 1 + sckRateID). The maximum
    615           * SPI rate is F_CPU/2 for \a sckRateID = 0 and the minimum rate is F_CPU/128
    616           * for \a scsRateID = 6.
    617           *
    618           * \return The value one, true, is returned for success and the value zero,
    619           * false, is returned for an invalid value of \a sckRateID.
    620           */

   \                                 In section .text, align 2, keep-with-next
    621          bool Sd2Card::setSckRate(uint8_t sckRateID) {
   \                     _ZN7Sd2Card10setSckRateEh: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    622            if (sckRateID > 6) {
   \        0x2   0x460A             MOV      R2,R1
   \        0x4   0x2A07             CMP      R2,#+7
   \        0x6   0xDB04             BLT.N    ??setSckRate_0
    623              error(SD_CARD_ERROR_SCK_RATE);
   \        0x8   0x2118             MOVS     R1,#+24
   \        0xA   0x.... 0x....      BL       _ZN7Sd2Card5errorEh
    624              return false;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xBD02             POP      {R1,PC}
    625            }
    626            spiRate_ = sckRateID;
   \                     ??setSckRate_0: (+1)
   \       0x12   0x7081             STRB     R1,[R0, #+2]
    627            return true;
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0xBD02             POP      {R1,PC}          ;; return
    628          }
    629          //------------------------------------------------------------------------------
    630          // wait for card to go not busy

   \                                 In section .text, align 2, keep-with-next
    631          bool Sd2Card::waitNotBusy(uint16_t timeoutMillis) {
   \                     _ZN7Sd2Card11waitNotBusyEt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x460C             MOV      R4,R1
    632            uint16_t t0 = millis();
   \        0x4   0x.... 0x....      BL       HAL_GetTick
   \        0x8   0x4605             MOV      R5,R0
   \        0xA   0xB2AD             UXTH     R5,R5
    633            while (spiRec() != 0XFF) {
   \                     ??waitNotBusy_0: (+1)
   \        0xC   0x.... 0x....      BL       _ZN33_INTERNAL_11_Sd2Card_cpp_f61128976spiRecEv
   \       0x10   0x28FF             CMP      R0,#+255
   \       0x12   0xD008             BEQ.N    ??waitNotBusy_1
    634              if (((uint16_t)millis() - t0) >= timeoutMillis) goto fail;
   \       0x14   0x.... 0x....      BL       HAL_GetTick
   \       0x18   0xB280             UXTH     R0,R0
   \       0x1A   0x1B40             SUBS     R0,R0,R5
   \       0x1C   0x4621             MOV      R1,R4
   \       0x1E   0x4288             CMP      R0,R1
   \       0x20   0xDBF4             BLT.N    ??waitNotBusy_0
    635            }
    636            return true;
    637          fail:
    638            return false;
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??waitNotBusy_1: (+1)
   \       0x26   0x2001             MOVS     R0,#+1
   \       0x28   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    639          }
    640          //------------------------------------------------------------------------------
    641          /**
    642           * Writes a 512 byte block to an SD card.
    643           *
    644           * \param[in] blockNumber Logical block to be written.
    645           * \param[in] src Pointer to the location of the data to be written.
    646           * \return The value one, true, is returned for success and
    647           * the value zero, false, is returned for failure.
    648           */

   \                                 In section .text, align 2, keep-with-next
    649          bool Sd2Card::writeBlock(uint32_t blockNumber, const uint8_t* src) {
   \                     _ZN7Sd2Card10writeBlockEjPKh: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
    650            // use address if not SDHC card
    651            if (type() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;
   \        0x8   0x.... 0x....      BL       _ZNK7Sd2Card4typeEv
   \        0xC   0x2803             CMP      R0,#+3
   \        0xE   0xD000             BEQ.N    ??writeBlock_0
   \       0x10   0x026D             LSLS     R5,R5,#+9
    652            if (cardCommand(CMD24, blockNumber)) {
   \                     ??writeBlock_0: (+1)
   \       0x12   0x462A             MOV      R2,R5
   \       0x14   0x2118             MOVS     R1,#+24
   \       0x16   0x4620             MOV      R0,R4
   \       0x18   0x.... 0x....      BL       _ZN7Sd2Card11cardCommandEhj
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD008             BEQ.N    ??writeBlock_1
    653              error(SD_CARD_ERROR_CMD24);
   \       0x20   0x2106             MOVS     R1,#+6
   \       0x22   0x4620             MOV      R0,R4
   \       0x24   0x.... 0x....      BL       _ZN7Sd2Card5errorEh
    654              goto fail;
    655            }
    656            if (!writeData(DATA_START_BLOCK, src)) goto fail;
    657          
    658            // wait for flash programming to complete
    659            if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    660              error(SD_CARD_ERROR_WRITE_TIMEOUT);
    661              goto fail;
    662            }
    663            // response is r2 so get and check two bytes for nonzero
    664            if (cardCommand(CMD13, 0) || spiRec()) {
    665              error(SD_CARD_ERROR_WRITE_PROGRAMMING);
    666              goto fail;
    667            }
    668            chipSelectHigh();
    669            return true;
    670          fail:
    671            chipSelectHigh();
   \                     ??writeBlock_2: (+1)
   \       0x28   0x4620             MOV      R0,R4
   \       0x2A   0x.... 0x....      BL       _ZN7Sd2Card14chipSelectHighEv
    672            return false;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??writeBlock_1: (+1)
   \       0x32   0x4632             MOV      R2,R6
   \       0x34   0x21FE             MOVS     R1,#+254
   \       0x36   0x4620             MOV      R0,R4
   \       0x38   0x.... 0x....      BL       _ZN7Sd2Card9writeDataEhPKh
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD0F3             BEQ.N    ??writeBlock_2
   \       0x40   0xF44F 0x7116      MOV      R1,#+600
   \       0x44   0x4620             MOV      R0,R4
   \       0x46   0x.... 0x....      BL       _ZN7Sd2Card11waitNotBusyEt
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD104             BNE.N    ??writeBlock_3
   \       0x4E   0x2117             MOVS     R1,#+23
   \       0x50   0x4620             MOV      R0,R4
   \       0x52   0x.... 0x....      BL       _ZN7Sd2Card5errorEh
   \       0x56   0xE7E7             B.N      ??writeBlock_2
   \                     ??writeBlock_3: (+1)
   \       0x58   0x2200             MOVS     R2,#+0
   \       0x5A   0x210D             MOVS     R1,#+13
   \       0x5C   0x4620             MOV      R0,R4
   \       0x5E   0x.... 0x....      BL       _ZN7Sd2Card11cardCommandEhj
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xD103             BNE.N    ??writeBlock_4
   \       0x66   0x.... 0x....      BL       _ZN33_INTERNAL_11_Sd2Card_cpp_f61128976spiRecEv
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD004             BEQ.N    ??writeBlock_5
   \                     ??writeBlock_4: (+1)
   \       0x6E   0x2116             MOVS     R1,#+22
   \       0x70   0x4620             MOV      R0,R4
   \       0x72   0x.... 0x....      BL       _ZN7Sd2Card5errorEh
   \       0x76   0xE7D7             B.N      ??writeBlock_2
   \                     ??writeBlock_5: (+1)
   \       0x78   0x4620             MOV      R0,R4
   \       0x7A   0x.... 0x....      BL       _ZN7Sd2Card14chipSelectHighEv
   \       0x7E   0x2001             MOVS     R0,#+1
   \       0x80   0xBD70             POP      {R4-R6,PC}
    673          }
    674          //------------------------------------------------------------------------------
    675          /** Write one data block in a multiple block write sequence
    676           * \param[in] src Pointer to the location of the data to be written.
    677           * \return The value one, true, is returned for success and
    678           * the value zero, false, is returned for failure.
    679           */

   \                                 In section .text, align 2, keep-with-next
    680          bool Sd2Card::writeData(const uint8_t* src) {
   \                     _ZN7Sd2Card9writeDataEPKh: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    681            chipSelectLow();
   \        0x6   0x.... 0x....      BL       _ZN7Sd2Card13chipSelectLowEv
    682            // wait for previous write to finish
    683            if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
   \        0xA   0xF44F 0x7116      MOV      R1,#+600
   \        0xE   0x4620             MOV      R0,R4
   \       0x10   0x.... 0x....      BL       _ZN7Sd2Card11waitNotBusyEt
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD00B             BEQ.N    ??writeData_0
    684            if (!writeData(WRITE_MULTIPLE_TOKEN, src)) goto fail;
   \       0x18   0x462A             MOV      R2,R5
   \       0x1A   0x21FC             MOVS     R1,#+252
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0x.... 0x....      BL       _ZN7Sd2Card9writeDataEhPKh
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD004             BEQ.N    ??writeData_0
    685            chipSelectHigh();
   \       0x26   0x4620             MOV      R0,R4
   \       0x28   0x.... 0x....      BL       _ZN7Sd2Card14chipSelectHighEv
    686            return true;
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0xBD32             POP      {R1,R4,R5,PC}
    687          fail:
    688            error(SD_CARD_ERROR_WRITE_MULTIPLE);
   \                     ??writeData_0: (+1)
   \       0x30   0x2115             MOVS     R1,#+21
   \       0x32   0x4620             MOV      R0,R4
   \       0x34   0x.... 0x....      BL       _ZN7Sd2Card5errorEh
    689            chipSelectHigh();
   \       0x38   0x4620             MOV      R0,R4
   \       0x3A   0x.... 0x....      BL       _ZN7Sd2Card14chipSelectHighEv
    690            return false;
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    691          }
    692          //------------------------------------------------------------------------------
    693          // send one block of data for write block or write multiple blocks

   \                                 In section .text, align 2, keep-with-next
    694          bool Sd2Card::writeData(uint8_t token, const uint8_t* src) {
   \                     _ZN7Sd2Card9writeDataEhPKh: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x4608             MOV      R0,R1
    695            spiSendBlock(token, src);
   \        0x6   0x4611             MOV      R1,R2
   \        0x8   0x.... 0x....      BL       _ZN33_INTERNAL_11_Sd2Card_cpp_f611289712spiSendBlockEhPKh
    696          
    697            spiSend(0xFF);  // dummy crc
   \        0xC   0x20FF             MOVS     R0,#+255
   \        0xE   0x.... 0x....      BL       _Z7spiSendh
    698            spiSend(0xFF);  // dummy crc
   \       0x12   0x20FF             MOVS     R0,#+255
   \       0x14   0x.... 0x....      BL       _Z7spiSendh
    699          
    700            status_ = spiRec();
   \       0x18   0x.... 0x....      BL       _ZN33_INTERNAL_11_Sd2Card_cpp_f61128976spiRecEv
   \       0x1C   0x70E0             STRB     R0,[R4, #+3]
    701            if ((status_ & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
   \       0x1E   0xF000 0x001F      AND      R0,R0,#0x1F
   \       0x22   0x2805             CMP      R0,#+5
   \       0x24   0xD008             BEQ.N    ??writeData_1
    702              error(SD_CARD_ERROR_WRITE);
   \       0x26   0x2113             MOVS     R1,#+19
   \       0x28   0x4620             MOV      R0,R4
   \       0x2A   0x.... 0x....      BL       _ZN7Sd2Card5errorEh
    703              goto fail;
    704            }
    705            return true;
    706          fail:
    707            chipSelectHigh();
   \       0x2E   0x4620             MOV      R0,R4
   \       0x30   0x.... 0x....      BL       _ZN7Sd2Card14chipSelectHighEv
    708            return false;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xBD10             POP      {R4,PC}
   \                     ??writeData_1: (+1)
   \       0x38   0x2001             MOVS     R0,#+1
   \       0x3A   0xBD10             POP      {R4,PC}          ;; return
    709          }
    710          //------------------------------------------------------------------------------
    711          /** Start a write multiple blocks sequence.
    712           *
    713           * \param[in] blockNumber Address of first block in sequence.
    714           * \param[in] eraseCount The number of blocks to be pre-erased.
    715           *
    716           * \note This function is used with writeData() and writeStop()
    717           * for optimized multiple block writes.
    718           *
    719           * \return The value one, true, is returned for success and
    720           * the value zero, false, is returned for failure.
    721           */

   \                                 In section .text, align 2, keep-with-next
    722          bool Sd2Card::writeStart(uint32_t blockNumber, uint32_t eraseCount) {
   \                     _ZN7Sd2Card10writeStartEjj: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    723            // send pre-erase count
    724            if (cardAcmd(ACMD23, eraseCount)) {
   \        0x6   0x2117             MOVS     R1,#+23
   \        0x8   0x.... 0x....      BL       _ZN7Sd2Card8cardAcmdEhj
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD008             BEQ.N    ??writeStart_0
    725              error(SD_CARD_ERROR_ACMD23);
   \       0x10   0x2109             MOVS     R1,#+9
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0x.... 0x....      BL       _ZN7Sd2Card5errorEh
    726              goto fail;
    727            }
    728            // use address if not SDHC card
    729            if (type() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;
    730            if (cardCommand(CMD25, blockNumber)) {
    731              error(SD_CARD_ERROR_CMD25);
    732              goto fail;
    733            }
    734            chipSelectHigh();
    735            return true;
    736          fail:
    737            chipSelectHigh();
   \                     ??writeStart_1: (+1)
   \       0x18   0x4620             MOV      R0,R4
   \       0x1A   0x.... 0x....      BL       _ZN7Sd2Card14chipSelectHighEv
    738            return false;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   \                     ??writeStart_0: (+1)
   \       0x22   0x4620             MOV      R0,R4
   \       0x24   0x.... 0x....      BL       _ZNK7Sd2Card4typeEv
   \       0x28   0x2803             CMP      R0,#+3
   \       0x2A   0xD000             BEQ.N    ??writeStart_2
   \       0x2C   0x026D             LSLS     R5,R5,#+9
   \                     ??writeStart_2: (+1)
   \       0x2E   0x462A             MOV      R2,R5
   \       0x30   0x2119             MOVS     R1,#+25
   \       0x32   0x4620             MOV      R0,R4
   \       0x34   0x.... 0x....      BL       _ZN7Sd2Card11cardCommandEhj
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD004             BEQ.N    ??writeStart_3
   \       0x3C   0x2107             MOVS     R1,#+7
   \       0x3E   0x4620             MOV      R0,R4
   \       0x40   0x.... 0x....      BL       _ZN7Sd2Card5errorEh
   \       0x44   0xE7E8             B.N      ??writeStart_1
   \                     ??writeStart_3: (+1)
   \       0x46   0x4620             MOV      R0,R4
   \       0x48   0x.... 0x....      BL       _ZN7Sd2Card14chipSelectHighEv
   \       0x4C   0x2001             MOVS     R0,#+1
   \       0x4E   0xBD32             POP      {R1,R4,R5,PC}
    739          }
    740          //------------------------------------------------------------------------------
    741          /** End a write multiple blocks sequence.
    742           *
    743          * \return The value one, true, is returned for success and
    744           * the value zero, false, is returned for failure.
    745           */

   \                                 In section .text, align 2, keep-with-next
    746          bool Sd2Card::writeStop() {
   \                     _ZN7Sd2Card9writeStopEv: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    747            chipSelectLow();
   \        0x4   0x.... 0x....      BL       _ZN7Sd2Card13chipSelectLowEv
    748            if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
   \        0x8   0xF44F 0x7116      MOV      R1,#+600
   \        0xC   0x4620             MOV      R0,R4
   \        0xE   0x.... 0x....      BL       _ZN7Sd2Card11waitNotBusyEt
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD00E             BEQ.N    ??writeStop_0
    749            spiSend(STOP_TRAN_TOKEN);
   \       0x16   0x20FD             MOVS     R0,#+253
   \       0x18   0x.... 0x....      BL       _Z7spiSendh
    750            if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
   \       0x1C   0xF44F 0x7116      MOV      R1,#+600
   \       0x20   0x4620             MOV      R0,R4
   \       0x22   0x.... 0x....      BL       _ZN7Sd2Card11waitNotBusyEt
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD004             BEQ.N    ??writeStop_0
    751            chipSelectHigh();
   \       0x2A   0x4620             MOV      R0,R4
   \       0x2C   0x.... 0x....      BL       _ZN7Sd2Card14chipSelectHighEv
    752            return true;
   \       0x30   0x2001             MOVS     R0,#+1
   \       0x32   0xBD10             POP      {R4,PC}
    753          fail:
    754            error(SD_CARD_ERROR_STOP_TRAN);
   \                     ??writeStop_0: (+1)
   \       0x34   0x2112             MOVS     R1,#+18
   \       0x36   0x4620             MOV      R0,R4
   \       0x38   0x.... 0x....      BL       _ZN7Sd2Card5errorEh
    755            chipSelectHigh();
   \       0x3C   0x4620             MOV      R0,R4
   \       0x3E   0x.... 0x....      BL       _ZN7Sd2Card14chipSelectHighEv
    756            return false;
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0xBD10             POP      {R4,PC}          ;; return
    757          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x4000'3800        DC32     0x40003800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x4000'3808        DC32     0x40003808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \        0x0   0x4221'01BC        DC32     0x422101bc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \        0x0   0x....'....        DC32     gArrayGpioPin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \        0x0   0x....'....        DC32     gArrayGpioPort

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \        0x0   0x00 0x08          DC8 0, 8, 16, 24, 32, 40, 48, 56
   \              0x10 0x18    
   \              0x20 0x28    
   \              0x30 0x38    
    758          
    759          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   Sd2Card::cardAcmd(uint8_t, uint32_t)
         0   -> Sd2Card::cardCommand(uint8_t, uint32_t)
        16   -> Sd2Card::cardCommand(uint8_t, uint32_t)
      24   Sd2Card::cardCommand(uint8_t, uint32_t)
        24   -> Sd2Card::chipSelectLow()
        24   -> Sd2Card::waitNotBusy(uint16_t)
        24   -> spiRec()
        24   -> spiSend(uint8_t)
      24   Sd2Card::cardSize()
        24   -> Sd2Card::error(uint8_t)
        24   -> Sd2Card::readCSD(csd_t *)
       0   Sd2Card::chipSelectHigh()
       8   Sd2Card::chipSelectLow()
         8   -> spiInit(uint8_t)
      32   Sd2Card::erase(uint32_t, uint32_t)
        32   -> Sd2Card::cardCommand(uint8_t, uint32_t)
        32   -> Sd2Card::chipSelectHigh()
        32   -> Sd2Card::error(uint8_t)
        32   -> Sd2Card::readCSD(csd_t *)
        32   -> Sd2Card::waitNotBusy(uint16_t)
      24   Sd2Card::eraseSingleBlockEnable()
        24   -> Sd2Card::readCSD(csd_t *)
       0   Sd2Card::error(uint8_t)
      24   Sd2Card::init(uint8_t, uint8_t)
        24   -> HAL_GPIO_WritePin
        24   -> HAL_GetTick
        24   -> Sd2Card::cardAcmd(uint8_t, uint32_t)
        24   -> Sd2Card::cardCommand(uint8_t, uint32_t)
        24   -> Sd2Card::chipSelectHigh()
        24   -> Sd2Card::error(uint8_t)
         0   -> Sd2Card::setSckRate(uint8_t)
        24   -> Sd2Card::type() const
        24   -> Sd2Card::type(uint8_t)
        24   -> spiInit(uint8_t)
        24   -> spiRec()
        24   -> spiSend(uint8_t)
      16   Sd2Card::readBlock(uint32_t, uint8_t *)
        16   -> Sd2Card::cardCommand(uint8_t, uint32_t)
        16   -> Sd2Card::chipSelectHigh()
        16   -> Sd2Card::error(uint8_t)
         0   -> Sd2Card::readData(uint8_t *, uint16_t)
        16   -> Sd2Card::type() const
       0   Sd2Card::readCSD(csd_t *)
         0   -> Sd2Card::readRegister(uint8_t, void *)
      16   Sd2Card::readData(uint8_t *)
        16   -> Sd2Card::chipSelectLow()
         0   -> Sd2Card::readData(uint8_t *, uint16_t)
      24   Sd2Card::readData(uint8_t *, uint16_t)
        24   -> HAL_GetTick
        24   -> Sd2Card::chipSelectHigh()
        24   -> Sd2Card::error(uint8_t)
        24   -> spiRead(uint8_t *, uint16_t)
        24   -> spiRec()
        24   -> spiSend(uint8_t)
      16   Sd2Card::readRegister(uint8_t, void *)
        16   -> Sd2Card::cardCommand(uint8_t, uint32_t)
        16   -> Sd2Card::chipSelectHigh()
        16   -> Sd2Card::error(uint8_t)
         0   -> Sd2Card::readData(uint8_t *, uint16_t)
      16   Sd2Card::readStart(uint32_t)
        16   -> Sd2Card::cardCommand(uint8_t, uint32_t)
        16   -> Sd2Card::chipSelectHigh()
        16   -> Sd2Card::error(uint8_t)
        16   -> Sd2Card::type() const
       8   Sd2Card::readStop()
         8   -> Sd2Card::cardCommand(uint8_t, uint32_t)
         8   -> Sd2Card::chipSelectHigh()
         8   -> Sd2Card::chipSelectLow()
         8   -> Sd2Card::error(uint8_t)
       8   Sd2Card::setSckRate(uint8_t)
         8   -> Sd2Card::error(uint8_t)
       0   Sd2Card::type() const
       0   Sd2Card::type(uint8_t)
      16   Sd2Card::waitNotBusy(uint16_t)
        16   -> HAL_GetTick
        16   -> spiRec()
      16   Sd2Card::writeBlock(uint32_t, uint8_t const *)
        16   -> Sd2Card::cardCommand(uint8_t, uint32_t)
        16   -> Sd2Card::chipSelectHigh()
        16   -> Sd2Card::error(uint8_t)
        16   -> Sd2Card::type() const
        16   -> Sd2Card::waitNotBusy(uint16_t)
        16   -> Sd2Card::writeData(uint8_t, uint8_t const *)
        16   -> spiRec()
      16   Sd2Card::writeData(uint8_t const *)
        16   -> Sd2Card::chipSelectHigh()
        16   -> Sd2Card::chipSelectLow()
        16   -> Sd2Card::error(uint8_t)
        16   -> Sd2Card::waitNotBusy(uint16_t)
        16   -> Sd2Card::writeData(uint8_t, uint8_t const *)
       8   Sd2Card::writeData(uint8_t, uint8_t const *)
         8   -> Sd2Card::chipSelectHigh()
         8   -> Sd2Card::error(uint8_t)
         8   -> spiRec()
         8   -> spiSend(uint8_t)
         8   -> spiSendBlock(uint8_t, uint8_t const *)
      16   Sd2Card::writeStart(uint32_t, uint32_t)
        16   -> Sd2Card::cardAcmd(uint8_t, uint32_t)
        16   -> Sd2Card::cardCommand(uint8_t, uint32_t)
        16   -> Sd2Card::chipSelectHigh()
        16   -> Sd2Card::error(uint8_t)
        16   -> Sd2Card::type() const
       8   Sd2Card::writeStop()
         8   -> Sd2Card::chipSelectHigh()
         8   -> Sd2Card::chipSelectLow()
         8   -> Sd2Card::error(uint8_t)
         8   -> Sd2Card::waitNotBusy(uint16_t)
         8   -> spiSend(uint8_t)
      16   spiInit(uint8_t)
        16   -> SPI2_SetSpeed
      12   spiRead(uint8_t *, uint16_t)
       8   spiRec()
         8   -> SPI_I2S_GetFlagStatus
       0   spiSend(uint8_t)
       0   spiSendBlock(uint8_t, uint8_t const *)


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       8  ?_0
      30  Sd2Card::cardAcmd(uint8_t, uint32_t)
     106  Sd2Card::cardCommand(uint8_t, uint32_t)
     134  Sd2Card::cardSize()
       8  Sd2Card::chipSelectHigh()
      16  Sd2Card::chipSelectLow()
     170  Sd2Card::erase(uint32_t, uint32_t)
      36  Sd2Card::eraseSingleBlockEnable()
       4  Sd2Card::error(uint8_t)
     338  Sd2Card::init(uint8_t, uint8_t)
      64  Sd2Card::readBlock(uint32_t, uint8_t *)
       8  Sd2Card::readCSD(csd_t *)
      22  Sd2Card::readData(uint8_t *)
     114  Sd2Card::readData(uint8_t *, uint16_t)
      46  Sd2Card::readRegister(uint8_t, void *)
      58  Sd2Card::readStart(uint32_t)
      50  Sd2Card::readStop()
      24  Sd2Card::setSckRate(uint8_t)
       4  Sd2Card::type() const
       4  Sd2Card::type(uint8_t)
      42  Sd2Card::waitNotBusy(uint16_t)
     130  Sd2Card::writeBlock(uint32_t, uint8_t const *)
      66  Sd2Card::writeData(uint8_t const *)
      60  Sd2Card::writeData(uint8_t, uint8_t const *)
      80  Sd2Card::writeStart(uint32_t, uint32_t)
      70  Sd2Card::writeStop()
      24  spiInit(uint8_t)
      82  spiRead(uint8_t *, uint16_t)
      28  spiRec()
      22  spiSend(uint8_t)
      78  spiSendBlock(uint8_t, uint8_t const *)

 
 1 946 bytes in section .text
 
 1 896 bytes of CODE memory (+ 50 bytes shared)

Errors: none
Warnings: 16
