###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       28/Dec/2020  22:13:57
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\nano\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_tim_ex.c
#    Command line =  
#        -f C:\Users\ADMINI~1\AppData\Local\Temp\EWFF1E.tmp
#        (F:\nano\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_tim_ex.c -D
#        USE_HAL_DRIVER -D STM32F103xE -D MKS_ROBIN -D MARLIN -D __arm__ -D
#        USE_MKS_WIFI --preprocess=s F:\nano\EWARM\mksRobinLite\List -lC
#        F:\nano\EWARM\mksRobinLite\List -lA F:\nano\EWARM\mksRobinLite\List
#        --diag_suppress Pa050 -o F:\nano\EWARM\mksRobinLite\Obj --no_unroll
#        --no_inline --no_tbaa --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --char_is_signed --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Full.h" -I F:\nano\EWARM/../Inc\ -I
#        F:\nano\EWARM/../Src\ -I
#        F:\nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\ -I
#        F:\nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\ -I
#        F:\nano\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/Inc\ -I
#        F:\nano\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\ -I
#        F:\nano\EWARM/../Drivers/CMSIS/Include\ -I
#        F:\nano\EWARM/../Drivers/BSP/STM32MKS-3dPrinter\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/Common\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/l6474\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/at24cxx\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/w25qxx\ -I
#        F:\nano\EWARM/../Drivers/BSP/MotorControl\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/FatFs/src\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/Marlin\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/u8glib_arm_v1.17/src\ -I
#        F:\nano\EWARM/../Middlewares/arduino\ -I
#        F:\nano\EWARM/../Middlewares/arduino/avr\ -I
#        F:\nano\EWARM/../Inc/Logo\ -Om --use_c++_inline -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.0\arm\CMSIS\Core\Include\" -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  F:\nano\EWARM\mksRobinLite\List\stm32f1xx_hal_tim_ex.lst
#    Object file  =  F:\nano\EWARM\mksRobinLite\Obj\stm32f1xx_hal_tim_ex.o
#
###############################################################################

F:\nano\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_tim_ex.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f1xx_hal_tim_ex.c
      4            * @author  MCD Application Team
      5            * @version V1.0.4
      6            * @date    29-April-2016
      7            * @brief   TIM HAL module driver.
      8            *          This file provides firmware functions to manage the following
      9            *          functionalities of the Timer Extended peripheral:
     10            *           + Time Hall Sensor Interface Initialization
     11            *           + Time Hall Sensor Interface Start
     12            *           + Time Complementary signal bread and dead time configuration
     13            *           + Time Master and Slave synchronization configuration
     14            *           + Timer remapping capabilities configuration
     15            @verbatim
     16            ==============================================================================
     17                                ##### TIMER Extended features #####
     18            ==============================================================================
     19            [..]
     20              The Timer Extended features include:
     21              (#) Complementary outputs with programmable dead-time for :
     22                  (++) Output Compare
     23                  (++) PWM generation (Edge and Center-aligned Mode)
     24                  (++) One-pulse mode output
     25              (#) Synchronization circuit to control the timer with external signals and to
     26                  interconnect several timers together.
     27              (#) Break input to put the timer output signals in reset state or in a known state.
     28              (#) Supports incremental (quadrature) encoder and hall-sensor circuitry for
     29                  positioning purposes
     30          
     31                      ##### How to use this driver #####
     32            ==============================================================================
     33              [..]
     34               (#) Initialize the TIM low level resources by implementing the following functions
     35                   depending from feature used :
     36                     (++) Complementary Output Compare : HAL_TIM_OC_MspInit()
     37                     (++) Complementary PWM generation : HAL_TIM_PWM_MspInit()
     38                     (++) Complementary One-pulse mode output : HAL_TIM_OnePulse_MspInit()
     39                     (++) Hall Sensor output : HAL_TIMEx_HallSensor_MspInit()
     40          
     41               (#) Initialize the TIM low level resources :
     42                  (##) Enable the TIM interface clock using __HAL_RCC_TIMx_CLK_ENABLE();
     43                  (##) TIM pins configuration
     44                      (+++) Enable the clock for the TIM GPIOs using the following function:
     45                        __HAL_RCC_GPIOx_CLK_ENABLE();
     46                      (+++) Configure these TIM pins in Alternate function mode using HAL_GPIO_Init();
     47          
     48               (#) The external Clock can be configured, if needed (the default clock is the
     49                   internal clock from the APBx), using the following function:
     50                   HAL_TIM_ConfigClockSource, the clock configuration should be done before
     51                   any start function.
     52          
     53               (#) Configure the TIM in the desired functioning mode using one of the
     54                   initialization function of this driver:
     55                    (++) HAL_TIMEx_HallSensor_Init and HAL_TIMEx_ConfigCommutationEvent: to use the
     56                        Timer Hall Sensor Interface and the commutation event with the corresponding
     57                        Interrupt and DMA request if needed (Note that One Timer is used to interface
     58                       with the Hall sensor Interface and another Timer should be used to use
     59                       the commutation event).
     60          
     61               (#) Activate the TIM peripheral using one of the start functions:
     62                     (++) Complementary Output Compare : HAL_TIMEx_OCN_Start(), HAL_TIMEx_OCN_Start_DMA(), HAL_TIMEx_OCN_Start_IT()
     63                     (++) Complementary PWM generation : HAL_TIMEx_PWMN_Start(), HAL_TIMEx_PWMN_Start_DMA(), HAL_TIMEx_PWMN_Start_IT()
     64                     (++) Complementary One-pulse mode output : HAL_TIMEx_OnePulseN_Start(), HAL_TIMEx_OnePulseN_Start_IT()
     65                     (++) Hall Sensor output : HAL_TIMEx_HallSensor_Start(), HAL_TIMEx_HallSensor_Start_DMA(), HAL_TIMEx_HallSensor_Start_IT().
     66          
     67          
     68            @endverbatim
     69            ******************************************************************************
     70            * @attention
     71            *
     72            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
     73            *
     74            * Redistribution and use in source and binary forms, with or without modification,
     75            * are permitted provided that the following conditions are met:
     76            *   1. Redistributions of source code must retain the above copyright notice,
     77            *      this list of conditions and the following disclaimer.
     78            *   2. Redistributions in binary form must reproduce the above copyright notice,
     79            *      this list of conditions and the following disclaimer in the documentation
     80            *      and/or other materials provided with the distribution.
     81            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     82            *      may be used to endorse or promote products derived from this software
     83            *      without specific prior written permission.
     84            *
     85            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     86            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     87            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     88            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     89            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     90            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     91            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     92            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     93            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     94            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     95            *
     96            ******************************************************************************
     97          */
     98          
     99          /* Includes ------------------------------------------------------------------*/
    100          #include "stm32f1xx_hal.h"
    101          
    102          /** @addtogroup STM32F1xx_HAL_Driver
    103            * @{
    104            */
    105          
    106          /** @defgroup TIMEx TIMEx
    107            * @brief TIM Extended HAL module driver
    108            * @{
    109            */
    110          
    111          #ifdef HAL_TIM_MODULE_ENABLED
    112          
    113          /* Private typedef -----------------------------------------------------------*/
    114          /* Private define ------------------------------------------------------------*/
    115          /* Private macro -------------------------------------------------------------*/
    116          /* Private variables ---------------------------------------------------------*/
    117          /* Private function prototypes -----------------------------------------------*/
    118          
    119          #if defined (STM32F100xB) || defined (STM32F100xE) ||                                                   \
    120              defined (STM32F103x6) || defined (STM32F103xB) || defined (STM32F103xE) || defined (STM32F103xG) || \
    121              defined (STM32F105xC) || defined (STM32F107xC)
    122          /** @defgroup TIMEx_Private_Functions TIMEx Private Functions
    123            * @{
    124            */
    125          static void TIM_CCxNChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelNState);
    126          /**
    127            * @}
    128            */
    129          #endif /* defined(STM32F100xB) || defined(STM32F100xE) ||                                                 */
    130                 /* defined(STM32F103x6) || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG) || */
    131                 /* defined(STM32F105xC) || defined(STM32F107xC)                                                    */
    132          
    133          /* Exported functions ---------------------------------------------------------*/
    134          
    135          /** @defgroup TIMEx_Exported_Functions TIMEx Exported Functions
    136            * @{
    137            */
    138          
    139          
    140          /** @defgroup TIMEx_Exported_Functions_Group1 Timer Hall Sensor functions
    141           *  @brief    Timer Hall Sensor functions
    142           *
    143          @verbatim
    144            ==============================================================================
    145                                ##### Timer Hall Sensor functions #####
    146            ==============================================================================
    147            [..]
    148              This section provides functions allowing to:
    149              (+) Initialize and configure TIM HAL Sensor.
    150              (+) De-initialize TIM HAL Sensor.
    151              (+) Start the Hall Sensor Interface.
    152              (+) Stop the Hall Sensor Interface.
    153              (+) Start the Hall Sensor Interface and enable interrupts.
    154              (+) Stop the Hall Sensor Interface and disable interrupts.
    155              (+) Start the Hall Sensor Interface and enable DMA transfers.
    156              (+) Stop the Hall Sensor Interface and disable DMA transfers.
    157          
    158          @endverbatim
    159            * @{
    160            */
    161          /**
    162            * @brief  Initializes the TIM Hall Sensor Interface and create the associated handle.
    163            * @param  htim : TIM Encoder Interface handle
    164            * @param  sConfig : TIM Hall Sensor configuration structure
    165            * @retval HAL status
    166            */

   \                                 In section .text, align 2, keep-with-next
    167          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Init(TIM_HandleTypeDef *htim, TIM_HallSensor_InitTypeDef* sConfig)
    168          {
   \                     HAL_TIMEx_HallSensor_Init: (+1)
   \   00000000   0xB578             PUSH     {R3-R6,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460E             MOV      R6,R1
    169            TIM_OC_InitTypeDef OC_Config;
    170          
    171            /* Check the TIM handle allocation */
    172            if(htim == NULL)
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD101             BNE.N    ??HAL_TIMEx_HallSensor_Init_0
    173            {
    174              return HAL_ERROR;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE055             B.N      ??HAL_TIMEx_HallSensor_Init_1
    175            }
    176          
    177            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
    178            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    179            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    180            assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
    181            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
    182            assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
    183          
    184            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIMEx_HallSensor_Init_0: (+1)
   \   00000010   0xF104 0x0538      ADD      R5,R4,#+56
   \   00000014   0xF995 0x0001      LDRSB    R0,[R5, #+1]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD104             BNE.N    ??HAL_TIMEx_HallSensor_Init_2
    185            {
    186              /* Allocate lock resource and initialize it */
    187              htim->Lock = HAL_UNLOCKED;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x7028             STRB     R0,[R5, #+0]
    188              
    189              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    190              HAL_TIMEx_HallSensor_MspInit(htim);
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       HAL_TIMEx_HallSensor_MspInit
    191            }
    192          
    193            /* Set the TIM state */
    194            htim->State= HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIMEx_HallSensor_Init_2: (+1)
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0x7068             STRB     R0,[R5, #+1]
    195          
    196            /* Configure the Time base in the Encoder Mode */
    197            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \   0000002A   0x1D21             ADDS     R1,R4,#+4
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x.... 0x....      BL       TIM_Base_SetConfig
    198          
    199            /* Configure the Channel 1 as Input Channel to interface with the three Outputs of the  Hall sensor */
    200            TIM_TI1_SetConfig(htim->Instance, sConfig->IC1Polarity, TIM_ICSELECTION_TRC, sConfig->IC1Filter);
   \   00000032   0x68B3             LDR      R3,[R6, #+8]
   \   00000034   0x2203             MOVS     R2,#+3
   \   00000036   0x6831             LDR      R1,[R6, #+0]
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x.... 0x....      BL       TIM_TI1_SetConfig
    201          
    202            /* Reset the IC1PSC Bits */
    203            htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6981             LDR      R1,[R0, #+24]
   \   00000042   0xF021 0x010C      BIC      R1,R1,#0xC
   \   00000046   0x6181             STR      R1,[R0, #+24]
    204            /* Set the IC1PSC value */
    205            htim->Instance->CCMR1 |= sConfig->IC1Prescaler;
   \   00000048   0x6821             LDR      R1,[R4, #+0]
   \   0000004A   0x698A             LDR      R2,[R1, #+24]
   \   0000004C   0x6870             LDR      R0,[R6, #+4]
   \   0000004E   0x4302             ORRS     R2,R0,R2
   \   00000050   0x618A             STR      R2,[R1, #+24]
    206          
    207            /* Enable the Hall sensor interface (XOR function of the three inputs) */
    208            htim->Instance->CR2 |= TIM_CR2_TI1S;
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x6841             LDR      R1,[R0, #+4]
   \   00000056   0xF041 0x0180      ORR      R1,R1,#0x80
   \   0000005A   0x6041             STR      R1,[R0, #+4]
    209          
    210            /* Select the TIM_TS_TI1F_ED signal as Input trigger for the TIM */
    211            htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6881             LDR      R1,[R0, #+8]
   \   00000060   0xF021 0x0170      BIC      R1,R1,#0x70
   \   00000064   0x6081             STR      R1,[R0, #+8]
    212            htim->Instance->SMCR |= TIM_TS_TI1F_ED;
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x6881             LDR      R1,[R0, #+8]
   \   0000006A   0xF041 0x0140      ORR      R1,R1,#0x40
   \   0000006E   0x6081             STR      R1,[R0, #+8]
    213          
    214            /* Use the TIM_TS_TI1F_ED signal to reset the TIM counter each edge detection */
    215            htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x6881             LDR      R1,[R0, #+8]
   \   00000074   0x08C9             LSRS     R1,R1,#+3
   \   00000076   0x00C9             LSLS     R1,R1,#+3
   \   00000078   0x6081             STR      R1,[R0, #+8]
    216            htim->Instance->SMCR |= TIM_SLAVEMODE_RESET;
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x6881             LDR      R1,[R0, #+8]
   \   0000007E   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000082   0x6081             STR      R1,[R0, #+8]
    217          
    218            /* Program channel 2 in PWM 2 mode with the desired Commutation_Delay*/
    219            OC_Config.OCFastMode = TIM_OCFAST_DISABLE;
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x9004             STR      R0,[SP, #+16]
    220            OC_Config.OCIdleState = TIM_OCIDLESTATE_RESET;
   \   00000088   0x9005             STR      R0,[SP, #+20]
    221            OC_Config.OCMode = TIM_OCMODE_PWM2;
   \   0000008A   0x2070             MOVS     R0,#+112
   \   0000008C   0x9000             STR      R0,[SP, #+0]
    222            OC_Config.OCNIdleState = TIM_OCNIDLESTATE_RESET;
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x9006             STR      R0,[SP, #+24]
    223            OC_Config.OCNPolarity = TIM_OCNPOLARITY_HIGH;
   \   00000092   0x9003             STR      R0,[SP, #+12]
    224            OC_Config.OCPolarity = TIM_OCPOLARITY_HIGH;
   \   00000094   0x9002             STR      R0,[SP, #+8]
    225            OC_Config.Pulse = sConfig->Commutation_Delay;
   \   00000096   0x68F0             LDR      R0,[R6, #+12]
   \   00000098   0x9001             STR      R0,[SP, #+4]
    226          
    227            TIM_OC2_SetConfig(htim->Instance, &OC_Config);
   \   0000009A   0x4669             MOV      R1,SP
   \   0000009C   0x6820             LDR      R0,[R4, #+0]
   \   0000009E   0x.... 0x....      BL       TIM_OC2_SetConfig
    228          
    229            /* Select OC2REF as trigger output on TRGO: write the MMS bits in the TIMx_CR2
    230              register to 101 */
    231            htim->Instance->CR2 &= ~TIM_CR2_MMS;
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x6841             LDR      R1,[R0, #+4]
   \   000000A6   0xF021 0x0170      BIC      R1,R1,#0x70
   \   000000AA   0x6041             STR      R1,[R0, #+4]
    232            htim->Instance->CR2 |= TIM_TRGO_OC2REF;
   \   000000AC   0x6820             LDR      R0,[R4, #+0]
   \   000000AE   0x6841             LDR      R1,[R0, #+4]
   \   000000B0   0xF041 0x0150      ORR      R1,R1,#0x50
   \   000000B4   0x6041             STR      R1,[R0, #+4]
    233          
    234            /* Initialize the TIM state*/
    235            htim->State= HAL_TIM_STATE_READY;
   \   000000B6   0x2001             MOVS     R0,#+1
   \   000000B8   0x7068             STRB     R0,[R5, #+1]
    236          
    237            return HAL_OK;
   \   000000BA   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_HallSensor_Init_1: (+1)
   \   000000BC   0xB008             ADD      SP,SP,#+32
   \   000000BE   0xBD70             POP      {R4-R6,PC}       ;; return
    238          }
    239          
    240          /**
    241            * @brief  DeInitializes the TIM Hall Sensor interface
    242            * @param  htim : TIM Hall Sensor handle
    243            * @retval HAL status
    244            */

   \                                 In section .text, align 2, keep-with-next
    245          HAL_StatusTypeDef HAL_TIMEx_HallSensor_DeInit(TIM_HandleTypeDef *htim)
    246          {
   \                     HAL_TIMEx_HallSensor_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    247            /* Check the parameters */
    248            assert_param(IS_TIM_INSTANCE(htim->Instance));
    249          
    250            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
    251          
    252            /* Disable the TIM Peripheral Clock */
    253            __HAL_TIM_DISABLE(htim);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6A01             LDR      R1,[R0, #+32]
   \   0000000E   0xF241 0x1211      MOVW     R2,#+4369
   \   00000012   0x4211             TST      R1,R2
   \   00000014   0xD108             BNE.N    ??HAL_TIMEx_HallSensor_DeInit_0
   \   00000016   0x6A01             LDR      R1,[R0, #+32]
   \   00000018   0xF240 0x4244      MOVW     R2,#+1092
   \   0000001C   0x4211             TST      R1,R2
   \   0000001E   0xD103             BNE.N    ??HAL_TIMEx_HallSensor_DeInit_0
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x0849             LSRS     R1,R1,#+1
   \   00000024   0x0049             LSLS     R1,R1,#+1
   \   00000026   0x6001             STR      R1,[R0, #+0]
    254          
    255            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    256            HAL_TIMEx_HallSensor_MspDeInit(htim);
   \                     ??HAL_TIMEx_HallSensor_DeInit_0: (+1)
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_TIMEx_HallSensor_MspDeInit
    257          
    258            /* Change TIM state */
    259            htim->State = HAL_TIM_STATE_RESET;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF884 0x0039      STRB     R0,[R4, #+57]
    260          
    261            /* Release Lock */
    262            __HAL_UNLOCK(htim);
    263          
    264            return HAL_OK;
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    265          }
    266          
    267          /**
    268            * @brief  Initializes the TIM Hall Sensor MSP.
    269            * @param  htim : TIM handle
    270            * @retval None
    271            */

   \                                 In section .text, align 2
    272          __weak void HAL_TIMEx_HallSensor_MspInit(TIM_HandleTypeDef *htim)
    273          {
    274            /* Prevent unused argument(s) compilation warning */
    275            UNUSED(htim);
    276            /* NOTE : This function Should not be modified, when the callback is needed,
    277                      the HAL_TIMEx_HallSensor_MspInit could be implemented in the user file
    278             */
    279          }
   \                     HAL_TIMEx_HallSensor_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    280          
    281          /**
    282            * @brief  DeInitializes TIM Hall Sensor MSP.
    283            * @param  htim : TIM handle
    284            * @retval None
    285            */

   \                                 In section .text, align 2
    286          __weak void HAL_TIMEx_HallSensor_MspDeInit(TIM_HandleTypeDef *htim)
    287          {
    288            /* Prevent unused argument(s) compilation warning */
    289            UNUSED(htim);
    290            /* NOTE : This function Should not be modified, when the callback is needed,
    291                      the HAL_TIMEx_HallSensor_MspDeInit could be implemented in the user file
    292             */
    293          }
   \                     HAL_TIMEx_HallSensor_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    294          
    295          /**
    296            * @brief  Starts the TIM Hall Sensor Interface.
    297            * @param  htim : TIM Hall Sensor handle
    298            * @retval HAL status
    299            */

   \                                 In section .text, align 2, keep-with-next
    300          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start(TIM_HandleTypeDef *htim)
    301          {
   \                     HAL_TIMEx_HallSensor_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    302            /* Check the parameters */
    303            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
    304          
    305            /* Enable the Input Capture channel 1
    306              (in the Hall Sensor Interface the 3 possible channels that are used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
    307            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x.... 0x....      BL       TIM_CCxChannelCmd
    308          
    309            /* Enable the Peripheral */
    310            __HAL_TIM_ENABLE(htim);
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6801             LDR      R1,[R0, #+0]
   \   00000012   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000016   0x6001             STR      R1,[R0, #+0]
    311          
    312            /* Return function status */
    313            return HAL_OK;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    314          }
    315          
    316          /**
    317            * @brief  Stops the TIM Hall sensor Interface.
    318            * @param  htim : TIM Hall Sensor handle
    319            * @retval HAL status
    320            */

   \                                 In section .text, align 2, keep-with-next
    321          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop(TIM_HandleTypeDef *htim)
    322          {
   \                     HAL_TIMEx_HallSensor_Stop: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    323            /* Check the parameters */
    324            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
    325          
    326            /* Disable the Input Capture channel 1
    327              (in the Hall Sensor Interface the 3 possible channels that are used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
    328            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x4611             MOV      R1,R2
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x.... 0x....      BL       TIM_CCxChannelCmd
    329          
    330            /* Disable the Peripheral */
    331            __HAL_TIM_DISABLE(htim);
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6A01             LDR      R1,[R0, #+32]
   \   00000012   0xF241 0x1211      MOVW     R2,#+4369
   \   00000016   0x4211             TST      R1,R2
   \   00000018   0xD108             BNE.N    ??HAL_TIMEx_HallSensor_Stop_0
   \   0000001A   0x6A01             LDR      R1,[R0, #+32]
   \   0000001C   0xF240 0x4244      MOVW     R2,#+1092
   \   00000020   0x4211             TST      R1,R2
   \   00000022   0xD103             BNE.N    ??HAL_TIMEx_HallSensor_Stop_0
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0x0849             LSRS     R1,R1,#+1
   \   00000028   0x0049             LSLS     R1,R1,#+1
   \   0000002A   0x6001             STR      R1,[R0, #+0]
    332          
    333            /* Return function status */
    334            return HAL_OK;
   \                     ??HAL_TIMEx_HallSensor_Stop_0: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    335          }
    336          
    337          /**
    338            * @brief  Starts the TIM Hall Sensor Interface in interrupt mode.
    339            * @param  htim : TIM Hall Sensor handle
    340            * @retval HAL status
    341            */

   \                                 In section .text, align 2, keep-with-next
    342          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_IT(TIM_HandleTypeDef *htim)
    343          {
   \                     HAL_TIMEx_HallSensor_Start_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    344            /* Check the parameters */
    345            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
    346          
    347            /* Enable the capture compare Interrupts 1 event */
    348            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x68C1             LDR      R1,[R0, #+12]
   \   00000008   0xF041 0x0102      ORR      R1,R1,#0x2
   \   0000000C   0x60C1             STR      R1,[R0, #+12]
    349          
    350            /* Enable the Input Capture channel 1
    351              (in the Hall Sensor Interface the 3 possible channels that are used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
    352            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x.... 0x....      BL       TIM_CCxChannelCmd
    353          
    354            /* Enable the Peripheral */
    355            __HAL_TIM_ENABLE(htim);
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x6801             LDR      R1,[R0, #+0]
   \   0000001C   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000020   0x6001             STR      R1,[R0, #+0]
    356          
    357            /* Return function status */
    358            return HAL_OK;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    359          }
    360          
    361          /**
    362            * @brief  Stops the TIM Hall Sensor Interface in interrupt mode.
    363            * @param  htim : TIM handle
    364            * @retval HAL status
    365            */

   \                                 In section .text, align 2, keep-with-next
    366          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_IT(TIM_HandleTypeDef *htim)
    367          {
   \                     HAL_TIMEx_HallSensor_Stop_IT: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    368            /* Check the parameters */
    369            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
    370          
    371            /* Disable the Input Capture channel 1
    372              (in the Hall Sensor Interface the 3 possible channels that are used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
    373            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x4611             MOV      R1,R2
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x.... 0x....      BL       TIM_CCxChannelCmd
    374          
    375            /* Disable the capture compare Interrupts event */
    376            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x68C1             LDR      R1,[R0, #+12]
   \   00000012   0xF021 0x0102      BIC      R1,R1,#0x2
   \   00000016   0x60C1             STR      R1,[R0, #+12]
    377          
    378            /* Disable the Peripheral */
    379            __HAL_TIM_DISABLE(htim);
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x6A01             LDR      R1,[R0, #+32]
   \   0000001C   0xF241 0x1211      MOVW     R2,#+4369
   \   00000020   0x4211             TST      R1,R2
   \   00000022   0xD108             BNE.N    ??HAL_TIMEx_HallSensor_Stop_IT_0
   \   00000024   0x6A01             LDR      R1,[R0, #+32]
   \   00000026   0xF240 0x4244      MOVW     R2,#+1092
   \   0000002A   0x4211             TST      R1,R2
   \   0000002C   0xD103             BNE.N    ??HAL_TIMEx_HallSensor_Stop_IT_0
   \   0000002E   0x6801             LDR      R1,[R0, #+0]
   \   00000030   0x0849             LSRS     R1,R1,#+1
   \   00000032   0x0049             LSLS     R1,R1,#+1
   \   00000034   0x6001             STR      R1,[R0, #+0]
    380          
    381            /* Return function status */
    382            return HAL_OK;
   \                     ??HAL_TIMEx_HallSensor_Stop_IT_0: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    383          }
    384          
    385          /**
    386            * @brief  Starts the TIM Hall Sensor Interface in DMA mode.
    387            * @param  htim : TIM Hall Sensor handle
    388            * @param  pData : The destination Buffer address.
    389            * @param  Length : The length of data to be transferred from TIM peripheral to memory.
    390            * @retval HAL status
    391            */

   \                                 In section .text, align 2, keep-with-next
    392          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
    393          {
   \                     HAL_TIMEx_HallSensor_Start_DMA: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460C             MOV      R4,R1
   \   00000006   0x4616             MOV      R6,R2
    394            /* Check the parameters */
    395            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
    396          
    397             if((htim->State == HAL_TIM_STATE_BUSY))
   \   00000008   0xF995 0x0039      LDRSB    R0,[R5, #+57]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD101             BNE.N    ??HAL_TIMEx_HallSensor_Start_DMA_0
    398            {
    399               return HAL_BUSY;
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xBD76             POP      {R1,R2,R4-R6,PC}
    400            }
    401            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIMEx_HallSensor_Start_DMA_0: (+1)
   \   00000014   0xF995 0x0039      LDRSB    R0,[R5, #+57]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD108             BNE.N    ??HAL_TIMEx_HallSensor_Start_DMA_1
    402            {
    403              if(((uint32_t)pData == 0 ) && (Length > 0))
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD103             BNE.N    ??HAL_TIMEx_HallSensor_Start_DMA_2
   \   00000020   0x0030             MOVS     R0,R6
   \   00000022   0xD001             BEQ.N    ??HAL_TIMEx_HallSensor_Start_DMA_2
    404              {
    405                return HAL_ERROR;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xBD76             POP      {R1,R2,R4-R6,PC}
    406              }
    407              else
    408              {
    409                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIMEx_HallSensor_Start_DMA_2: (+1)
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xF885 0x0039      STRB     R0,[R5, #+57]
    410              }
    411            }
    412            /* Enable the Input Capture channel 1
    413              (in the Hall Sensor Interface the 3 possible channels that are used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
    414            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIMEx_HallSensor_Start_DMA_1: (+1)
   \   0000002E   0x2201             MOVS     R2,#+1
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x6828             LDR      R0,[R5, #+0]
   \   00000034   0x.... 0x....      BL       TIM_CCxChannelCmd
    415          
    416            /* Set the DMA Input Capture 1 Callback */
    417            htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable4
   \   0000003C   0x6A29             LDR      R1,[R5, #+32]
   \   0000003E   0x6288             STR      R0,[R1, #+40]
    418            /* Set the DMA error callback */
    419            htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \   00000044   0x6A29             LDR      R1,[R5, #+32]
   \   00000046   0x6308             STR      R0,[R1, #+48]
    420          
    421            /* Enable the DMA channel for Capture 1*/
    422            HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length);
   \   00000048   0x4633             MOV      R3,R6
   \   0000004A   0x4622             MOV      R2,R4
   \   0000004C   0x6828             LDR      R0,[R5, #+0]
   \   0000004E   0xF100 0x0134      ADD      R1,R0,#+52
   \   00000052   0x6A28             LDR      R0,[R5, #+32]
   \   00000054   0x.... 0x....      BL       HAL_DMA_Start_IT
    423          
    424            /* Enable the capture compare 1 Interrupt */
    425            __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   00000058   0x6828             LDR      R0,[R5, #+0]
   \   0000005A   0x68C1             LDR      R1,[R0, #+12]
   \   0000005C   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000060   0x60C1             STR      R1,[R0, #+12]
    426          
    427            /* Enable the Peripheral */
    428            __HAL_TIM_ENABLE(htim);
   \   00000062   0x6828             LDR      R0,[R5, #+0]
   \   00000064   0x6801             LDR      R1,[R0, #+0]
   \   00000066   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000006A   0x6001             STR      R1,[R0, #+0]
    429          
    430            /* Return function status */
    431            return HAL_OK;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    432          }
    433          
    434          /**
    435            * @brief  Stops the TIM Hall Sensor Interface in DMA mode.
    436            * @param  htim : TIM handle
    437            * @retval HAL status
    438            */

   \                                 In section .text, align 2, keep-with-next
    439          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_DMA(TIM_HandleTypeDef *htim)
    440          {
   \                     HAL_TIMEx_HallSensor_Stop_DMA: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    441            /* Check the parameters */
    442            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
    443          
    444            /* Disable the Input Capture channel 1
    445              (in the Hall Sensor Interface the 3 possible channels that are used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
    446            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x4611             MOV      R1,R2
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x.... 0x....      BL       TIM_CCxChannelCmd
    447          
    448          
    449            /* Disable the capture compare Interrupts 1 event */
    450            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x68C1             LDR      R1,[R0, #+12]
   \   00000012   0xF421 0x7100      BIC      R1,R1,#0x200
   \   00000016   0x60C1             STR      R1,[R0, #+12]
    451          
    452            /* Disable the Peripheral */
    453            __HAL_TIM_DISABLE(htim);
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x6A01             LDR      R1,[R0, #+32]
   \   0000001C   0xF241 0x1211      MOVW     R2,#+4369
   \   00000020   0x4211             TST      R1,R2
   \   00000022   0xD108             BNE.N    ??HAL_TIMEx_HallSensor_Stop_DMA_0
   \   00000024   0x6A01             LDR      R1,[R0, #+32]
   \   00000026   0xF240 0x4244      MOVW     R2,#+1092
   \   0000002A   0x4211             TST      R1,R2
   \   0000002C   0xD103             BNE.N    ??HAL_TIMEx_HallSensor_Stop_DMA_0
   \   0000002E   0x6801             LDR      R1,[R0, #+0]
   \   00000030   0x0849             LSRS     R1,R1,#+1
   \   00000032   0x0049             LSLS     R1,R1,#+1
   \   00000034   0x6001             STR      R1,[R0, #+0]
    454          
    455            /* Return function status */
    456            return HAL_OK;
   \                     ??HAL_TIMEx_HallSensor_Stop_DMA_0: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    457          }
    458          
    459          /**
    460            * @}
    461            */
    462          
    463          #if defined (STM32F100xB) || defined (STM32F100xE) ||                                                   \
    464              defined (STM32F103x6) || defined (STM32F103xB) || defined (STM32F103xE) || defined (STM32F103xG) || \
    465              defined (STM32F105xC) || defined (STM32F107xC)
    466          
    467          /** @defgroup TIMEx_Exported_Functions_Group2 Timer Complementary Output Compare functions
    468           *  @brief    Timer Complementary Output Compare functions
    469           *
    470          @verbatim
    471            ==============================================================================
    472                        ##### Timer Complementary Output Compare functions #####
    473            ==============================================================================
    474            [..]
    475              This section provides functions allowing to:
    476              (+) Start the Complementary Output Compare/PWM.
    477              (+) Stop the Complementary Output Compare/PWM.
    478              (+) Start the Complementary Output Compare/PWM and enable interrupts.
    479              (+) Stop the Complementary Output Compare/PWM and disable interrupts.
    480              (+) Start the Complementary Output Compare/PWM and enable DMA transfers.
    481              (+) Stop the Complementary Output Compare/PWM and disable DMA transfers.
    482          
    483          @endverbatim
    484            * @{
    485            */
    486          
    487          /**
    488            * @brief  Starts the TIM Output Compare signal generation on the complementary
    489            *         output.
    490            * @param  htim : TIM Output Compare handle
    491            * @param  Channel : TIM Channel to be enabled
    492            *          This parameter can be one of the following values:
    493            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    494            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    495            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    496            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    497            * @retval HAL status
    498            */

   \                                 In section .text, align 2, keep-with-next
    499          HAL_StatusTypeDef HAL_TIMEx_OCN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
    500          {
   \                     HAL_TIMEx_OCN_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    501            /* Check the parameters */
    502            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    503          
    504            /* Enable the Capture compare channel N */
    505            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   \   00000004   0x2204             MOVS     R2,#+4
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_CCxNChannelCmd
    506          
    507            /* Enable the Main Ouput */
    508            __HAL_TIM_MOE_ENABLE(htim);
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6C41             LDR      R1,[R0, #+68]
   \   00000010   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000014   0x6441             STR      R1,[R0, #+68]
    509          
    510            /* Enable the Peripheral */
    511            __HAL_TIM_ENABLE(htim);
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000001E   0x6001             STR      R1,[R0, #+0]
    512          
    513            /* Return function status */
    514            return HAL_OK;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    515          }
    516          
    517          /**
    518            * @brief  Stops the TIM Output Compare signal generation on the complementary
    519            *         output.
    520            * @param  htim : TIM handle
    521            * @param  Channel : TIM Channel to be disabled
    522            *          This parameter can be one of the following values:
    523            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    524            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    525            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    526            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    527            * @retval HAL status
    528            */

   \                                 In section .text, align 2, keep-with-next
    529          HAL_StatusTypeDef HAL_TIMEx_OCN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
    530          {
   \                     HAL_TIMEx_OCN_Stop: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    531            /* Check the parameters */
    532            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    533          
    534            /* Disable the Capture compare channel N */
    535            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_CCxNChannelCmd
    536          
    537            /* Disable the Main Ouput */
    538            __HAL_TIM_MOE_DISABLE(htim);
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000012   0x6A02             LDR      R2,[R0, #+32]
   \   00000014   0x420A             TST      R2,R1
   \   00000016   0xD108             BNE.N    ??HAL_TIMEx_OCN_Stop_0
   \   00000018   0x6A02             LDR      R2,[R0, #+32]
   \   0000001A   0xF240 0x4344      MOVW     R3,#+1092
   \   0000001E   0x421A             TST      R2,R3
   \   00000020   0xD103             BNE.N    ??HAL_TIMEx_OCN_Stop_0
   \   00000022   0x6C42             LDR      R2,[R0, #+68]
   \   00000024   0xF422 0x4200      BIC      R2,R2,#0x8000
   \   00000028   0x6442             STR      R2,[R0, #+68]
    539          
    540            /* Disable the Peripheral */
    541            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_OCN_Stop_0: (+1)
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x6A02             LDR      R2,[R0, #+32]
   \   0000002E   0x420A             TST      R2,R1
   \   00000030   0xD108             BNE.N    ??HAL_TIMEx_OCN_Stop_1
   \   00000032   0x6A01             LDR      R1,[R0, #+32]
   \   00000034   0xF240 0x4244      MOVW     R2,#+1092
   \   00000038   0x4211             TST      R1,R2
   \   0000003A   0xD103             BNE.N    ??HAL_TIMEx_OCN_Stop_1
   \   0000003C   0x6801             LDR      R1,[R0, #+0]
   \   0000003E   0x0849             LSRS     R1,R1,#+1
   \   00000040   0x0049             LSLS     R1,R1,#+1
   \   00000042   0x6001             STR      R1,[R0, #+0]
    542          
    543            /* Return function status */
    544            return HAL_OK;
   \                     ??HAL_TIMEx_OCN_Stop_1: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    545          }
    546          
    547          /**
    548            * @brief  Starts the TIM Output Compare signal generation in interrupt mode
    549            *         on the complementary output.
    550            * @param  htim : TIM OC handle
    551            * @param  Channel : TIM Channel to be enabled
    552            *          This parameter can be one of the following values:
    553            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    554            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    555            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    556            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    557            * @retval HAL status
    558            */

   \                                 In section .text, align 2, keep-with-next
    559          HAL_StatusTypeDef HAL_TIMEx_OCN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    560          {
   \                     HAL_TIMEx_OCN_Start_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    561            /* Check the parameters */
    562            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    563          
    564            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIMEx_OCN_Start_IT_0
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD00A             BEQ.N    ??HAL_TIMEx_OCN_Start_IT_1
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD00E             BEQ.N    ??HAL_TIMEx_OCN_Start_IT_2
   \   00000010   0x280C             CMP      R0,#+12
   \   00000012   0xD012             BEQ.N    ??HAL_TIMEx_OCN_Start_IT_3
   \   00000014   0xE016             B.N      ??HAL_TIMEx_OCN_Start_IT_4
    565            {
    566              case TIM_CHANNEL_1:
    567              {
    568                /* Enable the TIM Output Compare interrupt */
    569                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIMEx_OCN_Start_IT_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x68C2             LDR      R2,[R0, #+12]
   \   0000001A   0xF042 0x0202      ORR      R2,R2,#0x2
   \   0000001E   0x60C2             STR      R2,[R0, #+12]
    570              }
    571              break;
   \   00000020   0xE010             B.N      ??HAL_TIMEx_OCN_Start_IT_4
    572          
    573              case TIM_CHANNEL_2:
    574              {
    575                /* Enable the TIM Output Compare interrupt */
    576                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIMEx_OCN_Start_IT_1: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C2             LDR      R2,[R0, #+12]
   \   00000026   0xF042 0x0204      ORR      R2,R2,#0x4
   \   0000002A   0x60C2             STR      R2,[R0, #+12]
    577              }
    578              break;
   \   0000002C   0xE00A             B.N      ??HAL_TIMEx_OCN_Start_IT_4
    579          
    580              case TIM_CHANNEL_3:
    581              {
    582                /* Enable the TIM Output Compare interrupt */
    583                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIMEx_OCN_Start_IT_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68C2             LDR      R2,[R0, #+12]
   \   00000032   0xF042 0x0208      ORR      R2,R2,#0x8
   \   00000036   0x60C2             STR      R2,[R0, #+12]
    584              }
    585              break;
   \   00000038   0xE004             B.N      ??HAL_TIMEx_OCN_Start_IT_4
    586          
    587              case TIM_CHANNEL_4:
    588              {
    589                /* Enable the TIM Output Compare interrupt */
    590                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIMEx_OCN_Start_IT_3: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x68C2             LDR      R2,[R0, #+12]
   \   0000003E   0xF042 0x0210      ORR      R2,R2,#0x10
   \   00000042   0x60C2             STR      R2,[R0, #+12]
    591              }
    592              break;
    593          
    594              default:
    595              break;
    596            }
    597          
    598            /* Enable the TIM Break interrupt */
    599            __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
   \                     ??HAL_TIMEx_OCN_Start_IT_4: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x68C2             LDR      R2,[R0, #+12]
   \   00000048   0xF042 0x0280      ORR      R2,R2,#0x80
   \   0000004C   0x60C2             STR      R2,[R0, #+12]
    600          
    601            /* Enable the Capture compare channel N */
    602            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   \   0000004E   0x2204             MOVS     R2,#+4
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x.... 0x....      BL       TIM_CCxNChannelCmd
    603          
    604            /* Enable the Main Ouput */
    605            __HAL_TIM_MOE_ENABLE(htim);
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x6C41             LDR      R1,[R0, #+68]
   \   0000005A   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000005E   0x6441             STR      R1,[R0, #+68]
    606          
    607            /* Enable the Peripheral */
    608            __HAL_TIM_ENABLE(htim);
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x6801             LDR      R1,[R0, #+0]
   \   00000064   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000068   0x6001             STR      R1,[R0, #+0]
    609          
    610            /* Return function status */
    611            return HAL_OK;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xBD10             POP      {R4,PC}          ;; return
    612          }
    613          
    614          /**
    615            * @brief  Stops the TIM Output Compare signal generation in interrupt mode
    616            *         on the complementary output.
    617            * @param  htim : TIM Output Compare handle
    618            * @param  Channel : TIM Channel to be disabled
    619            *          This parameter can be one of the following values:
    620            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    621            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    622            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    623            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    624            * @retval HAL status
    625            */

   \                                 In section .text, align 2, keep-with-next
    626          HAL_StatusTypeDef HAL_TIMEx_OCN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    627          {
   \                     HAL_TIMEx_OCN_Stop_IT: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    628            uint32_t tmpccer = 0;
    629          
    630            /* Check the parameters */
    631            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    632          
    633            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIMEx_OCN_Stop_IT_0
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD00A             BEQ.N    ??HAL_TIMEx_OCN_Stop_IT_1
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD00E             BEQ.N    ??HAL_TIMEx_OCN_Stop_IT_2
   \   00000010   0x280C             CMP      R0,#+12
   \   00000012   0xD012             BEQ.N    ??HAL_TIMEx_OCN_Stop_IT_3
   \   00000014   0xE016             B.N      ??HAL_TIMEx_OCN_Stop_IT_4
    634            {
    635              case TIM_CHANNEL_1:
    636              {
    637                /* Disable the TIM Output Compare interrupt */
    638                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIMEx_OCN_Stop_IT_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x68C2             LDR      R2,[R0, #+12]
   \   0000001A   0xF022 0x0202      BIC      R2,R2,#0x2
   \   0000001E   0x60C2             STR      R2,[R0, #+12]
    639              }
    640              break;
   \   00000020   0xE010             B.N      ??HAL_TIMEx_OCN_Stop_IT_4
    641          
    642              case TIM_CHANNEL_2:
    643              {
    644                /* Disable the TIM Output Compare interrupt */
    645                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIMEx_OCN_Stop_IT_1: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C2             LDR      R2,[R0, #+12]
   \   00000026   0xF022 0x0204      BIC      R2,R2,#0x4
   \   0000002A   0x60C2             STR      R2,[R0, #+12]
    646              }
    647              break;
   \   0000002C   0xE00A             B.N      ??HAL_TIMEx_OCN_Stop_IT_4
    648          
    649              case TIM_CHANNEL_3:
    650              {
    651                /* Disable the TIM Output Compare interrupt */
    652                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIMEx_OCN_Stop_IT_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68C2             LDR      R2,[R0, #+12]
   \   00000032   0xF022 0x0208      BIC      R2,R2,#0x8
   \   00000036   0x60C2             STR      R2,[R0, #+12]
    653              }
    654              break;
   \   00000038   0xE004             B.N      ??HAL_TIMEx_OCN_Stop_IT_4
    655          
    656              case TIM_CHANNEL_4:
    657              {
    658                /* Disable the TIM Output Compare interrupt */
    659                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIMEx_OCN_Stop_IT_3: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x68C2             LDR      R2,[R0, #+12]
   \   0000003E   0xF022 0x0210      BIC      R2,R2,#0x10
   \   00000042   0x60C2             STR      R2,[R0, #+12]
    660              }
    661              break;
    662          
    663              default:
    664              break;
    665            }
    666          
    667            /* Disable the Capture compare channel N */
    668            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
   \                     ??HAL_TIMEx_OCN_Stop_IT_4: (+1)
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       TIM_CCxNChannelCmd
    669          
    670            /* Disable the TIM Break interrupt (only if no more channel is active) */
    671            tmpccer = htim->Instance->CCER;
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6A02             LDR      R2,[R0, #+32]
    672            if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == RESET)
   \   00000050   0xF240 0x4144      MOVW     R1,#+1092
   \   00000054   0x420A             TST      R2,R1
   \   00000056   0xD103             BNE.N    ??HAL_TIMEx_OCN_Stop_IT_5
    673            {
    674              __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
   \   00000058   0x68C2             LDR      R2,[R0, #+12]
   \   0000005A   0xF022 0x0280      BIC      R2,R2,#0x80
   \   0000005E   0x60C2             STR      R2,[R0, #+12]
    675            }
    676          
    677            /* Disable the Main Ouput */
    678            __HAL_TIM_MOE_DISABLE(htim);
   \                     ??HAL_TIMEx_OCN_Stop_IT_5: (+1)
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0xF241 0x1211      MOVW     R2,#+4369
   \   00000066   0x6A03             LDR      R3,[R0, #+32]
   \   00000068   0x4213             TST      R3,R2
   \   0000006A   0xD106             BNE.N    ??HAL_TIMEx_OCN_Stop_IT_6
   \   0000006C   0x6A03             LDR      R3,[R0, #+32]
   \   0000006E   0x420B             TST      R3,R1
   \   00000070   0xD103             BNE.N    ??HAL_TIMEx_OCN_Stop_IT_6
   \   00000072   0x6C43             LDR      R3,[R0, #+68]
   \   00000074   0xF423 0x4300      BIC      R3,R3,#0x8000
   \   00000078   0x6443             STR      R3,[R0, #+68]
    679          
    680            /* Disable the Peripheral */
    681            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_OCN_Stop_IT_6: (+1)
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x6A03             LDR      R3,[R0, #+32]
   \   0000007E   0x4213             TST      R3,R2
   \   00000080   0xD106             BNE.N    ??HAL_TIMEx_OCN_Stop_IT_7
   \   00000082   0x6A02             LDR      R2,[R0, #+32]
   \   00000084   0x420A             TST      R2,R1
   \   00000086   0xD103             BNE.N    ??HAL_TIMEx_OCN_Stop_IT_7
   \   00000088   0x6801             LDR      R1,[R0, #+0]
   \   0000008A   0x0849             LSRS     R1,R1,#+1
   \   0000008C   0x0049             LSLS     R1,R1,#+1
   \   0000008E   0x6001             STR      R1,[R0, #+0]
    682          
    683            /* Return function status */
    684            return HAL_OK;
   \                     ??HAL_TIMEx_OCN_Stop_IT_7: (+1)
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    685          }
    686          
    687          /**
    688            * @brief  Starts the TIM Output Compare signal generation in DMA mode
    689            *         on the complementary output.
    690            * @param  htim : TIM Output Compare handle
    691            * @param  Channel : TIM Channel to be enabled
    692            *          This parameter can be one of the following values:
    693            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    694            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    695            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    696            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    697            * @param  pData : The source Buffer address.
    698            * @param  Length : The length of data to be transferred from memory to TIM peripheral
    699            * @retval HAL status
    700            */

   \                                 In section .text, align 2, keep-with-next
    701          HAL_StatusTypeDef HAL_TIMEx_OCN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
    702          {
   \                     HAL_TIMEx_OCN_Start_DMA: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4611             MOV      R1,R2
    703            /* Check the parameters */
    704            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    705          
    706            if((htim->State == HAL_TIM_STATE_BUSY))
   \   00000008   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD101             BNE.N    ??HAL_TIMEx_OCN_Start_DMA_0
    707            {
    708               return HAL_BUSY;
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xBD32             POP      {R1,R4,R5,PC}
    709            }
    710            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIMEx_OCN_Start_DMA_0: (+1)
   \   00000014   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD108             BNE.N    ??HAL_TIMEx_OCN_Start_DMA_1
    711            {
    712              if(((uint32_t)pData == 0 ) && (Length > 0))
   \   0000001C   0x2900             CMP      R1,#+0
   \   0000001E   0xD103             BNE.N    ??HAL_TIMEx_OCN_Start_DMA_2
   \   00000020   0x0018             MOVS     R0,R3
   \   00000022   0xD001             BEQ.N    ??HAL_TIMEx_OCN_Start_DMA_2
    713              {
    714                return HAL_ERROR;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xBD32             POP      {R1,R4,R5,PC}
    715              }
    716              else
    717              {
    718                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIMEx_OCN_Start_DMA_2: (+1)
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xF884 0x0039      STRB     R0,[R4, #+57]
    719              }
    720            }
    721            switch (Channel)
   \                     ??HAL_TIMEx_OCN_Start_DMA_1: (+1)
   \   0000002E   0x0028             MOVS     R0,R5
   \   00000030   0xD006             BEQ.N    ??HAL_TIMEx_OCN_Start_DMA_3
   \   00000032   0x2804             CMP      R0,#+4
   \   00000034   0xD018             BEQ.N    ??HAL_TIMEx_OCN_Start_DMA_4
   \   00000036   0x2808             CMP      R0,#+8
   \   00000038   0xD02A             BEQ.N    ??HAL_TIMEx_OCN_Start_DMA_5
   \   0000003A   0x280C             CMP      R0,#+12
   \   0000003C   0xD03C             BEQ.N    ??HAL_TIMEx_OCN_Start_DMA_6
   \   0000003E   0xE04E             B.N      ??HAL_TIMEx_OCN_Start_DMA_7
    722            {
    723              case TIM_CHANNEL_1:
    724              {
    725                /* Set the DMA Period elapsed callback */
    726                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIMEx_OCN_Start_DMA_3: (+1)
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable4_2
   \   00000044   0x6A22             LDR      R2,[R4, #+32]
   \   00000046   0x6290             STR      R0,[R2, #+40]
    727          
    728                /* Set the DMA error callback */
    729                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \   0000004C   0x6A22             LDR      R2,[R4, #+32]
   \   0000004E   0x6310             STR      R0,[R2, #+48]
    730          
    731                /* Enable the DMA channel */
    732                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0xF100 0x0234      ADD      R2,R0,#+52
   \   00000056   0x6A20             LDR      R0,[R4, #+32]
   \   00000058   0x.... 0x....      BL       HAL_DMA_Start_IT
    733          
    734                /* Enable the TIM Output Compare DMA request */
    735                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x68C1             LDR      R1,[R0, #+12]
   \   00000060   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000064   0x60C1             STR      R1,[R0, #+12]
    736              }
    737              break;
   \   00000066   0xE03A             B.N      ??HAL_TIMEx_OCN_Start_DMA_7
    738          
    739              case TIM_CHANNEL_2:
    740              {
    741                /* Set the DMA Period elapsed callback */
    742                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIMEx_OCN_Start_DMA_4: (+1)
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable4_2
   \   0000006C   0x6A62             LDR      R2,[R4, #+36]
   \   0000006E   0x6290             STR      R0,[R2, #+40]
    743          
    744                /* Set the DMA error callback */
    745                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \   00000074   0x6A62             LDR      R2,[R4, #+36]
   \   00000076   0x6310             STR      R0,[R2, #+48]
    746          
    747                /* Enable the DMA channel */
    748                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0xF100 0x0238      ADD      R2,R0,#+56
   \   0000007E   0x6A60             LDR      R0,[R4, #+36]
   \   00000080   0x.... 0x....      BL       HAL_DMA_Start_IT
    749          
    750                /* Enable the TIM Output Compare DMA request */
    751                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x68C1             LDR      R1,[R0, #+12]
   \   00000088   0xF441 0x6180      ORR      R1,R1,#0x400
   \   0000008C   0x60C1             STR      R1,[R0, #+12]
    752              }
    753              break;
   \   0000008E   0xE026             B.N      ??HAL_TIMEx_OCN_Start_DMA_7
    754          
    755              case TIM_CHANNEL_3:
    756          {
    757                /* Set the DMA Period elapsed callback */
    758                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIMEx_OCN_Start_DMA_5: (+1)
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable4_2
   \   00000094   0x6AA2             LDR      R2,[R4, #+40]
   \   00000096   0x6290             STR      R0,[R2, #+40]
    759          
    760                /* Set the DMA error callback */
    761                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \   0000009C   0x6AA2             LDR      R2,[R4, #+40]
   \   0000009E   0x6310             STR      R0,[R2, #+48]
    762          
    763                /* Enable the DMA channel */
    764                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0xF100 0x023C      ADD      R2,R0,#+60
   \   000000A6   0x6AA0             LDR      R0,[R4, #+40]
   \   000000A8   0x.... 0x....      BL       HAL_DMA_Start_IT
    765          
    766                /* Enable the TIM Output Compare DMA request */
    767                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \   000000AC   0x6820             LDR      R0,[R4, #+0]
   \   000000AE   0x68C1             LDR      R1,[R0, #+12]
   \   000000B0   0xF441 0x6100      ORR      R1,R1,#0x800
   \   000000B4   0x60C1             STR      R1,[R0, #+12]
    768              }
    769              break;
   \   000000B6   0xE012             B.N      ??HAL_TIMEx_OCN_Start_DMA_7
    770          
    771              case TIM_CHANNEL_4:
    772              {
    773               /* Set the DMA Period elapsed callback */
    774                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIMEx_OCN_Start_DMA_6: (+1)
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable4_2
   \   000000BC   0x6AE2             LDR      R2,[R4, #+44]
   \   000000BE   0x6290             STR      R0,[R2, #+40]
    775          
    776                /* Set the DMA error callback */
    777                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \   000000C0   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \   000000C4   0x6AE2             LDR      R2,[R4, #+44]
   \   000000C6   0x6310             STR      R0,[R2, #+48]
    778          
    779                /* Enable the DMA channel */
    780                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
   \   000000C8   0x6820             LDR      R0,[R4, #+0]
   \   000000CA   0xF100 0x0240      ADD      R2,R0,#+64
   \   000000CE   0x6AE0             LDR      R0,[R4, #+44]
   \   000000D0   0x.... 0x....      BL       HAL_DMA_Start_IT
    781          
    782                /* Enable the TIM Output Compare DMA request */
    783                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \   000000D4   0x6820             LDR      R0,[R4, #+0]
   \   000000D6   0x68C1             LDR      R1,[R0, #+12]
   \   000000D8   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   000000DC   0x60C1             STR      R1,[R0, #+12]
    784              }
    785              break;
    786          
    787              default:
    788              break;
    789            }
    790          
    791            /* Enable the Capture compare channel N */
    792            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   \                     ??HAL_TIMEx_OCN_Start_DMA_7: (+1)
   \   000000DE   0x2204             MOVS     R2,#+4
   \   000000E0   0x4629             MOV      R1,R5
   \   000000E2   0x6820             LDR      R0,[R4, #+0]
   \   000000E4   0x.... 0x....      BL       TIM_CCxNChannelCmd
    793          
    794            /* Enable the Main Ouput */
    795            __HAL_TIM_MOE_ENABLE(htim);
   \   000000E8   0x6820             LDR      R0,[R4, #+0]
   \   000000EA   0x6C41             LDR      R1,[R0, #+68]
   \   000000EC   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000000F0   0x6441             STR      R1,[R0, #+68]
    796          
    797            /* Enable the Peripheral */
    798            __HAL_TIM_ENABLE(htim);
   \   000000F2   0x6820             LDR      R0,[R4, #+0]
   \   000000F4   0x6801             LDR      R1,[R0, #+0]
   \   000000F6   0xF041 0x0101      ORR      R1,R1,#0x1
   \   000000FA   0x6001             STR      R1,[R0, #+0]
    799          
    800            /* Return function status */
    801            return HAL_OK;
   \   000000FC   0x2000             MOVS     R0,#+0
   \   000000FE   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    802          }
    803          
    804          /**
    805            * @brief  Stops the TIM Output Compare signal generation in DMA mode
    806            *         on the complementary output.
    807            * @param  htim : TIM Output Compare handle
    808            * @param  Channel : TIM Channel to be disabled
    809            *          This parameter can be one of the following values:
    810            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    811            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    812            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    813            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    814            * @retval HAL status
    815            */

   \                                 In section .text, align 2, keep-with-next
    816          HAL_StatusTypeDef HAL_TIMEx_OCN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
    817          {
   \                     HAL_TIMEx_OCN_Stop_DMA: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    818            /* Check the parameters */
    819            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    820          
    821            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIMEx_OCN_Stop_DMA_0
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD00A             BEQ.N    ??HAL_TIMEx_OCN_Stop_DMA_1
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD00E             BEQ.N    ??HAL_TIMEx_OCN_Stop_DMA_2
   \   00000010   0x280C             CMP      R0,#+12
   \   00000012   0xD012             BEQ.N    ??HAL_TIMEx_OCN_Stop_DMA_3
   \   00000014   0xE016             B.N      ??HAL_TIMEx_OCN_Stop_DMA_4
    822            {
    823              case TIM_CHANNEL_1:
    824              {
    825                /* Disable the TIM Output Compare DMA request */
    826                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIMEx_OCN_Stop_DMA_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x68C2             LDR      R2,[R0, #+12]
   \   0000001A   0xF422 0x7200      BIC      R2,R2,#0x200
   \   0000001E   0x60C2             STR      R2,[R0, #+12]
    827              }
    828              break;
   \   00000020   0xE010             B.N      ??HAL_TIMEx_OCN_Stop_DMA_4
    829          
    830              case TIM_CHANNEL_2:
    831              {
    832                /* Disable the TIM Output Compare DMA request */
    833                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIMEx_OCN_Stop_DMA_1: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C2             LDR      R2,[R0, #+12]
   \   00000026   0xF422 0x6280      BIC      R2,R2,#0x400
   \   0000002A   0x60C2             STR      R2,[R0, #+12]
    834              }
    835              break;
   \   0000002C   0xE00A             B.N      ??HAL_TIMEx_OCN_Stop_DMA_4
    836          
    837              case TIM_CHANNEL_3:
    838              {
    839                /* Disable the TIM Output Compare DMA request */
    840                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIMEx_OCN_Stop_DMA_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68C2             LDR      R2,[R0, #+12]
   \   00000032   0xF422 0x6200      BIC      R2,R2,#0x800
   \   00000036   0x60C2             STR      R2,[R0, #+12]
    841              }
    842              break;
   \   00000038   0xE004             B.N      ??HAL_TIMEx_OCN_Stop_DMA_4
    843          
    844              case TIM_CHANNEL_4:
    845              {
    846                /* Disable the TIM Output Compare interrupt */
    847                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIMEx_OCN_Stop_DMA_3: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x68C2             LDR      R2,[R0, #+12]
   \   0000003E   0xF422 0x5280      BIC      R2,R2,#0x1000
   \   00000042   0x60C2             STR      R2,[R0, #+12]
    848              }
    849              break;
    850          
    851              default:
    852              break;
    853            }
    854          
    855            /* Disable the Capture compare channel N */
    856            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
   \                     ??HAL_TIMEx_OCN_Stop_DMA_4: (+1)
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       TIM_CCxNChannelCmd
    857          
    858            /* Disable the Main Ouput */
    859            __HAL_TIM_MOE_DISABLE(htim);
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000052   0x6A02             LDR      R2,[R0, #+32]
   \   00000054   0x420A             TST      R2,R1
   \   00000056   0xD108             BNE.N    ??HAL_TIMEx_OCN_Stop_DMA_5
   \   00000058   0x6A02             LDR      R2,[R0, #+32]
   \   0000005A   0xF240 0x4344      MOVW     R3,#+1092
   \   0000005E   0x421A             TST      R2,R3
   \   00000060   0xD103             BNE.N    ??HAL_TIMEx_OCN_Stop_DMA_5
   \   00000062   0x6C42             LDR      R2,[R0, #+68]
   \   00000064   0xF422 0x4200      BIC      R2,R2,#0x8000
   \   00000068   0x6442             STR      R2,[R0, #+68]
    860          
    861            /* Disable the Peripheral */
    862            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_OCN_Stop_DMA_5: (+1)
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x6A02             LDR      R2,[R0, #+32]
   \   0000006E   0x420A             TST      R2,R1
   \   00000070   0xD108             BNE.N    ??HAL_TIMEx_OCN_Stop_DMA_6
   \   00000072   0x6A01             LDR      R1,[R0, #+32]
   \   00000074   0xF240 0x4244      MOVW     R2,#+1092
   \   00000078   0x4211             TST      R1,R2
   \   0000007A   0xD103             BNE.N    ??HAL_TIMEx_OCN_Stop_DMA_6
   \   0000007C   0x6801             LDR      R1,[R0, #+0]
   \   0000007E   0x0849             LSRS     R1,R1,#+1
   \   00000080   0x0049             LSLS     R1,R1,#+1
   \   00000082   0x6001             STR      R1,[R0, #+0]
    863          
    864            /* Change the htim state */
    865            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIMEx_OCN_Stop_DMA_6: (+1)
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0xF884 0x0039      STRB     R0,[R4, #+57]
    866          
    867            /* Return function status */
    868            return HAL_OK;
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    869          }
    870          
    871          /**
    872            * @}
    873            */
    874          
    875          /** @defgroup TIMEx_Exported_Functions_Group3 Timer Complementary PWM functions
    876           *  @brief    Timer Complementary PWM functions
    877           *
    878          @verbatim
    879            ==============================================================================
    880                           ##### Timer Complementary PWM functions #####
    881            ==============================================================================
    882            [..]
    883              This section provides functions allowing to:
    884              (+) Start the Complementary PWM.
    885              (+) Stop the Complementary PWM.
    886              (+) Start the Complementary PWM and enable interrupts.
    887              (+) Stop the Complementary PWM and disable interrupts.
    888              (+) Start the Complementary PWM and enable DMA transfers.
    889              (+) Stop the Complementary PWM and disable DMA transfers.
    890              (+) Start the Complementary Input Capture measurement.
    891              (+) Stop the Complementary Input Capture.
    892              (+) Start the Complementary Input Capture and enable interrupts.
    893              (+) Stop the Complementary Input Capture and disable interrupts.
    894              (+) Start the Complementary Input Capture and enable DMA transfers.
    895              (+) Stop the Complementary Input Capture and disable DMA transfers.
    896              (+) Start the Complementary One Pulse generation.
    897              (+) Stop the Complementary One Pulse.
    898              (+) Start the Complementary One Pulse and enable interrupts.
    899              (+) Stop the Complementary One Pulse and disable interrupts.
    900          
    901          @endverbatim
    902            * @{
    903            */
    904          
    905          /**
    906            * @brief  Starts the PWM signal generation on the complementary output.
    907            * @param  htim : TIM handle
    908            * @param  Channel : TIM Channel to be enabled
    909            *          This parameter can be one of the following values:
    910            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    911            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    912            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    913            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    914            * @retval HAL status
    915            */

   \                                 In section .text, align 2, keep-with-next
    916          HAL_StatusTypeDef HAL_TIMEx_PWMN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
    917          {
   \                     HAL_TIMEx_PWMN_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    918            /* Check the parameters */
    919            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    920          
    921            /* Enable the complementary PWM output  */
    922            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   \   00000004   0x2204             MOVS     R2,#+4
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_CCxNChannelCmd
    923          
    924            /* Enable the Main Ouput */
    925            __HAL_TIM_MOE_ENABLE(htim);
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6C41             LDR      R1,[R0, #+68]
   \   00000010   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000014   0x6441             STR      R1,[R0, #+68]
    926          
    927            /* Enable the Peripheral */
    928            __HAL_TIM_ENABLE(htim);
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000001E   0x6001             STR      R1,[R0, #+0]
    929          
    930            /* Return function status */
    931            return HAL_OK;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    932          }
    933          
    934          /**
    935            * @brief  Stops the PWM signal generation on the complementary output.
    936            * @param  htim : TIM handle
    937            * @param  Channel : TIM Channel to be disabled
    938            *          This parameter can be one of the following values:
    939            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    940            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    941            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    942            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    943            * @retval HAL status
    944            */

   \                                 In section .text, align 2, keep-with-next
    945          HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
    946          {
   \                     HAL_TIMEx_PWMN_Stop: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    947            /* Check the parameters */
    948            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    949          
    950            /* Disable the complementary PWM output  */
    951            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_CCxNChannelCmd
    952          
    953            /* Disable the Main Ouput */
    954            __HAL_TIM_MOE_DISABLE(htim);
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000012   0x6A02             LDR      R2,[R0, #+32]
   \   00000014   0x420A             TST      R2,R1
   \   00000016   0xD108             BNE.N    ??HAL_TIMEx_PWMN_Stop_0
   \   00000018   0x6A02             LDR      R2,[R0, #+32]
   \   0000001A   0xF240 0x4344      MOVW     R3,#+1092
   \   0000001E   0x421A             TST      R2,R3
   \   00000020   0xD103             BNE.N    ??HAL_TIMEx_PWMN_Stop_0
   \   00000022   0x6C42             LDR      R2,[R0, #+68]
   \   00000024   0xF422 0x4200      BIC      R2,R2,#0x8000
   \   00000028   0x6442             STR      R2,[R0, #+68]
    955          
    956            /* Disable the Peripheral */
    957            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_PWMN_Stop_0: (+1)
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x6A02             LDR      R2,[R0, #+32]
   \   0000002E   0x420A             TST      R2,R1
   \   00000030   0xD108             BNE.N    ??HAL_TIMEx_PWMN_Stop_1
   \   00000032   0x6A01             LDR      R1,[R0, #+32]
   \   00000034   0xF240 0x4244      MOVW     R2,#+1092
   \   00000038   0x4211             TST      R1,R2
   \   0000003A   0xD103             BNE.N    ??HAL_TIMEx_PWMN_Stop_1
   \   0000003C   0x6801             LDR      R1,[R0, #+0]
   \   0000003E   0x0849             LSRS     R1,R1,#+1
   \   00000040   0x0049             LSLS     R1,R1,#+1
   \   00000042   0x6001             STR      R1,[R0, #+0]
    958          
    959            /* Return function status */
    960            return HAL_OK;
   \                     ??HAL_TIMEx_PWMN_Stop_1: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    961          }
    962          
    963          /**
    964            * @brief  Starts the PWM signal generation in interrupt mode on the
    965            *         complementary output.
    966            * @param  htim : TIM handle
    967            * @param  Channel : TIM Channel to be disabled
    968            *          This parameter can be one of the following values:
    969            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    970            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    971            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    972            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    973            * @retval HAL status
    974            */

   \                                 In section .text, align 2, keep-with-next
    975          HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    976          {
   \                     HAL_TIMEx_PWMN_Start_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    977            /* Check the parameters */
    978            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    979          
    980            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIMEx_PWMN_Start_IT_0
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD00A             BEQ.N    ??HAL_TIMEx_PWMN_Start_IT_1
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD00E             BEQ.N    ??HAL_TIMEx_PWMN_Start_IT_2
   \   00000010   0x280C             CMP      R0,#+12
   \   00000012   0xD012             BEQ.N    ??HAL_TIMEx_PWMN_Start_IT_3
   \   00000014   0xE016             B.N      ??HAL_TIMEx_PWMN_Start_IT_4
    981            {
    982              case TIM_CHANNEL_1:
    983              {
    984                /* Enable the TIM Capture/Compare 1 interrupt */
    985                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIMEx_PWMN_Start_IT_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x68C2             LDR      R2,[R0, #+12]
   \   0000001A   0xF042 0x0202      ORR      R2,R2,#0x2
   \   0000001E   0x60C2             STR      R2,[R0, #+12]
    986              }
    987              break;
   \   00000020   0xE010             B.N      ??HAL_TIMEx_PWMN_Start_IT_4
    988          
    989              case TIM_CHANNEL_2:
    990              {
    991                /* Enable the TIM Capture/Compare 2 interrupt */
    992                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIMEx_PWMN_Start_IT_1: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C2             LDR      R2,[R0, #+12]
   \   00000026   0xF042 0x0204      ORR      R2,R2,#0x4
   \   0000002A   0x60C2             STR      R2,[R0, #+12]
    993              }
    994              break;
   \   0000002C   0xE00A             B.N      ??HAL_TIMEx_PWMN_Start_IT_4
    995          
    996              case TIM_CHANNEL_3:
    997              {
    998                /* Enable the TIM Capture/Compare 3 interrupt */
    999                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIMEx_PWMN_Start_IT_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68C2             LDR      R2,[R0, #+12]
   \   00000032   0xF042 0x0208      ORR      R2,R2,#0x8
   \   00000036   0x60C2             STR      R2,[R0, #+12]
   1000              }
   1001              break;
   \   00000038   0xE004             B.N      ??HAL_TIMEx_PWMN_Start_IT_4
   1002          
   1003              case TIM_CHANNEL_4:
   1004              {
   1005                /* Enable the TIM Capture/Compare 4 interrupt */
   1006                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIMEx_PWMN_Start_IT_3: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x68C2             LDR      R2,[R0, #+12]
   \   0000003E   0xF042 0x0210      ORR      R2,R2,#0x10
   \   00000042   0x60C2             STR      R2,[R0, #+12]
   1007              }
   1008              break;
   1009          
   1010              default:
   1011              break;
   1012            }
   1013          
   1014            /* Enable the TIM Break interrupt */
   1015            __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
   \                     ??HAL_TIMEx_PWMN_Start_IT_4: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x68C2             LDR      R2,[R0, #+12]
   \   00000048   0xF042 0x0280      ORR      R2,R2,#0x80
   \   0000004C   0x60C2             STR      R2,[R0, #+12]
   1016          
   1017            /* Enable the complementary PWM output  */
   1018            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   \   0000004E   0x2204             MOVS     R2,#+4
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x.... 0x....      BL       TIM_CCxNChannelCmd
   1019          
   1020            /* Enable the Main Ouput */
   1021            __HAL_TIM_MOE_ENABLE(htim);
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x6C41             LDR      R1,[R0, #+68]
   \   0000005A   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000005E   0x6441             STR      R1,[R0, #+68]
   1022          
   1023            /* Enable the Peripheral */
   1024            __HAL_TIM_ENABLE(htim);
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x6801             LDR      R1,[R0, #+0]
   \   00000064   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000068   0x6001             STR      R1,[R0, #+0]
   1025          
   1026            /* Return function status */
   1027            return HAL_OK;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xBD10             POP      {R4,PC}          ;; return
   1028          }
   1029          
   1030          /**
   1031            * @brief  Stops the PWM signal generation in interrupt mode on the
   1032            *         complementary output.
   1033            * @param  htim : TIM handle
   1034            * @param  Channel : TIM Channel to be disabled
   1035            *          This parameter can be one of the following values:
   1036            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1037            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1038            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1039            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1040            * @retval HAL status
   1041            */

   \                                 In section .text, align 2, keep-with-next
   1042          HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
   1043          {
   \                     HAL_TIMEx_PWMN_Stop_IT: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1044            uint32_t tmpccer = 0;
   1045          
   1046            /* Check the parameters */
   1047            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
   1048          
   1049            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIMEx_PWMN_Stop_IT_0
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD00A             BEQ.N    ??HAL_TIMEx_PWMN_Stop_IT_1
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD00E             BEQ.N    ??HAL_TIMEx_PWMN_Stop_IT_2
   \   00000010   0x280C             CMP      R0,#+12
   \   00000012   0xD012             BEQ.N    ??HAL_TIMEx_PWMN_Stop_IT_3
   \   00000014   0xE016             B.N      ??HAL_TIMEx_PWMN_Stop_IT_4
   1050            {
   1051              case TIM_CHANNEL_1:
   1052              {
   1053                /* Disable the TIM Capture/Compare 1 interrupt */
   1054                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x68C2             LDR      R2,[R0, #+12]
   \   0000001A   0xF022 0x0202      BIC      R2,R2,#0x2
   \   0000001E   0x60C2             STR      R2,[R0, #+12]
   1055              }
   1056              break;
   \   00000020   0xE010             B.N      ??HAL_TIMEx_PWMN_Stop_IT_4
   1057          
   1058              case TIM_CHANNEL_2:
   1059              {
   1060                /* Disable the TIM Capture/Compare 2 interrupt */
   1061                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_1: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C2             LDR      R2,[R0, #+12]
   \   00000026   0xF022 0x0204      BIC      R2,R2,#0x4
   \   0000002A   0x60C2             STR      R2,[R0, #+12]
   1062              }
   1063              break;
   \   0000002C   0xE00A             B.N      ??HAL_TIMEx_PWMN_Stop_IT_4
   1064          
   1065              case TIM_CHANNEL_3:
   1066              {
   1067                /* Disable the TIM Capture/Compare 3 interrupt */
   1068                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68C2             LDR      R2,[R0, #+12]
   \   00000032   0xF022 0x0208      BIC      R2,R2,#0x8
   \   00000036   0x60C2             STR      R2,[R0, #+12]
   1069              }
   1070              break;
   \   00000038   0xE004             B.N      ??HAL_TIMEx_PWMN_Stop_IT_4
   1071          
   1072              case TIM_CHANNEL_4:
   1073              {
   1074                /* Disable the TIM Capture/Compare 3 interrupt */
   1075                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_3: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x68C2             LDR      R2,[R0, #+12]
   \   0000003E   0xF022 0x0210      BIC      R2,R2,#0x10
   \   00000042   0x60C2             STR      R2,[R0, #+12]
   1076              }
   1077              break;
   1078          
   1079              default:
   1080              break;
   1081            }
   1082          
   1083            /* Disable the complementary PWM output  */
   1084            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_4: (+1)
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       TIM_CCxNChannelCmd
   1085          
   1086            /* Disable the TIM Break interrupt (only if no more channel is active) */
   1087            tmpccer = htim->Instance->CCER;
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6A02             LDR      R2,[R0, #+32]
   1088            if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == RESET)
   \   00000050   0xF240 0x4144      MOVW     R1,#+1092
   \   00000054   0x420A             TST      R2,R1
   \   00000056   0xD103             BNE.N    ??HAL_TIMEx_PWMN_Stop_IT_5
   1089            {
   1090              __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
   \   00000058   0x68C2             LDR      R2,[R0, #+12]
   \   0000005A   0xF022 0x0280      BIC      R2,R2,#0x80
   \   0000005E   0x60C2             STR      R2,[R0, #+12]
   1091            }
   1092          
   1093            /* Disable the Main Ouput */
   1094            __HAL_TIM_MOE_DISABLE(htim);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_5: (+1)
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0xF241 0x1211      MOVW     R2,#+4369
   \   00000066   0x6A03             LDR      R3,[R0, #+32]
   \   00000068   0x4213             TST      R3,R2
   \   0000006A   0xD106             BNE.N    ??HAL_TIMEx_PWMN_Stop_IT_6
   \   0000006C   0x6A03             LDR      R3,[R0, #+32]
   \   0000006E   0x420B             TST      R3,R1
   \   00000070   0xD103             BNE.N    ??HAL_TIMEx_PWMN_Stop_IT_6
   \   00000072   0x6C43             LDR      R3,[R0, #+68]
   \   00000074   0xF423 0x4300      BIC      R3,R3,#0x8000
   \   00000078   0x6443             STR      R3,[R0, #+68]
   1095          
   1096            /* Disable the Peripheral */
   1097            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_6: (+1)
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x6A03             LDR      R3,[R0, #+32]
   \   0000007E   0x4213             TST      R3,R2
   \   00000080   0xD106             BNE.N    ??HAL_TIMEx_PWMN_Stop_IT_7
   \   00000082   0x6A02             LDR      R2,[R0, #+32]
   \   00000084   0x420A             TST      R2,R1
   \   00000086   0xD103             BNE.N    ??HAL_TIMEx_PWMN_Stop_IT_7
   \   00000088   0x6801             LDR      R1,[R0, #+0]
   \   0000008A   0x0849             LSRS     R1,R1,#+1
   \   0000008C   0x0049             LSLS     R1,R1,#+1
   \   0000008E   0x6001             STR      R1,[R0, #+0]
   1098          
   1099            /* Return function status */
   1100            return HAL_OK;
   \                     ??HAL_TIMEx_PWMN_Stop_IT_7: (+1)
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   1101          }
   1102          
   1103          /**
   1104            * @brief  Starts the TIM PWM signal generation in DMA mode on the
   1105            *         complementary output
   1106            * @param  htim : TIM handle
   1107            * @param  Channel : TIM Channel to be enabled
   1108            *          This parameter can be one of the following values:
   1109            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1110            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1111            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1112            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1113            * @param  pData : The source Buffer address.
   1114            * @param  Length : The length of data to be transferred from memory to TIM peripheral
   1115            * @retval HAL status
   1116            */

   \                                 In section .text, align 2, keep-with-next
   1117          HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1118          {
   \                     HAL_TIMEx_PWMN_Start_DMA: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4611             MOV      R1,R2
   1119            /* Check the parameters */
   1120            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
   1121          
   1122            if((htim->State == HAL_TIM_STATE_BUSY))
   \   00000008   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD101             BNE.N    ??HAL_TIMEx_PWMN_Start_DMA_0
   1123            {
   1124               return HAL_BUSY;
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xBD32             POP      {R1,R4,R5,PC}
   1125            }
   1126            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIMEx_PWMN_Start_DMA_0: (+1)
   \   00000014   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD108             BNE.N    ??HAL_TIMEx_PWMN_Start_DMA_1
   1127            {
   1128              if(((uint32_t)pData == 0 ) && (Length > 0))
   \   0000001C   0x2900             CMP      R1,#+0
   \   0000001E   0xD103             BNE.N    ??HAL_TIMEx_PWMN_Start_DMA_2
   \   00000020   0x0018             MOVS     R0,R3
   \   00000022   0xD001             BEQ.N    ??HAL_TIMEx_PWMN_Start_DMA_2
   1129              {
   1130                return HAL_ERROR;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xBD32             POP      {R1,R4,R5,PC}
   1131              }
   1132              else
   1133              {
   1134                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIMEx_PWMN_Start_DMA_2: (+1)
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xF884 0x0039      STRB     R0,[R4, #+57]
   1135              }
   1136            }
   1137            switch (Channel)
   \                     ??HAL_TIMEx_PWMN_Start_DMA_1: (+1)
   \   0000002E   0x0028             MOVS     R0,R5
   \   00000030   0xD006             BEQ.N    ??HAL_TIMEx_PWMN_Start_DMA_3
   \   00000032   0x2804             CMP      R0,#+4
   \   00000034   0xD016             BEQ.N    ??HAL_TIMEx_PWMN_Start_DMA_4
   \   00000036   0x2808             CMP      R0,#+8
   \   00000038   0xD026             BEQ.N    ??HAL_TIMEx_PWMN_Start_DMA_5
   \   0000003A   0x280C             CMP      R0,#+12
   \   0000003C   0xD036             BEQ.N    ??HAL_TIMEx_PWMN_Start_DMA_6
   \   0000003E   0xE046             B.N      ??HAL_TIMEx_PWMN_Start_DMA_7
   1138            {
   1139              case TIM_CHANNEL_1:
   1140              {
   1141                /* Set the DMA Period elapsed callback */
   1142                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIMEx_PWMN_Start_DMA_3: (+1)
   \   00000040   0x....             LDR.N    R0,??DataTable4_2
   \   00000042   0x6A22             LDR      R2,[R4, #+32]
   \   00000044   0x6290             STR      R0,[R2, #+40]
   1143          
   1144                /* Set the DMA error callback */
   1145                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   00000046   0x....             LDR.N    R0,??DataTable4_1
   \   00000048   0x6A22             LDR      R2,[R4, #+32]
   \   0000004A   0x6310             STR      R0,[R2, #+48]
   1146          
   1147                /* Enable the DMA channel */
   1148                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0xF100 0x0234      ADD      R2,R0,#+52
   \   00000052   0x6A20             LDR      R0,[R4, #+32]
   \   00000054   0x.... 0x....      BL       HAL_DMA_Start_IT
   1149          
   1150                /* Enable the TIM Capture/Compare 1 DMA request */
   1151                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x68C1             LDR      R1,[R0, #+12]
   \   0000005C   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000060   0x60C1             STR      R1,[R0, #+12]
   1152              }
   1153              break;
   \   00000062   0xE034             B.N      ??HAL_TIMEx_PWMN_Start_DMA_7
   1154          
   1155              case TIM_CHANNEL_2:
   1156              {
   1157                /* Set the DMA Period elapsed callback */
   1158                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIMEx_PWMN_Start_DMA_4: (+1)
   \   00000064   0x....             LDR.N    R0,??DataTable4_2
   \   00000066   0x6A62             LDR      R2,[R4, #+36]
   \   00000068   0x6290             STR      R0,[R2, #+40]
   1159          
   1160                /* Set the DMA error callback */
   1161                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \   0000006A   0x....             LDR.N    R0,??DataTable4_1
   \   0000006C   0x6A62             LDR      R2,[R4, #+36]
   \   0000006E   0x6310             STR      R0,[R2, #+48]
   1162          
   1163                /* Enable the DMA channel */
   1164                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0xF100 0x0238      ADD      R2,R0,#+56
   \   00000076   0x6A60             LDR      R0,[R4, #+36]
   \   00000078   0x.... 0x....      BL       HAL_DMA_Start_IT
   1165          
   1166                /* Enable the TIM Capture/Compare 2 DMA request */
   1167                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0x68C1             LDR      R1,[R0, #+12]
   \   00000080   0xF441 0x6180      ORR      R1,R1,#0x400
   \   00000084   0x60C1             STR      R1,[R0, #+12]
   1168              }
   1169              break;
   \   00000086   0xE022             B.N      ??HAL_TIMEx_PWMN_Start_DMA_7
   1170          
   1171              case TIM_CHANNEL_3:
   1172              {
   1173                /* Set the DMA Period elapsed callback */
   1174                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIMEx_PWMN_Start_DMA_5: (+1)
   \   00000088   0x....             LDR.N    R0,??DataTable4_2
   \   0000008A   0x6AA2             LDR      R2,[R4, #+40]
   \   0000008C   0x6290             STR      R0,[R2, #+40]
   1175          
   1176                /* Set the DMA error callback */
   1177                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \   0000008E   0x....             LDR.N    R0,??DataTable4_1
   \   00000090   0x6AA2             LDR      R2,[R4, #+40]
   \   00000092   0x6310             STR      R0,[R2, #+48]
   1178          
   1179                /* Enable the DMA channel */
   1180                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0xF100 0x023C      ADD      R2,R0,#+60
   \   0000009A   0x6AA0             LDR      R0,[R4, #+40]
   \   0000009C   0x.... 0x....      BL       HAL_DMA_Start_IT
   1181          
   1182                /* Enable the TIM Capture/Compare 3 DMA request */
   1183                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0x68C1             LDR      R1,[R0, #+12]
   \   000000A4   0xF441 0x6100      ORR      R1,R1,#0x800
   \   000000A8   0x60C1             STR      R1,[R0, #+12]
   1184              }
   1185              break;
   \   000000AA   0xE010             B.N      ??HAL_TIMEx_PWMN_Start_DMA_7
   1186          
   1187              case TIM_CHANNEL_4:
   1188              {
   1189               /* Set the DMA Period elapsed callback */
   1190                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIMEx_PWMN_Start_DMA_6: (+1)
   \   000000AC   0x....             LDR.N    R0,??DataTable4_2
   \   000000AE   0x6AE2             LDR      R2,[R4, #+44]
   \   000000B0   0x6290             STR      R0,[R2, #+40]
   1191          
   1192                /* Set the DMA error callback */
   1193                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \   000000B2   0x....             LDR.N    R0,??DataTable4_1
   \   000000B4   0x6AE2             LDR      R2,[R4, #+44]
   \   000000B6   0x6310             STR      R0,[R2, #+48]
   1194          
   1195                /* Enable the DMA channel */
   1196                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
   \   000000B8   0x6820             LDR      R0,[R4, #+0]
   \   000000BA   0xF100 0x0240      ADD      R2,R0,#+64
   \   000000BE   0x6AE0             LDR      R0,[R4, #+44]
   \   000000C0   0x.... 0x....      BL       HAL_DMA_Start_IT
   1197          
   1198                /* Enable the TIM Capture/Compare 4 DMA request */
   1199                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \   000000C4   0x6820             LDR      R0,[R4, #+0]
   \   000000C6   0x68C1             LDR      R1,[R0, #+12]
   \   000000C8   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   000000CC   0x60C1             STR      R1,[R0, #+12]
   1200              }
   1201              break;
   1202          
   1203              default:
   1204              break;
   1205            }
   1206          
   1207            /* Enable the complementary PWM output  */
   1208               TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   \                     ??HAL_TIMEx_PWMN_Start_DMA_7: (+1)
   \   000000CE   0x2204             MOVS     R2,#+4
   \   000000D0   0x4629             MOV      R1,R5
   \   000000D2   0x6820             LDR      R0,[R4, #+0]
   \   000000D4   0x.... 0x....      BL       TIM_CCxNChannelCmd
   1209          
   1210            /* Enable the Main Ouput */
   1211              __HAL_TIM_MOE_ENABLE(htim);
   \   000000D8   0x6820             LDR      R0,[R4, #+0]
   \   000000DA   0x6C41             LDR      R1,[R0, #+68]
   \   000000DC   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000000E0   0x6441             STR      R1,[R0, #+68]
   1212          
   1213            /* Enable the Peripheral */
   1214            __HAL_TIM_ENABLE(htim);
   \   000000E2   0x6820             LDR      R0,[R4, #+0]
   \   000000E4   0x6801             LDR      R1,[R0, #+0]
   \   000000E6   0xF041 0x0101      ORR      R1,R1,#0x1
   \   000000EA   0x6001             STR      R1,[R0, #+0]
   1215          
   1216            /* Return function status */
   1217            return HAL_OK;
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1218          }
   1219          
   1220          /**
   1221            * @brief  Stops the TIM PWM signal generation in DMA mode on the complementary
   1222            *         output
   1223            * @param  htim : TIM handle
   1224            * @param  Channel : TIM Channel to be disabled
   1225            *          This parameter can be one of the following values:
   1226            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1227            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1228            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1229            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1230            * @retval HAL status
   1231            */

   \                                 In section .text, align 2, keep-with-next
   1232          HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1233          {
   \                     HAL_TIMEx_PWMN_Stop_DMA: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1234            /* Check the parameters */
   1235            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
   1236          
   1237            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIMEx_PWMN_Stop_DMA_0
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD00A             BEQ.N    ??HAL_TIMEx_PWMN_Stop_DMA_1
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD00E             BEQ.N    ??HAL_TIMEx_PWMN_Stop_DMA_2
   \   00000010   0x280C             CMP      R0,#+12
   \   00000012   0xD012             BEQ.N    ??HAL_TIMEx_PWMN_Stop_DMA_3
   \   00000014   0xE016             B.N      ??HAL_TIMEx_PWMN_Stop_DMA_4
   1238            {
   1239              case TIM_CHANNEL_1:
   1240              {
   1241                /* Disable the TIM Capture/Compare 1 DMA request */
   1242                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x68C2             LDR      R2,[R0, #+12]
   \   0000001A   0xF422 0x7200      BIC      R2,R2,#0x200
   \   0000001E   0x60C2             STR      R2,[R0, #+12]
   1243              }
   1244              break;
   \   00000020   0xE010             B.N      ??HAL_TIMEx_PWMN_Stop_DMA_4
   1245          
   1246              case TIM_CHANNEL_2:
   1247              {
   1248                /* Disable the TIM Capture/Compare 2 DMA request */
   1249                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_1: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C2             LDR      R2,[R0, #+12]
   \   00000026   0xF422 0x6280      BIC      R2,R2,#0x400
   \   0000002A   0x60C2             STR      R2,[R0, #+12]
   1250              }
   1251              break;
   \   0000002C   0xE00A             B.N      ??HAL_TIMEx_PWMN_Stop_DMA_4
   1252          
   1253              case TIM_CHANNEL_3:
   1254              {
   1255                /* Disable the TIM Capture/Compare 3 DMA request */
   1256                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68C2             LDR      R2,[R0, #+12]
   \   00000032   0xF422 0x6200      BIC      R2,R2,#0x800
   \   00000036   0x60C2             STR      R2,[R0, #+12]
   1257              }
   1258              break;
   \   00000038   0xE004             B.N      ??HAL_TIMEx_PWMN_Stop_DMA_4
   1259          
   1260              case TIM_CHANNEL_4:
   1261              {
   1262                /* Disable the TIM Capture/Compare 4 DMA request */
   1263                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_3: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x68C2             LDR      R2,[R0, #+12]
   \   0000003E   0xF422 0x5280      BIC      R2,R2,#0x1000
   \   00000042   0x60C2             STR      R2,[R0, #+12]
   1264              }
   1265              break;
   1266          
   1267              default:
   1268              break;
   1269            }
   1270          
   1271            /* Disable the complementary PWM output */
   1272              TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_4: (+1)
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       TIM_CCxNChannelCmd
   1273          
   1274            /* Disable the Main Ouput */
   1275              __HAL_TIM_MOE_DISABLE(htim);
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000052   0x6A02             LDR      R2,[R0, #+32]
   \   00000054   0x420A             TST      R2,R1
   \   00000056   0xD108             BNE.N    ??HAL_TIMEx_PWMN_Stop_DMA_5
   \   00000058   0x6A02             LDR      R2,[R0, #+32]
   \   0000005A   0xF240 0x4344      MOVW     R3,#+1092
   \   0000005E   0x421A             TST      R2,R3
   \   00000060   0xD103             BNE.N    ??HAL_TIMEx_PWMN_Stop_DMA_5
   \   00000062   0x6C42             LDR      R2,[R0, #+68]
   \   00000064   0xF422 0x4200      BIC      R2,R2,#0x8000
   \   00000068   0x6442             STR      R2,[R0, #+68]
   1276          
   1277            /* Disable the Peripheral */
   1278            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_5: (+1)
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x6A02             LDR      R2,[R0, #+32]
   \   0000006E   0x420A             TST      R2,R1
   \   00000070   0xD108             BNE.N    ??HAL_TIMEx_PWMN_Stop_DMA_6
   \   00000072   0x6A01             LDR      R1,[R0, #+32]
   \   00000074   0xF240 0x4244      MOVW     R2,#+1092
   \   00000078   0x4211             TST      R1,R2
   \   0000007A   0xD103             BNE.N    ??HAL_TIMEx_PWMN_Stop_DMA_6
   \   0000007C   0x6801             LDR      R1,[R0, #+0]
   \   0000007E   0x0849             LSRS     R1,R1,#+1
   \   00000080   0x0049             LSLS     R1,R1,#+1
   \   00000082   0x6001             STR      R1,[R0, #+0]
   1279          
   1280            /* Change the htim state */
   1281            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_6: (+1)
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0xF884 0x0039      STRB     R0,[R4, #+57]
   1282          
   1283            /* Return function status */
   1284            return HAL_OK;
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   1285          }
   1286          
   1287          /**
   1288            * @}
   1289            */
   1290          
   1291          /** @defgroup TIMEx_Exported_Functions_Group4 Timer Complementary One Pulse functions
   1292           *  @brief    Timer Complementary One Pulse functions
   1293           *
   1294          @verbatim
   1295            ==============================================================================
   1296                          ##### Timer Complementary One Pulse functions #####
   1297            ==============================================================================
   1298            [..]
   1299              This section provides functions allowing to:
   1300              (+) Start the Complementary One Pulse generation.
   1301              (+) Stop the Complementary One Pulse.
   1302              (+) Start the Complementary One Pulse and enable interrupts.
   1303              (+) Stop the Complementary One Pulse and disable interrupts.
   1304          
   1305          @endverbatim
   1306            * @{
   1307            */
   1308          
   1309          /**
   1310            * @brief  Starts the TIM One Pulse signal generation on the complemetary
   1311            *         output.
   1312            * @param  htim : TIM One Pulse handle
   1313            * @param  OutputChannel : TIM Channel to be enabled
   1314            *          This parameter can be one of the following values:
   1315            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1316            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1317            * @retval HAL status
   1318            */

   \                                 In section .text, align 2, keep-with-next
   1319          HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   1320            {
   \                     HAL_TIMEx_OnePulseN_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1321            /* Check the parameters */
   1322            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
   1323          
   1324            /* Enable the complementary One Pulse output */
   1325            TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE);
   \   00000004   0x2204             MOVS     R2,#+4
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_CCxNChannelCmd
   1326          
   1327            /* Enable the Main Ouput */
   1328            __HAL_TIM_MOE_ENABLE(htim);
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6C41             LDR      R1,[R0, #+68]
   \   00000010   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000014   0x6441             STR      R1,[R0, #+68]
   1329          
   1330            /* Return function status */
   1331            return HAL_OK;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
   1332          }
   1333          
   1334          /**
   1335            * @brief  Stops the TIM One Pulse signal generation on the complementary
   1336            *         output.
   1337            * @param  htim : TIM One Pulse handle
   1338            * @param  OutputChannel : TIM Channel to be disabled
   1339            *          This parameter can be one of the following values:
   1340            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1341            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1342            * @retval HAL status
   1343            */

   \                                 In section .text, align 2, keep-with-next
   1344          HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   1345          {
   \                     HAL_TIMEx_OnePulseN_Stop: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1346          
   1347            /* Check the parameters */
   1348            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
   1349          
   1350            /* Disable the complementary One Pulse output */
   1351            TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_CCxNChannelCmd
   1352          
   1353            /* Disable the Main Ouput */
   1354            __HAL_TIM_MOE_DISABLE(htim);
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000012   0x6A02             LDR      R2,[R0, #+32]
   \   00000014   0x420A             TST      R2,R1
   \   00000016   0xD108             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_0
   \   00000018   0x6A02             LDR      R2,[R0, #+32]
   \   0000001A   0xF240 0x4344      MOVW     R3,#+1092
   \   0000001E   0x421A             TST      R2,R3
   \   00000020   0xD103             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_0
   \   00000022   0x6C42             LDR      R2,[R0, #+68]
   \   00000024   0xF422 0x4200      BIC      R2,R2,#0x8000
   \   00000028   0x6442             STR      R2,[R0, #+68]
   1355          
   1356            /* Disable the Peripheral */
   1357            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_OnePulseN_Stop_0: (+1)
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x6A02             LDR      R2,[R0, #+32]
   \   0000002E   0x420A             TST      R2,R1
   \   00000030   0xD108             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_1
   \   00000032   0x6A01             LDR      R1,[R0, #+32]
   \   00000034   0xF240 0x4244      MOVW     R2,#+1092
   \   00000038   0x4211             TST      R1,R2
   \   0000003A   0xD103             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_1
   \   0000003C   0x6801             LDR      R1,[R0, #+0]
   \   0000003E   0x0849             LSRS     R1,R1,#+1
   \   00000040   0x0049             LSLS     R1,R1,#+1
   \   00000042   0x6001             STR      R1,[R0, #+0]
   1358          
   1359            /* Return function status */
   1360            return HAL_OK;
   \                     ??HAL_TIMEx_OnePulseN_Stop_1: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   1361          }
   1362          
   1363          /**
   1364            * @brief  Starts the TIM One Pulse signal generation in interrupt mode on the
   1365            *         complementary channel.
   1366            * @param  htim : TIM One Pulse handle
   1367            * @param  OutputChannel : TIM Channel to be enabled
   1368            *          This parameter can be one of the following values:
   1369            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1370            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1371            * @retval HAL status
   1372            */

   \                                 In section .text, align 2, keep-with-next
   1373          HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   1374          {
   \                     HAL_TIMEx_OnePulseN_Start_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1375            /* Check the parameters */
   1376            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
   1377          
   1378            /* Enable the TIM Capture/Compare 1 interrupt */
   1379            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x68C2             LDR      R2,[R0, #+12]
   \   00000008   0xF042 0x0202      ORR      R2,R2,#0x2
   \   0000000C   0x60C2             STR      R2,[R0, #+12]
   1380          
   1381            /* Enable the TIM Capture/Compare 2 interrupt */
   1382            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x68C2             LDR      R2,[R0, #+12]
   \   00000012   0xF042 0x0204      ORR      R2,R2,#0x4
   \   00000016   0x60C2             STR      R2,[R0, #+12]
   1383          
   1384            /* Enable the complementary One Pulse output */
   1385            TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE);
   \   00000018   0x2204             MOVS     R2,#+4
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x.... 0x....      BL       TIM_CCxNChannelCmd
   1386          
   1387            /* Enable the Main Ouput */
   1388            __HAL_TIM_MOE_ENABLE(htim);
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x6C41             LDR      R1,[R0, #+68]
   \   00000024   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000028   0x6441             STR      R1,[R0, #+68]
   1389          
   1390            /* Return function status */
   1391            return HAL_OK;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
   1392            }
   1393          
   1394          /**
   1395            * @brief  Stops the TIM One Pulse signal generation in interrupt mode on the
   1396            *         complementary channel.
   1397            * @param  htim : TIM One Pulse handle
   1398            * @param  OutputChannel : TIM Channel to be disabled
   1399            *          This parameter can be one of the following values:
   1400            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1401            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1402            * @retval HAL status
   1403            */

   \                                 In section .text, align 2, keep-with-next
   1404          HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   1405          {
   \                     HAL_TIMEx_OnePulseN_Stop_IT: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1406            /* Check the parameters */
   1407            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
   1408          
   1409            /* Disable the TIM Capture/Compare 1 interrupt */
   1410            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x68C2             LDR      R2,[R0, #+12]
   \   00000008   0xF022 0x0202      BIC      R2,R2,#0x2
   \   0000000C   0x60C2             STR      R2,[R0, #+12]
   1411          
   1412            /* Disable the TIM Capture/Compare 2 interrupt */
   1413            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x68C2             LDR      R2,[R0, #+12]
   \   00000012   0xF022 0x0204      BIC      R2,R2,#0x4
   \   00000016   0x60C2             STR      R2,[R0, #+12]
   1414          
   1415            /* Disable the complementary One Pulse output */
   1416            TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
   \   00000018   0x2200             MOVS     R2,#+0
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x.... 0x....      BL       TIM_CCxNChannelCmd
   1417          
   1418            /* Disable the Main Ouput */
   1419            __HAL_TIM_MOE_DISABLE(htim);
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0xF241 0x1111      MOVW     R1,#+4369
   \   00000026   0x6A02             LDR      R2,[R0, #+32]
   \   00000028   0x420A             TST      R2,R1
   \   0000002A   0xD108             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_IT_0
   \   0000002C   0x6A02             LDR      R2,[R0, #+32]
   \   0000002E   0xF240 0x4344      MOVW     R3,#+1092
   \   00000032   0x421A             TST      R2,R3
   \   00000034   0xD103             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_IT_0
   \   00000036   0x6C42             LDR      R2,[R0, #+68]
   \   00000038   0xF422 0x4200      BIC      R2,R2,#0x8000
   \   0000003C   0x6442             STR      R2,[R0, #+68]
   1420          
   1421            /* Disable the Peripheral */
   1422             __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_OnePulseN_Stop_IT_0: (+1)
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6A02             LDR      R2,[R0, #+32]
   \   00000042   0x420A             TST      R2,R1
   \   00000044   0xD108             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_IT_1
   \   00000046   0x6A01             LDR      R1,[R0, #+32]
   \   00000048   0xF240 0x4244      MOVW     R2,#+1092
   \   0000004C   0x4211             TST      R1,R2
   \   0000004E   0xD103             BNE.N    ??HAL_TIMEx_OnePulseN_Stop_IT_1
   \   00000050   0x6801             LDR      R1,[R0, #+0]
   \   00000052   0x0849             LSRS     R1,R1,#+1
   \   00000054   0x0049             LSLS     R1,R1,#+1
   \   00000056   0x6001             STR      R1,[R0, #+0]
   1423          
   1424            /* Return function status */
   1425            return HAL_OK;
   \                     ??HAL_TIMEx_OnePulseN_Stop_IT_1: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   1426          }
   1427          
   1428          /**
   1429            * @}
   1430            */
   1431          
   1432          #endif /* defined(STM32F100xB) || defined(STM32F100xE) ||                                                 */
   1433                 /* defined(STM32F103x6) || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG) || */
   1434                 /* defined(STM32F105xC) || defined(STM32F107xC)                                                    */
   1435          
   1436          /** @defgroup TIMEx_Exported_Functions_Group5 Peripheral Control functions
   1437           *  @brief   	Peripheral Control functions
   1438           *
   1439          @verbatim
   1440            ==============================================================================
   1441                              ##### Peripheral Control functions #####
   1442            ==============================================================================
   1443            [..]
   1444              This section provides functions allowing to:
   1445              (+) Configure the commutation event in case of use of the Hall sensor interface.
   1446                (+) Configure Complementary channels, break features and dead time.
   1447                (+) Configure Master synchronization.
   1448          
   1449          @endverbatim
   1450            * @{
   1451            */
   1452          
   1453          #if defined (STM32F100xB) || defined (STM32F100xE) ||                                                   \
   1454              defined (STM32F103x6) || defined (STM32F103xB) || defined (STM32F103xE) || defined (STM32F103xG) || \
   1455              defined (STM32F105xC) || defined (STM32F107xC)
   1456          
   1457          /**
   1458            * @brief  Configure the TIM commutation event sequence.
   1459            * @note: this function is mandatory to use the commutation event in order to
   1460            *        update the configuration at each commutation detection on the TRGI input of the Timer,
   1461            *        the typical use of this feature is with the use of another Timer(interface Timer)
   1462            *        configured in Hall sensor interface, this interface Timer will generate the
   1463            *        commutation at its TRGO output (connected to Timer used in this function) each time
   1464            *        the TI1 of the Interface Timer detect a commutation at its input TI1.
   1465            * @param  htim : TIM handle
   1466            * @param  InputTrigger : the Internal trigger corresponding to the Timer Interfacing with the Hall sensor
   1467            *          This parameter can be one of the following values:
   1468            *            @arg TIM_TS_ITR0: Internal trigger 0 selected
   1469            *            @arg TIM_TS_ITR1: Internal trigger 1 selected
   1470            *            @arg TIM_TS_ITR2: Internal trigger 2 selected
   1471            *            @arg TIM_TS_ITR3: Internal trigger 3 selected
   1472            *            @arg TIM_TS_NONE: No trigger is needed
   1473            * @param  CommutationSource : the Commutation Event source
   1474            *          This parameter can be one of the following values:
   1475            *            @arg TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer
   1476            *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit
   1477            * @retval HAL status
   1478            */

   \                                 In section .text, align 2, keep-with-next
   1479          HAL_StatusTypeDef HAL_TIMEx_ConfigCommutationEvent(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource)
   1480          {
   \                     HAL_TIMEx_ConfigCommutationEvent: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1481            /* Check the parameters */
   1482            assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));
   1483            assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
   1484          
   1485            __HAL_LOCK(htim);
   1486          
   1487            if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
   1488                (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD005             BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_0
   \   00000006   0x2910             CMP      R1,#+16
   \   00000008   0xD003             BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_0
   \   0000000A   0x2920             CMP      R1,#+32
   \   0000000C   0xD001             BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_0
   \   0000000E   0x2930             CMP      R1,#+48
   \   00000010   0xD108             BNE.N    ??HAL_TIMEx_ConfigCommutationEvent_1
   1489            {
   1490              /* Select the Input trigger */
   1491              htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \                     ??HAL_TIMEx_ConfigCommutationEvent_0: (+1)
   \   00000012   0x6803             LDR      R3,[R0, #+0]
   \   00000014   0x689C             LDR      R4,[R3, #+8]
   \   00000016   0xF024 0x0470      BIC      R4,R4,#0x70
   \   0000001A   0x609C             STR      R4,[R3, #+8]
   1492              htim->Instance->SMCR |= InputTrigger;
   \   0000001C   0x6803             LDR      R3,[R0, #+0]
   \   0000001E   0x689C             LDR      R4,[R3, #+8]
   \   00000020   0x4321             ORRS     R1,R1,R4
   \   00000022   0x6099             STR      R1,[R3, #+8]
   1493            }
   1494          
   1495            /* Select the Capture Compare preload feature */
   1496            htim->Instance->CR2 |= TIM_CR2_CCPC;
   \                     ??HAL_TIMEx_ConfigCommutationEvent_1: (+1)
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0x684B             LDR      R3,[R1, #+4]
   \   00000028   0xF043 0x0301      ORR      R3,R3,#0x1
   \   0000002C   0x604B             STR      R3,[R1, #+4]
   1497            /* Select the Commutation event source */
   1498            htim->Instance->CR2 &= ~TIM_CR2_CCUS;
   \   0000002E   0x6801             LDR      R1,[R0, #+0]
   \   00000030   0x684B             LDR      R3,[R1, #+4]
   \   00000032   0xF023 0x0304      BIC      R3,R3,#0x4
   \   00000036   0x604B             STR      R3,[R1, #+4]
   1499            htim->Instance->CR2 |= CommutationSource;
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x6841             LDR      R1,[R0, #+4]
   \   0000003C   0x430A             ORRS     R2,R2,R1
   \   0000003E   0x6042             STR      R2,[R0, #+4]
   1500          
   1501            __HAL_UNLOCK(htim);
   1502          
   1503            return HAL_OK;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xBC10             POP      {R4}
   \   00000044   0x4770             BX       LR               ;; return
   1504          }
   1505          
   1506          /**
   1507            * @brief  Configure the TIM commutation event sequence with interrupt.
   1508            * @note: this function is mandatory to use the commutation event in order to
   1509            *        update the configuration at each commutation detection on the TRGI input of the Timer,
   1510            *        the typical use of this feature is with the use of another Timer(interface Timer)
   1511            *        configured in Hall sensor interface, this interface Timer will generate the
   1512            *        commutation at its TRGO output (connected to Timer used in this function) each time
   1513            *        the TI1 of the Interface Timer detect a commutation at its input TI1.
   1514            * @param  htim : TIM handle
   1515            * @param  InputTrigger : the Internal trigger corresponding to the Timer Interfacing with the Hall sensor
   1516            *          This parameter can be one of the following values:
   1517            *            @arg TIM_TS_ITR0: Internal trigger 0 selected
   1518            *            @arg TIM_TS_ITR1: Internal trigger 1 selected
   1519            *            @arg TIM_TS_ITR2: Internal trigger 2 selected
   1520            *            @arg TIM_TS_ITR3: Internal trigger 3 selected
   1521            *            @arg TIM_TS_NONE: No trigger is needed
   1522            * @param  CommutationSource : the Commutation Event source
   1523            *          This parameter can be one of the following values:
   1524            *            @arg TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer
   1525            *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit
   1526            * @retval HAL status
   1527            */

   \                                 In section .text, align 2, keep-with-next
   1528          HAL_StatusTypeDef HAL_TIMEx_ConfigCommutationEvent_IT(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource)
   1529          {
   \                     HAL_TIMEx_ConfigCommutationEvent_IT: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1530            /* Check the parameters */
   1531            assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));
   1532            assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
   1533          
   1534            __HAL_LOCK(htim);
   1535          
   1536            if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
   1537                (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD005             BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_IT_0
   \   00000006   0x2910             CMP      R1,#+16
   \   00000008   0xD003             BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_IT_0
   \   0000000A   0x2920             CMP      R1,#+32
   \   0000000C   0xD001             BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_IT_0
   \   0000000E   0x2930             CMP      R1,#+48
   \   00000010   0xD108             BNE.N    ??HAL_TIMEx_ConfigCommutationEvent_IT_1
   1538            {
   1539              /* Select the Input trigger */
   1540              htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \                     ??HAL_TIMEx_ConfigCommutationEvent_IT_0: (+1)
   \   00000012   0x6803             LDR      R3,[R0, #+0]
   \   00000014   0x689C             LDR      R4,[R3, #+8]
   \   00000016   0xF024 0x0470      BIC      R4,R4,#0x70
   \   0000001A   0x609C             STR      R4,[R3, #+8]
   1541              htim->Instance->SMCR |= InputTrigger;
   \   0000001C   0x6803             LDR      R3,[R0, #+0]
   \   0000001E   0x689C             LDR      R4,[R3, #+8]
   \   00000020   0x4321             ORRS     R1,R1,R4
   \   00000022   0x6099             STR      R1,[R3, #+8]
   1542            }
   1543          
   1544            /* Select the Capture Compare preload feature */
   1545            htim->Instance->CR2 |= TIM_CR2_CCPC;
   \                     ??HAL_TIMEx_ConfigCommutationEvent_IT_1: (+1)
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0x684B             LDR      R3,[R1, #+4]
   \   00000028   0xF043 0x0301      ORR      R3,R3,#0x1
   \   0000002C   0x604B             STR      R3,[R1, #+4]
   1546            /* Select the Commutation event source */
   1547            htim->Instance->CR2 &= ~TIM_CR2_CCUS;
   \   0000002E   0x6801             LDR      R1,[R0, #+0]
   \   00000030   0x684B             LDR      R3,[R1, #+4]
   \   00000032   0xF023 0x0304      BIC      R3,R3,#0x4
   \   00000036   0x604B             STR      R3,[R1, #+4]
   1548            htim->Instance->CR2 |= CommutationSource;
   \   00000038   0x6801             LDR      R1,[R0, #+0]
   \   0000003A   0x684B             LDR      R3,[R1, #+4]
   \   0000003C   0x431A             ORRS     R2,R2,R3
   \   0000003E   0x604A             STR      R2,[R1, #+4]
   1549          
   1550            /* Enable the Commutation Interrupt Request */
   1551            __HAL_TIM_ENABLE_IT(htim, TIM_IT_COM);
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x68C1             LDR      R1,[R0, #+12]
   \   00000044   0xF041 0x0120      ORR      R1,R1,#0x20
   \   00000048   0x60C1             STR      R1,[R0, #+12]
   1552          
   1553            __HAL_UNLOCK(htim);
   1554          
   1555            return HAL_OK;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xBC10             POP      {R4}
   \   0000004E   0x4770             BX       LR               ;; return
   1556          }
   1557          
   1558          /**
   1559            * @brief  Configure the TIM commutation event sequence with DMA.
   1560            * @note: this function is mandatory to use the commutation event in order to
   1561            *        update the configuration at each commutation detection on the TRGI input of the Timer,
   1562            *        the typical use of this feature is with the use of another Timer(interface Timer)
   1563            *        configured in Hall sensor interface, this interface Timer will generate the
   1564            *        commutation at its TRGO output (connected to Timer used in this function) each time
   1565            *        the TI1 of the Interface Timer detect a commutation at its input TI1.
   1566            * @note: The user should configure the DMA in his own software, in This function only the COMDE bit is set
   1567            * @param  htim : TIM handle
   1568            * @param  InputTrigger : the Internal trigger corresponding to the Timer Interfacing with the Hall sensor
   1569            *          This parameter can be one of the following values:
   1570            *            @arg TIM_TS_ITR0: Internal trigger 0 selected
   1571            *            @arg TIM_TS_ITR1: Internal trigger 1 selected
   1572            *            @arg TIM_TS_ITR2: Internal trigger 2 selected
   1573            *            @arg TIM_TS_ITR3: Internal trigger 3 selected
   1574            *            @arg TIM_TS_NONE: No trigger is needed
   1575            * @param  CommutationSource : the Commutation Event source
   1576            *          This parameter can be one of the following values:
   1577            *            @arg TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer
   1578            *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit
   1579            * @retval HAL status
   1580            */

   \                                 In section .text, align 2, keep-with-next
   1581          HAL_StatusTypeDef HAL_TIMEx_ConfigCommutationEvent_DMA(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource)
   1582          {
   \                     HAL_TIMEx_ConfigCommutationEvent_DMA: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1583            /* Check the parameters */
   1584            assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));
   1585            assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
   1586          
   1587            __HAL_LOCK(htim);
   1588          
   1589            if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
   1590                (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD005             BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_DMA_0
   \   00000006   0x2910             CMP      R1,#+16
   \   00000008   0xD003             BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_DMA_0
   \   0000000A   0x2920             CMP      R1,#+32
   \   0000000C   0xD001             BEQ.N    ??HAL_TIMEx_ConfigCommutationEvent_DMA_0
   \   0000000E   0x2930             CMP      R1,#+48
   \   00000010   0xD108             BNE.N    ??HAL_TIMEx_ConfigCommutationEvent_DMA_1
   1591            {
   1592              /* Select the Input trigger */
   1593              htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \                     ??HAL_TIMEx_ConfigCommutationEvent_DMA_0: (+1)
   \   00000012   0x6803             LDR      R3,[R0, #+0]
   \   00000014   0x689C             LDR      R4,[R3, #+8]
   \   00000016   0xF024 0x0470      BIC      R4,R4,#0x70
   \   0000001A   0x609C             STR      R4,[R3, #+8]
   1594              htim->Instance->SMCR |= InputTrigger;
   \   0000001C   0x6803             LDR      R3,[R0, #+0]
   \   0000001E   0x689C             LDR      R4,[R3, #+8]
   \   00000020   0x4321             ORRS     R1,R1,R4
   \   00000022   0x6099             STR      R1,[R3, #+8]
   1595            }
   1596          
   1597            /* Select the Capture Compare preload feature */
   1598            htim->Instance->CR2 |= TIM_CR2_CCPC;
   \                     ??HAL_TIMEx_ConfigCommutationEvent_DMA_1: (+1)
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0x684B             LDR      R3,[R1, #+4]
   \   00000028   0xF043 0x0301      ORR      R3,R3,#0x1
   \   0000002C   0x604B             STR      R3,[R1, #+4]
   1599            /* Select the Commutation event source */
   1600            htim->Instance->CR2 &= ~TIM_CR2_CCUS;
   \   0000002E   0x6801             LDR      R1,[R0, #+0]
   \   00000030   0x684B             LDR      R3,[R1, #+4]
   \   00000032   0xF023 0x0304      BIC      R3,R3,#0x4
   \   00000036   0x604B             STR      R3,[R1, #+4]
   1601            htim->Instance->CR2 |= CommutationSource;
   \   00000038   0x6801             LDR      R1,[R0, #+0]
   \   0000003A   0x684B             LDR      R3,[R1, #+4]
   \   0000003C   0x431A             ORRS     R2,R2,R3
   \   0000003E   0x604A             STR      R2,[R1, #+4]
   1602          
   1603            /* Enable the Commutation DMA Request */
   1604            /* Set the DMA Commutation Callback */
   1605            htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = TIMEx_DMACommutationCplt;
   \   00000040   0x.... 0x....      ADR.W    R1,TIMEx_DMACommutationCplt
   \   00000044   0x6B02             LDR      R2,[R0, #+48]
   \   00000046   0x6291             STR      R1,[R2, #+40]
   1606            /* Set the DMA error callback */
   1607            htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError;
   \   00000048   0x....             LDR.N    R1,??DataTable4_1
   \   0000004A   0x6B02             LDR      R2,[R0, #+48]
   \   0000004C   0x6311             STR      R1,[R2, #+48]
   1608          
   1609            /* Enable the Commutation DMA Request */
   1610            __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_COM);
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0x68C1             LDR      R1,[R0, #+12]
   \   00000052   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000056   0x60C1             STR      R1,[R0, #+12]
   1611          
   1612            __HAL_UNLOCK(htim);
   1613          
   1614            return HAL_OK;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xBC10             POP      {R4}
   \   0000005C   0x4770             BX       LR               ;; return
   1615          }
   1616          
   1617          /**
   1618            * @brief   Configures the Break feature, dead time, Lock level, OSSI/OSSR State
   1619            *          and the AOE(automatic output enable).
   1620            * @param  htim : TIM handle
   1621            * @param  sBreakDeadTimeConfig : pointer to a TIM_ConfigBreakDeadConfigTypeDef structure that
   1622            *         contains the BDTR Register configuration  information for the TIM peripheral.
   1623            * @retval HAL status
   1624            */

   \                                 In section .text, align 2, keep-with-next
   1625          HAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim,
   1626                                                          TIM_BreakDeadTimeConfigTypeDef *sBreakDeadTimeConfig)
   1627          {
   1628            /* Check the parameters */
   1629            assert_param(IS_TIM_BREAK_INSTANCE(htim->Instance));
   1630            assert_param(IS_TIM_OSSR_STATE(sBreakDeadTimeConfig->OffStateRunMode));
   1631            assert_param(IS_TIM_OSSI_STATE(sBreakDeadTimeConfig->OffStateIDLEMode));
   1632            assert_param(IS_TIM_LOCK_LEVEL(sBreakDeadTimeConfig->LockLevel));
   1633            assert_param(IS_TIM_DEADTIME(sBreakDeadTimeConfig->DeadTime));
   1634            assert_param(IS_TIM_BREAK_STATE(sBreakDeadTimeConfig->BreakState));
   1635            assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));
   1636            assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));
   1637          
   1638            /* Process Locked */
   1639            __HAL_LOCK(htim);
   1640          
   1641            htim->State = HAL_TIM_STATE_BUSY;
   \                     HAL_TIMEx_ConfigBreakDeadTime: (+1)
   \   00000000   0x2202             MOVS     R2,#+2
   \   00000002   0xF880 0x2039      STRB     R2,[R0, #+57]
   1642          
   1643            /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
   1644               the OSSI State, the dead time value and the Automatic Output Enable Bit */
   1645            htim->Instance->BDTR = (uint32_t)sBreakDeadTimeConfig->OffStateRunMode  |
   1646                                             sBreakDeadTimeConfig->OffStateIDLEMode |
   1647                                             sBreakDeadTimeConfig->LockLevel        |
   1648                                             sBreakDeadTimeConfig->DeadTime         |
   1649                                             sBreakDeadTimeConfig->BreakState       |
   1650                                             sBreakDeadTimeConfig->BreakPolarity    |
   1651                                             sBreakDeadTimeConfig->AutomaticOutput;
   \   00000006   0x680B             LDR      R3,[R1, #+0]
   \   00000008   0x684A             LDR      R2,[R1, #+4]
   \   0000000A   0x4313             ORRS     R3,R2,R3
   \   0000000C   0x688A             LDR      R2,[R1, #+8]
   \   0000000E   0x4313             ORRS     R3,R2,R3
   \   00000010   0x68CA             LDR      R2,[R1, #+12]
   \   00000012   0x4313             ORRS     R3,R2,R3
   \   00000014   0x690A             LDR      R2,[R1, #+16]
   \   00000016   0x4313             ORRS     R3,R2,R3
   \   00000018   0x694A             LDR      R2,[R1, #+20]
   \   0000001A   0x4313             ORRS     R3,R2,R3
   \   0000001C   0x6989             LDR      R1,[R1, #+24]
   \   0000001E   0x430B             ORRS     R3,R1,R3
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x644B             STR      R3,[R1, #+68]
   1652          
   1653          
   1654            htim->State = HAL_TIM_STATE_READY;
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0xF880 0x1039      STRB     R1,[R0, #+57]
   1655          
   1656            __HAL_UNLOCK(htim);
   1657          
   1658            return HAL_OK;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x4770             BX       LR               ;; return
   1659          }
   1660          
   1661          #endif /* defined(STM32F100xB) || defined(STM32F100xE) ||                                                 */
   1662                 /* defined(STM32F103x6) || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG) || */
   1663                 /* defined(STM32F105xC) || defined(STM32F107xC)                                                    */
   1664          
   1665          /**
   1666            * @brief  Configures the TIM in master mode.
   1667            * @param  htim : TIM handle.
   1668            * @param  sMasterConfig : pointer to a TIM_MasterConfigTypeDef structure that
   1669            *         contains the selected trigger output (TRGO) and the Master/Slave
   1670            *         mode.
   1671            * @retval HAL status
   1672            */

   \                                 In section .text, align 2, keep-with-next
   1673          HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim, TIM_MasterConfigTypeDef * sMasterConfig)
   1674          {
   \                     HAL_TIMEx_MasterConfigSynchronization: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1675            /* Check the parameters */
   1676            assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
   1677            assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
   1678            assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
   1679          
   1680            __HAL_LOCK(htim);
   1681          
   1682            htim->State = HAL_TIM_STATE_BUSY;
   \   00000002   0x2202             MOVS     R2,#+2
   \   00000004   0xF880 0x2039      STRB     R2,[R0, #+57]
   1683          
   1684            /* Reset the MMS Bits */
   1685            htim->Instance->CR2 &= ~TIM_CR2_MMS;
   \   00000008   0x6802             LDR      R2,[R0, #+0]
   \   0000000A   0x6853             LDR      R3,[R2, #+4]
   \   0000000C   0xF023 0x0370      BIC      R3,R3,#0x70
   \   00000010   0x6053             STR      R3,[R2, #+4]
   1686            /* Select the TRGO source */
   1687            htim->Instance->CR2 |=  sMasterConfig->MasterOutputTrigger;
   \   00000012   0x6803             LDR      R3,[R0, #+0]
   \   00000014   0x685C             LDR      R4,[R3, #+4]
   \   00000016   0x680A             LDR      R2,[R1, #+0]
   \   00000018   0x4314             ORRS     R4,R2,R4
   \   0000001A   0x605C             STR      R4,[R3, #+4]
   1688          
   1689            /* Reset the MSM Bit */
   1690            htim->Instance->SMCR &= ~TIM_SMCR_MSM;
   \   0000001C   0x6802             LDR      R2,[R0, #+0]
   \   0000001E   0x6893             LDR      R3,[R2, #+8]
   \   00000020   0xF023 0x0380      BIC      R3,R3,#0x80
   \   00000024   0x6093             STR      R3,[R2, #+8]
   1691            /* Set or Reset the MSM Bit */
   1692            htim->Instance->SMCR |= sMasterConfig->MasterSlaveMode;
   \   00000026   0x6802             LDR      R2,[R0, #+0]
   \   00000028   0x6893             LDR      R3,[R2, #+8]
   \   0000002A   0x6849             LDR      R1,[R1, #+4]
   \   0000002C   0x430B             ORRS     R3,R1,R3
   \   0000002E   0x6093             STR      R3,[R2, #+8]
   1693          
   1694            htim->State = HAL_TIM_STATE_READY;
   \   00000030   0x2101             MOVS     R1,#+1
   \   00000032   0xF880 0x1039      STRB     R1,[R0, #+57]
   1695          
   1696            __HAL_UNLOCK(htim);
   1697          
   1698            return HAL_OK;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xBC10             POP      {R4}
   \   0000003A   0x4770             BX       LR               ;; return
   1699          }
   1700          
   1701          /**
   1702            * @}
   1703            */
   1704          
   1705          /** @defgroup TIMEx_Exported_Functions_Group6 Extension Callbacks functions
   1706           *  @brief   Extension Callbacks functions
   1707           *
   1708          @verbatim
   1709            ==============================================================================
   1710                              ##### Extension Callbacks functions #####
   1711            ==============================================================================
   1712            [..]
   1713              This section provides Extension TIM callback functions:
   1714              (+) Timer Commutation callback
   1715              (+) Timer Break callback
   1716          
   1717          @endverbatim
   1718            * @{
   1719            */
   1720          
   1721          /**
   1722            * @brief  Hall commutation changed callback in non blocking mode
   1723            * @param  htim : TIM handle
   1724            * @retval None
   1725            */

   \                                 In section .text, align 2
   1726          __weak void HAL_TIMEx_CommutationCallback(TIM_HandleTypeDef *htim)
   1727          {
   1728            /* Prevent unused argument(s) compilation warning */
   1729            UNUSED(htim);
   1730            /* NOTE : This function Should not be modified, when the callback is needed,
   1731                      the HAL_TIMEx_CommutationCallback could be implemented in the user file
   1732             */
   1733          }
   \                     HAL_TIMEx_CommutationCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1734          
   1735          /**
   1736            * @brief  Hall Break detection callback in non blocking mode
   1737            * @param  htim : TIM handle
   1738            * @retval None
   1739            */

   \                                 In section .text, align 2
   1740          __weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
   1741          {
   1742            /* Prevent unused argument(s) compilation warning */
   1743            UNUSED(htim);
   1744            /* NOTE : This function Should not be modified, when the callback is needed,
   1745                      the HAL_TIMEx_BreakCallback could be implemented in the user file
   1746             */
   1747          }
   \                     HAL_TIMEx_BreakCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1748          
   1749          /**
   1750            * @brief  TIM DMA Commutation callback.
   1751            * @param  hdma : pointer to DMA handle.
   1752            * @retval None
   1753            */

   \                                 In section .text, align 4, keep-with-next
   1754          void TIMEx_DMACommutationCplt(DMA_HandleTypeDef *hdma)
   1755          {
   1756            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \                     TIMEx_DMACommutationCplt: (+1)
   \   00000000   0x6A40             LDR      R0,[R0, #+36]
   1757          
   1758            htim->State= HAL_TIM_STATE_READY;
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0xF880 0x1039      STRB     R1,[R0, #+57]
   1759          
   1760            HAL_TIMEx_CommutationCallback(htim);
   \   00000008   0x.... 0x....      B.W      HAL_TIMEx_CommutationCallback
   1761          }
   1762          
   1763          /**
   1764            * @}
   1765            */
   1766          
   1767          #if defined (STM32F100xB) || defined (STM32F100xE) ||                                                   \
   1768              defined (STM32F103x6) || defined (STM32F103xB) || defined (STM32F103xE) || defined (STM32F103xG) || \
   1769              defined (STM32F105xC) || defined (STM32F107xC)
   1770          
   1771          /** @defgroup TIMEx_Exported_Functions_Group7 Extension Peripheral State functions
   1772           *  @brief   Extension Peripheral State functions
   1773           *
   1774          @verbatim
   1775            ==============================================================================
   1776                          ##### Extension Peripheral State functions #####
   1777            ==============================================================================
   1778            [..]
   1779              This subsection permit to get in run-time the status of the peripheral
   1780              and the data flow.
   1781          
   1782          @endverbatim
   1783            * @{
   1784            */
   1785          
   1786          /**
   1787            * @brief  Return the TIM Hall Sensor interface state
   1788            * @param  htim : TIM Hall Sensor handle
   1789            * @retval HAL state
   1790            */

   \                                 In section .text, align 2, keep-with-next
   1791          HAL_TIM_StateTypeDef HAL_TIMEx_HallSensor_GetState(TIM_HandleTypeDef *htim)
   1792          {
   1793            return htim->State;
   \                     HAL_TIMEx_HallSensor_GetState: (+1)
   \   00000000   0xF990 0x0039      LDRSB    R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   1794          }
   1795          
   1796          /**
   1797            * @}
   1798            */
   1799          #endif /* defined(STM32F100xB) || defined(STM32F100xE) ||                                                 */
   1800                 /* defined(STM32F103x6) || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG) || */
   1801                 /* defined(STM32F105xC) || defined(STM32F107xC)                                                    */
   1802          
   1803          /**
   1804            * @}
   1805            */
   1806          
   1807          #if defined (STM32F100xB) || defined (STM32F100xE) ||                                                   \
   1808              defined (STM32F103x6) || defined (STM32F103xB) || defined (STM32F103xE) || defined (STM32F103xG) || \
   1809              defined (STM32F105xC) || defined (STM32F107xC)
   1810          
   1811          /** @addtogroup TIMEx_Private_Functions
   1812            * @{
   1813            */
   1814          
   1815          /**
   1816            * @brief  Enables or disables the TIM Capture Compare Channel xN.
   1817            * @param  TIMx  to select the TIM peripheral
   1818            * @param  Channel : specifies the TIM Channel
   1819            *          This parameter can be one of the following values:
   1820            *            @arg TIM_Channel_1: TIM Channel 1
   1821            *            @arg TIM_Channel_2: TIM Channel 2
   1822            *            @arg TIM_Channel_3: TIM Channel 3
   1823            * @param  ChannelNState : specifies the TIM Channel CCxNE bit new state.
   1824            *          This parameter can be: TIM_CCxN_ENABLE or TIM_CCxN_Disable.
   1825            * @retval None
   1826            */

   \                                 In section .text, align 2, keep-with-next
   1827          static void TIM_CCxNChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelNState)
   1828          {
   \                     TIM_CCxNChannelCmd: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1829            uint32_t tmp = 0;
   1830          
   1831            tmp = TIM_CCER_CC1NE << Channel;
   1832          
   1833            /* Reset the CCxNE Bit */
   1834            TIMx->CCER &=  ~tmp;
   \   00000002   0x6A03             LDR      R3,[R0, #+32]
   \   00000004   0x2404             MOVS     R4,#+4
   \   00000006   0x408C             LSLS     R4,R4,R1
   \   00000008   0x43A3             BICS     R3,R3,R4
   \   0000000A   0x6203             STR      R3,[R0, #+32]
   1835          
   1836            /* Set or reset the CCxNE Bit */
   1837            TIMx->CCER |=  (uint32_t)(ChannelNState << Channel);
   \   0000000C   0x6A03             LDR      R3,[R0, #+32]
   \   0000000E   0xFA02 0xF101      LSL      R1,R2,R1
   \   00000012   0x4319             ORRS     R1,R1,R3
   \   00000014   0x6201             STR      R1,[R0, #+32]
   1838          }
   \   00000016   0xBC10             POP      {R4}
   \   00000018   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     TIM_DMACaptureCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     TIM_DMADelayPulseCplt
   1839          
   1840          /**
   1841            * @}
   1842            */
   1843          
   1844          #endif /* defined(STM32F100xB) || defined(STM32F100xE) ||                                                 */
   1845                 /* defined(STM32F103x6) || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG) || */
   1846                 /* defined(STM32F105xC) || defined(STM32F107xC)                                                    */
   1847          
   1848          #endif /* HAL_TIM_MODULE_ENABLED */
   1849          /**
   1850            * @}
   1851            */
   1852          
   1853          /**
   1854            * @}
   1855            */
   1856          
   1857          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_TIMEx_BreakCallback
       0   HAL_TIMEx_CommutationCallback
       0   HAL_TIMEx_ConfigBreakDeadTime
       4   HAL_TIMEx_ConfigCommutationEvent
       4   HAL_TIMEx_ConfigCommutationEvent_DMA
       4   HAL_TIMEx_ConfigCommutationEvent_IT
       8   HAL_TIMEx_HallSensor_DeInit
         8   -> HAL_TIMEx_HallSensor_MspDeInit
       0   HAL_TIMEx_HallSensor_GetState
      48   HAL_TIMEx_HallSensor_Init
        48   -> HAL_TIMEx_HallSensor_MspInit
        48   -> TIM_Base_SetConfig
        48   -> TIM_OC2_SetConfig
        48   -> TIM_TI1_SetConfig
       0   HAL_TIMEx_HallSensor_MspDeInit
       0   HAL_TIMEx_HallSensor_MspInit
       8   HAL_TIMEx_HallSensor_Start
         8   -> TIM_CCxChannelCmd
      24   HAL_TIMEx_HallSensor_Start_DMA
        24   -> HAL_DMA_Start_IT
        24   -> TIM_CCxChannelCmd
       8   HAL_TIMEx_HallSensor_Start_IT
         8   -> TIM_CCxChannelCmd
      16   HAL_TIMEx_HallSensor_Stop
        16   -> TIM_CCxChannelCmd
      16   HAL_TIMEx_HallSensor_Stop_DMA
        16   -> TIM_CCxChannelCmd
      16   HAL_TIMEx_HallSensor_Stop_IT
        16   -> TIM_CCxChannelCmd
       4   HAL_TIMEx_MasterConfigSynchronization
       8   HAL_TIMEx_OCN_Start
         8   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_OCN_Start_DMA
        16   -> HAL_DMA_Start_IT
        16   -> TIM_CCxNChannelCmd
       8   HAL_TIMEx_OCN_Start_IT
         8   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_OCN_Stop
        16   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_OCN_Stop_DMA
        16   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_OCN_Stop_IT
        16   -> TIM_CCxNChannelCmd
       8   HAL_TIMEx_OnePulseN_Start
         8   -> TIM_CCxNChannelCmd
       8   HAL_TIMEx_OnePulseN_Start_IT
         8   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_OnePulseN_Stop
        16   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_OnePulseN_Stop_IT
        16   -> TIM_CCxNChannelCmd
       8   HAL_TIMEx_PWMN_Start
         8   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_PWMN_Start_DMA
        16   -> HAL_DMA_Start_IT
        16   -> TIM_CCxNChannelCmd
       8   HAL_TIMEx_PWMN_Start_IT
         8   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_PWMN_Stop
        16   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_PWMN_Stop_DMA
        16   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_PWMN_Stop_IT
        16   -> TIM_CCxNChannelCmd
       0   TIMEx_DMACommutationCplt
         0   -> HAL_TIMEx_CommutationCallback
       4   TIM_CCxNChannelCmd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       2  HAL_TIMEx_BreakCallback
       2  HAL_TIMEx_CommutationCallback
      46  HAL_TIMEx_ConfigBreakDeadTime
      70  HAL_TIMEx_ConfigCommutationEvent
      94  HAL_TIMEx_ConfigCommutationEvent_DMA
      80  HAL_TIMEx_ConfigCommutationEvent_IT
      54  HAL_TIMEx_HallSensor_DeInit
       6  HAL_TIMEx_HallSensor_GetState
     192  HAL_TIMEx_HallSensor_Init
       2  HAL_TIMEx_HallSensor_MspDeInit
       2  HAL_TIMEx_HallSensor_MspInit
      28  HAL_TIMEx_HallSensor_Start
     112  HAL_TIMEx_HallSensor_Start_DMA
      38  HAL_TIMEx_HallSensor_Start_IT
      48  HAL_TIMEx_HallSensor_Stop
      58  HAL_TIMEx_HallSensor_Stop_DMA
      58  HAL_TIMEx_HallSensor_Stop_IT
      60  HAL_TIMEx_MasterConfigSynchronization
      36  HAL_TIMEx_OCN_Start
     256  HAL_TIMEx_OCN_Start_DMA
     110  HAL_TIMEx_OCN_Start_IT
      72  HAL_TIMEx_OCN_Stop
     142  HAL_TIMEx_OCN_Stop_DMA
     148  HAL_TIMEx_OCN_Stop_IT
      26  HAL_TIMEx_OnePulseN_Start
      46  HAL_TIMEx_OnePulseN_Start_IT
      72  HAL_TIMEx_OnePulseN_Stop
      92  HAL_TIMEx_OnePulseN_Stop_IT
      36  HAL_TIMEx_PWMN_Start
     240  HAL_TIMEx_PWMN_Start_DMA
     110  HAL_TIMEx_PWMN_Start_IT
      72  HAL_TIMEx_PWMN_Stop
     142  HAL_TIMEx_PWMN_Stop_DMA
     148  HAL_TIMEx_PWMN_Stop_IT
      12  TIMEx_DMACommutationCplt
      26  TIM_CCxNChannelCmd

 
 2 750 bytes in section .text
 
 2 742 bytes of CODE memory (+ 8 bytes shared)

Errors: none
Warnings: none
