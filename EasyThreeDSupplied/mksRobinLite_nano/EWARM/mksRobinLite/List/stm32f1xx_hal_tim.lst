###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       28/Dec/2020  22:13:57
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\nano\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_tim.c
#    Command line =  
#        -f C:\Users\ADMINI~1\AppData\Local\Temp\EWFD97.tmp
#        (F:\nano\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_tim.c -D
#        USE_HAL_DRIVER -D STM32F103xE -D MKS_ROBIN -D MARLIN -D __arm__ -D
#        USE_MKS_WIFI --preprocess=s F:\nano\EWARM\mksRobinLite\List -lC
#        F:\nano\EWARM\mksRobinLite\List -lA F:\nano\EWARM\mksRobinLite\List
#        --diag_suppress Pa050 -o F:\nano\EWARM\mksRobinLite\Obj --no_unroll
#        --no_inline --no_tbaa --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --char_is_signed --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Full.h" -I F:\nano\EWARM/../Inc\ -I
#        F:\nano\EWARM/../Src\ -I
#        F:\nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\ -I
#        F:\nano\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\ -I
#        F:\nano\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/Inc\ -I
#        F:\nano\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\ -I
#        F:\nano\EWARM/../Drivers/CMSIS/Include\ -I
#        F:\nano\EWARM/../Drivers/BSP/STM32MKS-3dPrinter\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/Common\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/l6474\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/at24cxx\ -I
#        F:\nano\EWARM/../Drivers/BSP/Components/w25qxx\ -I
#        F:\nano\EWARM/../Drivers/BSP/MotorControl\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/FatFs/src\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/Marlin\ -I
#        F:\nano\EWARM/../Middlewares/Third_Party/u8glib_arm_v1.17/src\ -I
#        F:\nano\EWARM/../Middlewares/arduino\ -I
#        F:\nano\EWARM/../Middlewares/arduino/avr\ -I
#        F:\nano\EWARM/../Inc/Logo\ -Om --use_c++_inline -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.0\arm\CMSIS\Core\Include\" -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  F:\nano\EWARM\mksRobinLite\List\stm32f1xx_hal_tim.lst
#    Object file  =  F:\nano\EWARM\mksRobinLite\Obj\stm32f1xx_hal_tim.o
#
###############################################################################

F:\nano\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_tim.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f1xx_hal_tim.c
      4            * @author  MCD Application Team
      5            * @version V1.0.4
      6            * @date    29-April-2016
      7            * @brief   TIM HAL module driver
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Timer (TIM) peripheral:
     10            *           + Time Base Initialization
     11            *           + Time Base Start
     12            *           + Time Base Start Interruption
     13            *           + Time Base Start DMA
     14            *           + Time Output Compare/PWM Initialization
     15            *           + Time Output Compare/PWM Channel Configuration
     16            *           + Time Output Compare/PWM  Start
     17            *           + Time Output Compare/PWM  Start Interruption
     18            *           + Time Output Compare/PWM Start DMA
     19            *           + Time Input Capture Initialization
     20            *           + Time Input Capture Channel Configuration
     21            *           + Time Input Capture Start
     22            *           + Time Input Capture Start Interruption 
     23            *           + Time Input Capture Start DMA
     24            *           + Time One Pulse Initialization
     25            *           + Time One Pulse Channel Configuration
     26            *           + Time One Pulse Start 
     27            *           + Time Encoder Interface Initialization
     28            *           + Time Encoder Interface Start
     29            *           + Time Encoder Interface Start Interruption
     30            *           + Time Encoder Interface Start DMA
     31            *           + Commutation Event configuration with Interruption and DMA
     32            *           + Time OCRef clear configuration
     33            *           + Time External Clock configuration
     34            @verbatim
     35            ==============================================================================
     36                                ##### TIMER Generic features #####
     37            ==============================================================================
     38            [..] The Timer features include:
     39                 (#) 16-bit up, down, up/down auto-reload counter.
     40                 (#) 16-bit programmable prescaler allowing dividing (also on the fly) the 
     41                     counter clock frequency either by any factor between 1 and 65536.
     42                 (#) Up to 4 independent channels for:
     43                     (++) Input Capture
     44                     (++) Output Compare
     45                     (++) PWM generation (Edge and Center-aligned Mode)
     46                     (++) One-pulse mode output 
     47          
     48                      ##### How to use this driver #####
     49            ==============================================================================
     50              [..]
     51               (#) Initialize the TIM low level resources by implementing the following functions 
     52                   depending from feature used :
     53                     (++) Time Base : HAL_TIM_Base_MspInit()
     54                     (++) Input Capture : HAL_TIM_IC_MspInit()
     55                     (++) Output Compare : HAL_TIM_OC_MspInit()
     56                     (++) PWM generation : HAL_TIM_PWM_MspInit()
     57                     (++) One-pulse mode output : HAL_TIM_OnePulse_MspInit()
     58                     (++) Encoder mode output : HAL_TIM_Encoder_MspInit()
     59          
     60               (#) Initialize the TIM low level resources :
     61                  (##) Enable the TIM interface clock using __HAL_RCC_TIMx_CLK_ENABLE();
     62                  (##) TIM pins configuration
     63                      (+++) Enable the clock for the TIM GPIOs using the following function:
     64                       __HAL_RCC_GPIOx_CLK_ENABLE();
     65                      (+++) Configure these TIM pins in Alternate function mode using HAL_GPIO_Init();
     66          
     67               (#) The external Clock can be configured, if needed (the default clock is the 
     68                   internal clock from the APBx), using the following function:
     69                   HAL_TIM_ConfigClockSource, the clock configuration should be done before 
     70                   any start function.
     71          
     72               (#) Configure the TIM in the desired functioning mode using one of the 
     73                 Initialization function of this driver:
     74                 (++) HAL_TIM_Base_Init: to use the Timer to generate a simple time base
     75                 (++) HAL_TIM_OC_Init and HAL_TIM_OC_ConfigChannel: to use the Timer to generate an 
     76                      Output Compare signal.
     77                 (++) HAL_TIM_PWM_Init and HAL_TIM_PWM_ConfigChannel: to use the Timer to generate a 
     78                      PWM signal.
     79                 (++) HAL_TIM_IC_Init and HAL_TIM_IC_ConfigChannel: to use the Timer to measure an 
     80                      external signal.
     81                   (++) HAL_TIM_OnePulse_Init and HAL_TIM_OnePulse_ConfigChannel: to use the Timer 
     82                        in One Pulse Mode.
     83                 (++) HAL_TIM_Encoder_Init: to use the Timer Encoder Interface.
     84          
     85               (#) Activate the TIM peripheral using one of the start functions depending from the feature used:
     86                     (++) Time Base : HAL_TIM_Base_Start(), HAL_TIM_Base_Start_DMA(), HAL_TIM_Base_Start_IT()
     87                     (++) Input Capture :  HAL_TIM_IC_Start(), HAL_TIM_IC_Start_DMA(), HAL_TIM_IC_Start_IT()
     88                     (++) Output Compare : HAL_TIM_OC_Start(), HAL_TIM_OC_Start_DMA(), HAL_TIM_OC_Start_IT()
     89                     (++) PWM generation : HAL_TIM_PWM_Start(), HAL_TIM_PWM_Start_DMA(), HAL_TIM_PWM_Start_IT()
     90                     (++) One-pulse mode output : HAL_TIM_OnePulse_Start(), HAL_TIM_OnePulse_Start_IT()
     91                     (++) Encoder mode output : HAL_TIM_Encoder_Start(), HAL_TIM_Encoder_Start_DMA(), HAL_TIM_Encoder_Start_IT().
     92          
     93               (#) The DMA Burst is managed with the two following functions:
     94                   HAL_TIM_DMABurst_WriteStart()
     95                   HAL_TIM_DMABurst_ReadStart()
     96          
     97            @endverbatim
     98            ******************************************************************************
     99            * @attention
    100            *
    101            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
    102            *
    103            * Redistribution and use in source and binary forms, with or without modification,
    104            * are permitted provided that the following conditions are met:
    105            *   1. Redistributions of source code must retain the above copyright notice,
    106            *      this list of conditions and the following disclaimer.
    107            *   2. Redistributions in binary form must reproduce the above copyright notice,
    108            *      this list of conditions and the following disclaimer in the documentation
    109            *      and/or other materials provided with the distribution.
    110            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    111            *      may be used to endorse or promote products derived from this software
    112            *      without specific prior written permission.
    113            *
    114            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    115            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    116            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    117            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    118            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    119            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    120            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    121            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    122            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    123            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    124            *
    125            ******************************************************************************
    126            */
    127          
    128          /* Includes ------------------------------------------------------------------*/
    129          #include "stm32f1xx_hal.h"
    130          
    131          /** @addtogroup STM32F1xx_HAL_Driver
    132            * @{
    133            */
    134          
    135          /** @defgroup TIM TIM
    136            * @brief TIM HAL module driver
    137            * @{
    138            */
    139          
    140          #ifdef HAL_TIM_MODULE_ENABLED
    141          
    142          /* Private typedef -----------------------------------------------------------*/
    143          /* Private define ------------------------------------------------------------*/
    144          /* Private macro -------------------------------------------------------------*/
    145          /* Private variables ---------------------------------------------------------*/
    146          /* Private function prototypes -----------------------------------------------*/
    147          /** @defgroup TIM_Private_Functions TIM Private Functions
    148            * @{
    149            */
    150          static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    151          static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    152          static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    153          static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);
    154          static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    155                                 uint32_t TIM_ICFilter);
    156          static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);
    157          static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    158                                 uint32_t TIM_ICFilter);
    159          static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    160                                 uint32_t TIM_ICFilter);
    161          static void TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler,
    162                                 uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter);
    163          static void TIM_ITRx_SetConfig(TIM_TypeDef* TIMx, uint16_t InputTriggerSource);
    164          static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma);
    165          static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma);
    166          static void TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
    167                                               TIM_SlaveConfigTypeDef * sSlaveConfig);
    168          
    169          /**
    170            * @}
    171            */
    172          
    173          /* Exported functions ---------------------------------------------------------*/
    174          
    175          /** @defgroup TIM_Exported_Functions TIM Exported Functions
    176            * @{
    177            */
    178          
    179          /** @defgroup TIM_Exported_Functions_Group1 Time Base functions 
    180           *  @brief    Time Base functions 
    181           *
    182          @verbatim 
    183            ==============================================================================
    184                        ##### Time Base functions #####
    185            ==============================================================================
    186            [..]
    187              This section provides functions allowing to:
    188              (+) Initialize and configure the TIM base.
    189              (+) De-initialize the TIM base.
    190              (+) Start the Time Base.
    191              (+) Stop the Time Base.
    192              (+) Start the Time Base and enable interrupt.
    193              (+) Stop the Time Base and disable interrupt.
    194              (+) Start the Time Base and enable DMA transfer.
    195              (+) Stop the Time Base and disable DMA transfer.
    196          
    197          @endverbatim
    198            * @{
    199            */
    200          /**
    201            * @brief  Initializes the TIM Time base Unit according to the specified
    202            *         parameters in the TIM_HandleTypeDef and create the associated handle.
    203            * @param  htim : TIM Base handle
    204            * @retval HAL status
    205            */

   \                                 In section .text, align 2, keep-with-next
    206          HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
    207          {
   \                     HAL_TIM_Base_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    208            /* Check the TIM handle allocation */
    209            if(htim == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_TIM_Base_Init_0
    210            {
    211              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD32             POP      {R1,R4,R5,PC}
    212            }
    213          
    214            /* Check the parameters */
    215            assert_param(IS_TIM_INSTANCE(htim->Instance));
    216            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    217            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    218          
    219            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_Base_Init_0: (+1)
   \   0000000A   0xF104 0x0538      ADD      R5,R4,#+56
   \   0000000E   0xF995 0x0001      LDRSB    R0,[R5, #+1]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD104             BNE.N    ??HAL_TIM_Base_Init_1
    220            {
    221              /* Allocate lock resource and initialize it */
    222              htim->Lock = HAL_UNLOCKED;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x7028             STRB     R0,[R5, #+0]
    223              
    224              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    225              HAL_TIM_Base_MspInit(htim);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       HAL_TIM_Base_MspInit
    226            }
    227          
    228            /* Set the TIM state */
    229            htim->State= HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Base_Init_1: (+1)
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0x7068             STRB     R0,[R5, #+1]
    230          
    231            /* Set the Time Base configuration */
    232            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \   00000024   0x1D21             ADDS     R1,R4,#+4
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x.... 0x....      BL       TIM_Base_SetConfig
    233          
    234            /* Initialize the TIM state*/
    235            htim->State= HAL_TIM_STATE_READY;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x7068             STRB     R0,[R5, #+1]
    236          
    237            return HAL_OK;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    238          }
    239          
    240          /**
    241            * @brief  DeInitializes the TIM Base peripheral 
    242            * @param  htim : TIM Base handle
    243            * @retval HAL status
    244            */

   \                                 In section .text, align 2, keep-with-next
    245          HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
    246          {
   \                     HAL_TIM_Base_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    247            /* Check the parameters */
    248            assert_param(IS_TIM_INSTANCE(htim->Instance));
    249          
    250            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
    251          
    252            /* Disable the TIM Peripheral Clock */
    253            __HAL_TIM_DISABLE(htim);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6A01             LDR      R1,[R0, #+32]
   \   0000000E   0xF241 0x1211      MOVW     R2,#+4369
   \   00000012   0x4211             TST      R1,R2
   \   00000014   0xD108             BNE.N    ??HAL_TIM_Base_DeInit_0
   \   00000016   0x6A01             LDR      R1,[R0, #+32]
   \   00000018   0xF240 0x4244      MOVW     R2,#+1092
   \   0000001C   0x4211             TST      R1,R2
   \   0000001E   0xD103             BNE.N    ??HAL_TIM_Base_DeInit_0
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x0849             LSRS     R1,R1,#+1
   \   00000024   0x0049             LSLS     R1,R1,#+1
   \   00000026   0x6001             STR      R1,[R0, #+0]
    254          
    255            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    256            HAL_TIM_Base_MspDeInit(htim);
   \                     ??HAL_TIM_Base_DeInit_0: (+1)
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_TIM_Base_MspDeInit
    257          
    258            /* Change TIM state */
    259            htim->State = HAL_TIM_STATE_RESET;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF884 0x0039      STRB     R0,[R4, #+57]
    260          
    261            /* Release Lock */
    262            __HAL_UNLOCK(htim);
    263          
    264            return HAL_OK;
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    265          }
    266          
    267          /**
    268            * @brief  Initializes the TIM Base MSP.
    269            * @param  htim : TIM handle
    270            * @retval None
    271            */

   \                                 In section .text, align 2
    272          __weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
    273          {
    274            /* Prevent unused argument(s) compilation warning */
    275            UNUSED(htim);
    276            /* NOTE : This function Should not be modified, when the callback is needed,
    277                      the HAL_TIM_Base_MspInit could be implemented in the user file
    278             */
    279          }
   \                     HAL_TIM_Base_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    280          
    281          /**
    282            * @brief  DeInitializes TIM Base MSP.
    283            * @param  htim : TIM handle
    284            * @retval None
    285            */

   \                                 In section .text, align 2
    286          __weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
    287          {
    288            /* Prevent unused argument(s) compilation warning */
    289            UNUSED(htim);
    290            /* NOTE : This function Should not be modified, when the callback is needed,
    291                      the HAL_TIM_Base_MspDeInit could be implemented in the user file
    292             */
    293          }
   \                     HAL_TIM_Base_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    294          
    295          
    296          /**
    297            * @brief  Starts the TIM Base generation.
    298            * @param  htim : TIM handle
    299            * @retval HAL status
    300          */

   \                                 In section .text, align 2, keep-with-next
    301          HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
    302          {
    303            /* Check the parameters */
    304            assert_param(IS_TIM_INSTANCE(htim->Instance));
    305          
    306            /* Set the TIM state */
    307            htim->State= HAL_TIM_STATE_BUSY;
   \                     HAL_TIM_Base_Start: (+1)
   \   00000000   0x2102             MOVS     R1,#+2
   \   00000002   0xF880 0x1039      STRB     R1,[R0, #+57]
    308          
    309            /* Enable the Peripheral */
    310            __HAL_TIM_ENABLE(htim);
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x680A             LDR      R2,[R1, #+0]
   \   0000000A   0xF042 0x0201      ORR      R2,R2,#0x1
   \   0000000E   0x600A             STR      R2,[R1, #+0]
    311          
    312            /* Change the TIM state*/
    313            htim->State= HAL_TIM_STATE_READY;
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0xF880 0x1039      STRB     R1,[R0, #+57]
    314          
    315            /* Return function status */
    316            return HAL_OK;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x4770             BX       LR               ;; return
    317          }
    318          
    319          /**
    320            * @brief  Stops the TIM Base generation.
    321            * @param  htim : TIM handle
    322            * @retval HAL status
    323          */

   \                                 In section .text, align 2, keep-with-next
    324          HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
    325          {
    326            /* Check the parameters */
    327            assert_param(IS_TIM_INSTANCE(htim->Instance));
    328          
    329            /* Set the TIM state */
    330            htim->State= HAL_TIM_STATE_BUSY;
   \                     HAL_TIM_Base_Stop: (+1)
   \   00000000   0x2102             MOVS     R1,#+2
   \   00000002   0xF880 0x1039      STRB     R1,[R0, #+57]
    331          
    332            /* Disable the Peripheral */
    333            __HAL_TIM_DISABLE(htim);
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x6A0A             LDR      R2,[R1, #+32]
   \   0000000A   0xF241 0x1311      MOVW     R3,#+4369
   \   0000000E   0x421A             TST      R2,R3
   \   00000010   0xD108             BNE.N    ??HAL_TIM_Base_Stop_0
   \   00000012   0x6A0A             LDR      R2,[R1, #+32]
   \   00000014   0xF240 0x4344      MOVW     R3,#+1092
   \   00000018   0x421A             TST      R2,R3
   \   0000001A   0xD103             BNE.N    ??HAL_TIM_Base_Stop_0
   \   0000001C   0x680A             LDR      R2,[R1, #+0]
   \   0000001E   0x0852             LSRS     R2,R2,#+1
   \   00000020   0x0052             LSLS     R2,R2,#+1
   \   00000022   0x600A             STR      R2,[R1, #+0]
    334          
    335            /* Change the TIM state*/
    336            htim->State= HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Base_Stop_0: (+1)
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0xF880 0x1039      STRB     R1,[R0, #+57]
    337          
    338            /* Return function status */
    339            return HAL_OK;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x4770             BX       LR               ;; return
    340          }
    341          
    342          /**
    343            * @brief  Starts the TIM Base generation in interrupt mode.
    344            * @param  htim : TIM handle
    345            * @retval HAL status
    346          */

   \                                 In section .text, align 2, keep-with-next
    347          HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
    348          {
    349            /* Check the parameters */
    350            assert_param(IS_TIM_INSTANCE(htim->Instance));
    351          
    352             /* Enable the TIM Update interrupt */
    353             __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
   \                     HAL_TIM_Base_Start_IT: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x68CA             LDR      R2,[R1, #+12]
   \   00000004   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000008   0x60CA             STR      R2,[R1, #+12]
    354          
    355             /* Enable the Peripheral */
    356            __HAL_TIM_ENABLE(htim);
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x6801             LDR      R1,[R0, #+0]
   \   0000000E   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000012   0x6001             STR      R1,[R0, #+0]
    357          
    358            /* Return function status */
    359            return HAL_OK;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x4770             BX       LR               ;; return
    360          }
    361          
    362          /**
    363            * @brief  Stops the TIM Base generation in interrupt mode.
    364            * @param  htim : TIM handle
    365            * @retval HAL status
    366          */

   \                                 In section .text, align 2, keep-with-next
    367          HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
    368          {
   \                     HAL_TIM_Base_Stop_IT: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
    369            /* Check the parameters */
    370            assert_param(IS_TIM_INSTANCE(htim->Instance));
    371            /* Disable the TIM Update interrupt */
    372            __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x68CA             LDR      R2,[R1, #+12]
   \   00000006   0x0852             LSRS     R2,R2,#+1
   \   00000008   0x0052             LSLS     R2,R2,#+1
   \   0000000A   0x60CA             STR      R2,[R1, #+12]
    373          
    374            /* Disable the Peripheral */
    375            __HAL_TIM_DISABLE(htim);
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x6A01             LDR      R1,[R0, #+32]
   \   00000010   0xF241 0x1211      MOVW     R2,#+4369
   \   00000014   0x4211             TST      R1,R2
   \   00000016   0xD108             BNE.N    ??HAL_TIM_Base_Stop_IT_0
   \   00000018   0x6A01             LDR      R1,[R0, #+32]
   \   0000001A   0xF240 0x4244      MOVW     R2,#+1092
   \   0000001E   0x4211             TST      R1,R2
   \   00000020   0xD103             BNE.N    ??HAL_TIM_Base_Stop_IT_0
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0x0849             LSRS     R1,R1,#+1
   \   00000026   0x0049             LSLS     R1,R1,#+1
   \   00000028   0x6001             STR      R1,[R0, #+0]
    376          
    377            /* Return function status */
    378            return HAL_OK;
   \                     ??HAL_TIM_Base_Stop_IT_0: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xB001             ADD      SP,SP,#+4
   \   0000002E   0x4770             BX       LR               ;; return
    379          }
    380          
    381          /**
    382            * @brief  Starts the TIM Base generation in DMA mode.
    383            * @param  htim : TIM handle
    384            * @param  pData : The source Buffer address.
    385            * @param  Length : The length of data to be transferred from memory to peripheral.
    386            * @retval HAL status
    387          */

   \                                 In section .text, align 2, keep-with-next
    388          HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
    389          {
   \                     HAL_TIM_Base_Start_DMA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4613             MOV      R3,R2
    390            /* Check the parameters */
    391            assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
    392          
    393            if((htim->State == HAL_TIM_STATE_BUSY))
   \   00000006   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   0000000A   0x2802             CMP      R0,#+2
   \   0000000C   0xD101             BNE.N    ??HAL_TIM_Base_Start_DMA_0
    394            {
    395               return HAL_BUSY;
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xBD10             POP      {R4,PC}
    396            }
    397            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIM_Base_Start_DMA_0: (+1)
   \   00000012   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD108             BNE.N    ??HAL_TIM_Base_Start_DMA_1
    398            {
    399              if((pData == 0 ) && (Length > 0))
   \   0000001A   0x2900             CMP      R1,#+0
   \   0000001C   0xD103             BNE.N    ??HAL_TIM_Base_Start_DMA_2
   \   0000001E   0x0018             MOVS     R0,R3
   \   00000020   0xD001             BEQ.N    ??HAL_TIM_Base_Start_DMA_2
    400              {
    401                return HAL_ERROR;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xBD10             POP      {R4,PC}
    402              }
    403              else
    404              {
    405                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Base_Start_DMA_2: (+1)
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0xF884 0x0039      STRB     R0,[R4, #+57]
    406              }
    407            }
    408            /* Set the DMA Period elapsed callback */
    409            htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   \                     ??HAL_TIM_Base_Start_DMA_1: (+1)
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000030   0x69E2             LDR      R2,[R4, #+28]
   \   00000032   0x6290             STR      R0,[R2, #+40]
    410          
    411            /* Set the DMA error callback */
    412            htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable15
   \   00000038   0x69E2             LDR      R2,[R4, #+28]
   \   0000003A   0x6310             STR      R0,[R2, #+48]
    413          
    414            /* Enable the DMA channel */
    415            HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR, Length);
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0xF100 0x022C      ADD      R2,R0,#+44
   \   00000042   0x69E0             LDR      R0,[R4, #+28]
   \   00000044   0x.... 0x....      BL       HAL_DMA_Start_IT
    416          
    417            /* Enable the TIM Update DMA request */
    418            __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x68C1             LDR      R1,[R0, #+12]
   \   0000004C   0xF441 0x7180      ORR      R1,R1,#0x100
   \   00000050   0x60C1             STR      R1,[R0, #+12]
    419          
    420            /* Enable the Peripheral */
    421            __HAL_TIM_ENABLE(htim);
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x6801             LDR      R1,[R0, #+0]
   \   00000056   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000005A   0x6001             STR      R1,[R0, #+0]
    422          
    423            /* Return function status */
    424            return HAL_OK;
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xBD10             POP      {R4,PC}          ;; return
    425          }
    426          
    427          /**
    428            * @brief  Stops the TIM Base generation in DMA mode.
    429            * @param  htim : TIM handle
    430            * @retval HAL status
    431          */

   \                                 In section .text, align 2, keep-with-next
    432          HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)
    433          {
    434            /* Check the parameters */
    435            assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
    436          
    437            /* Disable the TIM Update DMA request */
    438            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
   \                     HAL_TIM_Base_Stop_DMA: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x68CA             LDR      R2,[R1, #+12]
   \   00000004   0xF422 0x7280      BIC      R2,R2,#0x100
   \   00000008   0x60CA             STR      R2,[R1, #+12]
    439          
    440            /* Disable the Peripheral */
    441            __HAL_TIM_DISABLE(htim);
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0x6A0A             LDR      R2,[R1, #+32]
   \   0000000E   0xF241 0x1311      MOVW     R3,#+4369
   \   00000012   0x421A             TST      R2,R3
   \   00000014   0xD108             BNE.N    ??HAL_TIM_Base_Stop_DMA_0
   \   00000016   0x6A0A             LDR      R2,[R1, #+32]
   \   00000018   0xF240 0x4344      MOVW     R3,#+1092
   \   0000001C   0x421A             TST      R2,R3
   \   0000001E   0xD103             BNE.N    ??HAL_TIM_Base_Stop_DMA_0
   \   00000020   0x680A             LDR      R2,[R1, #+0]
   \   00000022   0x0852             LSRS     R2,R2,#+1
   \   00000024   0x0052             LSLS     R2,R2,#+1
   \   00000026   0x600A             STR      R2,[R1, #+0]
    442          
    443            /* Change the htim state */
    444            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Base_Stop_DMA_0: (+1)
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0xF880 0x1039      STRB     R1,[R0, #+57]
    445          
    446            /* Return function status */
    447            return HAL_OK;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x4770             BX       LR               ;; return
    448          }
    449          
    450          /**
    451            * @}
    452            */
    453          
    454          /** @defgroup TIM_Exported_Functions_Group2 Time Output Compare functions 
    455           *  @brief    Time Output Compare functions 
    456           *
    457          @verbatim 
    458            ==============================================================================
    459                            ##### Time Output Compare functions #####
    460            ==============================================================================
    461            [..]
    462              This section provides functions allowing to:
    463              (+) Initialize and configure the TIM Output Compare.
    464              (+) De-initialize the TIM Output Compare.
    465              (+) Start the Time Output Compare.
    466              (+) Stop the Time Output Compare.
    467              (+) Start the Time Output Compare and enable interrupt.
    468              (+) Stop the Time Output Compare and disable interrupt.
    469              (+) Start the Time Output Compare and enable DMA transfer.
    470              (+) Stop the Time Output Compare and disable DMA transfer.
    471          
    472          @endverbatim
    473            * @{
    474            */
    475          /**
    476            * @brief  Initializes the TIM Output Compare according to the specified
    477            *         parameters in the TIM_HandleTypeDef and create the associated handle.
    478            * @param  htim : TIM Output Compare handle
    479            * @retval HAL status
    480            */

   \                                 In section .text, align 2, keep-with-next
    481          HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef* htim)
    482          {
   \                     HAL_TIM_OC_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    483            /* Check the TIM handle allocation */
    484            if(htim == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_TIM_OC_Init_0
    485            {
    486              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD32             POP      {R1,R4,R5,PC}
    487            }
    488          
    489            /* Check the parameters */
    490            assert_param(IS_TIM_INSTANCE(htim->Instance));
    491            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    492            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    493          
    494            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_OC_Init_0: (+1)
   \   0000000A   0xF104 0x0538      ADD      R5,R4,#+56
   \   0000000E   0xF995 0x0001      LDRSB    R0,[R5, #+1]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD104             BNE.N    ??HAL_TIM_OC_Init_1
    495            {
    496              /* Allocate lock resource and initialize it */
    497              htim->Lock = HAL_UNLOCKED;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x7028             STRB     R0,[R5, #+0]
    498              
    499              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    500              HAL_TIM_OC_MspInit(htim);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       HAL_TIM_OC_MspInit
    501            }
    502          
    503            /* Set the TIM state */
    504            htim->State= HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_OC_Init_1: (+1)
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0x7068             STRB     R0,[R5, #+1]
    505          
    506            /* Init the base time for the Output Compare */
    507            TIM_Base_SetConfig(htim->Instance,  &htim->Init);
   \   00000024   0x1D21             ADDS     R1,R4,#+4
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x.... 0x....      BL       TIM_Base_SetConfig
    508          
    509            /* Initialize the TIM state*/
    510            htim->State= HAL_TIM_STATE_READY;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x7068             STRB     R0,[R5, #+1]
    511          
    512            return HAL_OK;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    513          }
    514          
    515          /**
    516            * @brief  DeInitializes the TIM peripheral 
    517            * @param  htim : TIM Output Compare handle
    518            * @retval HAL status
    519            */

   \                                 In section .text, align 2, keep-with-next
    520          HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
    521          {
   \                     HAL_TIM_OC_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    522            /* Check the parameters */
    523            assert_param(IS_TIM_INSTANCE(htim->Instance));
    524          
    525             htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
    526          
    527            /* Disable the TIM Peripheral Clock */
    528            __HAL_TIM_DISABLE(htim);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6A01             LDR      R1,[R0, #+32]
   \   0000000E   0xF241 0x1211      MOVW     R2,#+4369
   \   00000012   0x4211             TST      R1,R2
   \   00000014   0xD108             BNE.N    ??HAL_TIM_OC_DeInit_0
   \   00000016   0x6A01             LDR      R1,[R0, #+32]
   \   00000018   0xF240 0x4244      MOVW     R2,#+1092
   \   0000001C   0x4211             TST      R1,R2
   \   0000001E   0xD103             BNE.N    ??HAL_TIM_OC_DeInit_0
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x0849             LSRS     R1,R1,#+1
   \   00000024   0x0049             LSLS     R1,R1,#+1
   \   00000026   0x6001             STR      R1,[R0, #+0]
    529          
    530            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
    531            HAL_TIM_OC_MspDeInit(htim);
   \                     ??HAL_TIM_OC_DeInit_0: (+1)
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_TIM_OC_MspDeInit
    532          
    533            /* Change TIM state */
    534            htim->State = HAL_TIM_STATE_RESET;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF884 0x0039      STRB     R0,[R4, #+57]
    535          
    536            /* Release Lock */
    537            __HAL_UNLOCK(htim);
    538          
    539            return HAL_OK;
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    540          }
    541          
    542          /**
    543            * @brief  Initializes the TIM Output Compare MSP.
    544            * @param  htim : TIM handle
    545            * @retval None
    546            */

   \                                 In section .text, align 2
    547          __weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
    548          {
    549            /* Prevent unused argument(s) compilation warning */
    550            UNUSED(htim);
    551            /* NOTE : This function Should not be modified, when the callback is needed,
    552                      the HAL_TIM_OC_MspInit could be implemented in the user file
    553             */
    554          }
   \                     HAL_TIM_OC_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    555          
    556          /**
    557            * @brief  DeInitializes TIM Output Compare MSP.
    558            * @param  htim : TIM handle
    559            * @retval None
    560            */

   \                                 In section .text, align 2
    561          __weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
    562          {
    563            /* Prevent unused argument(s) compilation warning */
    564            UNUSED(htim);
    565            /* NOTE : This function Should not be modified, when the callback is needed,
    566                      the HAL_TIM_OC_MspDeInit could be implemented in the user file
    567             */
    568          }
   \                     HAL_TIM_OC_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    569          
    570          /**
    571            * @brief  Starts the TIM Output Compare signal generation.
    572            * @param  htim : TIM Output Compare handle 
    573            * @param  Channel : TIM Channel to be enabled
    574            *          This parameter can be one of the following values:
    575            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    576            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    577            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    578            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected 
    579            * @retval HAL status
    580          */

   \                                 In section .text, align 2, keep-with-next
    581          HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
    582          {
   \                     HAL_TIM_OC_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    583            /* Check the parameters */
    584            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    585          
    586            /* Enable the Output compare channel */
    587            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_CCxChannelCmd
    588          
    589            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable16  ;; 0x40012c00
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD003             BEQ.N    ??HAL_TIM_OC_Start_0
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x40013400
   \   0000001A   0x4288             CMP      R0,R1
   \   0000001C   0xD101             BNE.N    ??HAL_TIM_OC_Start_1
   \                     ??HAL_TIM_OC_Start_0: (+1)
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0xE000             B.N      ??HAL_TIM_OC_Start_2
   \                     ??HAL_TIM_OC_Start_1: (+1)
   \   00000022   0x2100             MOVS     R1,#+0
   \                     ??HAL_TIM_OC_Start_2: (+1)
   \   00000024   0x2900             CMP      R1,#+0
   \   00000026   0xD003             BEQ.N    ??HAL_TIM_OC_Start_3
    590            {
    591              /* Enable the main output */
    592              __HAL_TIM_MOE_ENABLE(htim);
   \   00000028   0x6C41             LDR      R1,[R0, #+68]
   \   0000002A   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000002E   0x6441             STR      R1,[R0, #+68]
    593            }
    594          
    595            /* Enable the Peripheral */
    596            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_OC_Start_3: (+1)
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x6801             LDR      R1,[R0, #+0]
   \   00000034   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000038   0x6001             STR      R1,[R0, #+0]
    597          
    598            /* Return function status */
    599            return HAL_OK;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
    600          }
    601          
    602          /**
    603            * @brief  Stops the TIM Output Compare signal generation.
    604            * @param  htim : TIM handle
    605            * @param  Channel : TIM Channel to be disabled
    606            *          This parameter can be one of the following values:
    607            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    608            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    609            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    610            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    611            * @retval HAL status
    612          */

   \                                 In section .text, align 2, keep-with-next
    613          HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
    614          {
   \                     HAL_TIM_OC_Stop: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    615            /* Check the parameters */
    616            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    617          
    618            /* Disable the Output compare channel */
    619            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_CCxChannelCmd
    620          
    621            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable16  ;; 0x40012c00
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD003             BEQ.N    ??HAL_TIM_OC_Stop_0
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x40013400
   \   0000001A   0x4288             CMP      R0,R1
   \   0000001C   0xD101             BNE.N    ??HAL_TIM_OC_Stop_1
   \                     ??HAL_TIM_OC_Stop_0: (+1)
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0xE000             B.N      ??HAL_TIM_OC_Stop_2
   \                     ??HAL_TIM_OC_Stop_1: (+1)
   \   00000022   0x2100             MOVS     R1,#+0
   \                     ??HAL_TIM_OC_Stop_2: (+1)
   \   00000024   0xF241 0x1211      MOVW     R2,#+4369
   \   00000028   0x2900             CMP      R1,#+0
   \   0000002A   0xD00B             BEQ.N    ??HAL_TIM_OC_Stop_3
    622            {
    623              /* Disable the Main Ouput */
    624              __HAL_TIM_MOE_DISABLE(htim);
   \   0000002C   0x6A01             LDR      R1,[R0, #+32]
   \   0000002E   0x4211             TST      R1,R2
   \   00000030   0xD108             BNE.N    ??HAL_TIM_OC_Stop_3
   \   00000032   0x6A01             LDR      R1,[R0, #+32]
   \   00000034   0xF240 0x4344      MOVW     R3,#+1092
   \   00000038   0x4219             TST      R1,R3
   \   0000003A   0xD103             BNE.N    ??HAL_TIM_OC_Stop_3
   \   0000003C   0x6C41             LDR      R1,[R0, #+68]
   \   0000003E   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000042   0x6441             STR      R1,[R0, #+68]
    625            }
    626          
    627            /* Disable the Peripheral */
    628            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_OC_Stop_3: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x6A01             LDR      R1,[R0, #+32]
   \   00000048   0x4211             TST      R1,R2
   \   0000004A   0xD108             BNE.N    ??HAL_TIM_OC_Stop_4
   \   0000004C   0x6A01             LDR      R1,[R0, #+32]
   \   0000004E   0xF240 0x4244      MOVW     R2,#+1092
   \   00000052   0x4211             TST      R1,R2
   \   00000054   0xD103             BNE.N    ??HAL_TIM_OC_Stop_4
   \   00000056   0x6801             LDR      R1,[R0, #+0]
   \   00000058   0x0849             LSRS     R1,R1,#+1
   \   0000005A   0x0049             LSLS     R1,R1,#+1
   \   0000005C   0x6001             STR      R1,[R0, #+0]
    629          
    630            /* Return function status */
    631            return HAL_OK;
   \                     ??HAL_TIM_OC_Stop_4: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    632          }
    633          
    634          /**
    635            * @brief  Starts the TIM Output Compare signal generation in interrupt mode.
    636            * @param  htim : TIM OC handle
    637            * @param  Channel : TIM Channel to be enabled
    638            *          This parameter can be one of the following values:
    639            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    640            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    641            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    642            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    643            * @retval HAL status
    644          */

   \                                 In section .text, align 2, keep-with-next
    645          HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    646          {
   \                     HAL_TIM_OC_Start_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    647            /* Check the parameters */
    648            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    649          
    650            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIM_OC_Start_IT_0
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD00A             BEQ.N    ??HAL_TIM_OC_Start_IT_1
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD00E             BEQ.N    ??HAL_TIM_OC_Start_IT_2
   \   00000010   0x280C             CMP      R0,#+12
   \   00000012   0xD012             BEQ.N    ??HAL_TIM_OC_Start_IT_3
   \   00000014   0xE016             B.N      ??HAL_TIM_OC_Start_IT_4
    651            {
    652              case TIM_CHANNEL_1:
    653              {
    654                /* Enable the TIM Capture/Compare 1 interrupt */
    655                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_OC_Start_IT_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x68C2             LDR      R2,[R0, #+12]
   \   0000001A   0xF042 0x0202      ORR      R2,R2,#0x2
   \   0000001E   0x60C2             STR      R2,[R0, #+12]
    656              }
    657              break;
   \   00000020   0xE010             B.N      ??HAL_TIM_OC_Start_IT_4
    658          
    659              case TIM_CHANNEL_2:
    660              {
    661                /* Enable the TIM Capture/Compare 2 interrupt */
    662                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_OC_Start_IT_1: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C2             LDR      R2,[R0, #+12]
   \   00000026   0xF042 0x0204      ORR      R2,R2,#0x4
   \   0000002A   0x60C2             STR      R2,[R0, #+12]
    663              }
    664              break;
   \   0000002C   0xE00A             B.N      ??HAL_TIM_OC_Start_IT_4
    665          
    666              case TIM_CHANNEL_3:
    667              {
    668                /* Enable the TIM Capture/Compare 3 interrupt */
    669                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_OC_Start_IT_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68C2             LDR      R2,[R0, #+12]
   \   00000032   0xF042 0x0208      ORR      R2,R2,#0x8
   \   00000036   0x60C2             STR      R2,[R0, #+12]
    670              }
    671              break;
   \   00000038   0xE004             B.N      ??HAL_TIM_OC_Start_IT_4
    672          
    673              case TIM_CHANNEL_4:
    674              {
    675                /* Enable the TIM Capture/Compare 4 interrupt */
    676                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_OC_Start_IT_3: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x68C2             LDR      R2,[R0, #+12]
   \   0000003E   0xF042 0x0210      ORR      R2,R2,#0x10
   \   00000042   0x60C2             STR      R2,[R0, #+12]
    677              }
    678              break;
    679          
    680              default:
    681              break;
    682            }
    683          
    684            /* Enable the Output compare channel */
    685            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_OC_Start_IT_4: (+1)
   \   00000044   0x2201             MOVS     R2,#+1
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       TIM_CCxChannelCmd
    686          
    687            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable16  ;; 0x40012c00
   \   00000052   0x4288             CMP      R0,R1
   \   00000054   0xD003             BEQ.N    ??HAL_TIM_OC_Start_IT_5
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x40013400
   \   0000005A   0x4288             CMP      R0,R1
   \   0000005C   0xD101             BNE.N    ??HAL_TIM_OC_Start_IT_6
   \                     ??HAL_TIM_OC_Start_IT_5: (+1)
   \   0000005E   0x2101             MOVS     R1,#+1
   \   00000060   0xE000             B.N      ??HAL_TIM_OC_Start_IT_7
   \                     ??HAL_TIM_OC_Start_IT_6: (+1)
   \   00000062   0x2100             MOVS     R1,#+0
   \                     ??HAL_TIM_OC_Start_IT_7: (+1)
   \   00000064   0x2900             CMP      R1,#+0
   \   00000066   0xD003             BEQ.N    ??HAL_TIM_OC_Start_IT_8
    688            {
    689              /* Enable the main output */
    690              __HAL_TIM_MOE_ENABLE(htim);
   \   00000068   0x6C41             LDR      R1,[R0, #+68]
   \   0000006A   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000006E   0x6441             STR      R1,[R0, #+68]
    691            }
    692          
    693            /* Enable the Peripheral */
    694            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_OC_Start_IT_8: (+1)
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x6801             LDR      R1,[R0, #+0]
   \   00000074   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000078   0x6001             STR      R1,[R0, #+0]
    695          
    696            /* Return function status */
    697            return HAL_OK;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xBD10             POP      {R4,PC}          ;; return
    698          }
    699          
    700          /**
    701            * @brief  Stops the TIM Output Compare signal generation in interrupt mode.
    702            * @param  htim : TIM Output Compare handle
    703            * @param  Channel : TIM Channel to be disabled
    704            *          This parameter can be one of the following values:
    705            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    706            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    707            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    708            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    709            * @retval HAL status
    710          */

   \                                 In section .text, align 2, keep-with-next
    711          HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    712          {
   \                     HAL_TIM_OC_Stop_IT: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    713            /* Check the parameters */
    714            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    715          
    716            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIM_OC_Stop_IT_0
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD00A             BEQ.N    ??HAL_TIM_OC_Stop_IT_1
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD00E             BEQ.N    ??HAL_TIM_OC_Stop_IT_2
   \   00000010   0x280C             CMP      R0,#+12
   \   00000012   0xD012             BEQ.N    ??HAL_TIM_OC_Stop_IT_3
   \   00000014   0xE016             B.N      ??HAL_TIM_OC_Stop_IT_4
    717            {
    718              case TIM_CHANNEL_1:
    719              {
    720                /* Disable the TIM Capture/Compare 1 interrupt */
    721                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_OC_Stop_IT_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x68C2             LDR      R2,[R0, #+12]
   \   0000001A   0xF022 0x0202      BIC      R2,R2,#0x2
   \   0000001E   0x60C2             STR      R2,[R0, #+12]
    722              }
    723              break;
   \   00000020   0xE010             B.N      ??HAL_TIM_OC_Stop_IT_4
    724          
    725              case TIM_CHANNEL_2:
    726              {
    727                /* Disable the TIM Capture/Compare 2 interrupt */
    728                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_OC_Stop_IT_1: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C2             LDR      R2,[R0, #+12]
   \   00000026   0xF022 0x0204      BIC      R2,R2,#0x4
   \   0000002A   0x60C2             STR      R2,[R0, #+12]
    729              }
    730              break;
   \   0000002C   0xE00A             B.N      ??HAL_TIM_OC_Stop_IT_4
    731          
    732              case TIM_CHANNEL_3:
    733              {
    734                /* Disable the TIM Capture/Compare 3 interrupt */
    735                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_OC_Stop_IT_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68C2             LDR      R2,[R0, #+12]
   \   00000032   0xF022 0x0208      BIC      R2,R2,#0x8
   \   00000036   0x60C2             STR      R2,[R0, #+12]
    736              }
    737              break;
   \   00000038   0xE004             B.N      ??HAL_TIM_OC_Stop_IT_4
    738          
    739              case TIM_CHANNEL_4:
    740              {
    741                /* Disable the TIM Capture/Compare 4 interrupt */
    742                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_OC_Stop_IT_3: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x68C2             LDR      R2,[R0, #+12]
   \   0000003E   0xF022 0x0210      BIC      R2,R2,#0x10
   \   00000042   0x60C2             STR      R2,[R0, #+12]
    743              }
    744              break;
    745          
    746              default:
    747              break;
    748            }
    749          
    750            /* Disable the Output compare channel */
    751            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_OC_Stop_IT_4: (+1)
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       TIM_CCxChannelCmd
    752          
    753            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable16  ;; 0x40012c00
   \   00000052   0x4288             CMP      R0,R1
   \   00000054   0xD003             BEQ.N    ??HAL_TIM_OC_Stop_IT_5
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x40013400
   \   0000005A   0x4288             CMP      R0,R1
   \   0000005C   0xD101             BNE.N    ??HAL_TIM_OC_Stop_IT_6
   \                     ??HAL_TIM_OC_Stop_IT_5: (+1)
   \   0000005E   0x2101             MOVS     R1,#+1
   \   00000060   0xE000             B.N      ??HAL_TIM_OC_Stop_IT_7
   \                     ??HAL_TIM_OC_Stop_IT_6: (+1)
   \   00000062   0x2100             MOVS     R1,#+0
   \                     ??HAL_TIM_OC_Stop_IT_7: (+1)
   \   00000064   0xF241 0x1211      MOVW     R2,#+4369
   \   00000068   0x2900             CMP      R1,#+0
   \   0000006A   0xD00B             BEQ.N    ??HAL_TIM_OC_Stop_IT_8
    754            {
    755              /* Disable the Main Ouput */
    756              __HAL_TIM_MOE_DISABLE(htim);
   \   0000006C   0x6A01             LDR      R1,[R0, #+32]
   \   0000006E   0x4211             TST      R1,R2
   \   00000070   0xD108             BNE.N    ??HAL_TIM_OC_Stop_IT_8
   \   00000072   0x6A01             LDR      R1,[R0, #+32]
   \   00000074   0xF240 0x4344      MOVW     R3,#+1092
   \   00000078   0x4219             TST      R1,R3
   \   0000007A   0xD103             BNE.N    ??HAL_TIM_OC_Stop_IT_8
   \   0000007C   0x6C41             LDR      R1,[R0, #+68]
   \   0000007E   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000082   0x6441             STR      R1,[R0, #+68]
    757            }
    758          
    759            /* Disable the Peripheral */
    760            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_OC_Stop_IT_8: (+1)
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x6A01             LDR      R1,[R0, #+32]
   \   00000088   0x4211             TST      R1,R2
   \   0000008A   0xD108             BNE.N    ??HAL_TIM_OC_Stop_IT_9
   \   0000008C   0x6A01             LDR      R1,[R0, #+32]
   \   0000008E   0xF240 0x4244      MOVW     R2,#+1092
   \   00000092   0x4211             TST      R1,R2
   \   00000094   0xD103             BNE.N    ??HAL_TIM_OC_Stop_IT_9
   \   00000096   0x6801             LDR      R1,[R0, #+0]
   \   00000098   0x0849             LSRS     R1,R1,#+1
   \   0000009A   0x0049             LSLS     R1,R1,#+1
   \   0000009C   0x6001             STR      R1,[R0, #+0]
    761          
    762            /* Return function status */
    763            return HAL_OK;
   \                     ??HAL_TIM_OC_Stop_IT_9: (+1)
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    764          }
    765          
    766          /**
    767            * @brief  Starts the TIM Output Compare signal generation in DMA mode.
    768            * @param  htim : TIM Output Compare handle
    769            * @param  Channel : TIM Channel to be enabled
    770            *          This parameter can be one of the following values:
    771            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    772            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    773            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    774            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    775            * @param  pData : The source Buffer address.
    776            * @param  Length : The length of data to be transferred from memory to TIM peripheral
    777            * @retval HAL status
    778          */

   \                                 In section .text, align 2, keep-with-next
    779          HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
    780          {
   \                     HAL_TIM_OC_Start_DMA: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4611             MOV      R1,R2
    781            /* Check the parameters */
    782            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    783          
    784            if((htim->State == HAL_TIM_STATE_BUSY))
   \   00000008   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD101             BNE.N    ??HAL_TIM_OC_Start_DMA_0
    785            {
    786               return HAL_BUSY;
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xBD32             POP      {R1,R4,R5,PC}
    787            }
    788            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIM_OC_Start_DMA_0: (+1)
   \   00000014   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD108             BNE.N    ??HAL_TIM_OC_Start_DMA_1
    789            {
    790              if(((uint32_t)pData == 0 ) && (Length > 0))
   \   0000001C   0x2900             CMP      R1,#+0
   \   0000001E   0xD103             BNE.N    ??HAL_TIM_OC_Start_DMA_2
   \   00000020   0x0018             MOVS     R0,R3
   \   00000022   0xD001             BEQ.N    ??HAL_TIM_OC_Start_DMA_2
    791              {
    792                return HAL_ERROR;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xBD32             POP      {R1,R4,R5,PC}
    793              }
    794              else
    795              {
    796                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_OC_Start_DMA_2: (+1)
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xF884 0x0039      STRB     R0,[R4, #+57]
    797              }
    798            }
    799            switch (Channel)
   \                     ??HAL_TIM_OC_Start_DMA_1: (+1)
   \   0000002E   0x0028             MOVS     R0,R5
   \   00000030   0xD006             BEQ.N    ??HAL_TIM_OC_Start_DMA_3
   \   00000032   0x2804             CMP      R0,#+4
   \   00000034   0xD018             BEQ.N    ??HAL_TIM_OC_Start_DMA_4
   \   00000036   0x2808             CMP      R0,#+8
   \   00000038   0xD02A             BEQ.N    ??HAL_TIM_OC_Start_DMA_5
   \   0000003A   0x280C             CMP      R0,#+12
   \   0000003C   0xD03C             BEQ.N    ??HAL_TIM_OC_Start_DMA_6
   \   0000003E   0xE04E             B.N      ??HAL_TIM_OC_Start_DMA_7
    800            {
    801              case TIM_CHANNEL_1:
    802              {
    803                /* Set the DMA Period elapsed callback */
    804                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_3: (+1)
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000044   0x6A22             LDR      R2,[R4, #+32]
   \   00000046   0x6290             STR      R0,[R2, #+40]
    805          
    806                /* Set the DMA error callback */
    807                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable15
   \   0000004C   0x6A22             LDR      R2,[R4, #+32]
   \   0000004E   0x6310             STR      R0,[R2, #+48]
    808          
    809                /* Enable the DMA channel */
    810                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0xF100 0x0234      ADD      R2,R0,#+52
   \   00000056   0x6A20             LDR      R0,[R4, #+32]
   \   00000058   0x.... 0x....      BL       HAL_DMA_Start_IT
    811          
    812                /* Enable the TIM Capture/Compare 1 DMA request */
    813                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x68C1             LDR      R1,[R0, #+12]
   \   00000060   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000064   0x60C1             STR      R1,[R0, #+12]
    814              }
    815              break;
   \   00000066   0xE03A             B.N      ??HAL_TIM_OC_Start_DMA_7
    816          
    817              case TIM_CHANNEL_2:
    818              {
    819                /* Set the DMA Period elapsed callback */
    820                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_4: (+1)
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable19
   \   0000006C   0x6A62             LDR      R2,[R4, #+36]
   \   0000006E   0x6290             STR      R0,[R2, #+40]
    821          
    822                /* Set the DMA error callback */
    823                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable15
   \   00000074   0x6A62             LDR      R2,[R4, #+36]
   \   00000076   0x6310             STR      R0,[R2, #+48]
    824          
    825                /* Enable the DMA channel */
    826                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0xF100 0x0238      ADD      R2,R0,#+56
   \   0000007E   0x6A60             LDR      R0,[R4, #+36]
   \   00000080   0x.... 0x....      BL       HAL_DMA_Start_IT
    827          
    828                /* Enable the TIM Capture/Compare 2 DMA request */
    829                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x68C1             LDR      R1,[R0, #+12]
   \   00000088   0xF441 0x6180      ORR      R1,R1,#0x400
   \   0000008C   0x60C1             STR      R1,[R0, #+12]
    830              }
    831              break;
   \   0000008E   0xE026             B.N      ??HAL_TIM_OC_Start_DMA_7
    832          
    833              case TIM_CHANNEL_3:
    834              {
    835                /* Set the DMA Period elapsed callback */
    836                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_5: (+1)
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000094   0x6AA2             LDR      R2,[R4, #+40]
   \   00000096   0x6290             STR      R0,[R2, #+40]
    837          
    838                /* Set the DMA error callback */
    839                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable15
   \   0000009C   0x6AA2             LDR      R2,[R4, #+40]
   \   0000009E   0x6310             STR      R0,[R2, #+48]
    840          
    841                /* Enable the DMA channel */
    842                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0xF100 0x023C      ADD      R2,R0,#+60
   \   000000A6   0x6AA0             LDR      R0,[R4, #+40]
   \   000000A8   0x.... 0x....      BL       HAL_DMA_Start_IT
    843          
    844                /* Enable the TIM Capture/Compare 3 DMA request */
    845                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \   000000AC   0x6820             LDR      R0,[R4, #+0]
   \   000000AE   0x68C1             LDR      R1,[R0, #+12]
   \   000000B0   0xF441 0x6100      ORR      R1,R1,#0x800
   \   000000B4   0x60C1             STR      R1,[R0, #+12]
    846              }
    847              break;
   \   000000B6   0xE012             B.N      ??HAL_TIM_OC_Start_DMA_7
    848          
    849              case TIM_CHANNEL_4:
    850              {
    851               /* Set the DMA Period elapsed callback */
    852                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_6: (+1)
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000000BC   0x6AE2             LDR      R2,[R4, #+44]
   \   000000BE   0x6290             STR      R0,[R2, #+40]
    853          
    854                /* Set the DMA error callback */
    855                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \   000000C0   0x.... 0x....      LDR.W    R0,??DataTable15
   \   000000C4   0x6AE2             LDR      R2,[R4, #+44]
   \   000000C6   0x6310             STR      R0,[R2, #+48]
    856          
    857                /* Enable the DMA channel */
    858                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
   \   000000C8   0x6820             LDR      R0,[R4, #+0]
   \   000000CA   0xF100 0x0240      ADD      R2,R0,#+64
   \   000000CE   0x6AE0             LDR      R0,[R4, #+44]
   \   000000D0   0x.... 0x....      BL       HAL_DMA_Start_IT
    859          
    860                /* Enable the TIM Capture/Compare 4 DMA request */
    861                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \   000000D4   0x6820             LDR      R0,[R4, #+0]
   \   000000D6   0x68C1             LDR      R1,[R0, #+12]
   \   000000D8   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   000000DC   0x60C1             STR      R1,[R0, #+12]
    862              }
    863              break;
    864          
    865              default:
    866              break;
    867            }
    868          
    869            /* Enable the Output compare channel */
    870            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_OC_Start_DMA_7: (+1)
   \   000000DE   0x2201             MOVS     R2,#+1
   \   000000E0   0x4629             MOV      R1,R5
   \   000000E2   0x6820             LDR      R0,[R4, #+0]
   \   000000E4   0x.... 0x....      BL       TIM_CCxChannelCmd
    871          
    872            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \   000000E8   0x6820             LDR      R0,[R4, #+0]
   \   000000EA   0x.... 0x....      LDR.W    R1,??DataTable16  ;; 0x40012c00
   \   000000EE   0x4288             CMP      R0,R1
   \   000000F0   0xD003             BEQ.N    ??HAL_TIM_OC_Start_DMA_8
   \   000000F2   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x40013400
   \   000000F6   0x4288             CMP      R0,R1
   \   000000F8   0xD101             BNE.N    ??HAL_TIM_OC_Start_DMA_9
   \                     ??HAL_TIM_OC_Start_DMA_8: (+1)
   \   000000FA   0x2101             MOVS     R1,#+1
   \   000000FC   0xE000             B.N      ??HAL_TIM_OC_Start_DMA_10
   \                     ??HAL_TIM_OC_Start_DMA_9: (+1)
   \   000000FE   0x2100             MOVS     R1,#+0
   \                     ??HAL_TIM_OC_Start_DMA_10: (+1)
   \   00000100   0x2900             CMP      R1,#+0
   \   00000102   0xD003             BEQ.N    ??HAL_TIM_OC_Start_DMA_11
    873            {
    874              /* Enable the main output */
    875              __HAL_TIM_MOE_ENABLE(htim);
   \   00000104   0x6C41             LDR      R1,[R0, #+68]
   \   00000106   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000010A   0x6441             STR      R1,[R0, #+68]
    876            }
    877          
    878            /* Enable the Peripheral */
    879            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_OC_Start_DMA_11: (+1)
   \   0000010C   0x6820             LDR      R0,[R4, #+0]
   \   0000010E   0x6801             LDR      R1,[R0, #+0]
   \   00000110   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000114   0x6001             STR      R1,[R0, #+0]
    880          
    881            /* Return function status */
    882            return HAL_OK;
   \   00000116   0x2000             MOVS     R0,#+0
   \   00000118   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    883          }
    884          
    885          /**
    886            * @brief  Stops the TIM Output Compare signal generation in DMA mode.
    887            * @param  htim : TIM Output Compare handle
    888            * @param  Channel : TIM Channel to be disabled
    889            *          This parameter can be one of the following values:
    890            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    891            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    892            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    893            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    894            * @retval HAL status
    895          */

   \                                 In section .text, align 2, keep-with-next
    896          HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
    897          {
   \                     HAL_TIM_OC_Stop_DMA: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    898            /* Check the parameters */
    899            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    900          
    901            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIM_OC_Stop_DMA_0
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD00A             BEQ.N    ??HAL_TIM_OC_Stop_DMA_1
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD00E             BEQ.N    ??HAL_TIM_OC_Stop_DMA_2
   \   00000010   0x280C             CMP      R0,#+12
   \   00000012   0xD012             BEQ.N    ??HAL_TIM_OC_Stop_DMA_3
   \   00000014   0xE016             B.N      ??HAL_TIM_OC_Stop_DMA_4
    902            {
    903              case TIM_CHANNEL_1:
    904              {
    905                /* Disable the TIM Capture/Compare 1 DMA request */
    906                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_OC_Stop_DMA_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x68C2             LDR      R2,[R0, #+12]
   \   0000001A   0xF422 0x7200      BIC      R2,R2,#0x200
   \   0000001E   0x60C2             STR      R2,[R0, #+12]
    907              }
    908              break;
   \   00000020   0xE010             B.N      ??HAL_TIM_OC_Stop_DMA_4
    909          
    910              case TIM_CHANNEL_2:
    911              {
    912                /* Disable the TIM Capture/Compare 2 DMA request */
    913                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_OC_Stop_DMA_1: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C2             LDR      R2,[R0, #+12]
   \   00000026   0xF422 0x6280      BIC      R2,R2,#0x400
   \   0000002A   0x60C2             STR      R2,[R0, #+12]
    914              }
    915              break;
   \   0000002C   0xE00A             B.N      ??HAL_TIM_OC_Stop_DMA_4
    916          
    917              case TIM_CHANNEL_3:
    918              {
    919                /* Disable the TIM Capture/Compare 3 DMA request */
    920                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_OC_Stop_DMA_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68C2             LDR      R2,[R0, #+12]
   \   00000032   0xF422 0x6200      BIC      R2,R2,#0x800
   \   00000036   0x60C2             STR      R2,[R0, #+12]
    921              }
    922              break;
   \   00000038   0xE004             B.N      ??HAL_TIM_OC_Stop_DMA_4
    923          
    924              case TIM_CHANNEL_4:
    925              {
    926                /* Disable the TIM Capture/Compare 4 interrupt */
    927                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_OC_Stop_DMA_3: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x68C2             LDR      R2,[R0, #+12]
   \   0000003E   0xF422 0x5280      BIC      R2,R2,#0x1000
   \   00000042   0x60C2             STR      R2,[R0, #+12]
    928              }
    929              break;
    930          
    931              default:
    932              break;
    933            }
    934          
    935            /* Disable the Output compare channel */
    936            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_OC_Stop_DMA_4: (+1)
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       TIM_CCxChannelCmd
    937          
    938            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable16  ;; 0x40012c00
   \   00000052   0x4288             CMP      R0,R1
   \   00000054   0xD003             BEQ.N    ??HAL_TIM_OC_Stop_DMA_5
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x40013400
   \   0000005A   0x4288             CMP      R0,R1
   \   0000005C   0xD101             BNE.N    ??HAL_TIM_OC_Stop_DMA_6
   \                     ??HAL_TIM_OC_Stop_DMA_5: (+1)
   \   0000005E   0x2101             MOVS     R1,#+1
   \   00000060   0xE000             B.N      ??HAL_TIM_OC_Stop_DMA_7
   \                     ??HAL_TIM_OC_Stop_DMA_6: (+1)
   \   00000062   0x2100             MOVS     R1,#+0
   \                     ??HAL_TIM_OC_Stop_DMA_7: (+1)
   \   00000064   0xF241 0x1211      MOVW     R2,#+4369
   \   00000068   0x2900             CMP      R1,#+0
   \   0000006A   0xD00B             BEQ.N    ??HAL_TIM_OC_Stop_DMA_8
    939            {
    940              /* Disable the Main Ouput */
    941              __HAL_TIM_MOE_DISABLE(htim);
   \   0000006C   0x6A01             LDR      R1,[R0, #+32]
   \   0000006E   0x4211             TST      R1,R2
   \   00000070   0xD108             BNE.N    ??HAL_TIM_OC_Stop_DMA_8
   \   00000072   0x6A01             LDR      R1,[R0, #+32]
   \   00000074   0xF240 0x4344      MOVW     R3,#+1092
   \   00000078   0x4219             TST      R1,R3
   \   0000007A   0xD103             BNE.N    ??HAL_TIM_OC_Stop_DMA_8
   \   0000007C   0x6C41             LDR      R1,[R0, #+68]
   \   0000007E   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000082   0x6441             STR      R1,[R0, #+68]
    942            }
    943          
    944            /* Disable the Peripheral */
    945            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_OC_Stop_DMA_8: (+1)
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x6A01             LDR      R1,[R0, #+32]
   \   00000088   0x4211             TST      R1,R2
   \   0000008A   0xD108             BNE.N    ??HAL_TIM_OC_Stop_DMA_9
   \   0000008C   0x6A01             LDR      R1,[R0, #+32]
   \   0000008E   0xF240 0x4244      MOVW     R2,#+1092
   \   00000092   0x4211             TST      R1,R2
   \   00000094   0xD103             BNE.N    ??HAL_TIM_OC_Stop_DMA_9
   \   00000096   0x6801             LDR      R1,[R0, #+0]
   \   00000098   0x0849             LSRS     R1,R1,#+1
   \   0000009A   0x0049             LSLS     R1,R1,#+1
   \   0000009C   0x6001             STR      R1,[R0, #+0]
    946          
    947            /* Change the htim state */
    948            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_OC_Stop_DMA_9: (+1)
   \   0000009E   0x2001             MOVS     R0,#+1
   \   000000A0   0xF884 0x0039      STRB     R0,[R4, #+57]
    949          
    950            /* Return function status */
    951            return HAL_OK;
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    952          }
    953          
    954          /**
    955            * @}
    956            */
    957          
    958          /** @defgroup TIM_Exported_Functions_Group3 Time PWM functions 
    959           *  @brief    Time PWM functions 
    960           *
    961          @verbatim 
    962            ==============================================================================
    963                                    ##### Time PWM functions #####
    964            ==============================================================================
    965            [..]
    966              This section provides functions allowing to:
    967              (+) Initialize and configure the TIM PWM.
    968              (+) De-initialize the TIM PWM.
    969              (+) Start the Time PWM.
    970              (+) Stop the Time PWM.
    971              (+) Start the Time PWM and enable interrupt.
    972              (+) Stop the Time PWM and disable interrupt.
    973              (+) Start the Time PWM and enable DMA transfer.
    974              (+) Stop the Time PWM and disable DMA transfer.
    975          
    976          @endverbatim
    977            * @{
    978            */
    979          /**
    980            * @brief  Initializes the TIM PWM Time Base according to the specified
    981            *         parameters in the TIM_HandleTypeDef and create the associated handle.
    982            * @param  htim : TIM handle
    983            * @retval HAL status
    984            */

   \                                 In section .text, align 2, keep-with-next
    985          HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
    986          {
   \                     HAL_TIM_PWM_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    987            /* Check the TIM handle allocation */
    988            if(htim == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_TIM_PWM_Init_0
    989            {
    990              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD32             POP      {R1,R4,R5,PC}
    991            }
    992          
    993            /* Check the parameters */
    994            assert_param(IS_TIM_INSTANCE(htim->Instance));
    995            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    996            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    997          
    998            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_PWM_Init_0: (+1)
   \   0000000A   0xF104 0x0538      ADD      R5,R4,#+56
   \   0000000E   0xF995 0x0001      LDRSB    R0,[R5, #+1]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD104             BNE.N    ??HAL_TIM_PWM_Init_1
    999            {
   1000              /* Allocate lock resource and initialize it */
   1001              htim->Lock = HAL_UNLOCKED;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x7028             STRB     R0,[R5, #+0]
   1002              
   1003              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1004              HAL_TIM_PWM_MspInit(htim);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       HAL_TIM_PWM_MspInit
   1005            }
   1006          
   1007            /* Set the TIM state */
   1008            htim->State= HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_PWM_Init_1: (+1)
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0x7068             STRB     R0,[R5, #+1]
   1009          
   1010            /* Init the base time for the PWM */
   1011            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \   00000024   0x1D21             ADDS     R1,R4,#+4
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x.... 0x....      BL       TIM_Base_SetConfig
   1012          
   1013            /* Initialize the TIM state*/
   1014            htim->State= HAL_TIM_STATE_READY;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x7068             STRB     R0,[R5, #+1]
   1015          
   1016            return HAL_OK;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1017          }
   1018          
   1019          /**
   1020            * @brief  DeInitializes the TIM peripheral 
   1021            * @param  htim : TIM handle
   1022            * @retval HAL status
   1023            */

   \                                 In section .text, align 2, keep-with-next
   1024          HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
   1025          {
   \                     HAL_TIM_PWM_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1026            /* Check the parameters */
   1027            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1028          
   1029            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
   1030          
   1031            /* Disable the TIM Peripheral Clock */
   1032            __HAL_TIM_DISABLE(htim);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6A01             LDR      R1,[R0, #+32]
   \   0000000E   0xF241 0x1211      MOVW     R2,#+4369
   \   00000012   0x4211             TST      R1,R2
   \   00000014   0xD108             BNE.N    ??HAL_TIM_PWM_DeInit_0
   \   00000016   0x6A01             LDR      R1,[R0, #+32]
   \   00000018   0xF240 0x4244      MOVW     R2,#+1092
   \   0000001C   0x4211             TST      R1,R2
   \   0000001E   0xD103             BNE.N    ??HAL_TIM_PWM_DeInit_0
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x0849             LSRS     R1,R1,#+1
   \   00000024   0x0049             LSLS     R1,R1,#+1
   \   00000026   0x6001             STR      R1,[R0, #+0]
   1033          
   1034            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
   1035            HAL_TIM_PWM_MspDeInit(htim);
   \                     ??HAL_TIM_PWM_DeInit_0: (+1)
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_TIM_PWM_MspDeInit
   1036          
   1037            /* Change TIM state */
   1038            htim->State = HAL_TIM_STATE_RESET;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF884 0x0039      STRB     R0,[R4, #+57]
   1039          
   1040            /* Release Lock */
   1041            __HAL_UNLOCK(htim);
   1042          
   1043            return HAL_OK;
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
   1044          }
   1045          
   1046          /**
   1047            * @brief  Initializes the TIM PWM MSP.
   1048            * @param  htim : TIM handle
   1049            * @retval None
   1050            */

   \                                 In section .text, align 2
   1051          __weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
   1052          {
   1053            /* Prevent unused argument(s) compilation warning */
   1054            UNUSED(htim);
   1055            /* NOTE : This function Should not be modified, when the callback is needed,
   1056                      the HAL_TIM_PWM_MspInit could be implemented in the user file
   1057             */
   1058          }
   \                     HAL_TIM_PWM_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1059          
   1060          /**
   1061            * @brief  DeInitializes TIM PWM MSP.
   1062            * @param  htim : TIM handle
   1063            * @retval None
   1064            */

   \                                 In section .text, align 2
   1065          __weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
   1066          {
   1067            /* Prevent unused argument(s) compilation warning */
   1068            UNUSED(htim);
   1069            /* NOTE : This function Should not be modified, when the callback is needed,
   1070                      the HAL_TIM_PWM_MspDeInit could be implemented in the user file
   1071             */
   1072          }
   \                     HAL_TIM_PWM_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1073          
   1074          /**
   1075            * @brief  Starts the PWM signal generation.
   1076            * @param  htim : TIM handle
   1077            * @param  Channel : TIM Channels to be enabled
   1078            *          This parameter can be one of the following values:
   1079            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1080            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1081            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1082            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1083            * @retval HAL status
   1084          */

   \                                 In section .text, align 2, keep-with-next
   1085          HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   1086          {
   \                     HAL_TIM_PWM_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1087            /* Check the parameters */
   1088            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1089          
   1090            /* Enable the Capture compare channel */
   1091            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_CCxChannelCmd
   1092          
   1093            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable16  ;; 0x40012c00
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD003             BEQ.N    ??HAL_TIM_PWM_Start_0
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x40013400
   \   0000001A   0x4288             CMP      R0,R1
   \   0000001C   0xD101             BNE.N    ??HAL_TIM_PWM_Start_1
   \                     ??HAL_TIM_PWM_Start_0: (+1)
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0xE000             B.N      ??HAL_TIM_PWM_Start_2
   \                     ??HAL_TIM_PWM_Start_1: (+1)
   \   00000022   0x2100             MOVS     R1,#+0
   \                     ??HAL_TIM_PWM_Start_2: (+1)
   \   00000024   0x2900             CMP      R1,#+0
   \   00000026   0xD003             BEQ.N    ??HAL_TIM_PWM_Start_3
   1094            {
   1095              /* Enable the main output */
   1096              __HAL_TIM_MOE_ENABLE(htim);
   \   00000028   0x6C41             LDR      R1,[R0, #+68]
   \   0000002A   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000002E   0x6441             STR      R1,[R0, #+68]
   1097            }
   1098          
   1099            /* Enable the Peripheral */
   1100            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_PWM_Start_3: (+1)
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x6801             LDR      R1,[R0, #+0]
   \   00000034   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000038   0x6001             STR      R1,[R0, #+0]
   1101          
   1102            /* Return function status */
   1103            return HAL_OK;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
   1104          }
   1105          
   1106          /**
   1107            * @brief  Stops the PWM signal generation.
   1108            * @param  htim : TIM handle
   1109            * @param  Channel : TIM Channels to be disabled
   1110            *          This parameter can be one of the following values:
   1111            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1112            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1113            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1114            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1115            * @retval HAL status
   1116          */

   \                                 In section .text, align 2, keep-with-next
   1117          HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1118          {
   \                     HAL_TIM_PWM_Stop: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1119            /* Check the parameters */
   1120            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1121          
   1122            /* Disable the Capture compare channel */
   1123            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_CCxChannelCmd
   1124          
   1125            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable16  ;; 0x40012c00
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD003             BEQ.N    ??HAL_TIM_PWM_Stop_0
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x40013400
   \   0000001A   0x4288             CMP      R0,R1
   \   0000001C   0xD101             BNE.N    ??HAL_TIM_PWM_Stop_1
   \                     ??HAL_TIM_PWM_Stop_0: (+1)
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0xE000             B.N      ??HAL_TIM_PWM_Stop_2
   \                     ??HAL_TIM_PWM_Stop_1: (+1)
   \   00000022   0x2100             MOVS     R1,#+0
   \                     ??HAL_TIM_PWM_Stop_2: (+1)
   \   00000024   0xF241 0x1211      MOVW     R2,#+4369
   \   00000028   0x2900             CMP      R1,#+0
   \   0000002A   0xD00B             BEQ.N    ??HAL_TIM_PWM_Stop_3
   1126            {
   1127              /* Disable the Main Ouput */
   1128              __HAL_TIM_MOE_DISABLE(htim);
   \   0000002C   0x6A01             LDR      R1,[R0, #+32]
   \   0000002E   0x4211             TST      R1,R2
   \   00000030   0xD108             BNE.N    ??HAL_TIM_PWM_Stop_3
   \   00000032   0x6A01             LDR      R1,[R0, #+32]
   \   00000034   0xF240 0x4344      MOVW     R3,#+1092
   \   00000038   0x4219             TST      R1,R3
   \   0000003A   0xD103             BNE.N    ??HAL_TIM_PWM_Stop_3
   \   0000003C   0x6C41             LDR      R1,[R0, #+68]
   \   0000003E   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000042   0x6441             STR      R1,[R0, #+68]
   1129            }
   1130          
   1131            /* Disable the Peripheral */
   1132            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_PWM_Stop_3: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x6A01             LDR      R1,[R0, #+32]
   \   00000048   0x4211             TST      R1,R2
   \   0000004A   0xD108             BNE.N    ??HAL_TIM_PWM_Stop_4
   \   0000004C   0x6A01             LDR      R1,[R0, #+32]
   \   0000004E   0xF240 0x4244      MOVW     R2,#+1092
   \   00000052   0x4211             TST      R1,R2
   \   00000054   0xD103             BNE.N    ??HAL_TIM_PWM_Stop_4
   \   00000056   0x6801             LDR      R1,[R0, #+0]
   \   00000058   0x0849             LSRS     R1,R1,#+1
   \   0000005A   0x0049             LSLS     R1,R1,#+1
   \   0000005C   0x6001             STR      R1,[R0, #+0]
   1133          
   1134            /* Change the htim state */
   1135            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_PWM_Stop_4: (+1)
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0xF884 0x0039      STRB     R0,[R4, #+57]
   1136          
   1137            /* Return function status */
   1138            return HAL_OK;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   1139          }
   1140          
   1141          /**
   1142            * @brief  Starts the PWM signal generation in interrupt mode.
   1143            * @param  htim : TIM handle
   1144            * @param  Channel : TIM Channel to be disabled
   1145            *          This parameter can be one of the following values:
   1146            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1147            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1148            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1149            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1150            * @retval HAL status
   1151          */

   \                                 In section .text, align 2, keep-with-next
   1152          HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1153          {
   \                     HAL_TIM_PWM_Start_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1154            /* Check the parameters */
   1155            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1156          
   1157            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIM_PWM_Start_IT_0
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD00A             BEQ.N    ??HAL_TIM_PWM_Start_IT_1
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD00E             BEQ.N    ??HAL_TIM_PWM_Start_IT_2
   \   00000010   0x280C             CMP      R0,#+12
   \   00000012   0xD012             BEQ.N    ??HAL_TIM_PWM_Start_IT_3
   \   00000014   0xE016             B.N      ??HAL_TIM_PWM_Start_IT_4
   1158            {
   1159              case TIM_CHANNEL_1:
   1160              {
   1161                /* Enable the TIM Capture/Compare 1 interrupt */
   1162                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_PWM_Start_IT_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x68C2             LDR      R2,[R0, #+12]
   \   0000001A   0xF042 0x0202      ORR      R2,R2,#0x2
   \   0000001E   0x60C2             STR      R2,[R0, #+12]
   1163              }
   1164              break;
   \   00000020   0xE010             B.N      ??HAL_TIM_PWM_Start_IT_4
   1165          
   1166              case TIM_CHANNEL_2:
   1167              {
   1168                /* Enable the TIM Capture/Compare 2 interrupt */
   1169                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_PWM_Start_IT_1: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C2             LDR      R2,[R0, #+12]
   \   00000026   0xF042 0x0204      ORR      R2,R2,#0x4
   \   0000002A   0x60C2             STR      R2,[R0, #+12]
   1170              }
   1171              break;
   \   0000002C   0xE00A             B.N      ??HAL_TIM_PWM_Start_IT_4
   1172          
   1173              case TIM_CHANNEL_3:
   1174              {
   1175                /* Enable the TIM Capture/Compare 3 interrupt */
   1176                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_PWM_Start_IT_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68C2             LDR      R2,[R0, #+12]
   \   00000032   0xF042 0x0208      ORR      R2,R2,#0x8
   \   00000036   0x60C2             STR      R2,[R0, #+12]
   1177              }
   1178              break;
   \   00000038   0xE004             B.N      ??HAL_TIM_PWM_Start_IT_4
   1179          
   1180              case TIM_CHANNEL_4:
   1181              {
   1182                /* Enable the TIM Capture/Compare 4 interrupt */
   1183                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_PWM_Start_IT_3: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x68C2             LDR      R2,[R0, #+12]
   \   0000003E   0xF042 0x0210      ORR      R2,R2,#0x10
   \   00000042   0x60C2             STR      R2,[R0, #+12]
   1184              }
   1185              break;
   1186          
   1187              default:
   1188              break;
   1189            }
   1190          
   1191            /* Enable the Capture compare channel */
   1192            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_PWM_Start_IT_4: (+1)
   \   00000044   0x2201             MOVS     R2,#+1
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       TIM_CCxChannelCmd
   1193          
   1194            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable16  ;; 0x40012c00
   \   00000052   0x4288             CMP      R0,R1
   \   00000054   0xD003             BEQ.N    ??HAL_TIM_PWM_Start_IT_5
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x40013400
   \   0000005A   0x4288             CMP      R0,R1
   \   0000005C   0xD101             BNE.N    ??HAL_TIM_PWM_Start_IT_6
   \                     ??HAL_TIM_PWM_Start_IT_5: (+1)
   \   0000005E   0x2101             MOVS     R1,#+1
   \   00000060   0xE000             B.N      ??HAL_TIM_PWM_Start_IT_7
   \                     ??HAL_TIM_PWM_Start_IT_6: (+1)
   \   00000062   0x2100             MOVS     R1,#+0
   \                     ??HAL_TIM_PWM_Start_IT_7: (+1)
   \   00000064   0x2900             CMP      R1,#+0
   \   00000066   0xD003             BEQ.N    ??HAL_TIM_PWM_Start_IT_8
   1195            {
   1196              /* Enable the main output */
   1197              __HAL_TIM_MOE_ENABLE(htim);
   \   00000068   0x6C41             LDR      R1,[R0, #+68]
   \   0000006A   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000006E   0x6441             STR      R1,[R0, #+68]
   1198            }
   1199          
   1200            /* Enable the Peripheral */
   1201            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_PWM_Start_IT_8: (+1)
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x6801             LDR      R1,[R0, #+0]
   \   00000074   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000078   0x6001             STR      R1,[R0, #+0]
   1202          
   1203            /* Return function status */
   1204            return HAL_OK;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xBD10             POP      {R4,PC}          ;; return
   1205          }
   1206          
   1207          /**
   1208            * @brief  Stops the PWM signal generation in interrupt mode.
   1209            * @param  htim : TIM handle
   1210            * @param  Channel : TIM Channels to be disabled
   1211            *          This parameter can be one of the following values:
   1212            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1213            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1214            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1215            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1216            * @retval HAL status
   1217          */

   \                                 In section .text, align 2, keep-with-next
   1218          HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
   1219          {
   \                     HAL_TIM_PWM_Stop_IT: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1220            /* Check the parameters */
   1221            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1222          
   1223            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIM_PWM_Stop_IT_0
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD00A             BEQ.N    ??HAL_TIM_PWM_Stop_IT_1
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD00E             BEQ.N    ??HAL_TIM_PWM_Stop_IT_2
   \   00000010   0x280C             CMP      R0,#+12
   \   00000012   0xD012             BEQ.N    ??HAL_TIM_PWM_Stop_IT_3
   \   00000014   0xE016             B.N      ??HAL_TIM_PWM_Stop_IT_4
   1224            {
   1225              case TIM_CHANNEL_1:
   1226              {
   1227                /* Disable the TIM Capture/Compare 1 interrupt */
   1228                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_PWM_Stop_IT_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x68C2             LDR      R2,[R0, #+12]
   \   0000001A   0xF022 0x0202      BIC      R2,R2,#0x2
   \   0000001E   0x60C2             STR      R2,[R0, #+12]
   1229              }
   1230              break;
   \   00000020   0xE010             B.N      ??HAL_TIM_PWM_Stop_IT_4
   1231          
   1232              case TIM_CHANNEL_2:
   1233              {
   1234                /* Disable the TIM Capture/Compare 2 interrupt */
   1235                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_PWM_Stop_IT_1: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C2             LDR      R2,[R0, #+12]
   \   00000026   0xF022 0x0204      BIC      R2,R2,#0x4
   \   0000002A   0x60C2             STR      R2,[R0, #+12]
   1236              }
   1237              break;
   \   0000002C   0xE00A             B.N      ??HAL_TIM_PWM_Stop_IT_4
   1238          
   1239              case TIM_CHANNEL_3:
   1240              {
   1241                /* Disable the TIM Capture/Compare 3 interrupt */
   1242                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_PWM_Stop_IT_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68C2             LDR      R2,[R0, #+12]
   \   00000032   0xF022 0x0208      BIC      R2,R2,#0x8
   \   00000036   0x60C2             STR      R2,[R0, #+12]
   1243              }
   1244              break;
   \   00000038   0xE004             B.N      ??HAL_TIM_PWM_Stop_IT_4
   1245          
   1246              case TIM_CHANNEL_4:
   1247              {
   1248                /* Disable the TIM Capture/Compare 4 interrupt */
   1249                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_PWM_Stop_IT_3: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x68C2             LDR      R2,[R0, #+12]
   \   0000003E   0xF022 0x0210      BIC      R2,R2,#0x10
   \   00000042   0x60C2             STR      R2,[R0, #+12]
   1250              }
   1251              break;
   1252          
   1253              default:
   1254              break;
   1255            }
   1256          
   1257            /* Disable the Capture compare channel */
   1258            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_PWM_Stop_IT_4: (+1)
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       TIM_CCxChannelCmd
   1259          
   1260            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable16  ;; 0x40012c00
   \   00000052   0x4288             CMP      R0,R1
   \   00000054   0xD003             BEQ.N    ??HAL_TIM_PWM_Stop_IT_5
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x40013400
   \   0000005A   0x4288             CMP      R0,R1
   \   0000005C   0xD101             BNE.N    ??HAL_TIM_PWM_Stop_IT_6
   \                     ??HAL_TIM_PWM_Stop_IT_5: (+1)
   \   0000005E   0x2101             MOVS     R1,#+1
   \   00000060   0xE000             B.N      ??HAL_TIM_PWM_Stop_IT_7
   \                     ??HAL_TIM_PWM_Stop_IT_6: (+1)
   \   00000062   0x2100             MOVS     R1,#+0
   \                     ??HAL_TIM_PWM_Stop_IT_7: (+1)
   \   00000064   0xF241 0x1211      MOVW     R2,#+4369
   \   00000068   0x2900             CMP      R1,#+0
   \   0000006A   0xD00B             BEQ.N    ??HAL_TIM_PWM_Stop_IT_8
   1261            {
   1262              /* Disable the Main Ouput */
   1263              __HAL_TIM_MOE_DISABLE(htim);
   \   0000006C   0x6A01             LDR      R1,[R0, #+32]
   \   0000006E   0x4211             TST      R1,R2
   \   00000070   0xD108             BNE.N    ??HAL_TIM_PWM_Stop_IT_8
   \   00000072   0x6A01             LDR      R1,[R0, #+32]
   \   00000074   0xF240 0x4344      MOVW     R3,#+1092
   \   00000078   0x4219             TST      R1,R3
   \   0000007A   0xD103             BNE.N    ??HAL_TIM_PWM_Stop_IT_8
   \   0000007C   0x6C41             LDR      R1,[R0, #+68]
   \   0000007E   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000082   0x6441             STR      R1,[R0, #+68]
   1264            }
   1265          
   1266            /* Disable the Peripheral */
   1267            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_PWM_Stop_IT_8: (+1)
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x6A01             LDR      R1,[R0, #+32]
   \   00000088   0x4211             TST      R1,R2
   \   0000008A   0xD108             BNE.N    ??HAL_TIM_PWM_Stop_IT_9
   \   0000008C   0x6A01             LDR      R1,[R0, #+32]
   \   0000008E   0xF240 0x4244      MOVW     R2,#+1092
   \   00000092   0x4211             TST      R1,R2
   \   00000094   0xD103             BNE.N    ??HAL_TIM_PWM_Stop_IT_9
   \   00000096   0x6801             LDR      R1,[R0, #+0]
   \   00000098   0x0849             LSRS     R1,R1,#+1
   \   0000009A   0x0049             LSLS     R1,R1,#+1
   \   0000009C   0x6001             STR      R1,[R0, #+0]
   1268          
   1269            /* Return function status */
   1270            return HAL_OK;
   \                     ??HAL_TIM_PWM_Stop_IT_9: (+1)
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   1271          }
   1272          
   1273          /**
   1274            * @brief  Starts the TIM PWM signal generation in DMA mode.
   1275            * @param  htim : TIM handle
   1276            * @param  Channel : TIM Channels to be enabled
   1277            *          This parameter can be one of the following values:
   1278            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1279            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1280            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1281            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1282            * @param  pData : The source Buffer address.
   1283            * @param  Length : The length of data to be transferred from memory to TIM peripheral
   1284            * @retval HAL status
   1285          */

   \                                 In section .text, align 2, keep-with-next
   1286          HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1287          {
   \                     HAL_TIM_PWM_Start_DMA: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4611             MOV      R1,R2
   1288            /* Check the parameters */
   1289            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1290          
   1291            if((htim->State == HAL_TIM_STATE_BUSY))
   \   00000008   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD101             BNE.N    ??HAL_TIM_PWM_Start_DMA_0
   1292            {
   1293               return HAL_BUSY;
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xBD32             POP      {R1,R4,R5,PC}
   1294            }
   1295            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIM_PWM_Start_DMA_0: (+1)
   \   00000014   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD108             BNE.N    ??HAL_TIM_PWM_Start_DMA_1
   1296            {
   1297              if(((uint32_t)pData == 0 ) && (Length > 0))
   \   0000001C   0x2900             CMP      R1,#+0
   \   0000001E   0xD103             BNE.N    ??HAL_TIM_PWM_Start_DMA_2
   \   00000020   0x0018             MOVS     R0,R3
   \   00000022   0xD001             BEQ.N    ??HAL_TIM_PWM_Start_DMA_2
   1298              {
   1299                return HAL_ERROR;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xBD32             POP      {R1,R4,R5,PC}
   1300              }
   1301              else
   1302              {
   1303                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_PWM_Start_DMA_2: (+1)
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xF884 0x0039      STRB     R0,[R4, #+57]
   1304              }
   1305            }
   1306            switch (Channel)
   \                     ??HAL_TIM_PWM_Start_DMA_1: (+1)
   \   0000002E   0x0028             MOVS     R0,R5
   \   00000030   0xD006             BEQ.N    ??HAL_TIM_PWM_Start_DMA_3
   \   00000032   0x2804             CMP      R0,#+4
   \   00000034   0xD018             BEQ.N    ??HAL_TIM_PWM_Start_DMA_4
   \   00000036   0x2808             CMP      R0,#+8
   \   00000038   0xD02A             BEQ.N    ??HAL_TIM_PWM_Start_DMA_5
   \   0000003A   0x280C             CMP      R0,#+12
   \   0000003C   0xD03C             BEQ.N    ??HAL_TIM_PWM_Start_DMA_6
   \   0000003E   0xE04E             B.N      ??HAL_TIM_PWM_Start_DMA_7
   1307            {
   1308              case TIM_CHANNEL_1:
   1309              {
   1310                /* Set the DMA Period elapsed callback */
   1311                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_3: (+1)
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000044   0x6A22             LDR      R2,[R4, #+32]
   \   00000046   0x6290             STR      R0,[R2, #+40]
   1312          
   1313                /* Set the DMA error callback */
   1314                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable15
   \   0000004C   0x6A22             LDR      R2,[R4, #+32]
   \   0000004E   0x6310             STR      R0,[R2, #+48]
   1315          
   1316                /* Enable the DMA channel */
   1317                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0xF100 0x0234      ADD      R2,R0,#+52
   \   00000056   0x6A20             LDR      R0,[R4, #+32]
   \   00000058   0x.... 0x....      BL       HAL_DMA_Start_IT
   1318          
   1319                /* Enable the TIM Capture/Compare 1 DMA request */
   1320                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x68C1             LDR      R1,[R0, #+12]
   \   00000060   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000064   0x60C1             STR      R1,[R0, #+12]
   1321              }
   1322              break;
   \   00000066   0xE03A             B.N      ??HAL_TIM_PWM_Start_DMA_7
   1323          
   1324              case TIM_CHANNEL_2:
   1325              {
   1326                /* Set the DMA Period elapsed callback */
   1327                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_4: (+1)
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable19
   \   0000006C   0x6A62             LDR      R2,[R4, #+36]
   \   0000006E   0x6290             STR      R0,[R2, #+40]
   1328          
   1329                /* Set the DMA error callback */
   1330                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable15
   \   00000074   0x6A62             LDR      R2,[R4, #+36]
   \   00000076   0x6310             STR      R0,[R2, #+48]
   1331          
   1332                /* Enable the DMA channel */
   1333                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0xF100 0x0238      ADD      R2,R0,#+56
   \   0000007E   0x6A60             LDR      R0,[R4, #+36]
   \   00000080   0x.... 0x....      BL       HAL_DMA_Start_IT
   1334          
   1335                /* Enable the TIM Capture/Compare 2 DMA request */
   1336                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x68C1             LDR      R1,[R0, #+12]
   \   00000088   0xF441 0x6180      ORR      R1,R1,#0x400
   \   0000008C   0x60C1             STR      R1,[R0, #+12]
   1337              }
   1338              break;
   \   0000008E   0xE026             B.N      ??HAL_TIM_PWM_Start_DMA_7
   1339          
   1340              case TIM_CHANNEL_3:
   1341              {
   1342                /* Set the DMA Period elapsed callback */
   1343                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_5: (+1)
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000094   0x6AA2             LDR      R2,[R4, #+40]
   \   00000096   0x6290             STR      R0,[R2, #+40]
   1344          
   1345                /* Set the DMA error callback */
   1346                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable15
   \   0000009C   0x6AA2             LDR      R2,[R4, #+40]
   \   0000009E   0x6310             STR      R0,[R2, #+48]
   1347          
   1348                /* Enable the DMA channel */
   1349                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0xF100 0x023C      ADD      R2,R0,#+60
   \   000000A6   0x6AA0             LDR      R0,[R4, #+40]
   \   000000A8   0x.... 0x....      BL       HAL_DMA_Start_IT
   1350          
   1351                /* Enable the TIM Output Capture/Compare 3 request */
   1352                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \   000000AC   0x6820             LDR      R0,[R4, #+0]
   \   000000AE   0x68C1             LDR      R1,[R0, #+12]
   \   000000B0   0xF441 0x6100      ORR      R1,R1,#0x800
   \   000000B4   0x60C1             STR      R1,[R0, #+12]
   1353              }
   1354              break;
   \   000000B6   0xE012             B.N      ??HAL_TIM_PWM_Start_DMA_7
   1355          
   1356              case TIM_CHANNEL_4:
   1357              {
   1358               /* Set the DMA Period elapsed callback */
   1359                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_6: (+1)
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000000BC   0x6AE2             LDR      R2,[R4, #+44]
   \   000000BE   0x6290             STR      R0,[R2, #+40]
   1360          
   1361                /* Set the DMA error callback */
   1362                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \   000000C0   0x.... 0x....      LDR.W    R0,??DataTable15
   \   000000C4   0x6AE2             LDR      R2,[R4, #+44]
   \   000000C6   0x6310             STR      R0,[R2, #+48]
   1363          
   1364                /* Enable the DMA channel */
   1365                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
   \   000000C8   0x6820             LDR      R0,[R4, #+0]
   \   000000CA   0xF100 0x0240      ADD      R2,R0,#+64
   \   000000CE   0x6AE0             LDR      R0,[R4, #+44]
   \   000000D0   0x.... 0x....      BL       HAL_DMA_Start_IT
   1366          
   1367                /* Enable the TIM Capture/Compare 4 DMA request */
   1368                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \   000000D4   0x6820             LDR      R0,[R4, #+0]
   \   000000D6   0x68C1             LDR      R1,[R0, #+12]
   \   000000D8   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   000000DC   0x60C1             STR      R1,[R0, #+12]
   1369              }
   1370              break;
   1371          
   1372              default:
   1373              break;
   1374            }
   1375          
   1376            /* Enable the Capture compare channel */
   1377            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_PWM_Start_DMA_7: (+1)
   \   000000DE   0x2201             MOVS     R2,#+1
   \   000000E0   0x4629             MOV      R1,R5
   \   000000E2   0x6820             LDR      R0,[R4, #+0]
   \   000000E4   0x.... 0x....      BL       TIM_CCxChannelCmd
   1378          
   1379            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \   000000E8   0x6820             LDR      R0,[R4, #+0]
   \   000000EA   0x.... 0x....      LDR.W    R1,??DataTable16  ;; 0x40012c00
   \   000000EE   0x4288             CMP      R0,R1
   \   000000F0   0xD003             BEQ.N    ??HAL_TIM_PWM_Start_DMA_8
   \   000000F2   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x40013400
   \   000000F6   0x4288             CMP      R0,R1
   \   000000F8   0xD101             BNE.N    ??HAL_TIM_PWM_Start_DMA_9
   \                     ??HAL_TIM_PWM_Start_DMA_8: (+1)
   \   000000FA   0x2101             MOVS     R1,#+1
   \   000000FC   0xE000             B.N      ??HAL_TIM_PWM_Start_DMA_10
   \                     ??HAL_TIM_PWM_Start_DMA_9: (+1)
   \   000000FE   0x2100             MOVS     R1,#+0
   \                     ??HAL_TIM_PWM_Start_DMA_10: (+1)
   \   00000100   0x2900             CMP      R1,#+0
   \   00000102   0xD003             BEQ.N    ??HAL_TIM_PWM_Start_DMA_11
   1380            {
   1381              /* Enable the main output */
   1382              __HAL_TIM_MOE_ENABLE(htim);
   \   00000104   0x6C41             LDR      R1,[R0, #+68]
   \   00000106   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000010A   0x6441             STR      R1,[R0, #+68]
   1383            }
   1384          
   1385            /* Enable the Peripheral */
   1386            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_PWM_Start_DMA_11: (+1)
   \   0000010C   0x6820             LDR      R0,[R4, #+0]
   \   0000010E   0x6801             LDR      R1,[R0, #+0]
   \   00000110   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000114   0x6001             STR      R1,[R0, #+0]
   1387          
   1388            /* Return function status */
   1389            return HAL_OK;
   \   00000116   0x2000             MOVS     R0,#+0
   \   00000118   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1390          }
   1391          
   1392          /**
   1393            * @brief  Stops the TIM PWM signal generation in DMA mode.
   1394            * @param  htim : TIM handle
   1395            * @param  Channel : TIM Channels to be disabled
   1396            *          This parameter can be one of the following values:
   1397            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1398            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1399            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1400            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1401            * @retval HAL status
   1402          */

   \                                 In section .text, align 2, keep-with-next
   1403          HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1404          {
   \                     HAL_TIM_PWM_Stop_DMA: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1405            /* Check the parameters */
   1406            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1407          
   1408            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_0
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD00A             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_1
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD00E             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_2
   \   00000010   0x280C             CMP      R0,#+12
   \   00000012   0xD012             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_3
   \   00000014   0xE016             B.N      ??HAL_TIM_PWM_Stop_DMA_4
   1409            {
   1410              case TIM_CHANNEL_1:
   1411              {
   1412                /* Disable the TIM Capture/Compare 1 DMA request */
   1413                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_PWM_Stop_DMA_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x68C2             LDR      R2,[R0, #+12]
   \   0000001A   0xF422 0x7200      BIC      R2,R2,#0x200
   \   0000001E   0x60C2             STR      R2,[R0, #+12]
   1414              }
   1415              break;
   \   00000020   0xE010             B.N      ??HAL_TIM_PWM_Stop_DMA_4
   1416          
   1417              case TIM_CHANNEL_2:
   1418              {
   1419                /* Disable the TIM Capture/Compare 2 DMA request */
   1420                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_PWM_Stop_DMA_1: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C2             LDR      R2,[R0, #+12]
   \   00000026   0xF422 0x6280      BIC      R2,R2,#0x400
   \   0000002A   0x60C2             STR      R2,[R0, #+12]
   1421              }
   1422              break;
   \   0000002C   0xE00A             B.N      ??HAL_TIM_PWM_Stop_DMA_4
   1423          
   1424              case TIM_CHANNEL_3:
   1425              {
   1426                /* Disable the TIM Capture/Compare 3 DMA request */
   1427                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_PWM_Stop_DMA_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68C2             LDR      R2,[R0, #+12]
   \   00000032   0xF422 0x6200      BIC      R2,R2,#0x800
   \   00000036   0x60C2             STR      R2,[R0, #+12]
   1428              }
   1429              break;
   \   00000038   0xE004             B.N      ??HAL_TIM_PWM_Stop_DMA_4
   1430          
   1431              case TIM_CHANNEL_4:
   1432              {
   1433                /* Disable the TIM Capture/Compare 4 interrupt */
   1434                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_PWM_Stop_DMA_3: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x68C2             LDR      R2,[R0, #+12]
   \   0000003E   0xF422 0x5280      BIC      R2,R2,#0x1000
   \   00000042   0x60C2             STR      R2,[R0, #+12]
   1435              }
   1436              break;
   1437          
   1438              default:
   1439              break;
   1440            }
   1441          
   1442            /* Disable the Capture compare channel */
   1443            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_PWM_Stop_DMA_4: (+1)
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       TIM_CCxChannelCmd
   1444          
   1445            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable16  ;; 0x40012c00
   \   00000052   0x4288             CMP      R0,R1
   \   00000054   0xD003             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_5
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x40013400
   \   0000005A   0x4288             CMP      R0,R1
   \   0000005C   0xD101             BNE.N    ??HAL_TIM_PWM_Stop_DMA_6
   \                     ??HAL_TIM_PWM_Stop_DMA_5: (+1)
   \   0000005E   0x2101             MOVS     R1,#+1
   \   00000060   0xE000             B.N      ??HAL_TIM_PWM_Stop_DMA_7
   \                     ??HAL_TIM_PWM_Stop_DMA_6: (+1)
   \   00000062   0x2100             MOVS     R1,#+0
   \                     ??HAL_TIM_PWM_Stop_DMA_7: (+1)
   \   00000064   0xF241 0x1211      MOVW     R2,#+4369
   \   00000068   0x2900             CMP      R1,#+0
   \   0000006A   0xD00B             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_8
   1446            {
   1447              /* Disable the Main Ouput */
   1448              __HAL_TIM_MOE_DISABLE(htim);
   \   0000006C   0x6A01             LDR      R1,[R0, #+32]
   \   0000006E   0x4211             TST      R1,R2
   \   00000070   0xD108             BNE.N    ??HAL_TIM_PWM_Stop_DMA_8
   \   00000072   0x6A01             LDR      R1,[R0, #+32]
   \   00000074   0xF240 0x4344      MOVW     R3,#+1092
   \   00000078   0x4219             TST      R1,R3
   \   0000007A   0xD103             BNE.N    ??HAL_TIM_PWM_Stop_DMA_8
   \   0000007C   0x6C41             LDR      R1,[R0, #+68]
   \   0000007E   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000082   0x6441             STR      R1,[R0, #+68]
   1449            }
   1450          
   1451            /* Disable the Peripheral */
   1452            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_PWM_Stop_DMA_8: (+1)
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x6A01             LDR      R1,[R0, #+32]
   \   00000088   0x4211             TST      R1,R2
   \   0000008A   0xD108             BNE.N    ??HAL_TIM_PWM_Stop_DMA_9
   \   0000008C   0x6A01             LDR      R1,[R0, #+32]
   \   0000008E   0xF240 0x4244      MOVW     R2,#+1092
   \   00000092   0x4211             TST      R1,R2
   \   00000094   0xD103             BNE.N    ??HAL_TIM_PWM_Stop_DMA_9
   \   00000096   0x6801             LDR      R1,[R0, #+0]
   \   00000098   0x0849             LSRS     R1,R1,#+1
   \   0000009A   0x0049             LSLS     R1,R1,#+1
   \   0000009C   0x6001             STR      R1,[R0, #+0]
   1453          
   1454            /* Change the htim state */
   1455            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_PWM_Stop_DMA_9: (+1)
   \   0000009E   0x2001             MOVS     R0,#+1
   \   000000A0   0xF884 0x0039      STRB     R0,[R4, #+57]
   1456          
   1457            /* Return function status */
   1458            return HAL_OK;
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   1459          }
   1460          
   1461          /**
   1462            * @}
   1463            */
   1464          
   1465          /** @defgroup TIM_Exported_Functions_Group4 Time Input Capture functions 
   1466           *  @brief    Time Input Capture functions 
   1467           *
   1468          @verbatim 
   1469            ==============================================================================
   1470                        ##### Time Input Capture functions #####
   1471            ==============================================================================
   1472           [..]
   1473             This section provides functions allowing to:
   1474             (+) Initialize and configure the TIM Input Capture.
   1475             (+) De-initialize the TIM Input Capture.
   1476             (+) Start the Time Input Capture.
   1477             (+) Stop the Time Input Capture.
   1478             (+) Start the Time Input Capture and enable interrupt.
   1479             (+) Stop the Time Input Capture and disable interrupt.
   1480             (+) Start the Time Input Capture and enable DMA transfer.
   1481             (+) Stop the Time Input Capture and disable DMA transfer.
   1482          
   1483          @endverbatim
   1484            * @{
   1485            */
   1486          /**
   1487            * @brief  Initializes the TIM Input Capture Time base according to the specified
   1488            *         parameters in the TIM_HandleTypeDef and create the associated handle.
   1489            * @param  htim : TIM Input Capture handle
   1490            * @retval HAL status
   1491            */

   \                                 In section .text, align 2, keep-with-next
   1492          HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
   1493          {
   \                     HAL_TIM_IC_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1494            /* Check the TIM handle allocation */
   1495            if(htim == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_TIM_IC_Init_0
   1496            {
   1497              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD32             POP      {R1,R4,R5,PC}
   1498            }
   1499          
   1500            /* Check the parameters */
   1501            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1502            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1503            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   1504          
   1505            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_IC_Init_0: (+1)
   \   0000000A   0xF104 0x0538      ADD      R5,R4,#+56
   \   0000000E   0xF995 0x0001      LDRSB    R0,[R5, #+1]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD104             BNE.N    ??HAL_TIM_IC_Init_1
   1506            {
   1507              /* Allocate lock resource and initialize it */
   1508              htim->Lock = HAL_UNLOCKED;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x7028             STRB     R0,[R5, #+0]
   1509              
   1510              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1511              HAL_TIM_IC_MspInit(htim);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       HAL_TIM_IC_MspInit
   1512            }
   1513          
   1514            /* Set the TIM state */
   1515            htim->State= HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_IC_Init_1: (+1)
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0x7068             STRB     R0,[R5, #+1]
   1516          
   1517            /* Init the base time for the input capture */
   1518            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \   00000024   0x1D21             ADDS     R1,R4,#+4
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x.... 0x....      BL       TIM_Base_SetConfig
   1519          
   1520            /* Initialize the TIM state*/
   1521            htim->State= HAL_TIM_STATE_READY;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x7068             STRB     R0,[R5, #+1]
   1522          
   1523            return HAL_OK;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1524          }
   1525          
   1526          /**
   1527            * @brief  DeInitializes the TIM peripheral 
   1528            * @param  htim : TIM Input Capture handle
   1529            * @retval HAL status
   1530            */

   \                                 In section .text, align 2, keep-with-next
   1531          HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)
   1532          {
   \                     HAL_TIM_IC_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1533            /* Check the parameters */
   1534            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1535          
   1536            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
   1537          
   1538            /* Disable the TIM Peripheral Clock */
   1539            __HAL_TIM_DISABLE(htim);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6A01             LDR      R1,[R0, #+32]
   \   0000000E   0xF241 0x1211      MOVW     R2,#+4369
   \   00000012   0x4211             TST      R1,R2
   \   00000014   0xD108             BNE.N    ??HAL_TIM_IC_DeInit_0
   \   00000016   0x6A01             LDR      R1,[R0, #+32]
   \   00000018   0xF240 0x4244      MOVW     R2,#+1092
   \   0000001C   0x4211             TST      R1,R2
   \   0000001E   0xD103             BNE.N    ??HAL_TIM_IC_DeInit_0
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x0849             LSRS     R1,R1,#+1
   \   00000024   0x0049             LSLS     R1,R1,#+1
   \   00000026   0x6001             STR      R1,[R0, #+0]
   1540          
   1541            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
   1542            HAL_TIM_IC_MspDeInit(htim);
   \                     ??HAL_TIM_IC_DeInit_0: (+1)
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_TIM_IC_MspDeInit
   1543          
   1544            /* Change TIM state */
   1545            htim->State = HAL_TIM_STATE_RESET;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF884 0x0039      STRB     R0,[R4, #+57]
   1546          
   1547            /* Release Lock */
   1548            __HAL_UNLOCK(htim);
   1549          
   1550            return HAL_OK;
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
   1551          }
   1552          
   1553          /**
   1554            * @brief  Initializes the TIM Input Capture MSP.
   1555            * @param  htim : TIM handle
   1556            * @retval None
   1557            */

   \                                 In section .text, align 2
   1558          __weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
   1559          {
   1560            /* Prevent unused argument(s) compilation warning */
   1561            UNUSED(htim);
   1562            /* NOTE : This function Should not be modified, when the callback is needed,
   1563                      the HAL_TIM_IC_MspInit could be implemented in the user file
   1564             */
   1565          }
   \                     HAL_TIM_IC_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1566          
   1567          /**
   1568            * @brief  DeInitializes TIM Input Capture MSP.
   1569            * @param  htim : TIM handle
   1570            * @retval None
   1571            */

   \                                 In section .text, align 2
   1572          __weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
   1573          {
   1574            /* Prevent unused argument(s) compilation warning */
   1575            UNUSED(htim);
   1576            /* NOTE : This function Should not be modified, when the callback is needed,
   1577                      the HAL_TIM_IC_MspDeInit could be implemented in the user file
   1578             */
   1579          }
   \                     HAL_TIM_IC_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1580          
   1581          /**
   1582            * @brief  Starts the TIM Input Capture measurement.
   1583            * @param  htim : TIM Input Capture handle
   1584            * @param  Channel : TIM Channels to be enabled
   1585            *          This parameter can be one of the following values:
   1586            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1587            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1588            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1589            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1590            * @retval HAL status
   1591          */

   \                                 In section .text, align 2, keep-with-next
   1592          HAL_StatusTypeDef HAL_TIM_IC_Start (TIM_HandleTypeDef *htim, uint32_t Channel)
   1593          {
   \                     HAL_TIM_IC_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1594            /* Check the parameters */
   1595            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1596          
   1597            /* Enable the Input Capture channel */
   1598            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_CCxChannelCmd
   1599          
   1600            /* Enable the Peripheral */
   1601            __HAL_TIM_ENABLE(htim);
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
   \   00000010   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000014   0x6001             STR      R1,[R0, #+0]
   1602          
   1603            /* Return function status */
   1604            return HAL_OK;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
   1605          }
   1606          
   1607          /**
   1608            * @brief  Stops the TIM Input Capture measurement.
   1609            * @param  htim : TIM handle
   1610            * @param  Channel : TIM Channels to be disabled
   1611            *          This parameter can be one of the following values:
   1612            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1613            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1614            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1615            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1616            * @retval HAL status
   1617          */

   \                                 In section .text, align 2, keep-with-next
   1618          HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1619          {
   \                     HAL_TIM_IC_Stop: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1620            /* Check the parameters */
   1621            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1622          
   1623            /* Disable the Input Capture channel */
   1624            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       TIM_CCxChannelCmd
   1625          
   1626            /* Disable the Peripheral */
   1627            __HAL_TIM_DISABLE(htim);
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6A01             LDR      R1,[R0, #+32]
   \   00000010   0xF241 0x1211      MOVW     R2,#+4369
   \   00000014   0x4211             TST      R1,R2
   \   00000016   0xD108             BNE.N    ??HAL_TIM_IC_Stop_0
   \   00000018   0x6A01             LDR      R1,[R0, #+32]
   \   0000001A   0xF240 0x4244      MOVW     R2,#+1092
   \   0000001E   0x4211             TST      R1,R2
   \   00000020   0xD103             BNE.N    ??HAL_TIM_IC_Stop_0
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0x0849             LSRS     R1,R1,#+1
   \   00000026   0x0049             LSLS     R1,R1,#+1
   \   00000028   0x6001             STR      R1,[R0, #+0]
   1628          
   1629            /* Return function status */
   1630            return HAL_OK;
   \                     ??HAL_TIM_IC_Stop_0: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   1631          }
   1632          
   1633          /**
   1634            * @brief  Starts the TIM Input Capture measurement in interrupt mode.
   1635            * @param  htim : TIM Input Capture handle
   1636            * @param  Channel : TIM Channels to be enabled
   1637            *          This parameter can be one of the following values:
   1638            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1639            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1640            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1641            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1642            * @retval HAL status
   1643          */

   \                                 In section .text, align 2, keep-with-next
   1644          HAL_StatusTypeDef HAL_TIM_IC_Start_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
   1645          {
   \                     HAL_TIM_IC_Start_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1646            /* Check the parameters */
   1647            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1648          
   1649            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIM_IC_Start_IT_0
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD00A             BEQ.N    ??HAL_TIM_IC_Start_IT_1
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD00E             BEQ.N    ??HAL_TIM_IC_Start_IT_2
   \   00000010   0x280C             CMP      R0,#+12
   \   00000012   0xD012             BEQ.N    ??HAL_TIM_IC_Start_IT_3
   \   00000014   0xE016             B.N      ??HAL_TIM_IC_Start_IT_4
   1650            {
   1651              case TIM_CHANNEL_1:
   1652              {
   1653                /* Enable the TIM Capture/Compare 1 interrupt */
   1654                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_IC_Start_IT_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x68C2             LDR      R2,[R0, #+12]
   \   0000001A   0xF042 0x0202      ORR      R2,R2,#0x2
   \   0000001E   0x60C2             STR      R2,[R0, #+12]
   1655              }
   1656              break;
   \   00000020   0xE010             B.N      ??HAL_TIM_IC_Start_IT_4
   1657          
   1658              case TIM_CHANNEL_2:
   1659              {
   1660                /* Enable the TIM Capture/Compare 2 interrupt */
   1661                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_IC_Start_IT_1: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C2             LDR      R2,[R0, #+12]
   \   00000026   0xF042 0x0204      ORR      R2,R2,#0x4
   \   0000002A   0x60C2             STR      R2,[R0, #+12]
   1662              }
   1663              break;
   \   0000002C   0xE00A             B.N      ??HAL_TIM_IC_Start_IT_4
   1664          
   1665              case TIM_CHANNEL_3:
   1666              {
   1667                /* Enable the TIM Capture/Compare 3 interrupt */
   1668                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_IC_Start_IT_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68C2             LDR      R2,[R0, #+12]
   \   00000032   0xF042 0x0208      ORR      R2,R2,#0x8
   \   00000036   0x60C2             STR      R2,[R0, #+12]
   1669              }
   1670              break;
   \   00000038   0xE004             B.N      ??HAL_TIM_IC_Start_IT_4
   1671          
   1672              case TIM_CHANNEL_4:
   1673              {
   1674                /* Enable the TIM Capture/Compare 4 interrupt */
   1675                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_IC_Start_IT_3: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x68C2             LDR      R2,[R0, #+12]
   \   0000003E   0xF042 0x0210      ORR      R2,R2,#0x10
   \   00000042   0x60C2             STR      R2,[R0, #+12]
   1676              }
   1677              break;
   1678          
   1679              default:
   1680              break;
   1681            }
   1682            /* Enable the Input Capture channel */
   1683            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_IC_Start_IT_4: (+1)
   \   00000044   0x2201             MOVS     R2,#+1
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       TIM_CCxChannelCmd
   1684          
   1685            /* Enable the Peripheral */
   1686            __HAL_TIM_ENABLE(htim);
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6801             LDR      R1,[R0, #+0]
   \   00000050   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000054   0x6001             STR      R1,[R0, #+0]
   1687          
   1688            /* Return function status */
   1689            return HAL_OK;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xBD10             POP      {R4,PC}          ;; return
   1690          }
   1691          
   1692          /**
   1693            * @brief  Stops the TIM Input Capture measurement in interrupt mode.
   1694            * @param  htim : TIM handle
   1695            * @param  Channel : TIM Channels to be disabled
   1696            *          This parameter can be one of the following values:
   1697            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1698            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1699            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1700            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1701            * @retval HAL status
   1702          */

   \                                 In section .text, align 2, keep-with-next
   1703          HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1704          {
   \                     HAL_TIM_IC_Stop_IT: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1705            /* Check the parameters */
   1706            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1707          
   1708            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIM_IC_Stop_IT_0
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD00A             BEQ.N    ??HAL_TIM_IC_Stop_IT_1
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD00E             BEQ.N    ??HAL_TIM_IC_Stop_IT_2
   \   00000010   0x280C             CMP      R0,#+12
   \   00000012   0xD012             BEQ.N    ??HAL_TIM_IC_Stop_IT_3
   \   00000014   0xE016             B.N      ??HAL_TIM_IC_Stop_IT_4
   1709            {
   1710              case TIM_CHANNEL_1:
   1711              {
   1712                /* Disable the TIM Capture/Compare 1 interrupt */
   1713                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_IC_Stop_IT_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x68C2             LDR      R2,[R0, #+12]
   \   0000001A   0xF022 0x0202      BIC      R2,R2,#0x2
   \   0000001E   0x60C2             STR      R2,[R0, #+12]
   1714              }
   1715              break;
   \   00000020   0xE010             B.N      ??HAL_TIM_IC_Stop_IT_4
   1716          
   1717              case TIM_CHANNEL_2:
   1718              {
   1719                /* Disable the TIM Capture/Compare 2 interrupt */
   1720                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_IC_Stop_IT_1: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C2             LDR      R2,[R0, #+12]
   \   00000026   0xF022 0x0204      BIC      R2,R2,#0x4
   \   0000002A   0x60C2             STR      R2,[R0, #+12]
   1721              }
   1722              break;
   \   0000002C   0xE00A             B.N      ??HAL_TIM_IC_Stop_IT_4
   1723          
   1724              case TIM_CHANNEL_3:
   1725              {
   1726                /* Disable the TIM Capture/Compare 3 interrupt */
   1727                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_IC_Stop_IT_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68C2             LDR      R2,[R0, #+12]
   \   00000032   0xF022 0x0208      BIC      R2,R2,#0x8
   \   00000036   0x60C2             STR      R2,[R0, #+12]
   1728              }
   1729              break;
   \   00000038   0xE004             B.N      ??HAL_TIM_IC_Stop_IT_4
   1730          
   1731              case TIM_CHANNEL_4:
   1732              {
   1733                /* Disable the TIM Capture/Compare 4 interrupt */
   1734                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_IC_Stop_IT_3: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x68C2             LDR      R2,[R0, #+12]
   \   0000003E   0xF022 0x0210      BIC      R2,R2,#0x10
   \   00000042   0x60C2             STR      R2,[R0, #+12]
   1735              }
   1736              break;
   1737          
   1738              default:
   1739              break;
   1740            }
   1741          
   1742            /* Disable the Input Capture channel */
   1743            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_IC_Stop_IT_4: (+1)
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       TIM_CCxChannelCmd
   1744          
   1745            /* Disable the Peripheral */
   1746            __HAL_TIM_DISABLE(htim);
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6A01             LDR      R1,[R0, #+32]
   \   00000050   0xF241 0x1211      MOVW     R2,#+4369
   \   00000054   0x4211             TST      R1,R2
   \   00000056   0xD108             BNE.N    ??HAL_TIM_IC_Stop_IT_5
   \   00000058   0x6A01             LDR      R1,[R0, #+32]
   \   0000005A   0xF240 0x4244      MOVW     R2,#+1092
   \   0000005E   0x4211             TST      R1,R2
   \   00000060   0xD103             BNE.N    ??HAL_TIM_IC_Stop_IT_5
   \   00000062   0x6801             LDR      R1,[R0, #+0]
   \   00000064   0x0849             LSRS     R1,R1,#+1
   \   00000066   0x0049             LSLS     R1,R1,#+1
   \   00000068   0x6001             STR      R1,[R0, #+0]
   1747          
   1748            /* Return function status */
   1749            return HAL_OK;
   \                     ??HAL_TIM_IC_Stop_IT_5: (+1)
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   1750          }
   1751          
   1752          /**
   1753            * @brief  Starts the TIM Input Capture measurement in DMA mode.
   1754            * @param  htim : TIM Input Capture handle
   1755            * @param  Channel : TIM Channels to be enabled
   1756            *          This parameter can be one of the following values:
   1757            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1758            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1759            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1760            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1761            * @param  pData : The destination Buffer address.
   1762            * @param  Length : The length of data to be transferred from TIM peripheral to memory.
   1763            * @retval HAL status
   1764          */

   \                                 In section .text, align 2, keep-with-next
   1765          HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1766          {
   \                     HAL_TIM_IC_Start_DMA: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1767            /* Check the parameters */
   1768            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1769            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   1770          
   1771            if((htim->State == HAL_TIM_STATE_BUSY))
   \   00000006   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   0000000A   0x2802             CMP      R0,#+2
   \   0000000C   0xD101             BNE.N    ??HAL_TIM_IC_Start_DMA_0
   1772            {
   1773               return HAL_BUSY;
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xBD32             POP      {R1,R4,R5,PC}
   1774            }
   1775            else if((htim->State == HAL_TIM_STATE_READY))
   \                     ??HAL_TIM_IC_Start_DMA_0: (+1)
   \   00000012   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD108             BNE.N    ??HAL_TIM_IC_Start_DMA_1
   1776            {
   1777              if((pData == 0 ) && (Length > 0))
   \   0000001A   0x2A00             CMP      R2,#+0
   \   0000001C   0xD103             BNE.N    ??HAL_TIM_IC_Start_DMA_2
   \   0000001E   0x0018             MOVS     R0,R3
   \   00000020   0xD001             BEQ.N    ??HAL_TIM_IC_Start_DMA_2
   1778              {
   1779                return HAL_ERROR;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}
   1780              }
   1781              else
   1782              {
   1783                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_IC_Start_DMA_2: (+1)
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0xF884 0x0039      STRB     R0,[R4, #+57]
   1784              }
   1785            }
   1786          
   1787            switch (Channel)
   \                     ??HAL_TIM_IC_Start_DMA_1: (+1)
   \   0000002C   0x0028             MOVS     R0,R5
   \   0000002E   0xD006             BEQ.N    ??HAL_TIM_IC_Start_DMA_3
   \   00000030   0x2804             CMP      R0,#+4
   \   00000032   0xD018             BEQ.N    ??HAL_TIM_IC_Start_DMA_4
   \   00000034   0x2808             CMP      R0,#+8
   \   00000036   0xD02A             BEQ.N    ??HAL_TIM_IC_Start_DMA_5
   \   00000038   0x280C             CMP      R0,#+12
   \   0000003A   0xD03C             BEQ.N    ??HAL_TIM_IC_Start_DMA_6
   \   0000003C   0xE04E             B.N      ??HAL_TIM_IC_Start_DMA_7
   1788            {
   1789              case TIM_CHANNEL_1:
   1790              {
   1791                /* Set the DMA Period elapsed callback */
   1792                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_3: (+1)
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000042   0x6A21             LDR      R1,[R4, #+32]
   \   00000044   0x6288             STR      R0,[R1, #+40]
   1793          
   1794                /* Set the DMA error callback */
   1795                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   0000004A   0x6A21             LDR      R1,[R4, #+32]
   \   0000004C   0x6308             STR      R0,[R1, #+48]
   1796          
   1797                /* Enable the DMA channel */
   1798                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length);
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0xF100 0x0134      ADD      R1,R0,#+52
   \   00000054   0x6A20             LDR      R0,[R4, #+32]
   \   00000056   0x.... 0x....      BL       HAL_DMA_Start_IT
   1799          
   1800                /* Enable the TIM Capture/Compare 1 DMA request */
   1801                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x68C1             LDR      R1,[R0, #+12]
   \   0000005E   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000062   0x60C1             STR      R1,[R0, #+12]
   1802              }
   1803              break;
   \   00000064   0xE03A             B.N      ??HAL_TIM_IC_Start_DMA_7
   1804          
   1805              case TIM_CHANNEL_2:
   1806              {
   1807                /* Set the DMA Period elapsed callback */
   1808                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_4: (+1)
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable21
   \   0000006A   0x6A61             LDR      R1,[R4, #+36]
   \   0000006C   0x6288             STR      R0,[R1, #+40]
   1809          
   1810                /* Set the DMA error callback */
   1811                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   00000072   0x6A61             LDR      R1,[R4, #+36]
   \   00000074   0x6308             STR      R0,[R1, #+48]
   1812          
   1813                /* Enable the DMA channel */
   1814                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData, Length);
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0xF100 0x0138      ADD      R1,R0,#+56
   \   0000007C   0x6A60             LDR      R0,[R4, #+36]
   \   0000007E   0x.... 0x....      BL       HAL_DMA_Start_IT
   1815          
   1816                /* Enable the TIM Capture/Compare 2  DMA request */
   1817                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   00000082   0x6820             LDR      R0,[R4, #+0]
   \   00000084   0x68C1             LDR      R1,[R0, #+12]
   \   00000086   0xF441 0x6180      ORR      R1,R1,#0x400
   \   0000008A   0x60C1             STR      R1,[R0, #+12]
   1818              }
   1819              break;
   \   0000008C   0xE026             B.N      ??HAL_TIM_IC_Start_DMA_7
   1820          
   1821              case TIM_CHANNEL_3:
   1822              {
   1823                /* Set the DMA Period elapsed callback */
   1824                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_5: (+1)
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000092   0x6AA1             LDR      R1,[R4, #+40]
   \   00000094   0x6288             STR      R0,[R1, #+40]
   1825          
   1826                /* Set the DMA error callback */
   1827                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \   00000096   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   0000009A   0x6AA1             LDR      R1,[R4, #+40]
   \   0000009C   0x6308             STR      R0,[R1, #+48]
   1828          
   1829                /* Enable the DMA channel */
   1830                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData, Length);
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0xF100 0x013C      ADD      R1,R0,#+60
   \   000000A4   0x6AA0             LDR      R0,[R4, #+40]
   \   000000A6   0x.... 0x....      BL       HAL_DMA_Start_IT
   1831          
   1832                /* Enable the TIM Capture/Compare 3  DMA request */
   1833                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \   000000AA   0x6820             LDR      R0,[R4, #+0]
   \   000000AC   0x68C1             LDR      R1,[R0, #+12]
   \   000000AE   0xF441 0x6100      ORR      R1,R1,#0x800
   \   000000B2   0x60C1             STR      R1,[R0, #+12]
   1834              }
   1835              break;
   \   000000B4   0xE012             B.N      ??HAL_TIM_IC_Start_DMA_7
   1836          
   1837              case TIM_CHANNEL_4:
   1838              {
   1839                /* Set the DMA Period elapsed callback */
   1840                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_6: (+1)
   \   000000B6   0x.... 0x....      LDR.W    R0,??DataTable21
   \   000000BA   0x6AE1             LDR      R1,[R4, #+44]
   \   000000BC   0x6288             STR      R0,[R1, #+40]
   1841          
   1842                /* Set the DMA error callback */
   1843                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \   000000BE   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   000000C2   0x6AE1             LDR      R1,[R4, #+44]
   \   000000C4   0x6308             STR      R0,[R1, #+48]
   1844          
   1845                /* Enable the DMA channel */
   1846                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData, Length);
   \   000000C6   0x6820             LDR      R0,[R4, #+0]
   \   000000C8   0xF100 0x0140      ADD      R1,R0,#+64
   \   000000CC   0x6AE0             LDR      R0,[R4, #+44]
   \   000000CE   0x.... 0x....      BL       HAL_DMA_Start_IT
   1847          
   1848                /* Enable the TIM Capture/Compare 4  DMA request */
   1849                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \   000000D2   0x6820             LDR      R0,[R4, #+0]
   \   000000D4   0x68C1             LDR      R1,[R0, #+12]
   \   000000D6   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   000000DA   0x60C1             STR      R1,[R0, #+12]
   1850              }
   1851              break;
   1852          
   1853              default:
   1854              break;
   1855            }
   1856          
   1857            /* Enable the Input Capture channel */
   1858            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_IC_Start_DMA_7: (+1)
   \   000000DC   0x2201             MOVS     R2,#+1
   \   000000DE   0x4629             MOV      R1,R5
   \   000000E0   0x6820             LDR      R0,[R4, #+0]
   \   000000E2   0x.... 0x....      BL       TIM_CCxChannelCmd
   1859          
   1860            /* Enable the Peripheral */
   1861            __HAL_TIM_ENABLE(htim);
   \   000000E6   0x6820             LDR      R0,[R4, #+0]
   \   000000E8   0x6801             LDR      R1,[R0, #+0]
   \   000000EA   0xF041 0x0101      ORR      R1,R1,#0x1
   \   000000EE   0x6001             STR      R1,[R0, #+0]
   1862          
   1863            /* Return function status */
   1864            return HAL_OK;
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1865          }
   1866          
   1867          /**
   1868            * @brief  Stops the TIM Input Capture measurement in DMA mode.
   1869            * @param  htim : TIM Input Capture handle
   1870            * @param  Channel : TIM Channels to be disabled
   1871            *          This parameter can be one of the following values:
   1872            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1873            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1874            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1875            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1876            * @retval HAL status
   1877          */

   \                                 In section .text, align 2, keep-with-next
   1878          HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1879          {
   \                     HAL_TIM_IC_Stop_DMA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1880            /* Check the parameters */
   1881            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1882            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   1883          
   1884            switch (Channel)
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xD006             BEQ.N    ??HAL_TIM_IC_Stop_DMA_0
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD00A             BEQ.N    ??HAL_TIM_IC_Stop_DMA_1
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xD00E             BEQ.N    ??HAL_TIM_IC_Stop_DMA_2
   \   00000010   0x280C             CMP      R0,#+12
   \   00000012   0xD012             BEQ.N    ??HAL_TIM_IC_Stop_DMA_3
   \   00000014   0xE016             B.N      ??HAL_TIM_IC_Stop_DMA_4
   1885            {
   1886              case TIM_CHANNEL_1:
   1887              {
   1888                /* Disable the TIM Capture/Compare 1 DMA request */
   1889                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_IC_Stop_DMA_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x68C2             LDR      R2,[R0, #+12]
   \   0000001A   0xF422 0x7200      BIC      R2,R2,#0x200
   \   0000001E   0x60C2             STR      R2,[R0, #+12]
   1890              }
   1891              break;
   \   00000020   0xE010             B.N      ??HAL_TIM_IC_Stop_DMA_4
   1892          
   1893              case TIM_CHANNEL_2:
   1894              {
   1895                /* Disable the TIM Capture/Compare 2 DMA request */
   1896                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_IC_Stop_DMA_1: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x68C2             LDR      R2,[R0, #+12]
   \   00000026   0xF422 0x6280      BIC      R2,R2,#0x400
   \   0000002A   0x60C2             STR      R2,[R0, #+12]
   1897              }
   1898              break;
   \   0000002C   0xE00A             B.N      ??HAL_TIM_IC_Stop_DMA_4
   1899          
   1900              case TIM_CHANNEL_3:
   1901              {
   1902                /* Disable the TIM Capture/Compare 3  DMA request */
   1903                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_IC_Stop_DMA_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68C2             LDR      R2,[R0, #+12]
   \   00000032   0xF422 0x6200      BIC      R2,R2,#0x800
   \   00000036   0x60C2             STR      R2,[R0, #+12]
   1904              }
   1905              break;
   \   00000038   0xE004             B.N      ??HAL_TIM_IC_Stop_DMA_4
   1906          
   1907              case TIM_CHANNEL_4:
   1908              {
   1909                /* Disable the TIM Capture/Compare 4  DMA request */
   1910                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_IC_Stop_DMA_3: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x68C2             LDR      R2,[R0, #+12]
   \   0000003E   0xF422 0x5280      BIC      R2,R2,#0x1000
   \   00000042   0x60C2             STR      R2,[R0, #+12]
   1911              }
   1912              break;
   1913          
   1914              default:
   1915              break;
   1916            }
   1917          
   1918            /* Disable the Input Capture channel */
   1919            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_IC_Stop_DMA_4: (+1)
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       TIM_CCxChannelCmd
   1920          
   1921            /* Disable the Peripheral */
   1922            __HAL_TIM_DISABLE(htim);
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6A01             LDR      R1,[R0, #+32]
   \   00000050   0xF241 0x1211      MOVW     R2,#+4369
   \   00000054   0x4211             TST      R1,R2
   \   00000056   0xD108             BNE.N    ??HAL_TIM_IC_Stop_DMA_5
   \   00000058   0x6A01             LDR      R1,[R0, #+32]
   \   0000005A   0xF240 0x4244      MOVW     R2,#+1092
   \   0000005E   0x4211             TST      R1,R2
   \   00000060   0xD103             BNE.N    ??HAL_TIM_IC_Stop_DMA_5
   \   00000062   0x6801             LDR      R1,[R0, #+0]
   \   00000064   0x0849             LSRS     R1,R1,#+1
   \   00000066   0x0049             LSLS     R1,R1,#+1
   \   00000068   0x6001             STR      R1,[R0, #+0]
   1923          
   1924            /* Change the htim state */
   1925            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_IC_Stop_DMA_5: (+1)
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0xF884 0x0039      STRB     R0,[R4, #+57]
   1926          
   1927            /* Return function status */
   1928            return HAL_OK;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0xBD10             POP      {R4,PC}          ;; return
   1929          }
   1930          /**
   1931            * @}
   1932            */
   1933          
   1934          /** @defgroup TIM_Exported_Functions_Group5 Time One Pulse functions 
   1935           *  @brief    Time One Pulse functions 
   1936           *
   1937          @verbatim 
   1938            ==============================================================================
   1939                                  ##### Time One Pulse functions #####
   1940            ==============================================================================
   1941            [..]
   1942              This section provides functions allowing to:
   1943              (+) Initialize and configure the TIM One Pulse.
   1944              (+) De-initialize the TIM One Pulse.
   1945              (+) Start the Time One Pulse.
   1946              (+) Stop the Time One Pulse.
   1947              (+) Start the Time One Pulse and enable interrupt.
   1948              (+) Stop the Time One Pulse and disable interrupt.
   1949              (+) Start the Time One Pulse and enable DMA transfer.
   1950              (+) Stop the Time One Pulse and disable DMA transfer.
   1951          
   1952          @endverbatim
   1953            * @{
   1954            */
   1955          /**
   1956            * @brief  Initializes the TIM One Pulse Time Base according to the specified
   1957            *         parameters in the TIM_HandleTypeDef and create the associated handle.
   1958            * @param  htim : TIM OnePulse handle
   1959            * @param  OnePulseMode : Select the One pulse mode.
   1960            *         This parameter can be one of the following values:
   1961            *            @arg TIM_OPMODE_SINGLE: Only one pulse will be generated.
   1962            *            @arg TIM_OPMODE_REPETITIVE: Repetitive pulses wil be generated.
   1963            * @retval HAL status
   1964            */

   \                                 In section .text, align 2, keep-with-next
   1965          HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)
   1966          {
   \                     HAL_TIM_OnePulse_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
   1967            /* Check the TIM handle allocation */
   1968            if(htim == NULL)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE.N    ??HAL_TIM_OnePulse_Init_0
   1969            {
   1970              return HAL_ERROR;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xBD70             POP      {R4-R6,PC}
   1971            }
   1972          
   1973            /* Check the parameters */
   1974            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1975            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1976            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   1977            assert_param(IS_TIM_OPM_MODE(OnePulseMode));
   1978          
   1979            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_OnePulse_Init_0: (+1)
   \   0000000E   0xF104 0x0538      ADD      R5,R4,#+56
   \   00000012   0xF995 0x0001      LDRSB    R0,[R5, #+1]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD104             BNE.N    ??HAL_TIM_OnePulse_Init_1
   1980            {
   1981              /* Allocate lock resource and initialize it */
   1982              htim->Lock = HAL_UNLOCKED;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x7028             STRB     R0,[R5, #+0]
   1983              
   1984              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1985              HAL_TIM_OnePulse_MspInit(htim);
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       HAL_TIM_OnePulse_MspInit
   1986            }
   1987          
   1988            /* Set the TIM state */
   1989            htim->State= HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_OnePulse_Init_1: (+1)
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0x7068             STRB     R0,[R5, #+1]
   1990          
   1991            /* Configure the Time base in the One Pulse Mode */
   1992            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \   00000028   0x1D21             ADDS     R1,R4,#+4
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x.... 0x....      BL       TIM_Base_SetConfig
   1993          
   1994            /* Reset the OPM Bit */
   1995            htim->Instance->CR1 &= ~TIM_CR1_OPM;
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x6801             LDR      R1,[R0, #+0]
   \   00000034   0xF021 0x0108      BIC      R1,R1,#0x8
   \   00000038   0x6001             STR      R1,[R0, #+0]
   1996          
   1997            /* Configure the OPM Mode */
   1998            htim->Instance->CR1 |= OnePulseMode;
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6801             LDR      R1,[R0, #+0]
   \   0000003E   0x430E             ORRS     R6,R6,R1
   \   00000040   0x6006             STR      R6,[R0, #+0]
   1999          
   2000            /* Initialize the TIM state*/
   2001            htim->State= HAL_TIM_STATE_READY;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x7068             STRB     R0,[R5, #+1]
   2002          
   2003            return HAL_OK;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xBD70             POP      {R4-R6,PC}       ;; return
   2004          }
   2005          
   2006          /**
   2007            * @brief  DeInitializes the TIM One Pulse 
   2008            * @param  htim : TIM One Pulse handle
   2009            * @retval HAL status
   2010            */

   \                                 In section .text, align 2, keep-with-next
   2011          HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)
   2012          {
   \                     HAL_TIM_OnePulse_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2013            /* Check the parameters */
   2014            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2015          
   2016            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
   2017          
   2018            /* Disable the TIM Peripheral Clock */
   2019            __HAL_TIM_DISABLE(htim);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6A01             LDR      R1,[R0, #+32]
   \   0000000E   0xF241 0x1211      MOVW     R2,#+4369
   \   00000012   0x4211             TST      R1,R2
   \   00000014   0xD108             BNE.N    ??HAL_TIM_OnePulse_DeInit_0
   \   00000016   0x6A01             LDR      R1,[R0, #+32]
   \   00000018   0xF240 0x4244      MOVW     R2,#+1092
   \   0000001C   0x4211             TST      R1,R2
   \   0000001E   0xD103             BNE.N    ??HAL_TIM_OnePulse_DeInit_0
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x0849             LSRS     R1,R1,#+1
   \   00000024   0x0049             LSLS     R1,R1,#+1
   \   00000026   0x6001             STR      R1,[R0, #+0]
   2020          
   2021            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
   2022            HAL_TIM_OnePulse_MspDeInit(htim);
   \                     ??HAL_TIM_OnePulse_DeInit_0: (+1)
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_TIM_OnePulse_MspDeInit
   2023          
   2024            /* Change TIM state */
   2025            htim->State = HAL_TIM_STATE_RESET;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF884 0x0039      STRB     R0,[R4, #+57]
   2026          
   2027            /* Release Lock */
   2028            __HAL_UNLOCK(htim);
   2029          
   2030            return HAL_OK;
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
   2031          }
   2032          
   2033          /**
   2034            * @brief  Initializes the TIM One Pulse MSP.
   2035            * @param  htim : TIM handle
   2036            * @retval None
   2037            */

   \                                 In section .text, align 2
   2038          __weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
   2039          {
   2040            /* Prevent unused argument(s) compilation warning */
   2041            UNUSED(htim);
   2042            /* NOTE : This function Should not be modified, when the callback is needed,
   2043                      the HAL_TIM_OnePulse_MspInit could be implemented in the user file
   2044             */
   2045          }
   \                     HAL_TIM_OnePulse_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2046          
   2047          /**
   2048            * @brief  DeInitializes TIM One Pulse MSP.
   2049            * @param  htim : TIM handle
   2050            * @retval None
   2051            */

   \                                 In section .text, align 2
   2052          __weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
   2053          {
   2054            /* Prevent unused argument(s) compilation warning */
   2055            UNUSED(htim);
   2056            /* NOTE : This function Should not be modified, when the callback is needed,
   2057                      the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
   2058             */
   2059          }
   \                     HAL_TIM_OnePulse_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2060          
   2061          /**
   2062            * @brief  Starts the TIM One Pulse signal generation.
   2063            * @param  htim : TIM One Pulse handle
   2064            * @param  OutputChannel : TIM Channels to be enabled
   2065            *          This parameter can be one of the following values:
   2066            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2067            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2068            * @retval HAL status
   2069          */

   \                                 In section .text, align 2, keep-with-next
   2070          HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2071          {
   \                     HAL_TIM_OnePulse_Start: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2072            /* Enable the Capture compare and the Input Capture channels 
   2073              (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2074              if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2075              if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2076              in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
   2077          
   2078              No need to enable the counter, it's enabled automatically by hardware 
   2079              (the counter starts in response to a stimulus and generate a pulse */
   2080          
   2081            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x.... 0x....      BL       TIM_CCxChannelCmd
   2082            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x2104             MOVS     R1,#+4
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x.... 0x....      BL       TIM_CCxChannelCmd
   2083          
   2084            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x....             LDR.N    R1,??DataTable16  ;; 0x40012c00
   \   0000001C   0x4288             CMP      R0,R1
   \   0000001E   0xD002             BEQ.N    ??HAL_TIM_OnePulse_Start_0
   \   00000020   0x....             LDR.N    R1,??DataTable17  ;; 0x40013400
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xD101             BNE.N    ??HAL_TIM_OnePulse_Start_1
   \                     ??HAL_TIM_OnePulse_Start_0: (+1)
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0xE000             B.N      ??HAL_TIM_OnePulse_Start_2
   \                     ??HAL_TIM_OnePulse_Start_1: (+1)
   \   0000002A   0x2100             MOVS     R1,#+0
   \                     ??HAL_TIM_OnePulse_Start_2: (+1)
   \   0000002C   0x2900             CMP      R1,#+0
   \   0000002E   0xD003             BEQ.N    ??HAL_TIM_OnePulse_Start_3
   2085            {
   2086              /* Enable the main output */
   2087              __HAL_TIM_MOE_ENABLE(htim);
   \   00000030   0x6C41             LDR      R1,[R0, #+68]
   \   00000032   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000036   0x6441             STR      R1,[R0, #+68]
   2088            }
   2089          
   2090            /* Return function status */
   2091            return HAL_OK;
   \                     ??HAL_TIM_OnePulse_Start_3: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   2092          }
   2093          
   2094          /**
   2095            * @brief  Stops the TIM One Pulse signal generation.
   2096            * @param  htim : TIM One Pulse handle
   2097            * @param  OutputChannel : TIM Channels to be disable
   2098            *          This parameter can be one of the following values:
   2099            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2100            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2101            * @retval HAL status
   2102          */

   \                                 In section .text, align 2, keep-with-next
   2103          HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2104          {
   \                     HAL_TIM_OnePulse_Stop: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2105            /* Disable the Capture compare and the Input Capture channels
   2106            (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2107            if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2108            if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2109            in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
   2110          
   2111            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x4611             MOV      R1,R2
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x.... 0x....      BL       TIM_CCxChannelCmd
   2112            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0x2104             MOVS     R1,#+4
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x.... 0x....      BL       TIM_CCxChannelCmd
   2113          
   2114            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x....             LDR.N    R1,??DataTable16  ;; 0x40012c00
   \   0000001C   0x4288             CMP      R0,R1
   \   0000001E   0xD002             BEQ.N    ??HAL_TIM_OnePulse_Stop_0
   \   00000020   0x....             LDR.N    R1,??DataTable17  ;; 0x40013400
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xD101             BNE.N    ??HAL_TIM_OnePulse_Stop_1
   \                     ??HAL_TIM_OnePulse_Stop_0: (+1)
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0xE000             B.N      ??HAL_TIM_OnePulse_Stop_2
   \                     ??HAL_TIM_OnePulse_Stop_1: (+1)
   \   0000002A   0x2100             MOVS     R1,#+0
   \                     ??HAL_TIM_OnePulse_Stop_2: (+1)
   \   0000002C   0xF241 0x1211      MOVW     R2,#+4369
   \   00000030   0x2900             CMP      R1,#+0
   \   00000032   0xD00B             BEQ.N    ??HAL_TIM_OnePulse_Stop_3
   2115            {
   2116              /* Disable the Main Ouput */
   2117              __HAL_TIM_MOE_DISABLE(htim);
   \   00000034   0x6A01             LDR      R1,[R0, #+32]
   \   00000036   0x4211             TST      R1,R2
   \   00000038   0xD108             BNE.N    ??HAL_TIM_OnePulse_Stop_3
   \   0000003A   0x6A01             LDR      R1,[R0, #+32]
   \   0000003C   0xF240 0x4344      MOVW     R3,#+1092
   \   00000040   0x4219             TST      R1,R3
   \   00000042   0xD103             BNE.N    ??HAL_TIM_OnePulse_Stop_3
   \   00000044   0x6C41             LDR      R1,[R0, #+68]
   \   00000046   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   0000004A   0x6441             STR      R1,[R0, #+68]
   2118            }
   2119          
   2120            /* Disable the Peripheral */
   2121            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_OnePulse_Stop_3: (+1)
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6A01             LDR      R1,[R0, #+32]
   \   00000050   0x4211             TST      R1,R2
   \   00000052   0xD108             BNE.N    ??HAL_TIM_OnePulse_Stop_4
   \   00000054   0x6A01             LDR      R1,[R0, #+32]
   \   00000056   0xF240 0x4244      MOVW     R2,#+1092
   \   0000005A   0x4211             TST      R1,R2
   \   0000005C   0xD103             BNE.N    ??HAL_TIM_OnePulse_Stop_4
   \   0000005E   0x6801             LDR      R1,[R0, #+0]
   \   00000060   0x0849             LSRS     R1,R1,#+1
   \   00000062   0x0049             LSLS     R1,R1,#+1
   \   00000064   0x6001             STR      R1,[R0, #+0]
   2122          
   2123            /* Return function status */
   2124            return HAL_OK;
   \                     ??HAL_TIM_OnePulse_Stop_4: (+1)
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   2125          }
   2126          
   2127          /**
   2128            * @brief  Starts the TIM One Pulse signal generation in interrupt mode.
   2129            * @param  htim : TIM One Pulse handle
   2130            * @param  OutputChannel : TIM Channels to be enabled
   2131            *          This parameter can be one of the following values:
   2132            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2133            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2134            * @retval HAL status
   2135          */

   \                                 In section .text, align 2, keep-with-next
   2136          HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2137          {
   \                     HAL_TIM_OnePulse_Start_IT: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2138            /* Enable the Capture compare and the Input Capture channels 
   2139              (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2140              if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2141              if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2142              in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
   2143          
   2144              No need to enable the counter, it's enabled automatically by hardware 
   2145              (the counter starts in response to a stimulus and generate a pulse */
   2146          
   2147            /* Enable the TIM Capture/Compare 1 interrupt */
   2148            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x68C1             LDR      R1,[R0, #+12]
   \   00000008   0xF041 0x0102      ORR      R1,R1,#0x2
   \   0000000C   0x60C1             STR      R1,[R0, #+12]
   2149          
   2150            /* Enable the TIM Capture/Compare 2 interrupt */
   2151            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x68C1             LDR      R1,[R0, #+12]
   \   00000012   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000016   0x60C1             STR      R1,[R0, #+12]
   2152          
   2153            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \   00000018   0x2201             MOVS     R2,#+1
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x.... 0x....      BL       TIM_CCxChannelCmd
   2154            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \   00000022   0x2201             MOVS     R2,#+1
   \   00000024   0x2104             MOVS     R1,#+4
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x.... 0x....      BL       TIM_CCxChannelCmd
   2155          
   2156            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable22  ;; 0x40012c00
   \   00000032   0x4288             CMP      R0,R1
   \   00000034   0xD002             BEQ.N    ??HAL_TIM_OnePulse_Start_IT_0
   \   00000036   0x....             LDR.N    R1,??DataTable17  ;; 0x40013400
   \   00000038   0x4288             CMP      R0,R1
   \   0000003A   0xD101             BNE.N    ??HAL_TIM_OnePulse_Start_IT_1
   \                     ??HAL_TIM_OnePulse_Start_IT_0: (+1)
   \   0000003C   0x2101             MOVS     R1,#+1
   \   0000003E   0xE000             B.N      ??HAL_TIM_OnePulse_Start_IT_2
   \                     ??HAL_TIM_OnePulse_Start_IT_1: (+1)
   \   00000040   0x2100             MOVS     R1,#+0
   \                     ??HAL_TIM_OnePulse_Start_IT_2: (+1)
   \   00000042   0x2900             CMP      R1,#+0
   \   00000044   0xD003             BEQ.N    ??HAL_TIM_OnePulse_Start_IT_3
   2157            {
   2158              /* Enable the main output */
   2159              __HAL_TIM_MOE_ENABLE(htim);
   \   00000046   0x6C41             LDR      R1,[R0, #+68]
   \   00000048   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000004C   0x6441             STR      R1,[R0, #+68]
   2160            }
   2161          
   2162            /* Return function status */
   2163            return HAL_OK;
   \                     ??HAL_TIM_OnePulse_Start_IT_3: (+1)
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   2164          }
   2165          
   2166          /**
   2167            * @brief  Stops the TIM One Pulse signal generation in interrupt mode.
   2168            * @param  htim : TIM One Pulse handle
   2169            * @param  OutputChannel : TIM Channels to be enabled
   2170            *          This parameter can be one of the following values:
   2171            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2172            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2173            * @retval HAL status
   2174          */

   \                                 In section .text, align 2, keep-with-next
   2175          HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2176          {
   \                     HAL_TIM_OnePulse_Stop_IT: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2177            /* Disable the TIM Capture/Compare 1 interrupt */
   2178            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x68C1             LDR      R1,[R0, #+12]
   \   00000008   0xF021 0x0102      BIC      R1,R1,#0x2
   \   0000000C   0x60C1             STR      R1,[R0, #+12]
   2179          
   2180            /* Disable the TIM Capture/Compare 2 interrupt */
   2181            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x68C1             LDR      R1,[R0, #+12]
   \   00000012   0xF021 0x0104      BIC      R1,R1,#0x4
   \   00000016   0x60C1             STR      R1,[R0, #+12]
   2182          
   2183            /* Disable the Capture compare and the Input Capture channels 
   2184            (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2185            if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2186            if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2187            in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
   2188            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \   00000018   0x2200             MOVS     R2,#+0
   \   0000001A   0x4611             MOV      R1,R2
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x.... 0x....      BL       TIM_CCxChannelCmd
   2189            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \   00000022   0x2200             MOVS     R2,#+0
   \   00000024   0x2104             MOVS     R1,#+4
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x.... 0x....      BL       TIM_CCxChannelCmd
   2190          
   2191            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable22  ;; 0x40012c00
   \   00000032   0x4288             CMP      R0,R1
   \   00000034   0xD003             BEQ.N    ??HAL_TIM_OnePulse_Stop_IT_0
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable22_1  ;; 0x40013400
   \   0000003A   0x4288             CMP      R0,R1
   \   0000003C   0xD101             BNE.N    ??HAL_TIM_OnePulse_Stop_IT_1
   \                     ??HAL_TIM_OnePulse_Stop_IT_0: (+1)
   \   0000003E   0x2101             MOVS     R1,#+1
   \   00000040   0xE000             B.N      ??HAL_TIM_OnePulse_Stop_IT_2
   \                     ??HAL_TIM_OnePulse_Stop_IT_1: (+1)
   \   00000042   0x2100             MOVS     R1,#+0
   \                     ??HAL_TIM_OnePulse_Stop_IT_2: (+1)
   \   00000044   0xF241 0x1211      MOVW     R2,#+4369
   \   00000048   0x2900             CMP      R1,#+0
   \   0000004A   0xD00B             BEQ.N    ??HAL_TIM_OnePulse_Stop_IT_3
   2192            {
   2193              /* Disable the Main Ouput */
   2194              __HAL_TIM_MOE_DISABLE(htim);
   \   0000004C   0x6A01             LDR      R1,[R0, #+32]
   \   0000004E   0x4211             TST      R1,R2
   \   00000050   0xD108             BNE.N    ??HAL_TIM_OnePulse_Stop_IT_3
   \   00000052   0x6A01             LDR      R1,[R0, #+32]
   \   00000054   0xF240 0x4344      MOVW     R3,#+1092
   \   00000058   0x4219             TST      R1,R3
   \   0000005A   0xD103             BNE.N    ??HAL_TIM_OnePulse_Stop_IT_3
   \   0000005C   0x6C41             LDR      R1,[R0, #+68]
   \   0000005E   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000062   0x6441             STR      R1,[R0, #+68]
   2195            }
   2196          
   2197            /* Disable the Peripheral */
   2198             __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_OnePulse_Stop_IT_3: (+1)
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x6A01             LDR      R1,[R0, #+32]
   \   00000068   0x4211             TST      R1,R2
   \   0000006A   0xD108             BNE.N    ??HAL_TIM_OnePulse_Stop_IT_4
   \   0000006C   0x6A01             LDR      R1,[R0, #+32]
   \   0000006E   0xF240 0x4244      MOVW     R2,#+1092
   \   00000072   0x4211             TST      R1,R2
   \   00000074   0xD103             BNE.N    ??HAL_TIM_OnePulse_Stop_IT_4
   \   00000076   0x6801             LDR      R1,[R0, #+0]
   \   00000078   0x0849             LSRS     R1,R1,#+1
   \   0000007A   0x0049             LSLS     R1,R1,#+1
   \   0000007C   0x6001             STR      R1,[R0, #+0]
   2199          
   2200            /* Return function status */
   2201            return HAL_OK;
   \                     ??HAL_TIM_OnePulse_Stop_IT_4: (+1)
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   2202          }
   2203          
   2204          /**
   2205            * @}
   2206            */
   2207          
   2208          /** @defgroup TIM_Exported_Functions_Group6 Time Encoder functions 
   2209           *  @brief    Time Encoder functions 
   2210           *
   2211          @verbatim 
   2212            ==============================================================================
   2213                                    ##### Time Encoder functions #####
   2214            ==============================================================================
   2215            [..]
   2216              This section provides functions allowing to:
   2217              (+) Initialize and configure the TIM Encoder.
   2218              (+) De-initialize the TIM Encoder.
   2219              (+) Start the Time Encoder.
   2220              (+) Stop the Time Encoder.
   2221              (+) Start the Time Encoder and enable interrupt.
   2222              (+) Stop the Time Encoder and disable interrupt.
   2223              (+) Start the Time Encoder and enable DMA transfer.
   2224              (+) Stop the Time Encoder and disable DMA transfer.
   2225          
   2226          @endverbatim
   2227            * @{
   2228            */
   2229          /**
   2230            * @brief  Initializes the TIM Encoder Interface and create the associated handle.
   2231            * @param  htim : TIM Encoder Interface handle
   2232            * @param  sConfig : TIM Encoder Interface configuration structure
   2233            * @retval HAL status
   2234            */

   \                                 In section .text, align 2, keep-with-next
   2235          HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef* sConfig)
   2236          {
   \                     HAL_TIM_Encoder_Init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
   2237            uint32_t tmpsmcr = 0;
   2238            uint32_t tmpccmr1 = 0;
   2239            uint32_t tmpccer = 0;
   2240          
   2241            /* Check the TIM handle allocation */
   2242            if(htim == NULL)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE.N    ??HAL_TIM_Encoder_Init_0
   2243            {
   2244              return HAL_ERROR;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xBDF2             POP      {R1,R4-R7,PC}
   2245            }
   2246          
   2247            /* Check the parameters */
   2248            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2249            assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));
   2250            assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));
   2251            assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));
   2252            assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
   2253            assert_param(IS_TIM_IC_POLARITY(sConfig->IC2Polarity));
   2254            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
   2255            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
   2256            assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
   2257            assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));
   2258          
   2259            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_Encoder_Init_0: (+1)
   \   0000000E   0xF104 0x0538      ADD      R5,R4,#+56
   \   00000012   0xF995 0x0001      LDRSB    R0,[R5, #+1]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD104             BNE.N    ??HAL_TIM_Encoder_Init_1
   2260            {
   2261              /* Allocate lock resource and initialize it */
   2262              htim->Lock = HAL_UNLOCKED;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x7028             STRB     R0,[R5, #+0]
   2263              
   2264              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   2265              HAL_TIM_Encoder_MspInit(htim);
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       HAL_TIM_Encoder_MspInit
   2266            }
   2267          
   2268            /* Set the TIM state */
   2269            htim->State= HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Encoder_Init_1: (+1)
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0x7068             STRB     R0,[R5, #+1]
   2270          
   2271            /* Reset the SMS bits */
   2272            htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x6881             LDR      R1,[R0, #+8]
   \   0000002C   0x08C9             LSRS     R1,R1,#+3
   \   0000002E   0x00C9             LSLS     R1,R1,#+3
   \   00000030   0x6081             STR      R1,[R0, #+8]
   2273          
   2274            /* Configure the Time base in the Encoder Mode */
   2275            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \   00000032   0x1D21             ADDS     R1,R4,#+4
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x.... 0x....      BL       TIM_Base_SetConfig
   2276          
   2277            /* Get the TIMx SMCR register value */
   2278            tmpsmcr = htim->Instance->SMCR;
   \   0000003A   0x6821             LDR      R1,[R4, #+0]
   \   0000003C   0x688A             LDR      R2,[R1, #+8]
   2279          
   2280            /* Get the TIMx CCMR1 register value */
   2281            tmpccmr1 = htim->Instance->CCMR1;
   \   0000003E   0x698F             LDR      R7,[R1, #+24]
   2282          
   2283            /* Get the TIMx CCER register value */
   2284            tmpccer = htim->Instance->CCER;
   \   00000040   0x6A0B             LDR      R3,[R1, #+32]
   2285          
   2286            /* Set the encoder Mode */
   2287            tmpsmcr |= sConfig->EncoderMode;
   2288          
   2289            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   2290            tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
   2291            tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8));
   2292          
   2293            /* Set the the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
   2294            tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
   2295            tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
   2296            tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8);
   2297            tmpccmr1 |= (sConfig->IC1Filter << 4) | (sConfig->IC2Filter << 12);
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable22_2  ;; 0xfffffcfc
   \   00000046   0x4007             ANDS     R7,R0,R7
   \   00000048   0x68B0             LDR      R0,[R6, #+8]
   \   0000004A   0x4307             ORRS     R7,R0,R7
   \   0000004C   0x69B0             LDR      R0,[R6, #+24]
   \   0000004E   0xEA47 0x2700      ORR      R7,R7,R0, LSL #+8
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable22_3  ;; 0xffff0303
   \   00000056   0x4007             ANDS     R7,R0,R7
   \   00000058   0x68F0             LDR      R0,[R6, #+12]
   \   0000005A   0x4307             ORRS     R7,R0,R7
   \   0000005C   0x69F0             LDR      R0,[R6, #+28]
   \   0000005E   0xEA47 0x2700      ORR      R7,R7,R0, LSL #+8
   \   00000062   0x6930             LDR      R0,[R6, #+16]
   \   00000064   0xEA47 0x1700      ORR      R7,R7,R0, LSL #+4
   \   00000068   0x6A30             LDR      R0,[R6, #+32]
   \   0000006A   0xEA47 0x3700      ORR      R7,R7,R0, LSL #+12
   2298          
   2299            /* Set the TI1 and the TI2 Polarities */
   2300            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
   2301            tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
   2302            tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4);
   \   0000006E   0xF023 0x03AA      BIC      R3,R3,#0xAA
   \   00000072   0x6870             LDR      R0,[R6, #+4]
   \   00000074   0x4303             ORRS     R3,R0,R3
   \   00000076   0x6970             LDR      R0,[R6, #+20]
   \   00000078   0xEA43 0x1300      ORR      R3,R3,R0, LSL #+4
   2303          
   2304            /* Write to TIMx SMCR */
   2305            htim->Instance->SMCR = tmpsmcr;
   \   0000007C   0x6830             LDR      R0,[R6, #+0]
   \   0000007E   0x4302             ORRS     R2,R0,R2
   \   00000080   0x608A             STR      R2,[R1, #+8]
   2306          
   2307            /* Write to TIMx CCMR1 */
   2308            htim->Instance->CCMR1 = tmpccmr1;
   \   00000082   0x6820             LDR      R0,[R4, #+0]
   \   00000084   0x6187             STR      R7,[R0, #+24]
   2309          
   2310            /* Write to TIMx CCER */
   2311            htim->Instance->CCER = tmpccer;
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x6203             STR      R3,[R0, #+32]
   2312          
   2313            /* Initialize the TIM state*/
   2314            htim->State= HAL_TIM_STATE_READY;
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0x7068             STRB     R0,[R5, #+1]
   2315          
   2316            return HAL_OK;
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   2317          }
   2318          
   2319          
   2320          /**
   2321            * @brief  DeInitializes the TIM Encoder interface 
   2322            * @param  htim : TIM Encoder handle
   2323            * @retval HAL status
   2324            */

   \                                 In section .text, align 2, keep-with-next
   2325          HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
   2326          {
   \                     HAL_TIM_Encoder_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2327            /* Check the parameters */
   2328            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2329          
   2330            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
   2331          
   2332            /* Disable the TIM Peripheral Clock */
   2333            __HAL_TIM_DISABLE(htim);
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6A01             LDR      R1,[R0, #+32]
   \   0000000E   0xF241 0x1211      MOVW     R2,#+4369
   \   00000012   0x4211             TST      R1,R2
   \   00000014   0xD108             BNE.N    ??HAL_TIM_Encoder_DeInit_0
   \   00000016   0x6A01             LDR      R1,[R0, #+32]
   \   00000018   0xF240 0x4244      MOVW     R2,#+1092
   \   0000001C   0x4211             TST      R1,R2
   \   0000001E   0xD103             BNE.N    ??HAL_TIM_Encoder_DeInit_0
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x0849             LSRS     R1,R1,#+1
   \   00000024   0x0049             LSLS     R1,R1,#+1
   \   00000026   0x6001             STR      R1,[R0, #+0]
   2334          
   2335            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
   2336            HAL_TIM_Encoder_MspDeInit(htim);
   \                     ??HAL_TIM_Encoder_DeInit_0: (+1)
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_TIM_Encoder_MspDeInit
   2337          
   2338            /* Change TIM state */
   2339            htim->State = HAL_TIM_STATE_RESET;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF884 0x0039      STRB     R0,[R4, #+57]
   2340          
   2341            /* Release Lock */
   2342            __HAL_UNLOCK(htim);
   2343          
   2344            return HAL_OK;
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
   2345          }
   2346          
   2347          /**
   2348            * @brief  Initializes the TIM Encoder Interface MSP.
   2349            * @param  htim : TIM handle
   2350            * @retval None
   2351            */

   \                                 In section .text, align 2
   2352          __weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
   2353          {
   2354            /* Prevent unused argument(s) compilation warning */
   2355            UNUSED(htim);
   2356            /* NOTE : This function Should not be modified, when the callback is needed,
   2357                      the HAL_TIM_Encoder_MspInit could be implemented in the user file
   2358             */
   2359          }
   \                     HAL_TIM_Encoder_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2360          
   2361          /**
   2362            * @brief  DeInitializes TIM Encoder Interface MSP.
   2363            * @param  htim : TIM handle
   2364            * @retval None
   2365            */

   \                                 In section .text, align 2
   2366          __weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
   2367          {
   2368            /* Prevent unused argument(s) compilation warning */
   2369            UNUSED(htim);
   2370            /* NOTE : This function Should not be modified, when the callback is needed,
   2371                      the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
   2372             */
   2373          }
   \                     HAL_TIM_Encoder_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2374          
   2375          /**
   2376            * @brief  Starts the TIM Encoder Interface.
   2377            * @param  htim : TIM Encoder Interface handle
   2378            * @param  Channel : TIM Channels to be enabled
   2379            *          This parameter can be one of the following values:
   2380            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2381            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2382            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2383            * @retval HAL status
   2384          */

   \                                 In section .text, align 2, keep-with-next
   2385          HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   2386          {
   \                     HAL_TIM_Encoder_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2387            /* Check the parameters */
   2388            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2389          
   2390            /* Enable the encoder interface channels */
   2391            switch (Channel)
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD002             BEQ.N    ??HAL_TIM_Encoder_Start_0
   \   00000008   0x2904             CMP      R1,#+4
   \   0000000A   0xD006             BEQ.N    ??HAL_TIM_Encoder_Start_1
   \   0000000C   0xE00B             B.N      ??HAL_TIM_Encoder_Start_2
   2392            {
   2393              case TIM_CHANNEL_1:
   2394            {
   2395              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_0: (+1)
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x.... 0x....      BL       TIM_CCxChannelCmd
   2396                break;
   \   00000018   0xE00F             B.N      ??HAL_TIM_Encoder_Start_3
   2397            }
   2398              case TIM_CHANNEL_2:
   2399            {
   2400              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_1: (+1)
   \   0000001A   0x2201             MOVS     R2,#+1
   \   0000001C   0x2104             MOVS     R1,#+4
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x.... 0x....      BL       TIM_CCxChannelCmd
   2401                break;
   \   00000024   0xE009             B.N      ??HAL_TIM_Encoder_Start_3
   2402            }
   2403              default :
   2404            {
   2405               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_2: (+1)
   \   00000026   0x2201             MOVS     R2,#+1
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x.... 0x....      BL       TIM_CCxChannelCmd
   2406               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \   00000030   0x2201             MOVS     R2,#+1
   \   00000032   0x2104             MOVS     R1,#+4
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x.... 0x....      BL       TIM_CCxChannelCmd
   2407               break;
   2408              }
   2409            }
   2410            /* Enable the Peripheral */
   2411            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_Encoder_Start_3: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6801             LDR      R1,[R0, #+0]
   \   0000003E   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000042   0x6001             STR      R1,[R0, #+0]
   2412          
   2413            /* Return function status */
   2414            return HAL_OK;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xBD10             POP      {R4,PC}          ;; return
   2415          }
   2416          
   2417          /**
   2418            * @brief  Stops the TIM Encoder Interface.
   2419            * @param  htim : TIM Encoder Interface handle
   2420            * @param  Channel : TIM Channels to be disabled
   2421            *          This parameter can be one of the following values:
   2422            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2423            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2424            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2425            * @retval HAL status
   2426          */

   \                                 In section .text, align 2, keep-with-next
   2427          HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   2428          {
   \                     HAL_TIM_Encoder_Stop: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2429            /* Check the parameters */
   2430              assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2431          
   2432             /* Disable the Input Capture channels 1 and 2
   2433              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
   2434            switch (Channel)
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD002             BEQ.N    ??HAL_TIM_Encoder_Stop_0
   \   00000008   0x2904             CMP      R1,#+4
   \   0000000A   0xD006             BEQ.N    ??HAL_TIM_Encoder_Stop_1
   \   0000000C   0xE00B             B.N      ??HAL_TIM_Encoder_Stop_2
   2435            {
   2436              case TIM_CHANNEL_1:
   2437            {
   2438               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_0: (+1)
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0x4611             MOV      R1,R2
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x.... 0x....      BL       TIM_CCxChannelCmd
   2439                break;
   \   00000018   0xE00F             B.N      ??HAL_TIM_Encoder_Stop_3
   2440            }
   2441              case TIM_CHANNEL_2:
   2442            {
   2443              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_1: (+1)
   \   0000001A   0x2200             MOVS     R2,#+0
   \   0000001C   0x2104             MOVS     R1,#+4
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x.... 0x....      BL       TIM_CCxChannelCmd
   2444                break;
   \   00000024   0xE009             B.N      ??HAL_TIM_Encoder_Stop_3
   2445            }
   2446              default :
   2447            {
   2448              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_2: (+1)
   \   00000026   0x2200             MOVS     R2,#+0
   \   00000028   0x4611             MOV      R1,R2
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x.... 0x....      BL       TIM_CCxChannelCmd
   2449              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \   00000030   0x2200             MOVS     R2,#+0
   \   00000032   0x2104             MOVS     R1,#+4
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x.... 0x....      BL       TIM_CCxChannelCmd
   2450               break;
   2451              }
   2452            }
   2453          
   2454            /* Disable the Peripheral */
   2455            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_Encoder_Stop_3: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6A01             LDR      R1,[R0, #+32]
   \   0000003E   0xF241 0x1211      MOVW     R2,#+4369
   \   00000042   0x4211             TST      R1,R2
   \   00000044   0xD108             BNE.N    ??HAL_TIM_Encoder_Stop_4
   \   00000046   0x6A01             LDR      R1,[R0, #+32]
   \   00000048   0xF240 0x4244      MOVW     R2,#+1092
   \   0000004C   0x4211             TST      R1,R2
   \   0000004E   0xD103             BNE.N    ??HAL_TIM_Encoder_Stop_4
   \   00000050   0x6801             LDR      R1,[R0, #+0]
   \   00000052   0x0849             LSRS     R1,R1,#+1
   \   00000054   0x0049             LSLS     R1,R1,#+1
   \   00000056   0x6001             STR      R1,[R0, #+0]
   2456          
   2457            /* Return function status */
   2458            return HAL_OK;
   \                     ??HAL_TIM_Encoder_Stop_4: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   2459          }
   2460          
   2461          /**
   2462            * @brief  Starts the TIM Encoder Interface in interrupt mode.
   2463            * @param  htim : TIM Encoder Interface handle
   2464            * @param  Channel : TIM Channels to be enabled
   2465            *          This parameter can be one of the following values:
   2466            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2467            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2468            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2469            * @retval HAL status
   2470          */

   \                                 In section .text, align 2, keep-with-next
   2471          HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2472          {
   \                     HAL_TIM_Encoder_Start_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2473            /* Check the parameters */
   2474            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2475          
   2476            /* Enable the encoder interface channels */
   2477            /* Enable the capture compare Interrupts 1 and/or 2 */
   2478            switch (Channel)
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD002             BEQ.N    ??HAL_TIM_Encoder_Start_IT_0
   \   00000008   0x2904             CMP      R1,#+4
   \   0000000A   0xD00B             BEQ.N    ??HAL_TIM_Encoder_Start_IT_1
   \   0000000C   0xE015             B.N      ??HAL_TIM_Encoder_Start_IT_2
   2479            {
   2480              case TIM_CHANNEL_1:
   2481            {
   2482              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_IT_0: (+1)
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x.... 0x....      BL       TIM_CCxChannelCmd
   2483              __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x68C1             LDR      R1,[R0, #+12]
   \   0000001C   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000020   0x60C1             STR      R1,[R0, #+12]
   2484                break;
   \   00000022   0xE01E             B.N      ??HAL_TIM_Encoder_Start_IT_3
   2485            }
   2486              case TIM_CHANNEL_2:
   2487            {
   2488              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_IT_1: (+1)
   \   00000024   0x2201             MOVS     R2,#+1
   \   00000026   0x2104             MOVS     R1,#+4
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x.... 0x....      BL       TIM_CCxChannelCmd
   2489              __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x68C1             LDR      R1,[R0, #+12]
   \   00000032   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000036   0x60C1             STR      R1,[R0, #+12]
   2490                break;
   \   00000038   0xE013             B.N      ??HAL_TIM_Encoder_Start_IT_3
   2491            }
   2492              default :
   2493            {
   2494               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_IT_2: (+1)
   \   0000003A   0x2201             MOVS     R2,#+1
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x.... 0x....      BL       TIM_CCxChannelCmd
   2495               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \   00000044   0x2201             MOVS     R2,#+1
   \   00000046   0x2104             MOVS     R1,#+4
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x.... 0x....      BL       TIM_CCxChannelCmd
   2496               __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x68C1             LDR      R1,[R0, #+12]
   \   00000052   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000056   0x60C1             STR      R1,[R0, #+12]
   2497               __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x68C1             LDR      R1,[R0, #+12]
   \   0000005C   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000060   0x60C1             STR      R1,[R0, #+12]
   2498               break;
   2499              }
   2500            }
   2501          
   2502            /* Enable the Peripheral */
   2503            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_Encoder_Start_IT_3: (+1)
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x6801             LDR      R1,[R0, #+0]
   \   00000066   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000006A   0x6001             STR      R1,[R0, #+0]
   2504          
   2505            /* Return function status */
   2506            return HAL_OK;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xBD10             POP      {R4,PC}          ;; return
   2507          }
   2508          
   2509          /**
   2510            * @brief  Stops the TIM Encoder Interface in interrupt mode.
   2511            * @param  htim : TIM Encoder Interface handle
   2512            * @param  Channel : TIM Channels to be disabled
   2513            *          This parameter can be one of the following values:
   2514            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2515            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2516            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2517            * @retval HAL status
   2518          */

   \                                 In section .text, align 2, keep-with-next
   2519          HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2520          {
   \                     HAL_TIM_Encoder_Stop_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2521            /* Check the parameters */
   2522            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2523          
   2524            /* Disable the Input Capture channels 1 and 2
   2525              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
   2526            if(Channel == TIM_CHANNEL_1)
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD109             BNE.N    ??HAL_TIM_Encoder_Stop_IT_0
   2527            {
   2528              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x4611             MOV      R1,R2
   \   0000000E   0x.... 0x....      BL       TIM_CCxChannelCmd
   2529          
   2530              /* Disable the capture compare Interrupts 1 */
   2531            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x68C1             LDR      R1,[R0, #+12]
   \   00000016   0xF021 0x0102      BIC      R1,R1,#0x2
   \   0000001A   0x60C1             STR      R1,[R0, #+12]
   \   0000001C   0xE01E             B.N      ??HAL_TIM_Encoder_Stop_IT_1
   2532            }
   2533            else if(Channel == TIM_CHANNEL_2)
   \                     ??HAL_TIM_Encoder_Stop_IT_0: (+1)
   \   0000001E   0x2904             CMP      R1,#+4
   \   00000020   0xD109             BNE.N    ??HAL_TIM_Encoder_Stop_IT_2
   2534            {
   2535              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \   00000022   0x2200             MOVS     R2,#+0
   \   00000024   0x2104             MOVS     R1,#+4
   \   00000026   0x.... 0x....      BL       TIM_CCxChannelCmd
   2536          
   2537              /* Disable the capture compare Interrupts 2 */
   2538            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x68C1             LDR      R1,[R0, #+12]
   \   0000002E   0xF021 0x0104      BIC      R1,R1,#0x4
   \   00000032   0x60C1             STR      R1,[R0, #+12]
   \   00000034   0xE012             B.N      ??HAL_TIM_Encoder_Stop_IT_1
   2539            }
   2540            else
   2541            {
   2542              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_IT_2: (+1)
   \   00000036   0x2200             MOVS     R2,#+0
   \   00000038   0x4611             MOV      R1,R2
   \   0000003A   0x.... 0x....      BL       TIM_CCxChannelCmd
   2543              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0x2104             MOVS     R1,#+4
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x.... 0x....      BL       TIM_CCxChannelCmd
   2544          
   2545              /* Disable the capture compare Interrupts 1 and 2 */
   2546              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x68C1             LDR      R1,[R0, #+12]
   \   0000004C   0xF021 0x0102      BIC      R1,R1,#0x2
   \   00000050   0x60C1             STR      R1,[R0, #+12]
   2547              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x68C1             LDR      R1,[R0, #+12]
   \   00000056   0xF021 0x0104      BIC      R1,R1,#0x4
   \   0000005A   0x60C1             STR      R1,[R0, #+12]
   2548            }
   2549          
   2550            /* Disable the Peripheral */
   2551            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_Encoder_Stop_IT_1: (+1)
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6A01             LDR      R1,[R0, #+32]
   \   00000060   0xF241 0x1211      MOVW     R2,#+4369
   \   00000064   0x4211             TST      R1,R2
   \   00000066   0xD108             BNE.N    ??HAL_TIM_Encoder_Stop_IT_3
   \   00000068   0x6A01             LDR      R1,[R0, #+32]
   \   0000006A   0xF240 0x4244      MOVW     R2,#+1092
   \   0000006E   0x4211             TST      R1,R2
   \   00000070   0xD103             BNE.N    ??HAL_TIM_Encoder_Stop_IT_3
   \   00000072   0x6801             LDR      R1,[R0, #+0]
   \   00000074   0x0849             LSRS     R1,R1,#+1
   \   00000076   0x0049             LSLS     R1,R1,#+1
   \   00000078   0x6001             STR      R1,[R0, #+0]
   2552          
   2553            /* Change the htim state */
   2554            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Encoder_Stop_IT_3: (+1)
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0xF884 0x0039      STRB     R0,[R4, #+57]
   2555          
   2556            /* Return function status */
   2557            return HAL_OK;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xBD10             POP      {R4,PC}          ;; return
   2558          }
   2559          
   2560          /**
   2561            * @brief  Starts the TIM Encoder Interface in DMA mode.
   2562            * @param  htim : TIM Encoder Interface handle
   2563            * @param  Channel : TIM Channels to be enabled
   2564            *          This parameter can be one of the following values:
   2565            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2566            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2567            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2568            * @param  pData1 : The destination Buffer address for IC1.
   2569            * @param  pData2 : The destination Buffer address for IC2.
   2570            * @param  Length : The length of data to be transferred from TIM peripheral to memory.
   2571            * @retval HAL status
   2572          */

   \                                 In section .text, align 2, keep-with-next
   2573          HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1, uint32_t *pData2, uint16_t Length)
   2574          {
   \                     HAL_TIM_Encoder_Start_DMA: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4606             MOV      R6,R0
   \   00000006   0x461C             MOV      R4,R3
   2575            /* Check the parameters */
   2576            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2577          
   2578            if((htim->State == HAL_TIM_STATE_BUSY))
   \   00000008   0xF996 0x0039      LDRSB    R0,[R6, #+57]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD101             BNE.N    ??HAL_TIM_Encoder_Start_DMA_0
   2579            {
   2580               return HAL_BUSY;
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE08C             B.N      ??HAL_TIM_Encoder_Start_DMA_1
   2581            }
   \                     ??HAL_TIM_Encoder_Start_DMA_0: (+1)
   \   00000014   0x9D06             LDR      R5,[SP, #+24]
   2582            else if((htim->State == HAL_TIM_STATE_READY))
   \   00000016   0xF996 0x0039      LDRSB    R0,[R6, #+57]
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD10A             BNE.N    ??HAL_TIM_Encoder_Start_DMA_2
   2583            {
   2584              if((((pData1 == 0) || (pData2 == 0) )) && (Length > 0))
   \   0000001E   0x2A00             CMP      R2,#+0
   \   00000020   0xD001             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_3
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xD103             BNE.N    ??HAL_TIM_Encoder_Start_DMA_4
   \                     ??HAL_TIM_Encoder_Start_DMA_3: (+1)
   \   00000026   0x0028             MOVS     R0,R5
   \   00000028   0xD001             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_4
   2585              {
   2586                return HAL_ERROR;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xE07F             B.N      ??HAL_TIM_Encoder_Start_DMA_1
   2587              }
   2588              else
   2589              {
   2590                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Encoder_Start_DMA_4: (+1)
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0xF886 0x0039      STRB     R0,[R6, #+57]
   2591              }
   2592            }
   2593          
   2594            switch (Channel)
   \                     ??HAL_TIM_Encoder_Start_DMA_2: (+1)
   \   00000034   0x2900             CMP      R1,#+0
   \   00000036   0xD004             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_5
   \   00000038   0x2904             CMP      R1,#+4
   \   0000003A   0xD021             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_6
   \   0000003C   0x2918             CMP      R1,#+24
   \   0000003E   0xD03F             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_7
   \   00000040   0xE074             B.N      ??HAL_TIM_Encoder_Start_DMA_8
   2595            {
   2596              case TIM_CHANNEL_1:
   2597              {
   2598                /* Set the DMA Period elapsed callback */
   2599                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_Encoder_Start_DMA_5: (+1)
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000046   0x6A31             LDR      R1,[R6, #+32]
   \   00000048   0x6288             STR      R0,[R1, #+40]
   2600          
   2601                /* Set the DMA error callback */
   2602                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable23
   \   0000004E   0x6A31             LDR      R1,[R6, #+32]
   \   00000050   0x6308             STR      R0,[R1, #+48]
   2603          
   2604                /* Enable the DMA channel */
   2605                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t )pData1, Length);
   \   00000052   0x462B             MOV      R3,R5
   \   00000054   0x6830             LDR      R0,[R6, #+0]
   \   00000056   0xF100 0x0134      ADD      R1,R0,#+52
   \   0000005A   0x6A30             LDR      R0,[R6, #+32]
   \   0000005C   0x.... 0x....      BL       HAL_DMA_Start_IT
   2606          
   2607                /* Enable the TIM Input Capture DMA request */
   2608                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   00000060   0x6830             LDR      R0,[R6, #+0]
   \   00000062   0x68C1             LDR      R1,[R0, #+12]
   \   00000064   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000068   0x60C1             STR      R1,[R0, #+12]
   2609          
   2610                /* Enable the Peripheral */
   2611                __HAL_TIM_ENABLE(htim);
   \   0000006A   0x6830             LDR      R0,[R6, #+0]
   \   0000006C   0x6801             LDR      R1,[R0, #+0]
   \   0000006E   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000072   0x6001             STR      R1,[R0, #+0]
   2612          
   2613                /* Enable the Capture compare channel */
   2614                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \   00000074   0x2201             MOVS     R2,#+1
   \   00000076   0x2100             MOVS     R1,#+0
   \   00000078   0x6830             LDR      R0,[R6, #+0]
   \   0000007A   0x.... 0x....      BL       TIM_CCxChannelCmd
   2615              }
   2616              break;
   \   0000007E   0xE055             B.N      ??HAL_TIM_Encoder_Start_DMA_8
   2617          
   2618              case TIM_CHANNEL_2:
   2619              {
   2620                /* Set the DMA Period elapsed callback */
   2621                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_Encoder_Start_DMA_6: (+1)
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000084   0x6A71             LDR      R1,[R6, #+36]
   \   00000086   0x6288             STR      R0,[R1, #+40]
   2622          
   2623                /* Set the DMA error callback */
   2624                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError;
   \   00000088   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   0000008C   0x6A71             LDR      R1,[R6, #+36]
   \   0000008E   0x6308             STR      R0,[R1, #+48]
   2625                /* Enable the DMA channel */
   2626                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
   \   00000090   0x462B             MOV      R3,R5
   \   00000092   0x4622             MOV      R2,R4
   \   00000094   0x6830             LDR      R0,[R6, #+0]
   \   00000096   0xF100 0x0138      ADD      R1,R0,#+56
   \   0000009A   0x6A70             LDR      R0,[R6, #+36]
   \   0000009C   0x.... 0x....      BL       HAL_DMA_Start_IT
   2627          
   2628                /* Enable the TIM Input Capture  DMA request */
   2629                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   000000A0   0x6830             LDR      R0,[R6, #+0]
   \   000000A2   0x68C1             LDR      R1,[R0, #+12]
   \   000000A4   0xF441 0x6180      ORR      R1,R1,#0x400
   \   000000A8   0x60C1             STR      R1,[R0, #+12]
   2630          
   2631                /* Enable the Peripheral */
   2632                __HAL_TIM_ENABLE(htim);
   \   000000AA   0x6830             LDR      R0,[R6, #+0]
   \   000000AC   0x6801             LDR      R1,[R0, #+0]
   \   000000AE   0xF041 0x0101      ORR      R1,R1,#0x1
   \   000000B2   0x6001             STR      R1,[R0, #+0]
   2633          
   2634                /* Enable the Capture compare channel */
   2635                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \   000000B4   0x2201             MOVS     R2,#+1
   \   000000B6   0x2104             MOVS     R1,#+4
   \   000000B8   0x6830             LDR      R0,[R6, #+0]
   \   000000BA   0x.... 0x....      BL       TIM_CCxChannelCmd
   2636              }
   2637              break;
   \   000000BE   0xE035             B.N      ??HAL_TIM_Encoder_Start_DMA_8
   2638          
   2639              case TIM_CHANNEL_ALL:
   2640              {
   2641                /* Set the DMA Period elapsed callback */
   2642                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_Encoder_Start_DMA_7: (+1)
   \   000000C0   0x.... 0x....      ADR.W    R7,TIM_DMACaptureCplt
   \   000000C4   0x6A30             LDR      R0,[R6, #+32]
   \   000000C6   0x6287             STR      R7,[R0, #+40]
   2643          
   2644                /* Set the DMA error callback */
   2645                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   000000C8   0x.... 0x....      ADR.W    R8,TIM_DMAError
   \   000000CC   0x6A30             LDR      R0,[R6, #+32]
   \   000000CE   0xF8C0 0x8030      STR      R8,[R0, #+48]
   2646          
   2647                /* Enable the DMA channel */
   2648                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length);
   \   000000D2   0x462B             MOV      R3,R5
   \   000000D4   0x6830             LDR      R0,[R6, #+0]
   \   000000D6   0xF100 0x0134      ADD      R1,R0,#+52
   \   000000DA   0x6A30             LDR      R0,[R6, #+32]
   \   000000DC   0x.... 0x....      BL       HAL_DMA_Start_IT
   2649          
   2650                /* Set the DMA Period elapsed callback */
   2651                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   \   000000E0   0x6A70             LDR      R0,[R6, #+36]
   \   000000E2   0x6287             STR      R7,[R0, #+40]
   2652          
   2653                /* Set the DMA error callback */
   2654                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \   000000E4   0x6A70             LDR      R0,[R6, #+36]
   \   000000E6   0xF8C0 0x8030      STR      R8,[R0, #+48]
   2655          
   2656                /* Enable the DMA channel */
   2657                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
   \   000000EA   0x462B             MOV      R3,R5
   \   000000EC   0x4622             MOV      R2,R4
   \   000000EE   0x6830             LDR      R0,[R6, #+0]
   \   000000F0   0xF100 0x0138      ADD      R1,R0,#+56
   \   000000F4   0x6A70             LDR      R0,[R6, #+36]
   \   000000F6   0x.... 0x....      BL       HAL_DMA_Start_IT
   2658          
   2659               /* Enable the Peripheral */
   2660                __HAL_TIM_ENABLE(htim);
   \   000000FA   0x6830             LDR      R0,[R6, #+0]
   \   000000FC   0x6801             LDR      R1,[R0, #+0]
   \   000000FE   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000102   0x6001             STR      R1,[R0, #+0]
   2661          
   2662                /* Enable the Capture compare channel */
   2663                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \   00000104   0x2201             MOVS     R2,#+1
   \   00000106   0x2100             MOVS     R1,#+0
   \   00000108   0x6830             LDR      R0,[R6, #+0]
   \   0000010A   0x.... 0x....      BL       TIM_CCxChannelCmd
   2664                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \   0000010E   0x2201             MOVS     R2,#+1
   \   00000110   0x2104             MOVS     R1,#+4
   \   00000112   0x6830             LDR      R0,[R6, #+0]
   \   00000114   0x.... 0x....      BL       TIM_CCxChannelCmd
   2665          
   2666                /* Enable the TIM Input Capture  DMA request */
   2667                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   00000118   0x6830             LDR      R0,[R6, #+0]
   \   0000011A   0x68C1             LDR      R1,[R0, #+12]
   \   0000011C   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000120   0x60C1             STR      R1,[R0, #+12]
   2668                /* Enable the TIM Input Capture  DMA request */
   2669                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   00000122   0x6830             LDR      R0,[R6, #+0]
   \   00000124   0x68C1             LDR      R1,[R0, #+12]
   \   00000126   0xF441 0x6180      ORR      R1,R1,#0x400
   \   0000012A   0x60C1             STR      R1,[R0, #+12]
   2670              }
   2671              break;
   2672          
   2673              default:
   2674              break;
   2675            }
   2676            /* Return function status */
   2677            return HAL_OK;
   \                     ??HAL_TIM_Encoder_Start_DMA_8: (+1)
   \   0000012C   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_Encoder_Start_DMA_1: (+1)
   \   0000012E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2678          }
   2679          
   2680          /**
   2681            * @brief  Stops the TIM Encoder Interface in DMA mode.
   2682            * @param  htim : TIM Encoder Interface handle
   2683            * @param  Channel : TIM Channels to be enabled
   2684            *          This parameter can be one of the following values:
   2685            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2686            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2687            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2688            * @retval HAL status
   2689          */

   \                                 In section .text, align 2, keep-with-next
   2690          HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   2691          {
   \                     HAL_TIM_Encoder_Stop_DMA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2692            /* Check the parameters */
   2693            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2694          
   2695            /* Disable the Input Capture channels 1 and 2
   2696              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
   2697            if(Channel == TIM_CHANNEL_1)
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD109             BNE.N    ??HAL_TIM_Encoder_Stop_DMA_0
   2698            {
   2699              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x4611             MOV      R1,R2
   \   0000000E   0x.... 0x....      BL       TIM_CCxChannelCmd
   2700          
   2701              /* Disable the capture compare DMA Request 1 */
   2702              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x68C1             LDR      R1,[R0, #+12]
   \   00000016   0xF421 0x7100      BIC      R1,R1,#0x200
   \   0000001A   0x60C1             STR      R1,[R0, #+12]
   \   0000001C   0xE01E             B.N      ??HAL_TIM_Encoder_Stop_DMA_1
   2703            }
   2704            else if(Channel == TIM_CHANNEL_2)
   \                     ??HAL_TIM_Encoder_Stop_DMA_0: (+1)
   \   0000001E   0x2904             CMP      R1,#+4
   \   00000020   0xD109             BNE.N    ??HAL_TIM_Encoder_Stop_DMA_2
   2705            {
   2706              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \   00000022   0x2200             MOVS     R2,#+0
   \   00000024   0x2104             MOVS     R1,#+4
   \   00000026   0x.... 0x....      BL       TIM_CCxChannelCmd
   2707          
   2708              /* Disable the capture compare DMA Request 2 */
   2709              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x68C1             LDR      R1,[R0, #+12]
   \   0000002E   0xF421 0x6180      BIC      R1,R1,#0x400
   \   00000032   0x60C1             STR      R1,[R0, #+12]
   \   00000034   0xE012             B.N      ??HAL_TIM_Encoder_Stop_DMA_1
   2710            }
   2711            else
   2712            {
   2713              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_DMA_2: (+1)
   \   00000036   0x2200             MOVS     R2,#+0
   \   00000038   0x4611             MOV      R1,R2
   \   0000003A   0x.... 0x....      BL       TIM_CCxChannelCmd
   2714              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0x2104             MOVS     R1,#+4
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x.... 0x....      BL       TIM_CCxChannelCmd
   2715          
   2716              /* Disable the capture compare DMA Request 1 and 2 */
   2717              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x68C1             LDR      R1,[R0, #+12]
   \   0000004C   0xF421 0x7100      BIC      R1,R1,#0x200
   \   00000050   0x60C1             STR      R1,[R0, #+12]
   2718              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x68C1             LDR      R1,[R0, #+12]
   \   00000056   0xF421 0x6180      BIC      R1,R1,#0x400
   \   0000005A   0x60C1             STR      R1,[R0, #+12]
   2719            }
   2720          
   2721            /* Disable the Peripheral */
   2722            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_Encoder_Stop_DMA_1: (+1)
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6A01             LDR      R1,[R0, #+32]
   \   00000060   0xF241 0x1211      MOVW     R2,#+4369
   \   00000064   0x4211             TST      R1,R2
   \   00000066   0xD108             BNE.N    ??HAL_TIM_Encoder_Stop_DMA_3
   \   00000068   0x6A01             LDR      R1,[R0, #+32]
   \   0000006A   0xF240 0x4244      MOVW     R2,#+1092
   \   0000006E   0x4211             TST      R1,R2
   \   00000070   0xD103             BNE.N    ??HAL_TIM_Encoder_Stop_DMA_3
   \   00000072   0x6801             LDR      R1,[R0, #+0]
   \   00000074   0x0849             LSRS     R1,R1,#+1
   \   00000076   0x0049             LSLS     R1,R1,#+1
   \   00000078   0x6001             STR      R1,[R0, #+0]
   2723          
   2724            /* Change the htim state */
   2725            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Encoder_Stop_DMA_3: (+1)
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0xF884 0x0039      STRB     R0,[R4, #+57]
   2726          
   2727            /* Return function status */
   2728            return HAL_OK;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xBD10             POP      {R4,PC}          ;; return
   2729          }
   2730          
   2731          /**
   2732            * @}
   2733            */
   2734          /** @defgroup TIM_Exported_Functions_Group7 TIM IRQ handler management 
   2735           *  @brief    IRQ handler management 
   2736           *
   2737          @verbatim 
   2738            ==============================================================================
   2739                                  ##### IRQ handler management #####
   2740            ==============================================================================
   2741            [..]
   2742              This section provides Timer IRQ handler function.
   2743          
   2744          @endverbatim
   2745            * @{
   2746            */
   2747          /**
   2748            * @brief  This function handles TIM interrupts requests.
   2749            * @param  htim : TIM  handle
   2750            * @retval None
   2751            */

   \                                 In section .text, align 2, keep-with-next
   2752          void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
   2753          {
   \                     HAL_TIM_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2754            /* Capture compare 1 event */
   2755            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6901             LDR      R1,[R0, #+16]
   \   00000008   0x0789             LSLS     R1,R1,#+30
   \   0000000A   0xD517             BPL.N    ??HAL_TIM_IRQHandler_0
   2756            {
   2757              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
   \   0000000C   0x68C1             LDR      R1,[R0, #+12]
   \   0000000E   0x0789             LSLS     R1,R1,#+30
   \   00000010   0xD514             BPL.N    ??HAL_TIM_IRQHandler_0
   2758              {
   2759                {
   2760                  __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
   \   00000012   0xF06F 0x0102      MVN      R1,#+2
   \   00000016   0x6101             STR      R1,[R0, #+16]
   2761                  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x7620             STRB     R0,[R4, #+24]
   2762          
   2763                  /* Input capture event */
   2764                  if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6980             LDR      R0,[R0, #+24]
   \   00000020   0xF010 0x0F03      TST      R0,#0x3
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0xD002             BEQ.N    ??HAL_TIM_IRQHandler_1
   2765                  {
   2766                    HAL_TIM_IC_CaptureCallback(htim);
   \   00000028   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   \   0000002C   0xE004             B.N      ??HAL_TIM_IRQHandler_2
   2767                  }
   2768                  /* Output compare event */
   2769                  else
   2770                  {
   2771                    HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_1: (+1)
   \   0000002E   0x.... 0x....      BL       HAL_TIM_OC_DelayElapsedCallback
   2772                    HAL_TIM_PWM_PulseFinishedCallback(htim);
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   2773                  }
   2774                  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_2: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x7620             STRB     R0,[R4, #+24]
   2775                }
   2776              }
   2777            }
   2778            /* Capture compare 2 event */
   2779            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
   \                     ??HAL_TIM_IRQHandler_0: (+1)
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6901             LDR      R1,[R0, #+16]
   \   00000040   0x0749             LSLS     R1,R1,#+29
   \   00000042   0xD517             BPL.N    ??HAL_TIM_IRQHandler_3
   2780            {
   2781              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
   \   00000044   0x68C1             LDR      R1,[R0, #+12]
   \   00000046   0x0749             LSLS     R1,R1,#+29
   \   00000048   0xD514             BPL.N    ??HAL_TIM_IRQHandler_3
   2782              {
   2783                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
   \   0000004A   0xF06F 0x0104      MVN      R1,#+4
   \   0000004E   0x6101             STR      R1,[R0, #+16]
   2784                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \   00000050   0x2002             MOVS     R0,#+2
   \   00000052   0x7620             STRB     R0,[R4, #+24]
   2785                /* Input capture event */
   2786                if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00)
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x6980             LDR      R0,[R0, #+24]
   \   00000058   0xF410 0x7F40      TST      R0,#0x300
   \   0000005C   0x4620             MOV      R0,R4
   \   0000005E   0xD002             BEQ.N    ??HAL_TIM_IRQHandler_4
   2787                {
   2788                  HAL_TIM_IC_CaptureCallback(htim);
   \   00000060   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   \   00000064   0xE004             B.N      ??HAL_TIM_IRQHandler_5
   2789                }
   2790                /* Output compare event */
   2791                else
   2792                {
   2793                  HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_4: (+1)
   \   00000066   0x.... 0x....      BL       HAL_TIM_OC_DelayElapsedCallback
   2794                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   \   0000006A   0x4620             MOV      R0,R4
   \   0000006C   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   2795                }
   2796                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_5: (+1)
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x7620             STRB     R0,[R4, #+24]
   2797              }
   2798            }
   2799            /* Capture compare 3 event */
   2800            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
   \                     ??HAL_TIM_IRQHandler_3: (+1)
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0x6901             LDR      R1,[R0, #+16]
   \   00000078   0x0709             LSLS     R1,R1,#+28
   \   0000007A   0xD517             BPL.N    ??HAL_TIM_IRQHandler_6
   2801            {
   2802              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
   \   0000007C   0x68C1             LDR      R1,[R0, #+12]
   \   0000007E   0x0709             LSLS     R1,R1,#+28
   \   00000080   0xD514             BPL.N    ??HAL_TIM_IRQHandler_6
   2803              {
   2804                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
   \   00000082   0xF06F 0x0108      MVN      R1,#+8
   \   00000086   0x6101             STR      R1,[R0, #+16]
   2805                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \   00000088   0x2004             MOVS     R0,#+4
   \   0000008A   0x7620             STRB     R0,[R4, #+24]
   2806                /* Input capture event */
   2807                if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00)
   \   0000008C   0x6820             LDR      R0,[R4, #+0]
   \   0000008E   0x69C0             LDR      R0,[R0, #+28]
   \   00000090   0xF010 0x0F03      TST      R0,#0x3
   \   00000094   0x4620             MOV      R0,R4
   \   00000096   0xD002             BEQ.N    ??HAL_TIM_IRQHandler_7
   2808                {
   2809                  HAL_TIM_IC_CaptureCallback(htim);
   \   00000098   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   \   0000009C   0xE004             B.N      ??HAL_TIM_IRQHandler_8
   2810                }
   2811                /* Output compare event */
   2812                else
   2813                {
   2814                  HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_7: (+1)
   \   0000009E   0x.... 0x....      BL       HAL_TIM_OC_DelayElapsedCallback
   2815                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   \   000000A2   0x4620             MOV      R0,R4
   \   000000A4   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   2816                }
   2817                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_8: (+1)
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x7620             STRB     R0,[R4, #+24]
   2818              }
   2819            }
   2820            /* Capture compare 4 event */
   2821            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
   \                     ??HAL_TIM_IRQHandler_6: (+1)
   \   000000AC   0x6820             LDR      R0,[R4, #+0]
   \   000000AE   0x6901             LDR      R1,[R0, #+16]
   \   000000B0   0x06C9             LSLS     R1,R1,#+27
   \   000000B2   0xD517             BPL.N    ??HAL_TIM_IRQHandler_9
   2822            {
   2823              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
   \   000000B4   0x68C1             LDR      R1,[R0, #+12]
   \   000000B6   0x06C9             LSLS     R1,R1,#+27
   \   000000B8   0xD514             BPL.N    ??HAL_TIM_IRQHandler_9
   2824              {
   2825                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
   \   000000BA   0xF06F 0x0110      MVN      R1,#+16
   \   000000BE   0x6101             STR      R1,[R0, #+16]
   2826                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \   000000C0   0x2008             MOVS     R0,#+8
   \   000000C2   0x7620             STRB     R0,[R4, #+24]
   2827                /* Input capture event */
   2828                if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00)
   \   000000C4   0x6820             LDR      R0,[R4, #+0]
   \   000000C6   0x69C0             LDR      R0,[R0, #+28]
   \   000000C8   0xF410 0x7F40      TST      R0,#0x300
   \   000000CC   0x4620             MOV      R0,R4
   \   000000CE   0xD002             BEQ.N    ??HAL_TIM_IRQHandler_10
   2829                {
   2830                  HAL_TIM_IC_CaptureCallback(htim);
   \   000000D0   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   \   000000D4   0xE004             B.N      ??HAL_TIM_IRQHandler_11
   2831                }
   2832                /* Output compare event */
   2833                else
   2834                {
   2835                  HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_10: (+1)
   \   000000D6   0x.... 0x....      BL       HAL_TIM_OC_DelayElapsedCallback
   2836                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   \   000000DA   0x4620             MOV      R0,R4
   \   000000DC   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   2837                }
   2838                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_11: (+1)
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0x7620             STRB     R0,[R4, #+24]
   2839              }
   2840            }
   2841            /* TIM Update event */
   2842            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
   \                     ??HAL_TIM_IRQHandler_9: (+1)
   \   000000E4   0x6820             LDR      R0,[R4, #+0]
   \   000000E6   0x6901             LDR      R1,[R0, #+16]
   \   000000E8   0x07C9             LSLS     R1,R1,#+31
   \   000000EA   0xD508             BPL.N    ??HAL_TIM_IRQHandler_12
   2843            {
   2844              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
   \   000000EC   0x68C1             LDR      R1,[R0, #+12]
   \   000000EE   0x07C9             LSLS     R1,R1,#+31
   \   000000F0   0xD505             BPL.N    ??HAL_TIM_IRQHandler_12
   2845              {
   2846                __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
   \   000000F2   0xF06F 0x0101      MVN      R1,#+1
   \   000000F6   0x6101             STR      R1,[R0, #+16]
   2847                HAL_TIM_PeriodElapsedCallback(htim);
   \   000000F8   0x4620             MOV      R0,R4
   \   000000FA   0x.... 0x....      BL       HAL_TIM_PeriodElapsedCallback
   2848              }
   2849            }
   2850            /* TIM Break input event */
   2851            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
   \                     ??HAL_TIM_IRQHandler_12: (+1)
   \   000000FE   0x6820             LDR      R0,[R4, #+0]
   \   00000100   0x6901             LDR      R1,[R0, #+16]
   \   00000102   0x0609             LSLS     R1,R1,#+24
   \   00000104   0xD508             BPL.N    ??HAL_TIM_IRQHandler_13
   2852            {
   2853              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
   \   00000106   0x68C1             LDR      R1,[R0, #+12]
   \   00000108   0x0609             LSLS     R1,R1,#+24
   \   0000010A   0xD505             BPL.N    ??HAL_TIM_IRQHandler_13
   2854              {
   2855                __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
   \   0000010C   0xF06F 0x0180      MVN      R1,#+128
   \   00000110   0x6101             STR      R1,[R0, #+16]
   2856                HAL_TIMEx_BreakCallback(htim);
   \   00000112   0x4620             MOV      R0,R4
   \   00000114   0x.... 0x....      BL       HAL_TIMEx_BreakCallback
   2857              }
   2858            }
   2859            /* TIM Trigger detection event */
   2860            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
   \                     ??HAL_TIM_IRQHandler_13: (+1)
   \   00000118   0x6820             LDR      R0,[R4, #+0]
   \   0000011A   0x6901             LDR      R1,[R0, #+16]
   \   0000011C   0x0649             LSLS     R1,R1,#+25
   \   0000011E   0xD508             BPL.N    ??HAL_TIM_IRQHandler_14
   2861            {
   2862              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
   \   00000120   0x68C1             LDR      R1,[R0, #+12]
   \   00000122   0x0649             LSLS     R1,R1,#+25
   \   00000124   0xD505             BPL.N    ??HAL_TIM_IRQHandler_14
   2863              {
   2864                __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
   \   00000126   0xF06F 0x0140      MVN      R1,#+64
   \   0000012A   0x6101             STR      R1,[R0, #+16]
   2865                HAL_TIM_TriggerCallback(htim);
   \   0000012C   0x4620             MOV      R0,R4
   \   0000012E   0x.... 0x....      BL       HAL_TIM_TriggerCallback
   2866              }
   2867            }
   2868            /* TIM commutation event */
   2869            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
   \                     ??HAL_TIM_IRQHandler_14: (+1)
   \   00000132   0x6820             LDR      R0,[R4, #+0]
   \   00000134   0x6901             LDR      R1,[R0, #+16]
   \   00000136   0x0689             LSLS     R1,R1,#+26
   \   00000138   0xD50A             BPL.N    ??HAL_TIM_IRQHandler_15
   2870            {
   2871              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
   \   0000013A   0x68C1             LDR      R1,[R0, #+12]
   \   0000013C   0x0689             LSLS     R1,R1,#+26
   \   0000013E   0xD507             BPL.N    ??HAL_TIM_IRQHandler_15
   2872              {
   2873                __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
   \   00000140   0xF06F 0x0120      MVN      R1,#+32
   \   00000144   0x6101             STR      R1,[R0, #+16]
   2874                HAL_TIMEx_CommutationCallback(htim);
   \   00000146   0x4620             MOV      R0,R4
   \   00000148   0xE8BD 0x4010      POP      {R4,LR}
   \   0000014C   0x.... 0x....      B.W      HAL_TIMEx_CommutationCallback
   2875              }
   2876            }
   2877          }
   \                     ??HAL_TIM_IRQHandler_15: (+1)
   \   00000150   0xBD10             POP      {R4,PC}          ;; return
   2878          
   2879          /**
   2880            * @}
   2881            */
   2882          
   2883          /** @defgroup TIM_Exported_Functions_Group8 Peripheral Control functions
   2884           *  @brief   	Peripheral Control functions 
   2885           *
   2886          @verbatim 
   2887            ==============================================================================
   2888                             ##### Peripheral Control functions #####
   2889            ==============================================================================
   2890           [..]
   2891             This section provides functions allowing to:
   2892                (+) Configure The Input Output channels for OC, PWM, IC or One Pulse mode.
   2893                (+) Configure External Clock source.
   2894                (+) Configure Complementary channels, break features and dead time.
   2895                (+) Configure Master and the Slave synchronization.
   2896                (+) Configure the DMA Burst Mode.
   2897          
   2898          @endverbatim
   2899            * @{
   2900            */
   2901          
   2902          /**
   2903            * @brief  Initializes the TIM Output Compare Channels according to the specified
   2904            *         parameters in the TIM_OC_InitTypeDef.
   2905            * @param  htim : TIM Output Compare handle
   2906            * @param  sConfig : TIM Output Compare configuration structure
   2907            * @param  Channel : TIM Channels to be enabled
   2908            *          This parameter can be one of the following values:
   2909            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2910            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2911            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   2912            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected 
   2913            * @retval HAL status
   2914            */

   \                                 In section .text, align 2, keep-with-next
   2915          HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
   2916          {
   \                     HAL_TIM_OC_ConfigChannel: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2917            /* Check the parameters */
   2918            assert_param(IS_TIM_CHANNELS(Channel));
   2919            assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
   2920            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   2921          
   2922            /* Check input state */
   2923            __HAL_LOCK(htim);
   2924          
   2925            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
   2926          
   2927            switch (Channel)
   \   0000000A   0x2A00             CMP      R2,#+0
   \   0000000C   0xD006             BEQ.N    ??HAL_TIM_OC_ConfigChannel_0
   \   0000000E   0x2A04             CMP      R2,#+4
   \   00000010   0xD008             BEQ.N    ??HAL_TIM_OC_ConfigChannel_1
   \   00000012   0x2A08             CMP      R2,#+8
   \   00000014   0xD00A             BEQ.N    ??HAL_TIM_OC_ConfigChannel_2
   \   00000016   0x2A0C             CMP      R2,#+12
   \   00000018   0xD00C             BEQ.N    ??HAL_TIM_OC_ConfigChannel_3
   \   0000001A   0xE00E             B.N      ??HAL_TIM_OC_ConfigChannel_4
   2928            {
   2929              case TIM_CHANNEL_1:
   2930              {
   2931                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   2932                /* Configure the TIM Channel 1 in Output Compare */
   2933                TIM_OC1_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_0: (+1)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x.... 0x....      BL       TIM_OC1_SetConfig
   2934              }
   2935              break;
   \   00000022   0xE00A             B.N      ??HAL_TIM_OC_ConfigChannel_4
   2936          
   2937              case TIM_CHANNEL_2:
   2938              {
   2939                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2940                /* Configure the TIM Channel 2 in Output Compare */
   2941                TIM_OC2_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_1: (+1)
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x.... 0x....      BL       TIM_OC2_SetConfig
   2942              }
   2943              break;
   \   0000002A   0xE006             B.N      ??HAL_TIM_OC_ConfigChannel_4
   2944          
   2945              case TIM_CHANNEL_3:
   2946              {
   2947                 assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   2948                /* Configure the TIM Channel 3 in Output Compare */
   2949                TIM_OC3_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_2: (+1)
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x.... 0x....      BL       TIM_OC3_SetConfig
   2950              }
   2951              break;
   \   00000032   0xE002             B.N      ??HAL_TIM_OC_ConfigChannel_4
   2952          
   2953              case TIM_CHANNEL_4:
   2954              {
   2955                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   2956                 /* Configure the TIM Channel 4 in Output Compare */
   2957                 TIM_OC4_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_3: (+1)
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x.... 0x....      BL       TIM_OC4_SetConfig
   2958              }
   2959              break;
   2960          
   2961              default:
   2962              break;
   2963            }
   2964            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_OC_ConfigChannel_4: (+1)
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xF884 0x0039      STRB     R0,[R4, #+57]
   2965          
   2966            __HAL_UNLOCK(htim);
   2967          
   2968            return HAL_OK;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
   2969          }
   2970          
   2971          /**
   2972            * @brief  Initializes the TIM Input Capture Channels according to the specified
   2973            *         parameters in the TIM_IC_InitTypeDef.
   2974            * @param  htim : TIM IC handle
   2975            * @param  sConfig : TIM Input Capture configuration structure
   2976            * @param  Channel : TIM Channels to be enabled
   2977            *          This parameter can be one of the following values:
   2978            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2979            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2980            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   2981            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected 
   2982            * @retval HAL status
   2983            */

   \                                 In section .text, align 2, keep-with-next
   2984          HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef* sConfig, uint32_t Channel)
   2985          {
   \                     HAL_TIM_IC_ConfigChannel: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4614             MOV      R4,R2
   2986            /* Check the parameters */
   2987            assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   2988            assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));
   2989            assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));
   2990            assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));
   2991            assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));
   2992          
   2993            __HAL_LOCK(htim);
   2994          
   2995            htim->State = HAL_TIM_STATE_BUSY;
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0xF885 0x0039      STRB     R0,[R5, #+57]
   2996          
   2997            if (Channel == TIM_CHANNEL_1)
   \   0000000E   0x6872             LDR      R2,[R6, #+4]
   \   00000010   0x68F3             LDR      R3,[R6, #+12]
   \   00000012   0x6828             LDR      R0,[R5, #+0]
   \   00000014   0x6831             LDR      R1,[R6, #+0]
   \   00000016   0x2C00             CMP      R4,#+0
   \   00000018   0xD10C             BNE.N    ??HAL_TIM_IC_ConfigChannel_0
   2998            {
   2999              /* TI1 Configuration */
   3000              TIM_TI1_SetConfig(htim->Instance,
   3001                         sConfig->ICPolarity,
   3002                         sConfig->ICSelection,
   3003                         sConfig->ICFilter);
   \   0000001A   0x.... 0x....      BL       TIM_TI1_SetConfig
   3004          
   3005              /* Reset the IC1PSC Bits */
   3006              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   \   0000001E   0x6828             LDR      R0,[R5, #+0]
   \   00000020   0x6981             LDR      R1,[R0, #+24]
   \   00000022   0xF021 0x010C      BIC      R1,R1,#0xC
   \   00000026   0x6181             STR      R1,[R0, #+24]
   3007          
   3008              /* Set the IC1PSC value */
   3009              htim->Instance->CCMR1 |= sConfig->ICPrescaler;
   \   00000028   0x6829             LDR      R1,[R5, #+0]
   \   0000002A   0x698A             LDR      R2,[R1, #+24]
   \   0000002C   0x68B0             LDR      R0,[R6, #+8]
   \   0000002E   0x4302             ORRS     R2,R0,R2
   \   00000030   0x618A             STR      R2,[R1, #+24]
   \   00000032   0xE02B             B.N      ??HAL_TIM_IC_ConfigChannel_1
   3010            }
   3011            else if (Channel == TIM_CHANNEL_2)
   \                     ??HAL_TIM_IC_ConfigChannel_0: (+1)
   \   00000034   0x2C04             CMP      R4,#+4
   \   00000036   0xD10D             BNE.N    ??HAL_TIM_IC_ConfigChannel_2
   3012            {
   3013              /* TI2 Configuration */
   3014              assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3015          
   3016              TIM_TI2_SetConfig(htim->Instance,
   3017                                sConfig->ICPolarity,
   3018                                sConfig->ICSelection,
   3019                                sConfig->ICFilter);
   \   00000038   0x.... 0x....      BL       TIM_TI2_SetConfig
   3020          
   3021              /* Reset the IC2PSC Bits */
   3022              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   \   0000003C   0x6828             LDR      R0,[R5, #+0]
   \   0000003E   0x6981             LDR      R1,[R0, #+24]
   \   00000040   0xF421 0x6140      BIC      R1,R1,#0xC00
   \   00000044   0x6181             STR      R1,[R0, #+24]
   3023          
   3024              /* Set the IC2PSC value */
   3025              htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8);
   \   00000046   0x6828             LDR      R0,[R5, #+0]
   \   00000048   0x6981             LDR      R1,[R0, #+24]
   \   0000004A   0x68B2             LDR      R2,[R6, #+8]
   \   0000004C   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   00000050   0x6181             STR      R1,[R0, #+24]
   \   00000052   0xE01B             B.N      ??HAL_TIM_IC_ConfigChannel_1
   3026            }
   3027            else if (Channel == TIM_CHANNEL_3)
   \                     ??HAL_TIM_IC_ConfigChannel_2: (+1)
   \   00000054   0x2C08             CMP      R4,#+8
   \   00000056   0xD10C             BNE.N    ??HAL_TIM_IC_ConfigChannel_3
   3028            {
   3029              /* TI3 Configuration */
   3030              assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3031          
   3032              TIM_TI3_SetConfig(htim->Instance,
   3033                         sConfig->ICPolarity,
   3034                         sConfig->ICSelection,
   3035                         sConfig->ICFilter);
   \   00000058   0x.... 0x....      BL       TIM_TI3_SetConfig
   3036          
   3037              /* Reset the IC3PSC Bits */
   3038              htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
   \   0000005C   0x6828             LDR      R0,[R5, #+0]
   \   0000005E   0x69C1             LDR      R1,[R0, #+28]
   \   00000060   0xF021 0x010C      BIC      R1,R1,#0xC
   \   00000064   0x61C1             STR      R1,[R0, #+28]
   3039          
   3040              /* Set the IC3PSC value */
   3041              htim->Instance->CCMR2 |= sConfig->ICPrescaler;
   \   00000066   0x6829             LDR      R1,[R5, #+0]
   \   00000068   0x69CA             LDR      R2,[R1, #+28]
   \   0000006A   0x68B0             LDR      R0,[R6, #+8]
   \   0000006C   0x4302             ORRS     R2,R0,R2
   \   0000006E   0x61CA             STR      R2,[R1, #+28]
   \   00000070   0xE00C             B.N      ??HAL_TIM_IC_ConfigChannel_1
   3042            }
   3043            else
   3044            {
   3045              /* TI4 Configuration */
   3046              assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3047          
   3048              TIM_TI4_SetConfig(htim->Instance,
   3049                         sConfig->ICPolarity,
   3050                         sConfig->ICSelection,
   3051                         sConfig->ICFilter);
   \                     ??HAL_TIM_IC_ConfigChannel_3: (+1)
   \   00000072   0x.... 0x....      BL       TIM_TI4_SetConfig
   3052          
   3053              /* Reset the IC4PSC Bits */
   3054              htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
   \   00000076   0x6828             LDR      R0,[R5, #+0]
   \   00000078   0x69C1             LDR      R1,[R0, #+28]
   \   0000007A   0xF421 0x6140      BIC      R1,R1,#0xC00
   \   0000007E   0x61C1             STR      R1,[R0, #+28]
   3055          
   3056              /* Set the IC4PSC value */
   3057              htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8);
   \   00000080   0x6828             LDR      R0,[R5, #+0]
   \   00000082   0x69C1             LDR      R1,[R0, #+28]
   \   00000084   0x68B2             LDR      R2,[R6, #+8]
   \   00000086   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   0000008A   0x61C1             STR      R1,[R0, #+28]
   3058            }
   3059          
   3060            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_IC_ConfigChannel_1: (+1)
   \   0000008C   0x2001             MOVS     R0,#+1
   \   0000008E   0xF885 0x0039      STRB     R0,[R5, #+57]
   3061          
   3062            __HAL_UNLOCK(htim);
   3063          
   3064            return HAL_OK;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0xBD70             POP      {R4-R6,PC}       ;; return
   3065          }
   3066          
   3067          /**
   3068            * @brief  Initializes the TIM PWM  channels according to the specified
   3069            *         parameters in the TIM_OC_InitTypeDef.
   3070            * @param  htim : TIM handle
   3071            * @param  sConfig : TIM PWM configuration structure
   3072            * @param  Channel : TIM Channels to be enabled
   3073            *          This parameter can be one of the following values:
   3074            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3075            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3076            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3077            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   3078            * @retval HAL status
   3079            */

   \                                 In section .text, align 2, keep-with-next
   3080          HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
   3081          {
   \                     HAL_TIM_PWM_ConfigChannel: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   3082            __HAL_LOCK(htim);
   3083          
   3084            /* Check the parameters */
   3085            assert_param(IS_TIM_CHANNELS(Channel));
   3086            assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
   3087            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   3088            assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
   3089          
   3090            htim->State = HAL_TIM_STATE_BUSY;
   \   00000006   0x2002             MOVS     R0,#+2
   \   00000008   0xF884 0x0039      STRB     R0,[R4, #+57]
   3091          
   3092            switch (Channel)
   \   0000000C   0x2A00             CMP      R2,#+0
   \   0000000E   0xD006             BEQ.N    ??HAL_TIM_PWM_ConfigChannel_0
   \   00000010   0x2A04             CMP      R2,#+4
   \   00000012   0xD017             BEQ.N    ??HAL_TIM_PWM_ConfigChannel_1
   \   00000014   0x2A08             CMP      R2,#+8
   \   00000016   0xD029             BEQ.N    ??HAL_TIM_PWM_ConfigChannel_2
   \   00000018   0x2A0C             CMP      R2,#+12
   \   0000001A   0xD03A             BEQ.N    ??HAL_TIM_PWM_ConfigChannel_3
   \   0000001C   0xE04C             B.N      ??HAL_TIM_PWM_ConfigChannel_4
   3093            {
   3094              case TIM_CHANNEL_1:
   3095              {
   3096                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3097                /* Configure the Channel 1 in PWM mode */
   3098                TIM_OC1_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_0: (+1)
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x.... 0x....      BL       TIM_OC1_SetConfig
   3099          
   3100                /* Set the Preload enable bit for channel1 */
   3101                htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x6981             LDR      R1,[R0, #+24]
   \   00000028   0xF041 0x0108      ORR      R1,R1,#0x8
   \   0000002C   0x6181             STR      R1,[R0, #+24]
   3102          
   3103                /* Configure the Output Fast mode */
   3104                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x6981             LDR      R1,[R0, #+24]
   \   00000032   0xF021 0x0104      BIC      R1,R1,#0x4
   \   00000036   0x6181             STR      R1,[R0, #+24]
   3105                htim->Instance->CCMR1 |= sConfig->OCFastMode;
   \   00000038   0x6821             LDR      R1,[R4, #+0]
   \   0000003A   0x698A             LDR      R2,[R1, #+24]
   \   0000003C   0x6928             LDR      R0,[R5, #+16]
   \   0000003E   0x4302             ORRS     R2,R0,R2
   \   00000040   0x618A             STR      R2,[R1, #+24]
   3106              }
   3107              break;
   \   00000042   0xE039             B.N      ??HAL_TIM_PWM_ConfigChannel_4
   3108          
   3109              case TIM_CHANNEL_2:
   3110              {
   3111                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3112                /* Configure the Channel 2 in PWM mode */
   3113                TIM_OC2_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_1: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x.... 0x....      BL       TIM_OC2_SetConfig
   3114          
   3115                /* Set the Preload enable bit for channel2 */
   3116                htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x6981             LDR      R1,[R0, #+24]
   \   0000004E   0xF441 0x6100      ORR      R1,R1,#0x800
   \   00000052   0x6181             STR      R1,[R0, #+24]
   3117          
   3118                /* Configure the Output Fast mode */
   3119                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x6981             LDR      R1,[R0, #+24]
   \   00000058   0xF421 0x6180      BIC      R1,R1,#0x400
   \   0000005C   0x6181             STR      R1,[R0, #+24]
   3120                htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x6981             LDR      R1,[R0, #+24]
   \   00000062   0x692A             LDR      R2,[R5, #+16]
   \   00000064   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   00000068   0x6181             STR      R1,[R0, #+24]
   3121              }
   3122              break;
   \   0000006A   0xE025             B.N      ??HAL_TIM_PWM_ConfigChannel_4
   3123          
   3124              case TIM_CHANNEL_3:
   3125              {
   3126                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3127                /* Configure the Channel 3 in PWM mode */
   3128                TIM_OC3_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_2: (+1)
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x.... 0x....      BL       TIM_OC3_SetConfig
   3129          
   3130                /* Set the Preload enable bit for channel3 */
   3131                htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
   \   00000072   0x6820             LDR      R0,[R4, #+0]
   \   00000074   0x69C1             LDR      R1,[R0, #+28]
   \   00000076   0xF041 0x0108      ORR      R1,R1,#0x8
   \   0000007A   0x61C1             STR      R1,[R0, #+28]
   3132          
   3133               /* Configure the Output Fast mode */
   3134                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0x69C1             LDR      R1,[R0, #+28]
   \   00000080   0xF021 0x0104      BIC      R1,R1,#0x4
   \   00000084   0x61C1             STR      R1,[R0, #+28]
   3135                htim->Instance->CCMR2 |= sConfig->OCFastMode;
   \   00000086   0x6821             LDR      R1,[R4, #+0]
   \   00000088   0x69CA             LDR      R2,[R1, #+28]
   \   0000008A   0x6928             LDR      R0,[R5, #+16]
   \   0000008C   0x4302             ORRS     R2,R0,R2
   \   0000008E   0x61CA             STR      R2,[R1, #+28]
   3136              }
   3137              break;
   \   00000090   0xE012             B.N      ??HAL_TIM_PWM_ConfigChannel_4
   3138          
   3139              case TIM_CHANNEL_4:
   3140              {
   3141                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3142                /* Configure the Channel 4 in PWM mode */
   3143                TIM_OC4_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_3: (+1)
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x.... 0x....      BL       TIM_OC4_SetConfig
   3144          
   3145                /* Set the Preload enable bit for channel4 */
   3146                htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
   \   00000098   0x6820             LDR      R0,[R4, #+0]
   \   0000009A   0x69C1             LDR      R1,[R0, #+28]
   \   0000009C   0xF441 0x6100      ORR      R1,R1,#0x800
   \   000000A0   0x61C1             STR      R1,[R0, #+28]
   3147          
   3148               /* Configure the Output Fast mode */
   3149                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x69C1             LDR      R1,[R0, #+28]
   \   000000A6   0xF421 0x6180      BIC      R1,R1,#0x400
   \   000000AA   0x61C1             STR      R1,[R0, #+28]
   3150                htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;
   \   000000AC   0x6820             LDR      R0,[R4, #+0]
   \   000000AE   0x69C1             LDR      R1,[R0, #+28]
   \   000000B0   0x692A             LDR      R2,[R5, #+16]
   \   000000B2   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   000000B6   0x61C1             STR      R1,[R0, #+28]
   3151              }
   3152              break;
   3153          
   3154              default:
   3155              break;
   3156            }
   3157          
   3158            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_PWM_ConfigChannel_4: (+1)
   \   000000B8   0x2001             MOVS     R0,#+1
   \   000000BA   0xF884 0x0039      STRB     R0,[R4, #+57]
   3159          
   3160            __HAL_UNLOCK(htim);
   3161          
   3162            return HAL_OK;
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   3163          }
   3164          
   3165          /**
   3166            * @brief  Initializes the TIM One Pulse Channels according to the specified
   3167            *         parameters in the TIM_OnePulse_InitTypeDef.
   3168            * @param  htim : TIM One Pulse handle
   3169            * @param  sConfig : TIM One Pulse configuration structure
   3170            * @param  OutputChannel : TIM Channels to be enabled
   3171            *          This parameter can be one of the following values:
   3172            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3173            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3174            * @param  InputChannel : TIM Channels to be enabled
   3175            *          This parameter can be one of the following values:
   3176            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3177            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3178            * @retval HAL status
   3179            */

   \                                 In section .text, align 2, keep-with-next
   3180          HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef* sConfig, uint32_t OutputChannel,  uint32_t InputChannel)
   3181          {
   \                     HAL_TIM_OnePulse_ConfigChannel: (+1)
   \   00000000   0xB578             PUSH     {R3-R6,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460E             MOV      R6,R1
   \   00000008   0x461C             MOV      R4,R3
   3182            TIM_OC_InitTypeDef temp1;
   3183          
   3184            /* Check the parameters */
   3185            assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));
   3186            assert_param(IS_TIM_OPM_CHANNELS(InputChannel));
   3187          
   3188            if(OutputChannel != InputChannel)
   \   0000000A   0x42A2             CMP      R2,R4
   \   0000000C   0xD065             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_0
   3189            {
   3190            __HAL_LOCK(htim);
   3191          
   3192            htim->State = HAL_TIM_STATE_BUSY;
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xF885 0x0039      STRB     R0,[R5, #+57]
   3193          
   3194            /* Extract the Ouput compare configuration from sConfig structure */
   3195            temp1.OCMode = sConfig->OCMode;
   \   00000014   0x6830             LDR      R0,[R6, #+0]
   \   00000016   0x9000             STR      R0,[SP, #+0]
   3196            temp1.Pulse = sConfig->Pulse;
   \   00000018   0x6870             LDR      R0,[R6, #+4]
   \   0000001A   0x9001             STR      R0,[SP, #+4]
   3197            temp1.OCPolarity = sConfig->OCPolarity;
   \   0000001C   0x68B0             LDR      R0,[R6, #+8]
   \   0000001E   0x9002             STR      R0,[SP, #+8]
   3198            temp1.OCNPolarity = sConfig->OCNPolarity;
   \   00000020   0x68F0             LDR      R0,[R6, #+12]
   \   00000022   0x9003             STR      R0,[SP, #+12]
   3199            temp1.OCIdleState = sConfig->OCIdleState;
   \   00000024   0x6930             LDR      R0,[R6, #+16]
   \   00000026   0x9005             STR      R0,[SP, #+20]
   3200            temp1.OCNIdleState = sConfig->OCNIdleState;
   \   00000028   0x6970             LDR      R0,[R6, #+20]
   \   0000002A   0x9006             STR      R0,[SP, #+24]
   3201          
   3202              switch (OutputChannel)
   \   0000002C   0x2A00             CMP      R2,#+0
   \   0000002E   0xD002             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_1
   \   00000030   0x2A04             CMP      R2,#+4
   \   00000032   0xD005             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_2
   \   00000034   0xE008             B.N      ??HAL_TIM_OnePulse_ConfigChannel_3
   3203            {
   3204              case TIM_CHANNEL_1:
   3205              {
   3206                  assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3207          
   3208                TIM_OC1_SetConfig(htim->Instance, &temp1);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_1: (+1)
   \   00000036   0x4669             MOV      R1,SP
   \   00000038   0x6828             LDR      R0,[R5, #+0]
   \   0000003A   0x.... 0x....      BL       TIM_OC1_SetConfig
   3209              }
   3210              break;
   \   0000003E   0xE003             B.N      ??HAL_TIM_OnePulse_ConfigChannel_3
   3211              case TIM_CHANNEL_2:
   3212              {
   3213                  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3214          
   3215                TIM_OC2_SetConfig(htim->Instance, &temp1);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_2: (+1)
   \   00000040   0x4669             MOV      R1,SP
   \   00000042   0x6828             LDR      R0,[R5, #+0]
   \   00000044   0x.... 0x....      BL       TIM_OC2_SetConfig
   3216              }
   3217              break;
   3218              default:
   3219              break;
   3220            }
   3221            switch (InputChannel)
   \                     ??HAL_TIM_OnePulse_ConfigChannel_3: (+1)
   \   00000048   0x2C00             CMP      R4,#+0
   \   0000004A   0xD002             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_4
   \   0000004C   0x2C04             CMP      R4,#+4
   \   0000004E   0xD020             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_5
   \   00000050   0xE03E             B.N      ??HAL_TIM_OnePulse_ConfigChannel_6
   3222            {
   3223              case TIM_CHANNEL_1:
   3224              {
   3225                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3226          
   3227                TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
   3228                                  sConfig->ICSelection, sConfig->ICFilter);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_4: (+1)
   \   00000052   0x6A33             LDR      R3,[R6, #+32]
   \   00000054   0x69F2             LDR      R2,[R6, #+28]
   \   00000056   0x69B1             LDR      R1,[R6, #+24]
   \   00000058   0x6828             LDR      R0,[R5, #+0]
   \   0000005A   0x.... 0x....      BL       TIM_TI1_SetConfig
   3229          
   3230                /* Reset the IC1PSC Bits */
   3231              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   \   0000005E   0x6828             LDR      R0,[R5, #+0]
   \   00000060   0x6981             LDR      R1,[R0, #+24]
   \   00000062   0xF021 0x010C      BIC      R1,R1,#0xC
   \   00000066   0x6181             STR      R1,[R0, #+24]
   3232          
   3233                /* Select the Trigger source */
   3234                  htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \   00000068   0x6828             LDR      R0,[R5, #+0]
   \   0000006A   0x6881             LDR      R1,[R0, #+8]
   \   0000006C   0xF021 0x0170      BIC      R1,R1,#0x70
   \   00000070   0x6081             STR      R1,[R0, #+8]
   3235                htim->Instance->SMCR |= TIM_TS_TI1FP1;
   \   00000072   0x6828             LDR      R0,[R5, #+0]
   \   00000074   0x6881             LDR      R1,[R0, #+8]
   \   00000076   0xF041 0x0150      ORR      R1,R1,#0x50
   \   0000007A   0x6081             STR      R1,[R0, #+8]
   3236          
   3237                /* Select the Slave Mode */
   3238                  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \   0000007C   0x6828             LDR      R0,[R5, #+0]
   \   0000007E   0x6881             LDR      R1,[R0, #+8]
   \   00000080   0x08C9             LSRS     R1,R1,#+3
   \   00000082   0x00C9             LSLS     R1,R1,#+3
   \   00000084   0x6081             STR      R1,[R0, #+8]
   3239                htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
   \   00000086   0x6828             LDR      R0,[R5, #+0]
   \   00000088   0x6881             LDR      R1,[R0, #+8]
   \   0000008A   0xF041 0x0106      ORR      R1,R1,#0x6
   \   0000008E   0x6081             STR      R1,[R0, #+8]
   3240              }
   3241              break;
   \   00000090   0xE01E             B.N      ??HAL_TIM_OnePulse_ConfigChannel_6
   3242              case TIM_CHANNEL_2:
   3243              {
   3244                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3245          
   3246                TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
   3247                           sConfig->ICSelection, sConfig->ICFilter);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_5: (+1)
   \   00000092   0x6A33             LDR      R3,[R6, #+32]
   \   00000094   0x69F2             LDR      R2,[R6, #+28]
   \   00000096   0x69B1             LDR      R1,[R6, #+24]
   \   00000098   0x6828             LDR      R0,[R5, #+0]
   \   0000009A   0x.... 0x....      BL       TIM_TI2_SetConfig
   3248          
   3249                /* Reset the IC2PSC Bits */
   3250                  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   \   0000009E   0x6828             LDR      R0,[R5, #+0]
   \   000000A0   0x6981             LDR      R1,[R0, #+24]
   \   000000A2   0xF421 0x6140      BIC      R1,R1,#0xC00
   \   000000A6   0x6181             STR      R1,[R0, #+24]
   3251          
   3252                /* Select the Trigger source */
   3253                  htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \   000000A8   0x6828             LDR      R0,[R5, #+0]
   \   000000AA   0x6881             LDR      R1,[R0, #+8]
   \   000000AC   0xF021 0x0170      BIC      R1,R1,#0x70
   \   000000B0   0x6081             STR      R1,[R0, #+8]
   3254                htim->Instance->SMCR |= TIM_TS_TI2FP2;
   \   000000B2   0x6828             LDR      R0,[R5, #+0]
   \   000000B4   0x6881             LDR      R1,[R0, #+8]
   \   000000B6   0xF041 0x0160      ORR      R1,R1,#0x60
   \   000000BA   0x6081             STR      R1,[R0, #+8]
   3255          
   3256                /* Select the Slave Mode */
   3257                  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \   000000BC   0x6828             LDR      R0,[R5, #+0]
   \   000000BE   0x6881             LDR      R1,[R0, #+8]
   \   000000C0   0x08C9             LSRS     R1,R1,#+3
   \   000000C2   0x00C9             LSLS     R1,R1,#+3
   \   000000C4   0x6081             STR      R1,[R0, #+8]
   3258                htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
   \   000000C6   0x6828             LDR      R0,[R5, #+0]
   \   000000C8   0x6881             LDR      R1,[R0, #+8]
   \   000000CA   0xF041 0x0106      ORR      R1,R1,#0x6
   \   000000CE   0x6081             STR      R1,[R0, #+8]
   3259              }
   3260              break;
   3261          
   3262              default:
   3263              break;
   3264            }
   3265          
   3266            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_OnePulse_ConfigChannel_6: (+1)
   \   000000D0   0x2001             MOVS     R0,#+1
   \   000000D2   0xF885 0x0039      STRB     R0,[R5, #+57]
   3267          
   3268            __HAL_UNLOCK(htim);
   3269          
   3270            return HAL_OK;
   \   000000D6   0x2000             MOVS     R0,#+0
   \   000000D8   0xE000             B.N      ??HAL_TIM_OnePulse_ConfigChannel_7
   3271          }
   3272            else
   3273            {
   3274              return HAL_ERROR;
   \                     ??HAL_TIM_OnePulse_ConfigChannel_0: (+1)
   \   000000DA   0x2001             MOVS     R0,#+1
   \                     ??HAL_TIM_OnePulse_ConfigChannel_7: (+1)
   \   000000DC   0xB008             ADD      SP,SP,#+32
   \   000000DE   0xBD70             POP      {R4-R6,PC}       ;; return
   3275            }
   3276          }
   3277          
   3278          /**
   3279            * @brief  Configure the DMA Burst to transfer Data from the memory to the TIM peripheral 
   3280            * @param  htim : TIM handle
   3281            * @param  BurstBaseAddress : TIM Base address from where the DMA will start the Data write
   3282            *         This parameter can be one of the following values:
   3283            *            @arg TIM_DMABASE_CR1 
   3284            *            @arg TIM_DMABASE_CR2
   3285            *            @arg TIM_DMABASE_SMCR
   3286            *            @arg TIM_DMABASE_DIER
   3287            *            @arg TIM_DMABASE_SR
   3288            *            @arg TIM_DMABASE_EGR
   3289            *            @arg TIM_DMABASE_CCMR1
   3290            *            @arg TIM_DMABASE_CCMR2
   3291            *            @arg TIM_DMABASE_CCER
   3292            *            @arg TIM_DMABASE_CNT 
   3293            *            @arg TIM_DMABASE_PSC 
   3294            *            @arg TIM_DMABASE_ARR
   3295            *            @arg TIM_DMABASE_RCR
   3296            *            @arg TIM_DMABASE_CCR1
   3297            *            @arg TIM_DMABASE_CCR2
   3298            *            @arg TIM_DMABASE_CCR3 
   3299            *            @arg TIM_DMABASE_CCR4
   3300            *            @arg TIM_DMABASE_BDTR
   3301            *            @arg TIM_DMABASE_DCR
   3302            * @param  BurstRequestSrc : TIM DMA Request sources
   3303            *         This parameter can be one of the following values:
   3304            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   3305            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   3306            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   3307            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   3308            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   3309            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   3310            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   3311            * @param  BurstBuffer : The Buffer address.
   3312            * @param  BurstLength : DMA Burst length. This parameter can be one value
   3313            *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   3314            * @retval HAL status
   3315            */

   \                                 In section .text, align 2, keep-with-next
   3316          HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
   3317                                                        uint32_t* BurstBuffer, uint32_t  BurstLength)
   3318          {
   \                     HAL_TIM_DMABurst_WriteStart: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460F             MOV      R7,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x4619             MOV      R1,R3
   3319            /* Check the parameters */
   3320            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   3321            assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
   3322            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3323            assert_param(IS_TIM_DMA_LENGTH(BurstLength));
   3324          
   3325            if((htim->State == HAL_TIM_STATE_BUSY))
   \   0000000A   0xF995 0x0039      LDRSB    R0,[R5, #+57]
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xD101             BNE.N    ??HAL_TIM_DMABurst_WriteStart_0
   3326            {
   3327               return HAL_BUSY;
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0xBDF2             POP      {R1,R4-R7,PC}
   3328            }
   \                     ??HAL_TIM_DMABurst_WriteStart_0: (+1)
   \   00000016   0x9C06             LDR      R4,[SP, #+24]
   3329            else if((htim->State == HAL_TIM_STATE_READY))
   \   00000018   0xF995 0x0039      LDRSB    R0,[R5, #+57]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD108             BNE.N    ??HAL_TIM_DMABurst_WriteStart_1
   3330            {
   3331              if((BurstBuffer == 0 ) && (BurstLength > 0))
   \   00000020   0x2900             CMP      R1,#+0
   \   00000022   0xD103             BNE.N    ??HAL_TIM_DMABurst_WriteStart_2
   \   00000024   0x2C00             CMP      R4,#+0
   \   00000026   0xD001             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_2
   3332              {
   3333                return HAL_ERROR;
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xBDF2             POP      {R1,R4-R7,PC}
   3334              }
   3335              else
   3336              {
   3337                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_DMABurst_WriteStart_2: (+1)
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0xF885 0x0039      STRB     R0,[R5, #+57]
   3338              }
   3339            }
   3340            switch(BurstRequestSrc)
   \                     ??HAL_TIM_DMABurst_WriteStart_1: (+1)
   \   00000032   0x4630             MOV      R0,R6
   \   00000034   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000038   0xD012             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_3
   \   0000003A   0xF5B0 0x7F00      CMP      R0,#+512
   \   0000003E   0xD021             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_4
   \   00000040   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000044   0xD030             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_5
   \   00000046   0xF5B0 0x6F00      CMP      R0,#+2048
   \   0000004A   0xD03F             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_6
   \   0000004C   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000050   0xD04E             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_7
   \   00000052   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000056   0xD05D             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_8
   \   00000058   0xF5B0 0x4F80      CMP      R0,#+16384
   \   0000005C   0xD06C             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_9
   \   0000005E   0xE07C             B.N      ??HAL_TIM_DMABurst_WriteStart_10
   3341            {
   3342              case TIM_DMA_UPDATE:
   3343              {
   3344                /* Set the DMA Period elapsed callback */
   3345                htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_3: (+1)
   \   00000060   0x.... 0x....      ADR.W    R0,TIM_DMAPeriodElapsedCplt
   \   00000064   0x69EA             LDR      R2,[R5, #+28]
   \   00000066   0x6290             STR      R0,[R2, #+40]
   3346          
   3347                /* Set the DMA error callback */
   3348                htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
   \   00000068   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   0000006C   0x69EA             LDR      R2,[R5, #+28]
   \   0000006E   0x6310             STR      R0,[R2, #+48]
   3349          
   3350                /* Enable the DMA channel */
   3351                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);
   \   00000070   0x4623             MOV      R3,R4
   \   00000072   0x0A1B             LSRS     R3,R3,#+8
   \   00000074   0x1C5B             ADDS     R3,R3,#+1
   \   00000076   0x6828             LDR      R0,[R5, #+0]
   \   00000078   0xF100 0x024C      ADD      R2,R0,#+76
   \   0000007C   0x69E8             LDR      R0,[R5, #+28]
   \   0000007E   0x.... 0x....      BL       HAL_DMA_Start_IT
   3352              }
   3353              break;
   \   00000082   0xE06A             B.N      ??HAL_TIM_DMABurst_WriteStart_10
   3354              case TIM_DMA_CC1:
   3355              {
   3356                /* Set the DMA Period elapsed callback */
   3357                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback =  TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_4: (+1)
   \   00000084   0x.... 0x....      ADR.W    R0,TIM_DMADelayPulseCplt
   \   00000088   0x6A2A             LDR      R2,[R5, #+32]
   \   0000008A   0x6290             STR      R0,[R2, #+40]
   3358          
   3359                /* Set the DMA error callback */
   3360                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   0000008C   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   00000090   0x6A2A             LDR      R2,[R5, #+32]
   \   00000092   0x6310             STR      R0,[R2, #+48]
   3361          
   3362                /* Enable the DMA channel */
   3363                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);
   \   00000094   0x4623             MOV      R3,R4
   \   00000096   0x0A1B             LSRS     R3,R3,#+8
   \   00000098   0x1C5B             ADDS     R3,R3,#+1
   \   0000009A   0x6828             LDR      R0,[R5, #+0]
   \   0000009C   0xF100 0x024C      ADD      R2,R0,#+76
   \   000000A0   0x6A28             LDR      R0,[R5, #+32]
   \   000000A2   0x.... 0x....      BL       HAL_DMA_Start_IT
   3364              }
   3365              break;
   \   000000A6   0xE058             B.N      ??HAL_TIM_DMABurst_WriteStart_10
   3366              case TIM_DMA_CC2:
   3367              {
   3368                /* Set the DMA Period elapsed callback */
   3369                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback =  TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_5: (+1)
   \   000000A8   0x.... 0x....      ADR.W    R0,TIM_DMADelayPulseCplt
   \   000000AC   0x6A6A             LDR      R2,[R5, #+36]
   \   000000AE   0x6290             STR      R0,[R2, #+40]
   3370          
   3371                /* Set the DMA error callback */
   3372                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \   000000B0   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000B4   0x6A6A             LDR      R2,[R5, #+36]
   \   000000B6   0x6310             STR      R0,[R2, #+48]
   3373          
   3374                /* Enable the DMA channel */
   3375                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);
   \   000000B8   0x4623             MOV      R3,R4
   \   000000BA   0x0A1B             LSRS     R3,R3,#+8
   \   000000BC   0x1C5B             ADDS     R3,R3,#+1
   \   000000BE   0x6828             LDR      R0,[R5, #+0]
   \   000000C0   0xF100 0x024C      ADD      R2,R0,#+76
   \   000000C4   0x6A68             LDR      R0,[R5, #+36]
   \   000000C6   0x.... 0x....      BL       HAL_DMA_Start_IT
   3376              }
   3377              break;
   \   000000CA   0xE046             B.N      ??HAL_TIM_DMABurst_WriteStart_10
   3378              case TIM_DMA_CC3:
   3379              {
   3380                /* Set the DMA Period elapsed callback */
   3381                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback =  TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_6: (+1)
   \   000000CC   0x.... 0x....      ADR.W    R0,TIM_DMADelayPulseCplt
   \   000000D0   0x6AAA             LDR      R2,[R5, #+40]
   \   000000D2   0x6290             STR      R0,[R2, #+40]
   3382          
   3383                /* Set the DMA error callback */
   3384                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \   000000D4   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000D8   0x6AAA             LDR      R2,[R5, #+40]
   \   000000DA   0x6310             STR      R0,[R2, #+48]
   3385          
   3386                /* Enable the DMA channel */
   3387                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);
   \   000000DC   0x4623             MOV      R3,R4
   \   000000DE   0x0A1B             LSRS     R3,R3,#+8
   \   000000E0   0x1C5B             ADDS     R3,R3,#+1
   \   000000E2   0x6828             LDR      R0,[R5, #+0]
   \   000000E4   0xF100 0x024C      ADD      R2,R0,#+76
   \   000000E8   0x6AA8             LDR      R0,[R5, #+40]
   \   000000EA   0x.... 0x....      BL       HAL_DMA_Start_IT
   3388              }
   3389              break;
   \   000000EE   0xE034             B.N      ??HAL_TIM_DMABurst_WriteStart_10
   3390              case TIM_DMA_CC4:
   3391              {
   3392                /* Set the DMA Period elapsed callback */
   3393                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback =  TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_7: (+1)
   \   000000F0   0x.... 0x....      ADR.W    R0,TIM_DMADelayPulseCplt
   \   000000F4   0x6AEA             LDR      R2,[R5, #+44]
   \   000000F6   0x6290             STR      R0,[R2, #+40]
   3394          
   3395                /* Set the DMA error callback */
   3396                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \   000000F8   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000FC   0x6AEA             LDR      R2,[R5, #+44]
   \   000000FE   0x6310             STR      R0,[R2, #+48]
   3397          
   3398                /* Enable the DMA channel */
   3399                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);
   \   00000100   0x4623             MOV      R3,R4
   \   00000102   0x0A1B             LSRS     R3,R3,#+8
   \   00000104   0x1C5B             ADDS     R3,R3,#+1
   \   00000106   0x6828             LDR      R0,[R5, #+0]
   \   00000108   0xF100 0x024C      ADD      R2,R0,#+76
   \   0000010C   0x6AE8             LDR      R0,[R5, #+44]
   \   0000010E   0x.... 0x....      BL       HAL_DMA_Start_IT
   3400              }
   3401              break;
   \   00000112   0xE022             B.N      ??HAL_TIM_DMABurst_WriteStart_10
   3402              case TIM_DMA_COM:
   3403              {
   3404                /* Set the DMA Period elapsed callback */
   3405                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_8: (+1)
   \   00000114   0x.... 0x....      LDR.W    R0,??DataTable29
   \   00000118   0x6B2A             LDR      R2,[R5, #+48]
   \   0000011A   0x6290             STR      R0,[R2, #+40]
   3406          
   3407                /* Set the DMA error callback */
   3408                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
   \   0000011C   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   00000120   0x6B2A             LDR      R2,[R5, #+48]
   \   00000122   0x6310             STR      R0,[R2, #+48]
   3409          
   3410                /* Enable the DMA channel */
   3411                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);
   \   00000124   0x4623             MOV      R3,R4
   \   00000126   0x0A1B             LSRS     R3,R3,#+8
   \   00000128   0x1C5B             ADDS     R3,R3,#+1
   \   0000012A   0x6828             LDR      R0,[R5, #+0]
   \   0000012C   0xF100 0x024C      ADD      R2,R0,#+76
   \   00000130   0x6B28             LDR      R0,[R5, #+48]
   \   00000132   0x.... 0x....      BL       HAL_DMA_Start_IT
   3412              }
   3413              break;
   \   00000136   0xE010             B.N      ??HAL_TIM_DMABurst_WriteStart_10
   3414              case TIM_DMA_TRIGGER:
   3415              {
   3416                /* Set the DMA Period elapsed callback */
   3417                htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_9: (+1)
   \   00000138   0x.... 0x....      ADR.W    R0,TIM_DMATriggerCplt
   \   0000013C   0x6B6A             LDR      R2,[R5, #+52]
   \   0000013E   0x6290             STR      R0,[R2, #+40]
   3418          
   3419                /* Set the DMA error callback */
   3420                htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
   \   00000140   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   00000144   0x6B6A             LDR      R2,[R5, #+52]
   \   00000146   0x6310             STR      R0,[R2, #+48]
   3421          
   3422                /* Enable the DMA channel */
   3423                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);
   \   00000148   0x4623             MOV      R3,R4
   \   0000014A   0x0A1B             LSRS     R3,R3,#+8
   \   0000014C   0x1C5B             ADDS     R3,R3,#+1
   \   0000014E   0x6828             LDR      R0,[R5, #+0]
   \   00000150   0xF100 0x024C      ADD      R2,R0,#+76
   \   00000154   0x6B68             LDR      R0,[R5, #+52]
   \   00000156   0x.... 0x....      BL       HAL_DMA_Start_IT
   3424              }
   3425              break;
   3426              default:
   3427              break;
   3428            }
   3429             /* configure the DMA Burst Mode */
   3430             htim->Instance->DCR = BurstBaseAddress | BurstLength;
   \                     ??HAL_TIM_DMABurst_WriteStart_10: (+1)
   \   0000015A   0x4327             ORRS     R7,R4,R7
   \   0000015C   0x6828             LDR      R0,[R5, #+0]
   \   0000015E   0x6487             STR      R7,[R0, #+72]
   3431          
   3432             /* Enable the TIM DMA Request */
   3433             __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
   \   00000160   0x6828             LDR      R0,[R5, #+0]
   \   00000162   0x68C1             LDR      R1,[R0, #+12]
   \   00000164   0x430E             ORRS     R6,R6,R1
   \   00000166   0x60C6             STR      R6,[R0, #+12]
   3434          
   3435             htim->State = HAL_TIM_STATE_READY;
   \   00000168   0x2001             MOVS     R0,#+1
   \   0000016A   0xF885 0x0039      STRB     R0,[R5, #+57]
   3436          
   3437            /* Return function status */
   3438            return HAL_OK;
   \   0000016E   0x2000             MOVS     R0,#+0
   \   00000170   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   3439          }
   3440          
   3441          /**
   3442            * @brief  Stops the TIM DMA Burst mode 
   3443            * @param  htim : TIM handle
   3444            * @param  BurstRequestSrc : TIM DMA Request sources to disable
   3445            * @retval HAL status
   3446            */

   \                                 In section .text, align 2, keep-with-next
   3447          HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
   3448          {
   \                     HAL_TIM_DMABurst_WriteStop: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   3449            /* Check the parameters */
   3450            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3451          
   3452            /* Abort the DMA transfer (at least disable the DMA channel) */
   3453            switch(BurstRequestSrc)
   \   00000006   0x4628             MOV      R0,R5
   \   00000008   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000000C   0xD012             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_0
   \   0000000E   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000012   0xD013             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_1
   \   00000014   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000018   0xD014             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_2
   \   0000001A   0xF5B0 0x6F00      CMP      R0,#+2048
   \   0000001E   0xD015             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_3
   \   00000020   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000024   0xD016             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_4
   \   00000026   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000002A   0xD017             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_5
   \   0000002C   0xF5B0 0x4F80      CMP      R0,#+16384
   \   00000030   0xD018             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_6
   \   00000032   0xE01A             B.N      ??HAL_TIM_DMABurst_WriteStop_7
   3454            {
   3455              case TIM_DMA_UPDATE:
   3456              {
   3457                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
   \                     ??HAL_TIM_DMABurst_WriteStop_0: (+1)
   \   00000034   0x69E0             LDR      R0,[R4, #+28]
   \   00000036   0x.... 0x....      BL       HAL_DMA_Abort
   3458              }
   3459              break;
   \   0000003A   0xE016             B.N      ??HAL_TIM_DMABurst_WriteStop_7
   3460              case TIM_DMA_CC1:
   3461              {
   3462                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
   \                     ??HAL_TIM_DMABurst_WriteStop_1: (+1)
   \   0000003C   0x6A20             LDR      R0,[R4, #+32]
   \   0000003E   0x.... 0x....      BL       HAL_DMA_Abort
   3463              }
   3464              break;
   \   00000042   0xE012             B.N      ??HAL_TIM_DMABurst_WriteStop_7
   3465              case TIM_DMA_CC2:
   3466              {
   3467                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
   \                     ??HAL_TIM_DMABurst_WriteStop_2: (+1)
   \   00000044   0x6A60             LDR      R0,[R4, #+36]
   \   00000046   0x.... 0x....      BL       HAL_DMA_Abort
   3468              }
   3469              break;
   \   0000004A   0xE00E             B.N      ??HAL_TIM_DMABurst_WriteStop_7
   3470              case TIM_DMA_CC3:
   3471              {
   3472                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
   \                     ??HAL_TIM_DMABurst_WriteStop_3: (+1)
   \   0000004C   0x6AA0             LDR      R0,[R4, #+40]
   \   0000004E   0x.... 0x....      BL       HAL_DMA_Abort
   3473              }
   3474              break;
   \   00000052   0xE00A             B.N      ??HAL_TIM_DMABurst_WriteStop_7
   3475              case TIM_DMA_CC4:
   3476              {
   3477                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
   \                     ??HAL_TIM_DMABurst_WriteStop_4: (+1)
   \   00000054   0x6AE0             LDR      R0,[R4, #+44]
   \   00000056   0x.... 0x....      BL       HAL_DMA_Abort
   3478              }
   3479              break;
   \   0000005A   0xE006             B.N      ??HAL_TIM_DMABurst_WriteStop_7
   3480              case TIM_DMA_COM:
   3481              {
   3482                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
   \                     ??HAL_TIM_DMABurst_WriteStop_5: (+1)
   \   0000005C   0x6B20             LDR      R0,[R4, #+48]
   \   0000005E   0x.... 0x....      BL       HAL_DMA_Abort
   3483              }
   3484              break;
   \   00000062   0xE002             B.N      ??HAL_TIM_DMABurst_WriteStop_7
   3485              case TIM_DMA_TRIGGER:
   3486              {
   3487                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
   \                     ??HAL_TIM_DMABurst_WriteStop_6: (+1)
   \   00000064   0x6B60             LDR      R0,[R4, #+52]
   \   00000066   0x.... 0x....      BL       HAL_DMA_Abort
   3488              }
   3489              break;
   3490              default:
   3491              break;
   3492            }
   3493          
   3494            /* Disable the TIM Update DMA request */
   3495            __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
   \                     ??HAL_TIM_DMABurst_WriteStop_7: (+1)
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x68C1             LDR      R1,[R0, #+12]
   \   0000006E   0xEA21 0x0505      BIC      R5,R1,R5
   \   00000072   0x60C5             STR      R5,[R0, #+12]
   3496          
   3497            /* Return function status */
   3498            return HAL_OK;
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   3499          }
   3500          
   3501          /**
   3502            * @brief  Configure the DMA Burst to transfer Data from the TIM peripheral to the memory 
   3503            * @param  htim : TIM handle
   3504            * @param  BurstBaseAddress : TIM Base address from where the DMA will starts the Data read
   3505            *         This parameter can be one of the following values:
   3506            *            @arg TIM_DMABASE_CR1 
   3507            *            @arg TIM_DMABASE_CR2
   3508            *            @arg TIM_DMABASE_SMCR
   3509            *            @arg TIM_DMABASE_DIER
   3510            *            @arg TIM_DMABASE_SR
   3511            *            @arg TIM_DMABASE_EGR
   3512            *            @arg TIM_DMABASE_CCMR1
   3513            *            @arg TIM_DMABASE_CCMR2
   3514            *            @arg TIM_DMABASE_CCER
   3515            *            @arg TIM_DMABASE_CNT 
   3516            *            @arg TIM_DMABASE_PSC 
   3517            *            @arg TIM_DMABASE_ARR
   3518            *            @arg TIM_DMABASE_RCR
   3519            *            @arg TIM_DMABASE_CCR1
   3520            *            @arg TIM_DMABASE_CCR2
   3521            *            @arg TIM_DMABASE_CCR3 
   3522            *            @arg TIM_DMABASE_CCR4
   3523            *            @arg TIM_DMABASE_BDTR
   3524            *            @arg TIM_DMABASE_DCR
   3525            * @param  BurstRequestSrc : TIM DMA Request sources
   3526            *         This parameter can be one of the following values:
   3527            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   3528            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   3529            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   3530            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   3531            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   3532            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   3533            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   3534            * @param  BurstBuffer : The Buffer address.
   3535            * @param  BurstLength : DMA Burst length. This parameter can be one value
   3536            *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   3537            * @retval HAL status
   3538            */

   \                                 In section .text, align 2, keep-with-next
   3539          HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
   3540                                                       uint32_t  *BurstBuffer, uint32_t  BurstLength)
   3541          {
   \                     HAL_TIM_DMABurst_ReadStart: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460F             MOV      R7,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x461A             MOV      R2,R3
   3542            /* Check the parameters */
   3543            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   3544            assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
   3545            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3546            assert_param(IS_TIM_DMA_LENGTH(BurstLength));
   3547          
   3548            if((htim->State == HAL_TIM_STATE_BUSY))
   \   0000000A   0xF995 0x0039      LDRSB    R0,[R5, #+57]
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xD101             BNE.N    ??HAL_TIM_DMABurst_ReadStart_0
   3549            {
   3550               return HAL_BUSY;
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0xBDF2             POP      {R1,R4-R7,PC}
   3551            }
   \                     ??HAL_TIM_DMABurst_ReadStart_0: (+1)
   \   00000016   0x9C06             LDR      R4,[SP, #+24]
   3552            else if((htim->State == HAL_TIM_STATE_READY))
   \   00000018   0xF995 0x0039      LDRSB    R0,[R5, #+57]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD108             BNE.N    ??HAL_TIM_DMABurst_ReadStart_1
   3553            {
   3554              if((BurstBuffer == 0 ) && (BurstLength > 0))
   \   00000020   0x2A00             CMP      R2,#+0
   \   00000022   0xD103             BNE.N    ??HAL_TIM_DMABurst_ReadStart_2
   \   00000024   0x2C00             CMP      R4,#+0
   \   00000026   0xD001             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_2
   3555              {
   3556                return HAL_ERROR;
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xBDF2             POP      {R1,R4-R7,PC}
   3557              }
   3558              else
   3559              {
   3560                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_DMABurst_ReadStart_2: (+1)
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0xF885 0x0039      STRB     R0,[R5, #+57]
   3561              }
   3562            }
   3563            switch(BurstRequestSrc)
   \                     ??HAL_TIM_DMABurst_ReadStart_1: (+1)
   \   00000032   0x4630             MOV      R0,R6
   \   00000034   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000038   0xD012             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_3
   \   0000003A   0xF5B0 0x7F00      CMP      R0,#+512
   \   0000003E   0xD021             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_4
   \   00000040   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000044   0xD030             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_5
   \   00000046   0xF5B0 0x6F00      CMP      R0,#+2048
   \   0000004A   0xD03F             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_6
   \   0000004C   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000050   0xD04E             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_7
   \   00000052   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000056   0xD05D             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_8
   \   00000058   0xF5B0 0x4F80      CMP      R0,#+16384
   \   0000005C   0xD06C             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_9
   \   0000005E   0xE07C             B.N      ??HAL_TIM_DMABurst_ReadStart_10
   3564            {
   3565              case TIM_DMA_UPDATE:
   3566              {
   3567                /* Set the DMA Period elapsed callback */
   3568                htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_3: (+1)
   \   00000060   0x.... 0x....      ADR.W    R0,TIM_DMAPeriodElapsedCplt
   \   00000064   0x69E9             LDR      R1,[R5, #+28]
   \   00000066   0x6288             STR      R0,[R1, #+40]
   3569          
   3570                /* Set the DMA error callback */
   3571                htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
   \   00000068   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   0000006C   0x69E9             LDR      R1,[R5, #+28]
   \   0000006E   0x6308             STR      R0,[R1, #+48]
   3572          
   3573                /* Enable the DMA channel */
   3574                 HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);
   \   00000070   0x4623             MOV      R3,R4
   \   00000072   0x0A1B             LSRS     R3,R3,#+8
   \   00000074   0x1C5B             ADDS     R3,R3,#+1
   \   00000076   0x6828             LDR      R0,[R5, #+0]
   \   00000078   0xF100 0x014C      ADD      R1,R0,#+76
   \   0000007C   0x69E8             LDR      R0,[R5, #+28]
   \   0000007E   0x.... 0x....      BL       HAL_DMA_Start_IT
   3575              }
   3576              break;
   \   00000082   0xE06A             B.N      ??HAL_TIM_DMABurst_ReadStart_10
   3577              case TIM_DMA_CC1:
   3578              {
   3579                /* Set the DMA Period elapsed callback */
   3580                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback =  TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_4: (+1)
   \   00000084   0x.... 0x....      ADR.W    R0,TIM_DMACaptureCplt
   \   00000088   0x6A29             LDR      R1,[R5, #+32]
   \   0000008A   0x6288             STR      R0,[R1, #+40]
   3581          
   3582                /* Set the DMA error callback */
   3583                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \   0000008C   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   00000090   0x6A29             LDR      R1,[R5, #+32]
   \   00000092   0x6308             STR      R0,[R1, #+48]
   3584          
   3585                /* Enable the DMA channel */
   3586                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);
   \   00000094   0x4623             MOV      R3,R4
   \   00000096   0x0A1B             LSRS     R3,R3,#+8
   \   00000098   0x1C5B             ADDS     R3,R3,#+1
   \   0000009A   0x6828             LDR      R0,[R5, #+0]
   \   0000009C   0xF100 0x014C      ADD      R1,R0,#+76
   \   000000A0   0x6A28             LDR      R0,[R5, #+32]
   \   000000A2   0x.... 0x....      BL       HAL_DMA_Start_IT
   3587              }
   3588              break;
   \   000000A6   0xE058             B.N      ??HAL_TIM_DMABurst_ReadStart_10
   3589              case TIM_DMA_CC2:
   3590              {
   3591                /* Set the DMA Period elapsed callback */
   3592                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback =  TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_5: (+1)
   \   000000A8   0x.... 0x....      ADR.W    R0,TIM_DMACaptureCplt
   \   000000AC   0x6A69             LDR      R1,[R5, #+36]
   \   000000AE   0x6288             STR      R0,[R1, #+40]
   3593          
   3594                /* Set the DMA error callback */
   3595                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \   000000B0   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000B4   0x6A69             LDR      R1,[R5, #+36]
   \   000000B6   0x6308             STR      R0,[R1, #+48]
   3596          
   3597                /* Enable the DMA channel */
   3598                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);
   \   000000B8   0x4623             MOV      R3,R4
   \   000000BA   0x0A1B             LSRS     R3,R3,#+8
   \   000000BC   0x1C5B             ADDS     R3,R3,#+1
   \   000000BE   0x6828             LDR      R0,[R5, #+0]
   \   000000C0   0xF100 0x014C      ADD      R1,R0,#+76
   \   000000C4   0x6A68             LDR      R0,[R5, #+36]
   \   000000C6   0x.... 0x....      BL       HAL_DMA_Start_IT
   3599              }
   3600              break;
   \   000000CA   0xE046             B.N      ??HAL_TIM_DMABurst_ReadStart_10
   3601              case TIM_DMA_CC3:
   3602              {
   3603                /* Set the DMA Period elapsed callback */
   3604                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback =  TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_6: (+1)
   \   000000CC   0x.... 0x....      ADR.W    R0,TIM_DMACaptureCplt
   \   000000D0   0x6AA9             LDR      R1,[R5, #+40]
   \   000000D2   0x6288             STR      R0,[R1, #+40]
   3605          
   3606                /* Set the DMA error callback */
   3607                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \   000000D4   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000D8   0x6AA9             LDR      R1,[R5, #+40]
   \   000000DA   0x6308             STR      R0,[R1, #+48]
   3608          
   3609                /* Enable the DMA channel */
   3610                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);
   \   000000DC   0x4623             MOV      R3,R4
   \   000000DE   0x0A1B             LSRS     R3,R3,#+8
   \   000000E0   0x1C5B             ADDS     R3,R3,#+1
   \   000000E2   0x6828             LDR      R0,[R5, #+0]
   \   000000E4   0xF100 0x014C      ADD      R1,R0,#+76
   \   000000E8   0x6AA8             LDR      R0,[R5, #+40]
   \   000000EA   0x.... 0x....      BL       HAL_DMA_Start_IT
   3611              }
   3612              break;
   \   000000EE   0xE034             B.N      ??HAL_TIM_DMABurst_ReadStart_10
   3613              case TIM_DMA_CC4:
   3614              {
   3615                /* Set the DMA Period elapsed callback */
   3616                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback =  TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_7: (+1)
   \   000000F0   0x.... 0x....      ADR.W    R0,TIM_DMACaptureCplt
   \   000000F4   0x6AE9             LDR      R1,[R5, #+44]
   \   000000F6   0x6288             STR      R0,[R1, #+40]
   3617          
   3618                /* Set the DMA error callback */
   3619                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \   000000F8   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000FC   0x6AE9             LDR      R1,[R5, #+44]
   \   000000FE   0x6308             STR      R0,[R1, #+48]
   3620          
   3621                /* Enable the DMA channel */
   3622                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);
   \   00000100   0x4623             MOV      R3,R4
   \   00000102   0x0A1B             LSRS     R3,R3,#+8
   \   00000104   0x1C5B             ADDS     R3,R3,#+1
   \   00000106   0x6828             LDR      R0,[R5, #+0]
   \   00000108   0xF100 0x014C      ADD      R1,R0,#+76
   \   0000010C   0x6AE8             LDR      R0,[R5, #+44]
   \   0000010E   0x.... 0x....      BL       HAL_DMA_Start_IT
   3623              }
   3624              break;
   \   00000112   0xE022             B.N      ??HAL_TIM_DMABurst_ReadStart_10
   3625              case TIM_DMA_COM:
   3626              {
   3627                /* Set the DMA Period elapsed callback */
   3628                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_8: (+1)
   \   00000114   0x.... 0x....      LDR.W    R0,??DataTable29
   \   00000118   0x6B29             LDR      R1,[R5, #+48]
   \   0000011A   0x6288             STR      R0,[R1, #+40]
   3629          
   3630                /* Set the DMA error callback */
   3631                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
   \   0000011C   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   00000120   0x6B29             LDR      R1,[R5, #+48]
   \   00000122   0x6308             STR      R0,[R1, #+48]
   3632          
   3633                /* Enable the DMA channel */
   3634                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);
   \   00000124   0x4623             MOV      R3,R4
   \   00000126   0x0A1B             LSRS     R3,R3,#+8
   \   00000128   0x1C5B             ADDS     R3,R3,#+1
   \   0000012A   0x6828             LDR      R0,[R5, #+0]
   \   0000012C   0xF100 0x014C      ADD      R1,R0,#+76
   \   00000130   0x6B28             LDR      R0,[R5, #+48]
   \   00000132   0x.... 0x....      BL       HAL_DMA_Start_IT
   3635              }
   3636              break;
   \   00000136   0xE010             B.N      ??HAL_TIM_DMABurst_ReadStart_10
   3637              case TIM_DMA_TRIGGER:
   3638              {
   3639                /* Set the DMA Period elapsed callback */
   3640                htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_9: (+1)
   \   00000138   0x.... 0x....      ADR.W    R0,TIM_DMATriggerCplt
   \   0000013C   0x6B69             LDR      R1,[R5, #+52]
   \   0000013E   0x6288             STR      R0,[R1, #+40]
   3641          
   3642                /* Set the DMA error callback */
   3643                htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
   \   00000140   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   00000144   0x6B69             LDR      R1,[R5, #+52]
   \   00000146   0x6308             STR      R0,[R1, #+48]
   3644          
   3645                /* Enable the DMA channel */
   3646                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);
   \   00000148   0x4623             MOV      R3,R4
   \   0000014A   0x0A1B             LSRS     R3,R3,#+8
   \   0000014C   0x1C5B             ADDS     R3,R3,#+1
   \   0000014E   0x6828             LDR      R0,[R5, #+0]
   \   00000150   0xF100 0x014C      ADD      R1,R0,#+76
   \   00000154   0x6B68             LDR      R0,[R5, #+52]
   \   00000156   0x.... 0x....      BL       HAL_DMA_Start_IT
   3647              }
   3648              break;
   3649              default:
   3650              break;
   3651            }
   3652          
   3653            /* configure the DMA Burst Mode */
   3654            htim->Instance->DCR = BurstBaseAddress | BurstLength;
   \                     ??HAL_TIM_DMABurst_ReadStart_10: (+1)
   \   0000015A   0x4327             ORRS     R7,R4,R7
   \   0000015C   0x6828             LDR      R0,[R5, #+0]
   \   0000015E   0x6487             STR      R7,[R0, #+72]
   3655          
   3656            /* Enable the TIM DMA Request */
   3657            __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
   \   00000160   0x6828             LDR      R0,[R5, #+0]
   \   00000162   0x68C1             LDR      R1,[R0, #+12]
   \   00000164   0x430E             ORRS     R6,R6,R1
   \   00000166   0x60C6             STR      R6,[R0, #+12]
   3658          
   3659            htim->State = HAL_TIM_STATE_READY;
   \   00000168   0x2001             MOVS     R0,#+1
   \   0000016A   0xF885 0x0039      STRB     R0,[R5, #+57]
   3660          
   3661            /* Return function status */
   3662            return HAL_OK;
   \   0000016E   0x2000             MOVS     R0,#+0
   \   00000170   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   3663          }
   3664          
   3665          /**
   3666            * @brief  Stop the DMA burst reading 
   3667            * @param  htim : TIM handle
   3668            * @param  BurstRequestSrc : TIM DMA Request sources to disable.
   3669            * @retval HAL status
   3670            */

   \                                 In section .text, align 2, keep-with-next
   3671          HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
   3672          {
   \                     HAL_TIM_DMABurst_ReadStop: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   3673            /* Check the parameters */
   3674            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3675          
   3676            /* Abort the DMA transfer (at least disable the DMA channel) */
   3677            switch(BurstRequestSrc)
   \   00000006   0x4628             MOV      R0,R5
   \   00000008   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000000C   0xD012             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_0
   \   0000000E   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000012   0xD013             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_1
   \   00000014   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000018   0xD014             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_2
   \   0000001A   0xF5B0 0x6F00      CMP      R0,#+2048
   \   0000001E   0xD015             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_3
   \   00000020   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000024   0xD016             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_4
   \   00000026   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000002A   0xD017             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_5
   \   0000002C   0xF5B0 0x4F80      CMP      R0,#+16384
   \   00000030   0xD018             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_6
   \   00000032   0xE01A             B.N      ??HAL_TIM_DMABurst_ReadStop_7
   3678            {
   3679              case TIM_DMA_UPDATE:
   3680              {
   3681                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
   \                     ??HAL_TIM_DMABurst_ReadStop_0: (+1)
   \   00000034   0x69E0             LDR      R0,[R4, #+28]
   \   00000036   0x.... 0x....      BL       HAL_DMA_Abort
   3682              }
   3683              break;
   \   0000003A   0xE016             B.N      ??HAL_TIM_DMABurst_ReadStop_7
   3684              case TIM_DMA_CC1:
   3685              {
   3686                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
   \                     ??HAL_TIM_DMABurst_ReadStop_1: (+1)
   \   0000003C   0x6A20             LDR      R0,[R4, #+32]
   \   0000003E   0x.... 0x....      BL       HAL_DMA_Abort
   3687              }
   3688              break;
   \   00000042   0xE012             B.N      ??HAL_TIM_DMABurst_ReadStop_7
   3689              case TIM_DMA_CC2:
   3690              {
   3691                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
   \                     ??HAL_TIM_DMABurst_ReadStop_2: (+1)
   \   00000044   0x6A60             LDR      R0,[R4, #+36]
   \   00000046   0x.... 0x....      BL       HAL_DMA_Abort
   3692              }
   3693              break;
   \   0000004A   0xE00E             B.N      ??HAL_TIM_DMABurst_ReadStop_7
   3694              case TIM_DMA_CC3:
   3695              {
   3696                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
   \                     ??HAL_TIM_DMABurst_ReadStop_3: (+1)
   \   0000004C   0x6AA0             LDR      R0,[R4, #+40]
   \   0000004E   0x.... 0x....      BL       HAL_DMA_Abort
   3697              }
   3698              break;
   \   00000052   0xE00A             B.N      ??HAL_TIM_DMABurst_ReadStop_7
   3699              case TIM_DMA_CC4:
   3700              {
   3701                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
   \                     ??HAL_TIM_DMABurst_ReadStop_4: (+1)
   \   00000054   0x6AE0             LDR      R0,[R4, #+44]
   \   00000056   0x.... 0x....      BL       HAL_DMA_Abort
   3702              }
   3703              break;
   \   0000005A   0xE006             B.N      ??HAL_TIM_DMABurst_ReadStop_7
   3704              case TIM_DMA_COM:
   3705              {
   3706                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
   \                     ??HAL_TIM_DMABurst_ReadStop_5: (+1)
   \   0000005C   0x6B20             LDR      R0,[R4, #+48]
   \   0000005E   0x.... 0x....      BL       HAL_DMA_Abort
   3707              }
   3708              break;
   \   00000062   0xE002             B.N      ??HAL_TIM_DMABurst_ReadStop_7
   3709              case TIM_DMA_TRIGGER:
   3710              {
   3711                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
   \                     ??HAL_TIM_DMABurst_ReadStop_6: (+1)
   \   00000064   0x6B60             LDR      R0,[R4, #+52]
   \   00000066   0x.... 0x....      BL       HAL_DMA_Abort
   3712              }
   3713              break;
   3714              default:
   3715              break;
   3716            }
   3717          
   3718            /* Disable the TIM Update DMA request */
   3719            __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
   \                     ??HAL_TIM_DMABurst_ReadStop_7: (+1)
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x68C1             LDR      R1,[R0, #+12]
   \   0000006E   0xEA21 0x0505      BIC      R5,R1,R5
   \   00000072   0x60C5             STR      R5,[R0, #+12]
   3720          
   3721            /* Return function status */
   3722            return HAL_OK;
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   3723          }
   3724          
   3725          /**
   3726            * @brief  Generate a software event
   3727            * @param  htim : TIM handle
   3728            * @param  EventSource : specifies the event source.
   3729            *          This parameter can be one of the following values:
   3730            *            @arg TIM_EVENTSOURCE_UPDATE: Timer update Event source
   3731            *            @arg TIM_EVENTSOURCE_CC1: Timer Capture Compare 1 Event source
   3732            *            @arg TIM_EVENTSOURCE_CC2: Timer Capture Compare 2 Event source
   3733            *            @arg TIM_EVENTSOURCE_CC3: Timer Capture Compare 3 Event source
   3734            *            @arg TIM_EVENTSOURCE_CC4: Timer Capture Compare 4 Event source
   3735            *            @arg TIM_EVENTSOURCE_COM: Timer COM event source 
   3736            *            @arg TIM_EVENTSOURCE_TRIGGER: Timer Trigger Event source
   3737            *            @arg TIM_EVENTSOURCE_BREAK: Timer Break event source
   3738            * @note TIM6 and TIM7 can only generate an update event.
   3739            * @note TIM_EVENTSOURCE_COM and TIM_EVENTSOURCE_BREAK are used only with TIM1, TIM15, TIM16 and TIM17.
   3740            * @retval HAL status
   3741            */
   3742          

   \                                 In section .text, align 2, keep-with-next
   3743          HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)
   3744          {
   3745            /* Check the parameters */
   3746            assert_param(IS_TIM_INSTANCE(htim->Instance));
   3747            assert_param(IS_TIM_EVENT_SOURCE(EventSource));
   3748          
   3749            /* Process Locked */
   3750            __HAL_LOCK(htim);
   3751          
   3752            /* Change the TIM state */
   3753            htim->State = HAL_TIM_STATE_BUSY;
   \                     HAL_TIM_GenerateEvent: (+1)
   \   00000000   0x2202             MOVS     R2,#+2
   \   00000002   0xF880 0x2039      STRB     R2,[R0, #+57]
   3754          
   3755            /* Set the event sources */
   3756            htim->Instance->EGR = EventSource;
   \   00000006   0x6802             LDR      R2,[R0, #+0]
   \   00000008   0x6151             STR      R1,[R2, #+20]
   3757          
   3758            /* Change the TIM state */
   3759            htim->State = HAL_TIM_STATE_READY;
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0xF880 0x1039      STRB     R1,[R0, #+57]
   3760          
   3761            __HAL_UNLOCK(htim);
   3762          
   3763            /* Return function status */
   3764            return HAL_OK;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4770             BX       LR               ;; return
   3765          }
   3766          
   3767          /**
   3768            * @brief  Configures the OCRef clear feature
   3769            * @param  htim : TIM handle
   3770            * @param  sClearInputConfig : pointer to a TIM_ClearInputConfigTypeDef structure that
   3771            *         contains the OCREF clear feature and parameters for the TIM peripheral.
   3772            * @param  Channel : specifies the TIM Channel
   3773            *          This parameter can be one of the following values:
   3774            *            @arg TIM_CHANNEL_1: TIM Channel 1
   3775            *            @arg TIM_CHANNEL_2: TIM Channel 2
   3776            *            @arg TIM_CHANNEL_3: TIM Channel 3
   3777            *            @arg TIM_CHANNEL_4: TIM Channel 4
   3778            * @retval HAL status
   3779            */ 

   \                                 In section .text, align 2, keep-with-next
   3780          HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim, TIM_ClearInputConfigTypeDef * sClearInputConfig, uint32_t Channel)
   3781          {
   \                     HAL_TIM_ConfigOCrefClear: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   3782            uint32_t tmpsmcr = 0;
   3783          
   3784            /* Check the parameters */
   3785            assert_param(IS_TIM_OCXREF_CLEAR_INSTANCE(htim->Instance));
   3786            assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
   3787            assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
   3788            assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
   3789            assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
   3790          
   3791            /* Process Locked */
   3792            __HAL_LOCK(htim);
   3793          
   3794            htim->State = HAL_TIM_STATE_BUSY;
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0xF884 0x0039      STRB     R0,[R4, #+57]
   3795          
   3796            switch (sClearInputConfig->ClearInputSource)
   \   0000000E   0x6868             LDR      R0,[R5, #+4]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD002             BEQ.N    ??HAL_TIM_ConfigOCrefClear_0
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD004             BEQ.N    ??HAL_TIM_ConfigOCrefClear_1
   \   00000018   0xE00E             B.N      ??HAL_TIM_ConfigOCrefClear_2
   3797            {
   3798              case TIM_CLEARINPUTSOURCE_NONE:
   3799              {
   3800                /* Clear the OCREF clear selection bit */
   3801                tmpsmcr &= ~TIM_SMCR_OCCS;
   3802          
   3803                /* Clear the ETR Bits */
   3804                tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   3805          
   3806                /* Set TIMx_SMCR */
   3807                htim->Instance->SMCR = tmpsmcr;
   \                     ??HAL_TIM_ConfigOCrefClear_0: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x6821             LDR      R1,[R4, #+0]
   \   0000001E   0x6088             STR      R0,[R1, #+8]
   3808             }
   3809              break;
   \   00000020   0xE00A             B.N      ??HAL_TIM_ConfigOCrefClear_2
   3810          
   3811              case TIM_CLEARINPUTSOURCE_ETR:
   3812              {
   3813                TIM_ETR_SetConfig(htim->Instance,
   3814                                  sClearInputConfig->ClearInputPrescaler,
   3815                                  sClearInputConfig->ClearInputPolarity,
   3816                                  sClearInputConfig->ClearInputFilter);
   \                     ??HAL_TIM_ConfigOCrefClear_1: (+1)
   \   00000022   0x692B             LDR      R3,[R5, #+16]
   \   00000024   0x68AA             LDR      R2,[R5, #+8]
   \   00000026   0x68E9             LDR      R1,[R5, #+12]
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x.... 0x....      BL       TIM_ETR_SetConfig
   3817          
   3818                /* Set the OCREF clear selection bit */
   3819                htim->Instance->SMCR |= TIM_SMCR_OCCS;
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x6881             LDR      R1,[R0, #+8]
   \   00000032   0xF041 0x0108      ORR      R1,R1,#0x8
   \   00000036   0x6081             STR      R1,[R0, #+8]
   3820              }
   3821              break;
   3822              default:
   3823              break;
   3824            }
   3825          
   3826            switch (Channel)
   \                     ??HAL_TIM_ConfigOCrefClear_2: (+1)
   \   00000038   0x2E00             CMP      R6,#+0
   \   0000003A   0xD006             BEQ.N    ??HAL_TIM_ConfigOCrefClear_3
   \   0000003C   0x2E04             CMP      R6,#+4
   \   0000003E   0xD011             BEQ.N    ??HAL_TIM_ConfigOCrefClear_4
   \   00000040   0x2E08             CMP      R6,#+8
   \   00000042   0xD01C             BEQ.N    ??HAL_TIM_ConfigOCrefClear_5
   \   00000044   0x2E0C             CMP      R6,#+12
   \   00000046   0xD027             BEQ.N    ??HAL_TIM_ConfigOCrefClear_6
   \   00000048   0xE032             B.N      ??HAL_TIM_ConfigOCrefClear_7
   3827            {
   3828              case TIM_CHANNEL_1:
   3829                {
   3830                  if(sClearInputConfig->ClearInputState != RESET)
   \                     ??HAL_TIM_ConfigOCrefClear_3: (+1)
   \   0000004A   0x6821             LDR      R1,[R4, #+0]
   \   0000004C   0x6828             LDR      R0,[R5, #+0]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0x6988             LDR      R0,[R1, #+24]
   \   00000052   0xD003             BEQ.N    ??HAL_TIM_ConfigOCrefClear_8
   3831                  {
   3832                    /* Enable the Ocref clear feature for Channel 1 */
   3833                    htim->Instance->CCMR1 |= TIM_CCMR1_OC1CE;
   \   00000054   0xF040 0x0080      ORR      R0,R0,#0x80
   \   00000058   0x6188             STR      R0,[R1, #+24]
   \   0000005A   0xE029             B.N      ??HAL_TIM_ConfigOCrefClear_7
   3834                  }
   3835                  else
   3836                  {
   3837                    /* Disable the Ocref clear feature for Channel 1 */
   3838                  htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1CE;
   \                     ??HAL_TIM_ConfigOCrefClear_8: (+1)
   \   0000005C   0xF020 0x0080      BIC      R0,R0,#0x80
   \   00000060   0x6188             STR      R0,[R1, #+24]
   \   00000062   0xE025             B.N      ??HAL_TIM_ConfigOCrefClear_7
   3839                  }
   3840                }
   3841                break;
   3842              case TIM_CHANNEL_2:
   3843                {
   3844                  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3845                  if(sClearInputConfig->ClearInputState != RESET)
   \                     ??HAL_TIM_ConfigOCrefClear_4: (+1)
   \   00000064   0x6821             LDR      R1,[R4, #+0]
   \   00000066   0x6828             LDR      R0,[R5, #+0]
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0x6988             LDR      R0,[R1, #+24]
   \   0000006C   0xD003             BEQ.N    ??HAL_TIM_ConfigOCrefClear_9
   3846                  {
   3847                    /* Enable the Ocref clear feature for Channel 2 */
   3848                    htim->Instance->CCMR1 |= TIM_CCMR1_OC2CE;
   \   0000006E   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   00000072   0x6188             STR      R0,[R1, #+24]
   \   00000074   0xE01C             B.N      ??HAL_TIM_ConfigOCrefClear_7
   3849                  }
   3850                  else
   3851                  {
   3852                    /* Disable the Ocref clear feature for Channel 2 */
   3853                    htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2CE;
   \                     ??HAL_TIM_ConfigOCrefClear_9: (+1)
   \   00000076   0xF420 0x4000      BIC      R0,R0,#0x8000
   \   0000007A   0x6188             STR      R0,[R1, #+24]
   \   0000007C   0xE018             B.N      ??HAL_TIM_ConfigOCrefClear_7
   3854                  }
   3855                }
   3856              break;
   3857              case TIM_CHANNEL_3:
   3858                {
   3859                  assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3860                  if(sClearInputConfig->ClearInputState != RESET)
   \                     ??HAL_TIM_ConfigOCrefClear_5: (+1)
   \   0000007E   0x6821             LDR      R1,[R4, #+0]
   \   00000080   0x6828             LDR      R0,[R5, #+0]
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0x69C8             LDR      R0,[R1, #+28]
   \   00000086   0xD003             BEQ.N    ??HAL_TIM_ConfigOCrefClear_10
   3861                  {
   3862                    /* Enable the Ocref clear feature for Channel 3 */
   3863                    htim->Instance->CCMR2 |= TIM_CCMR2_OC3CE;
   \   00000088   0xF040 0x0080      ORR      R0,R0,#0x80
   \   0000008C   0x61C8             STR      R0,[R1, #+28]
   \   0000008E   0xE00F             B.N      ??HAL_TIM_ConfigOCrefClear_7
   3864                  }
   3865                  else
   3866                  {
   3867                    /* Disable the Ocref clear feature for Channel 3 */
   3868                  htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3CE;
   \                     ??HAL_TIM_ConfigOCrefClear_10: (+1)
   \   00000090   0xF020 0x0080      BIC      R0,R0,#0x80
   \   00000094   0x61C8             STR      R0,[R1, #+28]
   \   00000096   0xE00B             B.N      ??HAL_TIM_ConfigOCrefClear_7
   3869                  }
   3870                }
   3871              break;
   3872              case TIM_CHANNEL_4:
   3873                {
   3874                  assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3875                  if(sClearInputConfig->ClearInputState != RESET)
   \                     ??HAL_TIM_ConfigOCrefClear_6: (+1)
   \   00000098   0x6821             LDR      R1,[R4, #+0]
   \   0000009A   0x6828             LDR      R0,[R5, #+0]
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0x69C8             LDR      R0,[R1, #+28]
   \   000000A0   0xD003             BEQ.N    ??HAL_TIM_ConfigOCrefClear_11
   3876                  {
   3877                    /* Enable the Ocref clear feature for Channel 4 */
   3878                    htim->Instance->CCMR2 |= TIM_CCMR2_OC4CE;
   \   000000A2   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   000000A6   0x61C8             STR      R0,[R1, #+28]
   \   000000A8   0xE002             B.N      ??HAL_TIM_ConfigOCrefClear_7
   3879                  }
   3880                  else
   3881                  {
   3882                    /* Disable the Ocref clear feature for Channel 4 */
   3883                  htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4CE;
   \                     ??HAL_TIM_ConfigOCrefClear_11: (+1)
   \   000000AA   0xF420 0x4000      BIC      R0,R0,#0x8000
   \   000000AE   0x61C8             STR      R0,[R1, #+28]
   3884                  }
   3885                }
   3886              break;
   3887              default:
   3888              break;
   3889            }
   3890          
   3891            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_ConfigOCrefClear_7: (+1)
   \   000000B0   0x2001             MOVS     R0,#+1
   \   000000B2   0xF884 0x0039      STRB     R0,[R4, #+57]
   3892          
   3893            __HAL_UNLOCK(htim);
   3894          
   3895            return HAL_OK;
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0xBD70             POP      {R4-R6,PC}       ;; return
   3896          }
   3897          
   3898          /**
   3899            * @brief   Configures the clock source to be used
   3900            * @param  htim : TIM handle
   3901            * @param  sClockSourceConfig : pointer to a TIM_ClockConfigTypeDef structure that
   3902            *         contains the clock source information for the TIM peripheral.
   3903            * @retval HAL status
   3904            */ 

   \                                 In section .text, align 2, keep-with-next
   3905          HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig)
   3906          {
   \                     HAL_TIM_ConfigClockSource: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   3907            uint32_t tmpsmcr = 0;
   3908          
   3909            /* Process Locked */
   3910            __HAL_LOCK(htim);
   3911          
   3912            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
   3913          
   3914            /* Check the parameters */
   3915            assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
   3916          
   3917            /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
   3918            tmpsmcr = htim->Instance->SMCR;
   \   0000000A   0x6823             LDR      R3,[R4, #+0]
   \   0000000C   0x689A             LDR      R2,[R3, #+8]
   3919            tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
   3920            tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   3921            htim->Instance->SMCR = tmpsmcr;
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable29_1  ;; 0xffff0088
   \   00000012   0x4002             ANDS     R2,R0,R2
   \   00000014   0x609A             STR      R2,[R3, #+8]
   3922          
   3923            switch (sClockSourceConfig->ClockSource)
   \   00000016   0x6808             LDR      R0,[R1, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD050             BEQ.N    ??HAL_TIM_ConfigClockSource_0
   \   0000001C   0x2810             CMP      R0,#+16
   \   0000001E   0xD053             BEQ.N    ??HAL_TIM_ConfigClockSource_1
   \   00000020   0x2820             CMP      R0,#+32
   \   00000022   0xD056             BEQ.N    ??HAL_TIM_ConfigClockSource_2
   \   00000024   0x2830             CMP      R0,#+48
   \   00000026   0xD059             BEQ.N    ??HAL_TIM_ConfigClockSource_3
   \   00000028   0x2840             CMP      R0,#+64
   \   0000002A   0xD03E             BEQ.N    ??HAL_TIM_ConfigClockSource_4
   \   0000002C   0x2850             CMP      R0,#+80
   \   0000002E   0xD028             BEQ.N    ??HAL_TIM_ConfigClockSource_5
   \   00000030   0x2860             CMP      R0,#+96
   \   00000032   0xD030             BEQ.N    ??HAL_TIM_ConfigClockSource_6
   \   00000034   0x2870             CMP      R0,#+112
   \   00000036   0xD00C             BEQ.N    ??HAL_TIM_ConfigClockSource_7
   \   00000038   0xF5B0 0x5F80      CMP      R0,#+4096
   \   0000003C   0xD003             BEQ.N    ??HAL_TIM_ConfigClockSource_8
   \   0000003E   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000042   0xD012             BEQ.N    ??HAL_TIM_ConfigClockSource_9
   \   00000044   0xE04E             B.N      ??HAL_TIM_ConfigClockSource_10
   3924            {
   3925            case TIM_CLOCKSOURCE_INTERNAL:
   3926              {
   3927                assert_param(IS_TIM_INSTANCE(htim->Instance));
   3928                /* Disable slave mode to clock the prescaler directly with the internal clock */
   3929                htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \                     ??HAL_TIM_ConfigClockSource_8: (+1)
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x6881             LDR      R1,[R0, #+8]
   \   0000004A   0x08C9             LSRS     R1,R1,#+3
   \   0000004C   0x00C9             LSLS     R1,R1,#+3
   \   0000004E   0x6081             STR      R1,[R0, #+8]
   3930              }
   3931              break;
   \   00000050   0xE048             B.N      ??HAL_TIM_ConfigClockSource_10
   3932          
   3933            case TIM_CLOCKSOURCE_ETRMODE1:
   3934              {
   3935                /* Check whether or not the timer instance supports external trigger input mode 1 (ETRF)*/
   3936                assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
   3937          
   3938                /* Check ETR input conditioning related parameters */
   3939                assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   3940                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   3941                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   3942                
   3943                /* Configure the ETR Clock source */
   3944                TIM_ETR_SetConfig(htim->Instance,
   3945                                  sClockSourceConfig->ClockPrescaler,
   3946                                  sClockSourceConfig->ClockPolarity,
   3947                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_7: (+1)
   \   00000052   0x68CB             LDR      R3,[R1, #+12]
   \   00000054   0x684A             LDR      R2,[R1, #+4]
   \   00000056   0x6889             LDR      R1,[R1, #+8]
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x.... 0x....      BL       TIM_ETR_SetConfig
   3948                /* Get the TIMx SMCR register value */
   3949                tmpsmcr = htim->Instance->SMCR;
   \   0000005E   0x6821             LDR      R1,[R4, #+0]
   \   00000060   0x6888             LDR      R0,[R1, #+8]
   3950                /* Reset the SMS and TS Bits */
   3951                tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
   3952                /* Select the External clock mode1 and the ETRF trigger */
   3953                tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
   3954                /* Write to TIMx SMCR */
   3955                htim->Instance->SMCR = tmpsmcr;
   \   00000062   0xF040 0x0077      ORR      R0,R0,#0x77
   \   00000066   0x6088             STR      R0,[R1, #+8]
   3956              }
   3957              break;
   \   00000068   0xE03C             B.N      ??HAL_TIM_ConfigClockSource_10
   3958          
   3959            case TIM_CLOCKSOURCE_ETRMODE2:
   3960              {
   3961                /* Check whether or not the timer instance supports external trigger input mode 2 (ETRF)*/
   3962                assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));
   3963          
   3964                /* Check ETR input conditioning related parameters */
   3965                assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   3966                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   3967                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   3968                
   3969                /* Configure the ETR Clock source */
   3970                TIM_ETR_SetConfig(htim->Instance,
   3971                                  sClockSourceConfig->ClockPrescaler,
   3972                                  sClockSourceConfig->ClockPolarity,
   3973                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_9: (+1)
   \   0000006A   0x68CB             LDR      R3,[R1, #+12]
   \   0000006C   0x684A             LDR      R2,[R1, #+4]
   \   0000006E   0x6889             LDR      R1,[R1, #+8]
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x.... 0x....      BL       TIM_ETR_SetConfig
   3974                /* Enable the External clock mode2 */
   3975                htim->Instance->SMCR |= TIM_SMCR_ECE;
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0x6881             LDR      R1,[R0, #+8]
   \   0000007A   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   0000007E   0x6081             STR      R1,[R0, #+8]
   3976              }
   3977              break;
   \   00000080   0xE030             B.N      ??HAL_TIM_ConfigClockSource_10
   3978          
   3979            case TIM_CLOCKSOURCE_TI1:
   3980              {
   3981                /* Check whether or not the timer instance supports external clock mode 1 */
   3982                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   3983          
   3984                /* Check TI1 input conditioning related parameters */
   3985                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   3986                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   3987                
   3988                TIM_TI1_ConfigInputStage(htim->Instance,
   3989                                         sClockSourceConfig->ClockPolarity,
   3990                                         sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_5: (+1)
   \   00000082   0x68CA             LDR      R2,[R1, #+12]
   \   00000084   0x6849             LDR      R1,[R1, #+4]
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x.... 0x....      BL       TIM_TI1_ConfigInputStage
   3991                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
   \   0000008C   0x2150             MOVS     R1,#+80
   \   0000008E   0x6820             LDR      R0,[R4, #+0]
   \   00000090   0x.... 0x....      BL       TIM_ITRx_SetConfig
   3992              }
   3993              break;
   \   00000094   0xE026             B.N      ??HAL_TIM_ConfigClockSource_10
   3994            case TIM_CLOCKSOURCE_TI2:
   3995              {
   3996                /* Check whether or not the timer instance supports external clock mode 1 (ETRF)*/
   3997                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   3998          
   3999                 /* Check TI2 input conditioning related parameters */
   4000                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4001                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4002          
   4003                TIM_TI2_ConfigInputStage(htim->Instance,
   4004                                         sClockSourceConfig->ClockPolarity,
   4005                                         sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_6: (+1)
   \   00000096   0x68CA             LDR      R2,[R1, #+12]
   \   00000098   0x6849             LDR      R1,[R1, #+4]
   \   0000009A   0x6820             LDR      R0,[R4, #+0]
   \   0000009C   0x.... 0x....      BL       TIM_TI2_ConfigInputStage
   4006                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
   \   000000A0   0x2160             MOVS     R1,#+96
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x.... 0x....      BL       TIM_ITRx_SetConfig
   4007              }
   4008              break;
   \   000000A8   0xE01C             B.N      ??HAL_TIM_ConfigClockSource_10
   4009            case TIM_CLOCKSOURCE_TI1ED:
   4010              {
   4011                /* Check whether or not the timer instance supports external clock mode 1 */
   4012                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   4013          
   4014                /* Check TI1 input conditioning related parameters */
   4015                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4016                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4017          
   4018                TIM_TI1_ConfigInputStage(htim->Instance,
   4019                                         sClockSourceConfig->ClockPolarity,
   4020                                         sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_4: (+1)
   \   000000AA   0x68CA             LDR      R2,[R1, #+12]
   \   000000AC   0x6849             LDR      R1,[R1, #+4]
   \   000000AE   0x6820             LDR      R0,[R4, #+0]
   \   000000B0   0x.... 0x....      BL       TIM_TI1_ConfigInputStage
   4021                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
   \   000000B4   0x2140             MOVS     R1,#+64
   \   000000B6   0x6820             LDR      R0,[R4, #+0]
   \   000000B8   0x.... 0x....      BL       TIM_ITRx_SetConfig
   4022              }
   4023              break;
   \   000000BC   0xE012             B.N      ??HAL_TIM_ConfigClockSource_10
   4024            case TIM_CLOCKSOURCE_ITR0:
   4025              {
   4026                /* Check whether or not the timer instance supports external clock mode 1 */
   4027                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   4028          
   4029                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR0);
   \                     ??HAL_TIM_ConfigClockSource_0: (+1)
   \   000000BE   0x2100             MOVS     R1,#+0
   \   000000C0   0x6820             LDR      R0,[R4, #+0]
   \   000000C2   0x.... 0x....      BL       TIM_ITRx_SetConfig
   4030              }
   4031              break;
   \   000000C6   0xE00D             B.N      ??HAL_TIM_ConfigClockSource_10
   4032            case TIM_CLOCKSOURCE_ITR1:
   4033              {
   4034                /* Check whether or not the timer instance supports external clock mode 1 */
   4035                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   4036          
   4037                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR1);
   \                     ??HAL_TIM_ConfigClockSource_1: (+1)
   \   000000C8   0x2110             MOVS     R1,#+16
   \   000000CA   0x6820             LDR      R0,[R4, #+0]
   \   000000CC   0x.... 0x....      BL       TIM_ITRx_SetConfig
   4038              }
   4039              break;
   \   000000D0   0xE008             B.N      ??HAL_TIM_ConfigClockSource_10
   4040            case TIM_CLOCKSOURCE_ITR2:
   4041              {
   4042                /* Check whether or not the timer instance supports external clock mode 1 */
   4043                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   4044          
   4045                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR2);
   \                     ??HAL_TIM_ConfigClockSource_2: (+1)
   \   000000D2   0x2120             MOVS     R1,#+32
   \   000000D4   0x6820             LDR      R0,[R4, #+0]
   \   000000D6   0x.... 0x....      BL       TIM_ITRx_SetConfig
   4046              }
   4047              break;
   \   000000DA   0xE003             B.N      ??HAL_TIM_ConfigClockSource_10
   4048            case TIM_CLOCKSOURCE_ITR3:
   4049              {
   4050                /* Check whether or not the timer instance supports external clock mode 1 */
   4051                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   4052          
   4053                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR3);
   \                     ??HAL_TIM_ConfigClockSource_3: (+1)
   \   000000DC   0x2130             MOVS     R1,#+48
   \   000000DE   0x6820             LDR      R0,[R4, #+0]
   \   000000E0   0x.... 0x....      BL       TIM_ITRx_SetConfig
   4054              }
   4055              break;
   4056          
   4057            default:
   4058              break;
   4059            }
   4060            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_ConfigClockSource_10: (+1)
   \   000000E4   0x2001             MOVS     R0,#+1
   \   000000E6   0xF884 0x0039      STRB     R0,[R4, #+57]
   4061          
   4062            __HAL_UNLOCK(htim);
   4063          
   4064            return HAL_OK;
   \   000000EA   0x2000             MOVS     R0,#+0
   \   000000EC   0xBD10             POP      {R4,PC}          ;; return
   4065          }
   4066          
   4067          /**
   4068            * @brief  Selects the signal connected to the TI1 input: direct from CH1_input
   4069            *         or a XOR combination between CH1_input, CH2_input & CH3_input
   4070            * @param  htim : TIM handle.
   4071            * @param  TI1_Selection : Indicate whether or not channel 1 is connected to the
   4072            *         output of a XOR gate.
   4073            *          This parameter can be one of the following values:
   4074            *            @arg TIM_TI1SELECTION_CH1: The TIMx_CH1 pin is connected to TI1 input
   4075            *            @arg TIM_TI1SELECTION_XORCOMBINATION: The TIMx_CH1, CH2 and CH3
   4076            *            pins are connected to the TI1 input (XOR combination)
   4077            * @retval HAL status
   4078            */

   \                                 In section .text, align 2, keep-with-next
   4079          HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)
   4080          {
   4081            uint32_t tmpcr2 = 0;
   4082          
   4083            /* Check the parameters */
   4084            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
   4085            assert_param(IS_TIM_TI1SELECTION(TI1_Selection));
   4086          
   4087            /* Get the TIMx CR2 register value */
   4088            tmpcr2 = htim->Instance->CR2;
   \                     HAL_TIM_ConfigTI1Input: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x6842             LDR      R2,[R0, #+4]
   4089          
   4090            /* Reset the TI1 selection */
   4091            tmpcr2 &= ~TIM_CR2_TI1S;
   4092          
   4093            /* Set the the TI1 selection */
   4094            tmpcr2 |= TI1_Selection;
   4095          
   4096            /* Write to TIMxCR2 */
   4097            htim->Instance->CR2 = tmpcr2;
   \   00000004   0xF022 0x0280      BIC      R2,R2,#0x80
   \   00000008   0x4311             ORRS     R1,R1,R2
   \   0000000A   0x6041             STR      R1,[R0, #+4]
   4098          
   4099            return HAL_OK;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
   4100          }
   4101          
   4102          /**
   4103            * @brief  Configures the TIM in Slave mode
   4104            * @param  htim : TIM handle.
   4105            * @param  sSlaveConfig : pointer to a TIM_SlaveConfigTypeDef structure that
   4106            *         contains the selected trigger (internal trigger input, filtered
   4107            *         timer input or external trigger input) and the ) and the Slave 
   4108            *         mode (Disable, Reset, Gated, Trigger, External clock mode 1).
   4109            * @retval HAL status
   4110            */

   \                                 In section .text, align 2, keep-with-next
   4111          HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef * sSlaveConfig)
   4112          {
   \                     HAL_TIM_SlaveConfigSynchronization: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   4113            /* Check the parameters */
   4114            assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
   4115            assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
   4116            assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
   4117          
   4118            __HAL_LOCK(htim);
   4119          
   4120            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
   4121          
   4122            TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       TIM_SlaveTimer_SetConfig
   4123          
   4124            /* Disable Trigger Interrupt */
   4125            __HAL_TIM_DISABLE_IT(htim, TIM_IT_TRIGGER);
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x68C1             LDR      R1,[R0, #+12]
   \   00000014   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000018   0x60C1             STR      R1,[R0, #+12]
   4126          
   4127            /* Disable Trigger DMA request */
   4128            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x68C1             LDR      R1,[R0, #+12]
   \   0000001E   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   00000022   0x60C1             STR      R1,[R0, #+12]
   4129          
   4130            htim->State = HAL_TIM_STATE_READY;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xF884 0x0039      STRB     R0,[R4, #+57]
   4131          
   4132            __HAL_UNLOCK(htim);
   4133          
   4134            return HAL_OK;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
   4135              }
   4136          
   4137          /**
   4138            * @brief  Configures the TIM in Slave mode in interrupt mode
   4139            * @param  htim: TIM handle.
   4140            * @param  sSlaveConfig: pointer to a TIM_SlaveConfigTypeDef structure that
   4141            *         contains the selected trigger (internal trigger input, filtered
   4142            *         timer input or external trigger input) and the ) and the Slave 
   4143            *         mode (Disable, Reset, Gated, Trigger, External clock mode 1).
   4144            * @retval HAL status
   4145            */

   \                                 In section .text, align 2, keep-with-next
   4146          HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization_IT(TIM_HandleTypeDef *htim,
   4147                                                                  TIM_SlaveConfigTypeDef * sSlaveConfig)
   4148              {
   \                     HAL_TIM_SlaveConfigSynchronization_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   4149                /* Check the parameters */
   4150            assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
   4151            assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
   4152            assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
   4153          
   4154            __HAL_LOCK(htim);
   4155          
   4156            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
   4157          
   4158            TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       TIM_SlaveTimer_SetConfig
   4159          
   4160            /* Enable Trigger Interrupt */
   4161            __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x68C1             LDR      R1,[R0, #+12]
   \   00000014   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000018   0x60C1             STR      R1,[R0, #+12]
   4162          
   4163            /* Disable Trigger DMA request */
   4164            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x68C1             LDR      R1,[R0, #+12]
   \   0000001E   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   00000022   0x60C1             STR      R1,[R0, #+12]
   4165          
   4166            htim->State = HAL_TIM_STATE_READY;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xF884 0x0039      STRB     R0,[R4, #+57]
   4167          
   4168            __HAL_UNLOCK(htim);
   4169          
   4170            return HAL_OK;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
   4171          }
   4172          
   4173          /**
   4174            * @brief  Read the captured value from Capture Compare unit
   4175            * @param  htim : TIM handle.
   4176            * @param  Channel : TIM Channels to be enabled
   4177            *          This parameter can be one of the following values:
   4178            *            @arg TIM_CHANNEL_1 : TIM Channel 1 selected
   4179            *            @arg TIM_CHANNEL_2 : TIM Channel 2 selected
   4180            *            @arg TIM_CHANNEL_3 : TIM Channel 3 selected
   4181            *            @arg TIM_CHANNEL_4 : TIM Channel 4 selected
   4182            * @retval Captured value
   4183            */

   \                                 In section .text, align 2, keep-with-next
   4184          uint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)
   4185          {
   \                     HAL_TIM_ReadCapturedValue: (+1)
   \   00000000   0x4602             MOV      R2,R0
   4186            uint32_t tmpreg = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   4187          
   4188            __HAL_LOCK(htim);
   4189          
   4190            switch (Channel)
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD006             BEQ.N    ??HAL_TIM_ReadCapturedValue_0
   \   00000008   0x2904             CMP      R1,#+4
   \   0000000A   0xD007             BEQ.N    ??HAL_TIM_ReadCapturedValue_1
   \   0000000C   0x2908             CMP      R1,#+8
   \   0000000E   0xD008             BEQ.N    ??HAL_TIM_ReadCapturedValue_2
   \   00000010   0x290C             CMP      R1,#+12
   \   00000012   0xD009             BEQ.N    ??HAL_TIM_ReadCapturedValue_3
   \   00000014   0x4770             BX       LR
   4191            {
   4192            case TIM_CHANNEL_1:
   4193              {
   4194                /* Check the parameters */
   4195                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4196          
   4197                /* Return the capture 1 value */
   4198                tmpreg =  htim->Instance->CCR1;
   \                     ??HAL_TIM_ReadCapturedValue_0: (+1)
   \   00000016   0x6810             LDR      R0,[R2, #+0]
   \   00000018   0x6B40             LDR      R0,[R0, #+52]
   4199          
   4200                break;
   \   0000001A   0x4770             BX       LR
   4201              }
   4202            case TIM_CHANNEL_2:
   4203              {
   4204                /* Check the parameters */
   4205                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4206          
   4207                /* Return the capture 2 value */
   4208                tmpreg =   htim->Instance->CCR2;
   \                     ??HAL_TIM_ReadCapturedValue_1: (+1)
   \   0000001C   0x6810             LDR      R0,[R2, #+0]
   \   0000001E   0x6B80             LDR      R0,[R0, #+56]
   4209          
   4210                break;
   \   00000020   0x4770             BX       LR
   4211              }
   4212          
   4213            case TIM_CHANNEL_3:
   4214              {
   4215                /* Check the parameters */
   4216                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   4217          
   4218                /* Return the capture 3 value */
   4219                tmpreg =   htim->Instance->CCR3;
   \                     ??HAL_TIM_ReadCapturedValue_2: (+1)
   \   00000022   0x6810             LDR      R0,[R2, #+0]
   \   00000024   0x6BC0             LDR      R0,[R0, #+60]
   4220          
   4221                break;
   \   00000026   0x4770             BX       LR
   4222              }
   4223          
   4224            case TIM_CHANNEL_4:
   4225              {
   4226                /* Check the parameters */
   4227                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   4228          
   4229                /* Return the capture 4 value */
   4230                tmpreg =   htim->Instance->CCR4;
   \                     ??HAL_TIM_ReadCapturedValue_3: (+1)
   \   00000028   0x6810             LDR      R0,[R2, #+0]
   \   0000002A   0x6C00             LDR      R0,[R0, #+64]
   4231          
   4232                break;
   4233              }
   4234          
   4235            default:
   4236              break;
   4237            }
   4238          
   4239            __HAL_UNLOCK(htim);
   4240            return tmpreg;
   \   0000002C   0x4770             BX       LR               ;; return
   4241          }
   4242          
   4243          /**
   4244            * @}
   4245            */
   4246          
   4247          /** @defgroup TIM_Exported_Functions_Group9 TIM Callbacks functions
   4248           *  @brief    TIM Callbacks functions 
   4249           *
   4250          @verbatim 
   4251            ==============================================================================
   4252                                  ##### TIM Callbacks functions #####
   4253            ==============================================================================
   4254           [..]
   4255             This section provides TIM callback functions:
   4256             (+) Timer Period elapsed callback
   4257             (+) Timer Output Compare callback
   4258             (+) Timer Input capture callback
   4259             (+) Timer Trigger callback
   4260             (+) Timer Error callback
   4261          
   4262          @endverbatim
   4263            * @{
   4264            */
   4265          
   4266          /**
   4267            * @brief  Period elapsed callback in non blocking mode 
   4268            * @param  htim : TIM handle
   4269            * @retval None
   4270            */

   \                                 In section .text, align 2
   4271          __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
   4272          {
   4273            /* Prevent unused argument(s) compilation warning */
   4274            UNUSED(htim);
   4275            /* NOTE : This function Should not be modified, when the callback is needed,
   4276                      the __HAL_TIM_PeriodElapsedCallback could be implemented in the user file
   4277             */
   4278          
   4279          }
   \                     HAL_TIM_PeriodElapsedCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4280          /**
   4281            * @brief  Output Compare callback in non blocking mode 
   4282            * @param  htim : TIM OC handle
   4283            * @retval None
   4284            */

   \                                 In section .text, align 2
   4285          __weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
   4286          {
   4287            /* Prevent unused argument(s) compilation warning */
   4288            UNUSED(htim);
   4289            /* NOTE : This function Should not be modified, when the callback is needed,
   4290                      the __HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   4291             */
   4292          }
   \                     HAL_TIM_OC_DelayElapsedCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4293          /**
   4294            * @brief  Input Capture callback in non blocking mode 
   4295            * @param  htim : TIM IC handle
   4296            * @retval None
   4297            */

   \                                 In section .text, align 2
   4298          __weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
   4299          {
   4300            /* Prevent unused argument(s) compilation warning */
   4301            UNUSED(htim);
   4302            /* NOTE : This function Should not be modified, when the callback is needed,
   4303                      the __HAL_TIM_IC_CaptureCallback could be implemented in the user file
   4304             */
   4305          }
   \                     HAL_TIM_IC_CaptureCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4306          
   4307          /**
   4308            * @brief  PWM Pulse finished callback in non blocking mode 
   4309            * @param  htim : TIM handle
   4310            * @retval None
   4311            */

   \                                 In section .text, align 2
   4312          __weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
   4313          {
   4314            /* Prevent unused argument(s) compilation warning */
   4315            UNUSED(htim);
   4316            /* NOTE : This function Should not be modified, when the callback is needed,
   4317                      the __HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   4318             */
   4319          }
   \                     HAL_TIM_PWM_PulseFinishedCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4320          
   4321          /**
   4322            * @brief  Hall Trigger detection callback in non blocking mode 
   4323            * @param  htim : TIM handle
   4324            * @retval None
   4325            */

   \                                 In section .text, align 2
   4326          __weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
   4327          {
   4328            /* Prevent unused argument(s) compilation warning */
   4329            UNUSED(htim);
   4330            /* NOTE : This function Should not be modified, when the callback is needed,
   4331                      the HAL_TIM_TriggerCallback could be implemented in the user file
   4332             */
   4333          }
   \                     HAL_TIM_TriggerCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4334          
   4335          /**
   4336            * @brief  Timer error callback in non blocking mode 
   4337            * @param  htim : TIM handle
   4338            * @retval None
   4339            */

   \                                 In section .text, align 2
   4340          __weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
   4341          {
   4342            /* Prevent unused argument(s) compilation warning */
   4343            UNUSED(htim);
   4344            /* NOTE : This function Should not be modified, when the callback is needed,
   4345                      the HAL_TIM_ErrorCallback could be implemented in the user file
   4346             */
   4347          }
   \                     HAL_TIM_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4348          
   4349          /**
   4350            * @}
   4351            */
   4352          
   4353          /** @defgroup TIM_Exported_Functions_Group10 Peripheral State functions 
   4354           *  @brief   Peripheral State functions 
   4355           *
   4356          @verbatim 
   4357            ==============================================================================
   4358                                  ##### Peripheral State functions #####
   4359            ==============================================================================
   4360              [..]
   4361              This subsection permit to get in run-time the status of the peripheral 
   4362              and the data flow.
   4363          
   4364          @endverbatim
   4365            * @{
   4366            */
   4367          
   4368          /**
   4369            * @brief  Return the TIM Base state
   4370            * @param  htim : TIM Base handle
   4371            * @retval HAL state
   4372            */

   \                                 In section .text, align 2, keep-with-next
   4373          HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)
   4374          {
   4375            return htim->State;
   \                     HAL_TIM_Base_GetState: (+1)
   \   00000000   0xF990 0x0039      LDRSB    R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   4376          }
   4377          
   4378          /**
   4379            * @brief  Return the TIM OC state
   4380            * @param  htim : TIM Ouput Compare handle
   4381            * @retval HAL state
   4382            */

   \                                 In section .text, align 2, keep-with-next
   4383          HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)
   4384          {
   4385            return htim->State;
   \                     HAL_TIM_OC_GetState: (+1)
   \   00000000   0xF990 0x0039      LDRSB    R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   4386          }
   4387          
   4388          /**
   4389            * @brief  Return the TIM PWM state
   4390            * @param  htim : TIM handle
   4391            * @retval HAL state
   4392            */

   \                                 In section .text, align 2, keep-with-next
   4393          HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)
   4394          {
   4395            return htim->State;
   \                     HAL_TIM_PWM_GetState: (+1)
   \   00000000   0xF990 0x0039      LDRSB    R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   4396          }
   4397          
   4398          /**
   4399            * @brief  Return the TIM Input Capture state
   4400            * @param  htim : TIM IC handle
   4401            * @retval HAL state
   4402            */

   \                                 In section .text, align 2, keep-with-next
   4403          HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)
   4404          {
   4405            return htim->State;
   \                     HAL_TIM_IC_GetState: (+1)
   \   00000000   0xF990 0x0039      LDRSB    R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   4406          }
   4407          
   4408          /**
   4409            * @brief  Return the TIM One Pulse Mode state
   4410            * @param  htim : TIM OPM handle
   4411            * @retval HAL state
   4412            */

   \                                 In section .text, align 2, keep-with-next
   4413          HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)
   4414          {
   4415            return htim->State;
   \                     HAL_TIM_OnePulse_GetState: (+1)
   \   00000000   0xF990 0x0039      LDRSB    R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   4416          }
   4417          
   4418          /**
   4419            * @brief  Return the TIM Encoder Mode state
   4420            * @param  htim : TIM Encoder handle
   4421            * @retval HAL state
   4422            */

   \                                 In section .text, align 2, keep-with-next
   4423          HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)
   4424          {
   4425            return htim->State;
   \                     HAL_TIM_Encoder_GetState: (+1)
   \   00000000   0xF990 0x0039      LDRSB    R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   4426          }
   4427          
   4428          /**
   4429            * @}
   4430            */
   4431          
   4432          /**
   4433            * @}
   4434            */
   4435          
   4436          /** @addtogroup TIM_Private_Functions
   4437            * @{
   4438            */
   4439          
   4440          /**
   4441            * @brief  TIM DMA error callback 
   4442            * @param  hdma : pointer to DMA handle.
   4443            * @retval None
   4444            */

   \                                 In section .text, align 4, keep-with-next
   4445          void TIM_DMAError(DMA_HandleTypeDef *hdma)
   4446          {
   4447            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \                     TIM_DMAError: (+1)
   \   00000000   0x6A40             LDR      R0,[R0, #+36]
   4448          
   4449            htim->State= HAL_TIM_STATE_READY;
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0xF880 0x1039      STRB     R1,[R0, #+57]
   4450          
   4451            HAL_TIM_ErrorCallback(htim);
   \   00000008   0x.... 0x....      B.W      HAL_TIM_ErrorCallback
   4452          }
   4453          
   4454          /**
   4455            * @brief  TIM DMA Delay Pulse complete callback.
   4456            * @param  hdma : pointer to DMA handle.
   4457            * @retval None
   4458            */

   \                                 In section .text, align 4, keep-with-next
   4459          void TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
   4460          {
   \                     TIM_DMADelayPulseCplt: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   4461            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6A44             LDR      R4,[R0, #+36]
   4462          
   4463            htim->State= HAL_TIM_STATE_READY;
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0xF884 0x1039      STRB     R1,[R4, #+57]
   4464          
   4465            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   \   0000000A   0x6A21             LDR      R1,[R4, #+32]
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xD102             BNE.N    ??TIM_DMADelayPulseCplt_0
   4466            {
   4467              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x7620             STRB     R0,[R4, #+24]
   \   00000014   0xE010             B.N      ??TIM_DMADelayPulseCplt_1
   4468            }
   4469            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   \                     ??TIM_DMADelayPulseCplt_0: (+1)
   \   00000016   0x6A61             LDR      R1,[R4, #+36]
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD102             BNE.N    ??TIM_DMADelayPulseCplt_2
   4470            {
   4471              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0x7620             STRB     R0,[R4, #+24]
   \   00000020   0xE00A             B.N      ??TIM_DMADelayPulseCplt_1
   4472            }
   4473            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   \                     ??TIM_DMADelayPulseCplt_2: (+1)
   \   00000022   0x6AA1             LDR      R1,[R4, #+40]
   \   00000024   0x4288             CMP      R0,R1
   \   00000026   0xD102             BNE.N    ??TIM_DMADelayPulseCplt_3
   4474            {
   4475              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \   00000028   0x2004             MOVS     R0,#+4
   \   0000002A   0x7620             STRB     R0,[R4, #+24]
   \   0000002C   0xE004             B.N      ??TIM_DMADelayPulseCplt_1
   4476            }
   4477            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   \                     ??TIM_DMADelayPulseCplt_3: (+1)
   \   0000002E   0x6AE1             LDR      R1,[R4, #+44]
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xD101             BNE.N    ??TIM_DMADelayPulseCplt_1
   4478            {
   4479              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \   00000034   0x2008             MOVS     R0,#+8
   \   00000036   0x7620             STRB     R0,[R4, #+24]
   4480            }
   4481          
   4482            HAL_TIM_PWM_PulseFinishedCallback(htim);
   \                     ??TIM_DMADelayPulseCplt_1: (+1)
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   4483          
   4484            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x7620             STRB     R0,[R4, #+24]
   4485          }
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
   4486          /**
   4487            * @brief  TIM DMA Capture complete callback.
   4488            * @param  hdma : pointer to DMA handle.
   4489            * @retval None
   4490            */

   \                                 In section .text, align 4, keep-with-next
   4491          void TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)
   4492          {
   \                     TIM_DMACaptureCplt: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   4493            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6A44             LDR      R4,[R0, #+36]
   4494          
   4495            htim->State= HAL_TIM_STATE_READY;
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0xF884 0x1039      STRB     R1,[R4, #+57]
   4496          
   4497            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   \   0000000A   0x6A21             LDR      R1,[R4, #+32]
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xD102             BNE.N    ??TIM_DMACaptureCplt_0
   4498            {
   4499              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x7620             STRB     R0,[R4, #+24]
   \   00000014   0xE010             B.N      ??TIM_DMACaptureCplt_1
   4500            }
   4501            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   \                     ??TIM_DMACaptureCplt_0: (+1)
   \   00000016   0x6A61             LDR      R1,[R4, #+36]
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD102             BNE.N    ??TIM_DMACaptureCplt_2
   4502            {
   4503              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0x7620             STRB     R0,[R4, #+24]
   \   00000020   0xE00A             B.N      ??TIM_DMACaptureCplt_1
   4504            }
   4505            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   \                     ??TIM_DMACaptureCplt_2: (+1)
   \   00000022   0x6AA1             LDR      R1,[R4, #+40]
   \   00000024   0x4288             CMP      R0,R1
   \   00000026   0xD102             BNE.N    ??TIM_DMACaptureCplt_3
   4506            {
   4507              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \   00000028   0x2004             MOVS     R0,#+4
   \   0000002A   0x7620             STRB     R0,[R4, #+24]
   \   0000002C   0xE004             B.N      ??TIM_DMACaptureCplt_1
   4508            }
   4509            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   \                     ??TIM_DMACaptureCplt_3: (+1)
   \   0000002E   0x6AE1             LDR      R1,[R4, #+44]
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xD101             BNE.N    ??TIM_DMACaptureCplt_1
   4510            {
   4511              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \   00000034   0x2008             MOVS     R0,#+8
   \   00000036   0x7620             STRB     R0,[R4, #+24]
   4512            }
   4513          
   4514            HAL_TIM_IC_CaptureCallback(htim);
   \                     ??TIM_DMACaptureCplt_1: (+1)
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   4515          
   4516            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x7620             STRB     R0,[R4, #+24]
   4517          }
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
   4518          
   4519          /**
   4520            * @brief  TIM DMA Period Elapse complete callback.
   4521            * @param  hdma : pointer to DMA handle.
   4522            * @retval None
   4523            */

   \                                 In section .text, align 4, keep-with-next
   4524          static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)
   4525          {
   4526            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \                     TIM_DMAPeriodElapsedCplt: (+1)
   \   00000000   0x6A40             LDR      R0,[R0, #+36]
   4527          
   4528            htim->State= HAL_TIM_STATE_READY;
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0xF880 0x1039      STRB     R1,[R0, #+57]
   4529          
   4530            HAL_TIM_PeriodElapsedCallback(htim);
   \   00000008   0x.... 0x....      B.W      HAL_TIM_PeriodElapsedCallback
   4531          }
   4532          
   4533          /**
   4534            * @brief  TIM DMA Trigger callback.
   4535            * @param  hdma : pointer to DMA handle.
   4536            * @retval None
   4537            */

   \                                 In section .text, align 4, keep-with-next
   4538          static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)
   4539          {
   4540            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \                     TIM_DMATriggerCplt: (+1)
   \   00000000   0x6A40             LDR      R0,[R0, #+36]
   4541          
   4542            htim->State= HAL_TIM_STATE_READY;
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0xF880 0x1039      STRB     R1,[R0, #+57]
   4543          
   4544            HAL_TIM_TriggerCallback(htim);
   \   00000008   0x.... 0x....      B.W      HAL_TIM_TriggerCallback
   4545          }
   4546          
   4547          /**
   4548            * @brief  Time Base configuration
   4549            * @param  TIMx : TIM periheral
   4550            * @param  Structure : TIM Base configuration structure
   4551            * @retval None
   4552            */

   \                                 In section .text, align 2, keep-with-next
   4553          void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
   4554          {
   \                     TIM_Base_SetConfig: (+1)
   \   00000000   0xB418             PUSH     {R3,R4}
   4555            uint32_t tmpcr1 = 0;
   4556            tmpcr1 = TIMx->CR1;
   \   00000002   0x6804             LDR      R4,[R0, #+0]
   4557          
   4558            /* Set TIM Time Base Unit parameters ---------------------------------------*/
   4559            if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
   \   00000004   0x....             LDR.N    R3,??DataTable29_2  ;; 0x40012c00
   \   00000006   0x4298             CMP      R0,R3
   \   00000008   0xD00E             BEQ.N    ??TIM_Base_SetConfig_0
   \   0000000A   0x....             LDR.N    R2,??DataTable29_3  ;; 0x40013400
   \   0000000C   0x4290             CMP      R0,R2
   \   0000000E   0xD00B             BEQ.N    ??TIM_Base_SetConfig_0
   \   00000010   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \   00000014   0xD008             BEQ.N    ??TIM_Base_SetConfig_0
   \   00000016   0x....             LDR.N    R2,??DataTable29_4  ;; 0x40000400
   \   00000018   0x4290             CMP      R0,R2
   \   0000001A   0xD005             BEQ.N    ??TIM_Base_SetConfig_0
   \   0000001C   0x....             LDR.N    R2,??DataTable29_5  ;; 0x40000800
   \   0000001E   0x4290             CMP      R0,R2
   \   00000020   0xD002             BEQ.N    ??TIM_Base_SetConfig_0
   \   00000022   0x....             LDR.N    R2,??DataTable29_6  ;; 0x40000c00
   \   00000024   0x4290             CMP      R0,R2
   \   00000026   0xD103             BNE.N    ??TIM_Base_SetConfig_1
   4560            {
   4561              /* Select the Counter Mode */
   4562              tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
   4563              tmpcr1 |= Structure->CounterMode;
   \                     ??TIM_Base_SetConfig_0: (+1)
   \   00000028   0xF024 0x0470      BIC      R4,R4,#0x70
   \   0000002C   0x684A             LDR      R2,[R1, #+4]
   \   0000002E   0x4314             ORRS     R4,R2,R4
   4564            }
   4565          
   4566            if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   \                     ??TIM_Base_SetConfig_1: (+1)
   \   00000030   0x4298             CMP      R0,R3
   \   00000032   0xD00E             BEQ.N    ??TIM_Base_SetConfig_2
   \   00000034   0x....             LDR.N    R2,??DataTable29_3  ;; 0x40013400
   \   00000036   0x4290             CMP      R0,R2
   \   00000038   0xD00B             BEQ.N    ??TIM_Base_SetConfig_2
   \   0000003A   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \   0000003E   0xD008             BEQ.N    ??TIM_Base_SetConfig_2
   \   00000040   0x....             LDR.N    R2,??DataTable29_4  ;; 0x40000400
   \   00000042   0x4290             CMP      R0,R2
   \   00000044   0xD005             BEQ.N    ??TIM_Base_SetConfig_2
   \   00000046   0x....             LDR.N    R2,??DataTable29_5  ;; 0x40000800
   \   00000048   0x4290             CMP      R0,R2
   \   0000004A   0xD002             BEQ.N    ??TIM_Base_SetConfig_2
   \   0000004C   0x....             LDR.N    R2,??DataTable29_6  ;; 0x40000c00
   \   0000004E   0x4290             CMP      R0,R2
   \   00000050   0xD103             BNE.N    ??TIM_Base_SetConfig_3
   4567            {
   4568              /* Set the clock division */
   4569              tmpcr1 &= ~TIM_CR1_CKD;
   4570              tmpcr1 |= (uint32_t)Structure->ClockDivision;
   \                     ??TIM_Base_SetConfig_2: (+1)
   \   00000052   0xF424 0x7440      BIC      R4,R4,#0x300
   \   00000056   0x68CA             LDR      R2,[R1, #+12]
   \   00000058   0x4314             ORRS     R4,R2,R4
   4571            }
   4572          
   4573            TIMx->CR1 = tmpcr1;
   \                     ??TIM_Base_SetConfig_3: (+1)
   \   0000005A   0x6004             STR      R4,[R0, #+0]
   4574          
   4575            /* Set the Autoreload value */
   4576            TIMx->ARR = (uint32_t)Structure->Period ;
   \   0000005C   0x688A             LDR      R2,[R1, #+8]
   \   0000005E   0x62C2             STR      R2,[R0, #+44]
   4577          
   4578            /* Set the Prescaler value */
   4579            TIMx->PSC = (uint32_t)Structure->Prescaler;
   \   00000060   0x680A             LDR      R2,[R1, #+0]
   \   00000062   0x6282             STR      R2,[R0, #+40]
   4580          
   4581            if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
   \   00000064   0x4298             CMP      R0,R3
   \   00000066   0xD002             BEQ.N    ??TIM_Base_SetConfig_4
   \   00000068   0x....             LDR.N    R2,??DataTable29_3  ;; 0x40013400
   \   0000006A   0x4290             CMP      R0,R2
   \   0000006C   0xD101             BNE.N    ??TIM_Base_SetConfig_5
   4582            {
   4583              /* Set the Repetition Counter value */
   4584              TIMx->RCR = Structure->RepetitionCounter;
   \                     ??TIM_Base_SetConfig_4: (+1)
   \   0000006E   0x6909             LDR      R1,[R1, #+16]
   \   00000070   0x6301             STR      R1,[R0, #+48]
   4585            }
   4586          
   4587            /* Generate an update event to reload the Prescaler 
   4588               and the repetition counter(only for TIM1 and TIM8) value immediatly */
   4589            TIMx->EGR = TIM_EGR_UG;
   \                     ??TIM_Base_SetConfig_5: (+1)
   \   00000072   0x2101             MOVS     R1,#+1
   \   00000074   0x6141             STR      R1,[R0, #+20]
   4590          }
   \   00000076   0xBC11             POP      {R0,R4}
   \   00000078   0x4770             BX       LR               ;; return
   4591          
   4592          /**
   4593            * @brief  Time Ouput Compare 1 configuration
   4594            * @param  TIMx to select the TIM peripheral
   4595            * @param  OC_Config : The ouput configuration structure
   4596            * @retval None
   4597            */

   \                                 In section .text, align 2, keep-with-next
   4598          static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4599          {
   \                     TIM_OC1_SetConfig: (+1)
   \   00000000   0xB478             PUSH     {R3-R6}
   4600            uint32_t tmpccmrx = 0;
   4601            uint32_t tmpccer = 0;
   4602            uint32_t tmpcr2 = 0;
   4603          
   4604             /* Disable the Channel 1: Reset the CC1E Bit */
   4605            TIMx->CCER &= ~TIM_CCER_CC1E;
   \   00000002   0x6A02             LDR      R2,[R0, #+32]
   \   00000004   0x0852             LSRS     R2,R2,#+1
   \   00000006   0x0052             LSLS     R2,R2,#+1
   \   00000008   0x6202             STR      R2,[R0, #+32]
   4606          
   4607            /* Get the TIMx CCER register value */
   4608            tmpccer = TIMx->CCER;
   \   0000000A   0x6A03             LDR      R3,[R0, #+32]
   4609            /* Get the TIMx CR2 register value */
   4610            tmpcr2 =  TIMx->CR2;
   \   0000000C   0x6844             LDR      R4,[R0, #+4]
   4611          
   4612            /* Get the TIMx CCMR1 register value */
   4613            tmpccmrx = TIMx->CCMR1;
   \   0000000E   0x6985             LDR      R5,[R0, #+24]
   4614          
   4615            /* Reset the Output Compare Mode Bits */
   4616            tmpccmrx &= ~TIM_CCMR1_OC1M;
   4617            tmpccmrx &= ~TIM_CCMR1_CC1S;
   4618            /* Select the Output Compare Mode */
   4619            tmpccmrx |= OC_Config->OCMode;
   \   00000010   0xF025 0x0573      BIC      R5,R5,#0x73
   \   00000014   0x680A             LDR      R2,[R1, #+0]
   \   00000016   0x4315             ORRS     R5,R2,R5
   4620          
   4621            /* Reset the Output Polarity level */
   4622            tmpccer &= ~TIM_CCER_CC1P;
   4623            /* Set the Output Compare Polarity */
   4624            tmpccer |= OC_Config->OCPolarity;
   \   00000018   0xF023 0x0302      BIC      R3,R3,#0x2
   \   0000001C   0x688A             LDR      R2,[R1, #+8]
   \   0000001E   0x4313             ORRS     R3,R2,R3
   4625          
   4626            if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
   \   00000020   0x....             LDR.N    R6,??DataTable29_2  ;; 0x40012c00
   \   00000022   0x42B0             CMP      R0,R6
   \   00000024   0xD002             BEQ.N    ??TIM_OC1_SetConfig_0
   \   00000026   0x....             LDR.N    R2,??DataTable29_3  ;; 0x40013400
   \   00000028   0x4290             CMP      R0,R2
   \   0000002A   0xD105             BNE.N    ??TIM_OC1_SetConfig_1
   4627            {
   4628              /* Check parameters */
   4629              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   4630          
   4631              /* Reset the Output N Polarity level */
   4632              tmpccer &= ~TIM_CCER_CC1NP;
   4633              /* Set the Output N Polarity */
   4634              tmpccer |= OC_Config->OCNPolarity;
   4635              /* Reset the Output N State */
   4636              tmpccer &= ~TIM_CCER_CC1NE;
   \                     ??TIM_OC1_SetConfig_0: (+1)
   \   0000002C   0xF023 0x0308      BIC      R3,R3,#0x8
   \   00000030   0x68CA             LDR      R2,[R1, #+12]
   \   00000032   0x4313             ORRS     R3,R2,R3
   \   00000034   0xF023 0x0304      BIC      R3,R3,#0x4
   4637            }
   4638          
   4639            if(IS_TIM_BREAK_INSTANCE(TIMx))
   \                     ??TIM_OC1_SetConfig_1: (+1)
   \   00000038   0x42B0             CMP      R0,R6
   \   0000003A   0xD002             BEQ.N    ??TIM_OC1_SetConfig_2
   \   0000003C   0x....             LDR.N    R2,??DataTable29_3  ;; 0x40013400
   \   0000003E   0x4290             CMP      R0,R2
   \   00000040   0xD105             BNE.N    ??TIM_OC1_SetConfig_3
   4640            {
   4641              /* Check parameters */
   4642              assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   4643              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   4644          
   4645              /* Reset the Output Compare and Output Compare N IDLE State */
   4646              tmpcr2 &= ~TIM_CR2_OIS1;
   4647              tmpcr2 &= ~TIM_CR2_OIS1N;
   4648              /* Set the Output Idle state */
   4649              tmpcr2 |= OC_Config->OCIdleState;
   4650              /* Set the Output N Idle state */
   4651              tmpcr2 |= OC_Config->OCNIdleState;
   \                     ??TIM_OC1_SetConfig_2: (+1)
   \   00000042   0xF424 0x7440      BIC      R4,R4,#0x300
   \   00000046   0x694A             LDR      R2,[R1, #+20]
   \   00000048   0x4314             ORRS     R4,R2,R4
   \   0000004A   0x698A             LDR      R2,[R1, #+24]
   \   0000004C   0x4314             ORRS     R4,R2,R4
   4652            }
   4653            /* Write to TIMx CR2 */
   4654            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC1_SetConfig_3: (+1)
   \   0000004E   0x6044             STR      R4,[R0, #+4]
   4655          
   4656            /* Write to TIMx CCMR1 */
   4657            TIMx->CCMR1 = tmpccmrx;
   \   00000050   0x6185             STR      R5,[R0, #+24]
   4658          
   4659            /* Set the Capture Compare Register value */
   4660            TIMx->CCR1 = OC_Config->Pulse;
   \   00000052   0x6849             LDR      R1,[R1, #+4]
   \   00000054   0x6341             STR      R1,[R0, #+52]
   4661          
   4662            /* Write to TIMx CCER */
   4663            TIMx->CCER = tmpccer;
   \   00000056   0x6203             STR      R3,[R0, #+32]
   4664          }
   \   00000058   0xBC71             POP      {R0,R4-R6}
   \   0000005A   0x4770             BX       LR               ;; return
   4665          
   4666          /**
   4667            * @brief  Time Ouput Compare 2 configuration
   4668            * @param  TIMx  to select the TIM peripheral
   4669            * @param  OC_Config : The ouput configuration structure
   4670            * @retval None
   4671            */

   \                                 In section .text, align 2, keep-with-next
   4672          void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4673          {
   \                     TIM_OC2_SetConfig: (+1)
   \   00000000   0xB478             PUSH     {R3-R6}
   4674            uint32_t tmpccmrx = 0;
   4675            uint32_t tmpccer = 0;
   4676            uint32_t tmpcr2 = 0;
   4677          
   4678            /* Disable the Channel 2: Reset the CC2E Bit */
   4679            TIMx->CCER &= ~TIM_CCER_CC2E;
   \   00000002   0x6A02             LDR      R2,[R0, #+32]
   \   00000004   0xF022 0x0210      BIC      R2,R2,#0x10
   \   00000008   0x6202             STR      R2,[R0, #+32]
   4680          
   4681            /* Get the TIMx CCER register value */
   4682            tmpccer = TIMx->CCER;
   \   0000000A   0x6A03             LDR      R3,[R0, #+32]
   4683            /* Get the TIMx CR2 register value */
   4684            tmpcr2 =  TIMx->CR2;
   \   0000000C   0x6844             LDR      R4,[R0, #+4]
   4685          
   4686            /* Get the TIMx CCMR1 register value */
   4687            tmpccmrx = TIMx->CCMR1;
   \   0000000E   0x6985             LDR      R5,[R0, #+24]
   4688          
   4689            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   4690            tmpccmrx &= ~TIM_CCMR1_OC2M;
   4691            tmpccmrx &= ~TIM_CCMR1_CC2S;
   4692          
   4693            /* Select the Output Compare Mode */
   4694            tmpccmrx |= (OC_Config->OCMode << 8);
   \   00000010   0xF425 0x45E6      BIC      R5,R5,#0x7300
   \   00000014   0x680A             LDR      R2,[R1, #+0]
   \   00000016   0xEA45 0x2502      ORR      R5,R5,R2, LSL #+8
   4695          
   4696            /* Reset the Output Polarity level */
   4697            tmpccer &= ~TIM_CCER_CC2P;
   4698            /* Set the Output Compare Polarity */
   4699            tmpccer |= (OC_Config->OCPolarity << 4);
   \   0000001A   0xF023 0x0320      BIC      R3,R3,#0x20
   \   0000001E   0x688A             LDR      R2,[R1, #+8]
   \   00000020   0xEA43 0x1302      ORR      R3,R3,R2, LSL #+4
   4700          
   4701            if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
   \   00000024   0x....             LDR.N    R2,??DataTable29_2  ;; 0x40012c00
   \   00000026   0x4290             CMP      R0,R2
   \   00000028   0xD002             BEQ.N    ??TIM_OC2_SetConfig_0
   \   0000002A   0x....             LDR.N    R6,??DataTable29_3  ;; 0x40013400
   \   0000002C   0x42B0             CMP      R0,R6
   \   0000002E   0xD106             BNE.N    ??TIM_OC2_SetConfig_1
   4702            {
   4703              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   4704          
   4705              /* Reset the Output N Polarity level */
   4706              tmpccer &= ~TIM_CCER_CC2NP;
   4707              /* Set the Output N Polarity */
   4708              tmpccer |= (OC_Config->OCNPolarity << 4);
   4709              /* Reset the Output N State */
   4710              tmpccer &= ~TIM_CCER_CC2NE;
   \                     ??TIM_OC2_SetConfig_0: (+1)
   \   00000030   0xF023 0x0380      BIC      R3,R3,#0x80
   \   00000034   0x68CE             LDR      R6,[R1, #+12]
   \   00000036   0xEA43 0x1306      ORR      R3,R3,R6, LSL #+4
   \   0000003A   0xF023 0x0340      BIC      R3,R3,#0x40
   4711          
   4712            }
   4713          
   4714            if(IS_TIM_BREAK_INSTANCE(TIMx))
   \                     ??TIM_OC2_SetConfig_1: (+1)
   \   0000003E   0x4290             CMP      R0,R2
   \   00000040   0xD002             BEQ.N    ??TIM_OC2_SetConfig_2
   \   00000042   0x....             LDR.N    R2,??DataTable29_3  ;; 0x40013400
   \   00000044   0x4290             CMP      R0,R2
   \   00000046   0xD106             BNE.N    ??TIM_OC2_SetConfig_3
   4715            {
   4716              /* Check parameters */
   4717              assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   4718              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   4719          
   4720              /* Reset the Output Compare and Output Compare N IDLE State */
   4721              tmpcr2 &= ~TIM_CR2_OIS2;
   4722              tmpcr2 &= ~TIM_CR2_OIS2N;
   4723              /* Set the Output Idle state */
   4724              tmpcr2 |= (OC_Config->OCIdleState << 2);
   4725              /* Set the Output N Idle state */
   4726              tmpcr2 |= (OC_Config->OCNIdleState << 2);
   \                     ??TIM_OC2_SetConfig_2: (+1)
   \   00000048   0xF424 0x6440      BIC      R4,R4,#0xC00
   \   0000004C   0x694E             LDR      R6,[R1, #+20]
   \   0000004E   0x698A             LDR      R2,[R1, #+24]
   \   00000050   0x4316             ORRS     R6,R2,R6
   \   00000052   0xEA44 0x0486      ORR      R4,R4,R6, LSL #+2
   4727            }
   4728          
   4729            /* Write to TIMx CR2 */
   4730            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC2_SetConfig_3: (+1)
   \   00000056   0x6044             STR      R4,[R0, #+4]
   4731          
   4732            /* Write to TIMx CCMR1 */
   4733            TIMx->CCMR1 = tmpccmrx;
   \   00000058   0x6185             STR      R5,[R0, #+24]
   4734          
   4735            /* Set the Capture Compare Register value */
   4736            TIMx->CCR2 = OC_Config->Pulse;
   \   0000005A   0x6849             LDR      R1,[R1, #+4]
   \   0000005C   0x6381             STR      R1,[R0, #+56]
   4737          
   4738            /* Write to TIMx CCER */
   4739            TIMx->CCER = tmpccer;
   \   0000005E   0x6203             STR      R3,[R0, #+32]
   4740          }
   \   00000060   0xBC71             POP      {R0,R4-R6}
   \   00000062   0x4770             BX       LR               ;; return
   4741          
   4742          /**
   4743            * @brief  Time Ouput Compare 3 configuration
   4744            * @param  TIMx  to select the TIM peripheral
   4745            * @param  OC_Config : The ouput configuration structure
   4746            * @retval None
   4747            */

   \                                 In section .text, align 2, keep-with-next
   4748          static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4749          {
   \                     TIM_OC3_SetConfig: (+1)
   \   00000000   0xB478             PUSH     {R3-R6}
   4750            uint32_t tmpccmrx = 0;
   4751            uint32_t tmpccer = 0;
   4752            uint32_t tmpcr2 = 0;
   4753          
   4754            /* Disable the Channel 3: Reset the CC2E Bit */
   4755            TIMx->CCER &= ~TIM_CCER_CC3E;
   \   00000002   0x6A02             LDR      R2,[R0, #+32]
   \   00000004   0xF422 0x7280      BIC      R2,R2,#0x100
   \   00000008   0x6202             STR      R2,[R0, #+32]
   4756          
   4757            /* Get the TIMx CCER register value */
   4758            tmpccer = TIMx->CCER;
   \   0000000A   0x6A03             LDR      R3,[R0, #+32]
   4759            /* Get the TIMx CR2 register value */
   4760            tmpcr2 =  TIMx->CR2;
   \   0000000C   0x6844             LDR      R4,[R0, #+4]
   4761          
   4762            /* Get the TIMx CCMR2 register value */
   4763            tmpccmrx = TIMx->CCMR2;
   \   0000000E   0x69C5             LDR      R5,[R0, #+28]
   4764          
   4765            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   4766            tmpccmrx &= ~TIM_CCMR2_OC3M;
   4767            tmpccmrx &= ~TIM_CCMR2_CC3S;
   4768            /* Select the Output Compare Mode */
   4769            tmpccmrx |= OC_Config->OCMode;
   \   00000010   0xF025 0x0573      BIC      R5,R5,#0x73
   \   00000014   0x680A             LDR      R2,[R1, #+0]
   \   00000016   0x4315             ORRS     R5,R2,R5
   4770          
   4771            /* Reset the Output Polarity level */
   4772            tmpccer &= ~TIM_CCER_CC3P;
   4773            /* Set the Output Compare Polarity */
   4774            tmpccer |= (OC_Config->OCPolarity << 8);
   \   00000018   0xF423 0x7300      BIC      R3,R3,#0x200
   \   0000001C   0x688A             LDR      R2,[R1, #+8]
   \   0000001E   0xEA43 0x2302      ORR      R3,R3,R2, LSL #+8
   4775          
   4776            if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
   \   00000022   0x....             LDR.N    R2,??DataTable29_2  ;; 0x40012c00
   \   00000024   0x4290             CMP      R0,R2
   \   00000026   0xD002             BEQ.N    ??TIM_OC3_SetConfig_0
   \   00000028   0x....             LDR.N    R6,??DataTable29_3  ;; 0x40013400
   \   0000002A   0x42B0             CMP      R0,R6
   \   0000002C   0xD106             BNE.N    ??TIM_OC3_SetConfig_1
   4777            {
   4778              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   4779          
   4780              /* Reset the Output N Polarity level */
   4781              tmpccer &= ~TIM_CCER_CC3NP;
   4782              /* Set the Output N Polarity */
   4783              tmpccer |= (OC_Config->OCNPolarity << 8);
   4784              /* Reset the Output N State */
   4785              tmpccer &= ~TIM_CCER_CC3NE;
   \                     ??TIM_OC3_SetConfig_0: (+1)
   \   0000002E   0xF423 0x6300      BIC      R3,R3,#0x800
   \   00000032   0x68CE             LDR      R6,[R1, #+12]
   \   00000034   0xEA43 0x2306      ORR      R3,R3,R6, LSL #+8
   \   00000038   0xF423 0x6380      BIC      R3,R3,#0x400
   4786            }
   4787          
   4788            if(IS_TIM_BREAK_INSTANCE(TIMx))
   \                     ??TIM_OC3_SetConfig_1: (+1)
   \   0000003C   0x4290             CMP      R0,R2
   \   0000003E   0xD002             BEQ.N    ??TIM_OC3_SetConfig_2
   \   00000040   0x....             LDR.N    R2,??DataTable29_3  ;; 0x40013400
   \   00000042   0x4290             CMP      R0,R2
   \   00000044   0xD106             BNE.N    ??TIM_OC3_SetConfig_3
   4789            {
   4790              /* Check parameters */
   4791              assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   4792              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   4793          
   4794              /* Reset the Output Compare and Output Compare N IDLE State */
   4795              tmpcr2 &= ~TIM_CR2_OIS3;
   4796              tmpcr2 &= ~TIM_CR2_OIS3N;
   4797              /* Set the Output Idle state */
   4798              tmpcr2 |= (OC_Config->OCIdleState << 4);
   4799              /* Set the Output N Idle state */
   4800              tmpcr2 |= (OC_Config->OCNIdleState << 4);
   \                     ??TIM_OC3_SetConfig_2: (+1)
   \   00000046   0xF424 0x5440      BIC      R4,R4,#0x3000
   \   0000004A   0x694E             LDR      R6,[R1, #+20]
   \   0000004C   0x698A             LDR      R2,[R1, #+24]
   \   0000004E   0x4316             ORRS     R6,R2,R6
   \   00000050   0xEA44 0x1406      ORR      R4,R4,R6, LSL #+4
   4801            }
   4802          
   4803            /* Write to TIMx CR2 */
   4804            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC3_SetConfig_3: (+1)
   \   00000054   0x6044             STR      R4,[R0, #+4]
   4805          
   4806            /* Write to TIMx CCMR2 */
   4807            TIMx->CCMR2 = tmpccmrx;
   \   00000056   0x61C5             STR      R5,[R0, #+28]
   4808          
   4809            /* Set the Capture Compare Register value */
   4810            TIMx->CCR3 = OC_Config->Pulse;
   \   00000058   0x6849             LDR      R1,[R1, #+4]
   \   0000005A   0x63C1             STR      R1,[R0, #+60]
   4811          
   4812            /* Write to TIMx CCER */
   4813            TIMx->CCER = tmpccer;
   \   0000005C   0x6203             STR      R3,[R0, #+32]
   4814          }
   \   0000005E   0xBC71             POP      {R0,R4-R6}
   \   00000060   0x4770             BX       LR               ;; return
   4815          
   4816          /**
   4817            * @brief  Time Ouput Compare 4 configuration
   4818            * @param  TIMx  to select the TIM peripheral
   4819            * @param  OC_Config : The ouput configuration structure
   4820            * @retval None
   4821            */

   \                                 In section .text, align 2, keep-with-next
   4822          static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4823          {
   \                     TIM_OC4_SetConfig: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   4824            uint32_t tmpccmrx = 0;
   4825            uint32_t tmpccer = 0;
   4826            uint32_t tmpcr2 = 0;
   4827          
   4828            /* Disable the Channel 4: Reset the CC4E Bit */
   4829            TIMx->CCER &= ~TIM_CCER_CC4E;
   \   00000002   0x6A02             LDR      R2,[R0, #+32]
   \   00000004   0xF422 0x5280      BIC      R2,R2,#0x1000
   \   00000008   0x6202             STR      R2,[R0, #+32]
   4830          
   4831            /* Get the TIMx CCER register value */
   4832            tmpccer = TIMx->CCER;
   \   0000000A   0x6A02             LDR      R2,[R0, #+32]
   4833            /* Get the TIMx CR2 register value */
   4834            tmpcr2 =  TIMx->CR2;
   \   0000000C   0x6843             LDR      R3,[R0, #+4]
   4835          
   4836            /* Get the TIMx CCMR2 register value */
   4837            tmpccmrx = TIMx->CCMR2;
   \   0000000E   0x69C4             LDR      R4,[R0, #+28]
   4838          
   4839            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   4840            tmpccmrx &= ~TIM_CCMR2_OC4M;
   4841            tmpccmrx &= ~TIM_CCMR2_CC4S;
   4842          
   4843            /* Select the Output Compare Mode */
   4844            tmpccmrx |= (OC_Config->OCMode << 8);
   \   00000010   0xF424 0x44E6      BIC      R4,R4,#0x7300
   \   00000014   0x680D             LDR      R5,[R1, #+0]
   \   00000016   0xEA44 0x2405      ORR      R4,R4,R5, LSL #+8
   4845          
   4846            /* Reset the Output Polarity level */
   4847            tmpccer &= ~TIM_CCER_CC4P;
   4848            /* Set the Output Compare Polarity */
   4849            tmpccer |= (OC_Config->OCPolarity << 12);
   \   0000001A   0xF422 0x5200      BIC      R2,R2,#0x2000
   \   0000001E   0x688D             LDR      R5,[R1, #+8]
   \   00000020   0xEA42 0x3205      ORR      R2,R2,R5, LSL #+12
   4850          
   4851            if(IS_TIM_BREAK_INSTANCE(TIMx))
   \   00000024   0x....             LDR.N    R5,??DataTable29_2  ;; 0x40012c00
   \   00000026   0x42A8             CMP      R0,R5
   \   00000028   0xD002             BEQ.N    ??TIM_OC4_SetConfig_0
   \   0000002A   0x....             LDR.N    R5,??DataTable29_3  ;; 0x40013400
   \   0000002C   0x42A8             CMP      R0,R5
   \   0000002E   0xD104             BNE.N    ??TIM_OC4_SetConfig_1
   4852            {
   4853              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   4854          
   4855             /* Reset the Output Compare IDLE State */
   4856              tmpcr2 &= ~TIM_CR2_OIS4;
   4857              /* Set the Output Idle state */
   4858              tmpcr2 |= (OC_Config->OCIdleState << 6);
   \                     ??TIM_OC4_SetConfig_0: (+1)
   \   00000030   0xF423 0x4380      BIC      R3,R3,#0x4000
   \   00000034   0x694D             LDR      R5,[R1, #+20]
   \   00000036   0xEA43 0x1385      ORR      R3,R3,R5, LSL #+6
   4859            }
   4860          
   4861            /* Write to TIMx CR2 */
   4862            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC4_SetConfig_1: (+1)
   \   0000003A   0x6043             STR      R3,[R0, #+4]
   4863          
   4864            /* Write to TIMx CCMR2 */
   4865            TIMx->CCMR2 = tmpccmrx;
   \   0000003C   0x61C4             STR      R4,[R0, #+28]
   4866          
   4867            /* Set the Capture Compare Register value */
   4868            TIMx->CCR4 = OC_Config->Pulse;
   \   0000003E   0x6849             LDR      R1,[R1, #+4]
   \   00000040   0x6401             STR      R1,[R0, #+64]
   4869          
   4870            /* Write to TIMx CCER */
   4871            TIMx->CCER = tmpccer;
   \   00000042   0x6202             STR      R2,[R0, #+32]
   4872          }
   \   00000044   0xBC30             POP      {R4,R5}
   \   00000046   0x4770             BX       LR               ;; return
   4873          
   4874          
   4875          /**
   4876            * @brief  Time Slave configuration
   4877            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4878            *                the configuration information for TIM module.
   4879            * @param  sSlaveConfig: The slave configuration structure
   4880            * @retval None
   4881            */

   \                                 In section .text, align 2, keep-with-next
   4882          static void TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
   4883                                        TIM_SlaveConfigTypeDef * sSlaveConfig)
   4884          {
   \                     TIM_SlaveTimer_SetConfig: (+1)
   \   00000000   0xB418             PUSH     {R3,R4}
   4885            uint32_t tmpsmcr = 0;
   4886            uint32_t tmpccmr1 = 0;
   4887            uint32_t tmpccer = 0;
   4888          
   4889            /* Get the TIMx SMCR register value */
   4890            tmpsmcr = htim->Instance->SMCR;
   \   00000002   0x6803             LDR      R3,[R0, #+0]
   \   00000004   0x689C             LDR      R4,[R3, #+8]
   4891          
   4892            /* Reset the Trigger Selection Bits */
   4893            tmpsmcr &= ~TIM_SMCR_TS;
   4894            /* Set the Input Trigger source */
   4895            tmpsmcr |= sSlaveConfig->InputTrigger;
   4896          
   4897            /* Reset the slave mode Bits */
   4898            tmpsmcr &= ~TIM_SMCR_SMS;
   4899            /* Set the slave mode */
   4900            tmpsmcr |= sSlaveConfig->SlaveMode;
   4901          
   4902            /* Write to TIMx SMCR */
   4903            htim->Instance->SMCR = tmpsmcr;
   \   00000006   0xF024 0x0470      BIC      R4,R4,#0x70
   \   0000000A   0x684A             LDR      R2,[R1, #+4]
   \   0000000C   0x4314             ORRS     R4,R2,R4
   \   0000000E   0x08E4             LSRS     R4,R4,#+3
   \   00000010   0x680A             LDR      R2,[R1, #+0]
   \   00000012   0xEA52 0x04C4      ORRS     R4,R2,R4, LSL #+3
   \   00000016   0x609C             STR      R4,[R3, #+8]
   4904          
   4905            /* Configure the trigger prescaler, filter, and polarity */
   4906            switch (sSlaveConfig->InputTrigger)
   \   00000018   0x684A             LDR      R2,[R1, #+4]
   \   0000001A   0x2A40             CMP      R2,#+64
   \   0000001C   0xD00C             BEQ.N    ??TIM_SlaveTimer_SetConfig_0
   \   0000001E   0x2A50             CMP      R2,#+80
   \   00000020   0xD01B             BEQ.N    ??TIM_SlaveTimer_SetConfig_1
   \   00000022   0x2A60             CMP      R2,#+96
   \   00000024   0xD01E             BEQ.N    ??TIM_SlaveTimer_SetConfig_2
   \   00000026   0x2A70             CMP      R2,#+112
   \   00000028   0xD121             BNE.N    ??TIM_SlaveTimer_SetConfig_3
   4907            {
   4908            case TIM_TS_ETRF:
   4909              {
   4910                /* Check the parameters */
   4911                assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
   4912                assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
   4913                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   4914                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   4915                /* Configure the ETR Trigger source */
   4916                TIM_ETR_SetConfig(htim->Instance,
   4917                                  sSlaveConfig->TriggerPrescaler,
   4918                                  sSlaveConfig->TriggerPolarity,
   4919                                  sSlaveConfig->TriggerFilter);
   \   0000002A   0x690B             LDR      R3,[R1, #+16]
   \   0000002C   0x688A             LDR      R2,[R1, #+8]
   \   0000002E   0x68C9             LDR      R1,[R1, #+12]
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0xB001             ADD      SP,SP,#+4
   \   00000034   0xBC10             POP      {R4}
   \   00000036   0x....             B.N      TIM_ETR_SetConfig
   4920              }
   4921              break;
   4922          
   4923            case TIM_TS_TI1F_ED:
   4924              {
   4925                /* Check the parameters */
   4926                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4927                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   4928          
   4929                /* Disable the Channel 1: Reset the CC1E Bit */
   4930                tmpccer = htim->Instance->CCER;
   \                     ??TIM_SlaveTimer_SetConfig_0: (+1)
   \   00000038   0x6802             LDR      R2,[R0, #+0]
   \   0000003A   0x6A13             LDR      R3,[R2, #+32]
   4931                htim->Instance->CCER &= ~TIM_CCER_CC1E;
   \   0000003C   0x6A14             LDR      R4,[R2, #+32]
   \   0000003E   0x0864             LSRS     R4,R4,#+1
   \   00000040   0x0064             LSLS     R4,R4,#+1
   \   00000042   0x6214             STR      R4,[R2, #+32]
   4932                tmpccmr1 = htim->Instance->CCMR1;
   \   00000044   0x6802             LDR      R2,[R0, #+0]
   \   00000046   0x6994             LDR      R4,[R2, #+24]
   4933          
   4934                /* Set the filter */
   4935                tmpccmr1 &= ~TIM_CCMR1_IC1F;
   4936                tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4);
   4937          
   4938                /* Write to TIMx CCMR1 and CCER registers */
   4939                htim->Instance->CCMR1 = tmpccmr1;
   \   00000048   0xF024 0x04F0      BIC      R4,R4,#0xF0
   \   0000004C   0x6909             LDR      R1,[R1, #+16]
   \   0000004E   0xEA44 0x1401      ORR      R4,R4,R1, LSL #+4
   \   00000052   0x6194             STR      R4,[R2, #+24]
   4940                htim->Instance->CCER = tmpccer;
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0x6203             STR      R3,[R0, #+32]
   4941          
   4942              }
   4943              break;
   \   00000058   0xE009             B.N      ??TIM_SlaveTimer_SetConfig_3
   4944          
   4945            case TIM_TS_TI1FP1:
   4946              {
   4947                /* Check the parameters */
   4948                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4949                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   4950                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   4951          
   4952                /* Configure TI1 Filter and Polarity */
   4953                TIM_TI1_ConfigInputStage(htim->Instance,
   4954                                         sSlaveConfig->TriggerPolarity,
   4955                                         sSlaveConfig->TriggerFilter);
   \                     ??TIM_SlaveTimer_SetConfig_1: (+1)
   \   0000005A   0x690A             LDR      R2,[R1, #+16]
   \   0000005C   0x6889             LDR      R1,[R1, #+8]
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0xBC18             POP      {R3,R4}
   \   00000062   0x....             B.N      TIM_TI1_ConfigInputStage
   4956              }
   4957              break;
   4958          
   4959            case TIM_TS_TI2FP2:
   4960              {
   4961                /* Check the parameters */
   4962                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4963                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   4964                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   4965          
   4966                /* Configure TI2 Filter and Polarity */
   4967                TIM_TI2_ConfigInputStage(htim->Instance,
   4968                                          sSlaveConfig->TriggerPolarity,
   4969                                          sSlaveConfig->TriggerFilter);
   \                     ??TIM_SlaveTimer_SetConfig_2: (+1)
   \   00000064   0x690A             LDR      R2,[R1, #+16]
   \   00000066   0x6889             LDR      R1,[R1, #+8]
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0xBC18             POP      {R3,R4}
   \   0000006C   0x....             B.N      TIM_TI2_ConfigInputStage
   4970              }
   4971              break;
   4972          
   4973            case TIM_TS_ITR0:
   4974              {
   4975                /* Check the parameter */
   4976                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4977              }
   4978              break;
   4979          
   4980            case TIM_TS_ITR1:
   4981              {
   4982                /* Check the parameter */
   4983                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4984              }
   4985              break;
   4986          
   4987            case TIM_TS_ITR2:
   4988              {
   4989                /* Check the parameter */
   4990                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4991              }
   4992              break;
   4993          
   4994            case TIM_TS_ITR3:
   4995              {
   4996                /* Check the parameter */
   4997                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4998              }
   4999              break;
   5000          
   5001            default:
   5002              break;
   5003            }
   5004          }
   \                     ??TIM_SlaveTimer_SetConfig_3: (+1)
   \   0000006E   0xBC11             POP      {R0,R4}
   \   00000070   0x4770             BX       LR               ;; return
   5005          
   5006          /**
   5007            * @brief  Configure the TI1 as Input.
   5008            * @param  TIMx  to select the TIM peripheral.
   5009            * @param  TIM_ICPolarity : The Input Polarity.
   5010            *          This parameter can be one of the following values:
   5011            *            @arg TIM_ICPOLARITY_RISING
   5012            *            @arg TIM_ICPOLARITY_FALLING
   5013            *            @arg TIM_ICPOLARITY_BOTHEDGE
   5014            * @param  TIM_ICSelection : specifies the input to be used.
   5015            *          This parameter can be one of the following values:
   5016            *            @arg TIM_ICSELECTION_DIRECTTI:    TIM Input 1 is selected to be connected to IC1.
   5017            *            @arg TIM_ICSELECTION_INDIRECTTI:  TIM Input 1 is selected to be connected to IC2.
   5018            *            @arg TIM_ICSELECTION_TRC:         TIM Input 1 is selected to be connected to TRC.
   5019            * @param  TIM_ICFilter : Specifies the Input Capture Filter.
   5020            *          This parameter must be a value between 0x00 and 0x0F.
   5021            * @retval None
   5022            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI2FP1 
   5023            *       (on channel2 path) is used as the input signal. Therefore CCMR1 must be 
   5024            *        protected against un-initialized filter and polarity values.
   5025            */

   \                                 In section .text, align 2, keep-with-next
   5026          void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   5027                                 uint32_t TIM_ICFilter)
   5028          {
   \                     TIM_TI1_SetConfig: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   5029            uint32_t tmpccmr1 = 0;
   5030            uint32_t tmpccer = 0;
   5031          
   5032            /* Disable the Channel 1: Reset the CC1E Bit */
   5033            TIMx->CCER &= ~TIM_CCER_CC1E;
   \   00000002   0x6A04             LDR      R4,[R0, #+32]
   \   00000004   0x0864             LSRS     R4,R4,#+1
   \   00000006   0x0064             LSLS     R4,R4,#+1
   \   00000008   0x6204             STR      R4,[R0, #+32]
   5034            tmpccmr1 = TIMx->CCMR1;
   \   0000000A   0x6984             LDR      R4,[R0, #+24]
   5035            tmpccer = TIMx->CCER;
   \   0000000C   0x6A05             LDR      R5,[R0, #+32]
   5036          
   5037            /* Select the Input */
   5038            if(IS_TIM_CC2_INSTANCE(TIMx) != RESET)
   \   0000000E   0x....             LDR.N    R6,??DataTable29_2  ;; 0x40012c00
   \   00000010   0x42B0             CMP      R0,R6
   \   00000012   0xD00E             BEQ.N    ??TIM_TI1_SetConfig_0
   \   00000014   0x....             LDR.N    R6,??DataTable29_3  ;; 0x40013400
   \   00000016   0x42B0             CMP      R0,R6
   \   00000018   0xD00B             BEQ.N    ??TIM_TI1_SetConfig_0
   \   0000001A   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \   0000001E   0xD008             BEQ.N    ??TIM_TI1_SetConfig_0
   \   00000020   0x....             LDR.N    R6,??DataTable29_4  ;; 0x40000400
   \   00000022   0x42B0             CMP      R0,R6
   \   00000024   0xD005             BEQ.N    ??TIM_TI1_SetConfig_0
   \   00000026   0x....             LDR.N    R6,??DataTable29_5  ;; 0x40000800
   \   00000028   0x42B0             CMP      R0,R6
   \   0000002A   0xD002             BEQ.N    ??TIM_TI1_SetConfig_0
   \   0000002C   0x....             LDR.N    R6,??DataTable29_6  ;; 0x40000c00
   \   0000002E   0x42B0             CMP      R0,R6
   \   00000030   0xD101             BNE.N    ??TIM_TI1_SetConfig_1
   \                     ??TIM_TI1_SetConfig_0: (+1)
   \   00000032   0x2601             MOVS     R6,#+1
   \   00000034   0xE000             B.N      ??TIM_TI1_SetConfig_2
   \                     ??TIM_TI1_SetConfig_1: (+1)
   \   00000036   0x2600             MOVS     R6,#+0
   \                     ??TIM_TI1_SetConfig_2: (+1)
   \   00000038   0x2E00             CMP      R6,#+0
   \   0000003A   0xD003             BEQ.N    ??TIM_TI1_SetConfig_3
   5039            {
   5040              tmpccmr1 &= ~TIM_CCMR1_CC1S;
   5041              tmpccmr1 |= TIM_ICSelection;
   \   0000003C   0x08A4             LSRS     R4,R4,#+2
   \   0000003E   0xEA52 0x0284      ORRS     R2,R2,R4, LSL #+2
   \   00000042   0xE002             B.N      ??TIM_TI1_SetConfig_4
   5042            }
   5043            else
   5044            {
   5045              tmpccmr1 |= TIM_CCMR1_CC1S_0;
   \                     ??TIM_TI1_SetConfig_3: (+1)
   \   00000044   0x4622             MOV      R2,R4
   \   00000046   0xF042 0x0201      ORR      R2,R2,#0x1
   5046            }
   5047          
   5048            /* Set the filter */
   5049            tmpccmr1 &= ~TIM_CCMR1_IC1F;
   5050            tmpccmr1 |= ((TIM_ICFilter << 4) & TIM_CCMR1_IC1F);
   5051          
   5052            /* Select the Polarity and set the CC1E Bit */
   5053            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   5054            tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
   5055          
   5056            /* Write to TIMx CCMR1 and CCER registers */
   5057            TIMx->CCMR1 = tmpccmr1;
   \                     ??TIM_TI1_SetConfig_4: (+1)
   \   0000004A   0xF022 0x02F0      BIC      R2,R2,#0xF0
   \   0000004E   0x011B             LSLS     R3,R3,#+4
   \   00000050   0xF003 0x03F0      AND      R3,R3,#0xF0
   \   00000054   0x431A             ORRS     R2,R3,R2
   \   00000056   0x6182             STR      R2,[R0, #+24]
   5058            TIMx->CCER = tmpccer;
   \   00000058   0xF025 0x050A      BIC      R5,R5,#0xA
   \   0000005C   0xF001 0x010A      AND      R1,R1,#0xA
   \   00000060   0x4329             ORRS     R1,R1,R5
   \   00000062   0x6201             STR      R1,[R0, #+32]
   5059          }
   \   00000064   0xBC70             POP      {R4-R6}
   \   00000066   0x4770             BX       LR               ;; return
   5060          
   5061          /**
   5062            * @brief  Configure the Polarity and Filter for TI1.
   5063            * @param  TIMx  to select the TIM peripheral.
   5064            * @param  TIM_ICPolarity : The Input Polarity.
   5065            *          This parameter can be one of the following values:
   5066            *            @arg TIM_ICPOLARITY_RISING   
   5067            *            @arg TIM_ICPOLARITY_FALLING  
   5068            *            @arg TIM_ICPOLARITY_BOTHEDGE 
   5069            * @param  TIM_ICFilter : Specifies the Input Capture Filter.
   5070            *          This parameter must be a value between 0x00 and 0x0F.
   5071            * @retval None
   5072            */

   \                                 In section .text, align 2, keep-with-next
   5073          static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
   5074          {
   \                     TIM_TI1_ConfigInputStage: (+1)
   \   00000000   0xB410             PUSH     {R4}
   5075            uint32_t tmpccmr1 = 0;
   5076            uint32_t tmpccer = 0;
   5077          
   5078            /* Disable the Channel 1: Reset the CC1E Bit */
   5079            tmpccer = TIMx->CCER;
   \   00000002   0x6A03             LDR      R3,[R0, #+32]
   5080            TIMx->CCER &= ~TIM_CCER_CC1E;
   \   00000004   0x6A04             LDR      R4,[R0, #+32]
   \   00000006   0x0864             LSRS     R4,R4,#+1
   \   00000008   0x0064             LSLS     R4,R4,#+1
   \   0000000A   0x6204             STR      R4,[R0, #+32]
   5081            tmpccmr1 = TIMx->CCMR1;
   \   0000000C   0x6984             LDR      R4,[R0, #+24]
   5082          
   5083            /* Set the filter */
   5084            tmpccmr1 &= ~TIM_CCMR1_IC1F;
   5085            tmpccmr1 |= (TIM_ICFilter << 4);
   5086          
   5087            /* Select the Polarity and set the CC1E Bit */
   5088            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   5089            tmpccer |= TIM_ICPolarity;
   5090          
   5091            /* Write to TIMx CCMR1 and CCER registers */
   5092            TIMx->CCMR1 = tmpccmr1;
   \   0000000E   0xF024 0x04F0      BIC      R4,R4,#0xF0
   \   00000012   0xEA44 0x1402      ORR      R4,R4,R2, LSL #+4
   \   00000016   0x6184             STR      R4,[R0, #+24]
   5093            TIMx->CCER = tmpccer;
   \   00000018   0xF023 0x030A      BIC      R3,R3,#0xA
   \   0000001C   0x4319             ORRS     R1,R1,R3
   \   0000001E   0x6201             STR      R1,[R0, #+32]
   5094          }
   \   00000020   0xBC10             POP      {R4}
   \   00000022   0x4770             BX       LR               ;; return
   5095          
   5096          /**
   5097            * @brief  Configure the TI2 as Input.
   5098            * @param  TIMx  to select the TIM peripheral
   5099            * @param  TIM_ICPolarity : The Input Polarity.
   5100            *          This parameter can be one of the following values:
   5101            *            @arg TIM_ICPOLARITY_RISING   
   5102            *            @arg TIM_ICPOLARITY_FALLING  
   5103            *            @arg TIM_ICPOLARITY_BOTHEDGE 
   5104            * @param  TIM_ICSelection : specifies the input to be used.
   5105            *          This parameter can be one of the following values:
   5106            *            @arg TIM_ICSELECTION_DIRECTTI:   TIM Input 2 is selected to be connected to IC2.
   5107            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 2 is selected to be connected to IC1.
   5108            *            @arg TIM_ICSELECTION_TRC:        TIM Input 2 is selected to be connected to TRC.
   5109            * @param  TIM_ICFilter : Specifies the Input Capture Filter.
   5110            *          This parameter must be a value between 0x00 and 0x0F.
   5111            * @retval None
   5112            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI1FP2 
   5113            *       (on channel1 path) is used as the input signal. Therefore CCMR1 must be 
   5114            *        protected against un-initialized filter and polarity values.
   5115            */

   \                                 In section .text, align 2, keep-with-next
   5116          static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   5117                                 uint32_t TIM_ICFilter)
   5118          {
   \                     TIM_TI2_SetConfig: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   5119            uint32_t tmpccmr1 = 0;
   5120            uint32_t tmpccer = 0;
   5121          
   5122            /* Disable the Channel 2: Reset the CC2E Bit */
   5123            TIMx->CCER &= ~TIM_CCER_CC2E;
   \   00000002   0x6A04             LDR      R4,[R0, #+32]
   \   00000004   0xF024 0x0410      BIC      R4,R4,#0x10
   \   00000008   0x6204             STR      R4,[R0, #+32]
   5124            tmpccmr1 = TIMx->CCMR1;
   \   0000000A   0x6984             LDR      R4,[R0, #+24]
   5125            tmpccer = TIMx->CCER;
   \   0000000C   0x6A05             LDR      R5,[R0, #+32]
   5126          
   5127            /* Select the Input */
   5128            tmpccmr1 &= ~TIM_CCMR1_CC2S;
   5129            tmpccmr1 |= (TIM_ICSelection << 8);
   5130          
   5131            /* Set the filter */
   5132            tmpccmr1 &= ~TIM_CCMR1_IC2F;
   5133            tmpccmr1 |= ((TIM_ICFilter << 12) & TIM_CCMR1_IC2F);
   5134          
   5135            /* Select the Polarity and set the CC2E Bit */
   5136            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   5137            tmpccer |= ((TIM_ICPolarity << 4) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
   5138          
   5139            /* Write to TIMx CCMR1 and CCER registers */
   5140            TIMx->CCMR1 = tmpccmr1 ;
   \   0000000E   0xF424 0x7440      BIC      R4,R4,#0x300
   \   00000012   0xEA44 0x2402      ORR      R4,R4,R2, LSL #+8
   \   00000016   0xF424 0x4470      BIC      R4,R4,#0xF000
   \   0000001A   0x031B             LSLS     R3,R3,#+12
   \   0000001C   0xF403 0x4370      AND      R3,R3,#0xF000
   \   00000020   0x4323             ORRS     R3,R3,R4
   \   00000022   0x6183             STR      R3,[R0, #+24]
   5141            TIMx->CCER = tmpccer;
   \   00000024   0xF025 0x05A0      BIC      R5,R5,#0xA0
   \   00000028   0x0109             LSLS     R1,R1,#+4
   \   0000002A   0xF001 0x01A0      AND      R1,R1,#0xA0
   \   0000002E   0x4329             ORRS     R1,R1,R5
   \   00000030   0x6201             STR      R1,[R0, #+32]
   5142          }
   \   00000032   0xBC30             POP      {R4,R5}
   \   00000034   0x4770             BX       LR               ;; return
   5143          
   5144          /**
   5145            * @brief  Configure the Polarity and Filter for TI2.
   5146            * @param  TIMx  to select the TIM peripheral.
   5147            * @param  TIM_ICPolarity : The Input Polarity.
   5148            *          This parameter can be one of the following values:
   5149            *            @arg TIM_ICPOLARITY_RISING  
   5150            *            @arg TIM_ICPOLARITY_FALLING 
   5151            *            @arg TIM_ICPOLARITY_BOTHEDGE
   5152            * @param  TIM_ICFilter : Specifies the Input Capture Filter.
   5153            *          This parameter must be a value between 0x00 and 0x0F.
   5154            * @retval None
   5155            */

   \                                 In section .text, align 2, keep-with-next
   5156          static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
   5157          {
   \                     TIM_TI2_ConfigInputStage: (+1)
   \   00000000   0xB410             PUSH     {R4}
   5158            uint32_t tmpccmr1 = 0;
   5159            uint32_t tmpccer = 0;
   5160          
   5161            /* Disable the Channel 2: Reset the CC2E Bit */
   5162            TIMx->CCER &= ~TIM_CCER_CC2E;
   \   00000002   0x6A03             LDR      R3,[R0, #+32]
   \   00000004   0xF023 0x0310      BIC      R3,R3,#0x10
   \   00000008   0x6203             STR      R3,[R0, #+32]
   5163            tmpccmr1 = TIMx->CCMR1;
   \   0000000A   0x6983             LDR      R3,[R0, #+24]
   5164            tmpccer = TIMx->CCER;
   \   0000000C   0x6A04             LDR      R4,[R0, #+32]
   5165          
   5166            /* Set the filter */
   5167            tmpccmr1 &= ~TIM_CCMR1_IC2F;
   5168            tmpccmr1 |= (TIM_ICFilter << 12);
   5169          
   5170            /* Select the Polarity and set the CC2E Bit */
   5171            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   5172            tmpccer |= (TIM_ICPolarity << 4);
   5173          
   5174            /* Write to TIMx CCMR1 and CCER registers */
   5175            TIMx->CCMR1 = tmpccmr1 ;
   \   0000000E   0xF423 0x4370      BIC      R3,R3,#0xF000
   \   00000012   0xEA43 0x3302      ORR      R3,R3,R2, LSL #+12
   \   00000016   0x6183             STR      R3,[R0, #+24]
   5176            TIMx->CCER = tmpccer;
   \   00000018   0xF024 0x04A0      BIC      R4,R4,#0xA0
   \   0000001C   0xEA44 0x1401      ORR      R4,R4,R1, LSL #+4
   \   00000020   0x6204             STR      R4,[R0, #+32]
   5177          }
   \   00000022   0xBC10             POP      {R4}
   \   00000024   0x4770             BX       LR               ;; return
   5178          
   5179          /**
   5180            * @brief  Configure the TI3 as Input.
   5181            * @param  TIMx  to select the TIM peripheral
   5182            * @param  TIM_ICPolarity : The Input Polarity.
   5183            *          This parameter can be one of the following values:
   5184            *            @arg TIM_ICPOLARITY_RISING  
   5185            *            @arg TIM_ICPOLARITY_FALLING 
   5186            *            @arg TIM_ICPOLARITY_BOTHEDGE
   5187            * @param  TIM_ICSelection : specifies the input to be used.
   5188            *          This parameter can be one of the following values:
   5189            *            @arg TIM_ICSELECTION_DIRECTTI:   TIM Input 3 is selected to be connected to IC3.
   5190            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 3 is selected to be connected to IC4.
   5191            *            @arg TIM_ICSELECTION_TRC:        TIM Input 3 is selected to be connected to TRC.
   5192            * @param  TIM_ICFilter : Specifies the Input Capture Filter.
   5193            *          This parameter must be a value between 0x00 and 0x0F.
   5194            * @retval None
   5195            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI3FP4 
   5196            *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be 
   5197            *        protected against un-initialized filter and polarity values.
   5198            */

   \                                 In section .text, align 2, keep-with-next
   5199          static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   5200                                 uint32_t TIM_ICFilter)
   5201          {
   \                     TIM_TI3_SetConfig: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   5202            uint32_t tmpccmr2 = 0;
   5203            uint32_t tmpccer = 0;
   5204          
   5205            /* Disable the Channel 3: Reset the CC3E Bit */
   5206            TIMx->CCER &= ~TIM_CCER_CC3E;
   \   00000002   0x6A04             LDR      R4,[R0, #+32]
   \   00000004   0xF424 0x7480      BIC      R4,R4,#0x100
   \   00000008   0x6204             STR      R4,[R0, #+32]
   5207            tmpccmr2 = TIMx->CCMR2;
   \   0000000A   0x69C4             LDR      R4,[R0, #+28]
   5208            tmpccer = TIMx->CCER;
   \   0000000C   0x6A05             LDR      R5,[R0, #+32]
   5209          
   5210            /* Select the Input */
   5211            tmpccmr2 &= ~TIM_CCMR2_CC3S;
   5212            tmpccmr2 |= TIM_ICSelection;
   5213          
   5214            /* Set the filter */
   5215            tmpccmr2 &= ~TIM_CCMR2_IC3F;
   5216            tmpccmr2 |= ((TIM_ICFilter << 4) & TIM_CCMR2_IC3F);
   5217          
   5218            /* Select the Polarity and set the CC3E Bit */
   5219            tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
   5220            tmpccer |= ((TIM_ICPolarity << 8) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
   5221          
   5222            /* Write to TIMx CCMR2 and CCER registers */
   5223            TIMx->CCMR2 = tmpccmr2;
   \   0000000E   0x08A4             LSRS     R4,R4,#+2
   \   00000010   0xEA52 0x0284      ORRS     R2,R2,R4, LSL #+2
   \   00000014   0xF022 0x02F0      BIC      R2,R2,#0xF0
   \   00000018   0x011B             LSLS     R3,R3,#+4
   \   0000001A   0xF003 0x03F0      AND      R3,R3,#0xF0
   \   0000001E   0x431A             ORRS     R2,R3,R2
   \   00000020   0x61C2             STR      R2,[R0, #+28]
   5224            TIMx->CCER = tmpccer;
   \   00000022   0xF425 0x6520      BIC      R5,R5,#0xA00
   \   00000026   0x0209             LSLS     R1,R1,#+8
   \   00000028   0xF401 0x6120      AND      R1,R1,#0xA00
   \   0000002C   0x4329             ORRS     R1,R1,R5
   \   0000002E   0x6201             STR      R1,[R0, #+32]
   5225          }
   \   00000030   0xBC30             POP      {R4,R5}
   \   00000032   0x4770             BX       LR               ;; return
   5226          
   5227          /**
   5228            * @brief  Configure the TI4 as Input.
   5229            * @param  TIMx to select the TIM peripheral
   5230            * @param  TIM_ICPolarity : The Input Polarity.
   5231            *          This parameter can be one of the following values:
   5232            *            @arg TIM_ICPOLARITY_RISING  
   5233            *            @arg TIM_ICPOLARITY_FALLING 
   5234            *            @arg TIM_ICPOLARITY_BOTHEDGE
   5235            * @param  TIM_ICSelection : specifies the input to be used.
   5236            *          This parameter can be one of the following values:
   5237            *            @arg TIM_ICSELECTION_DIRECTTI:   TIM Input 4 is selected to be connected to IC4.
   5238            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 4 is selected to be connected to IC3.
   5239            *            @arg TIM_ICSELECTION_TRC:        TIM Input 4 is selected to be connected to TRC.
   5240            * @param  TIM_ICFilter : Specifies the Input Capture Filter.
   5241            *          This parameter must be a value between 0x00 and 0x0F.
   5242            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI4FP3 
   5243            *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be 
   5244            *        protected against un-initialized filter and polarity values.
   5245            * @retval None
   5246            */

   \                                 In section .text, align 2, keep-with-next
   5247          static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   5248                                 uint32_t TIM_ICFilter)
   5249          {
   \                     TIM_TI4_SetConfig: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   5250            uint32_t tmpccmr2 = 0;
   5251            uint32_t tmpccer = 0;
   5252          
   5253            /* Disable the Channel 4: Reset the CC4E Bit */
   5254            TIMx->CCER &= ~TIM_CCER_CC4E;
   \   00000002   0x6A04             LDR      R4,[R0, #+32]
   \   00000004   0xF424 0x5480      BIC      R4,R4,#0x1000
   \   00000008   0x6204             STR      R4,[R0, #+32]
   5255            tmpccmr2 = TIMx->CCMR2;
   \   0000000A   0x69C4             LDR      R4,[R0, #+28]
   5256            tmpccer = TIMx->CCER;
   \   0000000C   0x6A05             LDR      R5,[R0, #+32]
   5257          
   5258            /* Select the Input */
   5259            tmpccmr2 &= ~TIM_CCMR2_CC4S;
   5260            tmpccmr2 |= (TIM_ICSelection << 8);
   5261          
   5262            /* Set the filter */
   5263            tmpccmr2 &= ~TIM_CCMR2_IC4F;
   5264            tmpccmr2 |= ((TIM_ICFilter << 12) & TIM_CCMR2_IC4F);
   5265          
   5266            /* Select the Polarity and set the CC4E Bit */
   5267            tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
   5268            tmpccer |= ((TIM_ICPolarity << 12) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
   5269          
   5270            /* Write to TIMx CCMR2 and CCER registers */
   5271            TIMx->CCMR2 = tmpccmr2;
   \   0000000E   0xF424 0x7440      BIC      R4,R4,#0x300
   \   00000012   0xEA44 0x2402      ORR      R4,R4,R2, LSL #+8
   \   00000016   0xF424 0x4470      BIC      R4,R4,#0xF000
   \   0000001A   0x031B             LSLS     R3,R3,#+12
   \   0000001C   0xF403 0x4370      AND      R3,R3,#0xF000
   \   00000020   0x4323             ORRS     R3,R3,R4
   \   00000022   0x61C3             STR      R3,[R0, #+28]
   5272            TIMx->CCER = tmpccer ;
   \   00000024   0xF425 0x4520      BIC      R5,R5,#0xA000
   \   00000028   0x0309             LSLS     R1,R1,#+12
   \   0000002A   0xF401 0x4120      AND      R1,R1,#0xA000
   \   0000002E   0x4329             ORRS     R1,R1,R5
   \   00000030   0x6201             STR      R1,[R0, #+32]
   5273          }
   \   00000032   0xBC30             POP      {R4,R5}
   \   00000034   0x4770             BX       LR               ;; return
   5274          
   5275          /**
   5276            * @brief  Selects the Input Trigger source
   5277            * @param  TIMx  to select the TIM peripheral
   5278            * @param  InputTriggerSource : The Input Trigger source.
   5279            *          This parameter can be one of the following values:
   5280            *            @arg TIM_TS_ITR0 : Internal Trigger 0
   5281            *            @arg TIM_TS_ITR1 : Internal Trigger 1
   5282            *            @arg TIM_TS_ITR2 : Internal Trigger 2
   5283            *            @arg TIM_TS_ITR3 : Internal Trigger 3
   5284            *            @arg TIM_TS_TI1F_ED : TI1 Edge Detector
   5285            *            @arg TIM_TS_TI1FP1 : Filtered Timer Input 1
   5286            *            @arg TIM_TS_TI2FP2 : Filtered Timer Input 2
   5287            *            @arg TIM_TS_ETRF : External Trigger input
   5288            * @retval None
   5289            */

   \                                 In section .text, align 2, keep-with-next
   5290          static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint16_t InputTriggerSource)
   5291          {
   5292            uint32_t tmpsmcr = 0;
   5293          
   5294             /* Get the TIMx SMCR register value */
   5295             tmpsmcr = TIMx->SMCR;
   \                     TIM_ITRx_SetConfig: (+1)
   \   00000000   0x6882             LDR      R2,[R0, #+8]
   5296             /* Reset the TS Bits */
   5297             tmpsmcr &= ~TIM_SMCR_TS;
   5298             /* Set the Input Trigger source and the slave mode*/
   5299             tmpsmcr |= InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1;
   5300             /* Write to TIMx SMCR */
   5301             TIMx->SMCR = tmpsmcr;
   \   00000002   0xF022 0x0270      BIC      R2,R2,#0x70
   \   00000006   0x4311             ORRS     R1,R1,R2
   \   00000008   0xF041 0x0107      ORR      R1,R1,#0x7
   \   0000000C   0x6081             STR      R1,[R0, #+8]
   5302          }
   \   0000000E   0x4770             BX       LR               ;; return
   5303          /**
   5304            * @brief  Configures the TIMx External Trigger (ETR).
   5305            * @param  TIMx  to select the TIM peripheral
   5306            * @param  TIM_ExtTRGPrescaler : The external Trigger Prescaler.
   5307            *          This parameter can be one of the following values:
   5308            *            @arg TIM_ETRPRESCALER_DIV1: ETRP Prescaler OFF.
   5309            *            @arg TIM_ETRPRESCALER_DIV2: ETRP frequency divided by 2.
   5310            *            @arg TIM_ETRPRESCALER_DIV4: ETRP frequency divided by 4.
   5311            *            @arg TIM_ETRPRESCALER_DIV8: ETRP frequency divided by 8.
   5312            * @param  TIM_ExtTRGPolarity : The external Trigger Polarity.
   5313            *          This parameter can be one of the following values:
   5314            *            @arg TIM_ETRPOLARITY_INVERTED: active low or falling edge active.
   5315            *            @arg TIM_ETRPOLARITY_NONINVERTED: active high or rising edge active.
   5316            * @param  ExtTRGFilter : External Trigger Filter.
   5317            *          This parameter must be a value between 0x00 and 0x0F
   5318            * @retval None
   5319            */

   \                                 In section .text, align 2, keep-with-next
   5320          static void TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler,
   5321                                 uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
   5322          {
   \                     TIM_ETR_SetConfig: (+1)
   \   00000000   0xB410             PUSH     {R4}
   5323            uint32_t tmpsmcr = 0;
   5324          
   5325            tmpsmcr = TIMx->SMCR;
   \   00000002   0x6884             LDR      R4,[R0, #+8]
   5326          
   5327            /* Reset the ETR Bits */
   5328            tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   5329          
   5330            /* Set the Prescaler, the Filter value and the Polarity */
   5331            tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8)));
   5332          
   5333            /* Write to TIMx SMCR */
   5334            TIMx->SMCR = tmpsmcr;
   \   00000004   0xF424 0x447F      BIC      R4,R4,#0xFF00
   \   00000008   0x4321             ORRS     R1,R1,R4
   \   0000000A   0x4311             ORRS     R1,R2,R1
   \   0000000C   0xEA41 0x2103      ORR      R1,R1,R3, LSL #+8
   \   00000010   0x6081             STR      R1,[R0, #+8]
   5335          }
   \   00000012   0xBC10             POP      {R4}
   \   00000014   0x4770             BX       LR               ;; return
   5336          
   5337          /**
   5338            * @brief  Enables or disables the TIM Capture Compare Channel x.
   5339            * @param  TIMx  to select the TIM peripheral
   5340            * @param  Channel : specifies the TIM Channel
   5341            *          This parameter can be one of the following values:
   5342            *            @arg TIM_CHANNEL_1: TIM Channel 1
   5343            *            @arg TIM_CHANNEL_2: TIM Channel 2
   5344            *            @arg TIM_CHANNEL_3: TIM Channel 3
   5345            *            @arg TIM_CHANNEL_4: TIM Channel 4
   5346            * @param  ChannelState : specifies the TIM Channel CCxE bit new state.
   5347            *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_Disable.
   5348            * @retval None
   5349            */

   \                                 In section .text, align 2, keep-with-next
   5350          void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)
   5351          {
   \                     TIM_CCxChannelCmd: (+1)
   \   00000000   0xB410             PUSH     {R4}
   5352            uint32_t tmp = 0;
   5353          
   5354            /* Check the parameters */
   5355            assert_param(IS_TIM_CC1_INSTANCE(TIMx));
   5356            assert_param(IS_TIM_CHANNELS(Channel));
   5357          
   5358            tmp = TIM_CCER_CC1E << Channel;
   5359          
   5360            /* Reset the CCxE Bit */
   5361            TIMx->CCER &= ~tmp;
   \   00000002   0x6A03             LDR      R3,[R0, #+32]
   \   00000004   0x2401             MOVS     R4,#+1
   \   00000006   0x408C             LSLS     R4,R4,R1
   \   00000008   0x43A3             BICS     R3,R3,R4
   \   0000000A   0x6203             STR      R3,[R0, #+32]
   5362          
   5363            /* Set or reset the CCxE Bit */
   5364            TIMx->CCER |=  (uint32_t)(ChannelState << Channel);
   \   0000000C   0x6A03             LDR      R3,[R0, #+32]
   \   0000000E   0xFA02 0xF101      LSL      R1,R2,R1
   \   00000012   0x4319             ORRS     R1,R1,R3
   \   00000014   0x6201             STR      R1,[R0, #+32]
   5365          }
   \   00000016   0xBC10             POP      {R4}
   \   00000018   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     TIM_DMAPeriodElapsedCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x........         DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x40012C00         DC32     0x40012c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x40013400         DC32     0x40013400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x........         DC32     TIM_DMADelayPulseCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0x........         DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x........         DC32     TIM_DMACaptureCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   0x40012C00         DC32     0x40012c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \   00000000   0x40013400         DC32     0x40013400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_2:
   \   00000000   0xFFFFFCFC         DC32     0xfffffcfc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_3:
   \   00000000   0xFFFF0303         DC32     0xffff0303

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   0x........         DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29:
   \   00000000   0x........         DC32     TIMEx_DMACommutationCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_1:
   \   00000000   0xFFFF0088         DC32     0xffff0088

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_2:
   \   00000000   0x40012C00         DC32     0x40012c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_3:
   \   00000000   0x40013400         DC32     0x40013400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_4:
   \   00000000   0x40000400         DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_5:
   \   00000000   0x40000800         DC32     0x40000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_6:
   \   00000000   0x40000C00         DC32     0x40000c00
   5366          
   5367          /**
   5368            * @}
   5369            */
   5370          
   5371          #endif /* HAL_TIM_MODULE_ENABLED */
   5372          /**
   5373            * @}
   5374            */
   5375          
   5376          /**
   5377            * @}
   5378            */
   5379          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HAL_TIM_Base_DeInit
         8   -> HAL_TIM_Base_MspDeInit
       0   HAL_TIM_Base_GetState
      16   HAL_TIM_Base_Init
        16   -> HAL_TIM_Base_MspInit
        16   -> TIM_Base_SetConfig
       0   HAL_TIM_Base_MspDeInit
       0   HAL_TIM_Base_MspInit
       0   HAL_TIM_Base_Start
       8   HAL_TIM_Base_Start_DMA
         8   -> HAL_DMA_Start_IT
       0   HAL_TIM_Base_Start_IT
       0   HAL_TIM_Base_Stop
       0   HAL_TIM_Base_Stop_DMA
       4   HAL_TIM_Base_Stop_IT
       8   HAL_TIM_ConfigClockSource
         8   -> TIM_ETR_SetConfig
         8   -> TIM_ITRx_SetConfig
         8   -> TIM_TI1_ConfigInputStage
         8   -> TIM_TI2_ConfigInputStage
      16   HAL_TIM_ConfigOCrefClear
        16   -> TIM_ETR_SetConfig
       0   HAL_TIM_ConfigTI1Input
      24   HAL_TIM_DMABurst_ReadStart
        24   -> HAL_DMA_Start_IT
      16   HAL_TIM_DMABurst_ReadStop
        16   -> HAL_DMA_Abort
      24   HAL_TIM_DMABurst_WriteStart
        24   -> HAL_DMA_Start_IT
      16   HAL_TIM_DMABurst_WriteStop
        16   -> HAL_DMA_Abort
       8   HAL_TIM_Encoder_DeInit
         8   -> HAL_TIM_Encoder_MspDeInit
       0   HAL_TIM_Encoder_GetState
      24   HAL_TIM_Encoder_Init
        24   -> HAL_TIM_Encoder_MspInit
        24   -> TIM_Base_SetConfig
       0   HAL_TIM_Encoder_MspDeInit
       0   HAL_TIM_Encoder_MspInit
       8   HAL_TIM_Encoder_Start
         8   -> TIM_CCxChannelCmd
      24   HAL_TIM_Encoder_Start_DMA
        24   -> HAL_DMA_Start_IT
        24   -> TIM_CCxChannelCmd
       8   HAL_TIM_Encoder_Start_IT
         8   -> TIM_CCxChannelCmd
      16   HAL_TIM_Encoder_Stop
        16   -> TIM_CCxChannelCmd
       8   HAL_TIM_Encoder_Stop_DMA
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_Encoder_Stop_IT
         8   -> TIM_CCxChannelCmd
       0   HAL_TIM_ErrorCallback
       0   HAL_TIM_GenerateEvent
       0   HAL_TIM_IC_CaptureCallback
      16   HAL_TIM_IC_ConfigChannel
        16   -> TIM_TI1_SetConfig
        16   -> TIM_TI2_SetConfig
        16   -> TIM_TI3_SetConfig
        16   -> TIM_TI4_SetConfig
       8   HAL_TIM_IC_DeInit
         8   -> HAL_TIM_IC_MspDeInit
       0   HAL_TIM_IC_GetState
      16   HAL_TIM_IC_Init
        16   -> HAL_TIM_IC_MspInit
        16   -> TIM_Base_SetConfig
       0   HAL_TIM_IC_MspDeInit
       0   HAL_TIM_IC_MspInit
       8   HAL_TIM_IC_Start
         8   -> TIM_CCxChannelCmd
      16   HAL_TIM_IC_Start_DMA
        16   -> HAL_DMA_Start_IT
        16   -> TIM_CCxChannelCmd
       8   HAL_TIM_IC_Start_IT
         8   -> TIM_CCxChannelCmd
      16   HAL_TIM_IC_Stop
        16   -> TIM_CCxChannelCmd
       8   HAL_TIM_IC_Stop_DMA
         8   -> TIM_CCxChannelCmd
      16   HAL_TIM_IC_Stop_IT
        16   -> TIM_CCxChannelCmd
       8   HAL_TIM_IRQHandler
         8   -> HAL_TIMEx_BreakCallback
         0   -> HAL_TIMEx_CommutationCallback
         8   -> HAL_TIM_IC_CaptureCallback
         8   -> HAL_TIM_OC_DelayElapsedCallback
         8   -> HAL_TIM_PWM_PulseFinishedCallback
         8   -> HAL_TIM_PeriodElapsedCallback
         8   -> HAL_TIM_TriggerCallback
       8   HAL_TIM_OC_ConfigChannel
         8   -> TIM_OC1_SetConfig
         8   -> TIM_OC2_SetConfig
         8   -> TIM_OC3_SetConfig
         8   -> TIM_OC4_SetConfig
       8   HAL_TIM_OC_DeInit
         8   -> HAL_TIM_OC_MspDeInit
       0   HAL_TIM_OC_DelayElapsedCallback
       0   HAL_TIM_OC_GetState
      16   HAL_TIM_OC_Init
        16   -> HAL_TIM_OC_MspInit
        16   -> TIM_Base_SetConfig
       0   HAL_TIM_OC_MspDeInit
       0   HAL_TIM_OC_MspInit
       8   HAL_TIM_OC_Start
         8   -> TIM_CCxChannelCmd
      16   HAL_TIM_OC_Start_DMA
        16   -> HAL_DMA_Start_IT
        16   -> TIM_CCxChannelCmd
       8   HAL_TIM_OC_Start_IT
         8   -> TIM_CCxChannelCmd
      16   HAL_TIM_OC_Stop
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_OC_Stop_DMA
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_OC_Stop_IT
        16   -> TIM_CCxChannelCmd
      48   HAL_TIM_OnePulse_ConfigChannel
        48   -> TIM_OC1_SetConfig
        48   -> TIM_OC2_SetConfig
        48   -> TIM_TI1_SetConfig
        48   -> TIM_TI2_SetConfig
       8   HAL_TIM_OnePulse_DeInit
         8   -> HAL_TIM_OnePulse_MspDeInit
       0   HAL_TIM_OnePulse_GetState
      16   HAL_TIM_OnePulse_Init
        16   -> HAL_TIM_OnePulse_MspInit
        16   -> TIM_Base_SetConfig
       0   HAL_TIM_OnePulse_MspDeInit
       0   HAL_TIM_OnePulse_MspInit
      16   HAL_TIM_OnePulse_Start
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_OnePulse_Start_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_OnePulse_Stop
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_OnePulse_Stop_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_ConfigChannel
        16   -> TIM_OC1_SetConfig
        16   -> TIM_OC2_SetConfig
        16   -> TIM_OC3_SetConfig
        16   -> TIM_OC4_SetConfig
       8   HAL_TIM_PWM_DeInit
         8   -> HAL_TIM_PWM_MspDeInit
       0   HAL_TIM_PWM_GetState
      16   HAL_TIM_PWM_Init
        16   -> HAL_TIM_PWM_MspInit
        16   -> TIM_Base_SetConfig
       0   HAL_TIM_PWM_MspDeInit
       0   HAL_TIM_PWM_MspInit
       0   HAL_TIM_PWM_PulseFinishedCallback
       8   HAL_TIM_PWM_Start
         8   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_Start_DMA
        16   -> HAL_DMA_Start_IT
        16   -> TIM_CCxChannelCmd
       8   HAL_TIM_PWM_Start_IT
         8   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_Stop
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_Stop_DMA
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_Stop_IT
        16   -> TIM_CCxChannelCmd
       0   HAL_TIM_PeriodElapsedCallback
       0   HAL_TIM_ReadCapturedValue
       8   HAL_TIM_SlaveConfigSynchronization
         8   -> TIM_SlaveTimer_SetConfig
       8   HAL_TIM_SlaveConfigSynchronization_IT
         8   -> TIM_SlaveTimer_SetConfig
       0   HAL_TIM_TriggerCallback
       8   TIM_Base_SetConfig
       4   TIM_CCxChannelCmd
       8   TIM_DMACaptureCplt
         8   -> HAL_TIM_IC_CaptureCallback
       8   TIM_DMADelayPulseCplt
         8   -> HAL_TIM_PWM_PulseFinishedCallback
       0   TIM_DMAError
         0   -> HAL_TIM_ErrorCallback
       0   TIM_DMAPeriodElapsedCplt
         0   -> HAL_TIM_PeriodElapsedCallback
       0   TIM_DMATriggerCplt
         0   -> HAL_TIM_TriggerCallback
       4   TIM_ETR_SetConfig
       0   TIM_ITRx_SetConfig
      16   TIM_OC1_SetConfig
      16   TIM_OC2_SetConfig
      16   TIM_OC3_SetConfig
       8   TIM_OC4_SetConfig
       8   TIM_SlaveTimer_SetConfig
         0   -> TIM_ETR_SetConfig
         0   -> TIM_TI1_ConfigInputStage
         0   -> TIM_TI2_ConfigInputStage
       4   TIM_TI1_ConfigInputStage
      12   TIM_TI1_SetConfig
       4   TIM_TI2_ConfigInputStage
       8   TIM_TI2_SetConfig
       8   TIM_TI3_SetConfig
       8   TIM_TI4_SetConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable15
       4  ??DataTable16
       4  ??DataTable17
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable21
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_2
       4  ??DataTable22_3
       4  ??DataTable23
       4  ??DataTable29
       4  ??DataTable29_1
       4  ??DataTable29_2
       4  ??DataTable29_3
       4  ??DataTable29_4
       4  ??DataTable29_5
       4  ??DataTable29_6
      54  HAL_TIM_Base_DeInit
       6  HAL_TIM_Base_GetState
      52  HAL_TIM_Base_Init
       2  HAL_TIM_Base_MspDeInit
       2  HAL_TIM_Base_MspInit
      26  HAL_TIM_Base_Start
      96  HAL_TIM_Base_Start_DMA
      24  HAL_TIM_Base_Start_IT
      46  HAL_TIM_Base_Stop
      50  HAL_TIM_Base_Stop_DMA
      48  HAL_TIM_Base_Stop_IT
     238  HAL_TIM_ConfigClockSource
     186  HAL_TIM_ConfigOCrefClear
      16  HAL_TIM_ConfigTI1Input
     370  HAL_TIM_DMABurst_ReadStart
     120  HAL_TIM_DMABurst_ReadStop
     370  HAL_TIM_DMABurst_WriteStart
     120  HAL_TIM_DMABurst_WriteStop
      54  HAL_TIM_Encoder_DeInit
       6  HAL_TIM_Encoder_GetState
     146  HAL_TIM_Encoder_Init
       2  HAL_TIM_Encoder_MspDeInit
       2  HAL_TIM_Encoder_MspInit
      72  HAL_TIM_Encoder_Start
     306  HAL_TIM_Encoder_Start_DMA
     112  HAL_TIM_Encoder_Start_IT
      92  HAL_TIM_Encoder_Stop
     132  HAL_TIM_Encoder_Stop_DMA
     132  HAL_TIM_Encoder_Stop_IT
       2  HAL_TIM_ErrorCallback
      20  HAL_TIM_GenerateEvent
       2  HAL_TIM_IC_CaptureCallback
     150  HAL_TIM_IC_ConfigChannel
      54  HAL_TIM_IC_DeInit
       6  HAL_TIM_IC_GetState
      52  HAL_TIM_IC_Init
       2  HAL_TIM_IC_MspDeInit
       2  HAL_TIM_IC_MspInit
      26  HAL_TIM_IC_Start
     244  HAL_TIM_IC_Start_DMA
      90  HAL_TIM_IC_Start_IT
      46  HAL_TIM_IC_Stop
     116  HAL_TIM_IC_Stop_DMA
     110  HAL_TIM_IC_Stop_IT
     338  HAL_TIM_IRQHandler
      68  HAL_TIM_OC_ConfigChannel
      54  HAL_TIM_OC_DeInit
       2  HAL_TIM_OC_DelayElapsedCallback
       6  HAL_TIM_OC_GetState
      52  HAL_TIM_OC_Init
       2  HAL_TIM_OC_MspDeInit
       2  HAL_TIM_OC_MspInit
      62  HAL_TIM_OC_Start
     282  HAL_TIM_OC_Start_DMA
     126  HAL_TIM_OC_Start_IT
      98  HAL_TIM_OC_Stop
     168  HAL_TIM_OC_Stop_DMA
     162  HAL_TIM_OC_Stop_IT
     224  HAL_TIM_OnePulse_ConfigChannel
      54  HAL_TIM_OnePulse_DeInit
       6  HAL_TIM_OnePulse_GetState
      74  HAL_TIM_OnePulse_Init
       2  HAL_TIM_OnePulse_MspDeInit
       2  HAL_TIM_OnePulse_MspInit
      60  HAL_TIM_OnePulse_Start
      82  HAL_TIM_OnePulse_Start_IT
     106  HAL_TIM_OnePulse_Stop
     130  HAL_TIM_OnePulse_Stop_IT
     194  HAL_TIM_PWM_ConfigChannel
      54  HAL_TIM_PWM_DeInit
       6  HAL_TIM_PWM_GetState
      52  HAL_TIM_PWM_Init
       2  HAL_TIM_PWM_MspDeInit
       2  HAL_TIM_PWM_MspInit
       2  HAL_TIM_PWM_PulseFinishedCallback
      62  HAL_TIM_PWM_Start
     282  HAL_TIM_PWM_Start_DMA
     126  HAL_TIM_PWM_Start_IT
     104  HAL_TIM_PWM_Stop
     168  HAL_TIM_PWM_Stop_DMA
     162  HAL_TIM_PWM_Stop_IT
       2  HAL_TIM_PeriodElapsedCallback
      46  HAL_TIM_ReadCapturedValue
      46  HAL_TIM_SlaveConfigSynchronization
      46  HAL_TIM_SlaveConfigSynchronization_IT
       2  HAL_TIM_TriggerCallback
     122  TIM_Base_SetConfig
      26  TIM_CCxChannelCmd
      68  TIM_DMACaptureCplt
      68  TIM_DMADelayPulseCplt
      12  TIM_DMAError
      12  TIM_DMAPeriodElapsedCplt
      12  TIM_DMATriggerCplt
      22  TIM_ETR_SetConfig
      16  TIM_ITRx_SetConfig
      92  TIM_OC1_SetConfig
     100  TIM_OC2_SetConfig
      98  TIM_OC3_SetConfig
      72  TIM_OC4_SetConfig
     114  TIM_SlaveTimer_SetConfig
      36  TIM_TI1_ConfigInputStage
     104  TIM_TI1_SetConfig
      38  TIM_TI2_ConfigInputStage
      54  TIM_TI2_SetConfig
      52  TIM_TI3_SetConfig
      54  TIM_TI4_SetConfig

 
 8 572 bytes in section .text
 
 8 536 bytes of CODE memory (+ 36 bytes shared)

Errors: none
Warnings: none
